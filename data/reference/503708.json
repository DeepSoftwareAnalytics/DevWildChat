[
    {
        "link": "https://doksi.net/en/get.php?lid=1065",
        "document": "Developer’s Guide Borland® C++Builder 5 ™ for Windows 2000 / 98 / 95 / NT Inprise Corporation 100 Enterprise Way, Scotts Valley, CA 95066-3249 Refer to the file DEPLOY.TXT located in the root directory of your C++Builder product for a complete list of files that you can distribute in accordance with the C++Builder License Statement and Limited Warranty. Inprise may have patents and/or pending patent applications covering subject matter in this document. The furnishing of this document does not give you any license to these patents. COPYRIGHT 1983, 2000 Inprise Corporation. All rights reserved All Inprise and Borland brands and product names are trademarks or registered trademarks of Inprise Corporation. Other product names are trademarks or registered trademarks of their respective holders. Printed in the U.SA CPE1350WW21001 3E2R0100 0001020304-9 8 7 6 5 4 3 2 1 PDF Contents Chapter 1 Introduction VCL standard components . Text controls . \n\n\n\nSpecialized input controls. Buttons and similar controls . Button controls . Bitmap buttons . Speed buttons . Check boxes . Radio buttons . Toolbars . Cool bars . Handling lists . List boxes and check-list boxes . Combo boxes . Tree views. List views . Date-time pickers and month calendars . Grouping components . Group boxes and radio groups . Panels . Scroll boxes . Tab controls. Page controls . Header controls . Visual feedback . Labels and static-text components . Status bars . Progress bars . Help and hint properties . Grids . Draw grids . String grids . Graphics display . Images. Shapes. Bevels . Paint boxes . \n\n\n\n Animation control . Windows common dialog boxes . Using windows common dialog boxes. Using helper objects . Working with lists . 1-1 What’s in this manual? . 1-1 Manual conventions . 1-2 Contacting developer support . 1-3 Part I Programming with C++Builder Chapter 2 Programming with C++Builder The integrated development environment Designing applications . Understanding the VCL. Properties . Methods . Events . User events . System events . Objects, components, and controls in the VCL . The TObject branch. The TPersistent branch . The TComponent branch . The TControl branch . The TWinControl branch . Properties common to TControl . Action properties . Position, size, and alignment properties . Display properties\n\n\n\n. Parent properties . A navigation property . Drag-and-drop properties . Drag-and-dock properties . Standard events common to TControl . Properties common to TWinControl . General information properties . Border style display properties . Navigation properties . Drag-and-dock properties . Events common to TWinControl . Creating the application user interface Using components . 2-1 . . . . . . . . . . . . . . . . . . . . . . . . 2-1 2-2 2-2 2-2 2-2 2-3 2-3 2-3 . . . . . . . . . . . . . . . . . . . . . . . . 2-3 2-4 2-5 2-5 2-6 2-7 2-7 2-8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-8 . 2-8 . 2-9 . 2-9 . 2-9 . 2-9 . 2-10 . 2-10 . 2-11 . 2-11 . 2-11 . 2-12 . 2-12 . 2-12 . 2-13 i . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-14 2-15 2-16 2-17 2-17 2-18 2-18 2-18 2-18 2-18 2-19 2-19 2-19 2-20 2-20 2-21 . . . . . . . . . . . . . . . . . .\n\n\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21 2-21 2-21 2-22 2-22 2-22 2-22 2-22 2-22 2-23 2-23 2-23 2-23 2-24 2-24 2-24 2-24 2-25 2-25 2-25 2-25 2-25 2-26 . 2-26 . 2-26 . 2-27 Working with string lists . Loading and saving string lists . Creating a new string list . Manipulating strings in a list . Associating objects with a string list Windows registry and INI files . Using TINIFile . Using TRegistry . Using TRegINIFile . Using TCanvas . Using TPrinter. Using streams . Developing applications . Editing code. Debugging applications . Deploying applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27 . 2-27 . 2-28 . 2-29 . 2-31 . 2-31 . 2-32 . 2-33 . 2-33 . 2-34 . 2-34 . 2-35 . 2-35 . 2-35 . 2-35 . 2-36 Distributing database applications . Using data\n\n\n\nmodules and remote data modules . Creating and editing data modules . Creating business rules in a data module . Accessing a data module from a form . Adding a remote data module to an application server project . Using the Object Repository . Sharing items within a project . Adding items to the Object Repository . Sharing objects in a team environment . Using an Object Repository item in a project . Copying an item . Inheriting an item . Using an item. Using project templates. Modifying shared items . Specifying a default project, new form, and main form . Chapter 3 Building applications, components, and libraries 3-1 Creating applications . Windows applications . User interface models . Setting IDE, project, and compilation options . Programming templates . Console applications . \n\n\n\n Using the VCL in console applications . Service applications . Service threads . Service name properties . Debugging services . Creating packages and DLLs . When to use packages and DLLs . Using DLLs in C++Builder . Creating DLLs in C++Builder . Creating DLLs containing VCL components . Linking DLLs . Writing database applications . Building distributed applications . Distributing applications using TCP/IP . Using sockets in applications . Creating Web server applications . Distributing applications using COM and DCOM . COM and DCOM . MTS and COM+ . Distributing applications using CORBA. . 3-1 . 3-1 . 3-2 . 3-17 . 3-17 . 3-18 . 3-18 . 3-19 . . . . . . . . . . 3-19 3-19 3-19 3-20 3-20 . . . . . . . . . . . . 3-20 3-20 3-21 3-21 3-21 3-21 . 3-22 Chapter 4 Developing the application user interface \n\n\n\n. 3-2 . 3-3 . 3-3 . 3-3 . 3-4 . 3-6 . 3-8 . 3-8 . 3-9 . 3-9 . 3-10 . 3-10 Understanding TApplication, TScreen, and TForm . Using the main form . Adding additional forms . Linking forms . Hiding the main form. Working at the application level . Handling the screen . Managing layout . Working with messages . More details on forms . Controlling when forms reside in memory. Displaying an auto-created form. Creating forms dynamically . Creating modeless forms such as windows . Using a local variable to create a form instance . Passing additional arguments to forms . Retrieving data from forms. Retrieving data from modeless forms . Retrieving data from modal forms. . 3-11 . 3-14 . 3-14 . 3-15 . 3-15 . 3-15 . 3-16 . 3-16 . 3-16 . 3-17 . 3-17 ii 4-1 . 4-1 . 4-1 . 4-2 . 4-2 . 4-2 . 4-3 . 4-3 . 4-3 . 4-4 . 4-5 .\n\n\n\n4-5 . 4-5 . 4-5 . 4-6 . 4-7 . 4-7 . 4-8 . 4-8 4-10 Reusing components and groups of components . Creating and using component templates . Working with frames . Creating frames. Adding frames to the Component palette . Using and modifying frames . Sharing frames . Creating and managing menus. Opening the Menu Designer . Building menus . Naming menus . Naming the menu items . Adding, inserting, and deleting menu items . Creating submenus . Adding images to menu items . Viewing the menu . Editing menu items in the Object Inspector . Using the Menu Designer context menu. Commands on the context menu . Switching between menus at design time . Using menu templates . Saving a menu as a template . Naming conventions for template menu items and event handlers . Manipulating menu\n\n\n\nitems at runtime . Merging menus . Specifying the active menu: Menu property . Determining the order of merged menu items: GroupIndex property . Importing resource files . Designing toolbars and cool bars . Adding a toolbar using a panel component. Adding a speed button to a panel. Assigning a speed button’s glyph. Setting the initial condition of a speed button . Creating a group of speed buttons . Allowing toggle buttons . Adding a toolbar using the toolbar component. Adding a tool button . Assigning images to tool buttons . . . . . . 4-12 . 4-12 . 4-13 . 4-13 . . . . . . . . . 4-14 . 4-14 . 4-15 . 4-15 . 4-16 . 4-17 . 4-18 . 4-18 . . . . . 4-19 . 4-20 . 4-22 . 4-22 Setting tool button appearance and initial conditions . Creating groups of tool buttons . Allowing toggled tool buttons . Adding a cool bar component . Setting the appearance of the cool\n\n\n\nbar . Responding to clicks . Assigning a menu to a tool button . Adding hidden toolbars . Hiding and showing toolbars . Using action lists . Action objects . Using Actions . Centralizing code . Linking properties . Executing actions . Updating actions. Pre-defined action classes . Standard edit actions . Standard Window actions. Standard Help actions. DataSet actions . Writing action components. How actions find their targets . Registering actions. Writing action list editors . . 4-22 . 4-23 . 4-23 . 4-24 . 4-24 . 4-25 . . . . . . . . . . . . 4-33 4-33 4-33 4-34 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-34 4-34 4-35 4-35 4-35 4-36 4-36 4-37 4-38 4-38 4-38 4-40 4-41 4-41 4-41 4-42 4-42 4-43 4-43 4-44 4-45 Implementing\n\n\n\ndrag-and-drop in controls . Starting a drag operation . Accepting dragged items . Dropping items . Ending a drag operation . Customizing drag and drop with a drag object . Changing the drag mouse pointer. Implementing drag-and-dock in controls . Making a windowed control a docking site. Making a control a dockable child. Controlling how child controls are docked . Controlling how child controls are undocked . Controlling how child controls respond to drag-and-dock operations . . . . . . . . . . . . 5-1 . 5-1 . 5-2 . 5-2 . 5-3 Chapter 5 . 4-26 . 4-27 . 4-27 Working with controls . 4-27 . 4-27 . 4-28 . 4-28 . 4-29 . 4-30 . 4-30 . 4-30 . 4-31 . 4-31 . 4-31 . 4-32 . 4-32 iii 5-1 . 5-3 . 5-4 . 5-4 . 5-4 . 5-4 . 5-5 . 5-6 . 5-6 Working with text in controls. Setting text alignment . Adding scroll bars at runtime . \n\n\n\n Adding the Clipboard object . Selecting text . Selecting all text . Cutting, copying, and pasting text . Deleting selected text . Disabling menu items . Providing a pop-up menu . Handling the OnPopup event. Adding graphics to controls . Indicating that a control is owner-drawn Adding graphical objects to a string list . Adding images to an application . Adding images to a string list . Drawing owner-drawn items . Sizing owner-draw items . Drawing each owner-draw item . . . . . . . . . . . . . . . . . . . . . 5-6 . 5-6 . 5-7 . 5-7 . 5-8 . 5-8 . 5-8 . 5-9 . 5-9 . 5-10 . 5-10 . 5-11 . 5-11 . 5-12 . 5-12 . 5-12 . 5-13 . 5-14 . 5-14 Saving a picture to a file. Replacing the picture . Using the Clipboard with graphics . Copying graphics to the Clipboard . Cutting graphics to the Clipboard . Pasting graphics from the Clipboard Rubber banding example . \n\n\n\nResponding to the mouse . Adding a field to a form object to track mouse actions . Refining line drawing . Working with multimedia . Adding silent video clips to an application . Example of adding silent video clips . Adding audio and/or video clips to an application . Example of adding audio and/or video clips . Chapter 6 . . . . . . . . 6-19 6-19 6-20 6-21 6-21 6-21 6-22 6-22 . 6-25 . 6-26 . 6-28 . 6-28 . 6-29 . 6-30 . 6-32 Chapter 7 Working with graphics and multimedia Overview of graphics programming. Refreshing the screen . Types of graphic objects . Common properties and methods of Canvas . Using the properties of the Canvas object . Using pens. Using brushes . Reading and setting pixels . Using Canvas methods to draw graphic objects . Drawing lines and polylines. \n\n\n\nDrawing shapes . Handling multiple drawing objects in your application . Keeping track of which drawing tool to use . Changing the tool with speed buttons Using drawing tools . Drawing on a graphic . Making scrollable graphics . Adding an image control . Loading and saving graphics files . Loading a picture from a file . . . . . . . . . Writing multi-threaded applications 7-1 6-1 Defining thread objects. Initializing the thread . Assigning a default priority . Indicating when threads are freed . Writing the thread function . Using the main VCL thread. Using thread-local variables . Checking for termination by other threads . Writing clean-up code. Coordinating threads . Avoiding simultaneous access . Locking objects. Using critical sections . Using the multi-read exclusive-write synchronizer\n\n\n\n. Other techniques for sharing memory. Waiting for other threads . Waiting for a thread to finish executing . Waiting for a task to be completed. Executing thread objects . Overriding the default priority . Starting and stopping threads . Debugging multi-threaded applications . . 6-1 . 6-2 . 6-2 . 6-3 . . . . . . . . 6-4 6-5 6-7 6-9 . 6-9 . 6-9 . 6-10 . 6-11 . . . . . . . . . 6-12 . 6-12 . 6-13 . 6-16 . 6-16 . 6-16 . 6-18 . 6-18 iv . . . . . . . . 7-1 . 7-2 . 7-2 . 7-3 . 7-3 . 7-4 . 7-5 . . . . . . . 7-5 . 7-6 . 7-6 . 7-6 . 7-6 . 7-7 . 7-7 . 7-8 . 7-8 . . . . . . . 7-8 . 7-9 7-10 7-10 7-11 7-11 Chapter 8 Exception handling C++ exception handling. ANSI requirements for exception handling . Exception handling syntax . Exception declarations . Throwing an exception . Examples. Handling an exception. Exception\n\n\n\nspecifications . Constructors and destructors in exception handling . Unhandled exceptions . Setting exception handling options . Structured exceptions under Win32 . Syntax of structured exceptions. Handling structured exceptions . Exception filters . Mixing C++ with structured exceptions . C-based exceptions in C++ program example . Defining exceptions . Raising exceptions . Termination blocks . VCL exception handling . Differences between C++ and VCL exception handling . Handling operating system exceptions . Handling VCL exceptions . VCL exception classes . Portability considerations . Calling virtual methods in base class constructors . Object Pascal model . C++ model . C++Builder model . Example: calling virtual methods . Constructor initialization of data members for virtual\n\n\n\nfunctions . Object destruction . Exceptions thrown from constructors . Virtual methods called from destructors . AfterConstruction and BeforeDestruction . Class virtual functions . Support for Object Pascal data types and language concepts. Typedefs . Classes that support the Object Pascal language . C++ language counterparts to the Object Pascal language . Var parameters . Untyped parameters. Open arrays . Calculating the number of elements . Temporaries . array of const . OPENARRAY macro . EXISTINGARRAY macro . C++ functions that take open array arguments. Types defined differently . Boolean data types. Char data types . Resource strings . Default parameters . Runtime type information . Unmapped types . \n\n\n\n 6-byte Real types . Arrays as return types of functions . Keyword extensions. classid . closure . property . published. 8-1 . 8-1 . . . . . . . . . . . . . . 8-1 8-2 8-2 8-3 8-3 8-6 8-9 . . . . . . . . . 8-10 . 8-10 . 8-11 . 8-11 . 8-12 . 8-12 . 8-13 . 8-15 . . . . . . 8-16 . 8-17 . 8-17 . 8-18 . 8-19 . . . . . . 8-20 . 8-20 . 8-21 . 8-21 . 8-22 C++ and Object Pascal object models . Object identity and instantiation . Distinguishing C++ and Object Pascal references . Copying objects . Objects as function arguments . Object construction for C++Builder VCL classes . C++ object construction . Object Pascal object construction . C++Builder object construction . . 9-1 . 9-1 Chapter 9 C++ language support for the VCL 9-1 . 9-2 . 9-2 . 9-3 . . . . 9-4 9-4 9-4 9-4 v . . . . . . 9-6 . 9-6 . 9-7 . 9-7 . 9-7 .\n\n\n\n 9-8 . 9-9 . 9-10 . 9-11 . 9-11 . 9-11 . 9-11 . 9-12 . 9-12 . . . . . . . . . 9-12 9-12 9-13 9-13 9-13 9-14 9-14 9-15 9-15 . . . . . . . . . . . . . . . 9-15 9-15 9-16 9-16 9-16 9-17 9-18 9-18 9-18 9-19 9-19 9-19 9-19 9-20 9-21 The declspec keyword extension. declspec(delphiclass) . declspec(delphireturn). declspec(dynamic) . declspec(hidesbase) . declspec(package) . declspec(pascalimplementation) . . . . . . . . . . . . . . . . . . . . . Why use packages? . Packages and standard DLLs . Runtime packages . Using packages in an application. Dynamically loading packages . Deciding which runtime packages to use Custom packages . Design-time packages . Installing component packages . Creating and editing packages . Creating a package . Editing an existing package . Package source files and project option files. Packaging\n\n\n\ncomponents. Understanding the structure of a package . Naming packages . The Requires list . The Contains list . Compiling packages . Package-specific compiler directives . Using the command-line compiler and linker . Package files created by a successful compilation . Deploying packages . Deploying applications that use packages . Distributing packages to other developers . Package collection files . . . . . . . . . . . . . Chapter 11 . 9-21 . 9-21 . 9-22 . 9-22 . 9-22 . 9-23 . 9-23 Creating international applications 11-1 Internationalization and localization . Internationalization . Localization . Internationalizing applications . Enabling application code . Character sets . OEM and ANSI character sets . Double byte character sets . Wide characters . \n\n\n\n Including bi-directional functionality in applications . BiDiMode property . Locale-specific features . Designing the user interface . Text . Graphic images . Formats and sort order . Keyboard mappings . Isolating resources. Creating resource DLLs. Using resource DLLs . Dynamic switching of resource DLLs . Localizing applications . Localizing resources. Chapter 10 Working with packages and components 10-1 . 10-2 . 10-2 . 10-2 . 10-2 . 10-3 . 10-3 . 10-4 . 10-4 . 10-5 . 10-6 . 10-6 . 10-7 . 10-7 . 10-8 . . . . . . . . . . . . . . . . . . . . . . . 11-1 11-1 11-1 11-2 11-2 11-2 11-2 11-2 11-3 . . . . . . . . . . . . . . . 11-3 . 11-5 . 11-7 . 11-8 . 11-8 . 11-8 . 11-8 . 11-9 . 11-9 . 11-9 .11-10 .11-11 .11-12 .11-12 . . . . . . . . . . . . . . . . . . . . . . . . . . Chapter 12 . 10-9 . 10-9 . 10-9 10-10 10-10 Deploying applications\n\n\n\nDeploying general applications . Using installation programs . Identifying application files . Application files . Package files . ActiveX controls . Helper applications . DLL locations. Deploying database applications . Providing the database engine . Borland Database Engine . Third-party database engines SQL Links. . 10-10 . 10-12 . 10-12 . 10-13 . 10-13 . 10-13 . 10-13 vi 12-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1 12-2 12-2 12-2 12-3 12-3 12-3 12-3 12-4 12-4 12-4 12-5 12-5 Multi-tiered Distributed Application Services (MIDAS) . Deploying Web applications . Programming for varying host environments . Screen resolutions and color depths . Considerations when not dynamically resizing . Considerations when dynamically resizing forms and controls . Accommodating varying color depths . Fonts . \n\n\n\n Windows versions . Software license requirements . DEPLOY.TXT README.TXT No-nonsense license agreement . Third-party product documentation . Chapter 14 . 12-6 . 12-6 Building one- and two-tiered applications BDE-based applications . BDE-based architecture . Understanding databases and datasets . Using sessions . Connecting to databases . Using transactions. Explicitly controlling transactions . Using a database component for transactions . Using the TransIsolation property . Using passthrough SQL . Using local transactions . Caching updates. Creating and restructuring database tables . ADO-based applications . ADO-based architecture . Understanding ADO databases and datasets. Connecting to ADO databases . Retrieving data . Creating and restructuring ADO database tables\n\n\n\n. Flat-file database applications . Creating the datasets . Creating a new dataset using persistent fields. Creating a dataset using field and index definitions . Creating a dataset based on an existing table . Loading and saving data . Using the briefcase model . Scaling up to a three-tiered application . . 12-6 . 12-7 . 12-7 . 12-7 . . . . . . . . . . . . . . . . . . . . . . . . . 12-8 . 12-9 . 12-9 12-10 12-10 12-10 12-10 12-10 Part II Developing database applications Chapter 13 Designing database applications Using databases . Types of databases . Local databases . Remote database servers . Database security. Transactions . Data Dictionary . Referential integrity, stored procedures, and triggers . Database architecture . Planning for scalability . Single-tiered database\n\n\n\napplications . Two-tiered database applications. Multi-tiered database applications . Designing the user interface . Displaying a single record. Displaying multiple records. Analyzing data . Selecting what data to show . Writing reports . 13-1 . . . . . . . . 13-1 . 13-2 . 13-2 . 13-2 . 13-3 . 13-3 . 13-4 . . . . . . . . . . . . . 13-5 . 13-6 . 13-7 . 13-8 . 13-9 . 13-9 13-11 13-11 13-12 13-12 13-13 13-15 14-1 . 14-2 . 14-2 . . . . . . . . . . . . . . . 14-3 14-3 14-4 14-5 14-5 . . . . . . . . . . . . . . . 14-6 14-7 14-8 14-8 14-9 . 14-10 . 14-10 . 14-10 . 14-11 . 14-11 . 14-12 . 14-12 . 14-13 . 14-14 . 14-14 . 14-14 . . . . . . . . 14-15 14-16 14-16 14-17 Chapter 15 Creating multi-tiered applications 15-1 Advantages of the multi-tiered database model . 15-2 Understanding MIDAS technology . 15-2 Overview of a MIDAS-based multi-tiered application. \n\n\n\n15-3 vii The structure of the client application . The structure of the application server. Using transactional data modules . Pooling remote data modules . Using the IAppServer interface . Choosing a connection protocol . Using DCOM connections . Using Socket connections . Using Web connections. Building a multi-tiered application . Creating the application server. Setting up the remote data module. Configuring the remote data module when it is not transactional . Configuring a transactional remote data module . Creating a data provider for the application server. Extending the application server’s interface . Adding callbacks to the application server’s interface . Extending a transactional application server’s interface . Creating the client application . Connecting to the application server. Specifying a connection using DCOM . \n\n\n\n Specifying a connection using sockets . Specifying a connection using HTTP . Brokering connections . Managing server connections . Connecting to the server . Dropping or changing a server connection . Calling server interfaces . Managing transactions in multi-tiered applications . Supporting master/detail relationships . Supporting state information in remote data modules . Writing MIDAS Web applications . Distributing a client application as an ActiveX control . Creating an Active Form for the client application . . . . . . . . . . . . . . 15-4 . 15-4 . 15-5 . 15-7 . 15-8 . 15-9 . 15-9 . 15-9 15-10 15-11 15-11 15-13 Building Web applications using InternetExpress . Building an InternetExpress application . Using the javascript libraries . Granting permission to access and launch the application server . Using an\n\n\n\nXML broker . Fetching XML data packets . Applying updates from XML delta packets . Creating Web pages with a MIDAS page producer . Using the Web page editor . Setting Web item properties . Customizing the MIDAS page producer template . . 15-13 . 15-14 . 15-27 . 15-28 . 15-29 . 15-30 . 15-30 . 15-31 . 15-32 . 15-32 . 15-33 . 15-34 Chapter 16 . 15-15 . 15-15 . 15-16 . 15-16 . 15-16 . 15-17 . 15-18 . 15-18 . . . . . 15-27 15-19 15-19 15-20 15-20 . 15-20 . 15-21 . 15-21 . 15-22 Using provider components 16-1 Determining the source of data . Choosing how to apply updates . Controlling what information is included in data packets. Specifying what fields appear in data packets . Setting options that influence the data packets . Adding custom information to data packets . Responding to client data requests . Responding to client update\n\n\n\nrequests . Editing delta packets before updating the database . Influencing how updates are applied . Screening individual updates . Resolving update errors on the provider . Applying updates to datasets that do not represent a single table . Responding to client-generated events . Handling server constraints . . 16-1 . 16-2 . 16-2 . 16-2 . 16-3 . 16-4 . 16-5 . 16-6 . . . . 16-6 16-7 16-9 16-9 . 16-9 16-10 16-10 Chapter 17 . 15-23 . 15-24 Managing database sessions Working with a session component. Using the default session . Creating additional sessions . Naming a session . Activating a session . . 15-26 . 15-26 viii 17-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-1 17-2 17-3 17-4 17-4 Customizing session start-up . Specifying default database connection behavior . Creating, opening, and closing database connections . Closing a single\n\n\n\ndatabase connection. Closing all database connections . Dropping temporary database connections . Searching for a database connection . Retrieving information about a session . Working with BDE aliases . Specifying alias visibility. Making session aliases visible to other sessions and applications . Determining known aliases, drivers, and parameters . Creating, modifying, and deleting aliases . Iterating through a session’s database components . Specifying Paradox directory locations . Specifying the control file location . Specifying a temporary files location . Working with password-protected Paradox and dBASE tables . Using the AddPassword method . Using the RemovePassword and RemoveAllPasswords methods . Using the GetPassword method and OnPassword event . Managing multiple sessions . Using a session component in data modules . . 17-5 \n\n\n\nSetting BDE alias parameters . Controlling server login . Connecting to a database server . Special considerations when connecting to a remote server . Working with network protocols. Using ODBC . Disconnecting from a database server . Closing datasets without disconnecting from a server . Iterating through a database component’s datasets . Understanding database and session component interactions. Using database components in data modules . Executing SQL statements from a TDatabase component . Executing SQL statements from TDatabase . Executing parameterized SQL statements . . 17-6 . 17-6 . 17-7 . 17-7 . . . . . . 17-7 . 17-8 . 17-8 . 17-9 17-10 . 17-10 . 17-10 . 17-10 . 17-12 . 17-12 . 17-13 Understanding persistent and temporary database components. Using temporary database components . Creating database components at design time . \n\n\n\n Creating database components at runtime . Controlling connections . Associating a database component with a session . Specifying a BDE alias . . . . . . . . . 18-8 18-8 18-8 18-9 . 18-9 . 18-9 . 18-9 . 18-10 . 18-10 . 18-10 . 18-11 Chapter 19 Understanding datasets . 17-13 What is TDataSet?. Types of datasets . Opening and closing datasets . Determining and setting dataset states . Inactivating a dataset . Browsing a dataset . Enabling dataset editing . Enabling insertion of new records . Enabling index-based searches and ranges on tables . Calculating fields . Filtering records . Updating records . Navigating datasets. Using the First and Last methods . Using the Next and Prior methods . Using the MoveBy method . Using the Eof and Bof properties . Eof . Bof . Marking\n\n\n\nand returning to records . Searching datasets . Using Locate . Using Lookup . . 17-13 . 17-13 . 17-14 . 17-14 . 17-16 . 17-17 Chapter 18 Connecting to databases . 18-5 . 18-6 . 18-7 18-1 . 18-1 . 18-2 . 18-2 . 18-3 . 18-4 . 18-4 . 18-4 ix 19-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2 19-2 19-3 19-3 19-5 19-6 19-7 19-7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-8 . 19-8 . 19-9 . 19-9 . 19-9 19-10 19-10 .19-11 .19-11 .19-11 19-12 19-13 19-15 19-15 19-16 Displaying and editing a subset of data using filters . Enabling and disabling filtering . Creating filters . Setting the Filter property . Writing an OnFilterRecord event handler. Switching filter event handlers at runtime . Setting filter options . Navigating records in a filtered dataset Modifying data. \n\n\n\n Editing records . Adding new records . Inserting records . Appending records . Deleting records . Posting data to the database . Canceling changes . Modifying entire records . Using dataset events. Aborting a method . Using OnCalcFields . Using BDE-enabled datasets . Overview of BDE-enablement . Handling database and session connections . Using the DatabaseName and SessionName properties . Working with BDE handle properties . Using cached updates . Caching BLOBs . . . . . . . . . Defining an aggregate field . Deleting persistent field components . Setting persistent field properties and events . Setting display and edit properties at design time . Setting field component properties at runtime . Creating attribute sets for field components . \n\n\n\nAssociating attribute sets with field components . Removing attribute associations . Controlling and masking user input . Using default formatting for numeric, date, and time fields. Handling events . Working with field component methods at runtime . Displaying, converting, and accessing field values. Displaying field component values in standard controls . Converting field values . Accessing field values with the default dataset property . Accessing field values with a dataset’s Fields property. Accessing field values with a dataset’s FieldByName method. Checking a field’s current value. Setting a default value for a field . Working with constraints . Creating a custom constraint. Using server constraints . Using object fields . Displaying ADT and array fields . Working with ADT fields. Accessing ADT field values. \n\n\n\nWorking with array fields . Accessing array field values . Working with dataset fields . Displaying dataset fields . Accessing data in a nested dataset . Working with reference fields . Displaying reference fields . Accessing data in a reference field . 19-17 19-17 19-17 19-18 . 19-19 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-19 19-19 19-20 19-21 19-21 19-22 19-23 19-23 19-23 19-23 19-24 19-24 19-26 19-26 19-26 19-27 19-28 . 19-28 . 19-29 . 19-29 . 19-29 . 19-30 Chapter 20 Working with field components Understanding field components . Dynamic field components . Persistent field components . Creating persistent fields . Arranging persistent fields . Defining new persistent fields . Defining a data field . Defining a calculated field. Programming a calculated field Defining a lookup field . . . . . . . . . . . . . . . . . . . . . 20-1 . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n\n\n. . . . . . . . . . . . . . 20-2 . 20-3 . 20-4 . 20-5 . 20-6 . 20-6 . 20-7 . 20-8 . 20-9 . 20-9 x . 20-11 . 20-12 . 20-12 . 20-12 . 20-14 . 20-14 . 20-15 . 20-15 . 20-15 . 20-16 . 20-17 . 20-17 . 20-18 . 20-18 . 20-19 . 20-20 . 20-20 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-21 20-21 20-21 20-22 20-22 20-22 20-23 20-24 20-24 20-24 20-25 20-25 20-26 20-26 20-26 20-27 20-27 20-27 Chapter 21 Working with tables Using table components. Setting up a table component. Specifying a database location . Specifying a table name . Specifying the table type for local tables. Opening and closing a table. Controlling read/write access to a table. Searching for records . Searching for records based on indexed fields . Executing a search with Goto methods . Executing a search with Find methods . Specifying the current record after a successful\n\n\n\nsearch . Searching on partial keys . Searching on alternate indexes . Repeating or extending a search . Sorting records . Retrieving a list of available indexes with GetIndexNames . Specifying an index with IndexName . Specifying a dBASE index file . Specifying sort order for SQL tables . Specifying fields with IndexFieldNames . Examining the field list for an index . Working with a subset of data . Understanding the differences between ranges and filters. Creating and applying a new range . Setting the beginning of a range . Setting the end of a range . Setting start- and end-range values . Specifying a range based on partial keys . Including or excluding records that match boundary values . Applying a range . Canceling a range . Modifying a range . Editing the start of a range. Editing the end of a range . Deleting all records in\n\n\n\na table . Deleting a table. Renaming a table. Creating a table . Importing data from another table . Using TBatchMove . Creating a batch move component . Specifying a batch move mode . Appending records . Updating records . Appending and updating records Copying datasets. Deleting records . Mapping data types . Executing a batch move. Handling batch move errors . Synchronizing tables linked to the same database table . Creating master/detail forms . Building an example master/detail form . Working with nested tables . Setting up a nested table component 21-1 . . . . . . . . . 21-1 . 21-2 . 21-2 . 21-3 . 21-3 . 21-4 . 21-4 . 21-5 . 21-5 . 21-6 . 21-7 . . . . . . . . . . 21-7 . 21-7 . 21-8 . 21-8 . 21-8 . . . . . . . . . . . . . 21-17 21-19 21-19 21-20 21-21 21-21 21-21 21-22 21-22 21-22 21-22 21-23 21-23 . 21-24 . \n\n\n\n21-25 . 21-25 . 21-26 . 21-26 Working with queries Using queries effectively . Queries for desktop developers . Queries for server developers . What databases can you access with a query component? . Using a query component: an overview . Specifying the SQL statement to execute . Specifying the SQL property at design time . Specifying an SQL statement at runtime . Setting the SQL property directly . Loading the SQL property from a file . Loading the SQL property from string list object. Setting parameters . Supplying parameters at design time . Supplying parameters at runtime . Using a data source to bind parameters . Executing a query . Executing a query at design time . Executing a query at runtime . Executing a query that returns a result set. . 21-9 . 21-9 . 21-9 21-10 21-11 21-12 21-12 21-13 21-14 . 21-14 . . . . . . . . . . . .\n\n\n\n. . . . . . . . . . Chapter 22 . 21-11 . 21-11 . 21-11 . . . . . . . . . . . . . . . . . . 21-15 21-15 21-15 21-15 21-16 21-16 21-16 21-16 21-17 xi 22-1 . 22-1 . 22-2 . 22-3 . 22-4 . 22-4 . 22-5 . 22-6 . 22-7 . 22-7 . 22-8 . . . . . . . . . 22-8 . 22-8 . 22-9 22-10 . . . . . . . . 22-10 22-12 22-12 22-12 . 22-13 Executing a query without a result set . Preparing a query . Unpreparing a query to release resources . Creating heterogeneous queries . Improving query performance . Disabling bi-directional cursors. Working with result sets . Enabling editing of a result set . Local SQL requirements for a live result set . Restrictions on live queries . Remote server SQL requirements for a live result set . Restrictions on updating a live result set. Updating a read-only result set . . . . . . . . . . . . . . . . . Using the result parameter . \n\n\n\n Accessing parameters at design time Setting parameter information at design time . Creating parameters at runtime . Binding parameters . Viewing parameter information at design time. Working with Oracle overloaded stored procedures . 22-13 22-13 22-14 22-14 22-15 22-15 22-16 22-16 . 22-16 . 22-17 . 23-12 . 23-12 . 23-13 . 23-14 . 23-15 . 23-15 . 23-16 Chapter 24 Working with ADO components . 22-17 Overview of ADO components . Connecting to ADO data stores . Connecting to a data store using TADOConnection . Using a TADOConnection versus a dataset’s ConnectionString . Specifying the connection. Accessing the connection object . Activating and deactivating the connection . Determining what a connection component is doing . Fine-tuning a connection . Specifying connection attributes . Controlling timeouts . Controlling the connection login . \n\n\n\nListing tables and stored procedures . Accessing the connection’s datasets . Accessing the connection’s commands . Listing available tables . Listing available stored procedures Working with (connection) transactions. Using transaction methods . Using transaction events . Using ADO datasets . Features common to all ADO dataset components . Modifying data. Navigating in a dataset . Using visual data-aware controls . Connecting to a data store using ADO dataset components . Working with record sets . . 22-17 . 22-17 Chapter 23 Working with stored procedures When should you use stored procedures? . Using a stored procedure . Creating a stored procedure component. Creating a stored procedure. Preparing and executing a stored procedure . Using stored procedures that return result sets . Retrieving a result set with a TQuery . \n\n\n\n Retrieving a result set with a TStoredProc . Using stored procedures that return data using parameters . Retrieving individual values with a TQuery . Retrieving individual values with a TStoredProc . Using stored procedures that perform actions on data . Executing an action stored procedure with a TQuery . Executing an action stored procedure with a TStoredProc . Understanding stored procedure parameters . Using input parameters . Using output parameters . Using input/output parameters . 23-1 . . . . . 23-2 . 23-2 . 23-3 . 23-4 . 23-5 . 23-5 . 23-5 . 23-6 . 23-7 . 23-7 . 23-7 . 23-8 . 23-8 . 23-9 . . . . 23-10 23-10 23-11 23-11 xii 24-1 . 24-1 . 24-2 . 24-3 . 24-3 . 24-3 . 24-4 . 24-4 . . . . . . . . . . . . . . . . . . 24-5 24-5 24-5 24-7 24-7 24-8 . 24-8 . 24-8 . 24-9 . 24-10 . . . . . . . . 24-10 24-10 24-10\n\n\n\n.24-11 . . . . . . . . .24-11 .24-11 24-12 24-12 . 24-13 . 24-13 Using batch updates . Loading data from and saving data to files . Using parameters in commands . Using TADODataSet . Retrieving a dataset using a command . Using TADOTable . Specifying the table to use . Using TADOQuery. Specifying SQL statements . Executing SQL statements . Using TADOStoredProc . Specifying the stored procedure . Executing the stored procedure . Using parameters with stored procedures . Executing commands . Specifying the command . Using the Execute method. Canceling commands . Retrieving result sets with commands . Handling command parameters . . 24-14 Copying data from another dataset . Assigning data directly . Cloning a client dataset cursor. Using a client dataset with a data provider . Specifying a data provider\n\n\n\n. Getting parameters from the application server . Passing parameters to the application server . Sending query or stored procedure parameters . Limiting records with parameters . Overriding the dataset on the application server . Requesting data from an application server . Handling constraints . Handling constraints from the server . Adding custom constraints . Updating records . Applying updates . Reconciling update errors. Refreshing records. Communicating with providers using custom events. Using a client dataset with flat-file data . Creating a new dataset . Loading data from a file or stream . Merging changes into data . Saving data to a file or stream . . 24-16 . 24-17 . 24-18 . . . . . . . . . . . . . . . . . . 24-18 24-19 24-19 24-20 24-20 24-21 24-21 24-22 24-23 . . . . . . . . . . . . . . 24-23 24-25 24-26\n\n\n\n24-26 24-27 24-27 24-28 Chapter 25 Creating and using a client dataset 25-1 Working with data using a client dataset . Navigating data in client datasets . Limiting what records appear. Representing master/detail relationships. Constraining data values . Making data read-only. Editing data . Undoing changes . Saving changes . Sorting and indexing. Adding a new index . Deleting and switching indexes . Using indexes to group data. Representing calculated values . Using internally calculated fields in client datasets. Using maintained aggregates . Specifying aggregates . Aggregating over groups of records Obtaining aggregate values . Adding application-specific information to the data. . 25-2 . 25-2 . 25-2 . . . . . . . . . . . . . . . . . . . . . . . 25-3 . 25-3 . 25-4 . 25-4 . 25-5 . 25-5 . 25-6 . 25-6 . 25-7 . 25-7 . 25-8 . . . . . . . . .\n\n\n\n. . 25-9 . 25-9 25-10 25-11 25-11 . 25-12 . 25-12 . 25-13 . 25-14 . 25-14 . 25-15 . 25-15 . 25-16 . 25-16 . 25-17 . 25-17 . 25-18 . . . . . . . . . . . . 25-19 25-19 25-20 25-20 25-21 25-22 . . . . . . . . . . . . 25-23 25-24 25-24 25-24 25-25 25-25 Deciding when to use cached updates . Using cached updates . Enabling and disabling cached updates Fetching records . Applying cached updates . Applying cached updates with a database component method . Applying cached updates with dataset component methods . Applying updates for master/detail tables . Canceling pending cached updates . Canceling pending updates and disabling further cached updates . . . . . . . . . . . Chapter 26 Working with cached updates . 25-12 xiii 26-1 26-1 26-2 26-3 26-4 26-4 . 26-5 . 26-6 . 26-6 . 26-7 . 26-8 Canceling pending cached updates. Canceling updates to the current record . Undeleting cached records . \n\n\n\n Specifying visible records in the cache . Checking update status . Using update objects to update a dataset . Specifying the UpdateObject property for a dataset . Using a single update object . Using multiple update objects. Creating SQL statements for update components . Creating SQL statements at design time . Understanding parameter substitution in update SQL statements . Composing update SQL statements . Using an update component’s Query property . Using the DeleteSQL, InsertSQL, and ModifySQL properties . Executing update statements . Calling the Apply method . Calling the SetParams method . Calling the ExecSQL method . Using dataset components to update a dataset . Updating a read-only result set . Controlling the update process. Determining if you need to control the updating process . Creating an\n\n\n\nOnUpdateRecord event handler. Handling cached update errors . Referencing the dataset to which to apply updates . Indicating the type of update that generated an error . Specifying the action to take . Working with error message text . Accessing a field’s OldValue, NewValue, and CurValue properties . Chapter 27 . 26-8 Using data controls . 26-8 . 26-9 Using common data control features . Associating a data control with a dataset . Editing and updating data . Enabling editing in controls on user entry . Editing data in a control. Disabling and enabling data display . Refreshing data display. Enabling mouse, keyboard, and timer events . Using data sources . Using TDataSource properties . Setting the DataSet property . Setting the Name property . Setting the Enabled property . Setting the AutoEdit\n\n\n\nproperty . Using TDataSource events . Using the OnDataChange event . Using the OnUpdateData event . Using the OnStateChange event . Controls that represent a single field . Displaying data as labels . Displaying and editing fields in an edit box . Displaying and editing text in a memo control . Displaying and editing text in a rich edit memo control . Displaying and editing graphics fields in an image control . Displaying and editing data in list and combo boxes . Displaying and editing data in a list box. Displaying and editing data in a combo box . Displaying and editing data in lookup list and combo boxes . Specifying a list based on a lookup field . Specifying a list based on a secondary data source . Setting lookup list and combo box properties . Searching incrementally for list item values . . 26-9 . \n\n\n\n26-10 . 26-11 . 26-12 . 26-12 . 26-12 . 26-13 . 26-13 . 26-14 . 26-15 . 26-16 . . . . . . . . . . 26-17 26-18 26-18 26-19 26-19 . 26-20 . 26-21 . 26-21 . 26-22 . 26-22 . 26-23 . 26-24 . 26-24 . 26-25 . 26-26 . 26-26 xiv 27-1 . 27-1 . 27-2 . 27-3 . . . . . . . . 27-3 27-3 27-4 27-5 . . . . . . . . . . . . . . . . . . . . . . . . . . 27-5 27-5 27-6 27-6 27-6 27-7 27-7 27-7 27-7 27-7 27-7 27-8 27-8 . 27-9 . 27-9 . 27-10 . 27-10 . 27-11 . 27-11 . 27-12 . 27-12 . 27-13 . 27-13 . 27-14 . 27-14 Handling Boolean field values with check boxes . Restricting field values with radio controls . Viewing and editing data with TDBGrid . Using a grid control in its default state . Creating a customized grid . Understanding persistent columns . Determining the source of a column property at runtime . Creating persistent columns . Deleting persistent columns . Arranging the order of persistent\n\n\n\ncolumns . Defining a lookup list column . Defining a pick list column . Putting a button in a column . Setting column properties at design time . Restoring default values to a column . Displaying ADT and array fields . Setting grid options . Editing in the grid . Rearranging column order at design time . Rearranging column order at runtime . Controlling grid drawing . Responding to user actions at runtime. Creating a grid that contains other data-aware controls . Navigating and manipulating records. Choosing navigator buttons to display Hiding and showing navigator buttons at design time . Hiding and showing navigator buttons at runtime . Displaying fly-over help. Using a single navigator for multiple datasets . Multidimensional crosstabs . Guidelines for using decision support components . Using datasets\n\n\n\nwith decision support components . Creating decision datasets with TQuery or TTable . Creating decision datasets with the Decision Query editor . Using the Decision Query editor . Decision query properties . Using decision cubes . Decision cube properties and events . Using the Decision Cube editor . Viewing and changing dimension settings . Setting the maximum available dimensions and summaries. Viewing and changing design options . Using decision sources . Properties and events . Using decision pivots. Decision pivot properties. Creating and using decision grids . Creating decision grids . Using decision grids . Opening and closing decision grid fields . Reorganizing rows and columns in decision grids . Drilling down for detail in decision grids . Limiting dimension selection in decision grids. \n\n\n\nDecision grid properties . Creating and using decision graphs . Creating decision graphs . Using decision graphs . The decision graph display. Customizing decision graphs . Setting decision graph template defaults . Customizing decision graph series Decision support components at runtime Decision pivots at runtime . Decision grids at runtime. Decision graphs at runtime. . 27-14 . 27-15 . 27-16 . 27-17 . 27-17 . 27-18 . 27-19 . 27-19 . 27-20 . . . . . . . . 27-20 27-20 27-21 27-21 . 27-21 . . . . . . . . 27-22 27-23 27-24 27-25 . 27-26 . 27-26 . 27-26 . 27-27 . 27-28 . 27-29 . 27-30 . 27-30 . 27-30 . 27-31 . 27-31 Chapter 28 Using decision support components 28-1 Overview . 28-1 About crosstabs . 28-2 One-dimensional crosstabs . 28-3 xv . 28-3 . 28-3 . 28-5 . 28-5 . . . . . . . . . . . . . . . . . . 28-6 28-6 28-7 28-7 28-7 28-8 \n\n\n\n. 28-8 . 28-9 . . . . . . . . . . . . . . . . . 28-9 . 28-9 . 28-9 28-10 28-10 .28-11 .28-11 .28-11 . 28-12 . 28-12 . 28-12 . . . . . . . . . . . . . . 28-12 28-12 28-13 28-14 28-14 28-15 28-16 . . . . . . . . . . . . 28-17 28-17 28-18 28-19 28-19 28-19 Decision support components and memory control . Setting maximum dimensions, summaries, and cells . Setting dimension state . Using paged dimensions . Serving client requests . Responding to client requests . Web server applications . Types of Web server applications . ISAPI and NSAPI . CGI stand-alone . Win-CGI stand-alone . Creating Web server applications . The Web module. The Web Application object . The structure of a Web server application . The Web dispatcher. Adding actions to the dispatcher . Dispatching request messages . Action items . Determining when action items fire. \n\n\n\n The target URL . The request method type . Enabling and disabling action items. Choosing a default action item . Responding to request messages with action items . Sending the response . Using multiple action items . Accessing client request information . Properties that contain request header information. Properties that identify the target . Properties that describe the Web client . Properties that identify the purpose of the request . Properties that describe the expected response . Properties that describe the content . The content of HTTP request messages . Creating HTTP response messages . Filling in the response header . Indicating the response status . Indicating the need for client action . Describing the server application . Describing the content . Setting the response content . Sending the response . Generating the content of response messages\n\n\n\n. Using page producer components. HTML templates . Specifying the HTML template. . 28-20 . 28-20 . 28-20 . 28-21 Part III Writing distributed applications Chapter 29 Writing CORBA applications Overview of a CORBA application . Understanding stubs and skeletons . Using Smart Agents . Activating server applications . Binding interface calls dynamically . Writing CORBA servers . Defining object interfaces . Using the CORBA Server Wizard. Generating stubs and skeletons from an IDL file . Using the CORBA Object Implementation Wizard . Instantiating CORBA objects . Using the delegation model . Viewing and editing changes . Implementing CORBA Objects . Guarding against thread conflicts. Changing CORBA interfaces . Registering server interfaces . Writing CORBA clients . Using stubs . Using the dynamic invocation interface . \n\n\n\nTesting CORBA servers . Setting up the testing tool . Recording and running test scripts . 29-1 . . . . . . . . . . . . . . . . . . . . . . . . . 29-1 . 29-2 . 29-3 . 29-3 . 29-4 . 29-4 . 29-5 . 29-5 . 29-6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29-6 . 29-7 . 29-8 . 29-9 . 29-9 29-11 29-12 29-12 29-13 29-14 . . . . . . . . . . . . 29-15 29-16 29-17 29-17 . . . . . . . . . . . . . . . . . . Chapter 30 Creating Internet server applications Terminology and standards. Parts of a Uniform Resource Locator. URI vs. URL HTTP request header information . HTTP server activity. Composing client requests . 30-1 . 30-1 . 30-2 . 30-2 . 30-3 . 30-3 . 30-3 xvi . . . . . . . . . . . . . . . . . . . . . 30-4 . 30-4 . 30-5 . 30-5 . 30-5 . 30-5 . 30-5 . 30-6 . 30-6 . 30-7 . 30-7 . 30-8 . 30-9 . 30-9 30-10 30-10 30-10 30-10 .30-11 .30-11 . . . . 30-12 30-12 30-12 30-13 . 30-13 . 30-13 . 30-13 . 30-14 . .\n\n\n\n. . . . . . . . . 30-14 30-14 30-15 30-15 30-15 30-15 30-16 30-16 30-16 30-16 30-17 . . . . 30-17 30-18 30-18 30-19 Converting HTML-transparent tags . Using page producers from an action item . Chaining page producers together . Using database information in responses . Adding a session to the Web module . Representing database information in HTML . Using dataset page producers . Using table producers . Specifying the table attributes . Specifying the row attributes . Specifying the columns. Embedding tables in HTML documents . Setting up a dataset table producer . Setting up a query table producer . Debugging server applications . Debugging ISAPI and NSAPI applications . Debugging under Windows NT. Debugging with a Microsoft IIS server . Debugging under MTS . Debugging with a Windows 95 Personal Web Server . Debugging with Netscape Server Version\n\n\n\n2.0 Debugging CGI and Win-CGI applications . Simulating the server. Debugging as a DLL . Using socket components . Using client sockets . Specifying the desired server . Forming the connection . Getting information about the connection . Closing the connection . Using server sockets . Specifying the port. Listening for client requests . Connecting to clients . Getting information about connections . Closing server connections . Responding to socket events. Error events . Client events . Server events. Events when listening . Events with client connections . Reading and writing over socket connections . Non-blocking connections . Reading and writing events . Blocking connections . Using threads with blocking connections . Using TWinSocketStream . Writing client threads . Writing server\n\n\n\nthreads. . 30-19 . . . . . . . . 30-19 30-20 30-21 30-22 . . . . . . . . . . . . 30-22 30-22 30-23 30-23 30-23 30-24 . . . . . . . . 30-24 30-24 30-24 30-25 . 30-25 . 30-25 . 30-25 . 30-26 . 30-27 . 30-28 . 30-29 . 30-29 . 30-29 Implementing services . Understanding service protocols . Communicating with applications Services and ports . Types of socket connections. Client connections . Listening connections . Server connections . Describing sockets . Describing the host . Choosing between a host name and an IP address . Using ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31-5 31-5 31-6 31-6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31-6 31-6 31-6 31-7 31-7 31-7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31-7 31-8 31-8 31-8 31-9 31-9 31-9 31-9 . . . . . . . . .\n\n\n\n. . . . . . . 31-10 31-10 31-10 .31-11 . . . . . . . . . . . . . . . . .31-11 31-12 31-12 31-13 Developing COM-based applications Chapter 32 31-1 . . . . . . . . . . . . . . Part IV Chapter 31 Working with sockets . . . . Overview of COM technologies . 31-1 . 31-2 . 31-2 . 31-2 . 31-2 . 31-3 . 31-3 . 31-3 . 31-3 . 31-4 COM as a specification and implementation . COM extensions . Parts of a COM application . COM interfaces . The fundamental COM interface, IUnknown . COM interface pointers . COM servers . CoClasses and class factories . In-process, out-of-process, and remote servers . . 31-4 . 31-5 xvii 32-1 . . . . . . . . . . . . . . . . 32-1 32-2 32-2 32-3 . . . . . . . . . . . . . . . . 32-4 32-4 32-5 32-6 . 32-6 The marshaling mechanism . Aggregation . COM clients . COM extensions . Automation servers . Active Server Pages . \n\n\n\n ActiveX controls . Active Documents . Transactional objects . Type libraries . The content of type libraries . Creating type libraries . When to use type libraries . Accessing type libraries . Benefits of using type libraries Using type library tools . Implementing COM objects with wizards . Code generated by wizards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32-8 . 32-8 . 32-9 . 32-9 32-11 32-12 32-12 32-13 32-13 32-14 32-14 32-15 32-15 32-16 32-16 32-17 Adding an enumeration to the type library . Adding an alias to the type library Adding a record or union to the type library . Adding a module to the type library . Saving and registering type library information . Saving a type library . Refreshing the type library . Registering\n\n\n\nthe type library. Exporting an IDL file . Deploying type libraries . . 33-15 . 33-16 . 33-16 . 33-16 . . . . . . . . . . . . Chapter 34 Creating COM clients . 32-17 . 32-20 Chapter 33 Working with type libraries Type Library editor . Parts of the Type Library editor. Toolbar . Object list pane . Status bar . Pages of type information . Type library elements . Interfaces. Dispinterfaces . CoClasses . Type definitions . Modules . Using the Type Library editor. Valid types . Creating a new type library . Opening an existing type library . Adding an interface to the type library . Modifying an interface using the type library . Adding properties and methods to an interface or dispinterface . Adding a CoClass to the type library . Adding an interface to a CoClass . 33-1\n\n\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33-2 . 33-2 . 33-3 . 33-4 . 33-5 . 33-5 . 33-7 . 33-8 . 33-9 . 33-9 . 33-9 33-10 33-10 33-11 33-12 33-12 . 33-13 . 33-13 . 33-14 . 33-15 . 33-15 33-17 33-17 33-18 33-18 33-18 33-18 Importing type library information . Using the Import Type Library dialog Using the Import ActiveX dialog . Code generated when you import type library information . Controlling an imported object . Using component wrappers . ActiveX wrappers . Automation object wrappers . Using data-aware ActiveX controls . Example: Printing a document with Microsoft Word . Step 1: Prepare C++Builder for this example . Step 2: Import the Word type library . Step 3: Use a VTable or dispatch interface object to control Microsoft Word . Step 4: Clean up the example . Writing client code based on type library definitions . \n\n\n\nConnecting to a server . Controlling an Automation server using a dual interface . Controlling an Automation server using a dispatch interface . Handling events in an automation controller . Creating Clients for servers that do not have a type library . xviii 34-1 . 34-2 . 34-3 . 34-4 . . . . . . . . . . . . . . . . . . 34-5 34-6 34-6 34-7 34-7 34-8 . 34-10 . 34-10 . 34-10 . 34-11 . 34-12 . 34-12 . 34-12 . 34-13 . 34-13 . 34-14 . 34-16 Chapter 35 Creating simple COM servers Registering an out-of-process server . 36-8 Testing and debugging the Active Server Page application. 36-8 35-1 Overview of creating a COM object . Designing a COM object . Using the COM object wizard . Using the Automation object wizard . Choosing a threading model . Writing an object that supports the free threading model . Writing an object that supports the apartment threading model . Writing an object\n\n\n\nthat supports the neutral threading model . Specifying ATL options . Defining a COM object’s interface . Adding a property to the object’s interface . Adding a method to the object’s interface . Exposing events to clients . Managing events in your Automation object . Automation interfaces . Dual interfaces . Dispatch interfaces . Custom interfaces . Marshaling data . Automation compatible types . Type restrictions for automatic marshaling . Custom marshaling . Registering a COM object . Registering an in-process server . Registering an out-of-process server . Testing and debugging the application . . . . . . . . . . . . . . . . . 35-1 . 35-2 . 35-2 . 35-4 . 35-5 Chapter 37 Creating an ActiveX control . 35-6 . 35-7 . 35-8 . 35-8 . 35-9 . 35-9 . 35-10 . 35-10 . . . . . . . . . . . . . . . . . . . . . 35-11\n\n\n\n35-11 35-12 35-13 35-14 35-14 35-14 . . . . . . . . . . . . . . . . . . 35-15 35-15 35-16 35-16 35-16 35-17 . . . . . . . . . . . . . . . . . . . . . Chapter 36 Creating an Active Server Page Creating an Active Server Object. Using the ASP intrinsics . Application . Request. Response . Session . Server . Creating ASPs for in-process or out-of-process servers . Registering an Active Server Object Registering an in-process server . . . . . . . . . . . . . . 36-1 . . . . . . . 37-1 Overview of ActiveX control creation . Elements of an ActiveX control . VCL control. ActiveX wrapper. Type library. Property page . Designing an ActiveX control . Generating an ActiveX control from a VCL control . Generating an ActiveX control based on a VCL form . Licensing ActiveX controls. Customizing the ActiveX control’s interface . \n\n\n\n Adding additional properties, methods, and events . Adding properties and methods . Adding events . Enabling simple data binding with the type library. Creating a property page for an ActiveX control . Creating a new property page . Adding controls to a property page . Associating property page controls with ActiveX control properties . Updating the property page . Updating the object . Connecting a property page to an ActiveX control . Registering an ActiveX control . Testing an ActiveX control . Deploying an ActiveX control on the Web . Setting options . . 36-2 . 36-3 . 36-3 . 36-4 . 36-4 . 36-5 . 36-6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37-2 37-2 37-3 37-3 37-3 37-3 37-4 . 37-4 . 37-6 . 37-7 . 37-8 . 37-9 . 37-9 . 37-10 . 37-11 . 37-13 . 37-13 . 37-14 . 37-14 . 37-14 . 37-15 . 37-15 . 37-15 . 37-16 . 37-16 . \n\n\n\n37-17 Chapter 38 Creating MTS or COM+ objects Understanding transactional objects Requirements for a transactional object . Managing resources . Accessing the object context . . 36-7 . 36-7 . 36-7 xix 38-1 . 38-2 . 38-2 . 38-3 . 38-3 Just-in-time activation . Resource pooling . Database resource dispensers . Shared property manager . Releasing resources . Object pooling . MTS and COM+ transaction support . Transaction attributes . Setting the transaction attribute . Stateful and stateless objects . Influencing how transactions end . Initiating transactions . Setting up a transaction object on the client side . Setting up a transaction object on the server side . Transaction timeout . Role-based security . Overview of creating transactional objects . Using the Transactional Object wizard .\n\n\n\nChoosing a threading model for a transactional object . Activities . Generating events under COM+ . Using the Event Object wizard . Firing events using a COM+ event object . Passing object references . Using the SafeRef method . Callbacks. Debugging and testing transactional objects . Installing transactional objects . Administering transactional objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38-4 . 38-5 . 38-5 . 38-6 . 38-9 . 38-9 . 38-9 38-10 38-11 38-12 38-12 38-13 Subclassing Windows controls. Creating nonvisual components . What goes into a component? . Removing dependencies . Properties, methods, and events . Properties . Events . Methods. Graphics encapsulation . Registration . Creating a new component . Using the Component wizard . Creating a component manually. Creating a unit\n\n\n\nfile . Deriving the component . Declaring a new constructor . Registering the component . Testing uninstalled components. Testing installed components . Installing a component on the Component palette . Component file locations . Adding the component . . 38-13 . 38-14 . 38-15 . 38-16 . 38-17 . 38-17 . . . . . . . . . . . . 38-18 38-19 38-20 38-20 . . . . . . . . . . . . 38-21 38-22 38-22 38-23 Chapter 39 . . . . . . . . . . . . . . . . . . 39-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39-4 . 39-4 . 39-5 . 39-5 . 39-5 . 39-6 . 39-6 . 39-6 . 39-7 . 39-7 . 39-7 . 39-8 .39-11 .39-11 .39-11 39-12 39-12 39-14 39-16 . 39-16 . 39-17 . 39-17 Defining new classes . Deriving new classes . To change class defaults to avoid repetition . To add new capabilities to a class Declaring a new component class . Ancestors, descendants,\n\n\n\nand class hierarchies . Controlling access. Hiding implementation details . Defining the component writer’s interface. Defining the runtime interface . Defining the design-time interface . Dispatching methods . Regular methods . Virtual methods . Overriding methods . Abstract class members . Classes and pointers . Creating custom components . . . . . . . . . . . . . . . . . . . . . . . . . Object-oriented programming for component writers Part V Visual Component Library . Components and classes . How do you create components? Modifying existing controls . Creating windowed controls . Creating graphic controls . . . . . . . . . . . . . . . . . . . . Chapter 40 . 38-23 . 38-24 . 38-25 Overview of component creation . . . . . . . . . . . . . . . . . . . . 39-1 . 39-2 . 39-2 . 39-3 . 39-3 . 39-4 xx 40-1 . 40-1 . 40-2 . 40-2 . 40-2 . 40-3 . \n\n\n\n 40-3 . 40-4 . 40-4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40-6 . 40-6 . 40-7 . 40-8 . 40-8 . 40-9 . 40-9 40-10 40-10 Chapter 41 Creating properties Defining the handler type . Simple notifications . Event-specific handlers . Returning information from the handler . Declaring the event . Event names start with “On” . Calling the event. 41-1 Why create properties? . Types of properties. Publishing inherited properties . Defining properties . The property declaration . Internal data storage . Direct access. Access methods. The read method . The write method . Default property values . Specifying no default value . Creating array properties . Storing and loading properties . Using the store-and-load mechanism Specifying default values . Determining what to store. Initializing after\n\n\n\nloading . Storing and loading unpublished properties . Creating methods to store and load property values . Overriding the DefineProperties method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41-1 . 41-2 . 41-2 . 41-3 . 41-3 . 41-4 . 41-4 . 41-5 . 41-6 . 41-6 . 41-7 . 41-7 . 41-8 . 41-9 41-10 41-10 41-11 41-12 42-1 . . . . . . . . . 42-1 . 42-2 . 42-2 . 42-3 . . . . . . . . . . . . . . . . . . . . . 42-3 . 42-3 . 42-4 . 42-4 . 42-4 . . . . . . . . . . . . . . . . . . . . Avoiding dependencies . Naming methods . Protecting methods . Methods that should be public. Methods that should be protected. Making methods virtual . Declaring methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Overview of graphics. Using the canvas . Working with pictures . Using a\n\n\n\npicture, graphic, or canvas . Loading and storing graphics . Handling palettes . Specifying a palette for a control . Off-screen bitmaps . Creating and managing off-screen bitmaps . Copying bitmapped images . Responding to changes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42-7 42-7 42-8 42-8 43-1 43-1 43-2 43-3 43-3 43-3 43-3 43-4 44-1 44-1 44-2 44-3 44-3 44-4 44-4 44-5 44-5 . 44-6 . 44-6 . 44-6 Chapter 45 Handling messages Understanding the message-handling system . What’s in a Windows message? . Dispatching messages. Tracing the flow of messages . Changing message handling. Overriding the handler method . Using message parameters . Trapping messages . Creating new message handlers. Defining your own messages . Declaring a message identifier . . 42-5 . 42-5 . . . . . . . . Using graphics in components . 41-13 . . . . . . . . \n\n\n\nChapter 44 . 41-12 . . . . . . . . Creating methods Chapter 42 What are events? . Events are closures . Events are properties. Event types are closure types . Event handlers have a return type of void . Event handlers are optional . Implementing the standard events. Identifying standard events . Standard events for all controls . Standard events for standard controls . Making events visible . Changing the standard event handling . Defining your own events . Triggering the event . Two kinds of events . . . . . Chapter 43 . 41-12 Creating events . 42-7 . 42-7 . 42-7 . 42-5 . 42-6 . 42-6 . 42-6 xxi 45-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45-1 45-2 45-2 45-3 45-3 45-4 45-4 45-5 45-5 45-6 45-6 Chapter 47 Declaring a message-structure type . 45-6\n\n\n\nDeclaring a new message-handling method. 45-7 Modifying an existing component Creating and registering the component . Modifying the component class . Overriding the constructor . Specifying the new default property value . Chapter 46 Making components available at design time Registering components. Declaring the Register function . Writing the Register function . Specifying the components . Specifying the palette page . Using the RegisterComponents function . Adding palette bitmaps . Providing Help for your component. Creating the Help file . Creating the entries . Making component help context-sensitive . Adding component help files . Adding property editors . Deriving a property-editor class . Editing the property as text . Displaying the property value. Setting the property value . Editing the property as a whole . Specifying editor\n\n\n\nattributes . Registering the property editor . Adding component editors . Adding items to the context menu . Specifying menu items . Implementing commands . Changing the double-click behavior . Adding clipboard formats . Registering the component editor . Property categories . Registering one property at a time . Registering multiple properties at once . Property category classes . Built-in property categories . Deriving new property categories Using the IsPropertyInCategory function . Compiling components into packages. Troubleshooting custom components . 46-1 . . . . . . . . . . . . . . . . 46-1 . 46-2 . 46-2 . 46-2 . 46-3 . . . . . . . . . . . . . . . . 46-3 . 46-4 . 46-5 . 46-5 . 46-5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46-7 . 46-7 . 46-7 . 46-8 . 46-9 . 46-9 . 46-9 . 46-9 46-10 46-11 46-12 46-12 46-13\n\n\n\n46-13 46-14 46-14 46-15 46-15 46-16 . . . . . . . . . . . . 46-16 46-17 46-17 46-18 47-1 . 47-1 . 47-2 . 47-3 . 47-3 Chapter 48 Creating a graphic component Creating and registering the component . Publishing inherited properties . Adding graphic capabilities . Determining what to draw . Declaring the property type . Declaring the property . Writing the implementation method Overriding the constructor and destructor. Changing default property values . Publishing the pen and brush . Declaring the data members . Declaring the access properties. Initializing owned classes. Setting owned classes’ properties . Drawing the component image . Refining the shape drawing . 48-1 . . . . . . . . . . . . . . 48-1 48-2 48-3 48-3 48-4 48-4 48-4 . . . . . . . . . . 48-5 . 48-5 . 48-6 . 48-6 . 48-6 . 48-7 . 48-8 . 48-9 48-10 . . . . . . . . . . . . . . . . 49-1 . 49-3 . 49-3 . 49-4 . 49-5 . 49-6 .\n\n\n\n49-6 . 49-7 . 49-8 49-10 .49-11 49-12 49-12 49-12 49-13 Chapter 49 Customizing a grid Creating and registering the component . Publishing inherited properties . Changing initial values. Resizing the cells . Filling in the cells . Tracking the date . Storing the internal date . Accessing the day, month, and year . Generating the day numbers . Selecting the current day . Navigating months and years . Navigating days. Moving the selection . Providing an OnChange event. Excluding blank cells . . 46-18 . 46-19 . 46-19 xxii 49-1 Chapter 50 Making a control data aware Creating a data-browsing control . Creating and registering the component. Making the control read-only . Adding the ReadOnly property . Allowing needed updates . Adding the data link . Declaring the data member . Declaring the access properties . An example of\n\n\n\ndeclaring access properties . Initializing the data link . Responding to data changes . Creating a data-editing control . Changing the default value of FReadOnly . Handling mouse-down and key-down messages . Responding to mouse-down messages . Responding to key-down messages . Updating the field datalink class . 50-11 Modifying the Change method . 50-12 Updating the dataset . 50-12 50-1 . 50-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50-2 . 50-3 . 50-3 . 50-4 . 50-5 . 50-5 . 50-5 . . . . . . . . . . . . . . . . . 50-6 . 50-7 . 50-7 . 50-8 . 50-9 . 50-9 Chapter 51 Making a dialog box a component Defining the component interface. Creating and registering the component . Creating the component interface. Including the form unit files . Adding interface properties . Adding the Execute method . Testing the component . . . . . . . .\n\n\n\n 51-1 . . . . . . . . . . . . . . 51-1 51-2 51-3 51-3 51-4 51-5 51-6 Appendix A ANSI implementation-specific standards Index . 50-9 . 50-10 xxiii A-1 I-1 Tables 1.1 2.1 4.2 4.3 4.4 4.5 5.1 5.2 6.1 6.2 6.3 6.4 6.5 7.1 7.2 8.1 8.2 9.1 9.2 9.3 10.1 10.2 10.3 10.4 11.1 11.2 12.1 12.2 13.1 14.1 14.2 15.1 15.2 15.3 15.4 16.1 Typefaces and symbols . Component palette pages . Menu Designer context menu commands . Setting speed buttons’ appearance. Setting tool buttons’ appearance . Setting a cool button’s appearance. Properties of selected text. Fixed vs. variable owner-draw styles . Graphic object types . Common properties of the Canvas object . Common methods of the Canvas object . Mouse-event parameters . Multimedia device types and their functions . Thread priorities . WaitFor return values . Exception handling compiler\n\n\n\noptions . Selected exception classes. Object model comparison. Equality comparison !A == !B of BOOL variables . Examples of RTTI mappings from Object Pascal to C++. Design-time packages . Package-specific compiler directives . Package-specific command-line linker switches . Compiled package files . VCL objects that support BiDi . Estimating string lengths . Application files . SQL database client software files . Data Dictionary interface . Possible values for the TransIsolation property. Transaction isolation levels . MIDAS components . Connection components . AppServer interface members . Javascript libraries . Provider options . . 1-2 . 2-14 . . . . . . 4-23 . 4-31 . 4-33 . 4-34 . 5-8 . 5-12 . 6-3 . 6-3 . 6-4 . 6-23 . . . . . . . 6-31 . 7-3 . 7-9 . 8-11 . 8-22 . 9-6 . 9-16 . 9-18 . 10-4 . 10-10 . . . . . .\n\n\n\n. 10-12 10-12 . 11-3 . 11-8 . 12-2 . 12-5 . 13-5 . . . . . . . . 14-7 . 14-7 . 15-3 . 15-4 . 15-8 15-28 . 16-3 16.2 16.3 16.4 17.1 UpdateStatus values . UpdateMode values . ProviderFlags values . Database-related informational methods for session components . 17.2 TSessionList properties and methods 19.1 Values for the dataset State property 19.2 Navigational methods of datasets 19.3 Navigational properties of datasets 19.4 Comparison and logical operators that can appear in a filter . 19.5 FilterOptions values 19.6 Filtered dataset navigational methods . 19.7 Dataset methods for inserting, updating, and deleting data . 19.8 Methods that work with entire records . 19.9 Dataset events 19.10 TDBDataSet database and session properties and function . 19.11 Properties, events, and methods for cached updates . 20.1 Field components 20.2 TFloatField properties\n\n\n\nthat affect data display . 20.3 Special persistent field kinds 20.4 Field component properties 20.5 Field component formatting routines . 20.6 Field component events 20.7 Selected field component methods 20.8 Field component conversion functions . 20.9 Special conversion results 20.10 Types of object field components 20.11 Common object field descendant properties . 21.1 Table types recognized by the BDE based on file extension . 21.2 TableType values 21.3 Index-based search methods 21.4 BatchMove import modes 21.5 Batch move modes 24.1 ADO components xxiv . 16-7 . 16-8 . 16-8 . . . . . . 17-8 17-17 . 19-3 . 19-9 19-10 . 19-18 . 19-20 . 19-20 . 19-21 . 19-24 . 19-26 . 19-28 . 19-30 . 20-1 . 20-2 . 20-6 . 20-12 . 20-16 . 20-17 . 20-18 . 20-19 . 20-19 . 20-23 . 20-23 . . . . . . . 21-3 . 21-4 . 21-6 21-19 21-21 . 24-2 24.2\n\n\n\nParameter direction property 25.1 Summary operators for maintained aggregates . 25.2 Client datasets properties and method for handling data requests . 26.1 TUpdateRecordType values 26.2 Return values for UpdateStatus 26.3 UpdateKind values 26.4 UpdateAction values 27.1 Data controls 27.2 Properties affecting editing in data controls . 27.3 Data-aware list box and combo box controls. 27.4 TDBLookupListBox and TDBLookupComboBox properties. 27.5 Column properties 27.6 Expanded TColumn Title properties 27.7 Properties that affect the way ADT and array fields appear in a TDBGrid . 27.8 Expanded TDBGrid Options properties . 27.9 Grid control events 27.10 Selected database control grid properties . 27.11 TDBNavigator buttons 30.1 Web server application components 30.2 MethodType values 32.1 COM object requirements . \n\n\n\n24-23 32.2 C++Builder wizards for implementing COM, Automation, and ActiveX objects. 33.1 Type library pages 35.1 Threading models for COM objects 36.1 IApplicationObject interface members . 36.2 IRequest interface members 36.3 IResponse interface members 36.4 ISessionObject interface members 36.5 IServer interface members 38.1 IObjectContext methods for transaction support . 38.2 Threading models for transactional objects . 38.3 Call synchronization options 39.1 Component creation starting points 40.1 Levels of visibility within an object 41.1 How properties appear in the Object Inspector . 44.1 Canvas capability summary 44.2 Image-copying methods 46.1 Predefined property-editor types 46.2 Methods for reading and writing property values . 46.3 Property-editor attribute flags 46.4 Property categories A.1 Options needed for ANSI\n\n\n\ncompliance A.2 Identifying diagnostics in C++ . 25-10 . . . . . . . . . . . . 25-17 . 26-9 26-10 26-24 26-25 . 27-2 . 27-4 . 27-11 . 27-14 . 27-22 . 27-22 . 27-23 . 27-24 . 27-27 . . . . . . . . . . 27-28 27-29 . 30-5 30-11 32-11 xxv . 32-18 . 33-5 . 35-5 . . . . . . . . . . 36-4 36-4 36-5 36-6 36-6 . 38-12 . . . . 38-18 38-20 . 39-3 . 40-4 . . . . . . . . . . . . . . 46-9 46-10 46-17 . A-1 . A-3 41-2 44-3 44-6 46-8 Figures 2.1 2.3 3.1 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 4.10 4.11 4.12 6.1 9.1 11.1 11.2 11.3 11.4 13.1 13.2 13.3 13.4 14.1 15.1 19.1 19.2 A simplified hierarchy diagram . A progress bar . A simple data module. A frame with data-aware controls and a data source component . Menu terminology. MainMenu and PopupMenu components . Menu Designer for a pop-up menu . Menu Designer for a main menu . Nested menu structures. Select Menu dialog box . Sample Insert\n\n\n\nTemplate dialog box for menus . Save Template dialog box for menus . Action list mechanism. Execution cycle for an action . Action targets . Bitmap-dimension dialog box from the BMPDlg unit . Order of VCL style object construction . TListBox set to bdLeftToRight . TListBox set to bdRightToLeft . TListBox set to bdRightToLeftNoAlign . TListBox set to bdRightToLeftReadingOnly . User-interface to dataset connections in all database applications . Single-tiered database application architectures . Two-tiered database application architectures . Multi-tiered database architectures . Components in a BDE-based application . Web-based multi-tiered database application . C++Builder Dataset hierarchy . Relationship of Inactive and Browse states . . 2-3 . 2-23 . 3-18 . 4-15 . 4-16 . 4-16 . 4-17 . 4-17 . 4-20 . 4-24 . 4-25 . 4-26\n\n\n\n. 4-37 . 4-39 . 4-43 . 6-20 . 9-5 . 11-5 . 11-5 . 11-6 . 11-6 . 13-7 . 13-8 . 13-9 13-10 . 14-2 15-25 . 19-1 . 19-5 19.3 Relationship of Browse to other dataset states . 19.4 Dataset component hierarchy 22.1 Sample master/detail query form and data module at design time . 27.1 TDBGrid control 27.2 TDBGrid control with ObjectView set to false . 27.3 TDBGrid control with Expanded set to false . 27.4 TDBGrid control with Expanded set to true . 27.5 TDBCtrlGrid at design time 27.6 Buttons on the TDBNavigator control . 28.1 Decision support components at design time . 28.2 One-dimensional crosstab 28.3 Three-dimensional crosstab 28.4 Decision graphs bound to different decision sources. 29.1 The structure of a CORBA application 30.1 Parts of a Uniform Resource Locator 30.2 Structure of a Server Application 32.1 A COM interface \n\n\n\n 32.2 Interface vtable 32.3 In-process server 32.4 Out-of-process and remote servers 32.5 COM-based technologies 32.6 Simple COM object interface 32.7 Automation object interface 32.8 ActiveX object interface 33.1 Type Library editor 33.2 Object list pane 35.1 Dual interface VTable 37.1 Mask Edit property page in design mode . 39.1 Visual Component Library class hierarchy. 39.2 Component wizard xxvi . 19-6 19-27 .22-11 27-16 27-23 27-24 27-24 27-28 27-29 . 28-2 . 28-3 . 28-3 28-15 . 29-2 . 30-2 . 30-8 . 32-3 . 32-5 . 32-7 . 32-7 32-10 32-17 32-18 32-18 . 33-3 . 33-4 35-13 37-14 . 39-2 . 39-9 Chapter 1 Introduction Chapter1 The Developer’s Guide describes intermediate and advanced development topics, such as building client/server database applications, writing custom components, creating Internet Web server applications, and\n\n\n\nincluding support for industry-standard specifications such as TCP/IP, OLE, and ActiveX. The Developer’s Guide assumes you are familiar with using C++Builder and understand fundamental C++Builder programming techniques. For an introduction to C++Builder programming and the integrated development environment (IDE), see the Quick Start and the online Help. What’s in this manual? This manual contains five parts, as follows:\n• Part I, “Programming with C++Builder,” describes how to build general-purpose C++Builder applications. This part provides details on programming techniques you can use in any C++Builder application. For example, it describes how to use common Visual Component Library (VCL) objects that make user interface programming easy such as handling strings, manipulating text, implementing the Windows common dialog, toolbars, and cool bars. It also includes chapters on working with graphics, error and exception handling, using DLLs, OLE automation, and writing\n\n\n\ninternational applications. Generally, it rarely matters that C++Builder’s underlying VCL is written in Object Pascal. However, there are a few instances where it affects your C++Builder programs. A chapter on C++ language support and the VCL details such language issues as how C++ class instantiation differs when using VCL classes and the C++ language extensions added to support the C++Builder “component-property-event” model of programming. The chapter on deployment details the tasks involved in deploying your application to your application users. For example, it includes information on effective compiler options, using InstallShield Express, licensing issues, and how Introduction 1-1 M a n http://www.doksihu ual conventions Forrás: to determine which packages, DLLs, and other libraries to use when building the production-quality version of your application.\n• Part II, “Developing database applications,” describes how to build database applications using database\n\n\n\ntools and components. C++Builder lets you access many types of databases. With the forms and reports you create, you can access local databases such as Paradox and dBASE, network SQL server databases like InterBase and Sybase, and any data source accessible through open database connectivity (ODBC) or ActiveX Data Objects (ADO).\n• Part III, “Writing distributed applications,” describes how to create Web server applications as CGI applications or dynamic-link libraries (DLLs). C++Builder provides Internet-specific components that make it easy to handle events associated with a specific Uniform Resource Identifier (URI) and to programmatically construct HTML documents. This part also provides a chapter on the C++Builder socket components that let you create applications that can communicate with other systems using TCP/IP and related protocols. Sockets provide connections based on the TCP/IP protocol, but are sufficiently general to work with related protocols such as Xerox Network\n\n\n\nSystem (XNS), Digital’s DECnet, or Novell’s IPX/SPX family.\n• Part IV, “Developing COM-based applications,” describes how to build applications that can interoperate with other COM-based API objects. C++Builder supports COM applications that are based on the Active Template Library (ATL). Wizards and a Type Library editor ease the development of COM servers, and an importing tool lets you quickly create client applications. Support for COM clients is available in all editions of C++Builder. To create COM servers, you need the Professional or Enterprise edition.\n• Part V, “Creating custom components,” describes how to design and implement your own components, and how to make them available on the Component palette of the IDE. A component can be almost any program element that you want to manipulate at design time. Implementing custom components entails deriving a new class from an existing class type in the VCL class library. Manual conventions This manual uses the\n\n\n\ntypefaces and symbols described in Table 1.1 to indicate special text. Table 1.1 Typefaces and symbols Typeface or symbol Meaning Monospace type [] Boldface 1-2 Developer’s Guide Monospaced text represents text as it appears on screen or in C++ code. It also represents anything you must type. Square brackets in text or syntax listings enclose optional items. Text of this sort should not be typed verbatim. Boldfaced words in text or code listings represent C++ reserved words or compiler options. Manual conventions Table 1.1 Typefaces and symbols (continued) Typeface or symbol Meaning Italics Italicized words in text represent C++ identifiers, such as variable or type names. Italics are also used to emphasize certain words, such as new terms Keycaps This typeface indicates a key on your keyboard. For example, “Press Esc to exit a menu.” Contacting developer support Inprise offers a variety of support options. These include free services on the Internet, where you\n\n\n\ncan search our extensive information base and connect with other users of Borland products. In addition, you can choose from several categories of support, ranging from support on installation of the Borland product to fee-based consultant-level support and detailed assistance. For more information about Inprise’s developer support services, please see our Web site at http://www.borlandcom/devsupport, call Borland Assist at (800) 523-7070, or contact our Sales Department at (831) 431-1064. For customers outside of the United States of America, see our web site at http://www.borlandcom/bww/ intlcust.html When contacting support, be prepared to provide complete information about your environment, the version of the product you are using, and a detailed description of the problem. For information about year 2000 issues and our products, see the following URL: http://www.borlandcom/about/y2000/ Introduction 1-3 1-4 Developer’s Guide Part I Programming with C++Builder Part\n\n\n\nI The chapters in “Programming with C++Builder” present concepts and skills necessary for creating C++Builder applications using any edition of the product. Programming with C++Builder Chapter 2 Programming with C++Builder Chapter2 Borland C++Builder is an object-oriented, visual programming environment for rapid development of 32-bit Windows applications. Using C++Builder, you can create highly efficient Windows applications with a minimum of manual coding. C++Builder provides a comprehensive class library called the Visual Component Library (VCL) and a suite of Rapid Application Development (RAD) design tools, including application and form templates, and programming wizards. C++Builder supports truly object-oriented programming: the class library includes objects that encapsulate the Windows API as well as other useful programming techniques. This chapter briefly describes the C++Builder development environment, presents a brief overview of the Visual Component\n\n\n\nLibrary, and touches on many of the components in the VCL that are available to you. The rest of this manual provides technical details on developing general-purpose, database, Internet and intranet applications, and includes information on writing your own components, and creating ActiveX and COM controls. The integrated development environment When you start C++Builder, you are immediately placed within the integrated development environment, also called the IDE. This environment provides all the tools you need to design, develop, test, debug, and deploy applications. C++Builder’s development environment includes a visual form designer, Object Inspector, Component palette, Project Manager, source code editor, debugger, and installation tool. You can move freely from the visual representation of an object (in the form designer), to the Object Inspector to edit the initial runtime state of the object, to the source code editor to edit the execution logic of the object. Changing\n\n\n\ncode-related properties, such as the name of an event handler, in the Object Inspector automatically changes the corresponding source code. In addition, changes to the source code, such as renaming an event handler method in a form class declaration, is immediately reflected in the Object Inspector. Programming with C++Builder 2-1 D e s http://www.doksihu igning applications Forrás: Designing applications C++Builder includes all the tools necessary to start designing applications:\n• A blank window, known as a form, on which to design the UI for your application.\n• An extensive class library with many reusable objects.\n• An Object Inspector for examining and changing object traits.\n• A Code editor that provides direct access to the underlying program logic.\n• A Project Manager for managing the files that make up one or more projects.\n• Many other tools such as an image editor on the toolbar and an integrated debugger on menus to support application development in the\n\n\n\nIDE.\n• Command-line tools including compilers, linkers, and other utilities. You can use C++Builder to design any kind of 32-bit Windows applicationfrom general-purpose utilities to sophisticated data access programs or distributed applications. C++Builder’s database tools and data-aware components let you quickly develop powerful desktop database and client/server applications. Using C++Builder’s data-aware controls, you can view live data while you design your application and immediately see the results of database queries and changes to the application interface. Chapter 3, “Building applications, components, and libraries” introduces C++Builder’s support for different types of applications. Understanding the VCL The Visual Component Library (VCL) is based on the properties, methods, and events (PME) model. The PME model defines the data members (properties), the functions that operate on the data (methods), and a way to interact with users of the class (events). The\n\n\n\nVCL is a hierarchy of objects, written in Object Pascal and tied to the C++Builder IDE, that allows you to develop applications quickly. Using C++Builder’s Component palette and Object Inspector, you can place VCL components on forms and specify their properties without writing code. Properties Properties are characteristics of components. You can see and change properties at design time and get immediate feedback as the components react in the IDE. Well-designed properties make your components easier for others to use and easier for you to maintain. Methods Methods are functions that are members of a class. Class methods can access all the public, protected, and private properties and data members of the class and are commonly referred to as member functions. 2-2 Developer’s Guide Objects, components, and controls in the VCL Events Event driven programming (EDP) means just thatprogramming by responding to events. In essence, event driven means that the program does not\n\n\n\nrestrict what the user can do next. For example, in a Windows program, the programmer has no way of knowing the sequence of actions the user will perform next. They may pick a menu item, click a button, or mark some text. So, EDP means that you write code to handle whatever events occur that you’re interested in, rather than write code that always executes in the same restricted order. The kinds of events that can occur can be divided into two main categories:\n• User events\n• System events Regardless of how the event was called, C++Builder looks to see if you have assigned any code to handle that event. If you have, then that code is executed; otherwise, nothing is done. User events User events are actions that are initiated by the user. Examples of user events are OnClick (the user clicked the mouse), OnKeyPress (the user pressed a key on the keyboard), and OnDblClick (the user double-clicked a mouse button). These events are always tied to a user’s actions. System events\n\n\n\nSystem events are events that the operating system fires for you. For example, the OnTimer event (the Timer component issues one of these events whenever a predefined interval has elapsed), the OnCreate event (the component is being created), the OnPaint event (a component or window needs to be redrawn), etc. Usually, system events are not directly initiated by a user action. Objects, components, and controls in the VCL Figure 2.1 is a summary of the Visual Component Library that shows the five major branches of the inheritance tree. Figure 2.1 A simplified hierarchy diagram Programming with C++Builder 2-3 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: The next few sections present a general description of the types of classes that each branch contains. For a complete overview of the VCL object hierarchy, refer to the VCL Object Hierarchy wall chart that is included with this product. The TObject branch All VCL objects descend from TObject, an\n\n\n\nabstract class whose methods define fundamental behavior like construction, destruction, and message handling. Much of the powerful capability of VCL objects are established by the methods that TObject introduces. TObject encapsulates the fundamental behavior common to all objects in the VCL, by introducing methods that provide:\n• The ability to respond when objects are created or destroyed.\n• Class type and instance information on an object, and runtime type information (RTTI) about its published properties.\n• Support for message-handling. TObject is the immediate ancestor of many simple classes. Classes that are contained within this branch have one common, important characteristic, they are transitory. What this means, is that these classes do not have a method to save the state that they are in prior to destruction, they are not persistent. One of the main groups of classes in this branch is the Exception class. This class provides a large set of built-in exception classes\n\n\n\nfor automatically handling divide-by-zero errors, file I/O errors, invalid typecasts, and many other exception conditions. Another type of group in the TObject branch are classes that are encapsulated data structures, such as:\n• TBits, a class that stores an “array” of Boolean values\n• TList, a linked list class\n• TStack, a class that maintains a last-in first-out array of pointers\n• TQueue, a class that maintains a first-in first-out array of pointers You can also find wrappers around external objects like TPrinter, which encapsulates the Windows printer interface, and TRegistry, a low-level wrapper for the system registry and functions that operate on the registry. TStream is good example of another type of class in this branch. TStream is the base class type for stream objects that can read from or write to various kinds of storage media, such as disk files, dynamic memory, and so on. So you can see, this branch includes many different types of classes that are very\n\n\n\nuseful to you as a developer. 2-4 Developer’s Guide Objects, components, and controls in the VCL The TPersistent branch Directly below TObject in the VCL hierarchy is TPersistent. TPersistent adds two very important methods to all classes based on itSaveToStream and LoadFromStream. These methods supply persistence to objects. For example, when the form designer needs to create a DFM file (a file used to store information about the components on the form), it loops through its components array and calls SaveToStream for all the components on the form. Each component “knows” how to write its changed properties out to a stream (in this case, a text file). Conversely, when the form designer needs to load the properties for components from the DFM file, it loops through the components array and calls LoadFromStream for each component. Thus, any class derived from TPersistent has the ability to save its state information and restore it on demand. The types of classes in this\n\n\n\nbranch include:\n• TGraphicsObject, an abstract base class for objects which encapsulate Windows graphics objects: TBrush, TFont, and TPen.\n• TGraphic, an abstract base class type for objects such as icons, bitmaps, and metafiles that can store and display visual images: TBitmap, TIcon, and TMetaFile.\n• TStrings, a base class for objects that represent a list of strings.\n• TClipboard, a wrapper for the Windows clipboard, which contains text or graphics that have been cut or copied from an application.\n• TCollection, TOwnedCollection, and TCollectionItem, maintained indexed collections of specially defined items. The TComponent branch TComponent is the common ancestor of all VCL components. Components are objects that you can manipulate on forms at design time. Despite its name, the VCL consists mostly of nonvisual objects. VCL components are persistent objects that have the following capabilities:\n• The ability to appear on the Component palette and be changed in the form\n\n\n\ndesigner.\n• The ability to own and manage other components.\n• Enhanced streaming and filing capabilities.\n• The ability to be converted into an ActiveX control or other COM object by wizards on the ActiveX page of the New Objects dialog. TComponent acts as the standard “bus” that all components plug into. There are several methods in TComponent that dictate how components act during design time. This is also where the Name and Owner properties are introduced. Every component derived from TComponent has a Name and an Owner property. The owner is responsible for deleting the component. Programming with C++Builder 2-5 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Components that do not need a visual interface are derived directly from TComponent. The types of classes that can be found in this branch include:\n• TMainMenu, a class that provides a menu bar and its accompanying drop-down menus for a form.\n• TTimer, a class that includes the\n\n\n\nWindows API timer functions.\n• TOpenDialog, TSaveDialog, TFontDialog, TFindDialog, TColorDialog, and so on, the common windows dialog boxes.\n• TActionList, a class that maintains a list of actions used with components and controls, such as menu items and buttons.\n• TScreen, a class that keeps track of what forms and data modules have been instantiated by the application, the active form, and the active control within that form, the size and resolution of the screen, and the cursors and fonts available for the application to use. The TControl branch All controls are visual objects, meaning the user can see them and manipulate them at runtime. All controls have properties, methods, and events in common that are specific to the visual aspect of controls, such as the position of the control, the cursor or hint associated with the control’s window, methods to paint or move the control, and events to respond to mouse actions. Whereas TComponent defines behavior for all components,\n\n\n\nTControl defines behavior for all visual controls. This includes drawing routines, standard Windows events, and containership. One group of classes in this branch is called TGraphicControls. TGraphicControls are controls that must draw themselves and can never receive focus. The types of controls that can be found in this group include:\n• TImage, a control that displays graphical images.\n• TLabel, a control that displays text on a form.\n• TBevel, a control that represents a beveled outline.\n• TPaintBox, a control that provides a canvas that applications can use for drawing or rendering an image. Notice that these include the common paint routines (Paint, RePaint, Invalidate, etc.) but C++Builder doesn’t have to allocate a window handle for them because they never need to receive focus. 2-6 Developer’s Guide Objects, components, and controls in the VCL The TWinControl branch TWinControl is the base class for all windowed controls. The following are features of\n\n\n\nwindowed controls:\n• Windowed controls are controls that can receive focus while the application is running.\n• Other controls may display data, but the user can use the keyboard to interact with a control only if the control is a windowed control.\n• Windowed controls can contain other controls.\n• A control that contains other controls is a parent. Only a windowed control can be a parent of one or more other child controls.\n• Windowed controls have a window handle. TWinControls are like TControls except they can receive focus. This means that there are many more standard events that apply to them and that Windows must allocate a window handle for them. This branch includes both controls that are drawn automatically by Windows (including TEdit, TListBox, TComboBox, TPageControl, and so on) and custom controls that C++Builder must draw (including TDBNavigator, TMediaPlayer, TGauge, and so on). However, you never have to worry about any of the implementation details of how the\n\n\n\ncontrols render themselves or how they respond to eventsC++Builder completely encapsulates this behavior for you. The following sections provide an overview of controls. Refer to Chapter 5, “Working with controls” for more information on using controls. Properties common to TControl All visual controls (descendants of TControl) share certain properties including:\n• \n• \n• \n• \n• \n• \n• Position, size, and alignment properties Display properties Parent properties A navigation property Drag-and-drop properties Drag-and-dock properties Action properties While these properties are inherited from TControl, they are publishedand hence appear in the Object Inspectoronly for components to which they are applicable. For example, TImage does not publish the Color property, since its color is determined by the graphic it displays. Programming with C++Builder 2-7 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Action properties Actions let you share\n\n\n\ncommon code for performing actions (for example, when a tool bar button and menu item do the same thing), as well as providing a single, centralized way to enable and disable actions depending on the state of your application.\n• Action designates the action associated with the control.\n• ActionLink contains the action link object associated with the control. Position, size, and alignment properties This set of properties defines the position and size of a control on the parent control:\n• Height sets the vertical size.\n• Width sets the horizontal size.\n• Top positions the top edge.\n• Left positions the left edge.\n• AutoSize specifies whether the control sizes itself automatically to accommodate its contents.\n• Align determines how the control aligns within its container (parent control).\n• Anchor specifies how the control is anchored to its parent. This set of properties determine the height, width, and overall size of the control’s client area:\n• ClientHeight\n\n\n\nspecifies the height of the control’s client area in pixels.\n• CleintWidth specifies the width of the control’s client area in pixels. These properties aren’t accessible in nonvisual components, but C++Builder does keep track of where you place the component icons on your forms. Most of the time you’ll set and alter these properties by manipulating the control’s image on the form or using the Alignment palette. You can, however, alter them at runtime Display properties The following properties govern the general appearance of a control:\n• Color changes the background color of a control.\n• Font changes the color, type family, style, or size of text.\n• Cursor specifies the image used to represent the mouse pointer when it passes into the region covered by the control.\n• DesktopFont specifies whether the control uses the Windows icon font when writing text. 2-8 Developer’s Guide Objects, components, and controls in the VCL Parent properties To maintain a\n\n\n\nconsistent appearance across your application, you can make any control look like its containercalled its parentby setting the parent properties to true.\n• ParentColor determines where a control looks for its color information.\n• ParentFont determines where a control looks for its font information.\n• ParentShowHint determines where a control looks to find out if its Help Hint should be shown. A navigation property The following property determines how users navigate among the controls in a form:\n• Caption contains the text string that labels a component. To underline a character in a string, include an ampersand (&) before the character. This type of character is called an accelerator key. The user can then select the control or menu item by pressing Alt while typing the underlined character. Drag-and-drop properties Two component properties affect drag-and-drop behavior:\n• DragMode determines how dragging starts. By default, DragMode is dmManual, and the application\n\n\n\nmust call the BeginDrag method to start dragging. When DragMode is dmAutomatic, dragging starts as soon as the mouse button goes down.\n• DragCursor determines the shape of the mouse pointer when it is over a draggable component. Drag-and-dock properties The following properties control drag-and-dock behavior:\n• Floating indicates whether the control is floating.\n• DragKind specifies whether the control is being dragged normally or for docking.\n• DragMode determines how the control initiates drag-and-drop or drag-and-dock operations.\n• FloatingDockSiteClass specifies the class of the temporary control that hosts the control when it is floating.\n• DragCursor is the cursor that is shown while dragging.\n• DockOrientation specifies how the control is docked relative to other controls docked in the same parent.\n• HostDockSite specifies the control in which the control is docked. For more information, see “Implementing drag-and-dock in controls” on page 5-4. Programming\n\n\n\nwith C++Builder 2-9 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Standard events common to TControl The VCL defines a set of standard events for its controls. The following events are declared as part of the TControl class, and are therefore available for all classes derived from TControl:\n• OnClick occurs when the user clicks the control.\n• OnContextPopup occurs when the user right-clicks the control or otherwise invokes the popup menu (such as using the keyboard).\n• OnCanResize occurs when an attempt is made to resize the control.\n• OnResize occurs immediately after the control is resized.\n• OnConstrainedResize occurs immediately after OnCanResize.\n• OnStartDock occurs when the user begins to drag a control with a DragKind of dkDock.\n• OnEndDock occurs when the dragging of an object ends, either by docking the object or by canceling the dragging.\n• OnStartDrag occurs when the user begins to drag the control or an object it contains\n\n\n\nby left-clicking on the control and holding the mouse button down.\n• OnEndDrag occurs when the dragging of an object ends, either by dropping the object or by canceling the dragging.\n• OnDragDrop occurs when the user drops an object being dragged.\n• OnMouseMove occurs when the user moves the mouse pointer while the mouse pointer is over a control.\n• OnDblClick occurs when the user double-clicks the primary mouse button when the mouse pointer is over the control.\n• OnDragOver occurs when the user drags an object over a control.\n• OnMouseDown Occurs when the user presses a mouse button with the mouse pointer over a control.\n• OnMouseUpOccurs when the user releases a mouse button that was pressed with the mouse pointer over a component. Properties common to TWinControl All windowed controls (descendants of TWinControl) share certain properties including:\n• \n• \n• \n• Information about the control Border style display properties Navigation properties Drag-and-dock\n\n\n\nproperties While these properties are inherited from TWinControl, they are publishedand hence appear in the Object Inspectoronly for controls to which they are applicable. 2-10 Developer’s Guide Objects, components, and controls in the VCL General information properties The general information properties contain information about the appearance of the TWinControl, client area size and origin, windows assigned information, and mouse wheel information.\n• ClientOrigin specifies the screen coordinates (in pixels) of the top left corner of a control’s client area. The screen coordinates of a control that is descended from TControl and not TWinControl are the screen coordinates of the control’s parent added to its Left and Top properties.\n• ClientRect returns a rectangle with its Top and Left properties set to zero, and its Bottom and Right properties set to the control’s Height and Width, respectively. ClientRect is equivalent to Rect(0, 0, ClientWidth, ClientHeight).\n• Brush determines the color and pattern used for painting the background of the control.\n• Handle provides access to the window handle of the control.\n• WindowHandle also provides access to a window handle for the control.\n• HelpContext provides a context number for use in calling context-sensitive online Help.\n• Controls lists all children of the windowed control. Border style display properties The bevel properties control the appearance of the beveled lines, boxes, or frames on the forms and windowed controls in your application.\n• InnerBevel specifies whether the inner bevel has a raised, lowered, or flat look.\n• BevelKind specifies the type of bevel if the control has beveled edges.\n• BevelOuter specifies whether the outer bevel has a raised, lowered, or flat look.\n• BevelWidth specifies the width, in pixels, of the inner and outer bevels.\n• BorderWidth is used to get or set the width of the control’s border.\n• BevelEdges is used to get or set which edges\n\n\n\nof the control are beveled. Navigation properties Two additional properties determine how users navigate among the controls in a form:\n• TabOrder indicates the position of the control in its parent’s tab order, the order in which controls receive focus when the user presses the Tab key. Initially, tab order is the order in which the components are added to the form, but you can change this by changing TabOrder. TabOrder is meaningful only if TabStop is true\n• TabStop determines whether the user can tab to a control. If TabStop is true, the control is in the tab order. Programming with C++Builder 2-11 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Drag-and-dock properties The following properties manage drag-and-dock behavior:\n• UseDockManager specifies whether the dock manager is used in drag-and-dock operations.\n• VisibleDockClientCount specifies the number of visible controls that are docked on the windowed control.\n• DockManager\n\n\n\nspecifies the control’s dock manager interface.\n• DockClients lists the controls that are docked to the windowed control.\n• DockSite specifies whether the control can be the target of drag-and-dock operations. For more information, see “Implementing drag-and-dock in controls” on page 5-4. Events common to TWinControl The following events exist for all controls derived from TWinControl (which also includes all the controls that Windows defines). These events are in addition to those that exist in all controls.\n• OnEnter occurs when the control is about to receive focus.\n• OnKeyDown occurs on the down stroke of a key press.\n• OnKeyPress occurs when a user presses a single character key.\n• OnKeyUp occurs when the user releases a key that has been pressed.\n• OnExit occurs when the input focus shifts away from one control to another.\n• OnDockDrop occurs when another control is docked to the control.\n• OnDockOver occurs when another control is dragged over the\n\n\n\ncontrol.\n• OnGetSiteInfo returns the control’s docking information.\n• OnMouseWheel occurs when the mouse wheel is rotated.\n• OnMouseWheelDown occurs when the mouse wheel is rotated downward.\n• OnMouseWheelUp occurs when the mouse wheel is rotated upward.\n• OnUnDock occurs when the application tries to undock a control that is docked to a windowed control. Creating the application user interface All visual design work in C++Builder takes place on forms. When you open C++Builder or create a new project, a blank form is displayed on the screen. You can use it to start building your application interface including windows, menus, and common dialogs. You design the look and feel of the graphical user interface for an application by placing and arranging visual components such as buttons and list boxes on the form. C++Builder takes care of the underlying programming details. You can also place 2-12 Developer’s Guide Objects, components, and controls in the VCL invisible\n\n\n\ncomponents on forms to capture information from databases, perform calculations, and manage other interactions. Chapter 4, “Developing the application user interface” provides details on using forms such as creating modal forms dynamically, passing parameters to forms, and retrieving data from forms. Using components Many visual components are provided in the development environment itself on the Component palette. You select components from the Component palette and drop them onto the form to design the application user interface. Once a visual component is on the form, you can adjust its position, size, and other design-time properties. C++Builder components are grouped functionally on the different pages of the Component palette. For example, commonly used components such as those to create menus, edit boxes, or buttons are located on the Standard page of the Component palette. Handy controls such as a timer, paint box, media player, and OLE container are on the System page. At\n\n\n\nfirst glance, C++Builder’s components appear to be just like any other C++ class. But there are differences between components in C++Builder and the standard C++ class hierarchies that most C++ programmers work with. Some differences are described here:\n• All C++Builder components descend from TComponent.\n• Components are most often used as is and are changed through their properties, rather than serving as “base classes” to be subclassed to add or change functionality. When a component is inherited, it is usually to add specific code to existing event handling member functions.\n• VCL components can only be allocated on the heap, not on the stack (that is, they must be created with the new operator).\n• Properties of components intrinsically contain runtime type information.\n• Components can be added to the Component palette in the C++Builder user interface and manipulated on a form. Components often achieve a better degree of encapsulation than is usually found in\n\n\n\nstandard C++ classes. For example, consider the use of a dialog containing a push button. In a C++ Windows program, when a user clicks on the button, the system generates a WM LBUTTONDOWN message. The program must catch this message (typically in a switch statement, a message map, or a response table) and dispatch it to a routine that will execute in response to the message. Most Windows messages are handled by C++Builder components. When you want to respond to a Windows message, you only need to provide an event handler. Chapter 9, “C++ language support for the VCL” provides details on extensions to the C++ language that enable you to use the VCL. Programming with C++Builder 2-13 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: VCL standard components The Component palette contains a selection of components that handle a wide variety of programming tasks. You can add, remove, and rearrange components on the palette, and you can create component\n\n\n\ntemplates and frames that group several components. The components on the palette are arranged in pages according to their purpose and functionality. Which pages appear in the default configuration depends on the version of C++Builder you are running. Table 21 lists typical default pages and the types of components they contain. Table 2.1 Component palette pages Page name Contents Standard Standard Windows controls, menus Additional Additional controls Win32 Windows 9x/NT 4.0 common controls System Components and controls for system-level access, including timers, multimedia, and DDE Data Access Nonvisual components for accessing database tables, queries, and reports Data Controls Visual, data-aware controls ADO Components that provide data access through the ADO framework InterBase Components that provide direct access to InterBase Midas Components used for creating multi-tiered database applications Internet Express Components that are simultaneously a Web\n\n\n\nServer application and the client of a multi-tiered database application Internet Components for internet communication protocols and Web applications FastNet NetMasters Internet controls Decision Cube Controls that let you summarize information from databases and view it from a variety of perspectives QReport QuickReport components for creating embedded reports Dialogs Windows common dialog boxes Win 3.1 Old style Win 3.1 components Samples Sample custom components ActiveX Sample ActiveX controls Servers Ole Servers for Microsoft Excel, Word, and so on The online Help provides information about the components on the default palette. Some of the components on the ActiveX and Samples pages, however, are provided as examples only and are not documented. 2-14 Developer’s Guide Objects, components, and controls in the VCL Text controls Many applications present text to the user or allow the user to enter text. The type of control used for this purpose depends on\n\n\n\nthe size and format of the information. Use this component: When you want users to do this: Edit Edit a single line of text Memo Edit multiple lines of text MaskEdit Adhere to a particular format, such as a postal code or phone number RichEdit Edit multiple lines of text using rich text format Properties common to all text controls All of the text controls have these properties in common:\n• Text determines the text that appears in the edit box or memo control.\n• CharCase forces the case of the text being entered to lowercase or uppercase.\n• ReadOnly specifies whether the user is allowed to change the text.\n• MaxLength limits the number of characters in the control.\n• PasswordChar hides the text by displaying a single character (usually an asterisk).\n• HideSelection specifies whether selected text remains highlighted when the control does not have focus. Properties shared by memo and rich text controls Memo and rich text controls, which handle multiple lines of\n\n\n\ntext, have several properties in common:\n• Alignment specifies how text is aligned (left, right, or center) in the component.\n• The Text property contains the text in the control. Your application can tell if the text changes by checking the Modified property.\n• Lines contains the text as a list of strings.\n• OEMConvert determines whether the text is temporarily converted from ANSI to OEM as it is entered. This is useful for validating file names\n• WordWrap determines whether the text will wrap at the right margin.\n• WantReturns determines whether the user can insert hard returns in the text.\n• WantTabs determines whether the user can insert tabs in the text.\n• AutoSelect determines whether the text is automatically selected (highlighted) when the control becomes active.\n• SelText contains the currently selected (highlighted) part of the text.\n• SelStart and SelLength indicate the position and length of the selected part of the text. At runtime, you can select all\n\n\n\nthe text in the memo with the SelectAll method. Programming with C++Builder 2-15 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Rich text controls The rich edit component is a memo control that supports rich text formatting, printing, searching, and drag-and-drop of text. It allows you to specify font properties, alignment, tabs, indentation, and numbering. Specialized input controls The following components provide additional ways of capturing input. Use this component: When you want users to do this: ScrollBar Select values on a continuous range TrackBar Select values on a continuous range (more visually effective than a scroll bar) UpDown Select a value from a spinner attached to an edit component HotKey Enter Ctrl/Shift/Alt keyboard sequences Scroll bars The scroll bar component is a Windows scroll bar that you can use to scroll the contents of a window, form, or other control. In the OnScroll event handler, you write code that\n\n\n\ndetermines how the control behaves when the user moves the scroll bar. The scroll bar component is not used very often, since many visual components provide scroll bars of their own that don’t require additional coding. For example, TForm has VertScrollBar and HorzScrollBar properties that automatically configure scroll bars on the form. To create a scrollable region within a form, use TScrollBox Track bars A track bar can set integer values on a continuous range. It is useful for adjusting properties like color, volume and brightness. The user moves the slide indicator by dragging it to a particular location or clicking within the bar.\n• Use the Max and Min properties to set the upper and lower range of the track bar.\n• Use SelEnd and SelStart to highlight a selection range. See Figure 22 Figure 2.2 Three views of the track bar component\n• The Orientation property determines whether the track bar is vertical or horizontal.\n• By default, a track bar has one row of ticks\n\n\n\nalong the bottom. Use the TickMarks property to change their location. To control the intervals between ticks, use the TickStyle property and SetTicks method.\n• Position sets a default position for the track bar and tracks the position at runtime.\n• By default, users can move one tick up or down by pressing the up and down arrow keys. Set LineSize to change that increment\n• Set PageSize to determine the number of ticks moved when the user presses Page Up and Page Down. 2-16 Developer’s Guide Objects, components, and controls in the VCL Up-down controls An up-down control consists of a pair of arrow buttons that allow users to change an integer value in fixed increments. The current value is given by the Position property; the increment, which defaults to 1, is specified by the Increment property. Use the Associate property to attach another component (such as an edit control) to the up-down control. Hot key controls Use the hot key component to assign a keyboard shortcut\n\n\n\nthat transfers focus to any control. The HotKey property contains the current key combination and the Modifiers property determines which keys are available for HotKey. Splitter control A splitter placed between aligned controls allows users to resize the controls. Used with components like panels and group boxes, splitters let you divide a form into several panes with multiple controls on each pane. After placing a panel or other control on a form, add a splitter with the same alignment as the control. The last control should be client-aligned, so that it fills up the remaining space when the others are resized. For example, you can place a panel at the left edge of a form, set its Alignment to alLeft, then place a splitter (also aligned to alLeft) to the right of the panel, and finally place another panel (aligned to alLeft or alClient) to the right of the splitter. Set MinSize to specify a minimum size the splitter must leave when resizing its neighboring control. Set Beveled to\n\n\n\ntrue to give the splitter’s edge a 3D look Buttons and similar controls Aside from menus, buttons provide the most common way to invoke a command in an application. C++Builder offers several button-like controls: Use this component: To do this: Button Present command choices on buttons with text BitBtn Present command choices on buttons with text and glyphs SpeedButton Create grouped toolbar buttons CheckBox Present on/off options RadioButton Present a set of mutually exclusive choices ToolBar Arrange tool buttons and other controls in rows and automatically adjust their sizes and positions CoolBar Display a collection of windowed controls within movable, resizable bands Button controls Users click button controls to initiate actions. Double-clicking a button at design time takes you to the button’s OnClick event handler in the Code editor.\n• Set Cancel to true if you want the button to trigger its OnClick event when the user presses Esc.\n• Set Default to true\n\n\n\nif you want the Enter key to trigger the button’s OnClick event. Programming with C++Builder 2-17 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Bitmap buttons A bitmap button (BitBtn) is a button control that presents a bitmap image on its face.\n• To choose a bitmap for your button, set the Glyph property.\n• Use Kind to automatically configure a button with a glyph and default behavior.\n• By default, the glyph is to the left of any text. To move it, use the Layout property\n• The glyph and text are automatically centered in the button. To move their position, use the Margin property. Margin determines the number of pixels between the edge of the image and the edge of the button.\n• By default, the image and the text are separated by 4 pixels. Use Spacing to increase or decrease the distance.\n• Bitmap buttons can have 3 states: up, down, and held down. Set the NumGlyphs property to 3 to show a different bitmap for each state. Speed buttons\n\n\n\nSpeed buttons, which usually have images on their faces, can function in groups. They are commonly used with panels to create toolbars.\n• To make speed buttons act as a group, give the GroupIndex property of all the buttons the same nonzero value.\n• By default, speed buttons appear in an up (unselected) state. To initially display a speed button as selected, set the Down property to true.\n• If AllowAllUp is true, all of the speed buttons in a group can be unselected. Set AllowAllUp to false if you want a group of buttons to act like a radio group. Check boxes A check box is a toggle that presents the user with two, or sometimes three, choices.\n• Set Checked to true to make the box appear checked by default.\n• Set AllowGrayed to true to give the check box three possible states: checked, unchecked, and grayed.\n• The State property indicates whether the check box is checked (cbChecked), unchecked (cbUnchecked), or grayed (cbGrayed). Radio buttons Radio buttons present a set\n\n\n\nof mutually exclusive choices. You can use individual radio buttons or the radio group component, which arranges groups of radio buttons automatically. See “Grouping components” on page 2-21 for more information Toolbars Toolbars provide an easy way to arrange and manage visual controls. You can create a toolbar out of a panel component and speed buttons, or you can use the ToolBar component, then right-click and choose New Button to add buttons to the toolbar. The ToolBar component has several advantages: buttons on a toolbar automatically 2-18 Developer’s Guide Objects, components, and controls in the VCL maintain uniform dimensions and spacing; other controls maintain their relative position and height; controls can automatically wrap around to start a new row when they do not fit horizontally; and the ToolBar offers display options like transparency, pop-up borders, and spaces and dividers to group controls. Cool bars A cool bar contains child controls that can be\n\n\n\nmoved and resized independently. Each control resides on an individual band. The user positions the controls by dragging the sizing grip to the left of each band. The cool bar requires version 4.70 or later of COMCTL32DLL (usually located in the WindowsSystem or WindowsSystem32 directory) at both design time and runtime.\n• The Bands property holds a collection of TCoolBand objects. At design time, you can add, remove, or modify bands with the Bands editor. To open the Bands editor, select the Bands property in the Object Inspector, then double-click in the Value column to the right, or click the ellipsis (.) button You can also create bands by adding new windowed controls from the palette.\n• The FixedOrder property determines whether users can reorder the bands.\n• The FixedSize property determines whether the bands maintain a uniform height. Handling lists Lists present the user with a collection of items to select from. Several components display lists: Use this component: To\n\n\n\ndisplay: ListBox A list of text strings CheckListBox A list with a check box in front of each item ComboBox An edit box with a scrollable drop-down list TreeView A hierarchical list ListView A list of (draggable) items with optional icons, columns, and headings DateTimePicker A list box for entering dates or times MonthCalendar A calendar for selecting dates Use the nonvisual TStringList and TImageList components to manage sets of strings and images. For more information about string lists, see “Working with string lists” on page 2-27. List boxes and check-list boxes List boxes and check-list boxes display lists from which users can select items.\n• Items uses a TStrings object to fill the control with values.\n• ItemIndex indicates which item in the list is selected.\n• MultiSelect specifies whether a user can select more than one item at a time. Programming with C++Builder 2-19 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: •\n\n\n\nSorted determines whether the list is arranged alphabetically.\n• Columns specifies the number of columns in the list control.\n• IntegralHeight specifies whether the list box shows only entries that fit completely in the vertical space.\n• ItemHeight specifies the height of each item in pixels. The Style property can cause ItemHeight to be ignored.\n• The Style property determines how a list control displays its items. By default, items are displayed as strings. By changing the value of Style, you can create owner-draw list boxes that display items graphically or in varying heights. For information on owner-draw controls, see “Adding graphics to controls” on page 5-11. Combo boxes A combo box combines an edit box with a scrollable list. When users enter data into the controlby typing or selecting from the listthe value of the Text property changes.\n• Use the Style property to select the type of combo box you need.\n• Use csDropdown if you want an edit box with a drop-down\n\n\n\nlist. Use csDropDownList to make the edit box read-only (forcing users to choose from the list). Set the DropDownCount property to change the number of items displayed in the list.\n• Use csSimple to create a combo box with a fixed list that does not close. Be sure to resize the combo box so that the list items are displayed.\n• Use csOwnerDrawFixed or csOwnerDrawVariable to create owner-draw combo boxes that display items graphically or in varying heights. For information on owner-draw controls, see “Adding graphics to controls” on page 5-11. Tree views A tree view displays items in an indented outline. The control provides buttons that allow nodes to be expanded and collapsed. You can include icons with items’ text labels and display different icons to indicate whether a node is expanded or collapsed. You can also include graphics, such as check boxes, that reflect state information about the items.\n• Indent sets the number of pixels horizontally separating items from\n\n\n\ntheir parents.\n• ShowButtons enables the display of ‘+’ and ‘–’ buttons to indicate whether an item can be expanded.\n• ShowLines enables display of connecting lines to show hierarchical relationships.\n• ShowRoot determines whether lines connecting the top-level items are displayed. 2-20 Developer’s Guide Objects, components, and controls in the VCL List views List views display lists in various formats. Use the ViewStyle property to choose the kind of list you want:\n• vsIcon and vsSmallIcon display each item as an icon with a label. Users can drag items within the list view window.\n• vsList displays items as labeled icons that cannot be dragged.\n• vsReport displays items on separate lines with information arranged in columns. The leftmost column contains a small icon and label, and subsequent columns contain subitems specified by the application. Use the ShowColumnHeaders property to display headers for the columns. Date-time pickers and month calendars\n\n\n\nThe DateTimePicker component displays a list box for entering dates or times, while the MonthCalendar component presents a calendar for entering dates or ranges of dates. To use these components, you must have version 470 or later of COMCTL32.DLL (usually located in the WindowsSystem or WindowsSystem32 directory) at both design time and runtime. Grouping components A graphical interface is easier to use when related controls and information are presented in groups. C++Builder provides several components for grouping components: Use this component: When you want this: GroupBox A standard group box with a title RadioGroup A simple group of radio buttons Panel A more visually flexible group of controls ScrollBox A scrollable region containing controls TabControl A set of mutually exclusive notebook-style tabs PageControl A set of mutually exclusive notebook-style tabs with corresponding pages, each of which may contain other controls HeaderControl Resizable column headers \n\n\n\nGroup boxes and radio groups A group box is a standard Windows component that arranges related controls on a form. The most commonly grouped controls are radio buttons After placing a group box on a form, select components from the Component palette and place them in the group box. The Caption property contains text that labels the group box at runtime The radio group component simplifies the task of assembling radio buttons and making them work together. To add radio buttons to a radio group, edit the Items property in the Object Inspector; each string in Items makes a radio button appear in the group box with the string as its caption. The value of the ItemIndex property determines which radio button is currently selected. Display the radio buttons in a single column or in multiple columns by setting the value of the Columns property. To respace the buttons, resize the radio group component. Programming with C++Builder 2-21 O b j ehttp://www.doksihu cts, components, and controls\n\n\n\nin the VCL Forrás: Panels The panel component provides a generic container for other controls. Panels can be aligned with the form to maintain the same relative position when the form is resized. The BorderWidth property determines the width, in pixels, of the border around a panel. Scroll boxes Scroll boxes create scrolling areas within a form. Applications often need to display more information than will fit in a particular area. Some controlssuch as list boxes, memos, and forms themselvescan automatically scroll their contents. Scroll boxes give you the additional flexibility to define arbitrary scrolling subregions of a form. Like panels and group boxes, scroll boxes contain other controls. But a scroll box is normally invisible. If the controls in the scroll box cannot fit in its visible area, the scroll box automatically displays scroll bars. Tab controls The tab control component looks like notebook dividers. You can create tabs by editing the Tabs property in the Object\n\n\n\nInspector; each string in Tabs represents a tab. The tab control is a single panel with one set of components on it. To change the appearance of the control when the tabs are clicked, you need to write an OnChange event handler. To create a multipage dialog box, use a page control instead Page controls The page control component is a page set suitable for multipage dialog boxes. To create a new page in a page control, right-click the control and choose New Page. Header controls A header control is a is a set of column headers that the user can select or resize at runtime. Edit the control’s Sections property to add or modify headers Visual feedback There are many ways to provide users with information about the state of an application. For example, some componentsincluding TFormhave a Caption property that can be set at runtime. You can also create dialog boxes to display messages. In addition, the following components are especially useful for providing visual feedback at\n\n\n\nruntime. 2-22 Use this component or property: To do this: Label and StaticText Display non-editable text StatusBar Display a status region (usually at the bottom of a window) ProgressBar Show the amount of work completed for a particular task Hint and ShowHint Activate fly-by or “tool-tip” help HelpContext and HelpFile Link context-sensitive online Help Developer’s Guide Objects, components, and controls in the VCL Labels and static-text components Labels display text and are usually placed next to other controls. The standard label component, TLabel, is a non-windowed control, so it cannot receive focus; when you need a label with a window handle, use TStaticText instead. Label properties include the following:\n• Caption contains the text string for the label.\n• FocusControl links the label to another control on the form. If Caption includes an accelerator key, the control specified by FocusControl receives focus when the user presses the accelerator key.\n• ShowAccelChar determines whether the label can display an underlined accelerator character. If ShowAccelChar is true, any character preceded by an ampersand (&) appears underlined and enables an accelerator key.\n• Transparent determines whether items under the label (such as graphics) are visible. Status bars Although you can use a panel to make a status bar, it is simpler to use the status-bar component. By default, the status bar’s Align property is set to alBottom, which takes care of both position and size. You will usually divide a status bar into several text areas. To create text areas, edit the Panels property in the Object Inspector, setting each panel’s Width, Alignment, and Text properties from the Panels editor. The Text property contains the text displayed in the panel. Progress bars When your application performs a time-consuming operation, you can use a progress bar to show how much of the task is completed. A progress bar displays a dotted line that\n\n\n\ngrows from left to right. Figure 2.3 A progress bar The Position property tracks the length of the dotted line. Max and Min determine the range of Position. To make the line grow, increment Position by calling the StepBy or StepIt method. The Step property determines the increment used by StepIt Help and hint properties Most visual controls can display context-sensitive Help as well as fly-by hints at runtime. The HelpContext and HelpFile properties establish a Help context number and Help file for the control. The Hint property contains the text string that appears when the user moves the mouse pointer over a control or menu item. To enable hints, set ShowHint to true; setting ParentShowHint to true causes the control’s ShowHint property to have the same value as its parent’s. Programming with C++Builder 2-23 O b j ehttp://www.doksihu cts, components, and controls in the VCL Forrás: Grids Grids display information in rows and columns. If you’re writing a database\n\n\n\napplication, use the TDBGrid or TDBCtrlGrid component described in Chapter 27, “Using data controls”. Otherwise, use a standard draw grid or string grid Draw grids A draw grid (TDrawGrid) displays arbitrary data in tabular format. Write an OnDrawCell event handler to fill in the cells of the grid.\n• The CellRect method returns the screen coordinates of a specified cell, while the MouseToCell method returns the column and row of the cell at specified screen coordinates. The Selection property indicates the boundaries of the currently selected cells.\n• The TopRow property determines which row is currently at the top of the grid. The LeftCol property determines the first visible column on the left. VisibleColCount and VisibleRowCount are the number of columns and rows visible in the grid.\n• You can change the width or height of a column or row with the ColWidths and RowHeights properties. Set the width of the grid lines with the GridLineWidth property. Add scroll bars to the\n\n\n\ngrid with the ScrollBars property\n• You can choose to have fixed or non-scrolling columns and rows with the FixedCols and FixedRows properties. Assign a color to the fixed columns and rows with the FixedColor property.\n• The Options, DefaultColWidth, and DefaultRowHeight properties also affect the appearance and behavior of the grid. String grids The string grid component is a descendant of TDrawGrid that adds specialized functionality to simplify the display of strings. The Cells property lists the strings for each cell in the grid; the Objects property lists objects associated with each string. All the strings and associated objects for a particular column or row can be accessed through the Cols or Rows property. Graphics display The following components make it easy to incorporate graphics into an application. 2-24 Use this component: To display: Image Graphics files Shape Geometric shapes Bevel 3D lines and frames PaintBox Graphics drawn by your program at runtime \n\n\n\nAnimate AVI files Developer’s Guide Objects, components, and controls in the VCL Images The image component displays a graphical image, like a bitmap, icon, or metafile. The Picture property determines the graphic to be displayed. Use Center, AutoSize, Stretch, and Transparent to set display options. For more information, see “Overview of graphics programming” on page 6-1. Shapes The shape component displays a geometric shape. It is a nonwindowed control and cannot receive user input. The Shape property determines which shape the control assumes. To change the shape’s color or add a pattern, use the Brush property, which holds a TBrush object. How the shape is painted depends on the Color and Style properties of TBrush. Bevels The bevel component is a line that can appear raised or lowered. Some components, such as TPanel, have built-in properties to create beveled borders. When such properties are unavailable, use TBevel to create beveled outlines, boxes, or frames. \n\n\n\nPaint boxes The paint box allows your application to draw on a form. Write an OnPaint event handler to render an image directly on the paint box’s Canvas. Drawing outside the boundaries of the paint box is prevented. For more information, see “Overview of graphics programming” on page 6-1. Animation control The animation component is a window that silently displays an Audio Video Interleaved (AVI) clip. An AVI clip is a series of bitmap frames, like a movie Although AVI clips can have sound, animation controls work only with silent AVI clips. The files you use must be either uncompressed AVI files or AVI clips compressed using run-length encoding (RLE). These are some of the properties of an animation component:\n• ResHandle is the Windows handle for the module that contains the AVI clip as a resource. Set ResHandle at runtime to the instance handle or module handle of the module that includes the animation resource. After setting ResHandle, set the ResID or ResName property to\n\n\n\nspecify which resource in the indicated module is the AVI clip that should be displayed by the animation control.\n• Set AutoSize to true to have the animation control adjust its size to the size of the frames in the AVI clip.\n• StartFrame and StopFrame specify in which frames to start and stop the clip.\n• Set CommonAVI to display one of the common Windows AVI clips provided in Shell32.DLL Programming with C++Builder 2-25 U s i nhttp://www.doksihu g helper objects Forrás:\n• Specify when to start and interrupt the animation by setting the Active property to true and false, respectively, and how many repetitions to play by setting the Repetitions property.\n• The Timers property lets you display the frames using a timer. This is useful for synchronizing the animation sequence with other actions, such as playing a sound track. Windows common dialog boxes The dialog box components on the Dialogs page of the Component palette make the Windows “common” dialog boxes\n\n\n\navailable to your applications. These dialog boxes provide all Windows-based applications with a familiar, consistent interface that enables the user to perform common file operations such as opening, saving, and printing files. Each dialog box opens when its Execute method is called. Execute returns a Boolean value: if the user chooses OK to accept any changes made in the dialog box, Execute returns true; if the user chooses Cancel to escape from the dialog box without making or saving changes, Execute returns false. Using windows common dialog boxes One of the commonly used dialog box components is TOpenDialog. This component is usually invoked by a New or Open menu item under the File option on the main menu bar of a form. The TOpenDialog component makes an Open dialog box available to your application. The purpose of this dialog box is to let a user specify a file to open You use the Execute method to display the dialog box. When the user chooses OK in the dialog box, the user’s\n\n\n\nfile is stored in the TOpenDialog FileName property, which you can then process as you want. The following code snippet can be placed in an Action and linked to the Action property of a TMainMenu subitem or be placed in the subitem’s OnClick event: if(OpenDialog1->Execute()){ filename = OpenDialog1->FileName; }; This code will show the dialog box and if the user presses the OK button, it will copy the name of the file into a previously declared AnsiString variable named filename. Using helper objects The VCL includes a variety of nonvisual objects that simplify common programming tasks. This section describes a few Helper objects that make it easier to perform the following tasks:\n• \n• \n• \n• 2-26 Working with lists Working with string lists Changing the Windows registry and .INI files Using streams Developer’s Guide Using helper objects Working with lists Several VCL objects provide functionality for creating and managing lists:\n• TList maintains a list of\n\n\n\npointers.\n• TObjectList maintains a memory-managed list of instance objects.\n• TComponentList maintains a memory-managed list of components (that is, instances of classes descended from TComponent).\n• TQueue maintains a first-in first-out list of pointers.\n• TStack maintains a last-in first-out list of pointers.\n• TObjectQueue maintains a first-in first-out list of objects.\n• TObjectStack maintains a last-in first-out list of objects.\n• TClassList maintains a list of class types.\n• TCollection, TOwnedCollection, and TCollectionItem maintain indexed collections of specially defined items.\n• TStringList maintains a list of strings. For more information about these objects, see the VCL Reference in the online Help. Working with string lists Applications often need to manage lists of character strings. Examples include items in a combo box, lines in a memo, names of fonts, and names of rows and columns in a string grid. The VCL provides a common interface to any list of\n\n\n\nstrings through an object called TStrings and its descendant TStringList. In addition to providing functionality for maintaining string lists, these objects allow easy interoperability; for example, you can edit the lines of a memo (which are an instance of TStrings) and then use these lines as items in a combo box (also an instance of TStrings). A string-list property appears in the Object Inspector with TStrings in the Value column. Double-click TStrings to open the String List editor, where you can edit, add, or delete lines. You can also work with string-list objects at runtime to perform such tasks as\n• \n• \n• \n• Loading and saving string lists Creating a new string list Manipulating strings in a list Associating objects with a string list Loading and saving string lists String-list objects provide SaveToFile and LoadFromFile methods that let you store a string list in a text file and load a text file into a string list. Each line in the text file corresponds to a string in\n\n\n\nthe list. Using these methods, you could, for example, create a simple text editor by loading a file into a memo component, or save lists of items for combo boxes. Programming with C++Builder 2-27 U s i nhttp://www.doksihu g helper objects Forrás: The following example loads a copy of the WIN.INI file into a memo field and makes a backup copy called WIN.BAK void fastcall EditWinIni() { AnsiString FileName = \"C:WINDOWSWIN.INI\";// set the file name Form1->Memo1->Lines->LoadFromFile(FileName); // load from file Form1->Memo1->Lines->SaveToFile(ChangeFileExt(FileName, \".BAK\")); // save to backup } Creating a new string list A string list is typically part of a component. There are times, however, when it is convenient to create independent string lists, for example to store strings for a lookup table. The way you create and manage a string list depends on whether the list is short-term (constructed, used, and destroyed in a single routine) or\n\n\n\nlong-term (available until the application shuts down). Whichever type of string list you create, remember that you are responsible for freeing the list when you finish with it. Short-term string lists If you use a string list only for the duration of a single routine, you can create it, use it, and destroy it all in one place. This is the safest way to work with string lists Because the string-list object allocates memory for itself and its strings, you should use a try. finally block to ensure that the memory is freed even if an exception occurs 1 Construct the string-list object. 2 In the try part of a try. finally block, use the string list 3 In the finally part, free the string-list object. The following event handler responds to a button click by constructing a string list, using it, and then destroying it. void fastcall TForm1::ButtonClick1(TObject *Sender) { TStringList *TempList = new TStringList; // declare the list try{ //use the string list } finally{ delete\n\n\n\nTempList; // destroy the list object } Long-term string lists If a string list must be available at any time while your application runs, construct the list at start-up and destroy it before the application terminates. 1 In the unit file for your application’s main form, add a field of type TStrings to the form’s declaration. 2 Write an event handler for the main form’s constructor, which executes before the form appears. It should create a string list and assign it to the field you declared in the first step. 3 Write an event handler that frees the string list for the form’s OnDestroy event. 2-28 Developer’s Guide Using helper objects This example uses a long-term string list to record the user’s mouse clicks on the main form, then saves the list to a file before the application terminates. //--------------------------------------------------------------------------#include <vcl.h> #pragma hdrstop #include \"Unit1.h\"\n\n\n\n//--------------------------------------------------------------------------#pragma package(smart init) #pragma resource \"*.dfm\" TForm1 *Form1; //-------------------------------------------------------------------------- fastcall TForm1::TForm1(TComponent* Owner) : TForm(Owner) { ClickList = new TStringList; } //--------------------------------------------------------------------------void fastcall TForm1::FormClose(TObject *Sender, TCloseAction &Action) { ClickList->SaveToFile(ChangeFileExt(Application->ExeName, \".LOG\"));//Save the list delete ClickList; } //--------------------------------------------------------------------------void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { TVarRec v[] = {X,Y}; ClickList->Add(Format(\"Click at (%d, %d)\",v,ARRAYSIZE(v) - 1));//add a string to the list } Manipulating strings in a list Operations commonly performed on string lists include: •\n• \n• \n• \n• \n• \n• \n• Counting the strings in a list Accessing a particular string Finding the position of a string in the list Iterating through strings in a list Adding a string to a list Moving a string within a list Deleting a string from a list Copying a complete string list Counting the strings in a list The read-only Count property returns the number of strings in the list. Since string lists use zero-based indexes, Count is one more than the index of the last string. Accessing a particular string The Strings array property contains the strings in the list, referenced by a zero-based index. Because Strings is the default property for string lists, you can omit the Programming with C++Builder 2-29 U s i nhttp://www.doksihu g helper objects Forrás: Strings identifier when accessing the list; thus StringList1->Strings[0] = “This is the first string.”; is equivalent to StringList1[0] = “This is the first string.”; Finding the position of a string in the\n\n\n\nlist To locate a string in a string list, use the IndexOf method. IndexOf returns the index of the first string in the list that matches the parameter passed to it, and returns –1 if the parameter string is not found. IndexOf finds exact matches only; if you want to match partial strings, you must iterate through the string list yourself. For example, you could use IndexOf to determine whether a given file name is found among the Items of a list box: if (FileListBox1->Items->IndexOf(\"WIN.INI\") > -1) Iterating through strings in a list To iterate through the strings in a list, use a for loop that runs from zero to Count – 1. This example converts each string in a list box to uppercase characters. void fastcall TForm1::Button1Click(TObject *Sender) { for (int i = 0; i < ListBox1->Items->Count; i++) ListBox1->Items->Strings[i] = UpperCase(ListBox1->Items->Strings[i]); } Adding a string to a list To add a string to the end of a string list,\n\n\n\ncall the Add method, passing the new string as the parameter. To insert a string into the list, call the Insert method, passing two parameters: the string and the index of the position where you want it placed. For example, to make the string “Three” the third string in a list, you would use: StringList1->Insert(2, \"Three\"); To append the strings from one list onto another, call AddStrings: StringList1->AddStrings(StringList2); // append the strings from StringList2 to StringList1 Moving a string within a list To move a string in a string list, call the Move method, passing two parameters: the current index of the string and the index you want assigned to it. For example, to move the third string in a list to the fifth position, you would use: StringListObject->Move(2, 4); Deleting a string from a list To delete a string from a string list, call the list’s Delete method, passing the index of the string you want to delete. If you don’t know the index of the\n\n\n\nstring you want to delete, use the IndexOf method to locate it. To delete all the strings in a string list, use the Clear method. 2-30 Developer’s Guide Using helper objects This example uses IndexOf and Delete to find and delete a string: int BIndex = ListBox1->Itesm->IndexOf(\"bureaucracy\"); if (BIndex > -1) ListBox1->Items->Delete(BIndex); Copying a complete string list You can use the Assign method to copy strings from a source list to a destination list, overwriting the contents of the destination list. To append strings without overwriting the destination list, use AddStrings. For example, Memo1->Lines->Assign(ComboBox1->Item)s; //overwrites original strings copies the lines from a combo box into a memo (overwriting the memo), while Memo1->Lines->AddStrings(ComboBox1->Items);//appends strings to end appends the lines from the combo box to the memo. When making local copies of a string list, use the Assign method. If you assign\n\n\n\none string-list variable to another StringList1 = StringList2; the original string-list object will be lost, often with unpredictable results. Associating objects with a string list In addition to the strings stored in its Strings property, a string list can maintain references to objects, which it stores in its Objects property. Like Strings, Objects is an array with a zero-based index. The most common use for Objects is to associate bitmaps with strings for owner-draw controls. Use the AddObject or InsertObject method to add a string and an associated object to the list in a single step. IndexOfObject returns the index of the first string in the list associated with a specified object. Methods like Delete, Clear, and Move operate on both strings and objects; for example, deleting a string removes the corresponding object (if there is one). To associate an object with an existing string, assign the object to the Objects property at the same index. You cannot add an object without\n\n\n\nadding a corresponding string Windows registry and INI files The Windows system registry is a hierarchical database where applications store configuration information. The VCL class TRegistry supplies methods that read and write to the registry. Until Windows 95, most applications stored configuration information in initialization files, usually named with the extension .INI The VCL provides the following classes to facilitate maintenance and migration of programs that use INI files:\n• TRegistry to work with the registry.\n• TIniFile or TMemIniFile to work with Windows 3.x style INI files Programming with C++Builder 2-31 U s i nhttp://www.doksihu g helper objects Forrás:\n• TRegistryIniFile when you want to work with both the registry and INI files. TRegistryIniFile has properties and methods similar to those of TIniFile, but it reads and writes to the system registry. By using a variable of type TCustomIniFile (the common ancestor of TIniFile, TMemIniFile, and\n\n\n\nTRegistryIniFile), you can write generic code that accesses either the registry or an INI file, depending on where it is called. Using TINIFile The INI file format is still popular, many of the C++Builder configuration files (such as the DSK Desktop settings file) are in this format. Because this file format was and is prevalent, VCL provides a class to make reading and writing these files very easy. When you instantiate the INIFile object, you pass as a parameter to the constructor the name of the INI file. If the file does not exist, it is automatically created You are then free to read values using ReadString, ReadInteger, or ReadBool. Alternatively, if you want to read an entire section of the INI file, you can use the ReadSection method. Similarly, you can write values using WriteBool, WriteInteger, or WriteString. Following is an example of reading configuration information from an INI file in a form’s constructor and writing values in the OnClose event handler. void \n\n\n\nfastcall TForm1::TForm1(TObject *Sender) { TIniFile *ini; ini = new TIniFile( ChangeFileExt( Application->ExeName, \".INI\" ) ); Top = ini->ReadInteger( \"Form\", \"Top\", 100 ); Left = ini->ReadInteger( \"Form\", \"Left\", 100 ); Caption = ini->ReadString( \"Form\", \"Caption\", \"Default Caption\" ); ini->ReadBool( \"Form\", \"InitMax\", false ) ? WindowState = wsMaximized : WindowState = wsNormal; delete ini; } void fastcall TForm1::FormClose(TObject *Sender, TCloseAction &Action) { TIniFile *ini; ini = new TIniFile(ChangeFileExt( Application->ExeName, \".INI\" ) ); ini->WriteInteger( \"Form\", \"Top\", Top ); ini->WriteInteger( \"Form\", \"Left\", Left ); ini->WriteString ( \"Form\", \"Caption\", Caption ); ini->WriteBool ( \"Form\", \"InitMax\", WindowState == wsMaximized ); delete ini; } Each\n\n\n\nof the Read routines takes three parameters. The first parameter identifies the section of the INI file. The second parameter identifies the value you want to read, and the third is a default value in case the section or value doesn’t exist in the INI file. 2-32 Developer’s Guide Using helper objects Similarly, the Write routines will create the section and/or value if they do not exist. The example code creates an INI file the first time it is run that looks like this: [Form] Top=185 Left=280 Caption=Default Caption InitMax=0 On subsequent execution of this application, the INI values are read in during creation of the form and written back out in the OnClose event. Using TRegistry Most 32-bit applications store their information in the registry instead of INI files because the registry is hierarchical, more robust, and doesn’t suffer from the size limitations of INI files. The TRegistry object contains methods to open, close, save, move, copy, and delete keys. The\n\n\n\nfollowing example retrieves a value from a registry entry: #include <Registry.hpp> AnsiString GetRegistryValue(AnsiString KeyName) { AnsiString S; TRegistry *Registry = new TRegistry; try { Registry->RootKey = HKEY LOCAL MACHINE; // False because we do not want to create it if it doesn’t exist Registry->OpenKey(KeyName,false); S = Registry->ReadString(\"VALUE1\"); } finally { delete Registry; } return S; } For more information, see the TRegistry topic in VCL help. Using TRegINIFile If you are accustomed to INI files and want to move your configuration information to the registry instead, you can use the TRegINIFile class. TRegINIFile is designed to make registry entries look like INI file entries. All the methods from TINIFile (read and write) exist in TRegINIFile. When you construct a TRegINIFile object, the parameter you pass (the filename for an INIFile object) becomes a key value under the user key in the registry, and all sections and values branch\n\n\n\nfrom that root. In fact, this object simplifies the registry interface considerably, so you may want to use it instead of the TRegistry component even if you aren’t porting existing code. For more information, see the TRegINIFile topic in VCL help. Programming with C++Builder 2-33 U s i nhttp://www.doksihu g helper objects Forrás: Using TCanvas The TCanvas encapsulates a Windows device context, which handles all drawing for both forms, visual containers (such as panels) and the printer object (covered in the next section). Using the canvas object, you no longer have to worry about allocating pens, brushes, palettes, and so onall the allocation and deallocation are handled for you. TCanvas includes a large number of primitive graphics routines to draw lines, shapes, polygons, fonts, etc. onto any control that contains a canvas For example, here is a button event handler that draws a line from the upper left hand corner to the middle of the form and outputs some raw text onto the\n\n\n\nform: void fastcall TForm1::Button1Click(TObject *Sender) { Canvas->Pen->Color = clBlue; Canvas->MoveTo( 10, 10 ); Canvas->LineTo( 100, 100 ); Canvas->Brush->Color = clBtnFace; Canvas->Font->Name = \"Arial\"; Canvas->TextOut( Canvas->PenPos.x, Canvas->PenPosy,\"This is the end of the line\" ); } The TCanvas object also protects you against common Windows graphics errors, such as restoring device contexts, pens, brushes, and so on to the value they had before the drawing operation. The TCanvas is used everywhere in C++Builder that drawing is required or possible, and makes graphics in Windows both fail-safe and easy. See the online help under TCanvas for a complete listing of properties and methods. Using TPrinter The TPrinter object encapsulates details of Windows printers. To get a list of installed and available printers, use the Printers property. The printer object uses a TCanvas (which is identical to the form’s TCanvas) which\n\n\n\nmeans that anything that can be drawn on a form can be printed as well. To print an image, call the BeginDoc method followed by whatever canvas graphics you want to print (including text through the TextOut method) and send the job to the printer by calling the EndDoc method. This example uses a button and a memo on a form. When the user clicks the button, the content of the memo is printed with a 200-pixel border around the page. To run this example successfully, include <Printers.hpp> in your unit file void fastcall TForm1::Button1Click(TObject *Sender) { TPrinter Prntr = Printer(); TRect r = Rect(200,200,Prntr->PageWidth – 200,Prntr->PageHeight – 200); Prntr->BeginDoc(); Prntr->Canvas->TextRect(r, 200, 200, Memo1->Lines->Text); Prntr->EndDoc(); } For more information on the use of the TPrinter object, look in the on-line help under TPrinter. 2-34 Developer’s Guide Developing applications Using streams Use specialized stream objects to\n\n\n\nread or write to storage media. Each descendant of TStream implements methods for accessing a particular medium, such as disk files, dynamic memory, and so on. TStream descendants include TFileStream, TStringStream, TMemoryStream, TBlobStream, and TWinSocketStream. In addition to methods for reading and writing, these objects permit applications to seek to an arbitrary position in the stream. Properties of TStream provide information about the stream, such as size and current position. Developing applications As you visually design the user interface for your application, C++Builder generates the underlying C++ code to support the application. As you select and modify the properties of components and forms, the results of those changes appear automatically in the source code, and vice versa. You can modify the source files directly with any text editor, including the built-in Code editor. The changes you make are immediately reflected in the visual environment as well. Editing code\n\n\n\nThe C++Builder Code editor is a full-featured ASCII editor. If using the visual programming environment, a form is automatically displayed as part of a new project. The contents of the form, all its properties, and its components and their properties can be viewed and edited as text in the Code editor by selecting the View as Text option in the form designer’s context menu. The C++Builder code generation and property streaming systems are completely open to inspection. The source code for everything that is included in your final EXEall of the VCL objects, RTL sources, all of the C++Builder project files can be viewed and edited in the Code editor. Debugging applications C++Builder provides an integrated debugger that helps you find and fix errors in your applications. The integrated debugger lets you control program execution, monitor variable values and items in data structures, and modify data values while debugging. By viewing the values of variables, the functions on the call\n\n\n\nstack, and the program output, you can check that the area of code you are examining is performing as designed. The debugger is described in online Help You can also use exception handling to recognize, locate, and deal with errors. Refer to Chapter 8, “Exception handling” for details on exception handling. Programming with C++Builder 2-35 D e v http://www.doksihu eloping applications Forrás: Deploying applications C++Builder includes add-on tools to help with application deployment. For example, InstallShield Express helps you to create an installation package for your application that includes all of the files needed for running a distributed application. Refer to Chapter 12, “Deploying applications” for specific information on deployment. TeamSource software is also available for tracking application updates. 2-36 Developer’s Guide Chapter 3 Building applications, components, and libraries Chapter3 This chapter provides an overview of how to use C++Builder\n\n\n\nto create applications, libraries, and components. Creating applications The main use of C++Builder is designing and building Windows applications. There are three basic kinds of Windows application:\n• Windows GUI applications\n• Console applications\n• Service applications Windows applications When you compile a project, an executable (.EXE) file is created The executable usually provides the basic functionality of your program, and simple programs often consist of only an EXE. You can extend the application by calling DLLs, packages, and other support files from the executable. Windows offers two application UI models:\n• Single document interface (SDI)\n• Multiple document interface (MDI) In addition to the implementation model of your applications, the design-time behavior of your project and the runtime behavior of your application can be manipulated by setting project options in the IDE. Building applications, components, and libraries 3-1 C r e ahttp://www.doksihu\n\n\n\nting applications Forrás: User interface models Any form can be implemented as a multiple document interface (MDI) or single document interface (SDI) form. In an MDI application, more than one document or child window can be opened within a single parent window. This is common in applications such as spreadsheets or word processors. An SDI application, in contrast, normally contains a single document view. To make your form an SDI application, set the FormStyle property of your Form object to fsNormal. For more information on developing the UI for an application, see Chapter 4, “Developing the application user interface.” SDI Applications To create a new SDI application, 1 Select File|New to bring up the New Items dialog. 2 Click on the Projects page and select SDI Application. 3 Click OK. By default, the FormStyle property of your Form object is set to fsNormal, so C++Builder assumes that all new applications are SDI applications. MDI applications To create a new MDI\n\n\n\napplication, 1 Select File|New to bring up the New Items dialog. 2 Click on the Projects page and select MDI Application. 3 Click OK. MDI applications require more planning and are somewhat more complex to design than SDI applications. MDI applications spawn child windows that reside within the client window; the main form contains child forms. Set the FormStyle property of the TForm object to specify whether a form is a child (fsMDIForm) or main form (fsMDIChild). It is a good idea to define a base class for your child forms and derive each child form from this class, to avoid having to reset the child form’s properties. Setting IDE, project, and compilation options Use Project|Project Options to specify various options for your project. For more information, see the online Help. Setting default project options To change the default options that apply to all future projects, set the options in the Project Options dialog box and check the Default box at the bottom right of the\n\n\n\nwindow. All new projects will now have the current options selected by default 3-2 Developer’s Guide Creating applications Programming templates Programming templates are commonly used “skeleton” structures that you can add to your source code and then fill in. For example, if you want to use a for loop in your code, you could insert the following template: for (; ;) { } To insert a code template in the Code editor, press Ctrl-j and select the template you want to use. You can also add your own templates to this collection To add a template: 1 Select Tools|Environment Options. 2 Click the Code Insight tab. 3 In the templates section click Add. 4 Choose a shortcut name and enter a brief description of the new template. 5 Add the template code to the Code text box. 6 Click OK. Console applications Console applications are 32-bit Windows programs that run without a graphical interface, usually in a console window. These applications typically don’t require much user\n\n\n\ninput and perform a limited set of functions. To create a new console application, 1 Choose File|New and select Console Wizard from the New Items dialog box. 2 In the Console Wizard dialog box, check the Console Application option, choose the source type (C or C++) for the main module of the project, or specify a pre-existing file that contains a main or winmain function, and click the OK button. The Console Wizard will then create a project file for this type of source file. Using the VCL in console applications When you create a new console application, the IDE does not create a new form. Only the code editor is displayed. You can, however, use VCL objects in console applications. To do this, you must indicate in the Console Wizard that you will be using the VCL (check the Use VCL option). If you do not indicate in the wizard that you want to use the VCL, you will not be able use any of the VCL classes in this application later. Trying to do so will cause linker errors Building\n\n\n\napplications, components, and libraries 3-3 C r e ahttp://www.doksihu ting applications Forrás: Service applications Service applications take requests from client applications, process those requests, and return information to the client applications. They typically run in the background, without much user input. A web, FTP, or e-mail server is an example of a service application. To create an application that implements a Win32 service, Choose File|New, and select Service Application from the New Items page. This adds a global variable named Application to your project, which is of type TServiceApplication. Once you have created a service application, you will see a window in the designer that corresponds to a service (TService). Implement the service by setting its properties and event handlers in the Object Inspector. You can add additional services to your service application by choosing Service from the new items dialog. Do not add services to an application that is not a\n\n\n\nservice application. While a TService object can be added, the application will not generate the requisite events or make the appropriate Windows calls on behalf of the service. Once your service application is built, you can install its services with the Service Control Manager (SCM). Other applications can then launch your services by sending requests to the SCM. To install your application’s services, run it using the /INSTALL option. The application installs its services and exits, giving a confirmation message if the services are successfully installed. You can suppress the confirmation message by running the service application using the /SILENT option. To uninstall the services, run it from the command line using the /UNINTALL option. (You can also use the /SILENT option to suppress the confirmation message when uninstalling). Example This service has a TServerSocket whose port is set to 80. This is the default port for Web Browsers to make requests to Web Servers and for Web\n\n\n\nServers to make responses to Web Browsers. This particular example produces a text document in the C:Temp directory called WebLogxxx.log (where xxx is the ThreadID) There should be only one Server listening on any given port, so if you have a web server, you should make sure that it is not listening (the service is stopped). To see the results: open up a web browser on the local machine and for the address, type ‘localhost’ (with no quotes). The Browser will time out eventually, but you should now have a file called weblogxxx.log in the C: emp directory 1 To create the example, choose File|New and select Service Application from the New Items dialog. You will see a window appear named Service1 From the Internet page of the component palette, add a ServerSocket component to the service window (Service1). 3-4 Developer’s Guide Creating applications 2 Next, add a private data member of type TMemoryStream to the TService1 class. The header for your unit should now look like\n\n\n\nthis: //--------------------------------------------------------------------------#ifndef Unit1H #define Unit1H //--------------------------------------------------------------------------#include <SysUtils.hpp> #include <Classes.hpp> #include <SvcMgr.hpp> #include <ScktComp.hpp> //--------------------------------------------------------------------------class TService1 : public TService { published:// IDE-managed Components TServerSocket *ServerSocket1; private:// User declarations TMemoryStream *Stream; // add this line here public:// User declarations fastcall TService1(TComponent* Owner); PServiceController fastcall GetServiceController(void); friend void stdcall ServiceController(unsigned CtrlCode); }; //--------------------------------------------------------------------------extern PACKAGE TService1 *Service1; //--------------------------------------------------------------------------#endif 3 Next, select ServerSocket1, the component you added\n\n\n\nin step 1. In the Object Inspector, double click the OnClientRead event and add the following event handler: void fastcall TService1::ServerSocket1ClientRead(TObject *Sender, TCustomWinSocket *Socket) { char *Buffer = NULL; int len = Socket->ReceiveLength(); while (len > 0) { try { Buffer = (char *)malloc(len); Socket->ReceiveBuf((void *)Buffer, len); Stream->Write(Buffer, strlen(Buffer)); } finally { free(Buffer); } Stream->Seek(0, soFromBeginning); AnsiString LogFile = \"C:\\Temp\\WebLog\"; LogFile = LogFile + IntToStr(ServiceThread->ThreadID) + \".log\"; Stream->SaveToFile(LogFile); } } Building applications, components, and libraries 3-5 C r e ahttp://www.doksihu ting applications Forrás: 4 Finally, select Service1 by clicking in the window’s client area (but not on the ServiceSocket). In the Object Inspector, double click the OnExecute event and add the following event handler: void fastcall TService1::Service1Execute(TService\n\n\n\n*Sender) { Stream = new TMemoryStream(); try { ServerSocket1->Port = 80; // WWW port ServerSocket1->Active = true; while (!Terminated) ServiceThread->ProcessRequests(false); ServerSocket1->Active = false; } finally { delete Stream; } } When writing your service application, you should be aware of:\n• Service threads\n• Service name properties\n• Debugging services Service threads Each service has its own thread (TServiceThread), so if your service application implements more than one service you must ensure that the implementation of your services is thread-safe. TServiceThread is designed so that you can implement the service in the TService OnExecute event handler. The service thread has its own Execute method which contains a loop that calls the service’s OnStart and OnExecute handlers before processing new requests. Because service requests can take a long time to process and the service application can receive simultaneous requests from more than one client,\n\n\n\nit is more efficient to spawn a new thread (derived from TThread, not TServiceThread) for each request and move the implementation of that service to the new thread’s Execute method. This allows the service thread’s Execute loop to process new requests continually without having to wait for the service’s OnExecute handler to finish. The following example demonstrates. Example This service beeps every 500 milliseconds from within the standard thread. It handles pausing, continuing, and stopping of the thread when the service is told to pause, continue, or stop. 1 Choose File|New and select Service Application from the New Items dialog. You will see a window appear named Service1. 2 In you unit’s header file, declare a new descendant of TThread named TSparkyThread. This is the thread that does the work for your service The declaration should appear as follows: 3-6 Developer’s Guide Creating applications class TSparkyThread : public TThread { private: protected: void \n\n\n\nfastcall Execute(); public: fastcall TSparkyThread(bool CreateSuspended); }; 3 Next, in the .cpp file for your unit, create a global variable for a TSparkyThread instance: TSparkyThread *SparkyThread; 4 Add the following code to the .cpp file for the TSparkyThread constructor: fastcall TSparkyThread::TSparkyThread(bool CreateSuspended) : TThread(CreateSuspended) { } 5 Add the following code to the .cpp file for the TSparkyThread Execute method (the thread function): void fastcall TSparkyThread::Execute() { while (!Terminated) { Beep(); Sleep(500); } } 6 Select the Service window (Service1), and double-click the OnStart event in the Object Inspector. Add the following OnStart event handler: void fastcall TService1::Service1Start(TService *Sender, bool &Started) { SparkyThread = new TSparkyThread(false); Started = true; } 7 Double-click the OnContinue event in the Object Inspector. Add the following OnContinue event handler: void fastcall\n\n\n\nTService1::Service1Continue(TService *Sender, bool &Continued) { SparkyThread->Resume(); Continued = true; } 8 Double-click the OnPause event in the Object Inspector. Add the following OnPause event handler: void fastcall TService1::Service1Pause(TService *Sender, bool &Paused) { SparkyThread->Suspend(); Paused = true; } Building applications, components, and libraries 3-7 C r e ahttp://www.doksihu ting applications Forrás: 9 Finally, double-click the OnStop event in the Object Inspector and add the following OnStop event handler: void fastcall TService1::Service1Stop(TService *Sender, bool &Stopped) { SparkyThread->Terminate(); Stopped = true; } When developing server applications, choosing to spawn a new thread depends on the nature of the service being provided, the anticipated number of connections, and the expected number of processors on the computer running the service. Service name properties The VCL provides classes for creating service\n\n\n\napplications. These include TService and TDependency. When using these classes, the various name properties can be confusing. This section describes the differences Services have user names (called Service start names) that are associated with passwords, display names for display in manager and editor windows, and actual names (the name of the service). Dependencies can be services or they can be load ordering groups. They also have names and display names And because service objects are derived from TComponent, they inherit the Name property. The following sections summarize the name properties: TDependency properties The TDependency DisplayName is both a display name and the actual name of the service. It is nearly always the same as the TDependency Name property TService name properties The TService Name property is inherited from TComponent. It is the name of the component, and is also the name of the service. For dependencies that are services, this property is the same as the\n\n\n\nTDependency Name and DisplayName properties. TService’s DisplayName is the name displayed in the Service Manager window. This often differs from the actual service name (TService::Name, TDependency::DisplayName, TDependency::Name). Note that the DisplayName for the Dependency and the DisplayName for the Service usually differ. Service start names are distinct from both the service display names and the actual service names. A ServiceStartName is the user name input on the Start dialog selected from the Service Control Manager. Debugging services Debugging service applications can be tricky, because it requires short time intervals: 1 First, launch the application in the debugger. Wait a few seconds until it has finished loading. 2 Quickly start the service from the control panel or from the command line: start MyServ 3-8 Developer’s Guide Creating packages and DLLs You must launch the service quickly (within 15-30 seconds of application startup) because the application\n\n\n\nwill terminate if no service is launched. Another approach is to attach to the service application process when it is already running. (That is, starting the service first, and then attaching to the debugger) To attach to the service application process, choose Run|Attach To Process, and select the service application in the resulting dialog. In some cases, this second approach may fail, due to insufficient rights. If that happens, you can use the Service Control Manager to enable your service to work with the debugger: 1 First create a key called Image File Execution Options in the following registry location: HKEY LOCAL MACHINESOFTWAREMicrosoftWindows NTCurrentVersion 2 Create a subkey with the same name as your service (for example, MYSERV.EXE) To this subkey, add a value of type REG SZ, named Debugger. Use the full path to BCB.exe as the string value 3 In the Services control panel applet, select your service, click Startup and check Allow Service to Interact with Desktop. \n\n\n\nCreating packages and DLLs Dynamic link libraries (DLLs) are modules of compiled code that work in conjunction with an executable to provide functionality to an application. Packages are special DLLs used by C++Builder applications, the IDE, or both. There are two kinds of packages: runtime packages and design-time packages. Runtime packages provide functionality to a program while that program is running. Design-time packages extend the functionality of the IDE. For more information on packages, see Chapter 10, “Working with packages and components.” When to use packages and DLLs For most applications written in C++Builder, packages provide greater flexibility and are easier to create than DLLs. However, there are several situations where DLLs would be better suited to your projects than packages:\n• \n• \n• \n• Your code module will be called from non-C++Builder applications. You are extending the functionality of a web server. You are creating a code module to be used by\n\n\n\nthird-party developers. Your project is an OLE container. Building applications, components, and libraries 3-9 U s i nhttp://www.doksihu g DLLs in C++Builder Forrás: Using DLLs in C++Builder A Windows DLL can be used in a C++Builder application just as it would be in any C++ application. To statically load a DLL when your C++Builder application is loaded, link the import library file for that DLL into your C++Builder application at link time. To add an import library to a C++Builder application, open the make file (.BPR) for the application and add the import library name to the library file list assigned to the ALLLIB variable. If necessary, add the path of the import library to the path(s) listed for the -L option of LFLAGS (linker options) variable. The exported functions of that DLL then become available for use by your application. Prototype the DLL functions your application uses with the declspec (dllimport) modifier: declspec(dllimport) return type imported function\n\n\n\nname(parameters); To dynamically load a DLL during the run of a C++Builder application, include the import library, just as you would for static loading, and set the delay load linker option on the Project|Options|Linker tab. You can also use the Windows API function LoadLibrary() to load the DLL, then use the API function GetProcAddress() to obtain pointers to the individual functions you want to use. Additional information on using DLLs can be found in the Microsoft® Win32 SDK Reference. Creating DLLs in C++Builder Creating DLLs in C++Builder is the same as in standard C++: 1 Choose File|New to display the New Items dialog box. 2 Click on the DLL Wizard icon 3 Choose the Source type (C or C++) for the main module. 4 If you want the DLL entry point to be DLLMain, MSVC++ style, check the VC++ style option, otherwise, DLLEntryPoint is used for the entry point. 5 Click Use VCL to create a DLL containing VCL components, this option is only available for C++ source modules. See\n\n\n\n“Creating DLLs containing VCL components” on page 3-11. 6 If you want the DLL to be multi-threaded, check the Multi-Threaded option. 7 Click the OK button. Exported functions in the code should be identified with the declspec (dllexport) modifier as they must be in Borland C++ or Microsoft Visual C++. For example, the following code is legal in C++Builder and other Windows C++ compilers: 3-10 Developer’s Guide Creating DLLs containing VCL components // MyDLL.cpp double dblValue(double); double halfValue(double); extern \"C\" declspec(dllexport) double changeValue(double, bool); double dblValue(double value) { return value * value; }; double halfValue(double value) { return value / 2.0; } double changeValue(double value, bool whichOp) { return whichOp ? dblValue(value) : halfValue(value); } In the code above, the function changeValue is exported, and therefore made available to calling applications. The functions dblValue and halfValue are internal, and cannot\n\n\n\nbe called from outside of the DLL. Additional information on creating DLLs can be found in the Microsoft® Win32 SDK Reference. Creating DLLs containing VCL components One of the strengths of DLLs is that a DLL created with one development tool can often be used by application written using a different development tool. When your DLL contains VCL components (such as forms) that are to be utilized by the calling application, you need to provide exported interface routines that use standard calling conventions, avoid C++ name mangling, and do not require the calling application to support the VCL library in order to work. To create VCL components that can be exported, use runtime packages. For more information, see Chapter 10, “Working with packages and components.” For example, suppose you want to create a DLL to display the following simple dialog box: Building applications, components, and libraries 3-11 C r e ahttp://www.doksihu ting DLLs containing VCL components Forrás: \n\n\n\nThe code for the dialog box DLL is as follows: // DLLMAIN.H //--------------------------------------------------------------------#ifndef dllMainH #define dllMainH //--------------------------------------------------------------------#include <vclClasses.hpp> #include <vclControls.hpp> #include <vclStdCtrls.hpp> #include <vclForms.hpp> //--------------------------------------------------------------------class TYesNoDialog : public TForm { published: // IDE-managed Components TLabel *LabelText; TButton *YesButton; TButton *NoButton; void fastcall YesButtonClick(TObject *Sender); void fastcall NoButtonClick(TObject *Sender); private: // User declarations bool returnValue; public: // User declarations virtual fastcall TYesNoDialog(TComponent *Owner); bool fastcall GetReturnValue(); }; // exported interface function extern \"C\" declspec(dllexport) bool InvokeYesNoDialog();\n\n\n\n//--------------------------------------------------------------------extern TYesNoDialog *YesNoDialog; //--------------------------------------------------------------------#endif // DLLMAIN.CPP //--------------------------------------------------------------------#include <vclvcl.h> #pragma hdrstop #include \"dllMain.h\" //--------------------------------------------------------------------#pragma resource \"*.dfm\" TYesNoDialog *YesNoDialog; //-------------------------------------------------------------------- fastcall TYesNoDialog::TYesNoDialog(TComponent *Owner) : TForm(Owner) { returnValue = false; } 3-12 Developer’s Guide Creating DLLs containing VCL components //--------------------------------------------------------------------void fastcall TYesNoDialog::YesButtonClick(TObject *Sender) { returnValue = true; Close(); } //--------------------------------------------------------------------void fastcall TYesNoDialog::NoButtonClick(TObject\n\n\n\n*Sender) { returnValue = false; Close(); } //--------------------------------------------------------------------bool fastcall TYesNoDialog::GetReturnValue() { return returnValue; } //--------------------------------------------------------------------// exported standard C++ interface function that calls into VCL bool InvokeYesNoDialog() { bool returnValue; TYesNoDialog *YesNoDialog = new TYesNoDialog(NULL); YesNoDialog->ShowModal(); returnValue = YesNoDialog->GetReturnValue(); delete YesNoDialog; return returnValue; } //--------------------------------------------------------------------- The code in this example displays the dialog and stores the value true in the private data member returnValue if the “Yes” button is pressed. Otherwise, returnValue is false. The public GetReturnValue() function retrieves the current value of returnValue To invoke the dialog and determine which button was pressed, the calling application calls the exported function InvokeYesNoDialog().\n\n\n\nThis function is declared in DLLMAIN.H as an exported function using C linkage (to avoid C++ name mangling) and the standard C calling convention. The function is defined in DLLMAIN.CPP By using a standard C function as the interface into the DLL, any calling application, whether or not it was created with C++Builder, can use the DLL. The VCL functionality required to support the dialog is linked into the DLL itself, and the calling application does not need to know anything about it. Note that when creating a DLL that uses the VCL, the required VCL components are linked into the DLL resulting in a certain amount of overhead. The impact of this overhead on the overall size of the application can be minimized by combining several components into one DLL which only needs one copy of the VCL support components. Building applications, components, and libraries 3-13 L i n khttp://www.doksihu ing DLLs Forrás: Linking DLLs You can set the linker options for your DLL on the Linker page\n\n\n\nof the Project Options dialog. The default check box on this page also creates an import library for your DLL. If compiling from the command line, invoke the linker, ILINK32EXE, with the -Tpd switch. For example, ilink32 /c /aa /Tpd c0d32.obj mydllobj, mydlldll, mdllmap, import32lib cw32mtlib If you need an import library, use the -Gi switch also, to generate an import library. You can optionally create an import library with the command line utility IMPLIB.EXE For example, implib mydll.lib mydlldll For more information about the different options for linking DLLs and using them with other modules that are statically or dynamically linked to the runtime library, see the online Help. Writing database applications One of C++Builder’s strengths is its support for creating advanced database applications. C++Builder includes built-in tools that allow you to connect to Oracle, Sybase, Informix, dBASE, Paradox, or other servers while providing transparent data sharing between\n\n\n\napplications. The Borland Database Engine (BDE) supports scaling from desktop to client/server applications. Tools, such as the Database Explorer, simplify the task of writing database applications. The Database Explorer is a hierarchical browser for inspecting and modifying database server-specific schema objects including tables, fields, stored procedure definitions, triggers, references, and index descriptions. Through a persistent connection to a database, Database Explorer lets you\n• Create and maintain database aliases\n• View schema data in a database, such as tables, stored procedures, and triggers\n• View table objects, such as fields and indexes\n• Create, view, and modify data in tables\n• Enter SQL statements to directly query any database\n• Create and maintain data dictionaries to store attribute sets See Part II, “Developing database applications” in this manual for details on how to use C++Builder to create both database client applications and application\n\n\n\nservers. 3-14 Developer’s Guide Building distributed applications Building distributed applications Distributed applications are applications that are deployed to various machines and platforms and work together, typically over a network, to perform a set of related functions. For instance, an application for purchasing items and tracking those purchases for a nationwide company would require individual client applications for all the outlets, a main server that would process the requests of those clients, and an interface to a database that stores all the information regarding those transactions. By building a distributed client application (for instance, a web-based application), maintaining and updating the individual clients is vastly simplified. C++Builder provides several options for the implementation model of distributed applications:\n• \n• \n• \n• TCP/IP applications COM and DCOM applications CORBA applications Database applications Distributing applications using\n\n\n\nTCP/IP TCP/IP is a communication protocol that allows you to write applications that communicate over networks. You can implement virtually any design in your applications. TCP/IP provides a transport layer, but does not impose any particular architecture for creating your distributed application. The growth of the Internet has created an environment where most computers already have some form of TCP/IP access, which simplifies distributing and setting up the application. Applications that use TCP/IP can be message-based distributed applications (such as Web server applications that service HTTP request messages) or distributed object applications (such as distributed database applications that communicate using Windows sockets). The most basic method of adding TCP/IP functionality to your applications is to use client or server sockets. C++Builder also provides support for applications that extend Web servers by creating CGI scripts or DLLs. In addition, C++Builder provides support\n\n\n\nfor TCP/IP-based database applications. Using sockets in applications Two VCL classes, TClientSocket and TServerSocket, allow you to create TCP/IP socket connections to communicate with other remote applications. For more information on sockets, see Chapter 31, “Working with sockets.” Building applications, components, and libraries 3-15 B u i l http://www.doksihu ding distributed applications Forrás: Creating Web server applications To create a new Web server application, select File|New and select Web Server Application in the New Items dialog box. Then select the Web server application type:\n• ISAPI and NSAPI\n• CGI stand-alone\n• Win-CGI stand-alone CGI and Win-CGI applications use more system resources on the server, so complex applications are better created as ISAPI or NSAPI applications. For more information on building Web server applications, see Chapter 30, “Creating Internet server applications.” ISAPI and NSAPI Web server applications Selecting this\n\n\n\ntype of application sets up your project as a DLL. ISAPI or NSAPI Web server applications are DLLs loaded by the Web server. Information is passed to the DLL, processed, and returned to the client by the Web server. CGI stand-alone Web server applications CGI Web server applications are console applications that receive requests from clients on standard input, processes those requests, and sends back the results to the server on standard output to be sent to the client. Win-CGI stand-alone Web server applications Win-CGI Web server applications are Windows applications that receive requests from clients from an INI file written by the server and writes the results to a file that the server sends to the client. Distributing applications using COM and DCOM COM is the Component Object Model, a Windows-based distributed object architecture designed to provide object interoperability using predefined routines called interfaces. COM applications use objects that are implemented by a\n\n\n\ndifferent process or, if you use DCOM, on a separate machine. COM and DCOM C++Builder has classes and wizards that make it easy to create the essential elements of a COM, OLE, or ActiveX application. Using C++Builder to create COM-based applications offers a wide range of possibilities, from improving software design by using interfaces internally in an application, to creating objects that can interact with other COM-based API objects on the system, such as the Win95 Shell extensions and DirectX multimedia support. For more information on COM and Active X controls, see Chapter 32, “Overview of COM technologies,” Chapter 37, “Creating an ActiveX control,” and “Distributing a client application as an ActiveX control” on page 15-26. For more information on DCOM, see “Using DCOM connections” on page 15-9. 3-16 Developer’s Guide Using data modules and remote data modules MTS and COM+ COM applications can be augmented with special services for managing objects in a\n\n\n\nlarge distributed environment. These services include transaction services, security, and resource management supplied by Microsoft Transaction Server (MTS) (for versions of Windows prior to Windows 2000) or COM+ (for Windows 2000 and later). For more information on MTS and COM+, see Chapter 38, “Creating MTS or COM+ objects” and “Using transactional data modules” on page 15-5. Distributing applications using CORBA Common Object Request Broker Architecture (CORBA) is a method of using distributed objects in applications. The CORBA standard is used on many platforms, so writing CORBA applications allows you to make use of programs that are not running on a Windows machine. Like COM, CORBA is a distributed object architecture, meaning that client applications can make use of objects that are implemented on a remote server. For more information on CORBA, see Chapter 29, “Writing CORBA applications.” Distributing database applications C++Builder provides support for creating\n\n\n\ndistributed database applications using the MIDAS technology. This powerful technology includes a coordinated set of components that allow you to build a wide variety of multi-tiered database applications. Distributed database applications can be built on a variety of communications protocols, including DCOM, TCP/IP, and OLEnterprise. For more information about building distributed database applications, see Chapter 15, “Creating multi-tiered applications.” Distributing database applications often requires you to distribute the Borland Database Engine (BDE) in addition to the application files. For information on deploying the BDE, see “Deploying database applications” on page 12-4. Using data modules and remote data modules A data module is like a special form that contains nonvisual components. All the components in a data module could be placed on ordinary forms alongside visual controls. But if you plan on reusing groups of database and system objects, or if you want to\n\n\n\nisolate the parts of your application that handle database connectivity and business rules, then data modules provide a convenient organizational tool. There are two types of data module: standard and remote. To create a single- or two-tiered application, use a standard data module. If you have the Enterprise edition of C++Builder and are creating a multi-tiered application, you can add a Building applications, components, and libraries 3-17 U s i nhttp://www.doksihu g data modules and remote data modules Forrás: remote data module to your application server; see “Adding a remote data module to an application server project” on page 3-19. Creating and editing data modules To create a data module, choose File|New and double-click on Data Module. C++Builder opens an empty data module in the Data Module Designer, displays the unit file for the new module in the Code editor, and adds the module to the current project. When you reopen an existing data module, C++Builder displays\n\n\n\nits components in the Data Module Designer. The Data Module Designer is divided into two panes. The left pane displays a hierarchical tree view of the components in the module. The right pane has two tabs: Components and Data Diagram. The Components page shows the components as they would appear on a form. The Data Diagram page shows a graphical representation of internal relationships among the components, such as master-detail links and lookup fields. Figure 3.1 A simple data module You can add components to a data module by selecting them on the Component palette and clicking in the Tree or Components view of the Data Module Designer. When a component is selected in the Data Module Designer, you can edit its properties in the Object Inspector just as you would if the component were on a form. For more information about the Data Module Designer, see the online Help. Creating business rules in a data module In a data module’s unit file, you can write methods, including event\n\n\n\nhandlers for the components in the module, as well as global routines that encapsulate business rules. For example, you might write a procedure to perform month-, quarter-, or year-end bookkeeping; you could call such a procedure from an event handler for a component in the module or from any unit that uses the module. 3-18 Developer’s Guide Using the Object Repository Accessing a data module from a form To associate visual controls on a form with a data module, you must first add the data module’s header file to the form’s cpp file. You can do this in several ways:\n• In the Code editor, open the form’s unit file and include the data module’s header file using the #include directive.\n• Choose File|Include Unit Hdr, then enter the name of the module or pick it from the list box in the Use Unit dialog.\n• Double-click on a TTable or TQuery component in the data module to open the Fields editor. From the Fields editor, drag any fields onto your form C++Builder\n\n\n\nprompts you to confirm that you want to add the module to the form, then creates controls (such as edit boxes) for the fields. Adding a remote data module to an application server project Some versions of C++Builder allow you to add remote data modules to application server projects. A remote data module has an interface that clients in a multi-tiered application can access across networks. To add a remote data module to a project, choose File|New, select the Multitier page in the New Items dialog box, and double-click the desired type of module (Remote Data Module, MTS Data Module, or CORBA Data Module) to open the Remote Data Module wizard. Once you add a remote data module to a project, you use it just like a standard data module. For more information about multi-tiered database applications, see Chapter 15, “Creating multi-tiered applications.” Using the Object Repository The Object Repository (Tools|Repository) makes it easy share forms, dialog boxes, frames, and data\n\n\n\nmodules. It also provides templates for new projects and wizards that guide the user through the creation of forms and projects. The repository is maintained in BCB.DRO (by default in the BIN directory), a text file that contains references to the items that appear in the Repository and New Items dialogs. Sharing items within a project You can share items within a project without adding them to the Object Repository. When you open the New Items dialog box (File|New), you’ll see a page tab with the name of the current project. This page lists all the forms, dialog boxes, and data modules in the project. You can derive a new item from an existing item and customize it as needed. Building applications, components, and libraries 3-19 U s i nhttp://www.doksihu g the Object Repository Forrás: Adding items to the Object Repository You can add your own projects, forms, frames, and data modules to those already available in the Object Repository. To add an item to the Object\n\n\n\nRepository, 1 If the item is a project or is in a project, open the project. 2 For a project, choose Project|Add To Repository. For a form or data module, right-click the item and choose Add To Repository. 3 Type a description, title, and author. 4 Decide which page you want the item to appear on in the New Items dialog box, then type the name of the page or select it from the Page combo box. If you type the name of a page that doesn’t exist, C++Builder creates a new page. 5 Choose Browse to select an icon to represent the object in the Object Repository. 6 Choose OK. Sharing objects in a team environment You can share objects with your workgroup or development team by making a repository available over a network. To use a shared repository, all team members must select the same Shared Repository directory in the Environment Options dialog: 1 Choose Tools|Environment Options. 2 On the Preferences page, locate the Shared Repository panel. In the Directory edit box, enter the\n\n\n\ndirectory where you want to locate the shared repository. Be sure to specify a directory that’s accessible to all team members. The first time an item is added to the repository, C++Builder creates a BCB.DRO file in the Shared Repository directory if one doesn’t exist already. Using an Object Repository item in a project To access items in the Object Repository, choose File|New. The New Items dialog appears, showing all the items available. Depending on the type of item you want to use, you have up to three options for adding the item to your project:\n• Copy\n• Inherit\n• Use Copying an item Choose Copy to make an exact copy of the selected item and add the copy to your project. Future changes made to the item in the Object Repository will not be reflected in your copy, and alterations made to your copy will not affect the original Object Repository item. Copy is the only option available for project templates. 3-20 Developer’s Guide Using the Object Repository \n\n\n\nInheriting an item Choose Inherit to derive a new class from the selected item in the Object Repository and add the new class to your project. When you recompile your project, any changes that have been made to the item in the Object Repository will be reflected in your derived class, in addition to changes you make to the item in your project. Changes made to your derived class do not affect the shared item in the Object Repository. Inherit is available for forms, dialog boxes, and data modules, but not for project templates. It is the only option available for reusing items within the same project Using an item Choose Use when you want the selected item itself to become part of your project. Changes made to the item in your project will appear in all other projects that have added the item with the Inherit or Use option. Select this option with caution The Use option is available for forms, dialog boxes, and data modules. Using project templates Templates are predesigned projects\n\n\n\nthat you can use as starting points for your own work. To create a new project from a template, 1 Choose File|New to display the New Items dialog box. 2 Choose the Projects tab. 3 Select the project template you want and choose OK. 4 In the Select Directory dialog, specify a directory for the new project’s files. C++Builder copies the template files to the specified directory, where you can modify them. The original project template is unaffected by your changes Modifying shared items If you modify an item in the Object Repository, your changes will affect all future projects that use the item as well as existing projects that have added the item with the Use or Inherit option. To avoid propagating changes to other projects, you have several alternatives:\n• Copy the item and modify it in your current project only.\n• Copy the item to the current project, modify it, then add it to the Repository under a different name.\n• Create a component, DLL, component template, or frame\n\n\n\nfrom the item. If you create a component or DLL, you can share it with other developers. Building applications, components, and libraries 3-21 U s i nhttp://www.doksihu g the Object Repository Forrás: Specifying a default project, new form, and main form By default, when you choose File|New Application or File|New Form, C++Builder displays a blank form. You can change this behavior by reconfiguring the Repository: 1 Choose Tools|Repository 2 If you want to specify a default project, select the Projects page and choose an item under Objects. Then select the New Project check box 3 If you want to specify a default form, select a Repository page (such as Forms), them choose a form under Objects. To specify the default new form (File|New Form), select the New Form check box. To specify the default main form for new projects, select the Main Form check box. 4 Click OK. 3-22 Developer’s Guide Chapter 4 Developing the application user interface Chapter4 With C++Builder, you\n\n\n\ncreate a user interface (UI) by selecting components from the Component palette and dropping them onto forms. Understanding TApplication, TScreen, and TForm TApplication, TScreen, and TForm are VCL classes that form the backbone of all C++Builder applications by controlling the behavior of your project. The TApplication class forms the foundation of a Windows application by providing properties and methods that encapsulate the behavior of a standard Windows program. TScreen is used at runtime to keep track of forms and data modules that have been loaded as well as system specific information such as screen resolution and what fonts are available for display. Instances of the TForm class are the building blocks of your application’s user interface. The windows and dialog boxes of your application are based on TForm. Using the main form TForm is the key class for creating Windows GUI applications. The first form you create and save in a project becomes, by default, the project’s\n\n\n\nmain form, which is the first form created at runtime. As you add forms to your projects, you might decide to designate a different form as your application’s main form. Also, specifying a form as the main form is an easy way to test it at runtime, because unless you change the form creation order, the main form is the first form displayed in the running application. Developing the application user interface 4-1 U n d http://www.doksihu erstanding TApplication, TScreen, and TForm Forrás: To change the project main form, 1 Choose Project|Options and select the Forms page. 2 In the Main Form combo box, select the form you want as the project main form and choose OK. Now if you run the application, your new main form choice is displayed. Adding additional forms To add an additional form to your project, select File|New Form. You can see all your project’s forms and their associated units listed in the Project Manager (View| Project Manager). Linking forms Adding a form to a\n\n\n\nproject adds a reference to it in the project file, but not to any other units in the project. Before you can write code that references the new form, you need to add a reference to it in the referencing forms’ unit files. This is called form linking. A common reason to link forms is to provide access to the components in that form. For example, you’ll often use form linking to enable a form that contains data-aware components to connect to the data-access components in a data module. To link a form to another form, 1 2 3 4 Select the form that needs to refer to another. Choose File|Include Unit Hdr. Select the name of the form unit for the form to be referenced. Choose OK. Linking a form to another just means that one form unit contains the header for the other’s form unit, meaning that the linked form and its components are now in scope for the linking form. Hiding the main form You can prevent the main form from displaying when your application first starts up. To do so,\n\n\n\nyou must use the global Application variable (described in the next topic). To hide the main form at startup, 1 Choose Project|View Source to display the main project file. 2 Add the following lines after the call to Application->CreateForm() and before the call to Application->Run(). Application->ShowMainForm = false; Form1->Visible = false; // the name of your main form may differ Note 4-2 You can set the form’s Visible property to false using the Object Inspector at design time rather than setting it at runtime as shown above. Developer’s Guide Understanding TApplication, TScreen, and TForm Working at the application level The global variable Application, of type TApplication, is in every VCL-based Windows application. Application encapsulates your application as well as providing many functions that occur in the background of the program. For instance, Application would handle how you would call a help file from the menu of your program. Understanding how\n\n\n\nTApplication works is more important to a component writer than to developers of stand-alone applications, but you should set the options that Application handles in the Project|Options Application page when you create a project. In addition, Application receives many events that apply to the application as a whole. For example, the OnActivate event lets you perform actions when the application first starts up, the OnIdle event lets you perform background processes when the application is not busy, the OnMessage event lets you intercept Windows messages, and so on. Although you can’t use the IDE to examine the properties and events of the global Application variable, another component, TApplicationEvents, intercepts the events and lets you supply event-handlers using the IDE. Handling the screen An global variable of type TScreen called Screen is created when you create a project. Screen encapsulates the state of the screen on which your application is running. Common tasks\n\n\n\nperformed by Screen include specifying the look of the cursor, the size of the window in which your application is running, the list of fonts available to the screen device, and multiple screen behavior. If your application runs on multiple monitors, Screen maintains a list of monitors and their dimensions so that you can effectively manage the layout of your user interface. Managing layout At its simplest, you control the layout of your user interface by how you place controls in your forms. The placement choices you make are reflected in the control’s Top, Left, Width, and Height properties. You can change these values at runtime to change the position and size of the controls in your forms. Controls have a number of other properties, however, that allow them to automatically adjust to their contents or containers. This allows you to lay out your forms so that the pieces fit together into a unified whole. Two properties affect how a control is positioned and sized in relation to\n\n\n\nits parent. The Align property lets you force a control to fit perfectly within its parent along a specific edge or filling up the entire client area after any other controls have been aligned. When the parent is resized, the controls aligned to it are automatically resized and remain positioned so that they fit against a particular edge. If you want to keep a control positioned relative to a particular edge of its parent, but don’t want it to necessarily touch that edge or be resized so that it always runs along the entire edge, you can use the Anchors property. Developing the application user interface 4-3 W o r http://www.doksihu king with messages Forrás: If you want to ensure that a control does not grow too big or too small, you can use the Constraints property. Constraints lets you specify the control’s maximum height, minimum height, maximum width, and minimum width. Set these to limit the size (in pixels) of the control’s height and width. For example, by setting\n\n\n\nthe MinWidth and MinHeight of the constraints on a container object, you can ensure that child objects are always visible. The value of Constraints propagates through the parent/child hierarchy so that an object’s size can be constrained because it contains aligned children that have size constraints. Constraints can also prevent a control from being scaled in a particular dimension when its ChangeScale method is called. TControl introduces a protected event, OnConstrainedResize, of type TConstrainedResizeEvent: void fastcall ( closure *TConstrainedResizeEvent)(System::TObject Sender, int &MinWidth, int &MinHeight, int &MaxWidth, int &MaxHeight); This event allows you to override the size constraints when an attempt is made to resize the control. The values of the constraints are passed as var parameters which can be changed inside the event handler. OnConstrainedResize is published for container objects (TForm, TScrollBox, TControlBar, and TPanel). In addition,\n\n\n\ncomponent writers can use or publish this event for any descendant of TControl. Controls that have contents that can change in size have an AutoSize property that causes the control to adjust its size to its font or contained objects. Working with messages A message is a notification that some event has occurred that is sent by Windows to an application. The message itself is a record passed to a control by Windows For instance, when you click a mouse button on a dialog box, Windows sends a message to the active control and the application containing that control reacts to this new event. If the click occurs over a button, the OnClick event could be activated upon receipt of the message. If the click occurs just in the form, the application can ignore the message. The record type passed to the application by Windows is called a TMsg. Windows predefines a constant for each message, and these values are stored in the message field of the TMsg record. Each of these constants begin with\n\n\n\nthe letters wm The VCL automatically handles messages unless you override the message handling system and create your own message handlers. For more information on messages and message handling, see “Understanding the message-handling system” on page 45-1, “Changing message handling” on page 45-3, and “Creating new message handlers” on page 45-5. 4-4 Developer’s Guide More details on forms More details on forms When you create a form in C++Builder from the IDE, C++Builder automatically creates the form in memory by including code in the WinMain() function. Usually, this is the desired behavior and you don’t have to do anything to change it. That is, the main window persists through the duration of your program, so you would likely not change the default C++Builder behavior when creating the form for your main window. However, you may not want all your application’s forms in memory for the duration of the program execution. That is, if you do not want all your\n\n\n\napplication’s dialogs in memory at once, you can create the dialogs dynamically when you want them to appear. Forms can be modal or modeless. Modal forms are forms with which the user must interact before switching to another form (for example, a dialog box requiring user input). Modeless forms, though, are windows that are displayed until they are either obscured by another window or until they are closed or minimized by the user. Controlling when forms reside in memory By default, C++Builder automatically creates the application’s main form in memory by including the following code in the application’s WinMain() function: Application ->CreateForm( classid(TForm1), &Form1); This function creates a global variable with the same name as the form. So, every form in an application has an associated global variable. This variable is a pointer to an instance of the form’s class and is used to reference the form while the application is running. Any source code (cpp) file\n\n\n\nthat includes the form’s header (h) file can access the form via this variable. Because the form is added to the WinMain(), the form appears when the program is invoked and it exists in memory for the duration of the application. Displaying an auto-created form If you choose to create a form at startup, and do not want it displayed until sometime later during program execution, the form’s event handler uses the ShowModal method to display the form that is already loaded in memory: void fastcall TMainMForm::FirstButtonClick(TObject *Sender) { ResultsForm->ShowModal(); } In this case, since the form is already in memory, there is no need to create another instance or destroy that instance. Creating forms dynamically You may not always want all your application’s forms in memory at once. To reduce the amount of memory required at load time, you may want to create some forms Developing the application user interface 4-5 M o r ehttp://www.doksihu details on forms Forrás: \n\n\n\nonly when you need to use them. For example, a dialog box needs to be in memory only during the time a user interacts with it. To create a form at a different stage during execution using the IDE, you: 1 Select the File|New Form from the Component bar to display the new form. 2 Remove the form from the Auto-create forms list of the Project Options|Forms page. This removes the form’s invocation in WinMain(). As an alternative, you can manually remove the following line from WinMain(): Application->CreateForm( classid(TResultsForm), &ResultsForm); 3 Invoke the form when desired by using the form’s Show method, if the form is modeless, or ShowModal method, if the form is modal. An event handler for the main form must create an instance of the result form and destroy it. One way to invoke the result form is to use the global variable as follows Note that ResultsForm is a modal form so the handler uses the ShowModal method. void fastcall TMainMForm::FirstButtonClick(TObject\n\n\n\n*Sender) { ResultsForm = new TResultsForm(this); ResultsForm->ShowModal(); delete ResultsForm; } The event handler in the example deletes the form after it is closed, so the form would need to be recreated using new if you needed to use ResultsForm elsewhere in the application. If the form were displayed using Show you could not delete the form within the event handler because Show returns while the form is still open. Note If you create a form using the new operator, be sure to check that the form is not in the Auto-create forms list on the Project Options|Forms page. Specifically, if you create the new form without deleting the form of the same name from the list, C++Builder creates the form at startup and this event-handler creates a new instance of the form, overwriting the reference to the auto-created instance. The auto-created instance still exists, but the application can no longer access it. After the event-handler terminates, the global variable no longer points to a\n\n\n\nvalid form. Any attempt to dereference the global variable will likely crash the application. Creating modeless forms such as windows You must guarantee that reference variables for modeless forms exist for as long as the form is in use. This means that these variables should have global scope In most cases, you use the global reference variable that was created when you made the form (the variable name that matches the name property of the form). If your application requires additional instances of the form, declare separate global variables (of type pointer to the form class) for each instance. 4-6 Developer’s Guide More details on forms Using a local variable to create a form instance A safer way to create a unique instance of a modal form is to use a local variable in the event handler as a reference to a new instance. If a local variable is used, it does not matter whether ResultsForm is auto-created or not. The code in the event handler makes no reference to the global\n\n\n\nform variable. For example: void fastcall TMainMForm::FirstButtonClick(TObject *Sender) { TResultsForm *rf = new TResultsForm(this);// rf is local form instance rf->ShowModal(); delete rf; // form safely destroyed } Notice how the global instance of the form is never used in this version of the event handler. Typically, applications use the global instances of forms. However, if you need a new instance of a modal form, and you use that form in a limited, discrete section of the application, such as a single function, a local instance is usually the safest and most efficient way of working with the form. Of course, you cannot use local variables in event handlers for modeless forms because they must have global scope to ensure that the forms exist for as long as the form is in use. Show returns as soon as the form opens, so if you used a local variable, the local variable would go out of scope immediately. Passing additional arguments to forms Typically, you create forms for your\n\n\n\napplication from within the IDE. When created this way, the forms have a constructor that takes one argument, Owner, which is a pointer to the owner of the form being created. (The owner is the calling application object or form object.) Owner can be NULL To pass additional arguments to a form, create a separate constructor and instantiate the form using the new operator. The example form class below shows an additional constructor, with the extra argument whichButton. This new constructor is added to the form class manually. class TResultsForm : public TForm { published: // IDE-managed Components TLabel *ResultsLabel; TButton *OKButton; void fastcall OKButtonClick(TObject *Sender); private: // User declarations public: // User declarations virtual fastcall TResultsForm(TComponent* Owner); virtual fastcall TResultsForm(int whichButton, TComponent* Owner); }; Developing the application user interface 4-7 M o r ehttp://www.doksihu details on forms Forrás: Here’s the\n\n\n\nmanually coded constructor that passes the additional argument, whichButton. This constructor uses the whichButton parameter to set the Caption property of a Label control on the form. void fastcall TResultsForm::TResultsForm(int whichButton, TComponent* Owner) : TForm(Owner) { switch (whichButton) { case 1: ResultsLabel->Caption = \"You picked the first button!\"; break; case 2: ResultsLabel->Caption = \"You picked the second button!\"; break; case 3: ResultsLabel->Caption = \"You picked the third button!\"; } } When creating an instance of a form with multiple constructors, you can select the constructor that best suits your purpose. For example, the following OnClick handler for a button on a form calls creates an instance of TResultsForm that uses the extra parameter: void fastcall TMainMForm::SecondButtonClick(TObject *Sender) { TResultsForm *rf = new TResultsForm(2, this); rf->ShowModal(); delete rf; } Retrieving data from forms Most\n\n\n\nreal-world applications consist of several forms. Often, information needs to be passed between these forms. Information can be passed to a form by means of parameters to the receiving form’s constructor, or by assigning values to the form’s properties. The way you get information from a form depends on whether the form is modal or modeless. Retrieving data from modeless forms You can easily extract information from modeless forms by calling public member functions of the form or by querying properties of the form. For example, assume an application contains a modeless form called ColorForm that contains a listbox called ColorListBox with a list of colors (“Red”, “Green”, “Blue”, and so on). The selected color name string in ColorListBox is automatically stored in a property called 4-8 Developer’s Guide More details on forms CurrentColor each time a user selects a new color. The class declaration for the form is as follows: class TColorForm : public TForm { \n\n\n\npublished: // IDE-managed Components TListBox *ColorListBox; void fastcall ColorListBoxClick(TObject *Sender); private: // User declarations String getColor(); void setColor(String); String curColor; public: // User declarations virtual fastcall TColorForm(TComponent* Owner); property String CurrentColor = {read=getColor, write=setColor}; }; The OnClick event handler for the listbox, ColorListBoxClick, sets the value of the CurrentColor property each time a new item in the listbox is selected. The event handler gets the string from the listbox containing the color name and assigns it to CurrentColor. The CurrentColor property uses the setter function, setColor, to store the actual value for the property in the private data member curColor: void fastcall TColorForm::ColorListBoxClick(TObject *Sender) { int index = ColorListBox->ItemIndex; if (index >= 0) {// make sure a color is selected CurrentColor = ColorListBox->Items->Strings[index]; } else // no color selected\n\n\n\nCurrentColor = \"\"; } //--------------------------------------------------------------------void TColorForm::setColor(String s) { curColor = s; } Now suppose that another form within the application, called ResultsForm, needs to find out which color is currently selected on ColorForm whenever a button (called UpdateButton) on ResultsForm is clicked. The OnClick event handler for UpdateButton might look like this: void fastcall TResultsForm::UpdateButtonClick(TObject *Sender) { if (ColorForm) {// verify ColorForm exists String s = ColorForm->CurrentColor; // do something with the color name string } } Developing the application user interface 4-9 M o r ehttp://www.doksihu details on forms Forrás: The event handler first verifies that ColorForm exists by checking whether the point is NULL. It then gets the value of ColorForm’s CurrentColor property The query of CurrentColor calls its getter function getColor which is shown here: String TColorForm::getColor() {\n\n\n\nreturn curColor; } Alternatively, if ColorForm’s getColor function were public, another form could get the current color without using the CurrentColor property (for example, String s = ColorForm->getColor();). In fact, there’s nothing to prevent another form from getting the ColorForm’s currently selected color by checking the listbox selection directly: String s = ColorListBox->Items->Strings[ColorListBox->ItemIndex]; However, using a property makes the interface to ColorForm very straightforward and simple. All a form needs to know about ColorForm is to check the value of CurrentColor. Retrieving data from modal forms Just like modeless forms, modal forms often contain information needed by other forms. The most common example is form A launches modal form B When form B is closed, form A needs to know what the user did with form B to decide how to proceed with the processing of form A. If form B is still in memory, it can be queried through properties or member\n\n\n\nfunctions just as in the modeless forms example above. But how do you handle situations where form B is deleted from memory upon closing? Since a form does not have an explicit return value, you must preserve important information from the form before it is destroyed. To illustrate, consider a modified version of the ColorForm form that is designed to be a modal form. The class declaration is as follows: class TColorForm : public TForm { published: // IDE-managed Components TListBox *ColorListBox; TButton *SelectButton; TButton *CancelButton; void fastcall CancelButtonClick(TObject *Sender); void fastcall SelectButtonClick(TObject *Sender); private: // User declarations String* curColor; public: // User declarations virtual fastcall TColorForm(TComponent* Owner); virtual fastcall TColorForm(String* s, TComponent Owner); }; The form has a listbox called ColorListBox with a list of names of colors. When pressed, the button called SelectButton makes note of the currently\n\n\n\nselected color name in ColorListBox then closes the form. CancelButton is a button that simply closes the form. 4-10 Developer’s Guide More details on forms Note that a user-defined constructor was added to the class that takes a String* argument. Presumably, this String* points to a string that the form launching ColorForm knows about. The implementation of this constructor is as follows: void fastcall TColorForm::TColorForm(String* s, TComponent Owner) : TForm(Owner) { curColor = s; *curColor = \"\"; } The constructor saves the pointer to a private data member curColor and initializes the string to an empty string. Note To use the above user-defined constructor, the form must be explicitly created. It cannot be auto-created when the application is started. For details, see “Controlling when forms reside in memory” on page 4-5. In the application, the user selects a color from the listbox and presses SelectButton to save the choice and close the form. The\n\n\n\nOnClick event handler for SelectButton might look like this: void fastcall TColorForm::SelectButtonClick(TObject *Sender) { int index = ColorListBox->ItemIndex; if (index >= 0) *curColor = ColorListBox->Items->Strings[index]; Close(); } Notice that the event handler stores the selected color name in the string address that was passed to the constructor. To use ColorForm effectively, the calling form must pass the constructor a pointer to an existing string. For example, assume ColorForm was instantiated by a form called ResultsForm in response to a button called UpdateButton on ResultsForm being clicked. The event handler would look as follows: void fastcall TResultsForm::UpdateButtonClick(TObject *Sender) { String s; GetColor(&s); if (s != \"\") { // do something with the color name string } else { // do something else because no color was picked } } //--------------------------------------------------------------------void TResultsForm::GetColor(String\n\n\n\n*s) { ColorForm = new TColorForm(s, this); ColorForm->ShowModal(); delete ColorForm; ColorForm = 0; // NULL the pointer } Developing the application user interface 4-11 R e u http://www.doksihu sing components and groups of components Forrás: UpdateButtonClick creates a String called s. The address of s is passed to the GetColor function which creates ColorForm, passing the pointer to s as an argument to the constructor. As soon as ColorForm is closed it is deleted, but the color name that was selected is still preserved in s, assuming that a color was selected. Otherwise, s contains an empty string which is a clear indication that the user exited ColorForm without selecting a color. This example uses one string variable to hold information from the modal form. Of course, more complex objects can be used depending on the need. Keep in mind that you should always provide a way to let the calling form know if the modal form was closed without making any changes or selections\n\n\n\n(such as having s default to an empty string). Reusing components and groups of components C++Builder offers several ways to save and reuse work you’ve done with VCL components:\n• Component templates provide a simple, quick way of configuring and saving groups of components. See “Creating and using component templates” on page 4-12.\n• You can save forms, data modules, and projects in the Repository. This gives you a central database of reusable elements and lets you use form inheritance to propagate changes.\n• You can save frames on the Component palette or in the repository. Frames use form inheritance and can be embedded into forms or other frames. See “Working with frames” on page 4-13.\n• Creating a custom component is the most complicated way of reusing code, but it offers the greatest flexibility. See Chapter 39, “Overview of component creation” Creating and using component templates You can create templates that are made up of one or more components. After\n\n\n\narranging components on a form, setting their properties, and writing code for them, save them as a component template. Later, by selecting the template from the Component palette, you can place the preconfigured components on a form in a single step; all associated properties and event-handling code are added to your project at the same time. Once you place a template on a form, you can reposition the components independently, reset their properties, and create or modify event handlers for them just as if you had placed each component in a separate operation. To create a component template, 1 Place and arrange components on a form. In the Object Inspector, set their properties and events as desired. 4-12 Developer’s Guide Working with frames 2 Select the components. The easiest way to select several components is to drag the mouse over all of them. Gray handles appear at the corners of each selected component. 3 Choose Component|Create Component Template. 4 Specify a name\n\n\n\nfor the component template in the Component Name edit box. The default proposal is the component type of the first component selected in step 2 followed by the word “Template”. For example, if you select a label and then an edit box, the proposed name will be “TLabelTemplate”. You can change this name, but be careful not to duplicate existing component names. 5 In the Palette Page edit box, specify the Component palette page where you want the template to reside. If you specify a page that does not exist, a new page is created when you save the template. 6 Under Palette Icon, select a bitmap to represent the template on the palette. The default proposal will be the bitmap used by the component type of the first component selected in step 2. To browse for other bitmaps, click Change The bitmap you choose must be no larger than 24 pixels by 24 pixels. 7 Click OK. To remove templates from the Component palette, choose Component|Configure Palette. Working with frames A frame\n\n\n\n(TFrame), like a form, is a container for other components. It uses the same ownership mechanism as forms for automatic instantiation and destruction of the components on it, and the same parent-child relationships for synchronization of component properties. In some ways, however, a frame is more like a customized component than a form. Frames can be saved on the Component palette for easy reuse, and they can be nested within forms, other frames, or other container objects. After a frame is created and saved, it continues to function as a unit and to inherit changes from the components (including other frames) it contains. When a frame is embedded in another frame or form, it continues to inherit changes made to the frame from which it derives. Creating frames To create an empty frame, choose File|New Frame, or choose File|New and double-click on Frame. You can now drop components (including other frames) onto your new frame. It is usually bestthough not necessaryto save frames as\n\n\n\npart of a project. If you want to create a project that contains only frames and no forms, choose File|New Application, close the new form and unit without saving them, then choose File| New Frame and save the project. Developing the application user interface 4-13 W o r http://www.doksihu king with frames Forrás: Note When you save frames, avoid using the default names Unit1, Project1, and so forth, since these are likely to cause conflicts when you try to use the frames later. At design time, you can display any frame included in the current project by choosing View|Forms and selecting a frame. As with forms and data modules, you can toggle between the Form Designer and the frame’s .DFM file by right-clicking and choosing View as Form or View as Text. Adding frames to the Component palette Frames are added to the Component palette as component templates. To add a frame to the Component palette, open the frame in the Form Designer (you cannot use a frame embedded in another\n\n\n\ncomponent for this purpose), right-click on the frame, and choose Add to Palette. When the Component Template Information dialog opens, select a name, palette page, and icon for the new template. Using and modifying frames To use a frame in an application, you must place it, directly or indirectly, on a form. You can add frames directly to forms, to other frames, or to other container objects such as panels and scroll boxes. The Form Designer provides two ways to add a frame to an application:\n• Select a frame from the Component palette and drop it onto a form, another frame, or another container object. If necessary, the Form Designer asks for permission to include the frame’s unit file in your project.\n• Select Frames from the Standard page of the Component palette and click on a form or another frame. A dialog appears with a list of frames that are already included in your project; select one and click OK. When you drop a frame onto a form or other container, C++Builder\n\n\n\ndeclares a new class that descends from the frame you selected. (Similarly, when you add a new form to a project, C++Builder declares a new class that descends from TForm.) This means that changes made later to the original (ancestor) frame propagate to the embedded frame, but changes to the embedded frame do not propagate backward to the ancestor. Suppose, for example, that you wanted to assemble a group of data-access components and data-aware controls for repeated use, perhaps in more than one application. One way to accomplish this would be to collect the components into a component template; but if you started to use the template and later changed your mind about the arrangement of the controls, you would have to go back and manually alter each project where the template was placed. If, on the other hand, you put your database components into a frame, later changes would need to be made in only one place; changes to an original frame automatically propagate to its embedded\n\n\n\ndescendants when your projects are recompiled. At the same time, you are free to modify any embedded frame without affecting the original frame or other embedded descendants of it. The only limitation on modifying embedded frames is that you cannot add components to them. 4-14 Developer’s Guide Creating and managing menus Figure 4.1 A frame with data-aware controls and a data source component In addition to simplifying maintenance, frames can help you to use resources more efficiently. For example, to use a bitmap or other graphic in an application, you might load the graphic into the Picture property of a TImage control. If, however, you use the same graphic repeatedly in one application, each Image object you place on a form will result in another copy of the graphic being added to the form’s resource file. (This is true even if you set TImage::Picture once and save the Image control as a component template.) A better solution is to drop the Image object onto a frame,\n\n\n\nload your graphic into it, then use the frame where you want the graphic to appear. This results in smaller form files and has the added advantage of letting you change the graphic everywhere it occurs simply by modifying the Image on the original frame. Sharing frames You can share a frame with other developers in two ways:\n• Add the frame to the Object Repository.\n• Distribute the frame’s unit (.CPP and h) and form (DFM) files To add a frame to the Repository, open any project that includes the frame, right-click in the Form Designer, and choose Add to Repository. If you send a frame’s unit and form files to other developers, they can open them and add them to the Component palette. If the frame has other frames embedded in it, they will have to open it as part of a project. Creating and managing menus Menus provide an easy way for your users to execute logically grouped commands. The Menu Designer enables you to easily add a menueither predesigned or custom tailoredto your\n\n\n\nform. You simply add a menu component to the form, open the Menu Designer, and type menu items directly into the Menu Designer window. You can add or delete menu items, or drag and drop them to rearrange them during design time. You don’t even need to run your program to see the resultsyour design is immediately visible in the form, appearing just as it will during runtime. Your code can also change menus at runtime, to provide more information or options to the user. Developing the application user interface 4-15 C r e ahttp://www.doksihu ting and managing menus Forrás: This chapter explains how to use the Menu Designer to design menu bars and pop-up (local) menus. It discusses the following ways to work with menus at design time and runtime:\n• \n• \n• \n• \n• \n• \n• Opening the Menu Designer Building menus Editing menu items in the Object Inspector Using the Menu Designer context menu Using menu templates Saving a menu as a template Adding images to menu items Figure 4.2\n\n\n\n Menu terminology Menu items on the menu bar Accelerator key Menu items in a menu list Separator bar Keyboard shortcut Opening the Menu Designer To start using the Menu Designer, first add either a MainMenu or PopupMenu component to your form. Both menu components are located on the Standard page of the Component palette. Figure 4.3 MainMenu and PopupMenu components MainMenu component PopupMenu component A MainMenu component creates a menu that’s attached to the form’s title bar. A PopupMenu component creates a menu that appears when the user right-clicks in the form. Pop-up menus do not have a menu bar To open the Menu Designer, select a menu component on the form, and then choose from one of the following methods:\n• Double-click the menu component.\n• From the Properties page of the Object Inspector, select the Items property, and then either double-click [Menu] in the Value column, or click the ellipsis (.) button. The Menu Designer appears, with the first (blank) menu\n\n\n\nitem highlighted in the Designer, and the Caption property selected in the Object Inspector. 4-16 Developer’s Guide Creating and managing menus Figure 4.4 Menu Designer for a pop-up menu Placeholder for first menu item Figure 4.5 Menu Designer for a main menu Title bar (shows Name property for Menu component) Menu bar Placeholder for menu item Menu Designer displays WYSIWYG menu items as you build the menu. A TMenuItem object is created and the Name property set to the menu item Caption you specify (minus any illegal characters and plus a numeric suffix). Building menus You add a menu component to your form, or forms, for every menu you want to include in your application. You can build each menu structure entirely from scratch, or you can start from one of the predesigned menu templates. Developing the application user interface 4-17 C r e ahttp://www.doksihu ting and managing menus Forrás: This section discusses the basics of creating a menu at design time. For\n\n\n\nmore information about menu templates, see “Using menu templates” on page 4-24. Naming menus As with all components, when you add a menu component to the form, C++Builder gives it a default name; for example, MainMenu1. You can give the menu a more meaningful name that follows Object Pascal naming conventions. C++Builder adds the menu name to the form’s type declaration, and the menu name then appears in the Component list. Naming the menu items In contrast to the menu component itself, you need to explicitly name menu items as you add them to the form. You can do this in one of two ways:\n• Directly type in the value for the Name property.\n• Type in the value for the Caption property first, and let C++Builder derive the Name property from the caption. For example, if you give a menu item a Caption property value of File, C++Builder assigns the menu item a Name property of File1. If you fill in the Name property before filling in the Caption property, C++Builder leaves the\n\n\n\nCaption property blank until you type in a value. Note If you enter characters in the Caption property that are not valid for C++ identifiers, C++Builder modifies the Name property accordingly. For example, if you want the caption to start with a number, C++Builder precedes the number with a character to derive the Name property. The following table demonstrates some examples of this, assuming all menu items shown appear in the same menu bar. Table 4.1 Sample captions and their derived names Component caption Derived name &File File1 Explanation Removes ampersand &File (2nd occurrence) File2 Numerically orders duplicate items 1234 N12341 Adds a preceding letter and numerical order 1234 (2nd occurrence) N12342 Adds a number to disambiguate the derived name $@@@# N1 Removes all non-standard characters, adding preceding letter and numerical order – (hyphen) N2 Numerical ordering of second occurrence of caption with no standard characters As with the menu\n\n\n\ncomponent, C++Builder adds any menu item names to the form’s type declaration, and those names then appear in the Component list. 4-18 Developer’s Guide Creating and managing menus Adding, inserting, and deleting menu items The following procedures describe how to perform the basic tasks involved in building your menu structure. Each procedure assumes you have the Menu Designer window open. To add menu items at design time, 1 Select the position where you want to create the menu item. If you’ve just opened the Menu Designer, the first position on the menu bar is already selected. 2 Begin typing to enter the caption. Or enter the Name property first by specifically placing your cursor in the Object Inspector and entering a value. In this case, you then need to reselect the Caption property and enter a value. 3 Press Enter. The next placeholder for a menu item is selected. If you entered the Caption property first, use the arrow keys to return to the menu item you just\n\n\n\nentered. You’ll see that C++Builder has filled in the Name property based on the value you entered for the caption. (See “Naming the menu items” on page 4-18.) 4 Continue entering values for the Name and Caption properties for each new item you want to create, or press Esc to return to the menu bar. Use the arrow keys to move from the menu bar into the menu, and to then move between items in the list; press Enter to complete an action. To return to the menu bar, press Esc. To insert a new, blank menu item, 1 Place the cursor on a menu item. 2 Press Ins. Menu items are inserted to the left of the selected item on the menu bar, and above the selected item in the menu list. To delete a menu item or command, 1 Place the cursor on the menu item you want to delete. 2 Press Del. Note You cannot delete the default placeholder that appears below the item last entered in a menu list, or next to the last item on the menu bar. This placeholder does not appear in your menu at runtime. \n\n\n\nAdding separator bars Separator bars insert a line between menu items. You can use separator bars to indicate groupings within the menu list, or simply to provide a visual break in a list. To make the menu item a separator bar, type a hyphen (–) for the caption. Developing the application user interface 4-19 C r e ahttp://www.doksihu ting and managing menus Forrás: Specifying accelerator keys and keyboard shortcuts Accelerator keys enable the user to access a menu command from the keyboard by pressing Alt+ the appropriate letter, indicated in your code by the preceding ampersand. The letter after the ampersand appears underlined in the menu C++Builder automatically checks for duplicate accelerators and adjusts them at runtime. This ensures that menus built dynamically at runtime contain no duplicate accelerators and that all menu items have an accelerator. You can turn off this automatic checking by setting the AutoHotkeys property of a menu item to maManual. To specify an\n\n\n\naccelerator,\n• Add an ampersand in front of the appropriate letter. For example, to add a Save menu command with the S as an accelerator key, type &Save. Keyboard shortcuts enable the user to perform the action without the menu directly, by typing in the shortcut key combination. To specify a keyboard shortcut,\n• Use the Object Inspector to enter a value for the ShortCut property, or select a key combination from the drop-down list. This list is only a subset of the valid combinations you can type in. When you add a shortcut, it appears next to the menu item caption. Caution Keyboard shortcuts, unlike accelerator keys, are not checked automatically for duplicates. You must ensure uniqueness yourself Creating submenus Many application menus contain drop-down lists that appear next to a menu item to provide additional, related commands. Such lists are indicated by an arrow to the right of the menu item. C++Builder supports as many levels of such submenus as you want to build\n\n\n\ninto your menu. Organizing your menu structure this way can save vertical screen space. However, for optimal design purposes you probably want to use no more than two or three menu levels in your interface design. (For pop-up menus, you might want to use only one submenu, if any.) Figure 4.6 Nested menu structures Menu item on the menu bar Menu item in a menu list Nested menu item 4-20 Developer’s Guide Creating and managing menus To create a submenu, 1 Select the menu item under which you want to create a submenu. 2 Press Ctrl to create the first placeholder, or right-click and choose Create Submenu. 3 Type a name for the submenu item, or drag an existing menu item into this placeholder. 4 Press Enter, or ↓, to create the next placeholder. 5 Repeat steps 3 and 4 for each item you want to create in the submenu. 6 Press Esc to return to the previous menu level. Creating submenus by demoting existing menus You can create a submenu by inserting a menu item from the menu bar\n\n\n\n(or a menu template) between menu items in a list. When you move a menu into an existing menu structure, all its associated items move with it, creating a fully intact submenu. This pertains to submenus as wellmoving a menu item into an existing submenu just creates one more level of nesting. Moving menu items During design time, you can move menu items simply by dragging and dropping. You can move menu items along the menu bar, or to a different place in the menu list, or into a different menu entirely. The only exception to this is hierarchical: you cannot demote a menu item from the menu bar into its own menu; nor can you move a menu item into its own submenu. However, you can move any item into a different menu, no matter what its original position is. While you are dragging, the cursor changes shape to indicate whether you can release the menu item at the new location. When you move a menu item, any items beneath it move as well. To move a menu item along the menu bar, 1 Drag\n\n\n\nthe menu item along the menu bar until the arrow tip of the drag cursor points to the new location. 2 Release the mouse button to drop the menu item at the new location. To move a menu item into a menu list, 1 Drag the menu item along the menu bar until the arrow tip of the drag cursor points to the new menu. This causes the menu to open, enabling you to drag the item to its new location. 2 Drag the menu item into the list, releasing the mouse button to drop the menu item at the new location. Developing the application user interface 4-21 C r e ahttp://www.doksihu ting and managing menus Forrás: Adding images to menu items Images can help users navigate in menus by matching glyphs and images to menu item action, similar to toolbar images. To add an image to a menu item: 1 Drop a TMainMenu or TPopupMenu object on a form. 2 Drop a TImageList object on the form. 3 Open the ImageList editor by double clicking on the TImageList object. 4 Click Add to select the bitmap or bitmap\n\n\n\ngroup you want to use in the menu. Click OK. 5 Set the TMainMenu or TPopupMenu object’s Images property to the ImageList you just created. 6 Create your menu items and submenu items as described above. 7 Select the menu item you want to have an image in the Object Inspector and set the ImageIndex property to the corresponding number of the image in the ImageList (the default value for ImageIndex is -1, which doesn’t display an image). Note Use images that are 16 by 16 pixels for proper display in the menu. Although you can use other sizes for the menu images, alignment and consistency problems may result when using images greater than or smaller than 16 by 16 pixels. Viewing the menu You can view your menu in the form at design time without first running your program code. (Pop-up menu components are visible in the form at design time, but the pop-up menus themselves are not. Use the Menu Designer to view a pop-up menu at design time.) To view the menu, 1 If the form is visible,\n\n\n\nclick the form, or from the View menu, choose the form whose menu you want to view. 2 If the form has more than one menu, select the menu you want to view from the form’s Menu property drop-down list. The menu appears in the form exactly as it will when you run the program. Editing menu items in the Object Inspector This section has discussed how to set several properties for menu itemsfor example, the Name and Caption propertiesby using the Menu Designer. The section has also described how to set menu item properties, such as the ShortCut property, directly in the Object Inspector, just as you would for any component selected in the form. 4-22 Developer’s Guide Creating and managing menus When you edit a menu item by using the Menu Designer, its properties are still displayed in the Object Inspector. You can switch focus to the Object Inspector and continue editing the menu item properties there. Or you can select the menu item from the Component list in the Object\n\n\n\nInspector and edit its properties without ever opening the Menu Designer. To close the Menu Designer window and continue editing menu items, 1 Switch focus from the Menu Designer window to the Object Inspector by clicking the properties page of the Object Inspector. 2 Close the Menu Designer as you normally would. The focus remains in the Object Inspector, where you can continue editing properties for the selected menu item. To edit another menu item, select it from the Component list. Using the Menu Designer context menu The Menu Designer context menu provides quick access to the most common Menu Designer commands, and to the menu template options. (For more information about menu templates, refer to “Using menu templates” on page 4-24.) To display the context menu, right-click the Menu Designer window, or press Alt+F10 when the cursor is in the Menu Designer window. Commands on the context menu The following table summarizes the commands on the Menu Designer context menu.\n\n\n\nTable 4.2 Menu Designer context menu commands Menu command Action Insert Inserts a placeholder above or to the left of the cursor. Delete Deletes the selected menu item (and all its sub-items, if any). Create Submenu Creates a placeholder at a nested level and adds an arrow to the right of the selected menu item. Select Menu Opens a list of menus in the current form. Double-clicking a menu name opens the designer window for the menu. Save As Template Opens the Save Template dialog box, where you can save a menu for future reuse. Insert From Template Opens the Insert Template dialog box, where you can select a template to reuse. Delete Templates Opens the Delete Templates dialog box, where you can choose to delete any existing templates. Insert From Resource Opens the Insert Menu from Resource file dialog box, where you can choose an .MNU file to open in the current form Developing the application user interface 4-23 C r e ahttp://www.doksihu ting and managing\n\n\n\nmenus Forrás: Switching between menus at design time If you’re designing several menus for your form, you can use the Menu Designer context menu or the Object Inspector to easily select and move among them. To use the context menu to switch between menus in a form, 1 Right-click in the Menu Designer and choose Select Menu. The Select Menu dialog box appears. Figure 4.7 Select Menu dialog box This dialog box lists all the menus associated with the form whose menu is currently open in the Menu Designer. 2 From the list in the Select Menu dialog box, choose the menu you want to view or edit. To use the Object Inspector to switch between menus in a form, 1 Give focus to the form whose menus you want to choose from. 2 From the Component list, select the menu you want to edit. 3 On the Properties page of the Object Inspector, select the Items property for this menu, and then either click the ellipsis button, or double-click [Menu]. Using menu templates C++Builder provides several\n\n\n\npredesigned menus, or menu templates, that contain frequently used commands. You can use these menus in your applications without modifying them (except to write code), or you can use them as a starting point, customizing them as you would a menu you originally designed yourself. Menu templates do not contain any event handler code. The menu templates shipped with C++Builder are stored in the BIN subdirectory in a default installation. These files have a DMT (C++Builder menu template) extension You can also save as a template any menu that you design using the Menu Designer. After saving a menu as a template, you can use it as you would any predesigned menu. If you decide you no longer want a particular menu template, you can delete it from the list. 4-24 Developer’s Guide Creating and managing menus To add a menu template to your application, 1 Right-click the Menu Designer and choose Insert From Template. (If there are no templates, the Insert From Template option appears\n\n\n\ndimmed in the context menu.) The Insert Template dialog box opens, displaying a list of available menu templates. Figure 4.8 Sample Insert Template dialog box for menus 2 Select the menu template you want to insert, then press Enter or choose OK. This inserts the menu into your form at the cursor’s location. For example, if your cursor is on a menu item in a list, the menu template is inserted above the selected item. If your cursor is on the menu bar, the menu template is inserted to the left of the cursor. To delete a menu template, 1 Right-click the Menu Designer and choose Delete Templates. (If there are no templates, the Delete Templates option appears dimmed in the context menu.) The Delete Templates dialog box opens, displaying a list of available templates. 2 Select the menu template you want to delete, and press Del. C++Builder deletes the template from the templates list and from your hard disk. Saving a menu as a template Any menu you design can be saved as a template\n\n\n\nso you can use it again. You can use menu templates to provide a consistent look to your applications, or use them as a starting point which you then further customize. The menu templates you save are stored in your BIN subdirectory as .DMT files To save a menu as a template, 1 Design the menu you want to be able to reuse. This menu can contain as many items, commands, and submenus as you like; everything in the active Menu Designer window will be saved as one reusable menu. Developing the application user interface 4-25 C r e ahttp://www.doksihu ting and managing menus Forrás: 2 Right-click in the Menu Designer and choose Save As Template. The Save Template dialog box appears. Figure 4.9 Save Template dialog box for menus 3 In the Template Description edit box, type a brief description for this menu, and then choose OK. The Save Template dialog box closes, saving your menu design and returning you to the Menu Designer window. Note The description you enter is displayed only\n\n\n\nin the Save Template, Insert Template, and Delete Templates dialog boxes. It is not related to the Name or Caption property for the menu. Naming conventions for template menu items and event handlers When you save a menu as a template, C++Builder does not save its Name property, since every menu must have a unique name within the scope of its owner (the form). However, when you insert the menu as a template into a new form by using the Menu Designer, C++Builder then generates new names for it and all of its items. For example, suppose you save a File menu as a template. In the original menu, you name it MyFile. If you insert it as a template into a new menu, C++Builder names it File1. If you insert it into a menu with an existing menu item named File1, C++Builder names it File2. C++Builder also does not save any OnClick event handlers associated with a menu saved as a template, since there is no way to test whether the code would be applicable in the new form. When you generate a new\n\n\n\nevent handler for the menu template item, C++Builder still generates the event handler name. You can easily associate items in the menu template with existing OnClick event handlers in the form. 4-26 Developer’s Guide Creating and managing menus Manipulating menu items at runtime Sometimes you want to add menu items to an existing menu structure while the application is running, to provide more information or options to the user. You can insert a menu item by using the menu item’s Add or Insert method, or you can alternately hide and show the items in a menu by changing their Visible property. The Visible property determines whether the menu item is displayed in the menu. To dim a menu item without hiding it, use the Enabled property. For examples that use the menu item’s Visible and Enabled properties, see “Disabling menu items” on page 5-9. In multiple document interface (MDI) and Object Linking and Embedding (OLE) applications, you can also merge menu items into an\n\n\n\nexisting menu bar. The following section discusses this in more detail. Merging menus For MDI applications, such as the text editor sample application, and for OLE client applications, your application’s main menu needs to be able to receive menu items either from another form or from the OLE server object. This is often called merging menus. You prepare menus for merging by specifying values for two properties:\n• Menu, a property of the form\n• GroupIndex, a property of menu items in the menu Specifying the active menu: Menu property The Menu property specifies the active menu for the form. Menu-merging operations apply only to the active menu. If the form contains more than one menu component, you can change the active menu at runtime by setting the Menu property in code. For example, Form1->Menu = SecondMenu; Determining the order of merged menu items: GroupIndex property The GroupIndex property determines the order in which the merging menu items appear in the shared\n\n\n\nmenu bar. Merging menu items can replace those on the main menu bar, or can be inserted. The default value for GroupIndex is 0. Several rules apply when specifying a value for GroupIndex:\n• Lower numbers appear first (farther left) in the menu. For instance, set the GroupIndex property to 0 (zero) for a menu that you always want to appear leftmost, such as a File menu. Similarly, specify a high number (it needn’t be in sequence) for a menu that you always want to appear rightmost, such as a Help menu. Developing the application user interface 4-27 D e s http://www.doksihu igning toolbars and cool bars Forrás:\n• To replace items in the main menu, give items on the child menu the same GroupIndex value. This can apply to groupings or to single items. For example, if your main form has an Edit menu item with a GroupIndex value of 1, you can replace it with one or more items from the child form’s menu by giving them a GroupIndex value of 1 as well. Giving multiple items in the\n\n\n\nchild menu the same GroupIndex value keeps their order intact when they merge into the main menu.\n• To insert items without replacing items in the main menu, leave room in the numeric range of the main menu’s items and “plug in” numbers from the child form. For example, number the items in the main menu 0 and 5, and insert items from the child menu by numbering them 1, 2, 3, and 4. Importing resource files C++Builder supports menus built with other applications, so long as they are in the standard Windows resource (.RC) file format You can import such menus directly into your C++Builder project, saving you the time and effort of rebuilding menus that you created elsewhere. To load existing .RC menu files, 1 In the Menu Designer, place your cursor where you want the menu to appear. The imported menu can be part of a menu you are designing, or an entire menu in itself. 2 Right-click and choose Insert From Resource. The Insert Menu From Resource dialog box appears. 3 In the\n\n\n\ndialog box, select the resource file you want to load, and choose OK. The menu appears in the Menu Designer window. Note If your resource file contains more than one menu, you first need to save each menu as a separate resource file before importing it. Designing toolbars and cool bars A toolbar is a panel, usually across the top of a form (under the menu bar), that holds buttons and other controls. A cool bar (also called a rebar) is a kind of toolbar that displays controls on movable, resizable bands. If you have multiple panels aligned to the top of the form, they stack vertically in the order added. You can put controls of any sort on a toolbar. In addition to buttons, you may want to put use color grids, scroll bars, labels, and so on. 4-28 Developer’s Guide Designing toolbars and cool bars There are several ways to add a toolbar to a form:\n• Place a panel (TPanel) on the form and add controls (typically speed buttons) to it.\n• Use a toolbar component (TToolBar)\n\n\n\ninstead of TPanel, and add controls to it. TToolBar manages buttons and other controls, arranging them in rows and automatically adjusting their sizes and positions. If you use tool button (TToolButton) controls on the toolbar, TToolBar makes it easy to group the buttons functionally and provides other display options.\n• Use a cool bar (TCoolBar) component and add controls to it. The cool bar displays controls on independently movable and resizable bands. How you implement your toolbar depends on your application. The advantage of using the Panel component is that you have total control over the look and feel of the toolbar. By using the toolbar and cool bar components, you are ensuring that your application has the look and feel of a Windows application because you are using the native Windows controls. If these operating system controls change in the future, your application could change as well. Also, since the toolbar and cool bar rely on common components in Windows, your\n\n\n\napplication requires the COMCTL32.DLL Toolbars and cool bars are not supported in WinNT 3.51 applications The following sections describe how to\n• Add a toolbar and corresponding speed button controls using the panel component\n• Add a toolbar and corresponding tool button controls using the Toolbar component\n• Add a cool bar using the cool bar component\n• Respond to clicks\n• Add hidden toolbars and cool bars\n• Hide and show toolbars and cool bars Adding a toolbar using a panel component To add a toolbar to a form using the panel component, 1 Add a panel component to the form (from the Standard page of the Component palette). 2 Set the panel’s Align property to alTop. When aligned to the top of the form, the panel maintains its height, but matches its width to the full width of the form’s client area, even if the window changes size. 3 Add speed buttons or other controls to the panel. Speed buttons are designed to work on toolbar panels. A speed button usually has no\n\n\n\ncaption, only a small graphic (called a glyph), which represents the button’s function. Developing the application user interface 4-29 D e s http://www.doksihu igning toolbars and cool bars Forrás: Speed buttons have three possible modes of operation. They can\n• Act like regular pushbuttons\n• Toggle on and off when clicked\n• Act like a set of radio buttons To implement speed buttons on toolbars, do the following:\n• \n• \n• \n• \n• Add a speed button to a toolbar panel Assign a speed button’s glyph Set the initial condition of a speed button Create a group of speed buttons Allow toggle buttons Adding a speed button to a panel To add a speed button to a toolbar panel, place the speed button component (from the Additional page of the Component palette) on the panel. The panel, rather than the form, “owns” the speed button, so moving or hiding the panel also moves or hides the speed button. The default height of the panel is 41, and the default height of speed\n\n\n\nbuttons is 25. If you set the Top property of each button to 8, they’ll be vertically centered. The default grid setting snaps the speed button to that vertical position for you. Assigning a speed button’s glyph Each speed button needs a graphic image called a glyph to indicate to the user what the button does. If you supply the speed button only one image, the button manipulates that image to indicate whether the button is pressed, unpressed, selected, or disabled. You can also supply separate, specific images for each state if you prefer. You normally assign glyphs to speed buttons at design time, although you can assign different glyphs at runtime. To assign a glyph to a speed button at design time, 1 Select the speed button. 2 In the Object Inspector, select the Glyph property. 3 Double-click the Value column beside Glyph to open the Picture Editor and select the desired bitmap. Setting the initial condition of a speed button Speed buttons use their appearance to give the\n\n\n\nuser clues as to their state and purpose. Because they have no caption, it’s important that you use the right visual cues to assist users. 4-30 Developer’s Guide Designing toolbars and cool bars Table 4.3 lists some actions you can set to change a speed button’s appearance: Table 4.3 Setting speed buttons’ appearance To make a speed button: Set the toolbar’s: Appear pressed GroupIndex property to a value other than zero and its Down property to true. Appear disabled Enabled property to false. Have a left margin Indent property to a value greater than 0. If your application has a default drawing tool, ensure that its button on the toolbar is pressed when the application starts. To do so, set its GroupIndex property to a value other than zero and its Down property to true. Creating a group of speed buttons A series of speed buttons often represents a set of mutually exclusive choices. In that case, you need to associate the buttons into a group, so that\n\n\n\nclicking any button in the group causes the others in the group to pop up. To associate any number of speed buttons into a group, assign the same number to each speed button’s GroupIndex property. The easiest way to do this is to select all the buttons you want in the group, and, with the whole group selected, set GroupIndex to a unique value. Allowing toggle buttons Sometimes you want to be able to click a button in a group that’s already pressed and have it pop up, leaving no button in the group pressed. Such a button is called a toggle. Use AllowAllUp to create a grouped button that acts as a toggle: click it once, it’s down; click it again, it pops up. To make a grouped speed button a toggle, set its AllowAllUp property to true. Setting AllowAllUp to true for any speed button in a group automatically sets the same property value for all buttons in the group. This enables the group to act as a normal group, with only one button pressed at a time, but also allows every button\n\n\n\nto be up at the same time. Adding a toolbar using the toolbar component The toolbar component (TToolBar) offers button management and display features that panel components do not. To add a toolbar to a form using the toolbar component, 1 Add a toolbar component to the form (from the Win32 page of the Component palette). The toolbar automatically aligns to the top of the form 2 Add tool buttons or other controls to the bar. Developing the application user interface 4-31 D e s http://www.doksihu igning toolbars and cool bars Forrás: Tool buttons are designed to work on toolbar components. Like speed buttons, tool buttons can\n• Act like regular pushbuttons\n• Toggle on and off when clicked\n• Act like a set of radio buttons To implement tool buttons on a toolbar, do the following:\n• \n• \n• \n• \n• Add a tool button Assign images to tool buttons Set the tool buttons’ appearance Create a group of tool buttons Allow toggled tool buttons Adding a tool button To add a tool\n\n\n\nbutton to a toolbar, right-click on the toolbar and choose New Button. The toolbar “owns” the tool button, so moving or hiding the toolbar also moves or hides the button. In addition, all tool buttons on the toolbar automatically maintain the same height and width. You can drop other controls from the Component palette onto the toolbar, and they will automatically maintain a uniform height. Controls will also wrap around and start a new row when they do not fit horizontally on the toolbar. Assigning images to tool buttons Each tool button has an ImageIndex property that determines what image appears on it at runtime. If you supply the tool button only one image, the button manipulates that image to indicate whether the button is disabled. To assign images to tool buttons at design time, 1 Select the toolbar on which the buttons appear. 2 In the Object Inspector, assign a TImageList object to the toolbar’s Images property. An image list is a collection of same-sized icons or\n\n\n\nbitmaps. 3 Select a tool button. 4 In the Object Inspector, assign an integer to the tool button’s ImageIndex property that corresponds to the image in the image list that you want to assign to the button. You can also specify separate images to appear on the tool buttons when they are disabled and when they are under the mouse pointer. To do so, assign separate image lists to the toolbar’s DisabledImages and HotImages properties. 4-32 Developer’s Guide Designing toolbars and cool bars Setting tool button appearance and initial conditions Table 4.4 lists some actions you can set to change a tool button’s appearance: Table 4.4 Note Setting tool buttons’ appearance To make a tool button: Set the toolbar’s: Appear pressed GroupIndex property to a nonzero value and its Down property to true. Appear disabled Enabled property to false. Have a left margin Indent property to a value greater than 0. Appear to have “pop-up” borders, thus making the toolbar\n\n\n\nappear transparent Flat property to true. Using the Flat property of TToolBar requires version 4.70 or later of COMCTL32DLL To force a new row of controls after a specific tool button, Select the tool button that you want to appear last in the row and set its Wrap property to true. To turn off the auto-wrap feature of the toolbar, set the toolbar’s Wrapable property to false. Creating groups of tool buttons To create a group of tool buttons, select the buttons you want to associate and set their Style property to tbsCheck; then set their Grouped property to true. Selecting a grouped tool button causes other buttons in the group to pop up, which is helpful to represent a set of mutually exclusive choices. Any unbroken sequence of adjacent tool buttons with Style set to tbsCheck and Grouped set to true forms a single group. To break up a group of tool buttons, separate the buttons with any of the following:\n• A tool button whose Grouped property is false.\n• A tool button whose\n\n\n\nStyle property is not set to tbsCheck. To create spaces or dividers on the toolbar, add a tool button whose Style is tbsSeparator or tbsDivider.\n• Another control besides a tool button. Allowing toggled tool buttons Use AllowAllUp to create a grouped tool button that acts as a toggle: click it once, it is down; click it again, it pops up. To make a grouped tool button a toggle, set its AllowAllUp property to true. As with speed buttons, setting AllowAllUp to true for any tool button in a group automatically sets the same property value for all buttons in the group. Developing the application user interface 4-33 D e s http://www.doksihu igning toolbars and cool bars Forrás: Adding a cool bar component The cool bar componentalso called a rebardisplays windowed controls on independently movable, resizable bands. The user can position the bands by dragging the resizing grips on the left side of each band. To add a cool bar to a form, 1 Add a cool bar component to the form (from\n\n\n\nthe Win32 page of the Component palette). The cool bar automatically aligns to the top of the form 2 Add windowed controls from the Component palette to the bar. Only components that descend from TWinControl are windowed controls. You can add graphic controlssuch as labels or speed buttonsto the cool bar, but they will not appear on separate bands. Note The cool bar component requires version 4.70 or later of COMCTLDLL Setting the appearance of the cool bar The cool bar component offers several useful configuration options. Table 45 lists some actions you can set to change a tool button’s appearance: Table 4.5 Setting a cool button’s appearance To make the cool bar: Set the toolbar’s: Resize automatically to accommodate the bands it contains AutoSize property to true. Bands maintain a uniform height FixedSize property to true. Reorient to vertical rather than horizontal Vertical property to true. This changes the effect of the FixedSize property. Prevent the Text\n\n\n\nproperties of the bands from displaying at runtime ShowText property to false. Each band in a cool bar has its own Text property. Remove the border around the bar BandBorderStyle to bsNone. Keep users from changing the bands’ order at runtime. (The user can still move and resize the bands.) FixedOrder to true. Create a background image for the cool bar Bitmap property to TBitmap object. Choose a list of images to appear on the left of any band Images property to TImageList object. To assign images to individual bands, select the cool bar and double-click on the Bands property in the Object Inspector. Then select a band and assign a value to its ImageIndex property. Responding to clicks When the user clicks a control, such as a button on a toolbar, the application generates an OnClick event which you can respond to with an event handler. Since OnClick is the default event for buttons, you can generate a skeleton handler for the event by double-clicking the button at design\n\n\n\ntime. 4-34 Developer’s Guide Designing toolbars and cool bars Assigning a menu to a tool button If you are using a toolbar (TToolBar) with tool buttons (TToolButton), you can associate menu with a specific button: 1 Select the tool button. 2 In the Object Inspector, assign a pop-up menu (TPopupMenu) to the tool button’s DropDownMenu property. If the menu’s AutoPopup property is set to true, it will appear automatically when the button is pressed. Adding hidden toolbars Toolbars do not have to be visible all the time. In fact, it is often convenient to have a number of toolbars available, but show them only when the user wants to use them. Often you create a form that has several toolbars, but hide some or all of them. To create a hidden toolbar, 1 Add a toolbar, cool bar, or panel component to the form. 2 Set the component’s Visible property to false. Although the toolbar remains visible at design time so you can modify it, it remains hidden at runtime until the\n\n\n\napplication specifically makes it visible. Hiding and showing toolbars Often, you want an application to have multiple toolbars, but you do not want to clutter the form with them all at once. Or you may want to let users decide whether to display toolbars. As with all components, toolbars can be shown or hidden at runtime as needed. To hide or show a toolbar at runtime, set its Visible property to false or true, respectively. Usually you do this in response to particular user events or changes in the operating mode of the application. To do this, you typically have a close button on each toolbar. When the user clicks that button, the application hides the corresponding toolbar. You can also provide a means of toggling the toolbar. In the following example, a toolbar of pens is toggled from a button on the main toolbar. Since each click presses or releases the button, an OnClick event handler can show or hide the Pen toolbar depending on whether the button is up or down. void \n\n\n\nfastcall TForm1::PenButtonClick(TObject *Sender) { PenBar->Visible = PenButton->Down; } Developing the application user interface 4-35 U s i nhttp://www.doksihu g action lists Forrás: Using action lists Action lists let you centralize the response to user commands (actions) for objects such as menus and buttons that respond to those commands. This section is an overview of actions and action lists, describing how to use them and how they interact with their clients and targets. Action objects Actions are user commands that operate on target objects. They represent your application’s response to user input. Typically, an action corresponds to one or more elements of the user interface, such as menu commands or tool bar buttons. By centralizing actions using action objects, you can abstract the functions performed by your application from the user interface. This lets you share common code for performing actions (for example, when a tool bar button and menu item do the\n\n\n\nsame thing), as well as providing a single, centralized way to enable and disable actions depending on the state of your application. You create actions in the action list editor. These actions are later connected to client controls via their action links. Following are descriptions of each type of component in the action/action list mechanism:\n• An action list (TActionList) maintains a list of actions (TAction). Action lists provide the design-time user interface for working with actions.\n• An action (TAction) is the implementation of an action, such as copying highlighted text, on a target, such as an edit control. Typically the target is the control that has focus. A client control triggers its corresponding action in response to a user command (such as a mouse click). The StdActns unit contains classes derived from TAction that implement the basic Edit and Window menu commands (actions) found in most Windows applications.\n• A client of an action is typically a menu item or a\n\n\n\nbutton (TToolButton, TSpeedButton, TMenuItem, TButton, TCheckBox, TRadioButton, and so on). When the client receives a user command (such as a mouse click), it initiates its associated action. Typically a client’s Click event is associated with its action’s Execute event\n• An action link (TActionLink) maintains the connection between actions and clients. Action links determine which action, if any, is currently applicable for a given client.\n• An action target is usually a control, such as a rich edit, a memo, or a data control. The DBActns unit, for example, contains classes that implement actions specific to data set controls. Component writers can create their own actions specific to the needs of the controls they design and use, and then package those units to create more modular applications. Not all actions have a target For example, the standard help actions ignore the target and simply launch the help system. The following figure shows the relationship of these objects.\n\n\n\nIn this diagram, ActionList1 is the action list, Cut1 is the action it contains, SpeedButton1 is the client of Cut1, and Memo1 is the target. 4-36 Developer’s Guide Using action lists Figure 4.10 Action list mechanism Action Linked to Cut1 ActionList1 contains: Cut1 Unlike actions, action lists, action clients, and action targets, action links are not components. Client controls include an internal action link (available through the protected ActionLink property) that represents the connection you establish when you set the client’s Action property to an action. Because the action link is not a component that you can place on a form, it is indicated by a white rectangle in the diagram. The action link associates the SpeedButton1 client to the Cut1 action contained in ActionList1. The VCL includes TAction, TActionList, and TActionLink type classes for working with Action lists. By unit, these are\n• ActnList: TAction, TActionLink, TActionList, TContainedAction,\n\n\n\nTCustomAction, and TCustomActionList\n• Classes: TBasicAction and TBasicActionLink\n• Controls: TControlActionLink and TWinControlActionLink\n• ComCtrls: TToolButtonActionLink\n• Menus.: TMenuActionLink\n• StdCtrls: TButtonActionLink There are also two units, StdActns and DBActns, that contain auxiliary classes that implement specific, commonly used standard Windows and data set actions. These are described in “Pre-defined action classes” on page 4-41. Many of the VCL controls include properties (such as Action) and methods (such as ExecuteAction) that enable them to be used as action clients and targets. Using Actions You can add an action list to your forms or data modules from the standard page of the Component Palette. Double-click the action list to display the Action List editor, where you can add, delete, and rearrange actions. The properties of each action (other than the Name property) represent values that are applied to the properties of its client controls. In the\n\n\n\nObject Inspector, set the Developing the application user interface 4-37 U s i nhttp://www.doksihu g action lists Forrás: properties for each action. The Name property identifies the action, and the other properties and events (Caption, Checked, Enabled, HelpContext, Hint, ImageIndex, ShortCut, Visible, and Execute) correspond to the properties and events of its client controls. The client’s corresponding properties are typically, but not necessarily, the same name as the corresponding client property. For example, an action’s Checked property corresponds to a TToolButton’s Down property. Centralizing code All controls include a public property called Action, which allows them to act as the client of an action object. Controls that typically act as the client of an action, such as TToolButton, TSpeedButton, TMenuItem, and TButton, publish this property so that you can set up the client/action relationship at design time. When you set the Action property to one of the\n\n\n\nactions in an action list, the values of the corresponding properties in the action are copied to those of the control. All properties and events in common with the action object (except Name and Tag) are dynamically linked to the control. Thus, for example, instead of duplicating the code that disables buttons and menu items, you can centralize this code in an action object, and when the action is disabled, all corresponding buttons and menu items are disabled. Note If you are using a tool button or a menu item, you must manually set the Images property of the corresponding toolbar or menu component to the Images property of the action list. This is true even though the ImageIndex property is dynamically linked to the client. Linking properties When you set the client’s Action property, you establish the link between the client control and an action. This link is managed by the client’s action link, which associates specific properties of the control with the corresponding\n\n\n\nproperties of the action. When the action changes, the action link updates the client’s properties You can selectively override the link between a specific property on the client and the corresponding property of the associated action. When you change the client control’s property at design time, you effectively sever the link for that property only. The client property is changed, but the corresponding property on the action and any other clients associated with that action remains unaffected. Applications that use actions do not need to work with the action link explicitly. It automatically handles the dynamic link between the client’s properties and those of the action. Individual client control classes use different classes of action link, each of which represents a set of properties that can be linked to the action. Note You can determine what properties of a client control are linked to its action by checking the VCL reference for the action link class. Executing actions\n\n\n\nWhen a client component or control is clicked, the OnExecute event occurs for it’s associated action. For example, the following code illustrates the OnExecute event 4-38 Developer’s Guide Using action lists handler for an action that toggles the visibility of a toolbar when the action is executed: void fastcall TForm1::Action1Execute(TObject *Sender) { // Toggle Toolbar1’s visibility ToolBar1->Visible = !ToolBar1->Visible; } When the user clicks on the client control, the client generates an OnExecute event on the associated action. If you assign an event handler to the action, the response to the user click is straightforward. Unless you are sharing the event handler with other actions or writing custom, reusable actions, this is all you need to do: Add an action to the action list, set its properties, write an OnExecute event handler, and link it to all relevant components by setting their Action property. If you want to write a single event handler that\n\n\n\nincludes the response for multiple actions, however, you can write an event handler that responds at the action list or even the application level. There is a dispatching sequence C++Builder follows when trying to find a way to respond to the user action. Consider, for example, the components illustrated in Figure 4.11 The Speedbutton1 client is linked to the Cut1 action. (Speedbutton1’s Action property is Cut1) Figure 411 illustrates the dispatching sequence that is followed when the user clicks Speedbutton1 with the mouse. Figure 4.11 Execution cycle for an action ActionList1.ExecuteAction SpeedButton1 Cut1.Execute Cut1 ActionList1 E XECUT TIONE CM AC ActionList1.OnExecute Application Cut1.OnExecute Application.OnActionExecute LEGEND Application Events Calls Objects Returns Application.ExecuteAction Clicking on Speedbutton1 initiates the following execution cycle: 1 Because Speedbutton1’s Action property is set to Cut1, Cut1 receives an OnExecute event. If Cut1 has\n\n\n\nan OnExecute event handler, processing stops there If Cut1 has no OnExecute event handler, processing continues: Developing the application user interface 4-39 U s i nhttp://www.doksihu g action lists Forrás: 2 Because Cut1 does not have an OnExecute event handler, it defers to its action list (ActionList1) for processing the event. ActionList1 receives an OnExecute event (The action list’s OnExecute event occurs when any of its contained actions do not handle an event in their OnExecute event handler.) The action list’s event handler has a parameter Handled, that returns false by default. If the handler is assigned and handles the event, it returns true, and the processing sequence ends here. For example: void fastcall TForm1::ActionList1ExecuteAction(TBasicAction *Action, bool &Handled) { // Prevent execution of actions contained by ActionList1 Handled = true; } If execution is not handled, at this point, in the action list event handler, then processing continues: 3\n\n\n\nThe global Application object receives an OnActionExecute event. (This event occurs when any action list in the application fails to handle an event.) Like the action list’s OnExecute event handler, the OnActionExecute handler has a parameter Handled that returns false by default. If the handler is assigned and handles the event, it returns true, and the processing sequence ends here. For example: void fastcall TForm1::ApplicationExecuteAction(TBasicAction *Action, bool &Handled) { // Prevent execution of all actions in Application Handled = true; } 4 This ends the sequence by which you can respond to action’s using event handlers. However, pre-defined action classes, such as Cut1, do not stop here You can use built-in actions or create your own action classes that know how to operate on specific target classes (such as edit controls). When no event handler is found at any level, the application next tries to find a target on which to execute the action. When the application\n\n\n\nlocates a target that the action knows how to address, it invokes the action. See “How actions find their targets” on page 4-43 for details on how the application locates a target that can respond to a pre-defined action class. Updating actions When the application is idle, the OnUpdate event occurs for every action that is linked to a control or menu item that is showing. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on. For example, the following code illustrates the OnUpdate event handler for an action that is “checked” when the toolbar is visible: void fastcall TForm1::Action1Update(TObject *Sender) { // Indicate whether ToolBar1 is currently visible ((TAction *)Sender)->Checked = ToolBar1->Visible; } See also the RichEdit demo. 4-40 Developer’s Guide Using action lists The dispatching cycle for updating actions follows the same sequence as the execution cycle in\n\n\n\n“Executing actions” on page 4-38. Warning Do not add time-intensive code to the OnUpdate event handler. This executes whenever the application is idle. If the event handler takes too much time, it will adversely affect performance of the entire application. Pre-defined action classes The Action List editor lets you use pre-defined action classes that automatically perform certain common actions. In addition, component writers can use the classes in the StdActns and DBActns units as examples for deriving their own action classes to implement behaviors specific to certain controls or components. The base classes for these specialized actions (TEditAction, TWindowAction) generally override HandlesTarget, UpdateTarget, and other methods to limit the target for the action to a specific class of objects. The descendant classes typically override ExecuteTarget to perform a specialized task. Standard edit actions The standard edit actions are designed to be used with an edit control\n\n\n\ntarget. TEditAction is the base class for descendants that each override the ExecuteTarget method to implement copy, cut, and paste tasks by using the Windows Clipboard.\n• TEditAction ensures that the target control is a TCustomEdit class (or descendant).\n• TEditCopy copies highlighted text to the Clipboard.\n• TEditCut cuts highlighted text from the target to the Clipboard.\n• TEditPaste pastes text from the Clipboard to the target and ensures that the Clipboard is enabled for the text format.\n• TEditDelete deletes the highlighted text.\n• TEditSelectAll selects all the text in the target edit control.\n• TEditUndo undoes the last edit made to the target edit control. Standard Window actions The standard Window actions are designed to be used with forms as targets in an MDI application. TWindowAction is the base class for descendants that each override the ExecuteTarget method to implement arranging, cascading, closing, tiling, and minimizing MDI child forms. •\n\n\n\nTWindowAction ensures that the target control is a TForm class and checks whether the form has MDI child forms.\n• TWindowArrange arranges the icons of minimized MDI child forms.\n• TWindowCascade cascades the MDI child forms.\n• TWindowClose closes the active MDI child form. Developing the application user interface 4-41 U s i nhttp://www.doksihu g action lists Forrás:\n• TWindowMinimizeAll minimizes all of the MDI child forms.\n• TWindowTileHorizontal arranges MDI child forms so that they are all the same size, tiled horizontally.\n• TWindowTileVertical arranges MDI child forms so that they are all the same size, tiled vertically. Standard Help actions The standard Help actions are designed to be used with any target. THelpAction is the base class for descendants that each override the ExecuteTarget method to pass the command on to WinHelp.\n• THelpAction ensures that the global Application variable is available, so that commands can be handled using its HelpCommand\n\n\n\nmethod.\n• THelpContents brings up the Help Topics dialog on the tab (Contents, Index or Find) that was last used.\n• THelpTopicSearch brings up the Help Topics dialog on the Index tab.\n• THelpOnHelp brings up the Microsoft help file on how to use Help. Note that this file is an HTML help file on recent versions of Windows, and does not describe the WinHelp system. DataSet actions The standard dataset actions are designed to be used with a dataset component target. TDataSetAction is the base class for descendants that each override the ExecuteTarget and UpdateTarget methods to implement navigation and editing of the target. The TDataSetAction introduces a DataSource property which ensures actions are performed on that dataset. If DataSource is NULL, the currently focused data-aware control is used. For details, refer to Figure 412, “Action targets,” on page 4-43\n• TDataSetAction ensures that the target is a TDataSource class and has an associated data set.\n• TDataSetCancel\n\n\n\ncancels the edits to the current record, restores the record display to its condition prior to editing, and turns off Insert and Edit states if they are active.\n• TDataSetDelete deletes the current record and makes the next record the current record.\n• TDataSetEdit puts the dataset into Edit state so that the current record can be modified.\n• TDataSetFirst sets the current record to the first record in the dataset.\n• TDataSetInsert inserts a new record before the current record, and sets the dataset into Insert and Edit states.\n• TDataSetLast sets the current record to the last record in the dataset.\n• TDataSetNext sets the current record to the next record. 4-42 Developer’s Guide Using action lists\n• TDataSetPost writes changes in the current record to the dataset.\n• TDataSetPrior sets the current record to the previous record.\n• TDataSetRefresh refreshes the buffered data in the associated dataset. Writing action components You can always use actions that\n\n\n\nyou create for a specific application by setting its properties in the object inspector. For such actions to do anything, you must write an event handler to respond at some point in the dispatching sequence described in “Executing actions” on page 4-38. When you use the pre-defined actions that ship with C++Builder, you do not need to write any event handlers, because the target components know how to respond to the action. It is also possible to create your own pre-defined action classes. When you write your own action classes, you can build in the ability to execute on certain target classes of object. Then, you can use your custom actions in the same way you use pre-defined action classes. That is, when the action can recognize and apply itself to a target class, you can simply assign the action to a client control, and it acts on the target with no need to write an event handler. How actions find their targets “Executing actions” on page 4-38 describes the execution cycle\n\n\n\nthat occurs when a user invokes an action. If there is no event handler assigned to respond to the action, either at the action, action list, or application level, then the application tries to identify a target object to which the action can apply itself. Figure 412 illustrates the process by which the application searches for a target object. The pre-defined action classes described previously as well as any action class that you create, follow this path of execution: Figure 4.12 Action targets CM AC TIO Form1.CM ACTIONEXECUTE NE XEC UTE Application Form1 Memo1 yes LEGEND Memo1.ExecuteAction(Cut1) Cut1.HandlesTarget(Memo1) Cut1 Events Calls Objects Returns Cut1.ExecuteTarget(Memo1): Developing the application user interface 4-43 U s i nhttp://www.doksihu g action lists Forrás: 1 The application receives a CM ACTIONEXECUTE message, which indicates that an action was not handled by any event handler. The application dispatches it to the Screen’s ActiveForm. If\n\n\n\nthere is no active form, the application sends the message to it’s MainForm. 2 Form1 (in this example, the active form) first looks for the active control (Memo1) as a potential target. The active control (Memo1) calls the action’s HandlesTarget method, to determine whether it is an appropriate target for the action. If Memo1 is not an appropriate target, HandlesTarget returns false and the active control informs the application that it is not a valid target. 3 In this case, Memo1 is an appropriate target for Cut1, so HandlesTarget returns true. Memo1 then calls Cut1::ExecuteTarget passing itself as a parameter. 4 Since Cut1 is an instance of a TEditCut action, the action calls Memo1’s CutToClipboard method: void fastcall TEditCut::ExecuteTarget(TObject *Target) { ((TCustomEdit *)Target)->CutToClipboard(); } If the active control were not an appropriate target, processing would continue as follows:\n• Form1 checks whether it is an appropriate target itself. If Form1 is an\n\n\n\nappropriate target (for example, a form can be a target for the TWindowCascade action) then it calls Cut1’s ExecuteTarget method, passing itself as a parameter.\n• If Form1 is not an appropriate target, the application iterates through every visible control on Form1 until a target is found. Note If the action involved is a descendant of TCustomAction, then it is automatically disabled for you when it can’t be handled and its DisableIfNoHandler property is true. Registering actions When you write your own actions, you can register and unregister them with the IDE by using the global routines in the ActnList unit: extern PACKAGE void fastcall RegisterActions(const AnsiString CategoryName, TMetaClass* const * AClasses, const int AClasses Size, TMetaClass Resource); extern PACKAGE void fastcall UnRegisterActions(TMetaClass* const AClasses, const int AClasses Size); When you call RegisterActions, the actions you register appear in the Action List editor for use by your\n\n\n\napplications. You can supply a category name to organize your actions, as well as a Resource parameter that lets you supply default property values. 4-44 Developer’s Guide Using action lists For example, the following code registers actions with the IDE in the MyAction unit: namespace MyAction { void fastcall PACKAGE Register() { // code goes here to register any components and editors TMetaClass classes[2] = { classid(TMyAction1), classid(TMyAction2)}; RegisterActions(\"MySpecialActions\", classes, 1, NULL); } } When you call UnRegisterActions, the actions no longer appear in the Action List editor. Writing action list editors You can write your own component editor for action lists. If you do, assign your own procedures to the four global procedure variables in the ActnList unit: extern PACKAGE Classes::TBasicAction* fastcall (CreateActionProc)(Classes::TComponent AOwner, TMetaClass* ActionClass); extern PACKAGE void fastcall\n\n\n\n(*EnumRegisteredActionsProc)(TEnumActionProc Proc, void Info); extern PACKAGE void fastcall (*RegisterActionsProc)(const AnsiString CategoryName, TMetaClass* const AClasses, const int AClasses Size, TMetaClass Resource); extern PACKAGE void fastcall (*UnRegisterActionsProc)(TMetaClass const AClasses, const int AClasses Size); You only need to reassign these if you want to manage the registration, unregistration, creation, and enumeration procedures of actions differently from the default behavior. If you do, write your own handlers and assign them to these variables within the initialization section of your design-time unit. Developing the application user interface 4-45 4-46 Developer’s Guide Chapter 5 Working with controls Chapter5 Controls are visual components that the user can interact with at runtime. This chapter describes a variety of features common to many controls. Implementing drag-and-drop in controls Drag-and-drop is often a convenient way for\n\n\n\nusers to manipulate objects. You can let users drag an entire control, or let them drag items from one controlsuch as a list box or tree viewinto another.\n• \n• \n• \n• \n• \n• Starting a drag operation Accepting dragged items Dropping items Ending a drag operation Customizing drag and drop with a drag object Changing the drag mouse pointer Starting a drag operation Every control has a property called DragMode that determines how drag operations are initiated. If DragMode is dmAutomatic, dragging begins automatically when the user presses a mouse button with the cursor on the control. Because dmAutomatic can interfere with normal mouse activity, you may want to set DragMode to dmManual (the default) and start the dragging by handling mouse-down events. To start dragging a control manually, call the control’s BeginDrag method. BeginDrag takes a Boolean parameter called Immediate. If you pass true, dragging begins immediately. If you pass false, dragging does not begin until the\n\n\n\nuser moves the mouse a short distance. Calling BeginDrag(false) allows the control to accept mouse clicks without beginning a drag operation. Working with controls 5-1 I m p lhttp://www.doksihu ementing drag-and-drop in controls Forrás: You can place other conditions on whether to begin dragging, such as checking which mouse button the user pressed, by testing the parameters of the mouse-down event before calling BeginDrag. The following code, for example, handles a mousedown event in a file list box by initiating a drag operation only if the left mouse button was pressed. void fastcall TFMForm::FileListBox1MouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { if (Button == mbLeft)// drag only if left button pressed { TFileListBox *pLB = (TFileListBox )Sender; // cast to TFileListBox if (pLB->ItemAtPos(Point(X,Y), true) >= 0) // is there an item here? pLB->BeginDrag(false); // if so, drag it } } Accepting dragged items When the user drags\n\n\n\nsomething over a control, that control receives an OnDragOver event, at which time it must indicate whether it can accept the item if the user drops it there. The drag cursor changes to indicate whether the control can accept the dragged item. To accept items dragged over a control, attach an event handler to the control’s OnDragOver event. The drag-over event has a parameter called Accept that the event handler can set to true if it will accept the item. If Accept is true, the application sends a drag-drop event to the control. The drag-over event has other parameters, including the source of the dragging and the current location of the mouse cursor, that the event handler can use to determine whether to accept the drop. In the following example, a directory tree view accepts dragged items only if they come from a file list box. void fastcall TForm1::TreeView1DragOver(TObject *Sender, TObject Source, int X, int Y, TDragState State, bool &Accept) { if (Source->InheritsFrom( \n\n\n\nclassid(TFileListBox))) Accept = true; } Dropping items If a control indicates that it can accept a dragged item, it needs to handle the item should it be dropped. To handle dropped items, attach an event handler to the OnDragDrop event of the control accepting the drop. Like the drag-over event, the drag-drop event indicates the source of the dragged item and the coordinates of the mouse cursor over the accepting control. The latter parameter allows you to monitor the path an item takes while being dragged; you might, for example, want to use this information to change the color of components as they are passed over. 5-2 Developer’s Guide Implementing drag-and-drop in controls In the following example, a directory tree view, accepting items dragged from a file list box, responds by moving files to the directory on which they are dropped. void fastcall TForm1::TreeView1DragDrop(TObject *Sender, TObject Source, int X, int Y){ if (Source->InheritsFrom( \n\n\n\nclassid(TFileListBox))) { TTreeNode *pNode = TreeView1->GetNodeAt(X,Y); // pNode is drop target AnsiString NewFile = pNode->Text + AnsiString(\"/\") + ExtractFileName(FileList->FileName); // build file name for drop target MoveFileEx(FileList->FileName.c str(), NewFilec str(), MOVEFILE REPLACE EXISTING | MOVEFILE COPY ALLOWED); // move the file } } Ending a drag operation A drag operation ends when the item is either successfully dropped or released over a control that cannot accept it. At this point an end-drag event is sent to the control from which the item was dragged. To enable a control to respond when items have been dragged from it, attach an event handler to the control’s OnEndDrag event. The most important parameter in an OnEndDrag event is called Target, which indicates which control, if any, accepts the drop. If Target is null, it means no control accepts the dragged item. The OnEndDrag event also includes the coordinates on the receiving control. In\n\n\n\nthis example, a file list box handles an end-drag event by refreshing its file list. void fastcall TFMForm::FileList1EndDrag(TObject *Sender, TObject Target, if (Target) FileList1->Update(); }; int X, int Y) Customizing drag and drop with a drag object You can use a TDragObject descendant to customize an object’s drag-and-drop behavior. The standard drag-over and drag-drop events indicate the source of the dragged item and the coordinates of the mouse cursor over the accepting control. To get additional state information, derive a custom drag object from TDragObject and override its virtual methods. Create the custom drag object in the OnStartDrag event Normally, the source parameter of the drag-over and drag-drop events is the control that starts the drag operation. If different kinds of control can start an operation involving the same kind of data, the source needs to support each kind of control. When you use a descendant of TDragObject, however, the source is the drag\n\n\n\nobject itself; if each control creates the same kind of drag object in its OnStartDrag event, the target needs to handle only one kind of object. The drag-over and drag-drop events can tell if the source is a drag object, as opposed to the control, by calling the IsDragObject function. Working with controls 5-3 I m p lhttp://www.doksihu ementing drag-and-dock in controls Forrás: Drag objects let you drag items between a form implemented in the application’s main EXE file and a form implemented in a DLL, or between forms that are implemented in different DLLs. Changing the drag mouse pointer You can customize the appearance of the mouse pointer during drag operations by setting the source component’s DragCursor property. Implementing drag-and-dock in controls Descendants of TWinControl can act as docking sites and descendants of TControl can act as child windows that are docked into docking sites. For example, to provide a docking site at the left edge of a form window,\n\n\n\nalign a panel to the left edge of the form and make the panel a docking site. When dockable controls are dragged to the panel and released, they become child controls of the panel.\n• \n• \n• \n• \n• Making a windowed control a docking site Making a control a dockable child Controlling how child controls are docked Controlling how child controls are undocked Controlling how child controls respond to drag-and-dock operations Making a windowed control a docking site To make a windowed control a docking site, 1 Set the DockSite property to true. 2 If the dock site object should not appear except when it contains a docked client, set its AutoSize property to true. When AutoSize is true, the dock site is sized to 0 until it accepts a child control for docking. Then it resizes to fit around the child control. Making a control a dockable child To make a control a dockable child, 1 Set its DragKind property to dkDock. When DragKind is dkDock, dragging the control moves the control to a\n\n\n\nnew docking site or undocks the control so that it becomes a floating window. When DragKind is dkDrag (the default), dragging the control starts a drag-and-drop operation which must be implemented using the OnDragOver, OnEndDrag, and OnDragDrop events. 2 Set its DragMode to dmAutomatic. When DragMode is dmAutomatic, dragging (for drag-and-drop or docking, depending on DragKind) is initiated automatically when the user starts dragging the control with the mouse. When DragMode is 5-4 Developer’s Guide Implementing drag-and-dock in controls dmManual, you can still begin a drag-and-dock (or drag-and-drop) operation by calling the BeginDrag method. 3 Set its FloatingDockSiteClass property to indicate the TWinControl descendant that should host the control when it is undocked and left as a floating window. When the control is released and not over a docking site, a windowed control of this class is created dynamically, and becomes the parent of the dockable child. If the dockable\n\n\n\nchild control is a descendant of TWinControl, it is not necessary to create a separate floating dock site to host the control, although you may want to specify a form in order to get a border and title bar. To omit a dynamic container window, set FloatingDockSiteClass to the same class as the control, and it will become a floating window with no parent. Controlling how child controls are docked A docking site automatically accepts child controls when they are released over the docking site. For most controls, the first child is docked to fill the client area, the second splits that into separate regions, and so on. Page controls dock children into new tab sheets (or merge in the tab sheets if the child is another page control). Three events allow docking sites to further constrain how child controls are docked: property TGetSiteInfoEvent OnGetSiteInfo = {read=FOnGetSiteInfo, write=FOnGetSiteInfo}; typedef void fastcall ( closure *TGetSiteInfoEvent)(System::TObject Sender,\n\n\n\nTControl DockClient, Windows::TRect &InfluenceRect, const Windows::TPoint &MousePos, bool &CanDock); OnGetSiteInfo occurs on the docking site when the user drags a dockable child over the control. It allows the site to indicate whether it will accept the control specified by the DockClient parameter as a child, and if so, where the child must be to be considered for docking. When OnGetSiteInfo occurs, InfluenceRect is initialized to the screen coordinates of the docking site, and CanDock is initialized to true. A more limited docking region can be created by changing InfluenceRect and the child can be rejected by setting CanDock to false. property TDockOverEvent OnDockOver = {read=FOnDockOver, write=FOnDockOver}; typedef void fastcall ( closure *TDockOverEvent)(System::TObject Sender, TDragDockObject* Source, int X, int Y, TDragState State, bool &Accept); OnDockOver occurs on the docking site when the user drags a dockable child over the control. It is analogous\n\n\n\nto the OnDragOver event in a drag-and-drop operation Use it to signal that the child can be released for docking, by setting the Accept parameter. If the dockable control is rejected by the OnGetSiteInfo event handler (perhaps because it is the wrong type of control), OnDockOver does not occur. property TDockDropEvent OnDockDrop = {read=FOnDockDrop, write=FOnDockDrop}; typedef void fastcall ( closure *TDockDropEvent)(System::TObject Sender, TDragDockObject* Source, int X, int Y); OnDockDrop occurs on the docking site when the user releases the dockable child over the control. It is analogous to the OnDragDrop event in a normal drag-and-drop operation. Use this event to perform any necessary accommodations to accepting the control as a child control. Access to the child control can be obtained using the Control property of the TDockObject specified by the Source parameter. Working with controls 5-5 W o r http://www.doksihu king with text in controls Forrás: Controlling how\n\n\n\nchild controls are undocked A docking site automatically allows child controls to be undocked when they are dragged and have a DragMode property of dmAutomatic. Docking sites can respond when child controls are dragged off, and even prevent the undocking, in an OnUnDock event handler: property TUnDockEvent OnUnDock = {read=FOnUnDock, write=FOnUnDock}; typedef void fastcall ( closure *TUnDockEvent)(System::TObject Sender, TControl Client, TWinControl* NewTarget, bool &Allow); The Client parameter indicates the child control that is trying to undock, and the Allow parameter lets the docking site (Sender) reject the undocking. When implementing an OnUnDock event handler, it can be useful to know what other children (if any) are currently docked. This information is available in the read-only DockClients property, which is an indexed array of TControl. The number of dock clients is given by the read-only DockClientCount property. Controlling how child controls respond to\n\n\n\ndrag-and-dock operations Dockable child controls have two events that occur during drag-and-dock operations: OnStartDock, analogous to the OnStartDrag event of a drag-and-drop operation, allows the dockable child control to create a custom drag object. OnEndDock, like OnEndDrag, occurs when the dragging terminates. Working with text in controls The following sections explain how to use various features of rich edit and memo controls. Some of these features work with edit controls as well\n• \n• \n• \n• \n• \n• \n• \n• \n• \n• Setting text alignment Adding scrollbars at runtime Adding the Clipboard object Selecting text Selecting all text Cutting, copying, and pasting text Deleting selected text Disabling menu items Providing a pop-up menu Handling the OnPopup event Setting text alignment In a rich edit or memo component, text can be left- or right-aligned or centered. To change text alignment, set the edit component’s Alignment property. Alignment takes effect only if the\n\n\n\nWordWrap property is true; if word wrapping is turned off, there is no margin to align to. 5-6 Developer’s Guide Working with text in controls For example, the following code from the RichEdit example sets the alignment depending on which button was chosen: switch((int)RichEdit1->Paragraph->Alignment) { case 0: LeftAlign->Down = true; break; case 1: RightAlign->Down = true; break; case 2: CenterAlign->Down = true; break; Adding scroll bars at runtime Rich edit and memo components can contain horizontal or vertical scroll bars, or both, as needed. When word-wrapping is enabled, the component needs only a vertical scroll bar. If the user turns off word-wrapping, the component might also need a horizontal scroll bar, since text is not limited by the right side of the editor. To add scroll bars at runtime, 1 Determine whether the text might exceed the right margin. In most cases, this means checking whether word wrapping is enabled. You might also check whether\n\n\n\nany text lines actually exceed the width of the control. 2 Set the rich edit or memo component’s ScrollBars property to include or exclude scroll bars. The following example attaches an OnClick event handler to a Character|WordWrap menu item. void fastcall TEditForm::WordWrap1Click(TObject *Sender) { Editor->WordWrap = !(Editor->WordWrap); // toggle wordwrapping if (Editor->WordWrap) Editor->ScrollBars = ssVertical; // wrapped requires only vertical else Editor->ScrollBars = ssBoth; // unwrapped can need both WordWrap1->Checked = Editor->WordWrap; // check menu item to match property } The rich edit and memo components handle their scroll bars in a slightly different way. The rich edit component can hide its scroll bars if the text fits inside the bounds of the component. The memo always shows scroll bars if they are enabled Adding the Clipboard object Most text-handling applications provide users with a way to move selected text between documents, including\n\n\n\ndocuments in different applications. The Clipboard object in C++Builder encapsulates the Windows Clipboard and includes methods for cutting, copying, and pasting text (and other formats, including graphics). The Clipboard object is declared in the Clipbrd unit. To add the Clipboard object to an application, 1 Select the unit that will use the Clipboard. 2 In the form’s .H file, add #include <vclClipbrd.hpp> Working with controls 5-7 W o r http://www.doksihu king with text in controls Forrás: Selecting text Before you can send any text to the Clipboard, that text must be selected. Highlighting of selected text is built into the edit components. When the user selects text, it appears highlighted. Table 5.1 lists properties commonly used to handle selected text Table 5.1 Properties of selected text Property Description SelText Contains a string representing the selected text in the component. SelLength Contains the length of a selected string. SelStart Contains the\n\n\n\nstarting position of a string. Selecting all text The SelectAll method selects the entire contents of the rich edit or memo component. This is especially useful when the component’s contents exceed the visible area of the component. In most other cases, users select text with either keystrokes or mouse dragging. To select the entire contents of a rich edit or memo control, call the RichEdit1 control’s SelectAll method. For example, void fastcall TMainForm::SelectAll(TObject *Sender) { RichEdit1->SelectAll(); // select all text in RichEdit } Cutting, copying, and pasting text Applications that use the Clipbrd unit can cut, copy, and paste text, graphics, and objects through the Windows Clipboard. The edit components that encapsulate the standard Windows text-handling controls all have methods built into them for interacting with the Clipboard. (See “Using the Clipboard with graphics” on page 6-20 for information on using the Clipboard with graphics.) To cut, copy, or\n\n\n\npaste text with the Clipboard, call the edit component’s CutToClipboard, CopyToClipboard, and PasteFromClipboard methods, respectively. 5-8 Developer’s Guide Working with text in controls For example, the following code attaches event handlers to the OnClick events of the Edit|Cut, Edit|Copy, and Edit|Paste commands, respectively: void { } void { } void { } fastcall TMainForm::EditCutClick(TObject* /Sender/) RichEdit1->CutToClipboard(); fastcall TMainForm::EditCopyClick(TObject* /Sender/) RichEdit1->CopyToClipboard(); fastcall TMainForm::EditPasteClick(TObject* /Sender/) RichEdit1->PasteFromClipboard(); Deleting selected text You can delete the selected text in an edit component without cutting it to the Clipboard. To do so, call the ClearSelection method For example, if you have a Delete item on the Edit menu, your code could look like this: void fastcall TMainForm::EditDeleteClick(TObject *Sender) { RichEdit1->ClearSelection(); } Disabling menu items\n\n\n\nIt is often useful to disable menu commands without removing them from the menu. For example, in a text editor, if there is no text currently selected, the Cut, Copy, and Delete commands are inapplicable. An appropriate time to enable or disable menu items is when the user selects the menu. To disable a menu item, set its Enabled property to false. In the following example, an event handler is attached to the OnClick event for the Edit item on a child form’s menu bar. It sets Enabled for the Cut, Copy, and Delete menu items on the Edit menu based on whether RichEdit1 has selected text. The Paste command is enabled or disabled based on whether any text exists on the Clipboard. void fastcall TMainForm::EditEditClick(TObject *Sender) { // enable or disable the Paste menu item Paste1->Enabled = Clipboard()->HasFormat(CF TEXT); bool HasSelection = (RichEdit1->SelLength > 0); // true if text is selected Cut1->Enabled = HasSelection; // enable menu items if HasSelection is\n\n\n\ntrue Copy1->Enabled = HasSelection; Delete1->Enabled = HasSelection; } The HasFormat method of the Clipboard returns a Boolean value based on whether the Clipboard contains objects, text, or images of a particular format. By calling HasFormat with the parameter CF TEXT, you can determine whether the Clipboard contains any text, and enable or disable the Paste item as appropriate. Chapter 6, “Working with graphics and multimedia” provides more information about using the Clipboard with graphics. Working with controls 5-9 W o r http://www.doksihu king with text in controls Forrás: Providing a pop-up menu Pop-up, or local, menus are a common ease-of-use feature for any application. They enable users to minimize mouse movement by clicking the right mouse button in the application workspace to access a list of frequently used commands. In a text editor application, for example, you can add a pop-up menu that repeats the Cut, Copy, and Paste editing commands. These pop-up\n\n\n\nmenu items can use the same event handlers as the corresponding items on the Edit menu. You don’t need to create accelerator or shortcut keys for pop-up menus because the corresponding regular menu items generally already have shortcuts. A form’s PopupMenu property specifies what pop-up menu to display when a user right-clicks any item on the form. Individual controls also have PopupMenu properties that can override the form’s property, allowing customized menus for particular controls. To add a pop-up menu to a form, 1 Place a pop-up menu component on the form. 2 Use the Menu Designer to define the items for the pop-up menu. 3 Set the PopupMenu property of the form or control that displays the menu to the name of the pop-up menu component. 4 Attach handlers to the OnClick events of the pop-up menu items. Handling the OnPopup event You may want to adjust pop-up menu items before displaying the menu, just as you may want to enable or disable items on a regular menu. With a\n\n\n\nregular menu, you can handle the OnClick event for the item at the top of the menu, as described in “Disabling menu items” on page 5-9. With a pop-up menu, however, there is no top-level menu bar, so to prepare the popup menu commands, you handle the event in the menu component itself. The pop-up menu component provides an event just for this purpose, called OnPopup. To adjust menu items on a pop-up menu before displaying them, 1 Select the pop-up menu component. 2 Attach an event handler to its OnPopup event. 3 Write code in the event handler to enable, disable, hide, or show menu items. In the following code, the EditEditClick event handler described previously in “Disabling menu items” on page 5-9 is attached to the pop-up menu component’s OnPopup event. A line of code is added to EditEditClick for each item in the pop-up menu. 5-10 Developer’s Guide Adding graphics to controls void fastcall TMainForm::EditEditClick(TObject *Sender) { // enable or disable the\n\n\n\nPaste menu item Paste1->Enabled = Clipboard()->HasFormat(CF TEXT); Paste2->Enabled = Paste1->Enabled; // add this line bool HasSelection = (RichEdit1->SelLength > 0); // true if text is selected Cut1->Enabled = HasSelection; // enable menu items if HasSelection is true Cut2->Enabled = HasSelection; // add this line Copy1->Enabled = HasSelection; Copy2->Enabled = HasSelection; // add this line Delete1->Enabled = HasSelection; } Adding graphics to controls Several Windows controls let you customize the way the control is rendered. These include list boxes, combo boxes, menus, headers, tab controls, list views, status bars, tree views, and tool bars. Instead of using Windows’ standard method of drawing the control or its items, the control’s owner (generally, the form) draws them at runtime. The most common use for owner-draw controls is to provide graphics instead of, or in addition to, text for items. For information on using owner-draw to add\n\n\n\nimages to menus, see “Adding images to menu items” on page 4-22. All owner-draw controls contain lists of items. Usually, those lists are lists of strings that Windows displays as text, or lists of objects that contain strings that Windows displays as text. You can associate an object with each item in a list to make it easy to use that object when drawing items. In general, creating an owner-draw control in C++Builder involves these steps: 1 Indicating that a control is owner-drawn 2 Adding graphical objects to a string list 3 Drawing owner-drawn items Indicating that a control is owner-drawn To customize the drawing of a control, you must supply event handlers that render the control’s image when it needs to be painted. Some controls receive these events automatically. For example, list views, tree views, and tool bars all receive events at various stages in the drawing process without your having to set any properties. These events have names such as “OnCustomDraw” or\n\n\n\n“OnAdvancedCustomDraw”. Other controls, however, require you to set a property before they receive ownerdraw events. List boxes, combo boxes, header controls, and status bars have a property called Style. Style determines whether the control uses the default drawing (called the “standard” style) or owner drawing. Grids use a property called DefaultDrawing to enable or disable the default drawing. List views and tab controls have a property called OwnerDraw that enables or disabled the default drawing. Working with controls 5-11 A d d http://www.doksihu ing graphics to controls Forrás: List boxes and combo boxes have additional owner-draw styles, called fixed and variable, as Table 5.2 describes Other controls are always fixed, although the size of the item that contains the text may vary, the size of each item is determined before drawing the control. Table 5.2 Fixed vs. variable owner-draw styles Owner-draw style Meaning Examples Fixed Each item is the same height,\n\n\n\nwith that height determined by the ItemHeight property. lbOwnerDrawFixed, csOwnerDrawFixed Variable Each item might have a different height, determined by the data at runtime. lbOwnerDrawVariable, csOwnerDrawVariable Adding graphical objects to a string list Every string list has the ability to hold a list of objects in addition to its list of strings. For example, in a file manager application, you may want to add bitmaps indicating the type of drive along with the letter of the drive. To do that, you need to add the bitmap images to the application, then copy those images into the proper places in the string list as described in the following sections. Adding images to an application An image control is a nonvisual control that contains a graphical image, such as a bitmap. You use image controls to display graphical images on a form You can also use them to hold hidden images that you’ll use in your application. For example, you can store bitmaps for owner-draw controls in\n\n\n\nhidden image controls, like this: 1 Add image controls to the main form. 2 Set their Name properties. 3 Set the Visible property for each image control to false. 4 Set the Picture property of each image to the desired bitmap using the Picture editor from the Object Inspector. The image controls are invisible when you run the application. Adding images to a string list Once you have graphical images in an application, you can associate them with the strings in a string list. You can either add the objects at the same time as the strings, or associate objects with existing strings. The preferred method is to add objects and strings at the same time, if all the needed data is available. The following example shows how you might want to add images to a string list. This is part of a file manager application where, along with a letter for each valid 5-12 Developer’s Guide Adding graphics to controls drive, it adds a bitmap indicating each drive’s type. The OnCreate event\n\n\n\nhandler looks like this: void fastcall TFMForm::FormCreate(TObject *Sender) { int AddedIndex; char DriveName[4] = \"A:\"; for (char Drive = A; Drive <= Z; Drive++) // try all possible drives { DriveName[0] = Drive; switch (GetDriveType(DriveName)) { case DRIVE REMOVABLE:// add a list item DriveName[1] = ; // temporarily make drive letter into string AddedIndex = DriveList->Items->AddObject(DriveName, Floppy->Picture->Graphic); DriveName[1] = : // replace the colon break; case DRIVE FIXED:// add a list item DriveName[1] = ; // temporarily make drive letter into string AddedIndex = DriveList->Items->AddObject(DriveName, Fixed->Picture->Graphic); DriveName[1] = : // replace the colon break; case DRIVE REMOTE:// add a list item DriveName[1] = ; // temporarily make drive letter into string AddedIndex = DriveList->Items->AddObject(DriveName, Network->Picture->Graphic); DriveName[1] = : // replace the colon break; } if ((int)(Drive - A) ==\n\n\n\ngetdisk()) // current drive? DriveList->ItemIndex = AddedIndex; // then make that the current list item } } Drawing owner-drawn items When you indicate that a control is owner-drawn, either by setting a property or supplying a custom draw event handler, Windows no longer draws the control on the screen. Instead, it generates events for each visible item in the control Your application handles the events to draw the items. To draw the items in an owner-draw control, do the following for each visible item in the control. Use a single event handler for all items 1 Size the item, if needed. Items of the same size (for example, with a list box style of lsOwnerDrawFixed), do not require sizing. 2 Draw the item. Working with controls 5-13 A d d http://www.doksihu ing graphics to controls Forrás: Sizing owner-draw items Before giving your application the chance to draw each item in a variable ownerdraw control, Windows generates a measure-item event. The measure-item event tells\n\n\n\nthe application where the item appears on the control. Windows determines the size the item (generally, it is just large enough to display the item’s text in the current font). Your application can handle the event and change the rectangle Windows chose. For example, if you plan to substitute a bitmap for the item’s text, change the rectangle to be the size of the bitmap. If you want a bitmap and text, adjust the rectangle to be big enough for both. To change the size of an owner-draw item, attach an event handler to the measureitem event in the owner-draw control. Depending on the control, the name of the event can vary. List boxes and combo boxes use OnMeasureItem Grids have no measure-item event. The sizing event has two important parameters: the index number of the item and the size of that item. The size is variable: the application can make it either smaller or larger. The positions of subsequent items depend on the size of preceding items For example, in a variable\n\n\n\nowner-draw list box, if the application sets the height of the first item to five pixels, the second item starts at the sixth pixel down from the top, and so on. In list boxes and combo boxes, the only aspect of the item the application can alter is the height of the item. The width of the item is always the width of the control. Owner-draw grids cannot change the sizes of their cells as they draw. The size of each row and column is set before drawing by the ColWidths and RowHeights properties. The following code, attached to the OnMeasureItem event of an owner-draw list box, increases the height of each list item to accommodate its associated bitmap. void fastcall TForm1::ListBox1MeasureItem(TWinControl *Control, int Index, int &Height) // note that Height is passed by reference { int BitmapHeight = ((TBitmap *)ListBox1->Items->Objects[Index])->Height + 2; // make sure list item has enough room for bitmap (plus 2) if (BitmapHeight > Height) Height = BitmapHeight; }\n\n\n\nNote You must typecast the items from the Objects property in the string list. Objects is a property of type TObject so that it can hold any kind of object. When you retrieve objects from the array, you need to typecast them back to the actual type of the items. Drawing each owner-draw item When an application needs to draw or redraw an owner-draw control, Windows generates draw-item events for each visible item in the control. Depending on the control, the item may also receive draw events for the item as a whole or subitems. 5-14 Developer’s Guide Adding graphics to controls To draw each item in an owner-draw control, attach an event handler to the drawitem event for that control. The names of events for owner drawing typically start with one of the following:\n• OnDraw, such as OnDrawItem or OnDrawCell\n• OnCustomDraw, such as OnCustomDrawItem\n• OnAdvancedCustomDraw, such as OnAdvancedCustomDrawItem The draw-item event contains parameters identifying the item to draw,\n\n\n\nthe rectangle in which to draw, and usually some information about the state of the item (such as whether the item has focus). The application handles each event by rendering the appropriate item in the given rectangle. For example, the following code shows how to draw items in a list box that has bitmaps associated with each string. It attaches this handler to the OnDrawItem event for the list box: void fastcall TForm1::ListBox1DrawItem(TWinControl *Control, int Index, TRect &Rect, TOwnerDrawState State) TBitmap *Bitmap = (TBitmap )ListBox1->Items->Objects[Index]; ListBox1->Canvas->Draw(R.Left, RTop + 2, Bitmap); // draw the bitmap ListBox1->Canvas->TextOut(R.Left + Bitmap->Width + 2, RTop + 2, ListBox1->Items->Strings[Index]); // and write the text to its right } Working with controls 5-15 5-16 Developer’s Guide Chapter 6 Working with graphics and multimedia Chapter6 Graphics and multimedia elements can add polish to your\n\n\n\napplications. C++Builder offers a variety of ways to introduce these features into your application. To add graphical elements, you can insert pre-drawn pictures at design time, create them using graphical controls at design time, or draw them dynamically at runtime. To add multimedia capabilities, C++Builder includes special components that can play audio and video clips. Overview of graphics programming The VCL graphics components encapsulate the Windows Graphics Device Interface (GDI), making it very easy to add graphics to your Windows programming. To draw graphics in a C++Builder application, you draw on an object’s canvas, rather than directly on the object. The canvas is a property of the object, and is itself an object. A main advantage of the canvas object is that it handles resources effectively and it takes care of device context, so your programs can use the same methods regardless of whether you are drawing on the screen, to a printer, or on bitmaps or metafiles.\n\n\n\nCanvases are available only at runtime, so you do all your work with canvases by writing code. Note Since TCanvas is a wrapper resource manager around the Windows device context, you can also use all Windows GDI functions on the canvas. The Handle property of the canvas is the device context Handle. How graphic images appear in your application depends on the type of object whose canvas you draw on. If you are drawing directly onto the canvas of a control, the picture is displayed immediately. However, if you draw on an offscreen image such as a TBitmap canvas, the image is not displayed until a control copies from the bitmap onto the control’s canvas. That is, when drawing bitmaps and assigning them to an Working with graphics and multimedia 6-1 O v e http://www.doksihu rview of graphics programming Forrás: image control, the image appears only when the control has an opportunity to process its OnPaint message. When working with graphics, you often encounter the terms drawing\n\n\n\nand painting:\n• Drawing is the creation of a single, specific graphic element, such as a line or a shape, with code. In your code, you tell an object to draw a specific graphic in a specific place on its canvas by calling a drawing method of the canvas.\n• Painting is the creation of the entire appearance of an object. Painting usually involves drawing. That is, in response to OnPaint events, an object generally draws some graphics. An edit box, for example, paints itself by drawing a rectangle and then drawing some text inside. A shape control, on the other hand, paints itself by drawing a single graphic. The examples in the beginning of this chapter demonstrate how to draw various graphics, but they do so in response to OnPaint events. Later sections show how to do the same kind of drawing in response to other events. Refreshing the screen At certain times, Windows determines that objects onscreen need to refresh their appearance, so it generates WM PAINT messages, which the VCL\n\n\n\nroutes to OnPaint events. The VCL calls any OnPaint event handler that you have written for that object when you use the Refresh method. The default name generated for the OnPaint event handler in a form is FormPaint. You may want to use the Refresh method at times to refresh a component or form. For example, you might call Refresh in the form’s OnResize event handler to redisplay any graphics or if you want to paint a background on a form. While some operating systems automatically handle the redrawing of the client area of a window that has been invalidated, Windows does not. In the Windows operating system anything drawn on the screen is permanent. When a form or control is temporarily obscured, for example during window dragging, the form or control must repaint the obscured area when it is re-exposed. For more information about the WM PAINT message, see the Windows online Help. If you use the TImage control, the painting and refreshing of the graphic contained in the TImage is\n\n\n\nhandled automatically by the VCL. Drawing on a TImage creates a persistent image. Consequently, you do not need to do anything to redraw the contained image. In contrast, TPaintBox’s canvas maps directly onto the screen device, so that anything drawn to the PaintBox’s canvas is transitory. This is true of nearly all controls, including the form itself. Therefore, if you draw or paint on a TPaintBox in its constructor, you will need to add that code to your OnPaint event handler in order for image to be repainted each time the client area is invalidated. Types of graphic objects The VCL provides the graphic objects shown in Table 6.1 These objects have methods to draw on the canvas, which are described in “Using Canvas methods to 6-2 Developer’s Guide Overview of graphics programming draw graphic objects” on page 6-9 and to load and save to graphics files, as described in “Loading and saving graphics files” on page 6-18. Table 6.1 Graphic object types Object \n\n\n\nDescription Picture Used to hold any graphic image. To add additional graphic file formats, use the Picture Register method. Use this to handle arbitrary files such as displaying images in an image control. Bitmap A powerful graphics object used to create, manipulate (scale, scroll, rotate, and paint), and store images as files on a disk. Creating copies of a bitmap is fast since the handle is copied, not the image. Clipboard Represents the container for any text or graphics that are cut, copied, or pasted from or to an application. With the clipboard, you can get and retrieve data according to the appropriate format; handle reference counting, and opening and closing the Clipboard; manage and manipulate formats for objects in the Clipboard. Icon Represents the value loaded from a Windows icon file (::ICO file). Metafile Contains a metafile, which records the operations required to construct an image, rather than contain the actual bitmap pixels of the image. Metafiles are\n\n\n\nextremely scalable without the loss of image detail and often require much less memory than bitmaps, particularly for high-resolution devices, such as printers. However, metafiles do not draw as fast as bitmaps. Use a metafile when versatility or precision is more important than performance. Common properties and methods of Canvas Table 6.2 lists the commonly used properties of the Canvas object For a complete list of properties and methods, see the TCanvas component in online Help. Table 6.2 Common properties of the Canvas object Properties Descriptions Font Specifies the font to use when writing text on the image. Set the properties of the TFont object to specify the font face, color, size, and style of the font. Brush Determines the color and pattern the canvas uses for filling graphical shapes and backgrounds. Set the properties of the TBrush object to specify the color and pattern or bitmap to use when filling in spaces on the canvas. Pen Specifies the kind of pen the\n\n\n\ncanvas uses for drawing lines and outlining shapes. Set the properties of the TPen object to specify the color, style, width, and mode of the pen. PenPos Specifies the current drawing position of the pen. Pixels Specifies the color of the area of pixels within the current ClipRect. These properties are described in more detail in “Using the properties of the Canvas object” on page 6-4. Working with graphics and multimedia 6-3 O v e http://www.doksihu rview of graphics programming Forrás: Table 6.3 is a list of several methods you can use: Table 6.3 Common methods of the Canvas object Method Descriptions Arc Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle. Chord Draws a closed figure represented by the intersection of a line and an ellipse. CopyRect Copies part of an image from another canvas into the canvas. Draw Renders the graphic object specified by the Graphic parameter on the canvas at the location given by\n\n\n\nthe coordinates (X, Y). Ellipse Draws the ellipse defined by a bounding rectangle on the canvas. FillRect Fills the specified rectangle on the canvas using the current brush. FloodFill Fills an area of the canvas using the current brush. FrameRect Draws a rectangle using the Brush of the canvas to draw the border. LineTo Draws a line on the canvas from PenPos to the point specified by X and Y, and sets the pen position to (X, Y). MoveTo Changes the current drawing position to the point (X,Y). Pie Draws a pie-shaped the section of the ellipse bounded by the rectangle (X1, Y1) and (X2, Y2) on the canvas. Polygon Draws a series of lines on the canvas connecting the points passed in and closing the shape by drawing a line from the last point to the first point. PolyLine Draws a series of lines on the canvas with the current pen, connecting each of the points passed to it in Points. Rectangle Draws a rectangle on the canvas with its upper left corner at the point (X1,\n\n\n\nY1) and its lower right corner at the point (X2, Y2). Use Rectangle to draw a box using Pen and fill it using Brush. RoundRect Draws a rectangle with rounded corners on the canvas. StretchDraw Draws a graphic on the canvas so that the image fits in the specified rectangle. The graphic image may need to change its magnitude or aspect ratio to fit. TextHeight, TextWidth Returns the height and width, respectively, of a string in the current font. Height includes leading between lines. TextOut Writes a string on the canvas, starting at the point (X,Y), and then updates the PenPos to the end of the string. TextRect Writes a string inside a region; any portions of the string that fall outside the region do not appear. These methods are described in more detail in “Using Canvas methods to draw graphic objects” on page 6-9. Using the properties of the Canvas object With the Canvas object, you can set the properties of a pen for drawing lines, a brush for filling shapes, a font\n\n\n\nfor writing text, and an array of pixels to represent the image. 6-4 Developer’s Guide Overview of graphics programming This section describes\n• Using pens\n• Using brushes\n• Reading and setting pixels Using pens The Pen property of a canvas controls the way lines appear, including lines drawn as the outlines of shapes. Drawing a straight line is really just changing a group of pixels that lie between two points. The pen itself has four properties you can change: Color, Width, Style, and Mode.\n• Color property: Changes the pen color\n• Width property: Changes the pen width\n• Style property: Changes the pen style\n• Mode property: Changes the pen mode The values of these properties determine how the pen changes the pixels in the line. By default, every pen starts out black, with a width of 1 pixel, a solid style, and a mode called copy that overwrites anything already on the canvas. Changing the pen color You can set the color of a pen as you would any other Color\n\n\n\nproperty at runtime. A pen’s color determines the color of the lines the pen draws, including lines drawn as the boundaries of shapes, as well as other lines and polylines. To change the pen color, assign a value to the Color property of the pen. To let the user choose a new color for the pen, put a color grid on the pen’s toolbar. A color grid can set both foreground and background colors. For a non-grid pen style, you must consider the background color, which is drawn in the gaps between line segments. Background color comes from the Brush color property Since the user chooses a new color by clicking the grid, this code changes the pen’s color in response to the OnClick event: void fastcall TForm1::PenColorClick(TObject *Sender) { Canvas->Pen->Color = PenColor->ForegroundColor; } Changing the pen width A pen’s width determines the thickness, in pixels, of the lines it draws. Note When the thickness is greater than 1, Windows 95 always draw solid lines, no matter\n\n\n\nwhat the value of the pen’s Style property. To change the pen width, assign a numeric value to the pen’s Width property. Working with graphics and multimedia 6-5 O v e http://www.doksihu rview of graphics programming Forrás: Suppose you have a scroll bar on the pen’s toolbar to set width values for the pen. And suppose you want to update the label next to the scroll bar to provide feedback to the user. Using the scroll bar’s position to determine the pen width, you update the pen width every time the position changes. This is how to handle the scroll bar’s OnChange event: void fastcall TForm1::PenWidthChange(TObject *Sender) { Canvas->Pen->Width = PenWidth->Position; // set the pen width directly PenSize->Caption = IntToStr(PenWidth->Position); // convert to string } Changing the pen style A pen’s Style property allows you to set solid lines, dashed lines, dotted lines, and so on. Note Windows 95 does not support dashed or dotted line styles for\n\n\n\npens wider than one pixel and makes all larger pens solid, no matter what style you specify. The task of setting the properties of pen is an ideal case for having different controls share same event handler to handle events. To determine which control actually got the event, you check the Sender parameter. To create one click-event handler for six pen-style buttons on a pen’s toolbar, do the following: 1 Select all six pen-style buttons and select the Object Inspector|Events|OnClick event and in the Handler column, type SetPenStyle. C++Builder generates an empty click-event handler called SetPenStyle and attaches it to the OnClick events of all six buttons. 2 Fill in the click-event handler by setting the pen’s style depending on the value of Sender, which is the control that sent the click event: void fastcall TForm1::SetPenStyle(TObject *Sender) { if (Sender == SolidPen) Canvas->Pen->Style = psSolid; else if (Sender == DashPen) Canvas->Pen->Style = psDash; else if\n\n\n\n(Sender == DotPen) Canvas->Pen->Style = psDot; else if (Sender == DashDotPen) Canvas->Pen->Style = psDashDot; else if (Sender == DashDotDotPen) Canvas->Pen->Style = psDashDotDot; else if (Sender == ClearPen) Canvas->Pen->Style = psClear; } 6-6 Developer’s Guide Overview of graphics programming The above event handler code could be further reduced by putting the pen style constants into the Tag properties of the pen style buttons. Then this event code would be something like: void fastcall TForm1::SetPenStyle(TObject *Sender) { if (Sender->InheritsFrom ( classid(TSpeedButton)) Canvas->Pen->Style = (TPenStyle) ((TSpeedButton *)Sender)->Tag; } Changing the pen mode A pen’s Mode property lets you specify various ways to combine the pen’s color with the color on the canvas. For example, the pen could always be black, be an inverse of the canvas background color, inverse of the pen color, and so on. See TPen in online Help for details. \n\n\n\nGetting the pen position The current drawing positionthe position from which the pen begins drawing its next lineis called the pen position. The canvas stores its pen position in its PenPos property. Pen position affects the drawing of lines only; for shapes and text, you specify all the coordinates you need. To set the pen position, call the MoveTo method of the canvas. For example, the following code moves the pen position to the upper left corner of the canvas: Canvas->MoveTo(0, 0); Note Drawing a line with the LineTo method also moves the current position to the endpoint of the line. Using brushes The Brush property of a canvas controls the way you fill areas, including the interior of shapes. Filling an area with a brush is a way of changing a large number of adjacent pixels in a specified way. The brush has three properties you can manipulate:\n• Color property: Changes the fill color\n• Style property: Changes the brush style\n• Bitmap property: Uses a bitmap as a brush\n\n\n\npattern The values of these properties determine the way the canvas fills shapes or other areas. By default, every brush starts out white, with a solid style and no pattern bitmap. Changing the brush color A brush’s color determines what color the canvas uses to fill shapes. To change the fill color, assign a value to the brush’s Color property. Brush is used for background color in text and line drawing so you typically set the background color property. Working with graphics and multimedia 6-7 O v e http://www.doksihu rview of graphics programming Forrás: You can set the brush color just as you do the pen color, in response to a click on a color grid on the brush’s toolbar (see “Changing the pen color” on page 6-5): void fastcall TForm1::BrushColorClick(TObject *Sender) { Canvas->Brush->Color = BrushColor->BackgroundColor; } Changing the brush style A brush style determines what pattern the canvas uses to fill shapes. It lets you specify various ways to\n\n\n\ncombine the brush’s color with any colors already on the canvas. The predefined styles include solid color, no color, and various line and hatch patterns. To change the style of a brush, set its Style property to one of the predefined values: bsSolid, bsClear, bsHorizontal, bsVertical, bsFDiagonal, bsBDiagonal, bsCross, or bsDiagCross. This example sets brush styles by sharing a click-event handler for a set of eight brush-style buttons. All eight buttons are selected, the Object Inspector|Events| OnClick is set, and the OnClick handler is named SetBrushStyle. Here is the handler code: void fastcall TForm1::SetBrushStyle(TObject *Sender) { if (Sender == SolidBrush) Canvas->Brush->Style = bsSolid; else if (Sender == ClearBrush) Canvas->Brush->Style = bsClear; else if (Sender == HorizontalBrush) Canvas->Brush->Style = bsHorizontal; else if (Sender == VerticalBrush) Canvas->Brush->Style = bsVertical; else if (Sender == FDiagonalBrush) Canvas->Brush->Style\n\n\n\n= bsFDiagonal; else if (Sender == BDiagonalBrush) Canvas->Brush->Style = bsBDiagonal; else if (Sender == CrossBrush) Canvas->Brush->Style = bsCross; else if (Sender == DiagCrossBrush) Canvas->Brush->Style = bsDiagCross; } The above event handler code could be further reduced by putting the brush style constants into the Tag properties of the brush style buttons. Then this event code would be something like: void fastcall TForm1::SetBrushStyle(TObject *Sender) { if (Sender->InheritsFrom ( classid(TSpeedButton)) Canvas->Brush>Style = (TBrushStyle) ((TSpeedButton *)Sender)->Tag; } 6-8 Developer’s Guide Overview of graphics programming Setting the Brush Bitmap property A brush’s Bitmap property lets you specify a bitmap image for the brush to use as a pattern for filling shapes and other areas. The following example loads a bitmap from a file and assigns it to the Brush of the Canvas of Form1: BrushBmp->LoadFromFile(\"MyBitmap.bmp\");\n\n\n\nForm1->Canvas->Brush->Bitmap = BrushBmp; Form1->Canvas->FillRect(Rect(0,0,100,100)); Note The brush does not assume ownership of a bitmap object assigned to its Bitmap property. You must ensure that the Bitmap object remain valid for the lifetime of the Brush, and you must free the Bitmap object yourself afterwards. Reading and setting pixels You will notice that every canvas has an indexed Pixels property that represents the individual colored points that make up the image on the canvas. You rarely need to access Pixels directly, it is available only for convenience to perform small actions such as finding or setting a pixel’s color. Note Setting and getting individual pixels is thousands of times slower than performing graphics operations on regions. Do not use the Pixel array property to access the image pixels of a general array. For high-performance access to image pixels, see the TBitmap::ScanLine property. Using Canvas methods to draw graphic objects This\n\n\n\nsection shows how to use some common methods to draw graphic objects. It covers:\n• \n• \n• \n• Drawing lines and polylines Drawing shapes Drawing rounded rectangles Drawing polygons Drawing lines and polylines A canvas can draw straight lines and polylines. A straight line is just a line of pixels connecting two points. A polyline is a series of straight lines, connected end-to-end The canvas draws all lines using its pen. Drawing lines To draw a straight line on a canvas, use the LineTo method of the canvas. LineTo draws a line from the current pen position to the point you specify and makes the endpoint of the line the current position. The canvas draws the line using its pen Working with graphics and multimedia 6-9 O v e http://www.doksihu rview of graphics programming Forrás: For example, the following method draws crossed diagonal lines across a form whenever the form is painted: void fastcall TForm1::FormPaint(TObject *Sender) { Canvas->MoveTo(0,0);\n\n\n\nCanvas->LineTo(ClientWidth, ClientHeight); Canvas->MoveTo(0, ClientHeight); Canvas->LineTo(ClientWidth, 0); } Drawing polylines In addition to individual lines, the canvas can also draw polylines, which are groups of any number of connected line segments. To draw a polyline on a canvas, call the Polyline method of the canvas. The parameter passed to the PolyLine method is an array of points. You can think of a polyline as performing a MoveTo on the first point and LineTo on each successive point. For drawing multiple lines, Polyline is faster than using the MoveTo method and the LineTo method because it eliminates a lot of call overhead. The following method, for example, draws a rhombus in a form: void fastcall TForm1::FormPaint(TObject *Sender) { POINT vertices[5]; vertices[0] = Point(0, 0); vertices[1] = Point(50, 0); vertices[2] = Point(75, 50); vertices[3] = Point(25, 50); vertices[4] = Point(0, 0); Canvas->Polyline(vertices, 4); } Note that the last parameter to\n\n\n\nPolyline is the index of the last point, not the number of points. Drawing shapes Canvases have methods for drawing different kinds of shapes. The canvas draws the outline of a shape with its pen, then fills the interior with its brush. The line that forms the border for the shape is controlled by the current Pen object. This section covers:\n• Drawing rectangles and ellipses\n• Drawing rounded rectangles\n• Drawing polygons Drawing rectangles and ellipses To draw a rectangle or ellipse on a canvas, call the canvas’s Rectangle method or Ellipse method, passing the coordinates of a bounding rectangle. 6-10 Developer’s Guide Overview of graphics programming The Rectangle method draws the bounding rectangle; Ellipse draws an ellipse that touches all sides of the rectangle. The following method draws a rectangle filling a form’s upper left quadrant, then draws an ellipse in the same area: void fastcall TForm1::FormPaint(TObject *Sender) { Canvas->Rectangle(0, 0,\n\n\n\nClientWidth/2, ClientHeight/2); Canvas->Ellipse(0, 0, ClientWidth/2, ClientHeight/2); } Drawing rounded rectangles To draw a rounded rectangle on a canvas, call the canvas’s RoundRect method. The first four parameters passed to RoundRect are a bounding rectangle, just as for the Rectangle method or the Ellipse method. RoundRect takes two more parameters that indicate how to draw the rounded corners. The following method, for example, draws a rounded rectangle in a form’s upper left quadrant, rounding the corners as sections of a circle with a diameter of 10 pixels: void fastcall TForm1::FormPaint(TObject *Sender) { Canvas->RoundRect(0, 0, ClientWidth/2, ClientHeight/2, 10, 10); } Drawing polygons To draw a polygon with any number of sides on a canvas, call the Polygon method of the canvas. Polygon takes an array of points as its only parameter and connects the points with the pen, then connects the last point to the first to close the polygon. After drawing the lines,\n\n\n\nPolygon uses the brush to fill the area inside the polygon. For example, the following code draws a right triangle in the lower left half of a form: void fastcall TForm1::FormPaint(TObject *Sender) { POINT vertices[3]; vertices[0] = Point(0, 0); vertices[1] = Point(0, ClientHeight); vertices[2] = Point(ClientWidth,ClientHeight); Canvas->Polygon(vertices,2); } Handling multiple drawing objects in your application Various drawing methods (rectangle, shape, line, and so on) are typically available on the toolbar and button panel. Applications can respond to clicks on speed buttons to set the desired drawing objects. This section describes how to:\n• Keep track of which drawing tool to use\n• Changing the tool with speed buttons\n• Using drawing tools Working with graphics and multimedia 6-11 O v e http://www.doksihu rview of graphics programming Forrás: Keeping track of which drawing tool to use A graphics program needs to keep track of what kind of drawing tool (such as a\n\n\n\nline, rectangle, ellipse, or rounded rectangle) a user might want to use at any given time. Typically, you would use the C++ enumerated type to list the available tools. Since an enumerated type is also a type declaration, you can use C++’s type-checking to ensure that you assign only those specific values. For example, the following code declares an enumerated type for each drawing tool available in a graphics application: enum TDrawingTool {dtLine, dtRectangle, dtEllipse, dtRoundRect}; A variable of type TDrawingTool can be assigned only one of the constants dtLine, dtRectangle, dtEllipse, or dtRoundRect. By convention, type identifiers begin with the letter T, and groups of similar constants (such as those making up an enumerated type) begin with a 2-letter prefix (such as dt for “drawing tool”). In the following code, a field added to a form keeps track of the form’s drawing tool: enum TDrawingTool {dtLine, dtRectangle, dtEllipse, dtRoundRect}; class TForm1 : public TForm\n\n\n\n{ published: // IDE-managed Components void fastcall FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); void fastcall FormMouseMove(TObject *Sender, TShiftState Shift, int X, int Y); void fastcall FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); private:// User declarations public:// User declarations fastcall TForm1(TComponent* Owner); bool Drawing; //field to track whether button was pressed POINT Origin, MovePt; // fields to store points TDrawingTool DrawingTool; // field to hold current tool }; Changing the tool with speed buttons Each drawing tool needs an associated OnClick event handler. Suppose your application had a toolbar button for each of four drawing tools: line, rectangle, ellipse, and rounded rectangle. You would attach the following event handlers to the OnClick events of the four drawing-tool buttons, setting DrawingTool to the appropriate value for each: void fastcall\n\n\n\nTForm1::LineButtonClick(TObject *Sender) // LineButton { DrawingTool = dtLine; } void fastcall TForm1::RectangleButtonClick(TObject *Sender) // RectangleButton { DrawingTool = dtRectangle; } 6-12 Developer’s Guide Overview of graphics programming void fastcall TForm1::EllipseButtonClick(TObject *Sender) // EllipseButton { DrawingTool = dtEllipse; } void fastcall TForm1::RoundedRectButtonClick(TObject *Sender) // RoundRectBtn { DrawingTool = dtRoundRect; } Using drawing tools Now that you can tell what tool to use, you must indicate how to draw the different shapes. The only methods that perform any drawing are the mouse-move and mouse-up handlers, and the only drawing code draws lines, no matter what tool is selected. To use different drawing tools, your code needs to specify how to draw, based on the selected tool. You add this instruction to each tool’s event handler This section describes\n• Drawing shapes\n• Sharing code among event handlers Drawing shapes\n\n\n\nDrawing shapes is just as easy as drawing lines: Each one takes a single statement; you just need the coordinates. Here’s a rewrite of the OnMouseUp event handler that draws shapes for all four tools: void fastcall TForm1::FormMouseUp(TObject *Sender) { switch (DrawingTool) { case dtLine: Canvas->MoveTo(Origin.x, Originy); Canvas->LineTo(X, Y); break; case dtRectangle: Canvas->Rectangle(Origin.x, Originy, X, Y); break; case dtEllipse: Canvas->Ellipse(Origin.x, Originy, X, Y); break; case dtRoundRect: Canvas->Rectangle(Origin.x, Originy, X, Y, (Originx - X)/2, (Origin.y - Y)/2); break; } Drawing = false; } Working with graphics and multimedia 6-13 O v e http://www.doksihu rview of graphics programming Forrás: Of course, you also need to update the OnMouseMove handler to draw shapes: void fastcall TForm1::FormMouseMove(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { if (Drawing) { Canvas->Pen->Mode = pmNotXor; // use XOR mode to\n\n\n\ndraw/erase switch (DrawingTool) { case dtLine: Canvas->MoveTo(Origin.x, Originy); Canvas->LineTo(MovePt.x, MovePty); Canvas->MoveTo(Origin.x, Originy); Canvas->LineTo(X, Y); break; case dtRectangle: Canvas->Rectangle(Origin.x, Originy, MovePtx, MovePty); Canvas->Rectangle(Origin.x, Originy, X, Y); break; case dtEllipse: Canvas->Ellipse(Origin.x, Originy, MovePtx, MovePty); Canvas->Ellipse(Origin.x, Originy, X, Y); break; case dtRoundRect: Canvas->Rectangle(Origin.x, Originy, MovePtx, MovePty, (Origin.x - MovePtx)/2,(Originy - MovePty)/2); Canvas->Rectangle(Origin.x, Originy, X, Y, (Origin.x - X)/2, (Originy - Y)/2); break; } MovePt = Point(X, Y); Canvas->Pen->Mode = pmCopy; } Typically, all the repetitious code that is in the above example would be in a separate routine. The next section shows all the shape-drawing code in a single routine that all mouse-event handlers can call. Sharing code among event handlers Any time you find that many your\n\n\n\nevent handlers use the same code, you can make your application more efficient by moving the repeated code into a routine that all event handlers can share. To add a method to a form, 1 Add the method declaration to the form object. You can add the declaration in either the public or private parts at the end of the form object’s declaration. If the code is just sharing the details of handling some events, it’s probably safest to make the shared method private. 2 Write the method implementation in the .cpp file for the form’s unit 6-14 Developer’s Guide Overview of graphics programming The header for the method implementation must match the declaration exactly, with the same parameters in the same order. The following code adds a method to the form called DrawShape and calls it from each of the handlers. First, the declaration of DrawShape is added to the form object’s declaration: enum TDrawingTool {dtLine, dtRectangle, dtEllipse, dtRoundRect}; class TForm1 : public\n\n\n\nTForm { published: // IDE-managed Components void fastcall FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); void fastcall FormMouseMove(TObject *Sender, TShiftState Shift, int X, int Y); void fastcall FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); private:// User declarations void fastcall DrawShape(POINT TopLeft, POINT BottomRight, TPenMode AMode); public:// User declarations fastcall TForm1(TComponent* Owner); bool Drawing; //field to track whether button was pressed POINT Origin, MovePt; // fields to store points TDrawingTool DrawingTool; // field to hold current tool }; Then, the implementation of DrawShape is written in the .cpp file for the unit: void fastcall TForm1::DrawShape(POINT TopLeft, POINT BottomRight, TPenMode AMode) { Canvas->Pen->Mode = AMode; switch (DrawingTool) { case dtLine: Canvas->MoveTo(TopLeft.x, TopLefty); Canvas->LineTo(BottomRight.x, BottomRighty); break;\n\n\n\ncase dtRectangle: Canvas->Rectangle(TopLeft.x, TopLefty, BottomRightx, BottomRighty); break; case dtEllipse: Canvas->Ellipse(TopLeft.x, TopLefty, BottomRightx, BottomRighty); break; case dtRoundRect: Canvas->Rectangle(TopLeft.x, TopLefty, BottomRightx, BottomRighty, (TopLeft.x - BottomRightx)/2,(TopLefty - BottomRighty)/2); break; } } Working with graphics and multimedia 6-15 O v e http://www.doksihu rview of graphics programming Forrás: The other event handlers are modified to call DrawShape. void fastcall TForm1::FormMouseUp(TObject *Sender) { DrawShape(Origin, Point(X,Y), pmCopy); // draw the final shape Drawing = false; } void fastcall TForm1::FormMouseMove(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { if (Drawing) { DrawShape(Origin, MovePt, pmNotXor); // erase previous shape MovePt = Point(X, Y); DrawShape(Origin, MovePt, pmNotXor); // draw current shape } } Drawing on a graphic You don’t need any components to manipulate your\n\n\n\napplication’s graphic objects. You can construct, draw on, save, and destroy graphic objects without ever drawing anything on screen. In fact, your applications rarely draw directly on a form More often, an application operates on graphics and then uses a VCL image control component to display the graphic on a form. Once you move the application’s drawing to the graphic in the image control, it is easy to add printing, Clipboard, and loading and saving operations for any graphic objects. graphic objects can be bitmap files, metafiles, icons or whatever other graphics classes that have been installed such as JPEG graphics. Note Because you are drawing on an offscreen image such as a TBitmap canvas, the image is not displayed until a control copies from a bitmap onto the control’s canvas. That is, when drawing bitmaps and assigning them to an image control, the image appears only when the control has an opportunity to process its paint message. But if you are drawing directly onto\n\n\n\nthe canvas property of a control, the picture object is displayed immediately. Making scrollable graphics The graphic need not be the same size as the form: it can be either smaller or larger. By adding a scroll box control to the form and placing the graphic image inside it, you can display graphics that are much larger than the form or even larger than the screen. To add a scrollable graphic first you add a TScrollBox component and then you add the image control. Adding an image control An image control is a container component that allows you to display your bitmap objects. You use an image control to hold a bitmap that is not necessarily displayed all the time, or which an application needs to use to generate other pictures. Note 6-16 “Adding graphics to controls” on page 5-11 shows how to use graphics in controls. Developer’s Guide Overview of graphics programming Placing the control You can place an image control anywhere on a form. If you take advantage of the\n\n\n\nimage control’s ability to size itself to its picture, you need to set the top left corner only. If the image control is a nonvisible holder for a bitmap, you can place it anywhere, just as you would a nonvisual component. If you drop the image control on a scroll box already aligned to the form’s client area, this assures that the scroll box adds any scroll bars necessary to access offscreen portions of the image’s picture. Then set the image control’s properties Setting the initial bitmap size When you place an image control, it is simply a container. However, you can set the image control’s Picture property at design time to contain a static graphic. The control can also load its picture from a file at runtime, as described in “Loading and saving graphics files” on page 6-18. To create a blank bitmap when the application starts, 1 Attach a handler to the OnCreate event for the form that contains the image. 2 Create a bitmap object, and assign it to the image\n\n\n\ncontrol’s Picture->Graphic property. In this example, the image is in the application’s main form, Form1, so the code attaches a handler to Form1’s OnCreate event: void fastcall TForm1::FormCreate(TObject *Sender) { TBitmap *Bitmap = new TBitmap(); // create the bitmap object Bitmap->Width = 200; // assign the initial width. Bitmap->Height = 200; // .and the initial height Image->Picture->Graphic = Bitmap; // assign the bitmap to the image control } Assigning the bitmap to the picture’s Graphic property gives ownership of the bitmap to the picture object. The picture object destroys the bitmap when it finishes with it, so you should not destroy the bitmap object. You can assign a different bitmap to the picture (see “Replacing the picture” on page 6-19), at which point the picture disposes of the old bitmap and assumes ownership of the new one. If you run the application now, you see that client area of the form has a white region, representing the bitmap.\n\n\n\nIf you size the window so that the client area cannot display the entire image, you’ll see that the scroll box automatically shows scroll bars to allow display of the rest of the image. But if you try to draw on the image, you don’t get any graphics, because the application is still drawing on the form, which is now behind the image and the scroll box. Drawing on the bitmap To draw on a bitmap, use the image control’s canvas and attach the mouse-event handlers to the appropriate events in the image control. Typically you would use region operations (fills, rectangles, polylines, and so on). These are fast and efficient methods of drawing. Working with graphics and multimedia 6-17 O v e http://www.doksihu rview of graphics programming Forrás: An efficient way to draw images when you need to access individual pixels is to use the bitmap ScanLine property. For general-purpose usage, you can set up the bitmap pixel format to 24 bits and then treat the pointer returned from\n\n\n\nScanLine as an array of RGB. Otherwise, you will need to know the native format of the ScanLine property This example shows how to use ScanLine to get pixels one line at a time. void fastcall TForm1::Button1Click(TObject *Sender) { Graphics::TBitmap *pBitmap = new Graphics::TBitmap(); // This example shows drawing directly to the Bitmap Byte *ptr; try { pBitmap->LoadFromFile(\"C:Program FilesBorlandCBuilderImagesSplash256colorfactory.bmp \"); for (int y = 0; y < pBitmap->Height; y++) { ptr = pBitmap->ScanLine[y]; for (int x = 0; x < pBitmap->Width; x++) ptr[x] = (Byte)y; } Canvas->Draw(0,0,pBitmap); } catch (.) { ShowMessage(\"Could not load or alter bitmap\"); } delete pBitmap; } Loading and saving graphics files Graphic images that exist only for the duration of one running of an application are of very limited value. Often, you either want to use the same picture every time, or you want to save a created picture for later use. The VCL’s\n\n\n\nimage control makes it easy to load pictures from a file and save them again. The VCL components you use to load, save, and replace graphic images support many graphic formats including bitmap files, metafiles, glyphs, and so on. They also support installable graphic classes. The way to load and save graphics files is the similar to any other files and is described in the following sections:\n• Loading a picture from a file\n• Saving a picture to a file\n• Replacing the picture Loading a picture from a file Your application should provide the ability to load a picture from a file if your application needs to modify the picture or if you want to store the picture outside the application so a person or another application can modify the picture. 6-18 Developer’s Guide Overview of graphics programming To load a graphics file into an image control, call the LoadFromFile method of the image control’s Picture object. The following code gets a file name from an open-file dialog\n\n\n\nbox, and then loads that file into an image control named Image: void fastcall TForm1::Open1Click(TObject *Sender) { if (OpenDialog1->Execute()) { CurrentFile = OpenDialog1->FileName; Image->Picture->LoadFromFile(CurrentFile); } } Saving a picture to a file The VCL picture object can load and save graphics in several formats, and you can create and register your own graphic-file formats so that picture objects can load and store them as well. To save the contents of an image control in a file, call the SaveToFile method of the image control’s Picture object. The SaveToFile method requires the name of a file in which to save. If the picture is newly created, it might not have a file name, or a user might want to save an existing picture in a different file. In either case, the application needs to get a file name from the user before saving, as shown in the next section. The following pair of event handlers, attached to the File|Save and File|Save As menu items,\n\n\n\nrespectively, handle the resaving of named files, saving of unnamed files, and saving existing files under new names. void fastcall TForm1::Save1Click(TObject *Sender) { if (!CurrentFile.IsEmpty()) Image->Picture->SaveToFile(CurrentFile); // save if already named else SaveAs1Click(Sender); // otherwise get a name } void fastcall TForm1::Saveas1Click(TObject *Sender) { if (SaveDialog1->Execute()) // get a file name { CurrentFile = SaveDialog1->FileName; // save user-specified name Save1Click(Sender); // then save normally } } Replacing the picture You can replace the picture in an image control at any time. If you assign a new graphic to a picture that already has a graphic, the new graphic replaces the existing one. To replace the picture in an image control, assign a new graphic to the image control’s Picture object. Working with graphics and multimedia 6-19 O v e http://www.doksihu rview of graphics programming Forrás: Creating the new graphic is the same\n\n\n\nprocess you used to create the initial graphic (see “Setting the initial bitmap size” on page 6-17), but you should also provide a way for the user to choose a size other than the default size used for the initial graphic. An easy way to provide that option is to present a dialog box, such as the one in Figure 6.1 Figure 6.1 Bitmap-dimension dialog box from the BMPDlg unit WidthEdit HeightEdit This particular dialog box is created in the BMPDlg unit included with the GraphEx project (in the EXAMPLESDOCGRAPHEX directory). With such a dialog box in your project, add an include statement for BMPDlg.hpp in the .cpp file for your main form You can then attach an event handler to the File| New menu item’s OnClick event. Here’s an example: void fastcall TForm1::New1Click(TObject *Sender) { Graphics::TBitmap *Bitmap; // make sure focus is on width field NewBMPForm->ActiveControl = NewBMPForm->WidthEdit; // initialize to current dimensions as default .\n\n\n\nNewBMPForm->WidthEdit->Text = IntToStr(Image->Picture->Graphic->Width); NewBMPForm->HeightEdit->Text = IntToStr(Image->Picture->Graphic->Height); if (NewBMPForm->ShowModal() != IDCANCEL){ // if user does not cancel dialog. Bitmap = new Graphics::TBitmap(); // create a new bitmap object // use specified dimensions Bitmap->Width = StrToInt(NewBMPForm->WidthEdit->Text); Bitmap->Height = StrToInt(NewBMPForm->HeightEdit->Text); Image->Picture->Graphic = Bitmap; // replace graphic with new bitmap CurrentFile = EmptyStr; //indicate unnamed file } } Note Assigning a new bitmap to the picture object’s Graphic property causes the picture object to destroy the existing bitmap and take ownership of the new one. The VCL handles the details of freeing the resources associated with the previous bitmap automatically. Using the Clipboard with graphics You can use the Windows Clipboard to copy and paste graphics within your applications or to\n\n\n\nexchange graphics with other applications. The VCL’s Clipboard object makes it easy to handle different kinds of information, including graphics. Before you can use the Clipboard object in your application, you must add an include statement for Clipbrd.hpp to any cpp file that needs to access Clipboard data 6-20 Developer’s Guide Overview of graphics programming Copying graphics to the Clipboard You can copy any picture, including the contents of image controls, to the Clipboard. Once on the Clipboard, the picture is available to all Windows applications. To copy a picture to the Clipboard, assign the picture to the Clipboard object using the Assign method. This code shows how to copy the picture from an image control named Image to the Clipboard in response to a click on an Edit|Copy menu item: void fastcall TForm1::Copy1Click(TObject *Sender) { Clipboard()->Assign(Image->Picture); } Cutting graphics to the Clipboard Cutting a graphic to the Clipboard is exactly\n\n\n\nlike copying it, but you also erase the graphic from the source. To cut a graphic from a picture to the Clipboard, first copy it to the Clipboard, then erase the original. In most cases, the only issue with cutting is how to show that the original image is erased. Setting the area to white is a common solution, as shown in the following code that attaches an event handler to the OnClick event of the Edit|Cut menu item: void fastcall TForm1::Cut1Click(TObject *Sender) { TRect ARect; Copy1Click(Sender); // copy picture to Clipboard Image->Canvas->CopyMode = cmWhiteness; // copy everything as white ARect = Rect(0, 0, Image->Width, Image->Height); // get dimensions of image Image->Canvas->CopyRect(ARect, Image->Canvas, ARect); // copy bitmap over self Image->Canvas->CopyMode = cmSrcCopy; // restore default mode } Pasting graphics from the Clipboard If the Windows Clipboard contains a bitmapped graphic, you can paste it into any image object, including image\n\n\n\ncontrols and the surface of a form. To paste a graphic from the Clipboard, 1 Call the Clipboard’s HasFormat method to see whether the Clipboard contains a graphic. HasFormat is a Boolean function. It returns true if the Clipboard contains an item of the type specified in the parameter. To test for graphics, you pass CF BITMAP 2 Assign the Clipboard to the destination. Working with graphics and multimedia 6-21 O v e http://www.doksihu rview of graphics programming Forrás: This code shows how to paste a picture from the Clipboard into an image control in response to a click on an Edit|Paste menu item: void fastcall TForm1::Paste1Click(TObject *Sender) { Graphics::TBitmap *Bitmap; if (Clipboard()->HasFormat(CF BITMAP)){ Image->Picture->Bitmap->ASsign(Clipboard);Canvas->Draw(0, 0, Bitmap); } } The graphic on the Clipboard could come from this application, or it could have been copied from another application, such as Windows Paintbrush. You do not need to check\n\n\n\nthe clipboard format in this case because the paste menu should be disabled when the clipboard does not contain a supported format. Rubber banding example This section walks you through the details of implementing the “rubber banding” effect in an graphics application that tracks mouse movements as the user draws a graphic at runtime. The example code in this section is taken from a sample application located in the EXAMPLESDOCGRAPHEX directory. The application draws lines and shapes on a window’s canvas in response to clicks and drags: pressing a mouse button starts drawing, and releasing the button ends the drawing. To start with, the example code shows how to draw on the surface of the main form. Later examples demonstrate drawing on a bitmap. This section covers:\n• Responding to the mouse\n• Adding a field to a form object to track mouse actions\n• Refining line drawing Responding to the mouse Your application can respond to the mouse actions: mouse-button down, mouse\n\n\n\nmoved, and mouse-button up. It can also respond to a click (a complete press-andrelease, all in one place) that can be generated by some kinds of keystrokes (such as pressing Enter in a modal dialog box). This section covers:\n• \n• \n• \n• 6-22 What’s in a mouse event Responding to a mouse-down action Responding to a mouse-up action Responding to a mouse move Developer’s Guide Overview of graphics programming What’s in a mouse event? The VCL has three mouse events: OnMouseDown event, OnMouseMove event, and OnMouseUp event. When a VCL application detects a mouse action, it calls whatever event handler you’ve defined for the corresponding event, passing five parameters. Use the information in those parameters to customize your responses to the events. The five parameters are as follows: Table 6.4 Mouse-event parameters Parameter Meaning Sender The object that detected the mouse action Button Indicates which mouse button was involved: mbLeft, mbMiddle, or mbRight \n\n\n\nShift Indicates the state of the Alt, Ctrl, and Shift keys at the time of the mouse action X, Y The coordinates where the event occurred Most of the time, you need the coordinates returned in a mouse-event handler, but sometimes you also need to check Button to determine which mouse button caused the event. Note C++Builder uses the same criteria as Microsoft Windows in determining which mouse button has been pressed. Thus, if you have switched the default “primary” and “secondary” mouse buttons (so that the right mouse button is now the primary button), clicking the primary (right) button will record mbLeft as the value of the Button parameter. Responding to a mouse-down action Whenever the user presses a button on the mouse, an OnMouseDown event goes to the object the pointer is over. The object can then respond to the event To respond to a mouse-down action, attach an event handler to the OnMouseDown event. The VCL generates an empty handler for a mouse-down event on\n\n\n\nthe form: void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { } Here’s code that displays some text at the point where the mouse button is pressed. It uses the X and Y parameters sent to the method, and calls the TextOut method of the canvas to display text there. Working with graphics and multimedia 6-23 O v e http://www.doksihu rview of graphics programming Forrás: The following code displays the string ‘Here!’ at the location on a form clicked with the mouse: void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Canvas->TextOut(X, Y, \"Here!\");// write text at (X, Y) } When the application runs, you can press the mouse button down with the mouse cursor on the form and have the string, “Here!” appear at the point clicked. This code sets the current drawing position to the coordinates where the user presses the button: void fastcall\n\n\n\nTForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Canvas->MoveTo(X, Y);// set pen position } Pressing the mouse button now sets the pen position, setting the line’s starting point. To draw a line to the point where the user releases the button, you need to respond to a mouse-up event. Responding to a mouse-up action An OnMouseUp event occurs whenever the user releases a mouse button. The event usually goes to the object the mouse cursor is over when the user presses the button, which is not necessarily the same object the cursor is over when the button is released. This enables you, for example, to draw a line as if it extended beyond the border of the form. To respond to mouse-up actions, define a handler for the OnMouseUp event. Here’s a simple OnMouseUp event handler that draws a line to the point of the mouse-button release: void fastcall TForm1::FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int\n\n\n\nY) { Canvas->LineTo(X, Y);// draw line from PenPos to (X, Y) } This code lets a user draw lines by clicking, dragging, and releasing. In this case, the user cannot see the line until the mouse button is released. Responding to a mouse move An OnMouseMove event occurs periodically when the user moves the mouse. The event goes to the object that was under the mouse pointer when the user pressed the button. This allows you to give the user some intermediate feedback by drawing temporary lines while the mouse moves. To respond to mouse movements, define an event handler for the OnMouseMove event. This example uses mouse-move events to draw intermediate shapes on a form while the user holds down the mouse button, thus providing some feedback to the 6-24 Developer’s Guide Overview of graphics programming user. The OnMouseMove event handler draws a line on a form to the location of the OnMouseMove event: void fastcall TForm1::FormMouseMove(TObject *Sender, TMouseButton Button,\n\n\n\nTShiftState Shift, int X, int Y) { Canvas->LineTo(X, Y);// draw line to current position } With this code, moving the mouse over the form causes drawing to follow the mouse, even before the mouse button is pressed. Mouse-move events occur even when you haven’t pressed the mouse button. If you want to track whether there is a mouse button pressed, you need to add an object field to the form object. Adding a field to a form object to track mouse actions To track whether a mouse button was pressed, you must add an object field to the form object. When you add a component to a form, C++Builder adds a field that represents that component to the form object, so that you can refer to the component by the name of its field. You can also add your own fields to forms by editing the type declaration in the form unit’s header file. In the following example, the form needs to track whether the user has pressed a mouse button. To do that, it adds a Boolean field and sets its value when the\n\n\n\nuser presses the mouse button. To add a field to an object, edit the object’s type definition, specifying the field identifier and type after the public directive at the bottom of the declaration. C++Builder “owns” any declarations before the public directive: that’s where it puts the fields that represent controls and the methods that respond to events. The following code gives a form a field called Drawing of type bool, in the form object’s declaration. It also adds two fields to store points Origin and MovePt of type POINT. class TForm1 : public TForm { published: // IDE-managed Components void fastcall FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); void fastcall FormMouseMove(TObject *Sender, TShiftState Shift, int X, int Y); void fastcall FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y); private:// User declarations public:// User declarations fastcall TForm1(TComponent* Owner); bool\n\n\n\nDrawing; //field to track whether button was pressed POINT Origin, MovePt; // fields to store points }; Working with graphics and multimedia 6-25 O v e http://www.doksihu rview of graphics programming Forrás: When you have a Drawing field to track whether to draw, set it to true when the user presses the mouse button, and false when the user releases it: void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Drawing = true; // set the Drawing flag Canvas->MoveTo(X, Y); // set pen position } void fastcall TForm1::FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Canvas->LineTo(X, Y); // draw line from PenPos to (X, Y) Drawing = false; // clear the Drawing flag } Then you can modify the OnMouseMove event handler to draw only when Drawing is true: void fastcall TForm1::FormMouseMove(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { if (Drawing)\n\n\n\nCanvas->LineTo(X, Y);// only draw if mouse is down } This results in drawing only between the mouse-down and mouse-up events, but you still get a scribbled line that tracks the mouse movements instead of a straight line. The problem is that each time you move the mouse, the mouse-move event handler calls LineTo, which moves the pen position, so by the time you release the button, you’ve lost the point where the straight line was supposed to start. Refining line drawing With fields in place to track various points, you can refine an application’s line drawing. Tracking the origin point When drawing lines, track the point where the line starts with the Origin field. Origin must be set to the point where the mouse-down event occurs, so the mouse-up event handler can use Origin to place the beginning of the line, as in this code: void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Drawing = true; // set the Drawing flag\n\n\n\nCanvas->MoveTo(X, Y); // set pen position Origin = Point(X, Y); // record where the line starts } 6-26 Developer’s Guide Overview of graphics programming void fastcall TForm1::FormMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Canvas->MoveTo(Origin.x, Originy); // move pen to starting point Canvas->LineTo(X, Y); // draw line from PenPos to (X, Y) Drawing = false; // clear the Drawing flag } Those changes get the application to draw the final line again, but they do not draw any intermediate actions--the application does not yet support “rubber banding.” Tracking movement The problem with this example as the OnMouseMove event handler is currently written is that it draws the line to the current mouse position from the last mouse position, not from the original position. You can correct this by moving the drawing position to the origin point, then drawing to the current point: void fastcall TForm1::FormMouseMove(TObject\n\n\n\n*Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { if (Drawing) { Canvas->MoveTo(Origin.x, Originy); // move pen to starting point Canvas->LineTo(X, Y); } } The above tracks the current mouse position, but the intermediate lines do not go away, so you can hardly see the final line. The example needs to erase each line before drawing the next one, by keeping track of where the previous one was. The MovePt field allows you to do this. MovePt must be set to the endpoint of each intermediate line, so you can use MovePt and Origin to erase that line the next time a line is drawn: void fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y) { Drawing = true; // set the Drawing flag Canvas->MoveTo(X, Y); // set pen position Origin = Point(X, Y); // record where the line starts MovePt = Point(X, Y); // record last endpoint } void fastcall TForm1::FormMouseMove(TObject *Sender, TMouseButton Button, TShiftState Shift, int\n\n\n\nX, int Y) { if (Drawing) { Canvas->Pen->Mode = pmNotXor; // use XOR mode to draw/erase Canvas->MoveTo(Origin.x, Originy); // move pen to starting point Canvas->LineTo(MovePt.x, MovePty); // erase old line Working with graphics and multimedia 6-27 W o r http://www.doksihu king with multimedia Forrás: Canvas->MoveTo(Origin.x, Originy); // move pen to starting point again Canvas->LineTo(X, Y); // draw new line } MovePt = Point(X, Y); // record new endpoint Canvas->Pen->Mode = pmCopy; } Now you get a “rubber band” effect when you draw the line. By changing the pen’s mode to pmNotXor, you have it combine your line with the background pixels. When you go to erase the line, you’re actually setting the pixels back to the way they were. By changing the pen mode back to pmCopy (its default value) after drawing the lines, you ensure that the pen is ready to do its final drawing when you release the mouse button. Working with multimedia C++Builder allows you\n\n\n\nto add multimedia components to your applications. To do this, you can use either the TAnimate component on the Win32 page or the TMediaPlayer component on the System page of the Component palette. Use the animate component when you want to add silent video clips to your application. Use the media player component when you want to add audio and/or video clips to an application. For more information on the TAnimate and TMediaPlayer components, see the VCL on-line help. The following topics are discussed in this section:\n• Adding silent video clips to an application\n• Adding audio and/or video clips to an application Adding silent video clips to an application The animation control in C++ Builder allows you to add silent video clips to your application. To add a silent video clip to an application: 1 Double-click the animate icon on the Win32 page of the Component palette. This automatically puts an animation control on the form window in which you want to display the video clip. 2\n\n\n\nUsing the Object Inspector, select the Name property and enter a new name for your animation control. You will use this name when you call the animation control. (Follow the standard rules for naming C++ identifiers) Always work directly with the Object Inspector when setting design time properties and creating event handlers. 6-28 Developer’s Guide Working with multimedia 3 Do one of the following:\n• Select the Common AVI property and choose one of the AVIs available from the drop down list; or\n• Select the FileName property and click the ellipsis () button, choose an AVI file from any available local or network directories and click Open in the Open AVI dialog; or\n• Select the resource of an AVI using the ResName or ResID properties. Use ResHandle to indicate the module that contains the resource identified by ResName or ResID. This loads the AVI file into memory. If you want to display the first frame of the AVI clip on-screen until it is played using the Active\n\n\n\nproperty or the Play method, then set the Open property to true. 4 Set the Repetitions property to the number of times you want to the AVI clip to play. If this value is 0, then the sequence is repeated until the Stop method is called 5 Make any other changes to the animation control settings. For example, if you want to change the first frame displayed when animation control opens, then set the StartFrame property to the desired frame value. 6 Set the Active property to true using the drop down list or write an event handler to run the AVI clip when a specific event takes place at runtime. For example, to activate the AVI clip when a button object is clicked, write the button’s OnClick event specifying that. You may also call the Play method to specify when to play the AVI. Note If you make any changes to the form or any of the components on the form after setting Active to true, the Active property becomes false and you have to reset it to true. Do this either just before runtime\n\n\n\nor at runtime Example of adding silent video clips Suppose you want to display an animated logo as the first screen that appears when your application starts. After the logo finishes playing the screen disappears To run this example, create a new project and save the Unit1.cpp file as Frmlogocpp and save the Project1.bpr file as Logobpr Then: 1 Double-click the animate icon from the Win32 page of the Component palette. 2 Using the Object Inspector, set its Name property to Logo1. 3 Select its FileName property, click the ellipsis () button, choose the cool.avi file from your .ExamplesCoolstuf directory Then click Open in the Open AVI dialog. This loads the cool.avi file into memory 4 Position the animation control box on the form by clicking and dragging it to the top right hand side of the form. 5 Set its Repetitions property to 5. Working with graphics and multimedia 6-29 W o r http://www.doksihu king with multimedia Forrás: 6 Click the form to bring focus to it and set its\n\n\n\nName property to LogoForm1 and its Caption property to Logo Window. Now decrease the height of the form to rightcenter the animation control on it 7 Double-click the form’s OnActivate event and write the following code to run the AVI clip when the form is in focus at runtime: Logo1->Active = true; 8 Double-click the Label icon on the Standard page of the Component palette. Select its Caption property and enter Welcome to Cool Images 4.0 Now select its Font property, click the ellipsis () button and choose Font Style: Bold, Size: 18, Color: Navy from the Font dialog and click OK. Click and drag the label control to center it on the form. 9 Click the animation control to bring focus back to it. Double-click its OnStop event and write the following code to close the form when the AVI file stops: LogoForm1->Close(); 10 Select Run|Run to execute the animated logo window. Adding audio and/or video clips to an application The media player component in C++ Builder allows you to add\n\n\n\naudio and/or video clips to your application. It opens a media device and plays, stops, pauses, records, etc., the audio and/or video clips used by the media device The media device may be hardware or software. To add an audio and/or video clip to an application: 1 Double-click the media player icon on the System page of the Component palette. This automatically put a media player control on the form window in which you want the media feature. 2 Using the Object Inspector, select the Name property and enter a new name for your media player control. You will use this when you call the media player control (Follow the standard rules for naming C++ identifiers.) Always work directly with the Object Inspector when setting design time properties and creating event handlers. 3 Select the DeviceType property and choose the appropriate device type to open using the AutoOpen property or the Open method. (If DeviceType is dtAutoSelect the device type is selected based on the file extension of\n\n\n\nthe media file specified by the FileName property.) For more information on device types and their functions, see Table 6.5 on page 6-31 4 If the device stores its media in a file, specify the name of the media file using the FileName property. Select the FileName property, click the ellipsis () button, and choose a media file from any available local or network directories and click Open in the Open dialog. Otherwise, insert the hardware the media is stored in (disk, cassette, and so on) for the selected media device, at runtime. 6-30 Developer’s Guide Working with multimedia 5 Set the AutoOpen property to true. This way the media player automatically opens the specified device when the form containing the media player control is created at runtime. If AutoOpen is false, the device must be opened with a call to the Open method. 6 Set the AutoEnable property to true to automatically enable or disable the media player buttons as required at runtime; or, double-click the\n\n\n\nEnabledButtons property to set each button to true or false depending on which ones you want to enable or disable. The multimedia device is played, paused, stopped, and so on when the user clicks the corresponding button on the media player component. The device can also be controlled by the methods that correspond to the buttons (Play, Pause, Stop, Next, Previous, and so on). 7 Position the media player control bar on the form by either clicking and dragging it to the appropriate place on the form or by selecting the Align property and choosing the appropriate align position from the drop down list. If you want the media player to be invisible at runtime, set the Visible property to false and control the device by calling the appropriate methods (Play, Pause, Stop, Next, Previous, Step, Back, Start Recording, Eject). 8 Make any other changes to the media player control settings. For example, if the media requires a display window, set the Display property to the control that\n\n\n\ndisplays the media. If the device uses multiple tracks, set the Tracks property to the desired track. Table 6.5 Multimedia device types and their functions Uses a Display Window Device Type Software/Hardware used Plays Uses Tracks dtAVIVideo AVI Video Player for Windows AVI Video files No Yes dtCDAudio CD Audio Player for Windows or a CD Audio Player CD Audio Disks Yes No dtDAT Digital Audio Tape Player Digital Audio Tapes Yes No dtDigitalVideo Digital Video Player for Windows AVI, MPG, MOV files No Yes dtMMMovie MM Movie Player MM film No Yes dtOverlay Overlay device Analog Video No Yes dtScanner Image Scanner N/A for Play (scans images on Record) No No dtSequencer MIDI Sequencer for Windows MIDI files Yes No dtVCR Video Cassette Recorder Video Cassettes No Yes dtWaveAudio Wave Audio Player for Windows WAV files No No Working with graphics and multimedia 6-31 W o r http://www.doksihu king with multimedia Forrás: Example of\n\n\n\nadding audio and/or video clips This example runs an AVI video clip of a multimedia advertisement for C++Builder. To run this example, create a new project and save the Unit1.cpp file to FrmAdcpp and save the Project1.bpr file to MmediaAdbpr Then: 1 Double-click the media player icon on the System page of the Component palette. 2 Using the Object Inspector, set the Name property of the media player to VideoPlayer1. 3 Select its DeviceType property and choose dtAVIVideo from the drop down list. 4 Select its FileName property, click the ellipsis () button, choose the file from your .ExamplesCoolstuf directory Click Open in the Open dialog 5 Set its AutoOpen property to true and its Visible property to false. 6 Double-click the Animate icon from the Win32 page of the Component palette. Set its AutoSize property to false, its Height property to 175 and Width property to 200. Click and drag the animation control to the top left corner of the form 7 Click the media player to bring back\n\n\n\nfocus to it. Select its Display property and choose Animate1 from the drop down list. 8 Click the form to bring focus to it and select its Name property and enter C++ Ad. Now resize the form to the size of the animation control. 9 Double-click the form’s OnActivate event and write the following code to run the AVI video when the form is in focus: Videoplayer1->Play(); 10 Choose Run|Run to execute the AVI video. 6-32 Developer’s Guide Chapter 7 Writing multi-threaded applications Chapter7 The VCL provides several objects that make writing multi-threaded applications easier. Multi-threaded applications are applications that include several simultaneous paths of execution. While using multiple threads requires careful thought, it can enhance your programs by\n• Avoiding bottlenecks. With only one thread, a program must stop all execution when waiting for slow processes such as accessing files on disk, communicating with other machines, or displaying multimedia content.\n\n\n\nThe CPU sits idle until the process completes. With multiple threads, your application can continue execution in separate threads while one thread waits for the results of a slow process.\n• Organizing program behavior. Often, a program’s behavior can be organized into several parallel processes that function independently. Use threads to launch a single section of code simultaneously for each of these parallel cases. Use threads to assign priorities to various program tasks so that you can give more CPU time to more critical tasks.\n• Multiprocessing. If the system running your program has multiple processors, you can improve performance by dividing the work into several threads and letting them run simultaneously on separate processors. Note Not all operating systems implement true multi-processing, even when it is supported by the underlying hardware. For example Windows 95 only simulates multiprocessing, even if the underlying hardware supports it. Defining thread objects For\n\n\n\nmost applications, you can use a thread object to represent an execution thread in your application. Thread objects simplify writing multi-threaded applications by encapsulating the most commonly needed uses of threads. Note Thread objects do not allow you to control the security attributes or stack size of your threads. If you need to control these, you must use the Windows API CreateThread or Writing multi-threaded applications 7-1 D e f ihttp://www.doksihu ning thread objects Forrás: the BeginThread function. Even when using Windows Thread API calls or BeginThread, you can still benefit from some of the thread synchronization objects and methods described in “Coordinating threads” on page 7-6. For more information on using CreateThread or BeginThread, see the Windows online help. To use a thread object in your application, you must create a new descendant of TThread. To create a descendant of TThread, choose File|New from the main menu In the new objects dialog box, select\n\n\n\nThread Object. You are prompted to provide a class name for your new thread object. After you provide the name, C++Builder creates a new .CPP and header file to implement the thread Note Unlike most dialog boxes in the IDE that require a class name, the New Thread Object dialog does not automatically prepend a ‘T’ to the front of the class name you provide. The automatically generated .CPP file contains the skeleton code for your new thread object. If you named your thread TMyThread, it would look like the following: //--------------------------------------------------------------------------#include <vclvcl.h> #pragma hdrstop #include \"Unit2.h\" //-------------------------------------------------------------------------- fastcall TMyThread::TMyThread(bool CreateSuspended): TThread(CreateSuspended) { } //--------------------------------------------------------------------------void fastcall TMyThread::Execute() { // ---- Place thread code here ---}\n\n\n\n//--------------------------------------------------------------------------- You must fill in the code forthe constructor and the Execute method. These steps are described in the following sections. Initializing the thread Use the constructor to initialize your new thread class. This is where you can assign a default priority for your thread and indicate whether it should be freed automatically when it finishes executing. Assigning a default priority Priority indicates how much preference the thread gets when the operating system schedules CPU time among all the threads in your application. Use a high priority thread to handle time critical tasks, and a low priority thread to perform other tasks. 7-2 Developer’s Guide Defining thread objects To indicate the priority of your thread object, set the Priority property. Priority values fall along a seven point scale, as described in Table 7.1: Table 7.1 Warning Thread priorities Value Priority tpIdle The thread executes\n\n\n\nonly when the system is idle. Windows won’t interrupt other threads to execute a thread with tpIdle priority. tpLowest The thread’s priority is two points below normal. tpLower The thread’s priority is one point below normal. tpNormal The thread has normal priority. tpHigher The thread’s priority is one point above normal. tpHighest The thread’s priority is two points above normal. tpTimeCritical The thread gets highest priority. Boosting the thread priority of a CPU intensive operation may “starve” other threads in the application. Only apply priority boosts to threads that spend most of their time waiting for external events. The following code shows the constructor of a low-priority thread that performs background tasks which should not interfere with the rest of the application’s performance: //-------------------------------------------------------------------------- fastcall TMyThread::TMyThread(bool CreateSuspended): TThread(CreateSuspended) {\n\n\n\nPriority = tpIdle; } //--------------------------------------------------------------------------- Indicating when threads are freed Usually, when threads finish their operation, they can simply be freed. In this case, it is easiest to let the thread object free itself. To do this, set the FreeOnTerminate property to true. There are times, however, when the termination of a thread must be coordinated with other threads. For example, you may be waiting for one thread to return a value before performing an action in another thread. To do this, you do not want to free the first thread until the second has received the return value. You can handle this situation by setting FreeOnTerminate to false and then explicitly freeing the first thread from the second. Writing the thread function The Execute method is your thread function. You can think of it as a program that is launched by your application, except that it shares the same process space. Writing the thread function is a little\n\n\n\ntrickier than writing a separate program because you must make sure that you don’t overwrite memory that is used by other threads in your application. On the other hand, because the thread shares the same process Writing multi-threaded applications 7-3 D e f ihttp://www.doksihu ning thread objects Forrás: space with other threads, you can use the shared memory to communicate between threads. Using the main VCL thread When you use objects from the VCL object hierarchy, their properties and methods are not guaranteed to be thread-safe. That is, accessing properties or executing methods may perform some actions that use memory which is not protected from the actions of other threads. Because of this, a main VCL thread is set aside for access of VCL objects. This is the thread that handles all Windows messages received by components in your application. If all objects access their properties and execute their methods within this single thread, you need not worry about your objects\n\n\n\ninterfering with each other. To use the main VCL thread, create a separate routine that performs the required actions. Call this separate routine from within your thread’s Synchronize method. For example: void fastcall TMyThread::PushTheButton(void) { Button1->Click(); } ƒ void fastcall TMyThread::Execute() { ƒ Synchronize((TThreadMethod)PushTheButton); ƒ } Synchronize waits for the main VCL thread to enter the message loop and then executes the passed method. Note Because Synchronize uses the message loop, it does not work in console applications. You must use other mechanisms, such as critical sections, to protect access to VCL objects in console applications. You do not always need to use the main VCL thread. Some objects are thread-aware Omitting the use of the Synchronize method when you know an object’s methods are thread-safe will improve performance because you don’t need to wait for the VCL thread to enter its message loop. You do not need to use the\n\n\n\nSynchronize method in the following situations:\n• Data access components are thread-safe as follows: For BDE-enabled datasets, each thread must have its own database session component. The one exception to this is when you are using Access drivers, which are built using a Microsoft library that is not thread-safe. ADO and InterbaseExpress components are thread-safe When using data access components, you must still wrap all calls that involve data-aware controls in the Synchronize method. Thus, for example, you need to synchronize calls that link a data control to a dataset by setting the DataSet property of the data source object, but you don’t need to synchronize to access the data in a field of the dataset. For more information about using database sessions with threads in BDE-enabled applications, see “Managing multiple sessions” on page 17-16. 7-4 Developer’s Guide Defining thread objects\n• Graphics objects are thread-safe. You do not need to use the main VCL\n\n\n\nthread to access TFont, TPen, TBrush, TBitmap, TMetafile, or TIcon. Canvas objects can be used outside the Synchronize method by locking them (see “Locking objects” on page 7-6).\n• While list objects are not thread-safe, you can use a thread-safe version, TThreadList, instead of TList. Using thread-local variables Your Execute method and any of the routines it calls have their own local variables, just like any other C++ routines. These routines also can access any global variables In fact, global variables provide a powerful mechanism for communicating between threads. Sometimes, however, you may want to use variables that are global to all the routines running in your thread, but not shared with other instances of the same thread class. You can do this by declaring thread-local variables. Make a variable thread-local by adding the thread modifier to the variable declaration. For example, int thread x; declares an integer type variable that is private to each thread in the\n\n\n\napplication, but global within each thread. The thread modifier can only be used for global (file-scope) and static variables. Pointer and Function variables can’t be thread variables. Types that use copy-onwrite semantics, such as AnsiStrings don’t work as thread variables either A program element that requires runtime initialization or runtime finalization cannot be declared to be a thread type. The following declarations require runtime initialization and are therefore illegal. int f( ); int thread x = f( ); // illegal Instantiation of a class with a user-defined constructor or destructor requires runtime initialization and is therefore illegal: class X { X( ); ~X( ); }; X thread myclass; // illegal Checking for termination by other threads Your thread begins running when the Execute method is called (see “Executing thread objects” on page 7-10) and continues until Execute finishes. This reflects the model that the thread performs a specific task, and then stops\n\n\n\nwhen it is finished. Sometimes, however, an application needs a thread to execute until some external criterion is satisfied. You can allow other threads to signal that it is time for your thread to finish executing by checking the Terminated property. When another thread tries to terminate your thread, it calls the Terminate method. Terminate sets your thread’s Writing multi-threaded applications 7-5 C o o http://www.doksihu rdinating threads Forrás: Terminated property to true. It is up to your Execute method to implement the Terminate method by checking and responding to the Terminated property. The following example shows one way to do this: void fastcall TMyThread::Execute() { while (!Terminated) PerformSomeTask(); } Writing clean-up code You can centralize the code that cleans up when your thread finishes executing. Just before a thread shuts down, an OnTerminate event occurs. Put any clean-up code in the OnTerminate event handler to ensure that it is always executed,\n\n\n\nno matter what execution path the Execute method follows. The OnTerminate event handler is not run as part of your thread. Instead, it is run in the context of the main VCL thread of your application. This has two implications:\n• You can’t use any thread-local variables in an OnTerminate event handler (unless you want the main VCL thread values).\n• You can safely access any components and VCL objects from the OnTerminate event handler without worrying about clashing with other threads. For more information about the main VCL thread, see “Using the main VCL thread” on page 7-4. Coordinating threads When writing the code that runs when your thread is executed, you must consider the behavior of other threads that may be executing simultaneously. In particular, care must be taken to avoid two threads trying to use the same global object or variable at the same time. In addition, the code in one thread can depend on the results of tasks performed by other threads. Avoiding\n\n\n\nsimultaneous access To avoid clashing with other threads when accessing global objects or variables, you may need to block the execution of other threads until your thread code has finished an operation. Be careful not to block other execution threads unnecessarily Doing so can cause performance to degrade seriously and negate most of the advantages of using multiple threads. Locking objects Some objects have built-in locking that prevents the execution of other threads from using that object instance. 7-6 Developer’s Guide Coordinating threads For example, canvas objects (TCanvas and descendants) have a Lock method that prevents other threads from accessing the canvas until the Unlock method is called. The VCL also includes a thread-safe list object, TThreadList. Calling TThreadList::LockList returns the list object while also blocking other execution threads from using the list until the UnlockList method is called. Calls to TCanvas::Lock or TThreadList::LockList can be\n\n\n\nsafely nested. The lock is not released until the last locking call is matched with a corresponding unlock call in the same thread. Using critical sections If objects do not provide built-in locking, you can use a critical section. Critical sections work like gates that allow only a single thread to enter at a time. To use a critical section, create a global instance of TCriticalSection. TCriticalSection has two methods, Acquire (which blocks other threads from executing the section) and Release (which removes the block). Each critical section is associated with the global memory you want to protect. Every thread that accesses that global memory should first use the Acquire method to ensure that no other thread is using it. When finished, threads call the Release method so that other threads can access the global memory by calling Acquire. Warning Critical sections only work if every thread uses them to access the associated global memory. Threads that ignore the critical section and\n\n\n\naccess the global memory without calling Acquire can introduce problems of simultaneous access. For example, consider an application that has a global critical section variable, pLockXY, that blocks access to global variables X and Y. Any thread that uses X or Y must surround that use with calls to the critical section such as the following: pLockXY->Acquire(); // lock out other threads try { Y = sin(X); } finally { pLockXY->Release(); } Using the multi-read exclusive-write synchronizer When you use critical sections to protect global memory, only one thread can use the memory at a time. This can be more protection than you need, especially if you have an object or variable that must be read often but to which you very seldom write. There is no danger in multiple threads reading the same memory simultaneously, as long as no thread is writing to it. When you have some global memory that is read often, but to which threads occasionally write, you can protect it using\n\n\n\nTMultiReadExclusiveWriteSynchronizer. This object acts like a critical section, but one which allows multiple threads to read the memory it protects as long as no thread is writing to it. Threads must have exclusive access to write to memory protected by TMultiReadExclusiveWriteSynchronizer. Writing multi-threaded applications 7-7 C o o http://www.doksihu rdinating threads Forrás: To use a multi-read exclusive-write synchronizer, create a global instance of TMultiReadExclusiveWriteSynchronizer that is associated with the global memory you want to protect. Every thread that reads from this memory must first call the BeginRead method. BeginRead ensures that no other thread is currently writing to the memory. When a thread finishes reading the protected memory, it calls the EndRead method. Any thread that writes to the protected memory must call BeginWrite first BeginWrite ensures that no other thread is currently reading or writing to the memory. When a thread finishes writing to\n\n\n\nthe protected memory, it calls the EndWrite method, so that threads waiting to read the memory can begin. Warning Like critical sections, the multi-read exclusive-write synchronizer only works if every thread uses it to access the associated global memory. Threads that ignore the synchronizer and access the global memory without calling BeginRead or BeginWrite introduce problems of simultaneous access. Other techniques for sharing memory When using objects in the VCL, use the main VCL thread to execute your code. Using the main VCL thread ensures that the object does not indirectly access any memory that is also used by VCL objects in other threads. See “Using the main VCL thread” on page 7-4 for more information on the main VCL thread. If the global memory does not need to be shared by multiple threads, consider using thread-local variables instead of global variables. By using thread-local variables, your thread does not need to wait for or lock out any other threads. See\n\n\n\n“Using thread-local variables” on page 7-5 for more information about thread-local variables. Waiting for other threads If your thread must wait for another thread to finish some task, you can tell your thread to temporarily suspend execution. You can either wait for another thread to completely finish executing, or you can wait for another thread to signal that it has completed a task. Waiting for a thread to finish executing To wait for another thread to finish executing, use the WaitFor method of that other thread. WaitFor doesn’t return until the other thread terminates, either by finishing its own Execute method or by terminating due to an exception. For example, the following code waits until another thread fills a thread list object before accessing the objects in the list: if (pListFillingThread->WaitFor()) { for (TList *pList = ThreadList1->LockList(), int i = 0; i < pList->Count; i++) ProcessItem(pList->Items[i]); ThreadList1->UnlockList(); } In the\n\n\n\nprevious example, the list items were only accessed when the WaitFor method indicated that the list was successfully filled. This return value must be assigned by 7-8 Developer’s Guide Coordinating threads the Execute method of the thread that was waited for. However, because threads that call WaitFor want to know the result of thread execution, not code that calls Execute, the Execute method does not return any value. Instead, the Execute method sets the ReturnValue property. ReturnValue is then returned by the WaitFor method when it is called by other threads. Return values are integers Your application determines their meaning. Waiting for a task to be completed Sometimes, you need to wait for a thread to finish some operation rather than waiting for a particular thread to complete execution. To do this, use an event object Event objects (TEvent) should be created with global scope so that they can act like signals that are visible to all threads. When a thread completes an\n\n\n\noperation that other threads depend on, it calls TEvent::SetEvent. SetEvent turns on the signal, so any other thread that checks will know that the operation has completed. To turn off the signal, use the ResetEvent method. For example, consider a situation where you must wait for several threads to complete their execution rather than a single thread. Because you don’t know which thread will finish last, you can’t simply use the WaitFor method of one of the threads. Instead, you can have each thread increment a counter when it is finished, and have the last thread signal that they are all done by setting an event. The following code shows the end of the OnTerminate event handler for all of the threads that must complete. CounterGuard is a global critical section object that prevents multiple threads from using the counter at the same time. Counter is a global variable that counts the number of threads that have completed. void fastcall TDataModule::TaskThreadTerminate(TObject\n\n\n\n*Sender) { ƒ CounterGuard->Acquire(); // lock the counter if (--Counter == 0) // decrement the global counter Event1->SetEvent(); // signal if this is the last thread CounterGuard->Release(); // release the lock on the counter } The main thread initializes the Counter variable, launches the task threads, and waits for the signal that they are all done by calling the WaitFor method. WaitFor waits for a specified time period for the signal to be set, and returns one of the values from Table 7.2 Table 7.2 WaitFor return values Value Meaning wrSignaled The signal of the event was set. wrTimeout The specified time elapsed without the signal being set. wrAbandoned The event object was destroyed before the timeout period elapsed. wrError An error occurred while waiting. Writing multi-threaded applications 7-9 E x e chttp://www.doksihu uting thread objects Forrás: The following shows how the main thread launches the task threads and then resumes when they have all\n\n\n\ncompleted: Event1->ResetEvent(); // clear the event before launching the threads for (i = 0; i < Counter; i++) new TaskThread(false); // create and launch task threads if (Event1->WaitFor(20000) != wrSignaled) throw Exception; // now continue with the main thread, All task threads have finished Note If you do not want to stop waiting for an event after a specified time period, pass the WaitFor method a parameter value of INFINITE. Be careful when using INFINITE, because your thread will hang if the anticipated signal is never received. Executing thread objects Once you have implemented a thread class by giving it an Execute method, you can use it in your application to launch the code in the Execute method. To use a thread, first create an instance of the thread class. You can create a thread instance that starts running immediately, or you can create your thread in a suspended state so that it only begins when you call the Resume method. To create a thread so that it starts\n\n\n\nup immediately, set the constructor’s CreateSuspended parameter to false. For example, the following line creates a thread and starts its execution: TMyThread *SecondProcess = new TMyThread(false); // create and run the thread Warning Do not create too many threads in your application. The overhead in managing multiple threads can impact performance. The recommended limit is 16 threads per process on single processor systems. This limit assumes that most of those threads are waiting for external events. If all threads are active, you will want to use fewer You can create multiple instances of the same thread type to execute parallel code. For example, you can launch a new instance of a thread in response to some user action, allowing each thread to perform the expected response. Overriding the default priority When the amount of CPU time the thread should receive is implicit in the thread’s task, its priority is set in the constructor. This is described in “Initializing the\n\n\n\nthread” on page 7-2. However, if the thread priority varies depending on when the thread is executed, create the thread in a suspended state, set the priority, and then start the thread running: TMyThread *SecondProcess = new TMyThread(true); // create but don’t run SecondProcess->Priority = tpLower; // set the priority lower than normal SecondProcess->Resume(); // now run the thread 7-10 Developer’s Guide Debugging multi-threaded applications Starting and stopping threads A thread can be started and stopped any number of times before it finishes executing. To stop a thread temporarily, call its Suspend method. When it is safe for the thread to resume, call its Resume method. Suspend increases an internal counter, so you can nest calls to Suspend and Resume. The thread does not resume execution until all suspensions have been matched by a call to Resume. You can request that a thread end execution prematurely by calling the Terminate method. Terminate sets the\n\n\n\nthread’s Terminated property to true If you have implemented the Execute method properly, it checks the Terminated property periodically, and stops execution when Terminated is true. Debugging multi-threaded applications When debugging multi-threaded applications, it can be confusing trying to keep track of the status of all the threads that are executing simultaneously, or even to determine which thread is executing when you stop at a breakpoint. You can use the Thread Status box to help you keep track of and manipulate all the threads in your application. To display the Thread status box, choose View|Threads from the main menu. When a debug event occurs (breakpoint, exception, paused), the thread status view indicates the status of each thread. Right-click the Thread Status box to access commands that locate the corresponding source location or make a different thread current. When a thread is marked as current, the next step or run operation is relative to that thread. The Thread\n\n\n\nStatus box lists all your application’s execution threads by their thread ID. If you are using thread objects, the thread ID is the value of the ThreadID property. If you are not using thread objects, the thread ID for each thread is returned by the call to CreateThread or BeginThread. For additional details on the Thread Status box, see online Help. Writing multi-threaded applications 7-11 7-12 Developer’s Guide Chapter 8 Exception handling Chapter8 C++Builder supports C++ exception handling, C-based structured exception handling, and VCL exception handling. Note that the examples provided in this chapter for C++ exception handling and structured exception handling can be compiled and run successfully from the command line using bcc32.exe rather than from the IDE You would use C++ exception handling if your application calls standard C++ routines and objects. VCL exception handling can occur from within the IDE. In fact, although C++Builder supports using C++ and\n\n\n\nC-based structured exception handling, C++Builder and the VCL make it possible for you to develop applications that include built-in exception handling routines that throw exceptions automatically when something goes wrong. C++ exception handling Exceptions are exceptional conditions that require special handling and can include errors that occur at runtime, such as divide by zero, and the exhaustion of free store. Exception handling provides a standard way of dealing with errors, discovering both anticipated and unanticipated problems, and enables developers to recognize, track down, and fix bugs. ANSI requirements for exception handling C++Builder exception handling is consistent with the proposed ANSI/ISO C++ working paper specification. Throwing an exception allows you to gather information at the throw point that could be useful for diagnosing its cause. You can use an exception handler to specify actions to take before terminating the program. Only synchronous exceptions (where\n\n\n\nthe cause of failure is generated from within the program) are handled. An event (generated from outside the program) such as pressing Ctrl+C is not considered to be an exception. Exception handling 8-1 C + + http://www.doksihu exception handling Forrás: The C++ language specifies that all exceptions should be thrown within a try-block. This block is followed by one or more catch blocks that identify and handle the errors generated in the try-block. Exception handling syntax Exception handling requires the use of three keywords: try, catch, and throw. Programs prepare to catch exceptions by trying statements that might generate a special condition. When a C++ program throws an exception, you can transfer or throw control to another part of the program called the exception handler that handles that type of exception. The handler is said to catch the exception A program throws an exception by executing a throw statement. The throw statement generally occurs within a function: throw\n\n\n\n“overflow”; As in the example, the statement throws an object that describes the type of exception, in this case, an arithmetic overflow. Another part of the program can catch the thrown exception object and handle it accordingly. To use exception handling, surround the code with a try/catch construct. The syntax for a try/catch construct is as follows: try-block: try compound-statement handler-list handler-list: handler handler-listopt handler: catch (exception-declaration) compound-statement exception declaration: type-specifier-list declarator type-specifier-list abstract-declarator type-specifier-list throw-expression: throw assignment-expressionopt Note The try, catch, and throw keywords are not allowed in C programs. A try-block specified by try must be followed immediately by the handler specified by catch. The try-block is a statement that specifies the flow of control as the program executes. If an exception is thrown in the try-block, program control is transferred to\n\n\n\nthe appropriate exception handler. The handler is a block of code designed to handle the exception. The C++ language requires at least one handler immediately after a try-block. The program should include a handler for each exception that the program can generate. Exception declarations Although C++ allows an exception to be of any type, it is useful to make exceptions objects. An exception object is treated like any other object The exception carries 8-2 Developer’s Guide C++ exception handling information from the point where the exception is thrown to the point where the exception is caught. This is information that the application user will want to know when the program encounters an anomaly at runtime. Predefined exceptions, specified by the C++ language, are documented in the Library Reference in online Help. Throwing an exception A block of code in which an exception can occur must be prefixed by the keyword try and enclosed by braces. This indicates that the program\n\n\n\nis prepared to test for exceptions If an exception occurs, the program flow is interrupted and the following occur:\n• The program searches for a matching handler\n• If a handler is found, the stack is unwound to that point\n• Program control is transferred to the handler\n• If no handler is found, you can call set terminate() to provide a termination handler; otherwise, the program calls the terminate function If no exceptions are thrown, the program executes normally. When an exception occurs, the throw expression initializes a temporary object of type T (to match the type of argument arg) used in throw(T arg). Other copies can be generated as required by the compiler. Consequently, it can be useful to define a copy constructor for the exception object when you have a class that contains subobjects. (You would not need to define the copy constructor for a bitwise copy) Examples You can see various ways to throw exceptions by reviewing the following examples. Note The examples\n\n\n\nprovided can be compiled and run successfully from the command line using bcc32.exe rather than from the IDE Example 1 The following example passes an Out object to a handler. /* Program results: duck */ #include <stdio.h> bool pass; class Out{}; void festival(bool firsttime){ if(firsttime) throw Out(); } int main() { try { pass = true; festival(true); } catch(Out& e){ pass = false; } return pass ? (puts(\"luck\"),0) : (puts(\"duck\"),1); } Exception handling 8-3 C + + http://www.doksihu exception handling Forrás: Example 2 The following example simply throws the last exception again. An exception must currently exist. /* Program results: got out of test */ #include <stdio.h> bool pass; class Out{}; void festival(bool firsttime){ if(firsttime) throw Out(); } void test() { try { festival(true); } catch(Out& e){ pass = false; throw; } } int main() { try { test(); } catch(Out& e){ pass = true; } return pass ? (puts(\"got out of\n\n\n\ntest\"),0) : (puts(\"still have test\"),1); } The following example calls the terminate function if no exception exists: /* Program results: * Nobody threw an exception */ #include <except.h> #include <process.h> #include <stdio.h> bool pass; class Out{}; void my terminate(){ puts(\"* Nobody threw an exception \"); exit(1); } void festival(bool firsttime){ if(firsttime) throw Out(); } void test() { try { festival(false); } catch(Out& e){ pass = false; } throw; // cant rethrow an exception that never happened! } int main() { set terminate(my terminate); try { test(); } catch(Out& e){ pass = true; } return pass ? (puts(\"got out of test\"),0) : (puts(\"still have test\"),1); } 8-4 Developer’s Guide C++ exception handling Example 3 The following example specifies a list of exceptions that festival and test can throw. No other exceptions can propagate from festival. /* Program results: test handled the exception */\n\n\n\n#include <stdio.h> bool pass; class Out{}; void festival(bool firsttime) throw(Out) // festival only throws Out exceptions. { if(firsttime) throw Out(); } void test() throw() // test throws no exceptions { try { festival(true); } catch(Out& e){ pass = true; } } int main() { pass = false; test(); return pass ? (puts(\"test handled the exception\"),0) : (puts(\"no exception happened\") ,1); } If festival generates an exception other than Out, it is considered an unexpected exception and program control is transferred to the unexpected function as shown in example 4. Example 4 The following example shows that test should not throw any exceptions. If any function (for example, operator new) in the body of test throws an exception, the exception should be caught and handled within the body of test. Otherwise, the exception is a violation of the exception specification for test. You can call set unexpected() to set a different handler; otherwise, the unexpected\n\n\n\nfunction is called. /* Program results: * test failed */ #include <except.h> #include <process.h> #include <stdio.h> bool pass; class Out{}; void my unexpected(){ puts(\"* test failed \"); exit(1); } void festival(bool firsttime) throw(Out) // festival only throws Out exceptions. { if(firsttime) throw Out(); } void test() throw() // test throws no exceptions Exception handling 8-5 C + + http://www.doksihu exception handling Forrás: { try { festival(true); } catch(Out& e){ pass = true; throw; } // rethrow Out exception - error } int main() { set unexpected(my unexpected); pass = false; test(); return pass ? (puts(\"test handled the exception\"),0) : (puts(\"no exception happened\") ,1); } When an exception occurs, the throw expression initializes a temporary object of type T (to match the type of argument arg) used in throw(T arg). Other copies can be generated by the compiler. Consequently, it can be useful to define a copy\n\n\n\nconstructor for the exception object as shown in the following example: /* Program results: throwing a festival made a festival copied a festival destructed a festival caught a festival destructed a festival */ #include <stdio.h> class festival { public: festival() { puts(\"made a festival\"); } festival(const festival&){ puts(\"copied a festival\"); } ~festival() { puts(\"destructed a festival\"); } }; int main() { try { puts(\"throwing a festival\"); throw(festival()); } catch(festival&){ puts(\"caught a festival\" ); } return 0; } Handling an exception The exception handler is specified by the catch keyword which is placed immediately after the try-block. The keyword catch can also occur immediately after another catch block. Every exception thrown by a program must be caught and processed by the exception handler. The handler catches an exception when its type matches (or can be converted to) the type in the catch statement.\n\n\n\nOnce a type match is made, program control is transferred to the handler and the stack is unwound. The handler specifies what actions to take to deal with the program anomaly. 8-6 Developer’s Guide C++ exception handling After the handler is executed, the program continues at the point after the last handler for the current try-block. No other handlers are evaluated for the current exception. A goto statement can be used to transfer program control out of a handler If the program fails to provide an exception handler for a thrown exception, the program terminates. Note The examples provided can be compiled and run successfully from the command line using bcc32.exe rather than from the IDE Example 1 /* Program results: threw a Spring Festival threw a Harvest Festival */ #include <stdio.h> class festival{}; class Harvest : public festival{}; class Spring: public festival{}; void ToHaveFun(int i) { if(i==1) throw(Harvest() ); else throw(Spring()); } int main() { try {\n\n\n\nToHaveFun(0); } catch(const Harvest&) { puts(\"threw a Harvest Festival\"); } catch(const Spring&){ puts(\"threw a Spring Festival\" ); } try { ToHaveFun(1); } catch(const Harvest&) { puts(\"threw a Harvest Festival\"); } catch(const Spring&){ puts(\"threw a Spring Festival\" ); } return 0; } Example 2 The following example shows that when you catch an exception and that exception is part of a class hierarchy, you need to start with the most derived class. /* Program results: threw a festival threw a harvest festival threw a spring festival threw a festival (what kind??!!) threw a festival (what kind?!!!) */ #include <stdio.h> class festival{}; class harvest : public festival{}; class spring: public festival{}; Exception handling 8-7 C + + http://www.doksihu exception handling Forrás: void ToHaveFun(int i) { if (i==1) throw(harvest() ); else if(i==2) throw(spring()); else throw(festival() ); } int main() { /* These catch\n\n\n\nstatements are in a sensible order:/ try { ToHaveFun(0); } catch(const harvest& ){ puts(\"threw a harvest festival\"); } catch(const spring&){ puts(\"threw a spring festival\" ); } catch(const festival& ){ puts(\"threw a festival\" ); } try { ToHaveFun(1); } catch(const harvest& ){ puts(\"threw a harvest festival\"); } catch(const spring&){ puts(\"threw a spring festival\" ); } catch(const festival& ){ puts(\"threw a festival\" ); } try { ToHaveFun(2); } catch(const harvest& ){ puts(\"threw a harvest festival\"); } catch(const spring&){ puts(\"threw a spring festival\" ); } catch(const festival& ){ puts(\"threw a festival\" ); } /* But, if you catch the base class Object first, you dont get a chance to see what type actually got thrown: */ try { ToHaveFun(1); } catch(const festival& ){ puts(\"threw a festival (what kind??!!)\"); } catch(const harvest& ){\n\n\n\nputs(\"threw a harvest festival\" ); } catch(const spring&){ puts(\"threw a spring festival\" ); } try { ToHaveFun(2); } catch(const festival& ){ puts(\"threw a festival (what kind?!!!)\"); } catch(const harvest& ){ puts(\"threw a harvest festival\" ); } catch(const spring&){ puts(\"threw a spring festival\" ); } return 0; } Example 3 In the following example, the catch ( . ) statement handles any exception, regardless of type. This statement is the only handler in the try-block /* Program results: test handled the exception */ #include <stdio.h> bool pass; class Out{}; void festival(bool firsttime) throw(Out) // festival only throws Out exceptions. { if(firsttime) throw Out(); } 8-8 Developer’s Guide C++ exception handling void test() throw() // test throws no exceptions { try { festival(true); } catch(.){ pass = true; } } int main() { pass = false; test(); return pass ? (puts(\"test handled the\n\n\n\nexception\"),0) : (puts(\"no exception happened\") ,1); } Exception specifications C++ provides a feature called exception specification that lets you list within a declaration what exceptions a function might throw. This exception specification is used as a suffix of the function declaration and has the following syntax: exception-specification: throw (type-id-listopt) type-id-list: type-id type-id-list, type-id The function suffix is not part of the function’s type. Consequently, a pointer to a function is not affected by the function’s exception specification. Such a pointer checks only the function’s return and argument types. Therefore, the following is legal: void void void fptr fptr f2(void) throw(); // Should not throw exceptions f3(void) throw (BETA); // Should only throw BETA objects (* fptr)(); // Pointer to a function returning void = f2; = f3; Be careful when overriding virtual functions. Because the exception specification is not considered part of\n\n\n\nthe function type, you can violate the program design. Example 1 In the following example, the derived class BETA::vfunc is defined so that it does not throw any exceptionsa departure from the original function declaration. class ALPHA { public: struct ALPHA ERR {}; virtual void vfunc(void) throw (ALPHA ERR) {} // Exception specification }; class BETA : public ALPHA { void vfunc(void) throw() {} // Exception specification is changed }; Exception handling 8-9 C + + http://www.doksihu exception handling Forrás: The following examples are functions with exception specifications. void f1(); // The function can throw any exception void f2() throw(); // Should not throw any exceptions void f3() throw( A, B* ); // Can throw exceptions publicly derived from A, // or a pointer to publicly derived B The definition and all declarations of such a function must have an exception specification containing the same set of type-ids. If a function throws an exception not listed in its\n\n\n\nspecification, the program will call unexpected. Constructors and destructors in exception handling Class constructors can throw exceptions if they cannot successfully construct an object. When you throw objects by value and an exception is thrown, the copy constructor is called for the exception. The copy constructor initializes a temporary object at the throw point. The program may also generate other copies If a constructor throws an exception, that object’s destructor is not necessarily called. Destructors are called only for the base classes and for those objects that were fully constructed inside the classes since entering the try-block. The process of calling destructors for objects constructed on the path from a try-block to a throw expression is called stack unwinding. If a destructor causes an exception to be raised during stack unwinding and does not handle it, terminate is called. Destructors are called by default, but you can switch off the default by using the\n\n\n\n-xdcompiler option. Unhandled exceptions If an exception is thrown and no event handler is found, the program calls the terminate function. This example shows what can happen when the program encounters an unhandled exception. /* Program results: * Nobody caught the exception */ #include <except.h> #include <process.h> #include <stdio.h> bool pass; class Out{}; void my terminate(){ puts(\"* Nobody caught the exception \"); abort(); } void festival(bool firsttime){ if(firsttime) throw Out(); } void test() { festival(true); } 8-10 Developer’s Guide Structured exceptions under Win32 int main() { set terminate(my terminate); test(); // test throws exception, but no handler. return pass ? (puts(\"got out of test\"),0) : (puts(\"still in test\"),1); } Setting exception handling options Following are the exception handling options in the C++Builder compiler. Table 8.1 Exception handling compiler options Command-line switch Description \n\n\n\n-x Enable C++ exception handling (On by default) -xd Enable destructor cleanup. Calls destructors for all automatically declared objects between the scope of the catch and throw statements when an exception is thrown. (Advanced option–on by default) -xp Enable exception location information. Makes available runtime identification of exceptions by providing line numbers in the source code at the exception location. This lets the program query the file and line number where a C++ exception occurred. (Advanced option) Structured exceptions under Win32 Win32 supports C-based structured exception handling that is similar to C++ exceptions. There are some key differences, however, that require careful use when they are mixed with C++ code that is exception aware. Keep the following in mind when using structured exception handling in C++Builder applications:\n• C-structured exceptions can be used in C++ programs.\n• C++ exceptions cannot be used in a C program because C++ exceptions\n\n\n\nrequire that their handler be specified by the catch keyword, and catch is not allowed in a C program.\n• An exception generated by a call to the RaiseException function is handled by a try/ except (C++) or try/ except (C) block. (You can also use try/ finally or try/ finally blocks. See “Syntax of structured exceptions” on page 8-12) All handlers of try/catch blocks are ignored when RaiseException is called.\n• Exceptions that are not handled by the application don’t result in a call to terminate(), but are instead passed to the operating system (in general, the end result is termination of the process).\n• Exception handlers do not receive a copy of the exception object, unless they request it. Exception handling 8-11 S t r uhttp://www.doksihu ctured exceptions under Win32 Forrás: You can use the following C exception helper functions in C or C++ programs:\n• \n• \n• \n• GetExceptionCode GetExceptionInformation SetUnhandledExceptionFilter\n\n\n\nUnhandledExceptionFilter C++Builder does not restrict the use of UnhandledExceptionFilter function to the except filter of try/ except or try/ except blocks. However, program behavior is undefined when this function is called outside of a try/ except or try/ except block. Syntax of structured exceptions In a C program, the ANSI-compatible keywords used to implement structured exceptions are except, finally, and try. Note The try keyword can only appear in C programs. If you want to write portable code, do not use structured exception handling in your C++ programs. try-except exception handling syntax For try-except exception handling, the syntax is as follows: try-block: try compound-statement (in a C module) try compound-statement (in a C++ module) handler: except (expression) compound-statement try-finally termination syntax For try-finally termination, the syntax is as follows: try-block: try compound-statement (in a C module) try compound-statement (in a\n\n\n\nC++ module) termination: finally compound-statement Handling structured exceptions Structured exceptions can be handled using an extension of C++ exception handling: try { foo(); } except( expr ) { // handler here } 8-12 Developer’s Guide Structured exceptions under Win32 expr is an expression that evaluates to one of three values: Value Description EXCEPTION CONTINUE SEARCH (0) The handler is not entered, and the OS continues searching for an exception handler. EXCEPTION CONTINUE EXECUTION (-1) Continue execution at the point of the exception. EXCEPTION EXECUTE HANDLER (1) Enter the exception handler. If the code was compiled with destructor cleanup enabled (-xd, on by default), all destructors for local objects created between the point of the exception and the exception handler are called when the stack is unwound. Stack unwinding is completed before entering the handler. Win32 provides two functions that can be used to query information about the active\n\n\n\nexception: GetExceptionCode() and GetExceptionInformation(). If you want to call a function as part of the “filter” expression above, these functions must be called from within the context of the except() directly: #include <Windows.h> #include <excpt.h> int filter func(EXCEPTION POINTERS *); . EXCEPTION POINTERS *xp = 0; try { foo(); } except(filter func(xp = GetExceptionInformation())) { //. } Or, if you prefer using the comma operator to assignments nested in function calls, see the following example: except((xp = GetExceptionInformation()), filter func(xp)) Exception filters A filter expression can invoke a filter function but the filter function cannot call GetExceptionInformation. You can pass the return value of GetExceptionInformation as a parameter to a filter function. To pass the EXCEPTION POINTERS information to an exception handler, the filter expression or filter function must copy the pointer or data from GetExceptionInformation to a location\n\n\n\nwhere the handler can later access it. In the case of nested try-except statements, each statement’s filter expression is evaluated until it locates EXCEPTION EXECUTE HANDLER or EXCEPTION CONTINUE EXECUTION. A filter expression can invoke GetExceptionInformation to get exception information. As long as GetExceptionInformation or GetExceptionCode is called directly in the expression provided to except, you can use a function to determine what to do Exception handling 8-13 S t r uhttp://www.doksihu ctured exceptions under Win32 Forrás: with an exception rather than trying to create a complex C++ expression. Almost all of the information needed to handle an exception can be extracted from the result of GetExceptionInformation(). GetExceptionInformation() returns a pointer to an EXCEPTION POINTERS structure: struct EXCEPTION POINTERS { EXCEPTION RECORD *ExceptionRecord; CONTEXT *Context; }; EXCEPTION RECORD contains the machine-independent state: struct EXCEPTION RECORD { DWORD\n\n\n\nExceptionCode; DWORD ExceptionFlags; struct EXCEPTION RECORD *ExceptionRecord; void *ExceptionAddress; DWORD NumberParameters; DWORD ExceptionInformation[EXCEPTION MAXIMUM PARAMETERS]; }; Typically, the filter function looks at the information in the ExceptionRecord to decide how to respond. Sometimes more specific information is needed (especially if the action to take is EXCEPTION CONTINUE EXECUTION: if nothing is done, the code that caused the exception would be executed again). For this situation, the other field of the EXCEPTION POINTERS structure provides the processor state at the time of the exception. If this structure is modified and the filter returns EXCEPTION CONTINUE EXCEPTION, it is used to set the state of the thread before continuing with execution. For example: static int xfilter(EXCEPTION POINTERS *xp) { int rc; EXCEPTION RECORD *xr = xp->ExceptionRecord; CONTEXT *xc = xp->Context; switch (xr->ExceptionCode) { case EXCEPTION BREAKPOINT: // whoops, someone\n\n\n\nleft an embedded breakpoint. // just step over it (1 byte on x86) ++xc->Eip; rc = EXCEPTION CONTINUE EXECUTION; break; case EXCEPTION ACCESS VIOLATION: rc = EXCEPTION EXECUTE HANDLER; break; default: // give up rc = EXCEPTION CONTINUE SEARCH; break; }; 8-14 Developer’s Guide Structured exceptions under Win32 return rc; } . EXCEPTION POINTERS *xp; try { func(); } except(xfilter(xp = GetExceptionInformation())) { abort(); } Mixing C++ with structured exceptions You need to be aware of a few issues when using structured exceptions in C++ programs. First, although C++Builder implements C++ exceptions with Win32 structured exceptions, C++ exceptions are transparent to an except block. A try block can be followed by either exactly one except block or at least one catch block. Attempting to mix the two causes a compiler error Code that needs to handle both types of exceptions should simply be nested inside two try blocks: try { EXCEPTION POINTERS *xp; try { func(); } \n\n\n\nexcept(xfilter(xp = GetExceptionInformation())) { //. } } catch (.) { //. } A function’s throw() specification does not affect the behavior of a program with regard to a Win32 exception. Also, an unhandled exception is eventually handled by the operating system (if a debugger doesn’t handle it first), unlike a C++ program that calls terminate(). Any module compiled with the -xd compiler option (on by default) will invoke destructors for all objects with auto storage. Stack unwinding occurs from the point where the exception is thrown to the point where the exception is caught. Exception handling 8-15 S t r uhttp://www.doksihu ctured exceptions under Win32 Forrás: C-based exceptions in C++ program example /* Program results: Another exception: Caught a C-based exception. Caught C++ exception[Hardware error: Divide by 0] C++ allows finally too! */ #include <stdio.h> #include <string.h> #include <windows.h> class Exception { public: Exception(char* s =\n\n\n\n\"Unknown\"){ what = strdup(s); Exception(const Exception& e ){ what = strdup(e.what); ~Exception() { delete[] what; char* msg() const { return what; private: char* what; }; int main() { float e, f, g; try { try { f = 1.0; g = 0.0; try { puts(\"Another exception:\"); e = f / g; } except(EXCEPTION EXECUTE HANDLER) { puts(\"Caught a C-based exception.\"); throw(Exception(\"Hardware error: Divide by 0\")); } } catch(const Exception& e) { printf(\"Caught C++ Exception: %s : \", e.msg()); } } finally { puts(\"C++ allows finally too!\"); } return e; } 8-16 Developer’s Guide } } } } Structured exceptions under Win32 Defining exceptions Raising a Win32 exception that is handled within the same program does not generally make much sense: C++ exceptions can do the job better, remain significantly more portable, and use a simpler syntax. Win32 exceptions do have the advantage, however, that they can be handled by components\n\n\n\nthat may not have been compiled with the same C++ compiler. The first step is to define the exception. An exception is a 32-bit integer with the following format (starting at bit 0): Bit Meaning 31-30 11 = error (normal) 00 = success, 01 = informational 10 = warning 29 1 = user-defined 28 Reserved 27-0 User-defined In addition to defining the exception code, you need to decide whether or not to include additional information with the exception (accessible to the filter/handler from the exception record). There is no conventional method for encoding additional parameters in the exception code. Refer to Win32 documentation (available in C++Builder online Help) for more information. Raising exceptions A Win32 exception is raised with a call to RaiseException(), which is declared as follows void RaiseException(DWORD ec, DWORD ef, DWORD na, const DWORD *a); where: ec Exception code ef Exception flags, either 0 or EXCEPTION NONCONTINUABLE (If the exception is marked as not\n\n\n\ncontinuable and a filter tries to continue it, EXCEPTION NONCONTINUABLE EXCEPTION is raised.) na Number of elements in the arguments array a Pointer to first element in the argument array–the meaning of these arguments depends on the particular exception Exception handling 8-17 S t r uhttp://www.doksihu ctured exceptions under Win32 Forrás: Termination blocks The structured exception handling model supports a “termination block” which is executed whether a guarded block is exited normally or via an exception. The C++Builder compiler supports this in C with the following syntax: try { func(); } finally { // this happens whether func() raises an exception or not } Termination blocks are supported by a C++ extension where you can handle cleanup in the finally block: try { func(); } finally { // this happens whether func() raises an exception or not } The following example illustrates termination blocks: /* Program results: An exception: Caught an exception. The \n\n\n\nfinally is executed too! No exception: No exception happened, but finally still executes! */ #include <stdio.h> #include <windows.h> int main() { float e, f, g; try { f = 1.0; g = 0.0; try { puts(\"An exception:\"); e = f / g; } except(EXCEPTION EXECUTE HANDLER) { puts(\"Caught an exception.\"); } } 8-18 Developer’s Guide VCL exception handling finally { puts(\"The finally is executed too!\"); } try { f = 1.0; g = 2.0; try { puts(\"No exception:\"); e = f / g; } except(EXCEPTION EXECUTE HANDLER) { puts(\"Caught an exception.\"); } } finally { puts(\"No exception happened, but finally still executes!\"); } return e; } C++ code can also handle a “termination block” by creating local objects with destructors that are called when the scope is exited. Since C++Builder structured exceptions support destructor cleanup, this will work regardless of the type of exception raised. Note One special case\n\n\n\nconcerns what happens when an exception is raised and never handled by the program. For a C++ exception, the C++Builder compiler calls destructors for local objects (not required by the language definition), whereas with an unhandled Win32 exception, destructor cleanup does not happen. VCL exception handling When using VCL components in your applications, you need to understand the VCL exception handling mechanism. That is because exceptions are built into many classes and they are thrown automatically when something unexpected occurs. If you do not handle the exception, the VCL will handle it in a default manner. Typically, a message displays describing the type of error that occurred. When you are programming and you encounter an exception that displays a message indicating the type of exception that was thrown, you can look up the exception class in the VCL Reference. The information provided will often help you to determine where the error occurred and its cause. In addition,\n\n\n\nChapter 9, “C++ language support for the VCL” describes subtle language differences that can cause exceptions. The section “Exceptions thrown from constructors” on page 9-10 provides an example to show what happens if an exception is thrown during object construction. Exception handling 8-19 V C L http://www.doksihu exception handling Forrás: Differences between C++ and VCL exception handling Following are some noteworthy differences between C++ and VCL exception handling. Exceptions thrown from constructors:\n• C++ destructors are called for members and base classes that are fully constructed.\n• VCL base class destructors are called even if the object or base class isn’t fully constructed. Catching and throwing exceptions:\n• C++ exceptions can be caught by reference, pointer, or value. VCL exceptions, which are exceptions derived from TObject, can only be caught by reference or pointer. An attempt to catch TObject exceptions by value results in a compile-time\n\n\n\nerror. Hardware or operating system exceptions, such as EAccessViolation, should be caught by reference.\n• VCL exceptions are caught by reference.\n• You cannot use throw to reraise an exception that was caught within VCL code. Handling operating system exceptions C++Builder allows you to handle exceptions thrown by the operating system. Operating system exceptions include access violations, integer math errors, floating-point math errors, stack overflow, and Ctrl+C interrupts. These are handled in the C++ RTL and converted to VCL exception class objects before being dispatched to your application. You can then write C++ code that looks like this: try { char * p = 0; *p = 0; } // You should always catch by reference. catch (const EAccessViolation &e) { printf(\"You cant do that! \"); } The classes C++Builder uses are the same as those that Delphi uses and are only available to C++Builder VCL applications. They are derived from TObject and require the VCL underpinnings.\n\n\n\nHere are some characteristics of C++Builder exception handling:\n• You are not responsible for freeing the exception object.\n• Operating system exceptions should be caught by reference.\n• You cannot rethrow an operating system exception once the catch frame has been exited and have it be caught by intervening VCL catch frames. 8-20 Developer’s Guide VCL exception handling\n• You cannot rethrow an operating system exception once the catch frame has been exited and have it be caught by intervening operating system catch frames. The last two points can be stated roughly as this: Once an operating system exception is caught as a C++ exception, it cannot be rethrown as if it were an operating system exception or a VCL exception unless you are in the catching stack frame. Handling VCL exceptions C++Builder broadens the semantics for handling software exceptions thrown from the VCL or, equivalently, exceptions thrown from C++ where the exception class being thrown is derived\n\n\n\nfrom TObject. In such a case, a couple of rules are derived from the fact that VCL-style classes can only be allocated on the heap.\n• VCL-style exception classes may only be caught by pointer, if it is a software exception, or by reference (reference is preferred).\n• A VCL-style exception should be thrown with “by value” syntax. VCL exception classes C++Builder includes a large set of built-in exception classes for automatically handling divide-by-zero errors, file I/O errors, invalid typecasts, and many other exception conditions. All VCL exception classes descend from one root object called Exception. Exception encapsulates the fundamental properties and methods for all exceptions and provides a consistent interface for applications to handle exceptions. You can pass exceptions to a catch block that takes a parameter of type Exception. Use the following syntax to catch VCL exceptions: catch (const exception class &exception variable) You specify the exception class that\n\n\n\nyou want to catch and provide a variable by which to refer to the exception. Following is an example of how to throw a VCL exception: void fastcall TForm1::ThrowException(TObject *Sender) { try { throw Exception(“VCL component”); } catch(const Exception &E) { ShowMessage(AnsiString(E.ClassName())+ EMessage); } } The throw statement in the previous example creates an instance of the Exception class and calls its constructor. All exceptions descended from Exception have a message that can be displayed, passed through constructors, and retrieved through the Message property. Exception handling 8-21 V C L http://www.doksihu exception handling Forrás: Selected VCL exception classes are described in Table 8.2 Table 8.2 Selected exception classes Exception class Description EAbort Stops a sequence of events without displaying an error message dialog box. EAccessViolation Checks for invalid memory access errors. EBitsError Prevents invalid attempts to access a Boolean\n\n\n\narray. EComponentError Signals an invalid attempt to register or rename a component. EConvertError Indicates string or object conversion errors. EDatabaseError Specifies a database access error. EDBEditError Catches data incompatible with a specified mask. EDivByZero Catches integer divide-by-zero errors. EExternalException Signifies an unrecognized exception code. EInOutError Represents a file I/O error. EIntOverflow Specifies integer calculations whose results are too large for the allocated register. EInvalidCast Checks for illegal typecasting. EInvalidGraphic Indicates an attempt to work with an unrecognized graphic file format. EInvalidOperation Occurs when invalid operations are attempted on a component. EInvalidPointer Results from invalid pointer operations. EMenuError Involves a problem with menu item. EOleCtrlError Detects problems with linking to ActiveX controls. EOleError Specifies OLE automation errors. EPrinterError Signals a printing\n\n\n\nerror. EPropertyError Occurs on unsuccessful attempts to set the value of a property. ERangeError Indicates an integer value that is too large for the declared type to which it is assigned. ERegistryException Specifies registry errors. EStackOverflow Occurs when the stack grows into the final guard page. EZeroDivide Catches floating-point divide-by-zero errors. As you can see from the selected list above, the built-in VCL exception classes handle much of the exception handling for you and can simplify your code. There are other times when you will need to create your own exception classes to handle unique situations. You can declare a new exception class making it a descendant of type Exception creating as many constructors as you need (or copy the constructors from an existing class in SYSUTILS.HPP) Portability considerations Several Runtime Libraries (RTLs) are delivered with C++Builder. Most of them pertain to C++Builder applications, but one of them (CW32MT.LIB) is the\n\n\n\nnormal multi-threaded RTL that does not make any references to the VCL. This RTL is 8-22 Developer’s Guide VCL exception handling provided for support of legacy applications which may be part of a project but should not depend on the VCL. This RTL does not have support for catching operating system exceptions because those exception objects are derived from TObject and would require parts of the VCL to be linked into your application. To get the full benefits of C++Builder, use the CP32MT.LIB library This is the multi-threaded runtime library that provides memory management and exception handling with the VCL. Exception handling 8-23 8-24 Developer’s Guide Chapter 9 C++ language support for the VCL Chapter9 C++Builder leverages the Rapid Application Development (RAD) capabilities of the Visual Component Library (VCL) written in Object Pascal. This chapter explains how Object Pascal language features, constructs, and concepts were implemented in C++Builder to\n\n\n\nsupport the VCL. It is written for programmers using VCL objects in their applications and for developers creating new classes descended from VCL classes. The first half of this chapter compares C++ and Object Pascal object models, describing how C++Builder combines these two approaches. The second half of the chapter describes how Object Pascal language constructs were translated into C++ counterparts in C++Builder. It includes details on keyword extensions that were added to support the VCL. Some of these extensions, like closures and properties, are useful features independent of their support for VCL-based code. Note References to C++ classes derived from TObject refer to classes for which TObject is the ultimate, but not necessarily immediate, ancestor. For consistency with the compiler diagnostics, such classes are also referred to as “VCL style classes.” C++ and Object Pascal object models C++ and Object Pascal are subtly different in the way they create, initialize,\n\n\n\nreference, copy, and destroy objects. These nuances and their impact on C++Builder VCL style classes are described in this section. Object identity and instantiation In C++, an instance of a class is an actual object. That object can be directly manipulated, or it can be accessed indirectly through either a reference or a pointer to C++ language support for the VCL 9-1 C + + http://www.doksihu and Object Pascal object models Forrás: it. For example, given a C++ class CPP class with a constructor that takes no arguments, the following are all valid instance variables of that class: CPP class by value;// an object of type CPP class CPP class& ref = by value;// a reference to the object by value, above CPP class* ptr = new CPP class();// a pointer to an object of type CPP class By contrast, in Object Pascal a variable of type object always refers to the object indirectly. The memory for all objects is dynamically allocated For example, given an Object Pascal class OP class\n\n\n\nref: OP class; ref := OP class.Create; ref is a “reference” to an object of type OP class. Translated to C++Builder code, it would be OP class* ref = new OP class; Distinguishing C++ and Object Pascal references Documentation frequently refers to an Object Pascal class instance variable as a reference, but describes its behavior as that of a pointer. This is because it has properties of both. An Object Pascal object reference is like a C++ pointer with the following exceptions:\n• An Object Pascal reference is implicitly dereferenced (in which case it acts more like a C++ reference).\n• An Object Pascal reference does not have pointer arithmetic as a defined operation. When comparing an Object Pascal reference with a C++ reference, there are also similarities and differences. References in both languages are implicitly dereferenced, however,\n• An Object Pascal reference can be rebound, whereas a C++ reference cannot.\n• An Object Pascal reference can be nil, whereas a C++\n\n\n\nreference must refer to a valid object. Some of the design decisions underlying the VCL framework are based upon the use of this type of instance variable. A pointer is the closest C++ language construct to an Object Pascal reference. Consequently, nearly all VCL object identifiers are translated into C++ pointers in C++Builder. Note The Object Pascal var parameter type is a close match to a C++ reference. For more information about var parameters, see “Var parameters” on page 9-12. Copying objects Unlike C++, Object Pascal does not have built-in compiler support for making a copy of an object. This section describes the impact of this difference on assignment operators and copy constructors for VCL style classes. 9-2 Developer’s Guide C++ and Object Pascal object models Assignment operators The Object Pascal assignment operator (:=) is not a class assignment operator (operator=()). The assignment operator copies the reference, not the object In the following code, B and\n\n\n\nC both refer to the same object: B, C: TButton; B:= TButton.Create(ownerCtrl); C:= B; This example translates to the following code in C++Builder: TButton *B = NULL; TButton *C = NULL; B = new TButton(ownerCtrl); C = B;// makes a copy of the pointer, not the object VCL style classes in C++Builder follow the Object Pascal language rules for assignment operators. This means that, in the following code, assignments between dereferenced pointers are not valid because they attempt to copy the object, not the pointer: TVCLStyleClass *p = new TVCLStyleClass; TVCLStyleClass *q = new TVCLStyleClass; *p = q;// not allowed for VCL style class objects Note For VCL style classes, it is still valid to use C++ syntax to bind a reference. For example, the following code is valid: TVCLStyleClass *ptr = new TVCLStyleClass; TVCLStyleClass &ref = *ptr;// OK for VCL style classes Although this is not the same as using an assignment operator, the syntax is similar enough that it is mentioned here\n\n\n\nfor clarification and comparison. Copy constructors Object Pascal does not have built-in copy constructors. Consequently, VCL style classes in C++Builder do not have built-in copy constructors. The following example code attempts to create a TButton pointer by using a copy constructor: TButton *B = new TButton(ownerCtrl); TButton *C = new TButton(B);// not allowed for VCL style class objects Do not write code that depends upon a built-in copy constructor for VCL classes. To create a copy of a VCL style class object in C++Builder, you can write code for a member function that copies the object. Alternatively, descendants of the VCL TPersistent class can override the Assign method to copy data from one object to another. This is typically done, for example, in graphics classes such as TBitmap and TIcon that contain resource images. Ultimately, the manner of copying an object can be determined by the programmer (component writer); but be aware that some of the copy methods used in\n\n\n\nstandard C++ are not available for VCL style classes. Objects as function arguments As discussed previously, instance variables in C++ and in Object Pascal are not identical. You should be aware of this when passing objects as arguments to functions. In C++, objects can be passed to functions either by value, by reference, or C++ language support for the VCL 9-3 C + + http://www.doksihu and Object Pascal object models Forrás: by pointer. In Object Pascal, when an object is passed by value to a function, remember that the object argument is already a reference to an object. So, it is, in fact, the reference that is passed by value, not the actual object. There is no Object Pascal equivalent to passing an actual object by value as in C++. VCL style objects passed to functions follow the Object Pascal rules. Object construction for C++Builder VCL classes C++ and Object Pascal construct objects differently. This section is an overview of this topic and a description of how\n\n\n\nC++Builder combines these two approaches. C++ object construction In standard C++, the order of construction is virtual base classes, followed by base classes, and finally the derived class. The C++ syntax uses the constructor initialization list to call base class constructors. The runtime type of the object is that of the class of the current constructor being called. Virtual method dispatching follows the runtime type of the object and changes accordingly during construction. Object Pascal object construction In Object Pascal, only the constructor for the instantiated class is guaranteed to be called; however, the memory for base classes is allocated. Constructing each immediate base class is done by calling inherited in the corresponding derived class’s constructor. By convention, VCL classes use inherited to call (non-empty) base class constructors. Be aware, however, that this is not a requirement of the language. The runtime type of the object is established immediately as\n\n\n\nthat of the instantiated class and does not change as base class constructors are called. Virtual method dispatching follows the runtime type of the object and, therefore, does not change during construction. C++Builder object construction VCL style objects are constructed like Object Pascal objects, but using C++ syntax. This means that the method and order of calling base class constructors follows C++ syntax using the initialization list for all non-VCL base classes and the first immediate VCL ancestor. This VCL base class is the first class to be constructed It constructs its own base class, optionally, using inherited, following the Object Pascal method. Therefore, the VCL base classes are constructed in the opposite order from which you might expect in C++. Then the C++ base classes are all constructed, from the most distant ancestor to the derived class. The runtime type of the object and virtual method dispatching are Object Pascal-based. Figure 9.1 illustrates the\n\n\n\nconstruction of an instance of a VCL style class, MyDerived, descended from MyBase, which is a direct descendant of TWinControl. MyDerived and MyBase are implemented in C++. TWinControl is a VCL class implemented in Object Pascal. 9-4 Developer’s Guide C++ and Object Pascal object models Figure 9.1 Order of VCL style object construction Inheritance Order of construction TObject TWinControl (constructor calls inherited ) TPersistent TControl (constructor calls inherited ) TComponent TComponent TControl TPersistent (no constructor) TWinControl TObject (empty constructor) C++/Object Pascal boundary MyBase MyBase MyDerived MyDerived Note that the order of construction might seem backwards to a C++ programmer because it starts from the leaf-most ancestor to TObject for true VCL classes, then constructs MyBase, and finally constructs the derived class. Note TComponent does not call inherited because TPersistent does not have a constructor. TObject has an empty\n\n\n\nconstructor, so it is not called. If these class constructors were called, the order would follow the diagram in which these classes appear in gray. C++ language support for the VCL 9-5 C + + http://www.doksihu and Object Pascal object models Forrás: The object construction models in C++, Object Pascal, and C++Builder are summarized in Table 9.1: Table 9.1 Object model comparison C++ Object Pascal C++Builder Instantiated class constructor is the first and only constructor to be called automatically. If subsequent classes are constructed, they are constructed from leaf-most to root. Most immediate VCL base class, then construction follows the Object Pascal model, then construction follows the C++ model (except that no virtual base classes are allowed). Order of construction Virtual base classes, then base classes, finally the derived class. Method of calling base class constructors Automatically, from the constructor initialization list. Optionally, explicitly, and at any\n\n\n\ntime during the body of the derived class constructor, by using the inherited keyword. Automatically from the constructor initialization list through the most immediate ancestor VCL base class constructor. Then according to the Object Pascal method, calling constructors with inherited. Runtime type of the object as it is being constructed Changes, reflecting the type of the current constructor class. Established immediately as that of the instantiated class. Established immediately as that of the instantiated class. Follows the runtime type of the object, which remains the same throughout calls to all class constructors. Follows the runtime type of the object, which remains the same throughout calls to all class constructors. Virtual method dispatching Changes according to the runtime type of the object as base class constructors are called. The significance of these differences is described in the following section. Calling virtual methods in base class constructors Virtual\n\n\n\nmethods invoked from the body of VCL base class constructors, that is, classes implemented in Object Pascal, are dispatched as in C++, according to the runtime type of the object. Because C++Builder combines the Object Pascal model of setting the runtime type of an object immediately, with the C++ model of constructing base classes before the derived class is constructed, calling virtual methods from base class constructors for VCL style classes can have subtle side-effects. The impact of this is described below, then illustrated in an example of an instantiated class that is derived from at least one base. In this discussion, the instantiated class is referred to as the derived class. Object Pascal model In Object Pascal, programmers can use the inherited keyword, which provides flexibility for calling base class constructors anywhere in the body of a derived class 9-6 Developer’s Guide C++ and Object Pascal object models constructor. Consequently, if the derived class\n\n\n\noverrides any virtual methods that depend upon setting up the object or initializing data members, this can happen before the base class constructor is called and the virtual methods are invoked. C++ model The C++ syntax does not have the inherited keyword to call the base class constructor at any time during the construction of the derived class. For the C++ model, the use of inherited is not necessary because the runtime type of the object is that of the current class being constructed, not the derived class. Therefore, the virtual methods invoked are those of the current class, not the derived class. Consequently, it is not necessary to initialize data members or set up the derived class object before these methods are called. C++Builder model In C++Builder, the VCL style objects have the runtime type of the derived class throughout calls to base class constructors. Therefore, if the base class constructor calls a virtual method, the derived class method is invoked if the derived\n\n\n\nclass overrides it. If this virtual method depends upon anything in the initialization list or body of the derived class constructor, the method is called before this happens. For example, CreateParams is a virtual member function that is called indirectly in the constructor of TWinControl. If you derive a class from TWinControl and override CreateParams so that it depends on anything in your constructor, this code is processed after CreateParams is called. This situation applies to any derived classes of a base. Consider a class C derived from B, which is derived from A Creating an instance of C, A would also call the overridden method of B, if B overrides the method but C does not. Note Be aware of virtual methods like CreateParams that are not obviously called in constructors, but are invoked indirectly. Example: calling virtual methods The following example compares C++ and VCL style classes that have overridden virtual methods. This example illustrates how calls to those virtual\n\n\n\nmethods from base class constructors are resolved in both cases. MyBase and MyDerived are standard C++ classes. MyVCLBase and MyVCLDerived are VCL style classes descended from TObject. The virtual method what am I() is overridden in both derived classes, but is called only in the base class constructors, not in derived class constructors. #include <sysutils.hpp> #include <iostream.h> // non-VCL style classes class MyBase { public: MyBase() { what am I(); } virtual void what am I() { cout << \"I am a base\" << endl; } }; C++ language support for the VCL 9-7 C + + http://www.doksihu and Object Pascal object models Forrás: class MyDerived : public MyBase { public: virtual void what am I() { cout << \"I am a derived\" << endl; } }; // VCL style classes class MyVCLBase : public TObject { public: fastcall MyVCLBase() { what am I(); } virtual void fastcall what am I() { cout << \"I am a base\" << endl; } };\n\n\n\nclass MyVCLDerived : public MyVCLBase { public: virtual void fastcall what am I() { cout << \"I am a derived\" << endl; } }; int main(void) { MyDerived d;// instantiation of the C++ class MyVCLDerived *pvd = new MyVCLDerived;// instantation of the VCL style class return 0; } The output of this example is I am a base I am a derived because of the difference in the runtime types of MyDerived and MyVCLDerived during the calls to their respective base class constructors. Constructor initialization of data members for virtual functions Because data members may be used in virtual functions, it is important to understand when and how they are initialized. In Object Pascal, all uninitialized data is zero-initialized. This applies, for example, to base classes whose constructors are not called with inherited. In standard C++, there is no guarantee of the value of uninitialized data members. The following types of class data members must be initialized in the\n\n\n\ninitialization list of the class’s constructor:\n• References\n• Data members with no default constructor Nevertheless, the value of these data members, or those initialized in the body of the constructor, is undefined when the base class constructors are called. In C++Builder, the memory for VCL style classes is zero-initialized. Note 9-8 Technically, it is the memory of the VCL class that is zero, that is the bits are zero, the values are actually undefined. For example, a reference is zero Developer’s Guide C++ and Object Pascal object models A virtual function which relies upon the value of member variables initialized in the body of the constructor or in the initialization list may behave as if the variables were initialized to zero. This is because the base class constructor is called before the initialization list is processed or the constructor body is entered. The following example illustrates this: #include <sysutils.hpp> class Base : public TObject {\n\n\n\npublic: fastcall Base() { init(); } virtual void fastcall init() { } }; class Derived : public Base { public: Derived(int nz) : not zero(nz) { } virtual void fastcall init() { if (not zero == 0) throw Exception(\"not zero is zero!\"); } private: int not zero; }; int main(void) { Derived *d42 = new Derived(42); return 0; } This example throws an exception in the constructor of Base. Because Base is constructed before Derived, not zero, has not yet been initialized with the value of 42 passed to the constructor. Be aware that you cannot initialize data members of your VCL style class before its base class constructors are called. Object destruction Two mechanisms concerning object destruction work differently in C++ from the way they do in Object Pascal. These are:\n• Destructors called because of exceptions thrown from constructors\n• Virtual methods called from destructors VCL style classes combine the methods of these two languages. The issues are discussed below. \n\n\n\nC++ language support for the VCL 9-9 C + + http://www.doksihu and Object Pascal object models Forrás: Exceptions thrown from constructors Destructors are called differently in C++ than in Object Pascal if an exception is thrown during object construction. Take as an example, class C, derived from class B, which is derived from class A: class A { // body }; class B: public A { // body }; class C: public B { // body }; Consider if an exception is raised in the constructor of class B when constructing an instance of C. What results in C++, Object Pascal, and VCL style classes is described here:\n• In C++, first the destructors for all completely constructed object data members of B are called, then A’s destructor is called, then the destructors for all completely constructed data members of A are called. However, the destructors for B and C are not called.\n• In Object Pascal, only the instantiated class destructor is called automatically. This is the destructor for C. As with\n\n\n\nconstructors, it is entirely the programmer’s responsibility to call inherited in destructors. In this example, if we assume all of the destructors call inherited, then the destructors for C, B, and A are called in that order. Moreover, whether or not inherited was already called in B’s constructor before the exception occurred, A’s destructor is called because inherited was called in B’s destructor. Calling the destructor for A is independent of whether or not its constructor was actually called. More importantly, because it is common for constructors to call inherited immediately, the destructor for C is called whether or not the body of its constructor was completely executed.\n• In VCL style classes, the true VCL bases (implemented in Object Pascal) follow the Object Pascal method of calling destructors. The C++ VCL style classes (implemented in C++) do not follow exactly either language method. What happens is that all the destructors are called; but the bodies of those\n\n\n\nthat would not have been called, according to C++ language rules, are not entered. Classes implemented in Object Pascal thereby provide an opportunity to process any cleanup code you write in the body of the destructor. This includes code that frees memory for sub-objects (data members that are objects) that are constructed before a constructor exception occurs. Be aware that, for VCL style classes, the clean-up code may not be processed for the instantiated class or for its C++-implemented bases, even though the destructors are called. For more information on handling exceptions in C++Builder, refer to “VCL exception handling” on page 8-19. 9-10 Developer’s Guide Support for Object Pascal data types and language concepts Virtual methods called from destructors Virtual method dispatching in destructors follows the same pattern that it did for constructors. This means that for VCL style classes, the derived class is destroyed first, but the runtime type of the object remains\n\n\n\nthat of the derived class throughout subsequent calls to base class destructors. Therefore, if virtual methods are called in VCL base class destructors, you are potentially dispatching to a class that has already destroyed itself. AfterConstruction and BeforeDestruction TObject introduces two virtual methods, BeforeDestruction and AfterConstruction, that allow programmers to write code that is processed before and after objects are destroyed and created, respectively. AfterConstruction is called after the last constructor is called. BeforeDestruction is called before the first destructor is called These methods are public and are called automatically. Class virtual functions Object Pascal has the concept of a class virtual function. The C++ analogy would be a static virtual function, if it were possible; but C++ has no exact counterpart to this type of function. These functions are safely called internally from the VCL However, you should never call a function of this type in\n\n\n\nC++Builder. You can identify these functions in the header files because they are preceded by the following comment: /* virtual class method / Support for Object Pascal data types and language concepts To support the VCL, C++Builder implements, translates, or otherwise maps most Object Pascal data types, constructs, and language concepts to the C++ language.This is done in the following ways:\n• \n• \n• \n• \n• Typedefs to native C++ types Classes, structs, and class templates C++ language counterparts Macros Keywords that are ANSI-conforming language extensions Not all aspects of the Object Pascal language map cleanly to C++. Occasionally, using these parts of the language can lead to unexpected behavior in your application. For example:\n• Some types exist in both Object Pascal and in C++, but are defined differently. These can require caution when sharing code between these two languages.\n• Some extensions were added to Object Pascal for the purpose of supporting C++Builder.\n\n\n\nOccasionally these can have subtle interoperability impact\n• Object Pascal types and language constructs that have no mapping to the C++ language should be avoided in C++Builder when sharing code between these languages. C++ language support for the VCL 9-11 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: This section summarizes how C++Builder implements the Object Pascal language, and suggests when to use caution. Typedefs Most Object Pascal intrinsic data types are implemented in C++Builder using a typedef to a native C++ type. These are found in sysmach Whenever possible you should use the native C++ type, rather than the Object Pascal type. Classes that support the Object Pascal language Some Object Pascal data types and language constructs that do not have a built-in C++ counterpart are implemented as classes or structs. Class templates are also used to implement data types as well as Object Pascal language constructs, like set,\n\n\n\nfrom which a specific type can be declared. The declarations for these are found in the following header files:\n• dstring.h\n• syscurr.h\n• systdate.h\n• wstring.h\n• sysdyn.h\n• systobj.h\n• sysclass.h\n• sysopen.h\n• systvar.h\n• syscomp.h\n• sysset.h\n• sysvari.h The classes implemented in these header files were created to support native types used in Object Pascal routines. They are intended to be used when calling these routines in VCL-based code. C++ language counterparts to the Object Pascal language Object Pascal var and untyped parameters are not native to C++. Both have C++ language counterparts that are used in C++Builder. Var parameters Both C++ and Object Pascal have the concept of “pass by reference.” These are modifiable arguments. In Object Pascal they are called var parameters The syntax for functions that take a var parameter is procedure myFunc(var x : Integer); In C++, you should pass these types of parameters by reference: void\n\n\n\nmyFunc(int& x); Both C++ references and pointers can be used to modify the object. However, a reference is a closer match to a var parameter because, unlike a pointer, a reference cannot be rebound and a var parameter cannot be reassigned; although, either can change the value of what it references. 9-12 Developer’s Guide Support for Object Pascal data types and language concepts Untyped parameters Object Pascal allows parameters of an unspecified type. These parameters are passed to functions with no type defined. The receiving function must cast the parameter to a known type before using it. C++Builder interprets untyped parameters as pointers-to-void (void *). The receiving function must cast the void pointer to a pointer of the desired type. Following is an example: int myfunc(void* MyName) { // Cast the pointer to the correct type; then dereference it. int* pi = static cast<int>(MyName); return 1 + *pi; } Open arrays Object Pascal has an “open array”\n\n\n\nconstruct that permits an array of unspecified size to be passed to a function. While there is no direct support in C++ for this type, an Object Pascal function that has an open array parameter can be called by explicitly passing both pointer to the first element of an array, and the value of the last index (number of array elements, minus one). For example, the Mean function in mathhpp has this declaration in Object Pascal: function Mean(Data: array of Double): Extended; The C++ declaration is Extended fastcall Mean(const double * Data, const int Data Size); The following code illustrates calling the Mean function from C++: double d[] = { 3.1, 44, 56 }; // explicitly specifying last index long double x = Mean(d, 2); // better: use sizeof to ensure that the correct value is passed long double y = Mean(d, (sizeof(d) / sizeof(d[0])) - 1); // use macro in sysopen.h long double z = Mean(d, ARRAYSIZE(d) - 1); Note In cases similar to the above example, but where the Object Pascal\n\n\n\nfunction takes a var parameter, the C++ function declaration parameters will not be const. Calculating the number of elements When using sizeof(), the ARRAYSIZE macro, or EXISTINGARRAY macro to calculate the number of elements in an array, be careful not to use a pointer to the first array element instead. Pass the name of an array instead: double d[] = { 3.1, 44, 56 }; ARRAYSIZE(d) == 3; double *pd = d; ARRAYSIZE(pd) == 0; // Error! C++ language support for the VCL 9-13 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: Taking the “sizeof” an array is not the same as taking the “sizeof” a pointer. For example, given the following declarations, double d[3]; double *p = d; taking the size of the array as shown here sizeof(d)/sizeof d[0] does not evaluate the same as taking the size of the pointer: sizeof(p)/sizeof(p[0]) This example and those following use the ARRAYSIZE macro instead of the sizeof() operator. For more information\n\n\n\nabout the ARRAYSIZE macro, see the online Help Temporaries Object Pascal provides support for passing unnamed temporary open arrays to functions. There is no syntax for doing this in C++ However, since variable definitions can be intermingled with other statements, one approach is to simply provide the variable with a name. Object Pascal: Result := Mean([3.1, 44, 56]); C++, using a named “temporary”: double d[] = { 3.1, 44, 56 }; return Mean(d, ARRAYSIZE(d) - 1); To restrict the scope of the named “temporary” to avoid clashing with other local variables, open a new scope in place: long double x; { double d[] = { 4.4, 3331, 00 }; x = Mean(d, ARRAYSIZE(d) - 1); } For another solution, see “OPENARRAY macro” on page 9-15. array of const Object Pascal supports a language construct called an array of const. This argument type is the same as taking an open array of TVarRec by value. The following is an Object Pascal code segment declared to accept an array of const: function\n\n\n\nFormat(const Format: string; Args: array of const): string; In C++, the prototype is AnsiString fastcall Format(const AnsiString Format; TVarRec const *Args, const int Args Size); 9-14 Developer’s Guide Support for Object Pascal data types and language concepts The function is called just like any other function that takes an open array: void show error(int error code, AnsiString const &error msg) { TVarRec v[] = { error code, error msg }; ShowMessage(Format(\"%d: %s\", v, ARRAYSIZE(v) - 1)); } OPENARRAY macro The OPENARRAY macro defined in sysopen.h can be used as an alternative to using a named variable for passing a temporary open array to a function that takes an open array by value. The use of the macro looks like OPENARRAY(T, (value1, value2, value3)) // up to 19 values where T is the type of open array to construct. For example: void show error(int error code, AnsiString const &error msg) { ShowMessage(Format(\"%d: %s\", OPENARRAY(TVarRec,\n\n\n\nerror code, error msg))); } Up to 19 values can be passed when using the OPENARRAY macro. If a larger array is needed, an explicit variable must be defined. Additionally, using the OPENARRAY macro incurs an additional (but small) runtime cost, due both to the cost of allocating the underlying array, and to an additional copy of each value. EXISTINGARRAY macro The EXISTINGARRAY macro defined in sysopen.h can be used to pass an existing array where an open array is expected. The use of the macro looks like long double Mean(const double *Data, const int Data Size); double d[] = { 3.1, 314159, 217128 }; Mean(EXISTINGARRAY (d)); Note The section “Calculating the number of elements” on page 9-13 also applies to the EXISTINGARRAY macro. C++ functions that take open array arguments When writing a C++ function that will be passed an open array from Object Pascal, it is important to explicitly maintain “pass by value” semantics. In particular, if the declaration for the function\n\n\n\ncorresponds to “pass by value”, be sure to explicitly copy any elements before modifying them. In Object Pascal, an open array is a built-in type and can be passed by value. In C++, the open array type is implemented using a pointer, which will modify the original array unless you make a local copy of it. Types defined differently Types that are defined differently in Object Pascal and C++ are not normally cause for concern. The rare cases in which they are problematic may be subtle For this reason, these types are mentioned in this section. C++ language support for the VCL 9-15 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: Boolean data types The True value for the Object Pascal ByteBool, WordBool, and LongBool data types is represented in Object Pascal as –1. False is represented as 0 Note The Boolean data type remains unchanged (True = 1, False = 0). While the C++ bool type converts these Object Pascal types correctly, there is\n\n\n\na problem when sharing a WinAPI function or any other function that uses a Window’s BOOL type, which is represented as 1. If a value is passed to a parameter of type BOOL, it evaluates to –1 in Object Pascal and to 1 in C++. Therefore, if you are sharing code between these two languages, any comparison of the two identifiers may fail unless they are both 0 (False, false). As a workaround, you can use the following method of comparison: !A == !B; Table 9.2 shows the results of using this method of equality comparison: Table 9.2 Equality comparison !A == !B of BOOL variables Object Pascal C++ !A == !B 0 (False) 0 (false) !0 == !0 (TRUE) 0 (False) 1 (true) !0 == !1 (FALSE) –1 (True) –1 (True) 0 (false) !–1 == !0 (FALSE) 1 (true) !–1 == !1 (TRUE) With this method of comparison, any set of values will evaluate correctly. Char data types The char type in C++ is a signed type, whereas it is an unsigned type in Object Pascal. It is extremely rare that a situation\n\n\n\nwould occur in which this difference would be a problem when sharing code. Resource strings If you have code in a Pascal unit that uses resource strings, the Pascal compiler (DCC32) generates a global variable and a corresponding preprocessor macro for each resource string when it generates the header file. The macros are used to automatically load the resource strings, and are intended to be used in your C++ code in all places where the resource string is referenced. For example, the resourcestring section in the Object Pascal code could contain unit borrowed; interface resourcestring Warning = Be careful when accessing string resources.; implementation begin end. 9-16 Developer’s Guide Support for Object Pascal data types and language concepts The corresponding code generated by the Pascal compiler for C++Builder would be extern System::Resource ResourceString Warning; #define Borrowed Warning System::LoadResourceString(&Borrowed:: Warning) This enables you to use the\n\n\n\nexported Object Pascal resource string without having to explicitly call LoadResourceString. Default parameters The Pascal compiler now accepts default parameters for compatibility with C++ regarding constructors. Unlike C++, Object Pascal constructors can have the same number and types of parameters, since they are uniquely named. In such cases, dummy parameters are used in the Object Pascal constructors to distinguish them when the C++ header files are generated. For example, for a class named TInCompatible, the Object Pascal constructors could be constructor Create(AOwner: TComponent); constructor CreateNew(AOwner: TComponent); which would translate, without default parameters, to the following ambiguous code in C++ for both constructors: fastcall TInCompatible(Classes::TComponent* Owner);// C++ version of the Pascal Create constructor fastcall TInCompatible(Classes::TComponent* Owner);// C++ version of the Pascal CreateNew constructor However, using default parameters, for a\n\n\n\nclass named TCompatible, the Object Pascal constructors are constructor Create(AOwner: TComponent); constructor CreateNew(AOwner: TComponent; Dummy: Integer = 0); They translate to the following unambiguous code in C++Builder: fastcall TCompatible(Classes::TComponent* Owner);// C++ version of the Pascal Create constructor fastcall TCompatible(Classes::TComponent* Owner, int Dummy);// C++ version of the Pascal CreateNew constructor Note The main issue regarding default parameters is that DCC32 strips out the default value of the default parameter. Failure to remove the default value would lead to the ambiguity that would occur if there were not defaults at all. You should be aware of this when using VCL classes or when using third-party components. C++ language support for the VCL 9-17 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: Runtime type information Object Pascal has language constructs dealing with RTTI. Some have C++\n\n\n\ncounterparts. These are listed in Table 93: Table 9.3 Examples of RTTI mappings from Object Pascal to C++ Object Pascal RTTI C++ RTTI if Sender is TButton. if (dynamic cast <TButton*> (Sender) // dynamic cast returns NULL on failure. b := Sender as TButton; (* raises an exception on failure ) TButton& ref b = dynamic cast <TButton&> (*Sender) // throws an exception on failure. ShowMessage(Sender.ClassName); ShowMessage(typeid(*Sender).name()); In Table 9.3, ClassName is a TObject method that returns a string containing the name of the actual type of the object, regardless of the type of the declared variable. Other RTTI methods introduced in TObject do not have C++ counterparts. These are all public and are listed here:\n• ClassInfo returns a pointer to the runtime type information (RTTI) table of the object type.\n• ClassNameIs determines whether an object is of a specific type.\n• ClassParent returns the type of the immediate ancestor of the class. In\n\n\n\nthe case of TObject, ClassParent returns nil because TObject has no parent. It is used by the is and as operators, and by the InheritsFrom method.\n• ClassType dynamically determines the actual type of an object. It is used internally by the Object Pascal is and as operators.\n• FieldAddress uses RTTI to obtain the address of a published field. It is used internally by the steaming system.\n• InheritsFrom determines the relationship of two objects. It is used internally by the Object Pascal is and as operators.\n• MethodAddress uses RTTI to find the address of a method. It is used internally by the steaming system. Some of these methods of TObject are primarily for internal use by the compiler or the streaming system. For more information about these methods, see the online Help Unmapped types 6-byte Real types The old Object Pascal 6-byte floating-point format is now called Real48. The old Real type is now a double. C++ does not have a counterpart for the Real48 type\n\n\n\nConsequently, you should not use Object Pascal code that includes this type with C++ code. If you do, the header file generator will generate a warning 9-18 Developer’s Guide Support for Object Pascal data types and language concepts Arrays as return types of functions In Object Pascal a function can take as an argument, or return as a type, an array. For example, the syntax for a function GetLine returning an array of 80 characters is type Line Data = array[0.79] of char; function GetLine: Line Data; C++ has no counterpart to this concept. In C++, arrays are not allowed as return types of functions. Nor does C++ accept arrays as the type of a function argument Be aware that, although the VCL does not have any properties that are arrays, the Object Pascal language does allow this. Because properties can use Get and Set read and write methods that take and return values of the property’s type, you cannot have a property of type array in C++Builder. Note Array properties,\n\n\n\nwhich are also valid in Object Pascal, are not a problem in C++ because the Get method takes an index value as a parameter, and the Set method returns an object of the type contained by the array. For more information about array properties, see “Creating array properties” on page 41-8. Keyword extensions This section describes ANSI-conforming keyword extensions implemented in C++Builder to support the VCL. For a complete list of keywords and keyword extensions in C++Builder, see the online Help. classid The classid operator is used by the compiler to generate a pointer to the vtable for the specified classname. This operator is used to obtain the meta class from a class Syntax classid(classname) For example, classid is used when registering property editors, components, and classes, and with the InheritsFrom method of TObject. The following code illustrates the use of classid for creating a new component derived from TWinControl: namespace Ywndctrl { void fastcall\n\n\n\nPACKAGE Register() { TComponentClass classes[1] = { classid(MyWndCtrl)}; RegisterComponents(\"Additional\", classes, 0); } } closure The closure keyword is used to declare a special type of pointer to a member function. Unlike a regular C++ member function pointer, a closure contains an object pointer. C++ language support for the VCL 9-19 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: In standard C++, you can assign a derived class instance to a base class pointer; however, you cannot assign a derived class’s member function to a base class member function pointer. The following code illustrates this: class base { public: void func(int x); }; class derived: public base { public: void new func(int i); }; void (base::*bptr)(int); bptr = &derived::new func;// illegal However, the closure language extension allows you to do this in C++Builder. A closure associates a pointer to a member function with a pointer to a\n\n\n\nclass instance. The pointer to the class instance is used as the this pointer when calling the associated member function. A closure declaration is the same as a function pointer declaration but with the addition of the closure keyword before the identifier being defined. For example: struct MyObject { double MemFunc(int); }; double func1(MyObject *obj) { // A closure taking an int argument and returning double. double ( closure *myClosure )(int); // Initialize the closure. myClosure = obj -> MemFunc; // Use the closure to call the member function and pass it an int. return myClosure(1); } Closures are used with events in C++Builder. property The property keyword declares a property in a class declaration. Properties can only be declared in classes. For property arrays (when <prop dim list> is used), the index to the arrays can be of any type. Syntax 9-20 <property declaration> ::= property <type> <id> [ <prop dim list> ] = \"{\"\n\n\n\n<prop attrib list> \"}\" <prop dim list> ::= \"[\" <type> [ <id> ] \"]\" [ <prop dim list> ] <prop attrib list> ::= <prop attrib> [ , <prop attrib list> ] <prop attrib> ::= read = <data/function id> <prop attrib> ::= write = <data/function id> <prop attrib> ::= stored = <data/function id> Developer’s Guide Support for Object Pascal data types and language concepts <prop <prop <prop <prop attrib> attrib> attrib> attrib> ::= ::= ::= ::= stored = <boolean constant> default = <constant> nodefault index = <const int expression> Properties have several features that distinguish them from data members. Properties can\n• \n• \n• \n• Associate read or write methods with an identifier (property) Set default values for the property Be stored in a form file Extend a property defined in a base class For more information about\n\n\n\nproperties, see Chapter 41, “Creating properties”. published The published keyword specifies that properties in that section are displayed in the Object Inspector, if the class is on the Component palette. Only classes derived from TObject can have published sections. The visibility rules for published members are identical to those of public members. The only difference between published and public members is that Object Pascal-style runtime type information (RTTI) is generated for data members and properties declared in a published section. RTTI enables an application to dynamically query the data members, member functions, and properties of an otherwise unknown class type. Note No constructors or destructors are allowed in a published section. Properties, Pascal intrinsic or VCL derived data-members, member functions, and closures are allowed in a published section. Fields defined in a published section must be of a class type. Properties defined in a published\n\n\n\nsection cannot be array properties The type of a property defined in a published section must be an ordinal type, a real type, a string type, a small set type, a class type, or a method pointer type. The declspec keyword extension Some arguments to the declspec keyword extension provide language support for the VCL. These arguments are listed below Macros for the declspec arguments and combinations of them are defined in sysmac.h In most cases you do not need to specify these. When you do need to add them, you should use the macros declspec(delphiclass) The delphiclass argument is used for declarations for classes derived from TObject. These classes will be created with the following VCL compatibility:\n• VCL-compatible RTTI\n• VCL-compatible constructor/destructor behavior\n• VCL-compatible exception handling C++ language support for the VCL 9-21 S u p http://www.doksihu port for Object Pascal data types and language concepts Forrás: A VCL-compatible class has the\n\n\n\nfollowing restrictions.\n• No virtual base classes are allowed.\n• No multiple inheritance is allowed.\n• Must be dynamically allocated by using the global new operator.\n• Must have a destructor.\n• Copy constructors and assignment operators are not compiler-generated for VCL-derived classes. A class declaration that is translated from Object Pascal will need this modifier if the compiler needs to know that the class is derived from TObject. declspec(delphireturn) The delphireturn argument is for internal use only by the VCL in C++Builder. It is used for declarations of classes that were created in C++Builder to support Object Pascal’s built-in data types and language constructs because they do not have a native C++ type. These include Currency, AnsiString, Variant, TDateTime, and Set The delphireturn argument marks C++ classes for VCL-compatible handling in function calls as parameters and return values. This modifier is needed when passing a structure by value to a\n\n\n\nfunction between Object Pascal and C++. declspec(dynamic) The dynamic argument is used for declarations for dynamic functions. Dynamic functions are similar to virtual functions except that they are stored only in the vtables for the objects that define them, not in descendant vtables. If you call a dynamic function, and that function is not defined in your object, the vtables of its ancestors are searched until the function is found. Dynamic functions are only valid for classes derived from TObject. declspec(hidesbase) The hidesbase argument preserves Object Pascal program semantics when porting Object Pascal virtual and override functions to C++Builder. In Object Pascal, virtual functions in base classes can appear in the derived class as a function of the same name, but which is intended to be a completely new function with no explicit relation to the earlier one. The compilers use the HIDESBASE macro, defined in sysmac.h, to specify that these types of function declarations\n\n\n\nare completely separate. For example, if a base class T1 declares a virtual function, func, taking no arguments, and its derived class T2 declared a function with the same name and signature, DCC32 -jphn would produce an HPP file with the following prototype: virtual void T1::func(void); HIDESBASE void T2::func(void); Without the HIDESBASE declaration, the C++ program semantics indicate that virtual function T1::func() is being overridden by T2::func(). 9-22 Developer’s Guide Support for Object Pascal data types and language concepts declspec(package) The package argument indicates that the code defining the class can be compiled in a package. This modifier is auto-generated by the compiler when creating packages in the IDE. See Chapter 10, “Working with packages and components” for more information about packages. declspec(pascalimplementation) The pascalimplementation argument indicates that the code defining the class was implemented in Object Pascal. This\n\n\n\nmodifier appears in an Object Pascal portability header file with a .hpp extension C++ language support for the VCL 9-23 9-24 Developer’s Guide Chapter 10 Working with packages and components Chapter10 A package is a special dynamic-link library used by C++Builder applications, the IDE, or both. Runtime packages provide functionality when a user runs an application Design-time packages are used to install components in the IDE and to create special property editors for custom components. A single package can function at both design time and runtime, and design-time packages frequently work by calling runtime packages. To distinguish them from other DLLs, package libraries are stored in files that end with the .BPL (Borland package library) extension Like other runtime libraries, packages contain code that can be shared among applications. For example, the most frequently used C++Builder components reside in a package called VCL50. Each time you create an application,\n\n\n\nyou can specify that it uses VCL50. When you compile an application created this way, the application’s executable image contains only the code and data unique to it; the common code is in VCL50.BPL A computer with several package-enabled applications installed on it needs only a single copy of VCL50.BPL, which is shared by all the applications and the IDE itself. C++Builder ships with several precompiled runtime packages, including VCL50, that encapsulate VCL components. C++Builder also uses design-time packages to manipulate components in the IDE. You can build applications with or without packages. However, if you want to add custom components to the IDE, you must install them as design-time packages. You can create your own runtime packages to share among applications. If you write C++Builder components, you can compile your components into design-time packages before installing them. Working with packages and components 10-1 W h y http://www.doksihu use packages? Forrás: \n\n\n\nWhy use packages? Design-time packages simplify the tasks of distributing and installing custom components. Runtime packages, which are optional, offer several advantages over conventional programming. By compiling reused code into a runtime library, you can share it among applications. For example, all of your applicationsincluding C++Builder itselfcan access standard components through packages. Since the applications don’t have separate copies of the component library bound into their executables, the executables are much smallersaving both system resources and hard disk storage. Moreover, packages allow faster compilation because only code unique to the application is compiled with each build. Packages and standard DLLs Create a package when you want to make a custom component that’s available through the IDE. Create a standard DLL when you want to build a library that can be called from any Windows application, regardless of the development tool used to build the application.\n\n\n\nNote Packages share their global data with other modules in an application. Runtime packages Runtime packages are deployed with C++Builder applications. They provide functionality when a user runs the application. To run an application that uses packages, a computer must have both the application’s .EXE file and all the packages (BPL files) that the application uses The .BPL files must be on the system path for an application to use them When you deploy an application, you must make sure that users have correct versions of any required .BPLs Using packages in an application To use packages in an application, 1 Load or create a project in the IDE. 2 Choose Project|Options. 3 Choose the Packages tab. 4 Select the “Build with Runtime Packages” check box, and enter one or more package names in the edit box underneath. (Runtime packages associated with installed design-time packages are already listed in the edit box.) To add a package to an existing list, click the Add button and\n\n\n\nenter the name of the new package in the Add Runtime Package dialog. To browse from a list of available packages, click the Add button, then click the Browse button next to the Package Name edit box in the Add Runtime Package dialog. 10-2 Developer’s Guide Runtime packages If you edit the Search Path edit box in the Add Runtime Package dialog, you will be changing C++Builder’s global Library Path. You do not need to include file extensions with package names. If you type directly into the Runtime Packages edit box, be sure to separate multiple names with semicolons. For example: VCL50;VCLDB50;VCLDBX50 Packages listed in the Runtime Packages edit box are automatically linked to your application when you compile. Duplicate package names are ignored, and if the edit box is empty the application is compiled without packages. Runtime packages are selected for the current project only. To make the current choices into automatic defaults for new projects, select the “Defaults”\n\n\n\ncheck box at the bottom of the dialog. An application built with packages still must include header files for the packaged units that it uses. For example, an application that uses database controls needs the #include \"vcldb.h\" statement, even if it uses the VCLDB40 package. In generated source files, C++Builder creates these #include statements automatically. Dynamically loading packages To load a package at runtime, call the LoadPackage function. For example, the following code could be executed when a file is chosen in a file-selection dialog. if (OpenDialog1->Execute()) PackageList->Items->AddObject(FileName, Pointer(LoadPackage(Filename))); To unload a package dynamically, call UnloadPackage. Be careful to destroy any instances of classes defined in the package and to unregister classes that were registered by it. Deciding which runtime packages to use C++Builder ships with several precompiled runtime packages, including VCL50, which supply basic language\n\n\n\nand component support. The VCL50 package contains the most commonly used components, system functions, and Windows interface elements. It does not include database or Windows 3.1 components, which are available in separate packages For a list of the other runtime packages shipped with C++Builder, see “runtime packages, precompiled” in your online Help index. To create a client/server database application that uses packages, you need at least two runtime packages: VCL50 and VCLDB50. If you want to use Outline components in your application, you also need VCLX50. To use these packages, choose Project|Options, select the Packages tab, and enter the following list in the Runtime Packages edit box. VCL50;VCLDB50;VCLX50 Working with packages and components 10-3 D e s http://www.doksihu ign-time packages Forrás: Actually, you don’t have to include VCL50, because VCL50 is referenced in the Requires list of VCLDB50. (See “The Requires list” on page 10-9) Your application will\n\n\n\ncompile just the same whether or not VCL50 is included in the Runtime Packages edit box. Custom packages A custom package is either a BPL you code and compile yourself, or a precompiled package from a third-party vendor. To use a custom runtime package with an application, choose Project|Options and add the name of the package to the Runtime Packages edit box on the Packages page. For example, suppose you have a statistical package called STATS.BPL To use it in an application, the line you enter in the Runtime Packages edit box might look like this: VCL50;VCLDB50;STATS If you create your own packages, you can add them to the list as needed. Design-time packages Design-time packages are used to install components on the IDE’s Component palette and to create special property editors for custom components. C++Builder ships with the following design-time component packages preinstalled in the IDE. Table 10.1 10-4 Design-time packages Package Component palette pages DCLSTD50.BPL \n\n\n\nStandard, Additional, System, Win32, Dialogs DCLTEE50.BPL Additional (TChart component) DCLDB50.BPL Data Access, Data Controls DCLMID50.BPL Data Access (MIDAS) DCL31W50.BPL Win 3.1 DCLNET50.BPL NMFAST50.BPL Internet BCBSMP50.BPL Samples DCLOCX50.BPL ActiveX DCLQRT50.BPL QReport DCLDSS50.BPL Decision Cube IBSMP50.BPL Samples (IBEventAlerter component) DCLINT50.BPL (International ToolsResource DLL wizard) RCEXPERT.BPL (Resource Expert) DBWEBXPRT.BPL (Web Wizard) MFCWIZARD.BPL (MFC Wizard) Developer’s Guide Design-time packages These design-time packages work by calling runtime packages, which they reference in their Requires lists. (See “The Requires list” on page 10-9) For example, DCLSTD50 references VCL50. DCLSTD50 itself contains additional functionality that makes most of the standard components available on the Component palette. In addition to preinstalled packages, you can install your own component packages, or component packages from\n\n\n\nthird-party developers, in the IDE. The DCLUSR50 design-time package is provided as a default container for new components. Installing component packages All components are installed in the IDE as packages. If you’ve written your own components, create and compile a package that contains them. (See “Creating and editing packages” on page 10-6.) Your component source code must follow the model described in Part V, “Creating custom components.” If you are adding multiple units to a single package, each with components in them, you must make a single Register function for all components in a namespace that has the name of the package. To install or uninstall your own components, or components from a third-party vendor, follow these steps: 1 If you are installing a new package, copy or move the package files to a local directory. If the package is shipped with BPL, BPI, LIB, and OBJ files, be sure to copy all of them. (For information about these files, see “Package files\n\n\n\ncreated by a successful compilation” on page 10-12.) The directory where you store the .BPI and header filesand the LIB or OBJ files, if they are included with the distributionmust be in the C++Builder Library Path. 2 Choose Component|Install Packages from the IDE menu, or choose Project|Options and click the Packages tab. 3 A list of available packages appears under “Design packages”.\n• To install a package in the IDE, select the check box next to it.\n• To uninstall a package, deselect its check box.\n• To see a list of components included in an installed package, select the package and click Components.\n• To add a package to the list, click Add and browse in the Add Design Package dialog for the directory where the .BPL file resides (see step 1) Select a BPL file and click Open.\n• To remove a package from the list, select the package and click Remove. 4 Click OK. The components in the package are installed on the Component palette pages specified in the components’\n\n\n\nRegisterComponents procedure, with the names they were assigned in the same procedure. Working with packages and components 10-5 C r e ahttp://www.doksihu ting and editing packages Forrás: New projects are created with all available packages installed, unless you change the default settings. To make the current installation choices into the automatic default for new projects, check the Default check box at the bottom of the dialog box. To remove components from the Component palette without uninstalling a package, select Component|Configure Palette, or select Tools|Environment Options and click the Palette tab. The Palette options tab lists each installed component along with the name of the Component palette page where it appears. Selecting any component and clicking Hide removes the component from the palette. Creating and editing packages Creating a package involves specifying\n• A name for the package.\n• A list of other packages to be required by, or linked to, the new\n\n\n\npackage.\n• A list of unit files to be contained by, or bound into, the package when it is compiled. The package is essentially a wrapper for these source-code units, which contain the functionality of the compiled .BPL The Contains list is where you put the source-code units for custom components that you want to compile into a package. A package is defined by a C++ source (.CPP) file and a project options file whose name ends with the .BPK extension These files are generated by the Package editor Creating a package To create a package, follow the procedure below. Refer to “Understanding the structure of a package” on page 10-9 for more information about the steps outlined here. 1 Choose File|New, select the Package icon, and click OK. 2 The generated package is displayed in the Package editor. 3 The Package editor shows a Requires node and a Contains node for the new package. 4 To add a unit to the Contains list, click the Add to package speed button. In the Add unit page,\n\n\n\ntype a .CPP file name in the Unit file name edit box, or click Browse to browse for the file, and then click OK. The unit you’ve selected appears under the Contains node in the Package editor. You can add additional units by repeating this step. 5 To add a package to the Requires list, click the Add to package speed button. In the Requires page, type a .BPI file name in the Package name edit box, or click Browse to browse for the file, and then click OK. (This adds USEPACKAGE(\"packageName.bpi\") to the CPP file generated in step 1 above) The 10-6 Developer’s Guide Creating and editing packages package you’ve selected appears under the Requires node in the Package editor. You can add additional packages by repeating this step. 6 Click the Options speed button, and decide what kind of package you want to build.\n• To create a design-time only package (a package that cannot be used at runtime), select the Designtime only radio button. (Or add the -Gpd linker switch\n\n\n\nto your BPK file: LFLAGS = . -Gpd )\n• To create a runtime-only package (a package that cannot be installed), select the Runtime only radio button. (Or add the -Gpr linker switch to your BPK file: LFLAGS = . -Gpr )\n• To create a package that is available at both design time and runtime, select the Designtime and runtime radio button. 7 In the Package editor, click the Compile package speed button to compile your package. Editing an existing package There are several ways to open an existing package for editing.\n• Choose File|Open (or File|Reopen) and select a CPP or BPK file.\n• Choose Component|Install Packages, select a package from the Design Packages list, and click the Edit button.\n• When the Package editor is open, select one of the packages in the Requires node, right-click, and choose Open. To edit a package’s description or set usage options, click the Options speed button in the Package editor and select the Description tab. The Project Options dialog has a\n\n\n\nDefault check box in the lower left corner. If you click OK when this box is checked, the options you’ve chosen are saved as default settings for new package projects. To restore the original defaults, delete or rename the DEFAULT.BPK file Package source files and project option files Package source files have the .CPP extension Package project option files are created using XML format and have the .BPK (Borland package) extension Display the package project option file from the Package editor by right-clicking on the Contains or Requires clause and choosing Edit Option Source. Note C++Builder maintains the .BPK file You do not normally need to edit it manually You should make changes using the Packages tab of the Project Options dialog box. Working with packages and components 10-7 C r e ahttp://www.doksihu ting and editing packages Forrás: The project option file for a package called MyPack might look, in part, like this: <MACROS> <VERSION\n\n\n\nvalue=\"BCB.0502\"/> <PROJECT value=\"MyPack.bpl\"/> <OBJFILES value=\"MyPack.obj Unit2obj Unit3obj\"/> <RESFILES value=\"MyPack.res\"/> <IDLFILES value=\"\"/> <IDLGENFILES value=\"\"/> <DEFFILE value=\"\"/> <RESDEPEN value=\"$(RESFILES)\"/> <LIBFILES value=\"\"/> <LIBRARIES value=\"\"/> <SPARELIBS value=\"Vcl50.lib\"/> <PACKAGES value=\"Vcl50.bpi vcldbx50bpi\"/> . . . In this case, MYPACK.CPP would include the following code: USERES(\"MyPack.res\"); USEPACKAGE(\"vcl50.bpi\"); USEPACKAGE(\"vcldbx50.bpi\"); USEUNIT(\"Unit2.cpp\"); USEUNIT(\"Unit3.cpp\"); MyPack’s Contains list includes three units: MyPack itself, Unit2, and Unit3. MyPack’s Requires list includes VCL50 and VCLDBX50. Packaging components If you use the New Component wizard to create components (by choosing\n\n\n\nComponent|New Component), C++Builder inserts the PACKAGE macro where it is needed. But if you have custom components from an older version of C++Builder, you’ll have to add PACKAGE manually in two places. The header-file declaration for a C++Builder component must include the predefined PACKAGE macro after the word class: class PACKAGE MyComponent : . And in the CPP file where the component is defined, include the PACKAGE macro in the declaration of the Register function: void fastcall PACKAGE Register() The PACKAGE macro expands to a statement that allows classes to be imported and exported from the resulting BPL file. 10-8 Developer’s Guide Creating and editing packages Understanding the structure of a package Packages include the following parts:\n• Package name\n• Requires list\n• Contains list Naming packages Package names must be unique within a project. If you name a package STATS, the Package editor generates a source file and project option file for it\n\n\n\ncalled STATS.CPP and STATS.BPK, respectively; the compiler generates an executable, a binary image, and (optionally) a static library called STATS.BPL, STATSBPI, and STATSLIB To use the package in an application, add STATS to the Runtime Packages edit box (after choosing Project|Options and clicking the Packages tab). The Requires list The Requires list specifies other, external packages that are used by the current package. An external package included in the Requires list is automatically linked at compile time into any application that uses both the current package and one of the units contained in the external package. If the unit files contained in your package make references to other packaged units, the other packages should appear in your package’s Requires list or you should add them. If the other packages are omitted from the Requires list, the compiler will import them into your package ‘implicitly contained units’. Note Most packages that you create will require\n\n\n\nVCL50. Any package that depends on VCL units (including SysUtils) must list VCL50, or another package that requires VCL50, in its Requires list. Avoiding circular package references Packages cannot contain circular references in their Requires list. This means that\n• A package cannot reference itself in its own Requires list.\n• A chain of references must terminate without re-referencing any package in the chain. If package A requires package B, then package B cannot require package A; if package A requires package B and package B requires package C, then package C cannot require package A. Handling duplicate package references Duplicate references in a package’s Requires listor in the Runtime Packages edit boxare ignored by the compiler. For programming clarity and readability, however, you should catch and remove duplicate package references. Working with packages and components 10-9 C r e ahttp://www.doksihu ting and editing packages Forrás: The Contains list The\n\n\n\nContains list identifies the unit files to be bound into the package. If you are writing your own package, put your source code in CPP files and include them in the Contains list. Avoiding redundant source code uses A package cannot appear in the Contains list of another package. All units included directly in a package’s Contains list, or included indirectly in any of those units, are bound into the package at compile time. A unit cannot be contained (directly or indirectly) in more than one package used by the same application, including the C++Builder IDE. This means that if you create a package that contains one of the units in VCL50, you won’t be able to install your package in the IDE. To use an already-packaged unit file in another package, put the first package in the second package’s Requires list. Compiling packages You can compile a package from the IDE or from the command line. To recompile a package by itself from the IDE, 1 Choose File|Open, select a package\n\n\n\nsource file or project option file, and click Open. 2 When the editor opens, choose Project|Make or Project|Build. You can insert compiler directives into your package source code. For more information, see “Package-specific compiler directives,” below. If you compile from the command line, several package-specific linker switches are available.For more information, see “Using the command-line compiler and linker” on page 10-12. Package-specific compiler directives The following table lists package-specific compiler directives that you can insert into your source code. Table 10.2 10-10 Package-specific compiler directives Directive Purpose #pragma package(smart init) Assures that packaged units are initialized in the order determined by their dependencies. (Included by default in package source file.) #pragma package(smart init, weak) Packages unit “weakly”. See “Weak packaging” below.(Put directive in unit source file) Developer’s Guide Creating and\n\n\n\nediting packages Weak packaging The #pragma package(smart init, weak) directive affects the way an .OBJ file is stored in a package’s .BPI and BPL files (For information about files generated by the compiler, see “Package files created by a successful compilation” on page 10-12.) If #pragma package(smart init, weak) appears in a unit file, the compiler omits the unit from BPLs when possible, and creates a non-packaged local copy of the unit when it is required by another application or package. A unit compiled with this directive is said to be “weakly packaged”. For example, suppose you’ve created a package called PACK that contains only one unit, UNIT1. Suppose UNIT1 does not use any further units, but it makes calls to RARE.DLL If you put #pragma package(smart init, weak) in UNIT1CPP when you compile your package, UNIT1 will not be included in PACK.BPL; you will not have to distribute copies of RARE.DLL with PACK However, UNIT1 will still be included in PACK.BPI If UNIT1\n\n\n\nis referenced by another package or application that uses PACK, it will be copied from PACK.BPI and compiled directly into the project Now suppose you add a second unit, UNIT2, to PACK. Suppose that UNIT2 uses UNIT1. This time, even if you compile PACK with #pragma package(smart init, weak) in UNIT1.CPP, the compiler will include UNIT1 in PACKBPL But other packages or applications that reference UNIT1 will use the (non-packaged) copy taken from PACK.BPI Note Unit files containing the #pragma package(smart init, weak) directive must not have global variables. #pragma package(smart init, weak) is an advanced feature intended for developers who distribute their BPLs to other C++Builder programmers. It can help you to avoid distribution of infrequently used DLLs, and to eliminate conflicts among packages that may depend on the same external library. For example, C++Builder’s PenWin unit references PENWIN.DLL Most projects don’t use PenWin, and most computers don’t have PENWIN.DLL\n\n\n\ninstalled on them For this reason, the PenWin unit is weakly packaged in VCL50. When you compile a project that uses PenWin and the VCL50 package, PenWin is copied from VCL50.BPI and bound directly into your project; the resulting executable is statically linked to PENWIN.DLL If PenWin were not weakly packaged, two problems would arise. First, VCL50 itself would be statically linked to PENWIN.DLL, and so you could not load it on any computer which didn’t have PENWIN.DLL installed Second, if you tried to create a package that contained PenWin, a compiler error would result because the PenWin unit would be contained in both VCL50 and your package. Thus, without weak packaging, PenWin could not be included in standard distributions of VCL50. Working with packages and components 10-11 C r e ahttp://www.doksihu ting and editing packages Forrás: Using the command-line compiler and linker When you compile from the command line, use the -Tpp linker switch to ensure that the project is\n\n\n\nbuilt as a package. Other package-specific switches are listed in the following table. Table 10.3 Package-specific command-line linker switches Switch Purpose -Tpp Builds the project as a package. Included by default in package project files -Gi Saves the generated BPI file. Included by default in package project files -Gpr Generates a runtime-only package. -Gpd Generates a design-time–only package. -Gl Generates a .LIB file -D “description” Saves the specified description with the package. The -Gpr and -Gpd switches correspond to the Runtime Package and Design Package check boxes on the Description page of the Project Options dialog (available for package projects only); if neither -Gpr nor -Gpd is used, the resulting package works at both design time and runtime. The -D switch corresponds to the Description edit box on the same page. The -Gl switch corresponds to the Generate .LIB File check box on the Linker page of the Project Options dialog Package files\n\n\n\ncreated by a successful compilation To create a package, you compile a source (.CPP) file using a project options file with the .BPK extension The base name of the source file should match the base name of the files generated by the compiler; that is, if the source file is called TRAYPAK.CPP, the project options fileTRAYPAK.BPKshould include <PROJECT value=\"Traypak.bpl\"/> In this case, compiling the project creates a package called TRAYPAK.BPL The following table lists the files produced by the successful compilation of a package. Table 10.4 10-12 Compiled package files File extension Contents BPI An import library. A single BPI (Borland package import library) file is created for each package. The base name for the BPI is the base name of the package source file. OBJ A binary image for a unit file contained in a package. One OBJ is created, when necessary, for each CPP file. BPL The runtime library. This file is a Windows DLL with C++Builder-specific\n\n\n\nfeatures. The base name for the BPL is specified in the package project options file and should match the base name of the package source file. LIB A library for static linking. Generated only if -Gl (Generate LIB File) is selected. Developer’s Guide Deploying packages When compiled, the BPI, BPL, and LIB files are generated by default in the directories specified in Library page of the Tools|Environment Options dialog. You can override the default settings by clicking the Options speed button in the Package editor to display the Project Options dialog; make any changes on the Directories/ Conditionals page. Deploying packages Deploying applications that use packages When distributing an application that uses runtime packages, make sure that your users have the application’s .EXE file as well as all the library (BPL or DLL) files that the application calls. If the library files are in a different directory from the EXE file, they must be accessible through the user’s\n\n\n\nPath. You may want to follow the convention of putting library files in the WindowsSystem directory. If you use InstallShield Express, your installation script can check the user’s system for any packages it requires before blindly reinstalling them. Distributing packages to other developers If you distribute runtime or design-time packages to other C++Builder developers, be sure to supply both .BPI and BPL files as well as any required header files To link components statically into their applicationsthat is, to build applications that don’t use runtime packagesdevelopers will also need .LIB (or OBJ) files for any packages you supply. Package collection files Package collections (.DPC files) offer a convenient way to distribute packages to other developers. Each package collection contains one or more packages, including BPLs and any additional files you want to distribute with them. When a package collection is selected for IDE installation, its constituent files are\n\n\n\nautomatically extracted from their .PCE container; the Installation dialog box offers a choice of installing all packages in the collection or installing packages selectively. To create a package collection, 1 Choose Tools|Package Collection Editor to open the Package Collection editor. 2 Click the Add Package speed button, then select a BPL in the Select Package dialog and click Open. To add more BPLs to the collection, click the Add Package speed button again. A tree diagram on the left side of the Package editor displays the BPLs as you add them. To remove a package, select it and click the Remove Package speed button. Working with packages and components 10-13 D e p http://www.doksihu loying packages Forrás: 3 Select the Collection node at the top of the tree diagram. On the right side of the Package Collection editor, two fields will appear:\n• In the Author/Vendor Name edit box, you can enter optional information about your package collection that will appear in the\n\n\n\nInstallation dialog when users install packages.\n• Under Directory List, list the default directories where you want the files in your package collection to be installed. Use the Add, Edit, and Delete buttons to edit this list. For example, suppose you want all source code files to be copied to the same directory. In this case, you might enter Source as a Directory Name with C:MyPackageSource as the Suggested Path. The Installation dialog box will display C:MyPackageSource as the suggested path for the directory. 4 In addition to BPLs, your package collection can contain .BPI, OBJ, and CPP (unit) files, documentation, and any other files you want to include with the distribution. Ancillary files are placed in file groups associated with specific packages (BPLs); the files in a group are installed only when their associated BPL is installed. To place ancillary files in your package collection, select a BPL in the tree diagram and click the Add File Group speed button; type a name for\n\n\n\nthe file group. Add more file groups, if desired, in the same way When you select a file group, new fields will appear on the right in the Package Collection editor,\n• In the Install Directory list box, select the directory where you want files in this group to be installed. The drop-down list includes the directories you entered under Directory List in step 3, above.\n• Check the Optional Group check box if you want installation of the files in this group to be optional.\n• Under Include Files, list the files you want to include in this group. Use the Add, Delete, and Auto buttons to edit the list. The Auto button allows you to select all files with specified extensions that are listed in the Contains list of the package; the Package Collection editor uses C++Builder’s global Library Path to search for these files. 5 You can select installation directories for the packages listed in the Requires list of any package in your collection. When you select a BPL in the tree diagram,\n\n\n\nfour new fields appear on the right side of the Package Collection editor:\n• In the Required Executables list box, select the directory where you want the .BPL files for packages listed in the Requires list to be installed (The drop-down list includes the directories you entered under Directory List in step 3, above.) The Package Collection Editor searches for these files using C++Builder’s global Library Path and lists them under Required Executable Files.\n• In the Required Libraries list box, select the directory where you want the .OBJ and .BPI files for packages listed in the Requires list to be installed (The drop-down list includes the directories you entered under Directory List in step 3, above.) The Package Collection Editor searches for these files using C++Builder’s global Library Path and lists them under Required Library Files. 10-14 Developer’s Guide Deploying packages 6 To save your package collection source file, choose File|Save. Package collection\n\n\n\nsource files should be saved with the .PCE extension 7 To build your package collection, click the Compile speed button. The Package Collection editor generates a .DPC file with the same name as your source (PCE) file. If you have not yet saved the source file, the editor queries you for a file name before compiling. To edit or recompile an existing .PCE file, select File|Open in the Package Collection editor. Working with packages and components 10-15 10-16 Developer’s Guide Chapter 11 Creating international applications Chapter11 This chapter discusses guidelines for writing applications that you plan to distribute to an international market. By planning ahead, you can reduce the amount of time and code necessary to make your application function in its foreign market as well as in its domestic market. Internationalization and localization To create an application that you can distribute to foreign markets, there are two major steps that need to be performed: •\n\n\n\nInternationalization\n• Localization If your version of C++Builder includes the Integrated Translation Environment, you can use the ITE to manage localization. For more information, see the online Help for the ITE (ITE.hlp) Internationalization Internationalization is the process of enabling your program to work in multiple locales. A locale is the user’s environment, which includes the cultural conventions of the target country as well as the language. Windows supports a large set of locales, each of which is described by a language and country pair. Localization Localization is the process of translating an application to function in a specific locale. In addition to translating the user interface, localization may include functionality customization. For example, a financial application may be modified to be aware of the different tax laws in different countries. Creating international applications 11-1 I n t e http://www.doksihu rnationalizing applications Forrás: \n\n\n\nInternationalizing applications It is not difficult to create internationalized applications. You need to complete the following steps: 1 You must enable your code to handle strings from international character sets. 2 You need to design your user interface so that it can accommodate the changes that result from localization. 3 You need to isolate all resources that need to be localized. Enabling application code You must make sure that the code in your application can handle the strings it will encounter in the various target locales. Character sets The United States edition of Windows uses the ANSI Latin-1 (1252) character set. However, other editions of Windows use different character sets. For example, the Japanese version of Windows uses the Shift-Jis character set (code page 932), which represents Japanese characters as 1- or 2-byte character codes. OEM and ANSI character sets It is sometimes necessary to convert between the Windows character set (ANSI) and the character set\n\n\n\nspecified by the code page of the user’s machine (called the OEM character set). Double byte character sets The ideographic character sets used in Asia cannot use the simple 1:1 mapping between characters in the language and the one byte (8-bit) char type. These languages have too many characters to be represented using the 1-byte char. Instead, characters are represented by a mix of 1- and 2-byte character codes. The first byte of every 2-byte character code is taken from a reserved range that depends on the specific character set. The second byte can sometimes be the same as the character code for a separate 1-byte character, or it can fall in the range reserved for the first byte of 2-byte characters. Thus, the only way to tell whether a particular byte in a string represents a single character or part of a 2-byte character is to read the string, starting at the beginning, parsing it into 2-byte characters when a lead byte from the reserved range is encountered. When writing code\n\n\n\nfor Asian locales, you must be sure to handle all string manipulation using functions that are enabled to parse strings into 1- and 2-byte characters. See “International API” in the online help for a list of the RTL functions that are enabled to work with multibyte characters. Remember that the length of the strings in bytes does not necessarily correspond to the length of the string in characters. Be careful not to truncate strings by cutting a 11-2 Developer’s Guide Internationalizing applications 2-byte character in half. Do not pass characters as a parameter to a function or procedure, since the size of a character can’t be known up front. Instead, always pass a pointer to a character or a string. Wide characters Another approach to working with ideographic character sets is to convert all characters to a wide character encoding scheme such as Unicode. Wide characters are two bytes instead of one, so that the character set can represent many more different\n\n\n\ncharacters. Using a wide character encoding scheme has the advantage that you can make many of the usual assumptions about strings that do not work for MBCS systems. There is a direct relationship between the number of bytes in the string and the number of characters in the string. You do not need to worry about cutting characters in half or mistaking the second half of a character for the start of a different character. The biggest disadvantage of working with wide characters is that Windows 95 only supports a few wide character API function calls. Because of this, the VCL components represent all string values as single byte or MBCS strings. Translating between the wide character system and the MBCS system every time you set a string property or read its value would require tremendous amounts of extra code and slow your application down. However, you may want to translate into wide characters for some special string processing algorithms that need to take advantage of the 1:1 mapping\n\n\n\nbetween characters and WideChars. See “International API” in the online help for a list of the RTL functions that are enabled to work with Unicode characters. Including bi-directional functionality in applications Some languages do not follow the left to right reading order commonly found in western languages, but rather read words right to left and numbers left to right. These languages are termed bi-directional (BiDi) because of this separation. The most common bi-directional languages are Arabic and Hebrew, although other Middle East languages are also bi-directional. TApplication has two properties, BiDiKeyboard and NonBiDiKeyboard, that allow you to specify the keyboard layout. In addition, the VCL supports bi-directional localization through the BiDiMode and ParentBiDiMode properties. The following table lists VCL objects that have these properties: Table 11.1 VCL objects that support BiDi Component palette page VCL object Standard TButton TCheckBox TComboBox TEdit\n\n\n\nTGroupBox TLabel Creating international applications 11-3 I n t e http://www.doksihu rnationalizing applications Forrás: Table 11.1 VCL objects that support BiDi (continued) Component palette page VCL object TListBox TMainMenu TMemo TPanel TPopupMenu TRadioButton TRadioGroup TScrollBar Additional TBitBtn TCheckListBox TDrawGrid TMaskEdit TScrollBox TSpeedButton TStaticLabel TStringGrid Win32 TDateTimePicker THeaderControl TListView TMonthCalendar TPageControl TRichEdit TStatusBar TTabControl Data Controls TDBCheckBox TDBComboBox TDBEdit TDBGrid TDBListBox TDBLookupComboBox TDBLookupListBox TDBMemo TDBRadioGroup TDBRichEdit TDBText QReport TQRDBText TQRExpr TQRLabel TQRMemo TQRSysData 11-4 Developer’s Guide Internationalizing applications Table 11.1 VCL objects that support BiDi (continued) Component palette page VCL object Other classes TApplication (has no ParentBiDiMode) TForm THintWindow (has no ParentBiDiMode) TStatusPanel THeaderSection Notes \n\n\n\nTHintWindow picks up the BiDiMode of the control that activated the hint. Bi-directional properties The objects listed in Table 11.1, “VCL objects that support BiDi,” on page 11-3 have the properties BiDiMode and ParentBiDiMode. These properties, along with TApplication‘s BiDiKeyboard and NonBiDiKeyboard, support bi-directional localization. BiDiMode property The property BiDiMode is a new enumerated type, TBiDiMode, with four states: bdLeftToRight, bdRightToLeft, bdRightToLeftNoAlign, and bdRightToLeftReadingOnly. bdLeftToRight bdLeftToRight draws text using left to right reading order, and the alignment and scroll bars are not changed. For instance, when entering right to left text, such as Arabic or Hebrew, the cursor goes into push mode and the text is entered right to left. Latin text, such as English or French, is entered left to right. bdLeftToRight is the default value. Figure 11.1 TListBox set to bdLeftToRight bdRightToLeft bdRightToLeft draws text using right to let\n\n\n\nreading order, the alignment is changed and the scroll bar is moved. Text is entered as normal for right-to-left languages such as Arabic or Hebrew. When the keyboard is changed to a Latin language, the cursor goes into push mode and the text is entered left-to-right. Figure 11.2 TListBox set to bdRightToLeft Creating international applications 11-5 I n t e http://www.doksihu rnationalizing applications Forrás: bdRightToLeftNoAlign bdRightToLeftNoAlign draws text using right to left reading order, the alignment is not changed, and the scroll bar is moved. Figure 11.3 TListBox set to bdRightToLeftNoAlign bdRightToLeftReadingOnly bdRightToLeftReadingOnly draws text using right to left reading order, and the alignment and scroll bars are not changed. Figure 11.4 TListBox set to bdRightToLeftReadingOnly ParentBiDiMode property ParentBiDiMode is a Boolean property. When True (the default) the control looks to its parent to determine what BiDiMode to use. If the control is a TForm\n\n\n\nobject, the form uses the BiDiMode setting from Application. If all the ParentBiDiMode properties are True, when you change Application’s BiDiMode property, all forms and controls in the project are updated with the new setting. FlipChildren method The FlipChildren method allows you to flip the position of a container control’s children. Container controls are controls that can accept other controls, such as TForm, TPanel, and TGroupbox. FlipChildren has a single boolean parameter, AllLevels When False, only the immediate children of the container control are flipped. When True, all the levels of children in the container control are flipped. C++Builder flips the controls by changing the Left property and the alignment of the control. If a control’s left side is five pixels from the left edge of its parent control, after it is flipped the edit control’s right side is five pixels from the right edge of the parent control. If the edit control is left aligned, calling\n\n\n\nFlipChildren will make the control right aligned. To flip a control at design-time select Edit|Flip Children and select either All or Selected, depending on whether you want to flip all the controls, or just the children of the selected control. You can also flip a control by selecting the control on the form, right-clicking, and selecting Flip Children from the context menu. Note 11-6 Selecting an edit control and issuing a Flip Children|Selected command does nothing. This is because edit controls are not containers Developer’s Guide Internationalizing applications Additional methods There are several other methods useful for developing applications for bi-directional users. Method Description OkToChangeFieldAlignment Used with database controls. Checks to see if the alignment of a control can be changed. DBUseRightToLeftAlignment A wrapper for database controls for checking alignment. ChangeBiDiModeAlignment Changes the alignment parameter passed to it. No check is\n\n\n\ndone for BiDiMode setting, it just converts left alignment into right alignment and vice versa, leaving center-aligned controls alone. IsRightToLeft Returns true if any of the right to left options are selected. If it returns false the control is in left to right mode. UseRightToLeftReading Returns true if the control is using right to left reading. UseRightToLeftAlignment Returns true if the control is using right to left alignment. It can be overriden for customization UseRightToLeftScrollBar Returns true if the control is using a left scroll bar. DrawTextBiDiModeFlags Returns the correct draw text flags for the BiDiMode of the control. DrawTextBiDiModeFlagsReadingOnly Returns the correct draw text flags for the BiDiMode of the control, limiting the flag to its reading order. AddBiDiModeExStyle Adds the appropriate ExStyle flags to the control that is being created. Locale-specific features You can add extra features to your application for specific locales. In\n\n\n\nparticular, for Asian language environments, you may want your application to control the input method editor (IME) that is used to convert the keystrokes typed by the user into character strings. VCL components offer you support in programming the IME. Most windowed controls that work directly with text input have an ImeName property that allows you to specify a particular IME that should be used when the control has input focus. They also provide an ImeMode property that specifies how the IME should convert keyboard input. TWinControl introduces several protected methods that you can use to control the IME from classes you define. In addition, the global Screen variable provides information about the IMEs available on the user’s system. The global Screen variable also provides information about the keyboard mapping installed on the user’s system. You can use this to obtain locale-specific information about the environment in which your application is running. Creating\n\n\n\ninternational applications 11-7 I n t e http://www.doksihu rnationalizing applications Forrás: Designing the user interface When creating an application for several foreign markets, it is important to design your user interface so that it can accommodate the changes that occur during translation. Text All text that appears in the user interface must be translated. English text is almost always shorter than its translations. Design the elements of your user interface that display text so that there is room for the text strings to grow. Create dialogs, menus, status bars, and other user interface elements that display text so that they can easily display longer strings. Avoid abbreviationsthey do not exist in languages that use ideographic characters. Short strings tend to grow in translation more than long phrases. Table 112 provides a rough estimate of how much expansion you should plan for given the length of your English strings: Table 11.2 Estimating string lengths Length of\n\n\n\nEnglish string (in characters) Expected increase 1-5 100% 6-12 80% 13-20 60% 21-30 40% 31-50 20% over 50 10% Graphic images Ideally, you will want to use images that do not require translation. Most obviously, this means that graphic images should not include text, which will always require translation. If you must include text in your images, it is a good idea to use a label object with a transparent background over an image rather than including the text as part of the image. There are other considerations when creating graphic images. Try to avoid images that are specific to a particular culture. For example, mailboxes in different countries look very different from each other. Religious symbols are not appropriate if your application is intended for countries that have different dominant religions. Even color can have different symbolic connotations in different cultures. Formats and sort order The date, time, number, and currency formats used in your application\n\n\n\nshould be localized for the target locale. If you use only the Windows formats, there is no need to translate formats, as these are taken from the user’s Windows Registry. However, 11-8 Developer’s Guide Internationalizing applications if you specify any of your own format strings, be sure to declare them as resourced constants so that they can be localized. The order in which strings are sorted also varies from country to country. Many European languages include diacritical marks that are sorted differently, depending on the locale. In addition, in some countries, 2-character combinations are treated as a single character in the sort order. For example, in Spanish, the combination ch is sorted like a single unique letter between c and d. Sometimes a single character is sorted as if it were two separate characters, such as the German eszett. Keyboard mappings Be careful with key-combinations shortcut assignments. Not all the characters available on the US keyboard are\n\n\n\neasily reproduced on all international keyboards. Where possible, use number keys and function keys for shortcuts, as these are available on virtually all keyboards. Isolating resources The most obvious task in localizing an application is translating the strings that appear in the user interface. To create an application that can be translated without altering code everywhere, the strings in the user interface should be isolated into a single module. C++Builder automatically creates a DFM file that contains the resources for your menus, dialogs, and bitmaps. In addition to these obvious user interface elements, you will need to isolate any strings, such as error messages, that you present to the user. String resources are not included in the .DFM file but you can isolate them into an RC file Creating resource DLLs Isolating resources simplifies the translation process. The next level of resource separation is the creation of a resource DLL. A resource DLL contains all the resources\n\n\n\nand only the resources for a program. Resource DLLs allow you to create a program that supports many translations simply by swapping the resource DLL. Use the Resource DLL wizard to create a resource DLL for your program. The Resource DLL wizard requires an open, saved, compiled project. It will create an RC file that contains the string tables from used RC files and resourcestring strings of the project, and generate a project for a resource only DLL that contains the relevant forms and the created RES file. The RES file is compiled from the new RC file You should create a resource DLL for each translation you want to support. Each resource DLL should have a file name extension specific to the target locale. The first two characters indicate the target language, and the third character indicates the Creating international applications 11-9 I n t e http://www.doksihu rnationalizing applications Forrás: country of the locale. If you use the Resource DLL wizard, this is handled for\n\n\n\nyou Otherwise, use the following code obtain the locale code for the target translation: /* This callback fills a listbox with the strings and their associated languages and countries*/ BOOL stdcall EnumLocalesProc(char* lpLocaleString) { AnsiString LocaleName, LanguageName, CountryName; LCID lcid; lcid = StrToInt(\"$\" + AnsiString(lpLocaleString)); LocaleName = GetLocaleStr(lcid, LOCALE SABBREVLANGNAME, \"\"); LanguageName = GetLocaleStr(lcid, LOCALE SNATIVELANGNAME, \"\"); CountryName = GetLocaleStr(lcid, LOCALE SNATIVECTRYNAME, \"\"); if (lstrlen(LocaleName.c str()) > 0) Form1->ListBox1->Items->Add(LocaleName + \":\" + LanguageName + \"-\" + CountryName); return TRUE; } /* This call causes the callback to execute for every locale / EnumSystemLocales((LOCALE ENUMPROC)EnumLocalesProc, LCID SUPPORTED); Using resource DLLs The executable, DLLs, and packages that make up your application contain all the necessary resources.\n\n\n\nHowever, to replace those resources by localized versions, you need only ship your application with localized resource DLLs that have the same name as your EXE, DLL, or BPL files. When your application starts up, it checks the locale of the local system. If it finds any resource DLLs with the same name as the EXE, DLL, or BPL files it is using, it checks the extension on those DLLs. If the extension of the resource module matches the language and country of the system locale, your application will use the resources in that resource module instead of the resources in the executable, DLL, or package. If there is not a resource module that matches both the language and the country, your application will try to locate a resource module that matches just the language. If there is no resource module that matches the language, your application will use the resources compiled with the executable, DLL, or package. If you want your application to use a different resource module than the one that\n\n\n\nmatches the locale of the local system, you can set a locale override entry in the Windows registry. Under the HKEY CURRENT USERSoftwareBorlandLocales key, add your application’s path and file name as a string value and set the data value to the extension of your resource DLLs. At startup, the application will look for resource DLLs with this extension before trying the system locale. Setting this registry entry allows you to test localized versions of your application without changing the locale on your system. 11-10 Developer’s Guide Internationalizing applications For example, the following procedure can be used in an install or setup program to set the registry key value that indicates the locale to use when loading C++Builder applications: void SetLocalOverrides(char* FileName, char LocaleOverride) { HKEY Key; const char* LocaleOverrideKey = \"Software\\Borland\\Locales\"; if (RegOpenKeyEx(HKEY CURRENT USER, LocaleOverrideKey, 0, KEY ALL ACCESS, &Key) == ERROR\n\n\n\nSUCCESS) { if (lstrlen(LocaleOverride) == 3) RegSetValueEx(Key, FileName, 0, REG SZ, (const BYTE*)LocaleOverride, 4); RegCloseKey(Key); } } Within your application, use the global FindResourceHInstance function to obtain the handle of the current resource module. For example: LoadString(FindResourceHInstance(HInstance), IDS AmountDueName, szQuery, sizeof(szQuery)); You can ship a single application that adapts itself automatically to the locale of the system it is running on, simply by providing the appropriate resource DLLs. Dynamic switching of resource DLLs In addition to locating a resource DLL at application startup, it is possible to switch resource DLLs dynamically at runtime. To add this functionality to your own applications, you need to include the ReInit unit in your project. (ReInit is located in the Richedit sample in the Demos directory.) To switch languages, you should call LoadResourceModule, passing the LCID for the new language, and then call ReinitializeForms. For\n\n\n\nexample, the following code switches the interface language to French: const FRENCH = (SUBLANG FRENCH << 10) | LANG FRENCH; if (LoadNewResourceModule(FRENCH)) ReinitializeForms(); The advantage of this technique is that the current instance of the application and all of its forms are used. It is not necessary to update the registry settings and restart the application or reacquire resources required by the application, such as logging in to database servers. When you switch resource DLLs the properties specified in the new DLL overwrite the properties in the running instances of the forms. Note Any changes made to the form properties at runtime will be lost. Once the new DLL is loaded, default values are not reset. Avoid code that assumes that the form objects are reinitialized to the their startup state, apart from differences due to localization. Creating international applications 11-11 L o c ahttp://www.doksihu lizing applications Forrás: Localizing applications Once\n\n\n\nyour application is internationalized, you can create localized versions for the different foreign markets in which you want to distribute it. Localizing resources Ideally, your resources have been isolated into a resource DLL that contains DFM files and a RES file. You can open your forms in the IDE and translate the relevant properties. Note In a resource DLL project, you cannot add or delete components. It is possible, however, to change properties in ways that could cause runtime errors, so be careful to modify only those properties that require translation. To avoid mistakes, you can configure the Object Inspector to display only localizable properties; to do so, right-click in the Object Inspector and use the View menu to filter out unwanted property categories. You can open the RC file and translate relevant strings. Use the StringTable editor by opening the RC file from the Project Manager. 11-12 Developer’s Guide Chapter 12 Deploying applications Chapter12 Once\n\n\n\nyour C++Builder application is up and running, you can deploy it. That is, you can make it available for others to run. A number of steps must be taken to deploy an application to another computer so that the application is completely functional. The steps required by a given application vary, depending on the type of application. The following sections describe those steps for deploying applications:\n• \n• \n• \n• \n• Deploying general applications Deploying database applications Deploying Web applications Programming for varying host environments Software license requirements Deploying general applications Beyond the executable file, an application may require a number of supporting files, such as DLLs, package files, and helper applications. In addition, the Windows registry may need to contain entries for an application, from specifying the location of supporting files to simple program settings. The process of copying an application’s files to a computer and making any\n\n\n\nneeded registry settings can be automated by an installation program, such as InstallShield Express. These are the main deployment concerns common to nearly all types of applications:\n• Using installation programs\n• Identifying application files C++Builder applications that access databases and those that run across the Web require additional installation steps beyond those that apply to general applications. For additional information on installing database applications, see “Deploying database applications” on page 12-4. For more information on installing Web applications, see “Deploying Web applications” on page 12-6. For more information on installing ActiveX controls, see “Deploying an ActiveX control on the Web” on Deploying applications 12-1 D e p http://www.doksihu loying general applications Forrás: page 37-16. For information on deploying CORBA applications, see the VisiBroker Installation and Administration Guide Using installation programs Simple\n\n\n\nC++Builder applications that consist of only an executable file are easy to install on a target computer. Just copy the executable file onto the computer However, more complex applications that comprise multiple files require more extensive installation procedures. These applications require dedicated installation programs. Setup toolkits automate the process of creating installation programs, often without needing to write any code. Installation programs created with Setup toolkits perform various tasks inherent to installing C++Builder applications, including: copying the executable and supporting files to the host computer, making Windows registry entries, and installing the Borland Database Engine for database applications. InstallShield Express is a setup toolkit that is bundled with C++Builder. InstallShield Express is certified for use with C++Builder and the Borland Database Engine. InstallShield Express is not automatically installed when C++Builder is installed, and must be\n\n\n\nmanually installed to be used to create installation programs. Run the installation program from the C++Builder CD to install InstallShield Express. For more information on using InstallShield Express to create installation programs, see the InstallShield Express online help. Other setup toolkits are available, however, you should only use those certified to deploy the Borland Database Engine. Identifying application files Besides the executable file, a number of other files may need to be distributed with an application.\n• Application files\n• Package files\n• ActiveX controls Application files The following types of files may need to be distributed with an application. Table 12.1 12-2 Application files Type File name extension Program files .EXE and DLL Package files .BPL and BCP Help files .HLP, CNT, and TOC (if used) ActiveX files .OCX (sometimes supported by a DLL) Local table files .DBF, MDX, DBT, NDX, DB, PX, Y*, .X*, .MB, VAL, QBE Developer’s Guide \n\n\n\nDeploying general applications Package files If the application uses runtime packages, those package files need to be distributed with the application. InstallShield Express handles the installation of package files the same as DLLs, copying the files and making necessary entries in the Windows registry. Borland recommends installing the runtime package files supplied by Borland in the WindowsSystem directory. This serves as a common location so that multiple applications would have access to a single instance of the files. For packages you created, it is recommended that you install them in the same directory as the application. Only the BPL files need to be distributed If you are distributing packages to other developers, supply both the .BPL and the .BCP files ActiveX controls Certain components bundled with C++Builder are ActiveX controls. The component wrapper is linked into the application’s executable file (or a runtime package), but the .OCX file for the component also\n\n\n\nneeds to be deployed with the application These components include\n• \n• \n• \n• \n• Chart FX, copyright SoftwareFX Inc. VisualSpeller Control, copyright Visual Components, Inc. Formula One (spreadsheet), copyright Visual Components, Inc. First Impression (VtChart), copyright Visual Components, Inc. Graph Custom Control, copyright Bits Per Second Ltd. ActiveX controls of your own creation need to be registered on the deployment computer before use. Installation programs such as InstallShield Express automate this registration process. To manually register an ActiveX control, use the TRegSvr demo application or the Microsoft utility REGSRV32.EXE (not included with all Windows versions). DLLs that support an ActiveX control also need to be distributed with an application. Helper applications Helper applications are separate programs without which your C++Builder application would be partially or completely unable to function. Helper applications may be those supplied with Windows,\n\n\n\nby Borland, or they might be third-party products. An example of a helper application is the InterBase utility program Server Manager, which administers InterBase databases, users, and security. If an application depends on a helper program, be sure to deploy it with your application, where possible. Distribution of helper programs may be governed by redistribution license agreements. Consult the documentation for the helper for specific information. DLL locations You can install .DLL files used only by a single application in the same directory as the application. DLLs that will be used by a number of applications should be installed in a location accessible to all of those applications. A common convention for locating such community DLLs is to place them either in the Windows or the Deploying applications 12-3 D e p http://www.doksihu loying database applications Forrás: WindowsSystem directory. A better way is to create a dedicated directory for the common .DLL files, similar\n\n\n\nto the way the Borland Database Engine is installed Deploying database applications Applications that access databases involve special installation considerations beyond copying the application’s executable file onto the host computer. Database access is most often handled by a separate database engine, the files of which cannot be linked into the application’s executable file. The data files, when not created beforehand, must be made available to the application. Multi-tier database applications require even more specialized handling on installation, because the files that make up the application are typically located on multiple computers. Two ways of including database access are\n• Providing the database engine\n• Multi-tiered Distributed Application Services (MIDAS) Providing the database engine Database access for an application is provided by various database engines. An application can use the Borland Database Engine or a third-party database engine. SQL Links is\n\n\n\nprovided (not available in all versions) to enable native access to SQL database systems. The following sections describe installation of the database access elements of an application:\n• Borland Database Engine\n• Third-party database engines\n• SQL Links Borland Database Engine For standard C++Builder data components to have database access, the Borland Database Engine (BDE) must be present and accessible. See BDEDEPLOYTXT for specific rights and limitations on redistributing the BDE. Borland recommends use of InstallShield Express (or other certified installation program) for installing the BDE. InstallShield Express will create the necessary registry entries and define any aliases the application may require. Using a certified installation program to deploy the BDE files and subsets is important because:\n• Improper installation of the BDE or BDE subsets can cause other applications using the BDE to fail. Such applications include not only Borland products, but many\n\n\n\nthird-party programs that use the BDE.\n• Under Windows 95 and Windows NT, BDE configuration information is stored in the Windows registry instead of .INI files, as was the case under 16-bit Windows Making the correct entries and deletions for install and uninstall is a complex task. It is possible to install only as much of the BDE as an application actually needs. For instance, if an application only uses Paradox tables, it is only necessary to install that 12-4 Developer’s Guide Deploying database applications portion of the BDE required to access Paradox tables. This reduces the disk space needed for an application. Certified installation programs, like InstallShield Express, are capable of performing partial BDE installations. Be sure to leave BDE system files that are not used by the deployed application, but that are needed by other programs. Third-party database engines You can use third-party database engines to provide database access for C++Builder applications.\n\n\n\nConsult the documentation or vendor for the database engine regarding redistribution rights, installation, and configuration. SQL Links SQL Links provides the drivers that connect an application (through the Borland Database Engine) with the client software for an SQL database. See DEPLOYTXT for specific rights and limitations on redistributing SQL Links. As is the case with the Borland Database Engine (BDE), SQL Links must be deployed using InstallShield Express (or other certified installation program). Note SQL Links only connects the BDE to the client software, not to the SQL database itself. It is still necessary to install the client software for the SQL database system used. See the documentation for the SQL database system or consult the vendor that supplies it for more information on installing and configuring client software. Table 12.2 shows the names of the driver and configuration files SQL Links uses to connect to the different SQL database systems. These files come\n\n\n\nwith SQL Links and are redistributable in accordance with the C++Builder license agreement. Table 12.2 SQL database client software files Vendor Redistributable files Oracle 7 SQLORA32.DLL and SQL ORACNF Oracle8 SQLORA8.DLL and SQL ORA8CNF Sybase Db-Lib SQLSYB32.DLL and SQL SYBCNF Sybase Ct-Lib SQLSSC32.DLL and SQL SSCCNF Microsoft SQL Server SQLMSS32.DLL and SQL MSSCNF Informix 7 SQLINF32.DLL and SQL INFCNF Informix 9 SQLINF9.DLL and SQL INF9CNF DB/2 SQLDB232.DLL and SQL DB2CNF InterBase SQLINT32.DLL and SQL INTCNF Install SQL Links using InstallShield Express or other certified installation program. For specific information concerning the installation and configuration of SQL Links, see the help file SQLLNK32.HLP, by default installed into the main BDE directory Deploying applications 12-5 D e p http://www.doksihu loying Web applications Forrás: Multi-tiered Distributed Application Services (MIDAS) Multi-tiered Distributed Application Services (MIDAS)\n\n\n\nprovides multi-tier database capability to C++Builder applications. Install MIDAS along with a multi-tier application using InstallShield Express (or other Borland-certified installation scripting utility). See the text file DEPLOYTXT (found in the main C++Builder directory) for details on the MIDAS files that need to be redistributed with an application. Also see REMOTETXT for related information on what MIDAS files can be redistributed and how. Deploying Web applications Some C++Builder applications are designed to be run over the World Wide Web, such as those in the form of Server-side Extension (ISAPI) DLLs, CGI applications, and ActiveForms. The steps for installing Web applications are the same as those for general applications, except the application’s files are deployed on the Web server. For information on installing general applications, see “Deploying general applications” on page 12-1. Here are some special considerations for deploying Web applications:\n• For\n\n\n\ndatabase applications, the Borland Database Engine (or alternate database engine) is installed along with the application files on the Web server.\n• Security for the directories must not be so high that access to application files, the BDE, or database files is not possible.\n• The directory containing an application must have read and execute attributes.\n• The application should not use hard-coded paths for accessing database or other files.\n• The location of an ActiveX control is indicated by the CODEBASE parameter of the <OBJECT> HTML tag. Programming for varying host environments Due to the nature of the Windows environment, there are a number of factors that vary with user preference or configuration. The following factors can affect an application deployed to another computer:\n• \n• \n• \n• \n• 12-6 Screen resolutions and color depths Fonts Windows versions Helper applications DLL locations Developer’s Guide Programming for varying host environments \n\n\n\nScreen resolutions and color depths The size of the Windows desktop and number of available colors on a computer is configurable and dependent on the hardware installed. These attributes are also likely to differ on the deployment computer compared to those on the development computer. An application’s appearance (window, object, and font sizes) on computers configured for different screen resolutions can be handled in various ways:\n• Design the application for the lowest resolution users will have (typically, 640x480). Take no special actions to dynamically resize objects to make them proportional to the host computer’s screen display. Visually, objects will appear smaller the higher the resolution is set.\n• Design using any screen resolution on the development computer and, at runtime, dynamically resize all forms and objects proportional to the difference between the screen resolutions for the development and deployment computers (a screen resolution difference ratio). •\n\n\n\nDesign using any screen resolution on the development computer and, at runtime, dynamically resize only the application’s forms. Depending on the location of visual controls on the forms, this may require the forms be scrollable for the user to be able to access all controls on the forms. Considerations when not dynamically resizing If the forms and visual controls that make up an application are not dynamically resized at runtime, design the application’s elements for the lowest resolution. Otherwise, the forms of an application run on a computer configured for a lower screen resolution than the development computer may overlap the boundaries of the screen. For example, if the development computer is set up for a screen resolution of 1024x768 and a form is designed with a width of 700 pixels, not all of that form will be visible within the Windows desktop on a computer configured for a 640x480 screen resolution. Considerations when dynamically resizing forms and controls If the\n\n\n\nforms and visual controls for an application are dynamically resized, accommodate all aspects of the resizing process to ensure optimal appearance of the application under all possible screen resolutions. Here are some factors to consider when dynamically resizing the visual elements of an application:\n• The resizing of forms and visual controls is done at a ratio calculated by comparing the screen resolution of the development computer to that of the computer onto which the application installed. Use a constant to represent one dimension of the screen resolution on the development computer: either the height or the width, in pixels. Retrieve the same dimension for the user’s computer at runtime using the TScreen::Height or the TScreen::Width property. Divide the value for the development computer by the value for the user’s computer to derive the difference ratio between the two computers’ screen resolutions. Deploying applications 12-7 P r o ghttp://www.doksihu ramming for\n\n\n\nvarying host environments Forrás:\n• Resize the visual elements of the application (forms and controls) by reducing or increasing the size of the elements and their positions on forms. This resizing is proportional to the difference between the screen resolutions on the development and user computers. Resize and reposition visual controls on forms automatically by setting the TCustomForm::Scaled property to true and calling the TWincontrol::ScaleBy method. The ScaleBy method does not change the form’s height and width, though. Do this manually by multiplying the current values for the Height and Width properties by the screen resolution difference ratio.\n• The controls on a form can be resized manually, instead of automatically with the TWincontrol::ScaleBy method, by referencing each visual control in a loop and setting its dimensions and position. The Height and Width property values for visual controls are multiplied by the screen resolution difference ratio. Reposition\n\n\n\nvisual controls proportional to screen resolution differences by multiplying the Top and Left property values by the same ratio.\n• If an application is designed on a computer configured for a higher screen resolution than that on the user’s computer, font sizes will be reduced in the process of proportionally resizing visual controls. If the size of the font at design time is too small, the font as resized at runtime may be unreadable. For example, the default font size for a form is 8. If the development computer has a screen resolution of 1024x768 and the user’s computer 640x480, visual control dimensions will be reduced by a factor of 0.625 (640 / 1024 = 0625) The original font size of 8 is reduced to 5 (8 * 0.625 = 5) Text in the application appears jagged and unreadable as Windows displays it in the reduced font size.\n• Some visual controls, such as TLabel and TEdit, dynamically resize when the size of the font for the control changes. This can affect deployed applications\n\n\n\nwhen forms and controls are dynamically resized. The resizing of the control due to font size changes are in addition to size changes due to proportional resizing for screen resolutions. This effect is offset by setting the AutoSize property of these controls to false.\n• Avoid making use of explicit pixel coordinates, such as when drawing directly to a canvas. Instead, modify the coordinates by a ratio proportionate to the screen resolution difference ratio between the development and user computers. For example, if the application draws a rectangle to a canvas ten pixels high by twenty wide, instead multiply the ten and twenty by the screen resolution difference ratio. This ensures that the rectangle visually appears the same size under different screen resolutions. Accommodating varying color depths To account for all deployment computers not being configured with the same color availability, the safest way is to use graphics with the least possible number of colors. This is\n\n\n\nespecially true for control glyphs, which should typically use 16-color graphics. For displaying pictures, either provide multiple copies of the images in different resolutions and color depths or explain in the application the minimum resolution and color requirements for the application. 12-8 Developer’s Guide Programming for varying host environments Fonts Windows comes with a standard set of TrueType and raster fonts. When designing an application to be deployed on other computers, realize that not all computers will have fonts outside the standard Windows set. Text components used in the application should all use fonts that are likely to be available on all deployment computers. When use of a nonstandard font is absolutely necessary in an application, you need to distribute that font with the application. Either the installation program or the application itself must install the font on the deployment computer. Distribution of third-party fonts may be subject to\n\n\n\nlimitations imposed by the font creator. Windows has a safety measure to account for attempts to use a font that does not exist on the computer. It substitutes another, existing font that it considers the closest match. While this may circumvent errors concerning missing fonts, the end result may be a degradation of the visual appearance of the application. It is better to prepare for this eventuality at design time. To make a nonstandard font available to an application, use the Windows API functions AddFontResource and DeleteFontResource. Deploy the FOT file for the nonstandard font with the application. Windows versions When using Windows API functions or accessing areas of the Windows operating system from an application, there is the possibility that the function, operation, or area may not be available on computers with different versions of Windows. For example, Services are only pertinent to the Windows NT operating system. If an application is to act as a Service or interact\n\n\n\nwith one, this would fail if the application is installed under Windows 95. To account for this possibility, you have a few options:\n• Specify in the application’s system requirements the versions of Windows on which the application can run. It is the user’s responsibility to install and use the application only under compatible Windows versions.\n• Check the version of Windows as the application is installed. If an incompatible version of Windows is present, either halt the installation process or at least warn the installer of the problem.\n• Check the Windows version at runtime, just prior to executing an operation not applicable to all versions. If an incompatible version of Windows is present, abort the process and alert the user. Alternately, provide different code to run dependent on different versions of Windows. Some operations are performed differently in Windows 95 than in Windows NT. Use the Windows API function GetVersionEx to determine the Windows version. \n\n\n\nDeploying applications 12-9 S o f thttp://www.doksihu ware license requirements Forrás: Software license requirements The distribution of some files associated with C++Builder applications is subject to limitations or cannot be redistributed at all. The following documents describe the legal stipulations regarding the distribution of these files:\n• \n• \n• \n• DEPLOY.TXT README.TXT No-nonsense license agreement Third-party product documentation DEPLOY.TXT DEPLOY.TXT covers the some of the legal aspects of distributing of various components and utilities, and other product areas that can be part of or associated with a C++Builder application. DEPLOYTXT is a text file installed in the main C++Builder directory. The topics covered include\n• \n• \n• \n• \n• \n• \n• .EXE, DLL, and BPL files Components and design-time packages Borland Database Engine (BDE) ActiveX controls Sample Images Multi-tiered Distributed Application Services (MIDAS) SQL Links README.TXT README.TXT\n\n\n\ncontains last minute information about C++Builder, possibly including information that could affect the redistribution rights for components, or utilities, or other product areas. READMETXT is a Windows help file installed into the main C++Builder directory. No-nonsense license agreement The C++Builder no-nonsense license agreement, a printed document, covers other legal rights and obligations concerning C++Builder. Third-party product documentation Redistribution rights for third-party components, utilities, helper applications, database engines, and other products are governed by the vendor supplying the product. Consult the documentation for the product or the vendor for information regarding the redistribution of the product with C++Builder applications prior to distribution. 12-10 Developer’s Guide Part II Developing database applications Part II The chapters in “Developing Database Applications” present concepts and skills necessary for creating C++Builder\n\n\n\ndatabase applications. Note The level of support for building database applications varies depending on your version of C++Builder. In particular, you must have the Enterprise edition to develop multi-tier database applications or to use client datasets. Developing database applications Chapter 13 Designing database applications Chapter13 Database applications allow users to interact with information that is stored in databases. Databases provide structure for the information, and allow it to be shared among different applications. C++Builder provides support for relational database applications. Relational databases organize information into tables, which contain rows (records) and columns (fields). These tables can be manipulated by simple operations known as the relational calculus. When designing a database application, you must understand how the data is structured. Based on that structure, you can then design a user interface to display data to the user and allow the\n\n\n\nuser to enter new information or modify existing data. This chapter introduces some common considerations for designing a database application and the decisions involved in designing a user interface. Using databases The components on the Data Access page, the ADO page, or the InterBase page of the Component palette allow your application to read from and write to databases. The components on the Data Access page use the Borland Database Engine (BDE) to access database information which they make available to the data-aware controls in your user interface. The ADOExpress components on the ADO page use ActiveX Data Objects (ADO) to access the database information through OLEDB. The InterBase Express components on the InterBase page access an InterBase database directly. Depending on your version of C++Builder, the BDE includes drivers for different types of databases. While all types of databases contain tables which store information, different types support additional features such\n\n\n\nas\n• \n• \n• \n• Database security Transactions Data dictionary Referential integrity, stored procedures, and triggers Designing database applications 13-1 U s i nhttp://www.doksihu g databases Forrás: Types of databases You can connect to different types of databases, depending on what drivers you have installed with the BDE or ADO. These drivers may connect your application to local databases such as Paradox, Access, and dBASE or remote database servers like Microsoft SQL Server, Oracle, and Informix. Similarly, the InterBase Express components can access either a local or remote version of InterBase. Note Different versions of C++Builder come with the components that use these drivers (BDE or ADO), or with the InterBase Express components. Choosing what type of database to use depends on several factors. Your data may already be stored in an existing database. If you are creating the tables of information your application uses, you may want to consider the following\n\n\n\nquestions.\n• How much data will the tables hold?\n• How many users will be sharing these tables?\n• What type of performance (speed) do you require from the database? Local databases Local databases reside on your local drive or on a local area network. They have proprietary APIs for accessing the data. Often, they are dedicated to a single system When they are shared by several users, they use file-based locking mechanisms. Because of this, they are sometimes called file-based databases. Local databases can be faster than remote database servers because they often reside on the same system as the database application. Because they are file-based, local databases are more limited than remote database servers in the amount of data they can store. Therefore, in deciding whether to use a local database, you must consider how much data the tables are expected to hold. Applications that use local databases are called single-tiered applications because the application and the database\n\n\n\nshare a single file system. Examples of local databases include Paradox, dBASE, FoxPro, and Access. Remote database servers Remote database servers usually reside on a remote machine. They use Structured Query Language (SQL) to enable clients to access the data. Because of this, they are sometimes called SQL servers. (Another name is Remote Database Management system, or RDBMS.) In addition to the common commands that make up SQL, most remote database servers support a unique “dialect” of SQL. Remote database servers are designed for access by several users at the same time. Instead of a file-based locking system such as those employed by local databases, they provide more sophisticated multi-user support, based on transactions. Remote database servers hold more data than local databases. Sometimes, the data from a remote database server does not even reside on a single machine, but is distributed over several servers. 13-2 Developer’s Guide Using databases Applications\n\n\n\nthat use remote database servers are called two-tiered applications or multi-tiered applications because the application and the database operate on independent systems (or tiers). Examples of SQL servers include InterBase, Oracle, Sybase, Informix, Microsoft SQL server, and DB2. Database security Databases often contain sensitive information. Different databases provide security schemes for protecting that information. Some databases, such as Paradox and dBASE, only provide security at the table or field level. When users try to access protected tables, they are required to provide a password. Once users have been authenticated, they can see only those fields (columns) for which they have permission. Most SQL servers require a password and user name to use the database server at all. Once the user has logged in to the database, that username and password determine which tables can be used. For information on providing passwords to SQL servers when using the BDE, see “Controlling\n\n\n\nserver login” on page 18-6. For information on providing this information when using ADO, see “Controlling the connection login” on page 24-7. For information on providing this information when using the InterBase direct access components, see the OnLogin event of TIBDatabase. When designing database applications, you must consider what type of authentication is required by your database server. If you do not want your users to have to provide a password, you must either use a database that does not require one or you must provide the password and username to the server programmatically. When providing the password programmatically, care must be taken that security can’t be breached by reading the password from the application. If you are requiring your user to supply a password, you must consider when the password is required. If you are using a local database but intend to scale up to a larger SQL server later, you may want to prompt for the password before you access the\n\n\n\ntable, even though it is not required until then. If your application requires multiple passwords because you must log in to several protected systems or databases, you can have your users provide a single master password which is used to access a table of passwords required by the protected systems. The application then supplies passwords programmatically, without requiring the user to provide multiple passwords. In multi-tiered applications, you may want to use a different security model altogether. You can use HTTPs or MTS to control access to middle tiers, and let the middle tiers handle all details of logging into database servers. Transactions A transaction is a group of actions that must all be carried out successfully on one or more tables in a database before they are committed (made permanent). If any of the actions in the group fails, then all actions are rolled back (undone). Designing database applications 13-3 U s i nhttp://www.doksihu g databases Forrás: \n\n\n\nTransactions protect against hardware failures that occur in the middle of a database command or set of commands. They also form the basis of multi-user concurrency control on SQL servers. When each user interacts with the database only through transactions, one user’s commands can’t disrupt the unity of another user’s transaction. Instead, the SQL server schedules incoming transactions, which either succeed as a whole or fail as a whole. Although transaction support is not part of most local databases, the BDE drivers provide limited transaction support for some of these databases. For SQL servers and ODBC-compliant databases, the database transaction support is provided by the component that represents the database connection. In multi-tiered applications, you can create transactions that include actions other than database operations or that span multiple databases. For details on using transactions in BDE-based database applications, see “Using transactions” on page 14-5.\n\n\n\nFor details on using transactions in ADO-based database applications, see “Working with (connection) transactions” on page 24-10. For details on using transactions in multi-tiered applications, see “Managing transactions in multi-tiered applications” on page 15-21. For details on using transactions in applications that use the InterBase direct access components, see the online help for the TIBTransaction component. Data Dictionary When you use the BDE to access your data, your application has access to the Data Dictionary. The Data Dictionary provides a customizable storage area, independent of your applications, where you can create extended field attribute sets that describe the content and appearance of data. For example, if you frequently develop financial applications, you may create a number of specialized field attribute sets describing different display formats for currency. When you create datasets for your application at design time, rather than using the Object\n\n\n\nInspector to set the currency fields in each dataset by hand, you can associate those fields with an extended field attribute set in the data dictionary. Using the data dictionary ensures a consistent data appearance within and across the applications you create. In a client/server environment, the Data Dictionary can reside on a remote server for additional sharing of information. To learn how to create extended field attribute sets from the Fields editor at design time, and how to associate them with fields throughout the datasets in your application, see “Creating attribute sets for field components” on page 20-14. To learn more about creating a data dictionary and extended field attributes with the SQL and Database Explorers, see their respective online help files. 13-4 Developer’s Guide Using databases A programming interface to the Data Dictionary is available in the drintf header file (located in the includeVCL directory). This interface supplies the following\n\n\n\nmethods: Table 13.1 Data Dictionary interface Routine Use DictionaryActive Indicates if the data dictionary is active. DictionaryDeactivate Deactivates the data dictionary. IsNullID Indicates whether a given ID is a null ID FindDatabaseID Returns the ID for a database given its alias. FindTableID Returns the ID for a table in a specified database. FindFieldID Returns the ID for a field in a specified table. FindAttrID Returns the ID for a named attribute set. GetAttrName Returns the name an attribute set given its ID. GetAttrNames Executes a callback for each attribute set in the dictionary. GetAttrID Returns the ID of the attribute set for a specified field. NewAttr Creates a new attribute set from a field component. UpdateAttr Updates an attribute set to match the properties of a field. CreateField Creates a field component based on stored attributes. UpdateField Changes the properties of a field to match a specified attribute set. AssociateAttr \n\n\n\nAssociates an attribute set with a given field ID. UnassociateAttr Removes an attribute set association for a field ID. GetControlClass Returns the control class for a specified attribute ID. QualifyTableName Returns a fully qualified table name (qualified by user name). QualifyTableNameByName Returns a fully qualified table name (qualified by user name). HasConstraints Indicates whether the dataset has constraints in the dictionary. UpdateConstraints Updates the imported constraints of a dataset. UpdateDataset Updates a dataset to the current settings and constraints in the dictionary. Referential integrity, stored procedures, and triggers All relational databases have certain features in common that allow applications to store and manipulate data. In addition, databases often provide other, database-specific, features that can prove useful for ensuring consistent relationships between the tables in a database. These include\n• Referential integrity. Referential\n\n\n\nintegrity provides a mechanism to prevent master/detail relationships between tables from being broken. When the user attempts to delete a field in a master table which would result in orphaned detail records, referential integrity rules prevent the deletion or automatically delete the orphaned detail records. Designing database applications 13-5 D a t ahttp://www.doksihu base architecture Forrás:\n• Stored procedures. Stored procedures are sets of SQL statements that are named and stored on an SQL server. Stored procedures usually perform common database-related tasks on the server, and return sets of records (datasets).\n• Triggers. Triggers are sets of SQL statements that are automatically executed in response to a particular command. Database architecture Database applications are built from user interface elements, components that manage the database or databases, and components that represent the data contained by the tables in those databases (datasets). How you\n\n\n\norganize these pieces is the architecture of your database application. By isolating database access components in data modules, you can develop forms in your database applications that provide a consistent user interface. By storing links to well-designed forms and data modules in the Object Repository, you and other developers can build on existing foundations rather than starting over from scratch for each new project. Sharing forms and modules also makes it possible for you to develop corporate standards for database access and application interfaces. Many aspects of the architecture of your database application depend on the type of database you are using, the number of users who will be sharing the database information, and the type of information you are working with. See “Types of databases” on page 13-2 for more information about different types of databases. When writing applications that use information that is not shared among several users, you may want to use a local\n\n\n\ndatabase in a single-tiered application. This approach can have the advantage of speed (because data is stored locally), and does not require the purchase of a separate database server and expensive site licences. However, it is limited in how much data the tables can hold and the number of users your application can support. Writing a two-tiered application provides more multi-user support and lets you use large remote databases that can store far more information. Note Support for two-tiered applications requires SQL Links, InterBase, or ADO. When the database information includes complicated relationships between several tables, or when the number of clients grows, you may want to use a multi-tiered application. Multi-tiered applications include middle tiers that centralize the logic which governs your database interactions so that there is centralized control over data relationships. This allows different client applications to use the same data while ensuring that the data logic\n\n\n\nis consistent. They also allow for smaller client applications because much of the processing is off-loaded onto middle tiers. These smaller client applications are easier to install, configure, and maintain because they do not include the database connectivity software. Multi-tiered applications can also improve performance by spreading the data-processing tasks over several systems. 13-6 Developer’s Guide Database architecture Planning for scalability The development process can get more involved and expensive as the number of tiers increases. Because of this, you may want to start developing your application as a single-tiered application. As the amount of data, the number of users, and the number of different applications accessing the data grows, you may later need to scale up to a multi-tiered architecture. By planning for scalability, you can protect your development investment when writing a single- or two-tiered application so that the code can be reused as your\n\n\n\napplication grows. The VCL data-aware components make it easy to write scalable applications by abstracting the behavior of the database and the data stored by the database. Whether you are writing a single-tiered, two-tiered, or multi-tiered application, you can isolate your user interface from the data access layer as illustrated in Figure 13.1 Figure 13.1 User-interface to dataset connections in all database applications user interface elements data source Form dataset component database Data Module Client Application A form represents the user interface, and contains data controls and other user interface elements. The data controls in the user interface connect to datasets which represent information from the tables in the database. A data source links the data controls to these datasets. By isolating the data source and datasets in a data module, the form can remain unchanged as you scale your application up. Only the datasets must change. Note Some user interface\n\n\n\nelements require special attention when planning for scalability. For example, different databases enforce security in different ways. See “Database security” on page 13-3 for more information on handling user authentication in a uniform manner as you change databases. When using C++Builder’s data access components (whether they use the BDE, ADOExpress, or InterBase Express) it is easy to scale from one-tiered to two-tiered. Only a few properties on the dataset must change to direct the dataset to connect to an SQL server rather than a local database. A flat-file database application is easily scaled to the client in a multi-tiered application because both architectures use the same client dataset component. In fact, Designing database applications 13-7 D a t ahttp://www.doksihu base architecture Forrás: you can write an application that acts as both a flat-file application and a multi-tiered client (see “Using the briefcase model” on page 14-16). If you plan to scale\n\n\n\nyour application up to a three-tiered architecture eventually, you can write your one- or two-tiered application with that goal in mind. In addition to isolating the user interface, isolate all logic that will eventually reside on the middle tier so that it is easy to replace at a later time. You can even connect your user interface elements to client datasets (used in multi-tiered applications), and connect them to local versions of the InterBase, BDE- or ADO- enabled datasets in a separate data module that will eventually move to the middle tier. If you do not want to introduce this artifice of an extra dataset layer in your one- and two-tiered applications, it is still easy to scale up to a three-tiered application at a later date. See “Scaling up to a three-tiered application” on page 14-17 for more information. Single-tiered database applications In single-tiered database applications, the application and the database share a single file system. They use local databases or\n\n\n\nfiles that store database information in a flat-file format. A single application comprises the user interface and incorporates the data access mechanism (either the BDE or a system for loading and saving flat-file database information). The type of dataset component used to represent database tables depends on whether the data is stored in a local database (such as Paradox, dBASE, Access, or FoxPro) or in a flat file. Figure 132 illustrates these two possibilities: Figure 13.2 Single-tiered database application architectures user interface elements Form user interface elements Form data source BDE-enabled dataset component Borland Database Engine local database Data Module data source Client dataset flat-file data Data Module For more information on building single-tiered database applications, see Chapter 14, “Building one- and two-tiered applications.” 13-8 Developer’s Guide Database architecture Two-tiered database applications In two-tiered database\n\n\n\napplications, a client application provides a user interface to data, and interacts directly with a remote database server. Figure 133 illustrates this relationship. Figure 13.3 Two-tiered database application architectures user interface elements data source Form ADO-enabled dataset component OLE DB remote database Data Module Client Application user interface elements data source Form BDE-enabled dataset component Borland Database Engine remote database Data Module Client Application In this model, all applications are database clients. A client requests information from and sends information to a database server. A server can process requests from many clients simultaneously, coordinating access to and updating of data. For more information on building two-tiered database applications, see “BDE-based applications” on page 14-2 and “ADO-based applications” on page 14-10. Multi-tiered database applications In multi-tiered database applications, an application\n\n\n\nis partitioned into pieces that reside on different machines. A client application provides a user interface to data It passes all data requests and updates through an application server (also called a “remote data broker”). The application server, in turn, communicates directly with a remote database server or some other custom dataset. Usually, in this model, the client application, the application server, and the remote database server are on separate machines. Figure 134 illustrates these relationships for different types of multi-tiered applications. Designing database applications 13-9 D a t ahttp://www.doksihu base architecture Forrás: Figure 13.4 Multi-tiered database architectures connection component user interface elements data source Client dataset Form Data Module remote database provider remote database data source Client dataset Data Module ADO-enabled dataset component OLE DB Remote data module Application Server Client Application user interface\n\n\n\nelements Borland Database Engine Application Server connection component Form BDE-enabled dataset component Remote data module Client Application user interface elements provider connection component provider Client dataset custom dataset data source Form Data Module Client Application Remote data module Application Server You can use C++Builder to create both client applications and application servers. The client application uses standard data-aware controls connected through a data source to one or more client dataset components in order to display data for viewing and editing. Each client dataset communicates with an application server through an IAppServer interface that is implemented by the application server. The client application can use a variety of protocols (TCP/IP, HTTP, DCOM, or MTS) to establish this communication. The protocol depends on the type of connection component used in the client application and the type of remote data module used in the\n\n\n\nserver application. The application server contains provider components that mediate the communication between client datasets on the client application and the datasets on the application server. All data is passed between the client application and the provider components through the IAppServer interface. 13-10 Developer’s Guide Designing the user interface Usually, several client applications communicate with a single application server in the multi-tiered model. The application server provides a gateway to your databases for all your client applications, and it lets you provide enterprise-wide database tasks in a central location, accessible to all your clients. For more information about creating and using a multi-tiered database application, see Chapter 15, “Creating multi-tiered applications.” Designing the user interface The Data Controls page of the Component palette provides a set of data-aware controls that represent data from fields in a database record, and\n\n\n\ncan permit users to edit that data and post changes back to the database. Using data-aware controls, you can build your database application’s user interface (UI) so that information is visible and accessible to users. For more information on data-aware controls see Chapter 27, “Using data controls.” Data-aware controls get data from and send data to a data source component (TDataSource. A data source component acts as a conduit between the user interface and a dataset component which represents a set of information from the tables in a database. Several data-aware controls on a form can share a single data source, in which case the display in each control is synchronized so that as the user scrolls through records, the corresponding value in the fields for the current record is displayed in each control. An application’s data source components usually reside in a data module, separate from the data-aware controls on forms. The data-aware controls you add to your user interface\n\n\n\ndepend on what type of data you are displaying (plain text, formatted text, graphics, multimedia elements, and so on). In addition, your choice of controls is determined by how you want to organize the information and how (or if) you want to let users navigate through the records of datasets and add or edit data. The following sections introduce the components you can use for various types of user interface. Displaying a single record In many applications, you may only want to provide information about a single record of data at a time. For example, an order-entry application may display the information about a single order without indicating what other orders are currently logged. This information probably comes from a single record in an orders dataset Applications that display a single record are usually easy to read and understand, because all database information is about the same thing (in the previous case, the same order). The data-aware controls in these user interfaces\n\n\n\nrepresent a single field from a database record. The Data Controls page of the Component palette provides a wide selection of controls to represent different kinds of fields. For more information about specific data-aware controls, see “Controls that represent a single field” on page 27-8. Designing database applications 13-11 D e s http://www.doksihu igning the user interface Forrás: Displaying multiple records Sometimes you want to display many records in the same form. For example, an invoicing application might show all the orders made by a single customer on the same form. To display multiple records, use a grid control. Grid controls provide a multi-field, multi-record view of data that can make your application’s user interface more compelling and effective. They are discussed in “Viewing and editing data with TDBGrid” on page 27-16 and “Creating a grid that contains other data-aware controls” on page 27-28. You may want to design a user interface that\n\n\n\ndisplays both fields from a single record and grids that represent multiple records. There are two models that combine these two approaches:\n• Master-detail forms: You can represent information from both a master table and a detail table by including both controls that display a single field and grid controls. For example, you could display information about a single customer with a detail grid that displays the orders for that customer. For information about linking the underlying tables in a master-detail form, see “Creating master/detail forms” on page 21-25 or “Working with nested tables” on page 21-26.\n• Drill-down forms: In a form that displays multiple records, you can include single field controls that display detailed information from the current record only. This approach is particularly useful when the records include long memos or graphic information. As the user scrolls through the records of the grid, the memo or graphic updates to represent the value of the\n\n\n\ncurrent record. Setting this up is very easy. The synchronization between the two displays is automatic if the grid and the memo or image control share a common data source. Tip It is generally not a good idea to combine these two approaches on a single form. While the result can sometimes be effective, it can be confusing for users to understand the data relationships. Analyzing data Some database applications do not present database information directly to the user. Instead, they analyze and summarize information from databases so that users can draw conclusions from the data. The TDBChart component on the Data Controls page of the Component palette lets you present database information in a graphical format that enables users to quickly grasp the import of database information. In addition, some versions of C++Builder include a Decision Cube page on the Component palette. It contains six components that let you perform data analysis and cross-tabulations on data when building\n\n\n\ndecision support applications. For more information about using the Decision Cube components, see Chapter 28, “Using decision support components.” 13-12 Developer’s Guide Designing the user interface If you want to build your own components that display data summaries based on various grouping criteria, you can use maintained aggregates with a client dataset. For more information about using maintained aggregates, see “Using maintained aggregates” on page 25-9. Selecting what data to show Often, the data you want to surface in your database application does not correspond exactly to the data in a single database table. You may want to use only a subset of the fields or a subset of the records in a table. You may want to combine the information from more than one table into a single joined view. The data available to your database application is controlled by your choice of dataset component. Datasets abstract the properties and methods of a database table, so that you\n\n\n\ndo not need to make major alterations depending on whether the data is stored in a database table or derived from one or more tables in the database. For more information on the common properties and methods of datasets, see Chapter 19, “Understanding datasets.” Your application can contain more than one dataset. Each dataset represents a logical table. By using datasets, your application logic is buffered from restructuring of the physical tables in your databases. You might need to alter the type of dataset component, or the way it specifies the data it contains, but the rest of your user interface can continue to work without alteration. When using the BDE to access your data, you can use any of the following types of dataset:\n• Table components (TTable): Tables correspond directly to the underlying tables in the database. You can adjust which fields appear (including adding lookup fields and calculated fields) by using persistent field components. You can limit the records\n\n\n\nthat appear using ranges or filters. Tables are described in more detail in Chapter 21, “Working with tables.” Persistent fields are described in “Persistent field components” on page 20-4. Ranges and filters are described in “Working with a subset of data” on page 21-11.\n• Query components (TQuery): Queries provide the most general mechanism for specifying what appears in a BDE-based dataset. You can combine the data from multiple tables using joins, and limit the fields and records that appear based on any criteria you can express in SQL. For more information on queries, see Chapter 22, “Working with queries.”\n• Stored procedures (TStoredProc): Stored procedures are sets of SQL statements that are named and stored on an SQL server. If your database server defines a stored procedure that returns the dataset you want, you can use a stored procedure component. For more information on stored procedures, see Chapter 23, “Working with stored procedures.”\n• Nested\n\n\n\ndatasets (TNestedTable): Nested datasets represent the records in an Oracle8 nested detail set. C++Builder does not let you create Oracle8 tables with nested dataset fields, but you can edit and display data from existing dataset fields using nested datasets. The nested dataset gets its data from a dataset field Designing database applications 13-13 D e s http://www.doksihu igning the user interface Forrás: component in a dataset which contains Oracle8 data. See “Working with nested tables” on page 21-26 and “Working with dataset fields” on page 20-26 for more information on using nested datasets to represent dataset fields. When using ADO to access your data, you can use any of the following types of dataset:\n• ADO datasets (TADODataset): ADO datasets provide the most flexible mechanism for accessing data using ADO.ADO datasets can represent a single database table or the results of an SQL query. You can adjust which fields appear (including adding lookup fields and\n\n\n\ncalculated fields) by using persistent field components. You can limit the records that appear using ranges or filters You can specify an SQL statement that generates the data. ADO datasets are described in more detail in “Features common to all ADO dataset components” on page 24-11 and “Using TADODataSet” on page 24-18.\n• ADO table components (TADOTable): ADO tables correspond directly to the underlying tables in the database. You can adjust which fields appear (including adding lookup fields and calculated fields) by using persistent field components. You can limit the records that appear using ranges or filters. ADO tables are described in more detail in “Using TADOTable” on page 24-19.\n• ADO query components (TADOQuery): ADO Queries represent the result set from running an SQL command or data definition language (DDL) statement. For more information on ADO queries, see “Using TADOQuery” on page 24-20.\n• ADO stored procedures (TADOStoredProc): If your database\n\n\n\nserver defines a stored procedure that returns the dataset you want, you can use an ADO stored procedure component. For more information on ADO stored procedures, see “Using TADOStoredProc” on page 24-21. If you are using InterBase for your database server, you can use any of the following types of dataset:\n• IB datasets (TIBDataSet): IB datasets represents the result set of an SQL statement (usually a SELECT statement). You can specify SQL statements for selecting and updating the data buffered by the dataset.\n• IB table components (TIBTable): IB tables get their data directly from an InterBase table or view. You can adjust which fields appear (including adding lookup fields and calculated fields) by using persistent field components. You can limit the records that appear using filters.\n• IB query components (TIBQuery): IB queries represent the result set from running an SQL command. IB queries are the most easily scaled dataset component when moving from local InterBase to\n\n\n\na remote InterBase server.\n• IB stored procedures (TIBStoredProc): IBStoredProc executes an InterBase Execute stored procedure. These datasets do not return a result set: for stored procedures that return a result set you must use TIBDataSet or TIBQuery. 13-14 Developer’s Guide Designing the user interface If you are not using the BDE, ADO, or InterBase, C++Builder provides the following options:\n• Client datasets (TClientDataSet): Client datasets cache the records of the logical dataset in memory. Because of that, they can only hold a limited number of records. Client datasets are populated with data in one of two ways: from an application server or from flat-file data stored on disk. They do not require a database engine such as BDE or ADO, but rely on a single DLL (Midas.dll) For more information about client datasets, see Chapter 25, “Creating and using a client dataset.”\n• Custom datasets: You can create your own custom descendants of TDataSet to represent a\n\n\n\nbody of data that you create or access in code you write. Writing custom datasets allows you the flexibility of managing the data using any method you choose, while still letting you use the VCL data controls to build your user interface. For more information about creating custom components, see Chapter 39, “Overview of component creation.” Writing reports If you want to let your users print database information from the datasets in your application, you can use the report components on the QReport page of the Component palette. Using these components you can visually build banded reports to present and summarize the information in your database tables. You can add summaries to group headers or footers to analyze the data based on grouping criteria. Start a report for your application by selecting the QuickReport icon from the New Items dialog. Select File|New from the main menu, and go to the page labeled Business. Double-click the QuickReport Wizard icon to launch the wizard\n\n\n\nNote See the QuickReport demo that ships with C++Builder for an example of how to use the components on the QReport page. Designing database applications 13-15 13-16 Developer’s Guide Chapter 14 Building one- and two-tiered applications Chapter14 One- and two-tiered applications include the logic that manipulates database information in the same application that implements the user interface. Because the data manipulation logic is not isolated in a separate tier, these types of applications are most appropriate when there are no other applications sharing the same database information. Even when other applications share the database information, these types of applications are appropriate if the database is very simple, and there are no data semantics that must duplicated by all applications that use the data. You may want to start by writing a one- or two-tiered application, even when you intend to eventually scale up to a multi-tiered model as your needs increase.\n\n\n\nThis approach lets you avoid having to develop data manipulation logic up front so that the application server can be available while you are writing the user interface. It also allows you to develop a simpler, cheaper prototype before investing in a large, multi-system development project. If you intend to eventually scale up to a multi-tiered application, you can isolate the data manipulation logic so that it is easy to move it to a middle tier at a later date. C++Builder provides support for two types of single-tiered applications: applications that use a local database (such as Paradox, dBase, Access, or Local InterBase) and flat-file database applications. Two-tiered applications use a driver to access a remote database The considerations when writing single-tired applications that use a local database and two-tiered applications are essentially the same, and depend primarily on the mechanism you choose to connect to the database. C++Builder provides three different built-in\n\n\n\nmechanisms for these types of applications:\n• BDE-based applications\n• ADO-based applications\n• InterBase Express applications Flat file database applications are based on the support for client datasets included in MIDAS.DLL Building one- and two-tiered applications 14-1 B D Ehttp://www.doksihu -based applications Forrás: BDE-based applications Because the data access components (and Borland Database Engine) handle the details of reading data, updating data, and navigating data, writing BDE-based two-tiered applications is essentially the same as writing BDE-based one-tiered applications. When deploying BDE-based applications, you must include the BDE with your application. While this increases the size of the application and the complexity of deployment, the BDE can be shared with other BDE-based applications and provides many advantages. BDE-based applications allow you to use the powerful library of Borland Database Engine API calls. Even if you do not want to use the\n\n\n\nBDE API, writing BDE-based applications gives you support for the following features not available to other applications such as flat-file database application:\n• \n• \n• \n• Connecting to databases Using transactions Caching updates Creating and restructuring database tables BDE-based architecture A BDE-based one- or two-tiered application includes\n• A user interface containing data-aware controls.\n• One or more datasets that represent information from the database tables.\n• A datasource component for each dataset to connect the data-aware controls to the datasets.\n• Optionally, one or more database components to control transactions in both oneand two-tiered applications and to manage database connections in two-tiered applications.\n• Optionally, one or more session components to isolate data access operations such as database connections, and to manage groups of databases. The relationships between these elements is illustrated in Figure 14.1: Figure 14.1 Components in\n\n\n\na BDE-based application user interface elements data source dataset data source dataset database Session Form 14-2 Developer’s Guide Data Module Borland Database Engine database BDE-based applications Understanding databases and datasets Databases contain information stored in tables. They may also include tables of information about what is contained in the database, objects such as indexes that are used by tables, and SQL objects such as stored procedures. See Chapter 18, “Connecting to databases” for more information about databases. The Data Access page of the Component palette contains various dataset components that represent the tables contained in a database or logical tables constructed out of data stored in those database tables. See “Selecting what data to show” on page 13-13 for more information about these dataset components. You must include a dataset component in your application to work with database information. Each BDE-enabled dataset\n\n\n\ncomponent on the Data Access page has a published DatabaseName property that specifies the database which contains the table or tables that hold the information in that dataset. When setting up your application, you must use this property to specify the database before you can bind the dataset to specific information contained in that database. What value you specify depends on whether\n• The database has a BDE alias. You can specify a BDE alias as the value of DatabaseName. A BDE alias represents a database plus configuration information for that database. The configuration information associated with an alias differs by database type (Oracle, Sybase, InterBase, Paradox, dBASE, and so on). Use the BDE Administration tool or the SQL explorer to create and manage BDE aliases.\n• The database is a Paradox or dBASE database. If you are using a Paradox or dBASE database, DatabaseName can specify the directory where the database tables are located.\n• You are using explicit database\n\n\n\ncomponents. Database components (TDatabase) represent a database in your application. If you don’t add a database component explicitly, a temporary one is created for you automatically, based on the value of the DatabaseName property. If you are using explicit database components, DatabaseName is the value of the DatabaseName property of the database component. See “Understanding persistent and temporary database components” on page 18-1 for more information about using database components. Using sessions Sessions isolate data access operations such as database connections, and manage groups of databases. All use of the Borland Database Engine takes place in the context of a session. You can use sessions to specify configuration information that applies to all the databases in the session. This allows you to override the default behavior specified using the BDE administration tool. You can use a session to\n• Manage BDE aliases. You can create new aliases, delete aliases, and\n\n\n\nmodify existing aliases. By default, changes affect only the session, but you can write changes so that they are added to the permanent BDE configuration file. For more information on managing BDE aliases, see “Working with BDE aliases” on page 17-9. Building one- and two-tiered applications 14-3 B D Ehttp://www.doksihu -based applications Forrás:\n• Control when database connections in two-tiered applications are closed. Keeping database connections open when none of the datasets in the database are active ties up resources that could be released, but improves speed and reduces network traffic. To keep database connections open even when there are no active datasets, the KeepConnections property should be true (the default).\n• Manage access to password-protected Paradox and dBASE files in one-tiered applications. Datasets that access password-protected Paradox and dBASE tables use the session component to supply a password when these tables must be opened. You can\n\n\n\noverride the default behavior (a password dialog that appears whenever a password is needed), to supply passwords programmatically. If you intend to scale your one-tiered application to a two-tiered or multi-tiered application, you can create a common user interface for obtaining user authentication information that need not change when you switch to using remote database servers which require a username and password at the server (rather than table) level. For more information about using sessions to manage Paradox and dBASE passwords, see “Working with password-protected Paradox and dBASE tables” on page 17-13.\n• Specify the location of special Paradox directories. Paradox databases that are shared on a network use a net directory which contains temporary files that specify table and record locking information. Paradox databases also use a private directory where temporary files such as the results of queries are kept. For more information on specifying these directory\n\n\n\nlocations, see “Specifying Paradox directory locations” on page 17-12. If your application may be accessing the same database multiple times simultaneously, you must use multiple sessions to isolate these uses of the database. Failure to do so will disrupt the logic governing transactions on that database (including transactions created for you automatically). Applications risk simultaneous access when running concurrent queries or when using multiple threads. For more information about using multiple sessions, see “Managing multiple sessions” on page 17-16. Unless you need to use multiple sessions, you can use the default session. Connecting to databases The Borland Database Engine includes drivers to connect to different databases. The professional version of C++Builder include the drivers for local databases: Paradox, dBASE, FoxPro, and Access, as well as an ODBC adapter that allows the BDE to use ODBC drivers. By supplying an ODBC driver, your application can use any\n\n\n\nODBC-compliant database. Then Enterprise version also include drivers for remote database servers. Use the drivers installed with SQL Links to communicate with remote database servers such as InterBase, Oracle, Sybase, Informix, Microsoft SQL server, and DB2. Note 14-4 The only difference between a BDE-based one-tiered application and a BDE-based two-tiered application is whether it uses local databases or remote database servers. Developer’s Guide BDE-based applications Using transactions A transaction is a group of actions that must all be carried out successfully on one or more tables in a database before they are committed (made permanent). If one of the actions in the group fails, then all actions are rolled back (undone). By using transactions, you ensure that the database is not left in an inconsistent state when a problem occurs completing one of the actions that make up the transaction. For example, in a banking application, transferring funds from one account to\n\n\n\nanother is an operation you would want to protect with a transaction. If, after decrementing the balance in one account, an error occurred incrementing the balance in the other, you want to roll back the transaction so that the database still reflects the correct total balance. By default, the BDE provides implicit transaction control for your applications. When an application is under implicit transaction control, a separate transaction is used for each record in a dataset that is written to the underlying database. Implicit transactions guarantee both a minimum of record update conflicts and a consistent view of the database. On the other hand, because each row of data written to a database takes place in its own transaction, implicit transaction control can lead to excessive network traffic and slower application performance. Also, implicit transaction control will not protect logical operations that span more than one record, such as the transfer of funds described previously. If\n\n\n\nyou explicitly control transactions, you can choose the most effective times to start, commit, and roll back your transactions. When you develop applications in a multi-user environment, particularly when your applications run against a remote SQL server, you should control transactions explicitly. Note You can also minimize the number of transactions you need by caching updates. For more information about cached updates, see Chapter 26, “Working with cached updates.” Explicitly controlling transactions There are two mutually exclusive ways to control transactions explicitly in a BDE-based database application:\n• Use the methods and properties of the database component, such as StartTransaction, Commit, Rollback, InTransaction, and TransIsolation. The main advantage to using the methods and properties of a database component to control transactions is that it provides a clean, portable application that is not dependent on a particular database or server.\n• Use passthrough SQL\n\n\n\nin a query component to pass SQL statements directly to remote SQL or ODBC servers. For more information about query components, see Chapter 22, “Working with queries.” The main advantage to passthrough SQL is that you can use the advanced transaction management capabilities of a particular database server, such as schema caching. To understand the advantages of your server’s transaction management model, see your database server documentation. One-tiered applications can‘t use passthrough SQL. You can use the database component to create explicit transactions for local databases. However, there are Building one- and two-tiered applications 14-5 B D Ehttp://www.doksihu -based applications Forrás: limitations to using local transactions. For more information on using local transactions, see “Using local transactions” on page 14-8. When writing two-tiered applications (which require SQL links), you can use either a database component or passthrough SQL to manage\n\n\n\ntransactions. For more information about using passthrough SQL, see “Using passthrough SQL” on page 14-8. Using a database component for transactions When you start a transaction, all subsequent statements that read from and write to the database occur in the context of that transaction. Each statement is considered part of a group. Changes must be successfully committed to the database, or every change made in the group must be undone. Ideally, a transaction should only last as long as necessary. The longer a transaction is active, the more simultaneous users that access the database, and the more concurrent, simultaneous transactions that start and end during the lifetime of your transaction, the greater the likelihood that your transaction will conflict with another when you attempt to commit your changes. When using a database component, you code a single transaction as follows: 1 Start the transaction by calling the database’s StartTransaction method:\n\n\n\nDatabaseInterBase->StartTransaction(); 2 Once the transaction is started, all subsequent database actions are considered part of the transaction until the transaction is explicitly terminated. You can determine whether a transaction is in process by checking the database component’s InTransaction property. While the transaction is in process, your view of the data in database tables is determined by you transaction isolation level. For more information about transaction isolation levels, see “Using the TransIsolation property” on page 14-7. 3 When the actions that make up the transaction have all succeeded, you can make the database changes permanent by using the database component’s Commit method: DatabaseInterBase->Commit(); Commit is usually attempted in a try.catch statement That way, if a transaction cannot commit successfully, you can use the catch block to handle the error and retry the operation or to roll back the transaction. 4 If an error occurs when making\n\n\n\nthe changes that are part of the transaction, or when trying to commit the transaction, you will want to discard all changes that make up the transaction. To discard these changes, use the database component’s Rollback method: DatabaseInterBase->Rollback(); Rollback usually occurs in\n• Exception handling code when you cannot recover from a database error.\n• Button or menu event code, such as when a user clicks a Cancel button. 14-6 Developer’s Guide BDE-based applications Using the TransIsolation property TransIsolation specifies the transaction isolation level for a database component’s transactions. Transaction isolation level determines how a transaction interacts with other simultaneous transactions when they work with the same tables. In particular, it affects how much a transaction “sees” of other transactions’ changes to a table. The default setting for TransIsolation is tiReadCommitted. The following table summarizes possible values for TransIsolation\n\n\n\nand describes what they mean: Table 14.1 Possible values for the TransIsolation property Isolation level Meaning tiDirtyRead Permit reading of uncommitted changes made to the database by other simultaneous transactions. Uncommitted changes are not permanent, and might be rolled back (undone) at any time. At this level your transaction is least isolated from the changes made by other transactions. tiReadCommitted Permit reading only of committed (permanent) changes made to the database by other simultaneous transactions. This is the default isolation level tiRepeatableRead Permit a single, one time reading of the database. Your transaction cannot see any subsequent changes to data by other simultaneous transactions. This isolation level guarantees that once your transaction reads a record, its view of that record will not change. At this level your transaction is most isolated from changes made by other transactions. Database servers may support these isolation levels\n\n\n\ndifferently or not at all. If the requested isolation level is not supported by the server, the BDE uses the next highest isolation level. The actual isolation level used by some servers is shown in Table 142, “Transaction isolation levels.” For a detailed description of how each isolation level is implemented, see your server documentation. Table 14.2 Transaction isolation levels Server Specified Level Actual Level Oracle tiDirtyRead tiReadCommitted tiRepeatableRead tiReadCommitted tiReadCommitted tiRepeatableRead (READONLY) Sybase, MS-SQL tiDirtyRead tiReadCommitted tiRepeatableRead tiReadCommitted tiReadCommitted Not supported DB2 tiDirtyRead tiReadCommitted tiRepeatableRead tiDirtyRead tiReadCommitted tiRepeatableRead Informix tiDirtyRead tiReadCommitted tiRepeatableRead tiDirtyRead tiReadCommitted tiRepeatableRead InterBase tiDirtyRead tiReadCommitted tiRepeatableRead tiReadCommitted tiReadCommitted tiRepeatableRead Paradox, dBASE, Access, FoxPro \n\n\n\ntiDirtyRead tiReadCommitted tiRepeatableRead tiDirtyRead Not supported Not supported Building one- and two-tiered applications 14-7 B D Ehttp://www.doksihu -based applications Forrás: Note When using transactions with local Paradox, dBASE, Access, and FoxPro tables, set TransIsolation to tiDirtyRead instead of using the default value of tiReadCommitted. A BDE error is returned if TransIsolation is set to anything but tiDirtyRead for local tables. If an application is using ODBC to interface with a server, the ODBC driver must also support the isolation level. For more information, see your ODBC driver documentation. Using passthrough SQL With passthrough SQL, you use a TQuery, TStoredProc, or TUpdateSQL component to send an SQL transaction control statement directly to a remote database server. The BDE does not process the SQL statement. Using passthrough SQL enables you to take direct advantage of the transaction controls offered by your server, especially when those controls\n\n\n\nare non-standard. To use passthrough SQL to control a transaction, you must\n• Install the proper SQL Links drivers. If you chose the “Typical” installation when installing C++Builder, all SQL Links drivers are already properly installed.\n• Configure your network protocol correctly. See your network administrator for more information.\n• Have access to a database on a remote server.\n• Set SQLPASSTHRU MODE to NOT SHARED using the SQL Explorer. SQLPASSTHRU MODE specifies whether the BDE and passthrough SQL statements can share the same database connections. In most cases, SQLPASSTHRU MODE is set to SHARED AUTOCOMMIT. However, you can’t share database connections when using transaction control statements. For more information about SQLPASSTHRU modes, see the help file for the BDE Administration utility. Note When SQLPASSTHRU MODE is NOT SHARED, you must use separate database components for datasets that pass SQL transaction statements to the server and datasets that do not. \n\n\n\nUsing local transactions The BDE supports local transactions against local Paradox, dBASE, Access, and FoxPro tables. From a coding perspective, there is no difference to you between a local transaction and a transaction against a remote database server. When a transaction is started against a local table, updates performed against the table are logged. Each log record contains the old record buffer for a record When a transaction is active, records that are updated are locked until the transaction is committed or rolled back. On rollback, old record buffers are applied against updated records to restore them to their pre-update states. 14-8 Developer’s Guide BDE-based applications Local transactions are more limited than transactions against SQL servers or ODBC drivers. In particular, the following limitations apply to local transactions:\n• Automatic crash recovery is not provided.\n• Data definition statements are not supported.\n• Transactions cannot be run against\n\n\n\ntemporary tables.\n• For Paradox, local transactions can only be performed on tables with valid indexes. Data cannot be rolled back on Paradox tables that do not have indexes\n• Only a limited number of records can be locked and modified. With Paradox tables, you are limited to 255 records. With dBASE the limit is 100\n• Transactions cannot be run against the BDE ASCII driver.\n• TransIsolation level must only be set to tiDirtyRead.\n• Closing a cursor on a table during a transaction rolls back the transaction unless:\n• Several tables are open.\n• The cursor is closed on a table to which no changes were made. Caching updates The Borland Database Engine provides support for caching updates. When you cache updates, your application retrieves data from a database, makes all changes to a local, cached copy of the data, and applies the cached changes to the dataset as a unit. Cached updates are applied to the database in a single transaction. Caching updates can minimize\n\n\n\ntransaction times and reduce network traffic. However, cached data is local to your application and is not under transaction control. This means that while you are working on your local, in-memory, copy of the data, other applications can be changing the data in the underlying database table. They also can’t see any changes you make until you apply the cached updates. Because of this, cached updates may not be appropriate for applications that work with volatile data, as you may create or encounter too many conflicts when trying to merge your changes into the database. You can tell BDE-enabled datasets to cache updates using the CachedUpdates property. When the changes are complete, they can be applied by the dataset component, by the database component, or by a special update object. When changes can’t be applied to the database without additional processing (for example, when working with a joined query), you must use the OnUpdateRecord event to write changes to each table that\n\n\n\nmakes up the joined view. For more information on caching updates, see Chapter 26, “Working with cached updates.” Note If you are caching updates, you may want to consider moving to a multitiered model to have greater control over the application of updates. For more information about the multitiered model, see Chapter 15, “Creating multi-tiered applications.” Building one- and two-tiered applications 14-9 A D Ohttp://www.doksihu -based applications Forrás: Creating and restructuring database tables In BDE-based applications, you can use the TTable component to create new database tables and to add indexes to existing tables. You can create tables either at design time, in the Forms Designer, or at runtime. To create a table, you must specify the fields in the table using the FieldDefs property, add any indexes using the IndexDefs property, and call the CreateTable method (or select the Create Table command from the table’s context menu). For more detailed instructions\n\n\n\non creating tables, see “Creating a table” on page 21-17. Note When creating Oracle8 tables, you can’t create object fields (ADT fields, array fields, reference fields, and dataset fields). If you want to restructure a table at runtime (other than by adding indexes), you must use the BDE API DbiDoRestructure. You can add indexes to an existing table using the AddIndex method of TTable. Note At design time, you can use the Database Desktop to create and restructure Paradox and dBASE tables. To create and restructure tables on remote servers, use the SQL Explorer and restructure the table using SQL. ADO-based applications C++Builder applications that use the ADO components for data access can be either one- or two-tier. Which category an application falls under is predicated on the database type used. For instance, using ADO to access a Microsoft SQL Server database will always be a two-tier application because SQL Server is an SQL database system. SQL database systems are\n\n\n\ntypically located on a dedicated SQL server On the other hand, an application that uses ADO to access some local database type, like dBASE or FoxPro, will always be a one-tier application. There are four major areas involved in database access using ADO and the C++Builder ADO components. These areas of concern are the same regardless of whether the application is one- or two-tier:\n• \n• \n• \n• ADO-based architecture Connecting to ADO databases Retrieving data Creating and restructuring ADO database tables ADO-based architecture An ADO-based application includes the following functional areas:\n• A user interface with visual data-aware controls. Visual data controls are optional if all data access is done programmatically.\n• One or more dataset components that represent information from tables or queries. 14-10 Developer’s Guide ADO-based applications\n• One datasource component for each dataset component to act as the conduit between dataset component and one or more\n\n\n\nvisual data-aware controls.\n• A connection component to connect to the ADO data store. The connection component acts as a conduit between the application’s dataset components and the database accessed through the data store. The ADO layer of an ADO-based C++Builder application consists of Microsoft ADO 2.1, an OLE DB provider or ODBC driver for the data store access, client software for the specific database system used (in the case of SQL databases), a database back-end system accessible to the application (for SQL database systems), and a database. All of these external entities must be present and accessible to the ADO-based application for it to be fully functional. Understanding ADO databases and datasets The ADO page of the Component Palette contains all of the components necessary for connecting to databases and for accessing the tables in them. All of the metadata objects an ADO-based application are contained in the database accessed through the ADO data store. To access\n\n\n\nthese objects or the data stored in them, an application must first connect to the data store. See “Connecting to ADO data stores” on page 24-2 for information on connecting to data stores. The data of a database is stored in one or more tables. You must include at least one ADO dataset component (TADODataSet, TADOQuery, and so on) in your application to work with the data stored in a database’s tables. See “Retrieving data” on page 14-12 and “Using ADO datasets” on page 24-11 for more information on using ADO dataset components to access data in tables. Connecting to ADO databases An ADO-based application C++Builder uses ADO 2.1 to interact with an OLE DB provider that connects to a data store and accesses its data. One of the items a data store can represent is a database. An ADO-based application requires that ADO 21 be installed on the client computer. ADO and OLE DB is supplied by Microsoft and installed with Windows. The provider can represent one of a number of\n\n\n\ntypes of access, from native OLE DB drivers to ODBC drivers. These drivers must also be installed on the client computer OLE DB drivers for various database systems are supplied by the database vendor or by a third-party. If the application uses an SQL database, such as Microsoft SQL Server or Oracle, the client software for that database system must also be installed on the client computer. Client software is supplied by the database vendor and installed from the database systems CD (or disk). To connect the application with the data store, the ADO connection component is configured to use one of the available providers. Once the connection component is connected to the data store, dataset components can be associated with the Building one- and two-tiered applications 14-11 A D Ohttp://www.doksihu -based applications Forrás: connection component to access the tables in the database. See “Connecting to ADO data stores” on page 24-2 for information on connecting to data\n\n\n\nstores. In addition to providing an application’s access to the database, the connection component encapsulates the ADO transaction processing capabilities. Retrieving data Once an application has established a valid connection to a database, dataset components can be used to access data in the database. The ADO page of the Component palette contains the ADO dataset components needed to access data from ADO data stores. These components include TADODataSet, TADOTable, TADOQuery, and TADOStoredProc. All of these components are capable of retrieving data from ADO data stores, programmatically modifying the data, and presenting the data to an application’s user for interactive use of the data. For more information on using the ADO dataset components to retrieve and modify data, see “Using ADO datasets” on page 24-11. To make the data accessed with an ADO dataset component visually accessible in an application, use the stock data-aware controls. There are no ADO-specific\n\n\n\ndata-aware controls. For details on using data-aware controls, see “Using common data control features” on page 27-1. The standard data source component is used as a conduit between the ADO dataset components and the data-aware controls. There is no dedicated data source component for ADO. For details on using data source components, see “Using data sources” on page 27-5. Where needed, persistent field objects can be used to represent fields in the ADO dataset components. As with the data-aware controls and data source components, simply use the inherent C++Builder field classes (TField and descendants). For details on using dynamic and persistent field objects, see “Understanding field components” on page 20-2. Creating and restructuring ADO database tables In a C++Builder application, you must use SQL to create and delete metadata in an ADO database. Similarly, you need to restructure tables using SQL statements Changing other metadata objects cannot be done per se.\n\n\n\nInstead, you need to delete the metadata object and then replace it with a new one with different attributes. Many database types can be accessed through ADO and not all of the drivers for specific database types support the same SQL syntax. It is beyond the scope of this document to describe the SQL syntax supported by each database type and the differences between the database types. For a comprehensive and up-to-date discussion of the SQL implementation for a given database system, see the documentation that comes with that database system. 14-12 Developer’s Guide Flat-file database applications In general, use the CREATE TABLE statement to create tables in the database and CREATE INDEX to create new indexes for those tables. Where supported, use other CREATE statements for adding various metadata objects, such as CREATE DOMAIN, CREATE VIEW, and CREATE SCHEMA. For each of the CREATE statements, there is a corresponding DROP statement to delete a metadata object. These\n\n\n\nstatements include DROP TABLE, DROP VIEW, DROP DOMAIN, and DROP SCHEMA. To change the structure of a table, use the ALTER TABLE statement. ALTER TABLE has ADD and DROP clauses to create new elements in a table and to delete them. For example, use the ADD COLUMN clause to add a new column to the table and DROP CONSTRAINT to delete an existing constraint from the table. Issue these metadata statements from the ADO command or the ADO query component. For details on using the ADO command component to execute commands, see “Executing commands” on page 24-25. Flat-file database applications Flat-file database applications are single-tiered applications that use TClientDataSet to represent all of their datasets. The client dataset holds all its data in memory, which means that this type of application is not appropriate for extremely large datasets. Flat-file database applications do not require the Borland Database Engine (BDE) or ActiveX Data Objects (ADO). Instead, they only use\n\n\n\nMIDASDLL By using only MIDAS.DLL, flat-file applications are easier to deploy because you do not need to install, configure, and maintain software that manages database connections. Because these applications do not use a database, there is no support for multiple users. Instead, the datasets are dedicated entirely to the application Data can be saved to flat files on disk, and loaded at a later time, but there is no built-in protection to prevent multiple users from overwriting each other’s data files. Client datasets (located on the MIDAS page of the Component palette) form the basis of flat-file database applications. They provide support for most of the database operations you perform with other datasets. You use the same data-aware controls and data source components that you would use in a BDE-based single-tiered application. You don’t use database components, because there is no database connection to manage, and no transactions to support. You do not need to be concerned\n\n\n\nwith session components unless your application is multi-threaded. For more information about using client datasets, see Chapter 25, “Creating and using a client dataset.” The main differences in writing flat-file database applications and other single-tiered database applications lie in how you create the datasets and how you load and save data. Building one- and two-tiered applications 14-13 F l a t http://www.doksihu -file database applications Forrás: Creating the datasets Because flat-file database applications do not use existing databases, you are responsible for creating the datasets yourself. Once the dataset is created, you can save it to a file. From then on, you do not need to recreate the table, only load it from the file you saved. However, indexes are not saved with the table You need to recreate them every time you load the table. When beginning a flat-file database application, you may want to first create and save empty files for your datasets before\n\n\n\nbeginning the writing of the application itself. This way, you do not need to define the metadata for your client datasets in the final application. How you create your client dataset depends on whether you are creating an entirely new dataset, or converting an existing BDE-based application. Creating a new dataset using persistent fields The following steps describe how to create a new client dataset using the Fields Editor: 1 From the MIDAS page of the Component palette, add a TClientDataSet component to your application. 2 Right-click the client dataset and select Fields Editor. In the Fields editor, right-click and choose the New Field command. Describe the basic properties of your field definition. Once the field is created, you can alter its properties in the Object Inspector by selecting the field in the Fields editor. Continue adding fields in the fields editor until you have described your client dataset. 3 Right-click the client dataset and choose Create DataSet. This\n\n\n\ncreates an empty client dataset from the persistent fields you added in the Fields Editor. 4 Right-click the client dataset and choose Save To File. (This command is not available unless the client dataset contains data.) 5 In the File Save dialog, choose a file name and save a flat file copy of your client dataset. Note You can also create the client dataset at runtime using persistent fields that are saved with the client dataset. Simply call the CreateDataSet method Creating a dataset using field and index definitions Creating a client dataset using field and index definitions is much like using a TTable component to create a database table. There is no DatabaseName, TableName, or TableType property to specify, as these are not relevant to client datasets. However, just as with TTable, you use the FieldDefs property to specify the fields in your table and the IndexDefs property to specify any indexes. Once the table is specified, right-click the client dataset and choose Create\n\n\n\nDataSet at design time, or call the CreateDataSet method at runtime. 14-14 Developer’s Guide Flat-file database applications When defining the index definitions for your client dataset, two properties of the index definition apply uniquely to client datasets. These are TIndexDef::DescFields and TIndexDef::CaseInsFields. DescFields lets you define indexes that sort records in ascending order on some fields and descending order on other fields. Instead of using the ixDescending option to sort in descending order on all the fields in the index, list only those fields that should sort in descending order as the value of DescFields. For example, when defining an index that sorts on Field1, then Field2, then Field3, setting DescFields to Field1;Field3 results in an index that sorts Field2 in ascending order and Field1 and Field3 in descending order. CaseInsFields lets you define indexes that sort records case-sensitively on some fields and case-insensitively on other fields.\n\n\n\nInstead of using the isCaseInsensitive option to sort case-insensitively on all the fields in the index, list only those fields that should sort case-insensitively as the value of CaseInsFields. Like DescFields, CaseInsFields takes a semicolon-delimited list of field names. You can specify the field and index definitions at design time using the Collection editor. Just choose the appropriate property in the Object Inspector (FieldDefs or IndexDefs), and double-click to display the Collection editor. Use the Collection editor to add, delete, and rearrange definitions. By selecting definitions in the Collection editor you can edit their properties in the Object Inspector. You can also specify the field and index definitions in code at runtime. For example, the following code creates and activates a client dataset in the form’s OnCreate event handler: void fastcall TForm1::FormCreate(TObject *Sender) { TFieldDef *pDef = ClientDataSet1->FieldDefs->AddFieldDef(); pDef->DataType\n\n\n\n= ftInteger; pDef->Name = \"Field1\"; pDef = ClientDataSet1->FieldDefs->AddFieldDef(); pDef->DataType = ftString; pDef->Size = 10; pDef->Name = \"Field2\"; TIndexDef *pIndex = ClientDataSet1->IndexDefs->AddIndexDef(); pIndex->Fields = \"Field1\"; pIndex->Name = \"IntIndex\"; ClientDataSet1->CreateDataSet(); } Creating a dataset based on an existing table If you are converting an existing BDE-based application into a single-tiered flat-file application, you can copy existing tables and save them as flat-file tables from the IDE. The following steps indicate how to copy an existing table: 1 From the Data Access page of the Component palette, add a TTable component to your application. Set its DatabaseName and TableName properties to identify the existing database table. Set its Active property to True Building one- and two-tiered applications 14-15 F l a t http://www.doksihu -file database applications Forrás: 2\n\n\n\nFrom the MIDAS page of the Component palette, add a TClientDataSet component. 3 Right-click the client dataset and select Assign Local Data. In the dialog that appears, choose the table component that you added in step 1. Choose OK 4 Right-click the client dataset and choose Save To File. (This command is not available unless the client dataset contains data.) 5 In the File Save dialog, choose a file name and save a flat-file copy of your database table. Loading and saving data In flat-file database applications, all modifications to the table exist only in an in-memory change log. This log is maintained separately from the data itself, although it is completely transparent to objects that use the client dataset. That is, controls that navigate the client dataset or display its data see a view of the data that includes the changes. If you do not want to back out of changes, however, you should merge the change log into the data of the client dataset by calling the MergeChangeLog\n\n\n\nmethod. For more information about the change log, see “Editing data” on page 25-4 Even when you have merged changes into the data of the client dataset, this data still exists only in memory. While it will persist if you close the client dataset and reopen it in your application, it will disappear when your application shuts down. To make the data permanent, it must be written to disk. Write changes to disk using the SaveToFile method. SaveToFile takes one parameter, the name of the file which is created (or overwritten) containing the table. When you want to read a table previously written using the SaveToFile method, use the LoadFromFile method. LoadFromFile also takes one parameter, the name of the file containing the table. When you save a client dataset, the metadata that describes the record structure is saved with the dataset, but not the indexes. Because of this, you may want to add code that recreates the indexes when you load the data from file. Alternately, you might\n\n\n\nwant to write your application so that it always creates indexes on the fly in an as-needed fashion. If you always load to and save from the same file, you can use the FileName property instead of the SaveToFile and LoadFromFile methods. When FileName is set to a valid file name, the data is automatically loaded from the file when the client dataset is opened and saved to the file when the client dataset is closed. Using the briefcase model Most of this section has described creating and using a client dataset in a one-tiered application. The one-tiered model can be combined with a multi-tiered model to create what is called the briefcase model. Note 14-16 The briefcase model is sometimes called the disconnected model, or mobile computing. Developer’s Guide Scaling up to a three-tiered application When operating on site, a briefcase model application looks like a multi-tiered model: a user starts a client application on one machine and connects over a network to an\n\n\n\napplication server on a remote machine. The client requests data from the application server, and sends updates to it. The updates are applied by the application server to a database that is presumably shared with other clients throughout an organization. Suppose, however, that your onsite company database contains valuable customer contact data that your sales representatives can use and update in the field. In this case, it would be useful if your sales reps could download some or all of the data from the company database, work with it on their laptops as they fly across the country, and even update records at existing or new customer sites. When the sales reps return onsite, they need to upload their data changes to the company database for everyone to use. This ability to work with data off-line and then apply updates online at a later date is known as the “briefcase” model. By using the briefcase model, you can take advantage of the client dataset component’s ability to read\n\n\n\nand write data to flat files to create client applications that can be used both online with an application server, and off-line, as temporary one-tiered applications. To implement the briefcase model, you must 1 Create a multi-tiered server application as described in “Creating the application server” on page 15-11. 2 Create a flat-file database application as your client application. Add a connection component and set the RemoteServer property of your client datasets to specify this connection component. This allows them to talk to the application server created in step 1. For more information about connection components, see “Connecting to the application server” on page 15-17. 3 In the client application, try on start-up to connect to the application server. If the connection fails, prompt the user for a file and read in the local copy of the data. 4 In the client application, add code to apply updates to the application server. For more information on sending updates from\n\n\n\na client application to an application server, see “Updating records” on page 25-20. Scaling up to a three-tiered application In a two-tiered client/server application, the application is a client that talks directly to a database server. Even so, the application can be thought of as having two parts: a database connection and a user interface. To make a two-tiered client/server application into a multi-tiered application you must:\n• Split your existing application into an application server that handles the database connection, and a client application that contains the user interface.\n• Add an interface between the client and the application server. Building one- and two-tiered applications 14-17 S c a lhttp://www.doksihu ing up to a three-tiered application Forrás: There are a number of ways to proceed, but the following sequential steps may best keep your translation work to a minimum: 1 Create a new project for the application server, starting with a remote data\n\n\n\nmodule. See “Creating the application server” on page 15-11 for details on how to do this. 2 Duplicate the relevant database connection portions of your former two-tiered application, and for each dataset, add a provider component that will act as a data conduit between the application server and the client. For more information on using a provider component, see Chapter 16, “Using provider components.” 3 Copy your existing two-tiered project, remove its direct database connections, add an appropriate connection component to it. For more information about creating and using connection components, see “Connecting to the application server” on page 15-17. 4 Substitute a client dataset for each dataset component in the original project. For general information about using a client dataset component, see Chapter 25, “Creating and using a client dataset.” 5 In the client application, add code to apply updates to the application server. For more information on sending updates\n\n\n\nfrom a client application to an application server, see “Updating records” on page 25-20. 6 Move the dataset components to the application server’s data modules. Set the DataSet property of each provider to specify the corresponding datasets. For more information about linking a dataset to a provider component, see Chapter 16, “Using provider components.” 14-18 Developer’s Guide Chapter 15 Creating multi-tiered applications Chapter15 This chapter describes how to create a multi-tiered, client/server database application. A multi-tiered client/server application is partitioned into logical units which run in conjunction on separate machines. Multi-tiered applications share data and communicate with one another over a local-area network or even over the Internet. They provide many benefits, such as centralized business logic and thin client applications. In its simplest form, sometimes called the “three-tiered model,” a multi-tiered application is partitioned\n\n\n\ninto thirds:\n• Client application: provides a user interface on the user’s machine.\n• Application server: resides in a central networking location accessible to all clients and provides common data services.\n• Remote database server: provides the relational database management system (RDBMS). In this three-tiered model, the application server manages the flow of data between clients and the remote database server, so it is sometimes called a “data broker.” With C++Builder you usually only create the application server and its clients, although, if you are really ambitious, you could create your own database back end as well. In more complex multi-tiered applications, additional services reside between a client and a remote database server. For example, there might be a security services broker to handle secure Internet transactions, or bridge services to handle sharing of data with databases on platforms not directly supported by C++Builder. C++Builder support for\n\n\n\nmulti-tiered applications is based on the Multi-tier Distributed Application Services Suite (MIDAS). This chapter focuses on creating a three-tiered database application using the MIDAS technology. Once you understand how to create and manage a three-tiered application, you can create and add additional service layers based on your needs. Creating multi-tiered applications 15-1 A d v ahttp://www.doksihu ntages of the multi-tiered database model Forrás: Advantages of the multi-tiered database model The multi-tiered database model breaks a database application into logical pieces. The client application can focus on data display and user interactions. Ideally, it knows nothing about how the data is stored or maintained. The application server (middle tier) coordinates and processes requests and updates from multiple clients. It handles all the details of defining datasets and interacting with the remote database server. The advantages of this multi-tiered model include the\n\n\n\nfollowing:\n• Encapsulation of business logic in a shared middle tier. Different client applications all access the same middle tier. This allows you to avoid the redundancy (and maintenance cost) of duplicating your business rules for each separate client application.\n• Thin client applications. Your client applications can be written to make a small footprint by delegating more of the processing to middle tiers. Not only are client applications smaller, but they are easier to deploy because they don’t need to worry about installing, configuring, and maintaining the database connectivity software (such as the Borland Database Engine). Thin client applications can be distributed over the internet for additional flexibility.\n• Distributed data processing. Distributing the work of an application over several machines can improve performance because of load balancing, and allow redundant systems to take over when a server goes down.\n• Increased opportunity for security. You can\n\n\n\nisolate sensitive functionality into tiers that have different access restrictions. This provides flexible and configurable levels of security. Middle tiers can limit the entry points to sensitive material, allowing you to control access more easily. If you are using HTTP or MTS, you can take advantage of the security models they support. Understanding MIDAS technology MIDAS provides the mechanism by which client applications and application servers communicate database information. Using MIDAS requires MIDASDLL, which is used by both client and server applications to manage datasets stored as data packets. Building MIDAS applications may also require the SQL explorer to help in database administration and to import server constraints into the Data Dictionary so that they can be checked at any level of the multi-tiered application. Note You must purchase server licenses for deploying your MIDAS applications. MIDAS-based multi-tiered applications use the components on the MIDAS page\n\n\n\nof the component palette, plus a remote data module that is created by a wizard on the 15-2 Developer’s Guide Understanding MIDAS technology Multitier page of the New Items dialog. These components are described in Table 15.1: Table 15.1 MIDAS components Component Description remote data modules Specialized data modules that work with a COM Automation server to give client applications access to any providers they contain. Used on the application server. provider component A data broker that provides data by creating data packets and resolves client updates. Used on the application server client dataset component A specialized dataset that uses MIDAS.DLL to manage data stored in data packets. connection components A family of components that locate the server, form connections, and make the IAppServer interface available to client datasets. Each connection component is specialized to use a particular communications protocol. Overview of a MIDAS-based multi-tiered\n\n\n\napplication The following numbered steps illustrate a normal sequence of events for a MIDAS-based multi-tiered application: 1 A user starts the client application. The client connects to the application server (which can be specified at design time or runtime). If the application server is not already running, it starts. The client receives an IAppServer interface from the application server. 2 The client requests data from the application server. A client may request all data at once, or may request chunks of data throughout the session (fetch on demand). 3 The application server retrieves the data (first establishing a database connection, if necessary), packages it for the client, and returns a data packet to the client. Additional information, (for example, about data constraints imposed by the database) can be included in the metadata of the data packet. This process of packaging data into data packets is called “providing.” 4 The client decodes the data packet and displays\n\n\n\nthe data to the user. 5 As the user interacts with the client application, the data is updated (records are added, deleted, or modified). These modifications are stored in a change log by the client. 6 Eventually the client applies its updates to the application server, usually in response to a user action. To apply updates, the client packages its change log and sends it as a data packet to the server. 7 The application server decodes the package and posts updates in the context of a transaction. If a record can’t be posted to the server (for example, because another application changed the record after the client requested it and before the client applied its updates), the application server either attempts to reconcile the client’s changes with the current data, or saves the records that could not be posted. This process of posting records and caching problem records is called “resolving.” Creating multi-tiered applications 15-3 U n d http://www.doksihu erstanding MIDAS\n\n\n\ntechnology Forrás: 8 When the application server finishes the resolving process, it returns any unposted records to the client for further resolution. 9 The client reconciles unresolved records. There are many ways a client can reconcile unresolved records. Typically the client attempts to correct the situation that prevented records from being posted or discards the changes. If the error situation can be rectified, the client applies updates again. 10 The client refreshes its data from the server. The structure of the client application To the end user, the client application of a multi-tiered application looks and behaves no differently than a traditional two-tiered application that uses cached updates. Structurally, the client application looks a lot like a flat-file single-tiered application. User interaction takes place through standard data-aware controls that display data from a client dataset component. For detailed information about using the properties, events, and methods\n\n\n\nof client datasets, see Chapter 25, “Creating and using a client dataset.” Unlike in a flat-file application, the client dataset in a multi-tiered application obtains its data through the IAppServer interface on the application server. It uses this interface to post updates to the application server as well. For more information about the IAppServer interface, see “Using the IAppServer interface” on page 15-8. The client gets this interface from a connection component. The connection component establishes the connection to the application server. Different connection components are available for using different communications protocols. These connection components are summarized in the following table: Table 15.2 Connection components Component Note Protocol TDCOMConnection DCOM TSocketConnection Windows sockets (TCP/IP) TWebConnection HTTP Three other connection components, TRemoteServer, TMIDASConnection, and TOLEnterpriseConnection are provided for backward\n\n\n\ncompatibility. For more information about using connection components, see “Connecting to the application server” on page 15-17. The structure of the application server The application server contains a special class, called the implementation object, that descends from REMOTEDATAMODULE IMPL(). REMOTEDATAMODULE IMPL is a macro defined in Atlvcl.h that lists the ancestors for the implementation object These include the ATL classes CComObjectRootEx and CComCoClass, as well as the 15-4 Developer’s Guide Understanding MIDAS technology IAppServer interface, which client applications use to communicate with data providers. If you are creating an application server that can take advantage of the distributed application services provided by MTS or COM+, REMOTEDATAMODULE IMPL also includes the IObjectControl interface, which is required of all transactional objects. The implementation class, which is generated for you by a wizard, has access to an IObjectContext interface, which\n\n\n\nis provided by the system on its behalf and which it uses to manage transactions, free resources, and take advantage of security support. In addition to the class that supports the IAppServer interface, application servers contain a remote data module that includes a dataset provider component for each dataset the application server makes available to client applications. A dataset provider\n• Receives data requests from the client, fetches the requested data from the database server, packages the data for transmission, and sends the data to the client dataset. This activity is called “providing”\n• Receives updated data from the client dataset, applies updates to the database or source dataset, and logs any updates that cannot be applied, returning unresolved updates to the client for further reconciliation. This activity is called “resolving” Often, the provider uses BDE- or ADO-enabled datasets such as you find in a two-tiered application. You can add database and session\n\n\n\ncomponents as needed, just as in a BDE-based two-tiered application, or add ADO connection components as in an ADO-based two-tiered application. Note Do not confuse the ADO connection component, which is analogous to a database component in a BDE-based application, with the connection components used by client applications in a multitiered application. For more information about two-tiered applications, see Chapter 14, “Building oneand two-tiered applications.” If the application server is to be deployed under MTS or COM+, the remote data module includes events for when the application server is activated or deactivated. This permits the application server to acquire database connections when activated and release them when deactivated. Using transactional data modules You can write an application server that takes advantage of special services for distributed applications that are supplied by MTS (before Windows 2000) or COM+ (under Windows 2000 and later). To do so, you create\n\n\n\na transactional data module instead of an ordinary remote data module. When you use a transactional data module, your application can take advantage of the following special services:\n• Security. MTS and COM+ provide role-based security for your application server Clients are assigned roles, which determine how they can access the application server’s interface. In addition, you can use the IObjectContext interface which is Creating multi-tiered applications 15-5 U n d http://www.doksihu erstanding MIDAS technology Forrás: accessed through your implementation class, to access these security services. For more information about MTS security, see “Role-based security” on page 38-16.\n• Database handle pooling. Transactional data modules automatically pool database connections that are made via ADO or (if you are using MTS and turn on MTS POOLING) the BDE. When one client is finished with a database connection, another client can reuse it. This cuts down on network traffic,\n\n\n\nbecause your middle tier does not need to log off of the remote database server and then log on again. When pooling database handles, your database or ADO connection component should set its KeepConnection property to false, so that your application maximizes the sharing of connections. For more information about pooling database handles, see “Database resource dispensers” on page 38-5.\n• Transactions. When using a transactional data module, you can provide enhanced transaction support beyond that available with a single database connection. Transactional databases can participate in transactions that span multiple databases, or include functions that do not involve databases at all. For more information about the transaction support provided by transactional objects such as transactional databases, see “Managing transactions in multi-tiered applications” on page 15-21.\n• Just-in-time activation and as-soon-as-possible deactivation. You can write your server so that\n\n\n\ninstances are activated and deactivated on an as-needed basis. When using just-in-time activation and as-soon-as-possible deactivation, your application server is instantiated only when it is needed to handle client requests. This prevents it from tying up resources such as database handles when they are not in use. Using just-in-time activation and as-soon-as-possible deactivation provides a middle ground between routing all clients through a single remote data module instance, and creating a separate instance for every client connection. With a single remote data module instance, the application server must handle all database calls through a single database connection. This acts as a bottleneck, and can impact performance when there are many clients. With multiple instances of the remote data module, each instance can maintain a separate database connection, thereby avoiding the need to serialize database access. However, this monopolizes resources because other clients can’t use\n\n\n\nthe database connection while it is associated with another client’s remote data module. To take advantage of transactions, just-in-time activation, and as-soon-as-possible deactivation, remote data module instances must be stateless. This means you must provide additional support if your client relies on state information. For example, the client must pass information about the current record when performing incremental fetches. For more information about state information and remote data modules in multi-tiered applications, see “Supporting state information in remote data modules” on page 15-23. By default, all automatically generated calls to a transactional data module are transactional (that is, they assume that when the call exits, the data module can be deactivated and any current transactions committed or rolled back). You can write a transactional data module that depends on persistent state information by setting the 15-6 Developer’s Guide Understanding MIDAS\n\n\n\ntechnology AutoComplete property to false, but it will not support transactions, just-in-time activation, or as-soon-as-possible deactivation unless you use a custom interface. Warning Application servers containing transactional data modules should not open database connections until the data module is activated. While developing your application, be sure that all datasets are not active and the database is not connected before running your application. In the application itself, add code to open database connections when the data module is activated and close them when it is deactivated. Pooling remote data modules Object pooling allows you to create a cache of application servers that are shared by their clients, thereby conserving resources. How this works depends on the type of remote data module and on the connection protocol. If you are creating a transactional data module that will be installed to COM+, you can use the COM+ Component Manager to install the application server\n\n\n\nas a pooled object. See “Object pooling” on page 38-9 for details Even if you are not using a transactional data module, you can take advantage of object pooling if the connection is formed using HTTP. Under this second type of object pooling, you limit the number of instances of your application server that are created. This limits the number of database connections that you must hold, as well as any other resources used by the application server. When the Web Server application (which passes calls to your application server) receives client requests, it passes them on to the first available application server in the pool. If there is no available application server, it creates a new one (up to a maximum number that you specify). This provides a middle ground between routing all clients through a single application server instance (which can act as a bottleneck), and creating a separate instance for every client connection (which can consume many resources). If an application\n\n\n\nserver instance in the pool does not receive any client requests for a while, it is automatically freed. This prevents the pool from monopolizing resources unless they are used. To set up object pooling when using a Web connection (HTTP), do the following: 1 Locate the UpdateRegistry method of the implementation class. This method appears in the header file of your implementation unit: static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { TRemoteDataModuleRegistrar regObj(GetObjectCLSID(), GetProgID(), GetDescription()); return regObj.UpdateRegistry(bRegister); } 2 Set the RegisterPooled flag of the regObj variable, which is an instance of TRemoteDataModuleRegistrar, to true. You will also want to set other properties of regObj to indicate how the cache of remote data modules should be managed. For Creating multi-tiered applications 15-7 U n d http://www.doksihu erstanding MIDAS technology Forrás: example, the following code allows a maximum of 10 remote data module instances\n\n\n\nand frees them from the cache if they are idle for more than 15 minutes: static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { TRemoteDataModuleRegistrar regObj(GetObjectCLSID(), GetProgID(), GetDescription()); regObj.RegisterPooled = true; regObj.Timeout = 15; regObj.Max = 10; return regObj.UpdateRegistry(bRegister); } When using either method of object pooling, your application server must be stateless. This is because a single instance potentially handles requests from several clients. If it relied on persistent state information, clients could interfere with each other. See “Supporting state information in remote data modules” on page 15-23 for more information on how to ensure that your remote data module is stateless. Using the IAppServer interface Application servers support the IAppServer interface. Connection components on client applications look for this interface to form connections. IAppServer provides the bridge between client applications and the provider\n\n\n\ncomponents in the application server. Most client applications do not use IAppServer directly, but invoke it indirectly through the properties and methods of the client dataset. However, when necessary, you can make direct calls to the IAppServer interface by using the AppServer property of the client dataset. Table 15.3 lists the methods of the IAppServer interface, as well as the corresponding methods and events on the provider component and the client dataset. These IAppServer methods include a Provider parameter to indicate which provider on the application server should provide data or resolve updates. In addition, most methods include an OleVariant parameter called OwnerData that allows the client application and application server to pass custom information back and forth. OwnerData is not used by default, but is passed to all event handlers so that you can write code that allows your application server to adjust for this information before and after each client call. Table 15.3\n\n\n\n 15-8 AppServer interface members IAppServer Provider component TClientDataSet AS ApplyUpdates method ApplyUpdates method, BeforeApplyUpdates event, AfterApplyUpdates event ApplyUpdates method, BeforeApplyUpdates event, AfterApplyUpdates event. AS DataRequest method DataRequest method, OnDataRequest event DataRequest method. AS Execute method Execute method, BeforeExecute event, AfterExecute event Execute method, BeforeExecute event, AfterExecute event. AS GetParams method GetParams method, BeforeGetParams event, AfterGetParams event FetchParams method, BeforeGetparams event, AfterGetParams event. Developer’s Guide Understanding MIDAS technology Table 15.3 AppServer interface members (continued) IAppServer Provider component TClientDataSet AS GetProviderNames method Used to identify all available providers. Used to create a design-time list for ProviderName property. AS GetRecords method GetRecords method, BeforeGetRecords event, AfterGetRecords event \n\n\n\nGetNextPacket method, Data property, BeforeGetRecords event, AfterGetRecords event AS RowRequest method RowRequest method, BeforeRowRequest event, AfterRowRequest event FetchBlobs method, FetchDetails method, RefreshRecord method, BeforeRowRequest event, AfterRowRequest event Choosing a connection protocol Each communications protocol you can use to connect your client applications to the application server provides its own unique benefits. Before choosing a protocol, consider how many clients you expect, how you are deploying your application, and future development plans. Using DCOM connections DCOM provides the most direct approach to communication, requiring no additional runtime applications on the server. However, because DCOM is not included with Windows 95, some older client machines may not have DCOM installed. DCOM provides the only approach that lets you use security services when writing a transactional data module. These security services are based on assigning roles\n\n\n\nto the callers of transactional objects. When using DCOM, DCOM identifies the caller to the system that calls your application server (MTS or COM+). Therefore, it is possible to accurately determine the role of the caller. When using other protocols, however, there is a runtime executable, separate from the application server, that receives client calls. This runtime executable makes COM calls into the application server on behalf of the client. Because of this, it is impossible to assign roles to separate clients: The runtime executable is, effectively, the only client. For more information about security and transactional objects, see “Role-based security” on page 38-16. Using Socket connections TCP/IP Sockets let you create lightweight clients. For example, if you are writing a Web-based client application, you can’t be sure that client systems support DCOM. Sockets provide a lowest common denominator that you know will be available for connecting to the application server.\n\n\n\nFor more information about sockets, see Chapter 31, “Working with sockets.” Instead of instantiating the remote data module directly from the client (as happens with DCOM), sockets use a separate application on the server (ScktSrvr.exe), which accepts client requests and instantiates the application server using COM. The Creating multi-tiered applications 15-9 U n d http://www.doksihu erstanding MIDAS technology Forrás: connection component on the client and ScktSrvr.exe on the server are responsible for marshaling IAppServer calls. Note ScktSrvr.exe can run as an NT service application Register it with the Service manager by starting it using the -install command line option. You can unregister it using the -uninstall command line option. Before you can use a socket connection, the application server must register its availability to clients using a socket connection. By default, all new remote data modules automatically register themselves via the\n\n\n\nTRemoteDataModuleRegistrar object in the UpdateRegistry method of the implementation object. You can prevent this registration by setting that object’s EnableSocket property to false. Note Because older servers did not add this registration, you can disable the check for whether an application server is registered by unchecking the Connections|Registered Objects Only menu item on ScktSrvr.exe When using sockets, there is no protection on the server against client systems failing before they release a reference to interfaces on the application server. While this results in less message traffic than when using DCOM (which sends periodic keep-alive messages), this can result in an application server that can’t release its resources because it is unaware that the client has gone away. Using Web connections HTTP lets you create clients that can communicate with an application server that is protected by a “firewall”. HTTP messages provide controlled access to internal\n\n\n\napplications so that you can distribute your client applications safely and widely. Like Socket connections, HTTP messages provide a lowest common denominator that you know will be available for connecting to the application server. For more information about HTTP messages, see Chapter 30, “Creating Internet server applications.” Instead of instantiating the remote data module directly from the client (as happens with DCOM), HTTP-based connections use a Web server application on the server (httpsrvr.dll) that accepts client requests and instantiates the application server using COM. Because of this, they are also called Web connections The connection component on the client and httpsrvr.dll on the server are responsible for marshaling IAppServer calls. Web connections can take advantage of the SSL security provided by wininet.dll (a library of internet utilities that runs on the client system). Once you have configured the Web server on the server system to require authentication,\n\n\n\nyou can specify the user name and password using the properties of the Web connection component. As an additional security measure, the application server must register its availability to clients using a Web connection. By default, all new remote data modules automatically register themselves via the TRemoteDataModuleRegistrar object in the UpdateRegistry method of the implementation object. You can prevent this registration by setting that object’s EnableWeb property to false. Web connections can take advantage of object pooling. This allows your server to create a limited pool of application server instances that are available for client requests. By pooling the application servers, your server does not consume the 15-10 Developer’s Guide Building a multi-tiered application resources for the data module and its database connection except when they are needed. For more information on object pooling, see “Pooling remote data modules” on page 15-7. Unlike other connection\n\n\n\ncomponents, you can’t use callbacks when the connection is formed via HTTP. Building a multi-tiered application The general steps for creating a multi-tiered database application are 1 Create the application server. 2 Register or install the application server.\n• If the application server uses DCOM, HTTP, or sockets as a communication protocol, it acts as an Automation server and must be registered like any other r COM server. For information about registering an application, see “Registering a COM object” on page 35-16.\n• If you are using a transactional data module, you do not register the application server. Instead, you install it with MTS or COM+ For information about installing transactional objects, see “Installing transactional objects” on page 38-24. 3 Create a client application. The order of creation is important. You should create and run the application server before you create a client. At design time, you can then connect to the application server to\n\n\n\ntest your client. You can, of course, create a client without specifying the application server at design time, and only supply the server name at runtime. However, doing so prevents you from seeing if your application works as expected when you code at design time, and you will not be able to choose servers and providers using the Object Inspector. Note If you are not creating the client application on the same system as the server, and you are not using a Web connection or socket connection, you may want to register or install the application server on the client system. This makes the connection component aware of the application server at design time so that you can choose server names and provider names from a drop-down list in the Object Inspector. (If you are using a Web connection or socket connection, the connection component fetches the names of registered servers from the server machine.) Creating the application server You create an application server very much as you\n\n\n\ncreate most database applications. The major difference is that the application server includes a dataset provider. Creating multi-tiered applications 15-11 C r e ahttp://www.doksihu ting the application server Forrás: To create an application server, start a new project, save it, and follow these steps: 1 Add a new remote data module to the project. From the main menu, choose File|New. Choose the Multitier page in the new items dialog, and select\n• Remote Data Module if you are creating a COM Automation server that clients access using DCOM, HTTP, or sockets.\n• Transactional Data Module if you are creating a remote data module that runs under MTS or COM+. Connections can be formed using DCOM, HTTP, or sockets. However, only DCOM supports the security services For more detailed information about setting up a remote data module, see “Setting up the remote data module” on page 15-13. Note When you add a remote data module to your project, the Wizard also creates a special\n\n\n\nCOM Automation object that contains a reference to the remote data module and uses it to look for providers. This object is called the implementation object. 2 Place the appropriate dataset components on the data module and set them up to access the database server. 3 Place a TDataSetProvider component on the data module for each dataset. This provider is required for brokering client requests and packaging data. 4 Set the DataSet property for each provider component to the name of the dataset to access. There are additional properties that you can set for the provider For more detailed information about setting up a provider, see Chapter 16, “Using provider components.” 5 Write application server code to implement events, shared business rules, shared data validation, and shared security. You may want to extend the application server’s interface to provide additional ways that the client application can call the server. For more information about extending the application\n\n\n\nserver’s interface, see “Extending the application server’s interface” on page 15-15. 6 Save, compile, and register or install the application server.\n• When the application server uses DCOM, HTTP, or sockets as a communication protocol, it acts as an Automation server and must be registered like any other ActiveX or COM server. For information about registering an application, see “Registering a COM object” on page 35-16.\n• If you are using a transactional data module, you do not register the application server. Instead, you install it with MTS or COM+ For information about installing transactional objects, see “Installing transactional objects” on page 38-24. 7 If your server application does not use DCOM, you must install the runtime software that receives client messages, instantiates the remote data module, and marshals interface calls.\n• For TCP/IP sockets this is a socket dispatcher application, Scktsrvr.exe\n• For HTTP connections this is httpsrvr.dll,\n\n\n\nan ISAPI/NSAPI DLL that must be installed with your Web server. 15-12 Developer’s Guide Creating the application server Setting up the remote data module When you set up and run an application server, it does not establish any connection with client applications. Instead, connection is maintained by client applications The client application uses its connection component to establish a connection to the application server, which it uses to communicate with its selected provider. All of this happens automatically, without your having to write code to manage incoming requests or supply interfaces. When you create the remote data module, you must provide certain information that indicates how it responds to client requests. This information varies, depending on whether your remote data module is transactional. Configuring the remote data module when it is not transactional To add a remote data module to your application without including transactional attributes, choose File|New\n\n\n\nand select Remote Data Module from the Multitier page of the new items dialog. You will see the Remote Data Module wizard You must supply a class name for your remote data module. This is the base name of a descendant of TCRemoteDataModule that your application creates. It is also the base name of the application server’s interface. For example, if you specify the class name MyDataServer, the wizard creates a new unit declaring TMyDataServer, a descendant of TCRemoteDataModule. In the unit header, the Wizard also declares a the implementation class (TMyDataServerImpl) that implements IMyDataServer, a descendant of IAppServer. Note You can add your own properties and methods to the new interface. For more information, see “Extending the application server’s interface” on page 15-15. You must specify the threading model in the Remote Data Module wizard. You can choose Single-threaded, Apartment-threaded, Free-threaded, or Both.\n• If you choose Single-threaded, COM ensures that\n\n\n\nonly one client request is serviced at a time. You do not need to worry about client requests interfering with each other.\n• If you choose Apartment-threaded, COM ensures that any instance of your remote data module services one request at a time. When writing code in an Apartment-threaded library, you must guard against thread conflicts if you use global variables or objects not contained in the remote data module. This is the recommended model if you are using BDE-enabled datasets. (Note that you will need a session component with its AutoSessionName property set to true to handle threading issues on BDE-enabled datasets)\n• If you choose Free-threaded, your application can receive simultaneous client requests on several threads. You are responsible for ensuring your application is thread-safe. Because multiple clients can access your remote data module simultaneously, you must guard your instance data (properties, contained objects, and so on) as well as global variables. This is\n\n\n\nthe recommended model if you are using ADO datasets. Creating multi-tiered applications 15-13 C r e ahttp://www.doksihu ting the application server Forrás:\n• If you choose Both, your library works the same as when you choose Free-threaded, with one exception: all callbacks (calls to client interfaces) are serialized for you.\n• If you choose Neutral, the remote data module can receive simultaneous calls on separate threads, as in the Free-threaded model, but COM guarantees that no two threads access the same method at the same time. Configuring a transactional remote data module To add a remote data module to your application when you will be using MTS or COM+, choose File|New and select Transactional Data Module from the Multitier page of the new items dialog. You will see the Transactional Data Module wizard You must supply a class name for your remote data module. This is the base name of a descendant of TCRemoteDataModule that your application creates. It is also the base\n\n\n\nname of the application server’s interface. For example, if you specify the class name MyDataServer, the wizard creates a new unit declaring TMyDataServer, a descendant of TCRemoteDataModule. In the unit header, the Wizard also declares the implementation class (TMyDataServerImpl) that implements both IMyDataServer (a descendant of IAppServer) and IObjectControl (which is required of all transactional objects). TMyDataServerImpl includes a data member for the IObjectContext interface, which you can use to manage transactions, check security, and so on. Note You can add your own properties and methods to your new interface. For more information, see “Extending the application server’s interface” on page 15-15. You must specify the threading model in the Transactional Data Module wizard. Choose Single, Apartment, or Both.\n• If you choose Single, client requests are serialized so that your application services only one at a time. You do not need to worry about client requests\n\n\n\ninterfering with each other.\n• If you choose Apartment, the system ensures that any instance of your remote data module services one request at a time, and calls always use the same thread. You must guard against thread conflicts if you use global variables or objects not contained in the remote data module. Instead of using global variables, you can use the shared property manager. For more information on the shared property manager, see “Shared property manager” on page 38-6.\n• If you choose Both, MTS calls into the application server’s interface in the same way as when you choose Apartment. However, any callbacks you make to client applications are serialized, so that you don’t need to worry about them interfering with each other. Note The Apartment model under MTS or COM+ is different from the corresponding model under DCOM. You must also specify the transaction attributes of your remote data module. You can choose from the following options:\n• Requires a\n\n\n\ntransaction. When you select this option, every time a client uses your application server’s interface, that call is executed in the context of a transaction. If the caller supplies a transaction, a new transaction need not be created. 15-14 Developer’s Guide Creating the application server\n• Requires a new transaction. When you select this option, every time a client uses your application server’s interface, a new transaction is automatically created for that call.\n• Supports transactions. When you select this option, your application server can be used in the context of a transaction, but the caller must supply the transaction when it invokes the interface.\n• Does not support transactions. When you select this option, your application server can’t be used in the context of transactions. Creating a data provider for the application server Each remote data module on an application server contains one or more provider components. Each client dataset uses a specific\n\n\n\nprovider, which acts as the bridge between the client dataset and the data it represents. A provider component (TDataSetProvider) takes care of packaging data into data packets that it sends to clients and applying updates received from the client. Most of the data logic in the application server is handled by the provider components contained in the remote data module. Event handlers that respond to client requests implement your business and data logic, while properties on the provider component control what information is included in data packets. See Chapter 16, “Using provider components” for details on how to use a provider component to control the interaction with client applications. Extending the application server’s interface Client applications interact with the application server by creating or connecting to the implementation class that was created by the data module Wizard. They use its interface as the basis of all communication with the application server. You\n\n\n\ncan add to your implementation class’s interface to provide additional support for your client applications. This interface is a descendant of IAppServer and is created for you automatically by the wizard when you create the remote data module. To add to the implementation class’s interface, use the type library editor. For more information about using the type library editor, see Chapter 33, “Working with type libraries.” When you add to a COM interface, your changes are added to your unit source code and the type library file (.TLB) Note You must explicitly save the TLB file by choosing Refresh in the type library editor and then saving the changes from the IDE. Once you have added to your implementation class’s interface, locate the properties and methods that were added to your implementation class. Add code to finish this implementation by filling in the bodies of the new methods. Creating multi-tiered applications 15-15 C r e ahttp://www.doksihu ting the client\n\n\n\napplication Forrás: Client applications call your interface extensions using the AppServer property of their connection component. For more information on how to do this, see “Calling server interfaces” on page 15-21. Adding callbacks to the application server’s interface You can allow the application server to call your client application by introducing a callback. To do this, the client application passes an interface to one of the application server’s methods, and the application server later calls this method as needed. However, if your extensions to the implementation class’s interface include callbacks, you can’t use an HTTP-based connection. TWebConnection does not support callbacks. If you are using a socket-based connection, client applications must indicate whether they are using callbacks by setting the SupportCallbacks property. All other types of connection automatically support callbacks. Extending a transactional application server’s interface When\n\n\n\nusing transactions or just-in-time activation, you must be sure all new methods call the IObjectContext’s SetComplete method to indicate when they are finished. This allows transactions to complete and permits the application server to be deactivated. Furthermore, you can’t return any values from your new methods that allow the client to communicate directly with objects or interfaces on the application server unless they provide a safe reference. If you are using a stateless MTS data module, neglecting to use a safe reference can lead to crashes because you can’t guarantee that the remote data module is active. For more information on safe references, see “Passing object references” on page 38-22. Creating the client application In most regards, creating a multi-tiered client application is similar to creating a traditional two-tiered client. The major differences are that a multi-tiered client uses\n• A connection component to establish a conduit to the application\n\n\n\nserver.\n• One or more TClientDataSet components to link to a data provider on the application server. Data-aware controls on the client are connected through data source components to these client datasets instead of TTable, TQuery, TStoredProc or TADODataSet components. To create a multi-tiered client application, start a new project and follow these steps: 1 Add a new data module to the project. 2 Place a connection component on the data module. The type of connection component you add depends on the communication protocol you want to use. See “The structure of the client application” on page 15-4 for details. 3 Set properties on your connection component to specify the application server with which it should establish a connection. To learn more about setting up the connection component, see “Connecting to the application server” on page 15-17. 15-16 Developer’s Guide Creating the client application 4 Set the other connection component properties as needed for\n\n\n\nyour application. For example, you might set the ObjectBroker property to allow the connection component to choose dynamically from several servers. For more information about using the connection components, see “Managing server connections” on page 15-20. 5 Place as many TClientDataSet components as needed on the data module, and set the RemoteServer property for each component to the name of the connection component you placed in Step 2. For a full introduction to client datasets, see Chapter 25, “Creating and using a client dataset.” 6 Set the ProviderName property for each TClientDataSet component. If your connection component is connected to the application server at design time, you can choose available application server providers from the ProviderName property’s drop-down list. 7 Create the client application in much the same way you would create any other database application. You will probably want to use some of the special features of client datasets that support\n\n\n\ntheir interaction with the provider components on the application server. These are described in “Using a client dataset with a data provider” on page 25-14. Connecting to the application server To establish and maintain a connection to an application server, a client application uses one or more connection components. You can find these components on the MIDAS page of the Component palette. Use a connection component to\n• Identify the protocol for communicating with the application server. Each type of connection component represents a different communication protocol. See “Choosing a connection protocol” on page 15-9 for details on the benefits and limitations of the available protocols.\n• Indicate how to locate the server machine. The details of identifying the server machine vary depending on the protocol.\n• Identify the application server on the server machine using the ServerName or ServerGUID property. ServerName identifies the base name of the class you specify\n\n\n\nwhen creating the remote data module on the application server. See “Setting up the remote data module” on page 15-13 for details on how this value is specified on the server. If the server is registered or installed on the client machine, or if the connection component is connected to the server machine, you can set the ServerName property at design time by choosing from a drop-down list in the Object Inspector. ServerGUID specifies the GUID of the remote data module’s interface. You can look up this value using the type library editor\n• Manage server connections. Connection components can be used to create or drop connections and to call application server interfaces. Usually the application server is on a different machine from the client application, but even if the server resides on the same machine as the client application (for Creating multi-tiered applications 15-17 C r e ahttp://www.doksihu ting the client application Forrás: example, during the building and\n\n\n\ntesting of the entire multi-tier application), you can still use the connection component to identify the application server by name, specify a server machine, and use the application server interface. Specifying a connection using DCOM When using DCOM to communicate with the application server, client applications include a TDCOMConnection component for connecting to the application server. TDCOMConnection uses the ComputerName property to identify the machine on which the server resides. When ComputerName is blank, the DCOM connection component assumes that the application server resides on the client machine or that the application server has a system registry entry. If you do not provide a system registry entry for the application server on the client when using DCOM, and the server resides on a different machine from the client, you must supply ComputerName. Note Even when there is a system registry entry for the application server, you can specify ComputerName to override this\n\n\n\nentry. This can be especially useful during development, testing, and debugging. If you have multiple servers that your client application can choose from, you can use the ObjectBroker property instead of specifying a value for ComputerName. For more information, see “Brokering connections” on page 15-19. If you supply the name of a host computer or server that cannot be found, the DCOM connection component throws an exception when you try to open the connection. Specifying a connection using sockets You can establish a connection to the application server using sockets from any machine that has a TCP/IP address. This method has the advantage of being applicable to more machines, but does not provide for using any security protocols. When using sockets, include a TSocketConnection component for connecting to the application server. TSocketConnection identifies the server machine using the IP Address or host name of the server system, and the port number of the socket dispatcher\n\n\n\nprogram (Scktsrvr.exe) that is running on the server machine For more information about IP addresses and port values, see “Describing sockets” on page 31-3. Three properties of TSocketConnection specify this information:\n• Address specifies the IP Address of the server.\n• Host specifies the host name of the server.\n• Port specifies the port number of the socket dispatcher program on the application server. Address and Host are mutually exclusive. Setting one unsets the value of the other For information on which one to use, see “Describing the host” on page 31-4. If you have multiple servers that your client application can choose from, you can use the ObjectBroker property instead of specifying a value for Address or Host. For more information, see “Brokering connections” on page 15-19. 15-18 Developer’s Guide Creating the client application By default, the value of Port is 211, which is the default port number of the socket dispatcher programs supplied with\n\n\n\nC++Builder. If the socket dispatcher has been configured to use a different port, set the Port property to match that value. Note You can configure the port of the socket dispatcher while it is running by right-clicking the Borland Socket Server tray icon and choosing Properties. Although socket connections do not provide for using security protocols, you can customize the socket connection to add your own encryption. To do this, create and register a COM object that supports the IDataIntercept interface. This is an interface for encrypting and decrypting data. Next, set the InterceptGUID property of the socket connection component to the GUID for this COM object. Finally, right click the Borland Socket Server tray icon, choose Properties, and on the properties tab set the Intercept GUID to the same GUID. This mechanism can also be used for data compression and decompression. Specifying a connection using HTTP You can establish a connection to the application server using HTTP from\n\n\n\nany machine that has a TCP/IP address. Unlike sockets, however, HTTP allows you to take advantage of SSL security and to communicate with a server that is protected behind a firewall. When using HTTP, include a TWebConnection component for connecting to the application server. The Web connection component establishes a connection to the Web server application (httpsrvr.dll), which in turn communicates with the application server TWebConnection locates httpsrvr.dll using a Uniform Resource Locator (URL) The URL specifies the protocol (http or, if you are using SSL security, https), the host name for the machine that runs the Web server and httpsrvr.dll, and the path to the Web server application (Httpsrvr.dll) Specify this value using the URL property Note When using TWebConnection, wininet.dll must be installed on the client machine If you have IE3 or higher installed, wininet.dll can be found in the Windows system directory. If the Web server requires authentication, or if you are\n\n\n\nusing a proxy server that requires authentication, you must set the values of the UserName and Password properties so that the connection component can log on. If you have multiple servers that your client application can choose from, you can use the ObjectBroker property instead of specifying a value for URL. For more information, see “Brokering connections” on page 15-19. Brokering connections If you have multiple servers that your client application can choose from, you can use an Object Broker to locate an available server system. The object broker maintains a list of servers from which the connection component can choose. When the connection component needs to connect to an application server, it asks the Object Broker for a computer name (or IP address, host name, or URL). The broker supplies a name, and the connection component forms a connection. If the supplied name does not work (for example, if the server is down), the broker supplies another name, and so on, until a\n\n\n\nconnection is formed. Creating multi-tiered applications 15-19 C r e ahttp://www.doksihu ting the client application Forrás: Once the connection component has formed a connection with a name supplied by the broker, it saves that name as the value of the appropriate property (ComputerName, Address, Host, RemoteHost, or URL). If the connection component closes the connection later, and then needs to reopen the connection, it tries using this property value, and only requests a new name from the broker if the connection fails. Use an Object Broker by specifying the ObjectBroker property of your connection component. When the ObjectBroker property is set, the connection component does not save the value of ComputerName, Address, Host, RemoteHost, or URL to disk. Managing server connections The main purpose of connection components is to locate and connect to the application server. Because they manage server connections, you can also use connection components to call the methods of\n\n\n\nthe application server’s interface. Connecting to the server To locate and connect to the application server, you must first set the properties of the connection component to identify the application server. This process is described in “Connecting to the application server” on page 15-17. In addition, before opening the connection, any client datasets that use the connection component to communicate with the application server should indicate this by setting their RemoteServer property to specify the connection component. The connection is opened automatically when client datasets try to access the application server. For example, setting the Active property of the client dataset to true opens the connection, as long as the RemoteServer property has been set. If you do not link any client datasets to the connection component, you can open the connection by setting the Connected property of the connection component to true. Before a connection component establishes a connection\n\n\n\nto an application server, it generates a BeforeConnect event. You can perform any special actions prior to connecting in a BeforeConnect handler that you code. After establishing a connection, the connection component generates an AfterConnect event for any special actions. Dropping or changing a server connection A connection component drops a connection to the application server when you\n• set the Connected property to false.\n• free the connection component. A connection object is automatically freed when a user closes the client application.\n• change any of the properties that identify the application server (ServerName, ServerGUID, ComputerName, and so on). Changing these properties allows you to switch among available application servers at runtime. The connection component drops the current connection and establishes a new one. 15-20 Developer’s Guide Note Managing transactions in multi-tiered applications Instead of using a single connection component to switch\n\n\n\namong available application servers, a client application can instead have more than one connection component, each of which is connected to a different application server. Before a connection component drops a connection, it automatically calls its BeforeDisconnect event handler, if one is provided. To perform any special actions prior to disconnecting, write a BeforeDisconnect handler. Similarly, after dropping the connection, the AfterDisconnect event handler is called. If you want to perform any special actions after disconnecting, write an AfterDisconnect handler. Calling server interfaces Applications do not need to call the IAppServer interface directly because the appropriate calls are made automatically when you use the properties and methods of the client dataset. However, while it is not necessary to work directly with the IAppServer interface, you may have added your own extensions to the application server’s interface. When you extend the application server’s\n\n\n\ninterface, you need a way to call those extensions using the connection created by your connection component. You can do this using the AppServer property of the connection component. For more information about extending the application server’s interface, see “Extending the application server’s interface” on page 15-15. AppServer is a Variant that represents the application server’s interface. To call this interface, you must obtain a dispatch interface from this Variant. The dispatch interface has the same name as the interface that was created when you created the remote data module, but with the string “Disp” appended. Thus, if your remote data module is called MyAppServer, you can use AppServer to call its interface as follows: IDispatch* disp = (IDispath)(MyConnection->AppServer) IMyAppServerDisp TempInterface( (IMyAppServer*)disp); TempInterface.SpecialMethod(x,y); Note The dispatch interface is declared in the TLB.h file generated by the Type Library editor. \n\n\n\nManaging transactions in multi-tiered applications When client applications apply updates to the application server, the provider component automatically wraps the process of applying updates and resolving errors in a transaction. This transaction is committed if the number of problem records does not exceed the MaxErrors value specified as an argument to the ApplyUpdates method. Otherwise, it is rolled back In addition, you can add transaction support to your server application by adding a database component or using passthrough SQL. This works the same way that you would manage transactions in a two-tiered application. For more information about this sort of transaction control, see “Using transactions” on page 14-5 and “Working with (connection) transactions” on page 24-10. Creating multi-tiered applications 15-21 S u p http://www.doksihu porting master/detail relationships Forrás: If you have a transactional data module, you can broaden your transaction support by\n\n\n\nusing MTS or COM+ transactions. These transactions can include any of the business logic on your application server, not just the database access. In addition, because they support two-phase commits, they can span multiple databases. Only the BDE- and ADO-based data access components support two-phase commit. Do not use InterbaseExpress components if you want to have transactions that span multiple databases. Warning When using the BDE, two-phase commit is fully implemented only on Oracle7 and MS-SQL databases. If your transaction involves multiple databases, and some of them are remote servers other than Oracle7 or MS-SQL, your transaction runs a small risk of only partially succeeding. Within any one database, however, you will always have transaction support. By default, all IAppServer calls on a transactional data module are transactional. You need only set the transaction attribute of your data module to indicate that it must participate in transactions. In addition, you can\n\n\n\nextend the application server’s interface to include method calls that encapsulate transactions that you define. If your transaction attribute indicates that the application server requires a transaction, then every time a client calls a method on its interface, it is automatically wrapped in a transaction. All client calls to your application server are then enlisted in that transaction until you indicate that the transaction is complete. These calls either succeed as a whole or are rolled back. Note Do not combine MTS or COM+ transactions with explicit transactions created by a database or ADO connection component or using passthrough SQL. When your transactional data module is enlisted in a transaction, it automatically enlists all of your database calls in the transaction as well. For more information about using MTS and COM+ transactions, see “MTS and COM+ transaction support” on page 38-9. Supporting master/detail relationships You can create master/detail relationships\n\n\n\nbetween client datasets in your client application in the same way you set up master/detail forms in one- and two-tiered applications. For more information about setting up master/detail forms, see “Creating master/detail forms” on page 21-25. However, this approach has two major drawbacks:\n• The detail table must fetch and store all of its records from the application server even though it only uses one detail set at a time. This problem can be mitigated by using parameters. For more information, see “Limiting records with parameters” on page 25-16.\n• It is very difficult to apply updates, because client datasets apply updates at the dataset level and master/detail updates span multiple datasets. Even in a two-tiered environment, where you can use the database to apply updates for multiple tables in a single transaction, applying updates in master/detail forms is 15-22 Developer’s Guide Supporting state information in remote data modules tricky. See “Applying\n\n\n\nupdates for master/detail tables” on page 26-6 for more information on applying updates in traditional master/detail forms. In multi-tiered applications, you can avoid these problems by using nested tables to represent the master/detail relationship. To do this, set up a master/detail relationship between the tables on the application server. Then set the DataSet property of your provider component to the master table. When clients call the GetRecords method of the provider, it automatically includes the detail datasets as a DataSet field in the records of the data packet. When clients call the ApplyUpdates method of the provider, it automatically handles applying updates in the proper order. See “Representing master/detail relationships” on page 25-3 for more information on using nested datasets to support master/detail relationships in client datasets. Supporting state information in remote data modules The IAppServer interface, which controls all communication between client\n\n\n\ndatasets and providers on the application server, is mostly stateless. When an application is stateless, it does not “remember” anything that happened in previous calls by the client. This stateless quality is useful if you are pooling database connections in a transactional data module, because your application server does not need to distinguish between database connections for persistent information such as record currency. Similarly, this stateless quality is important when you are sharing remote data module instances between many clients, as occurs with just-in-time activation or object pooling. However, there are times when you want to maintain state information between calls to the application server. For example, when requesting data using incremental fetching, the provider on the application server must “remember” information from previous calls (the current record). This is not a problem if the remote data module is configured so that each client has its own instance.\n\n\n\nWhen each client has its own instance of the remote data module, there are no other clients to change the state of the data module between client calls. However, it is reasonable to want the benefits of sharing remote data module instances while still managing persistent state information. For example, you may need to use incremental fetching to display a dataset that is too large to fit in memory at one time. Before and after any calls to the IAppServer interface that the client dataset sends to the application server (AS ApplyUpdates, AS Execute, AS GetParams, AS GetRecords, or AS RowRequest), it receives an event where it can send or retrieve custom state information. Similarly, before and after providers respond to these client-generated calls, they receive events where they can retrieve or send custom state information. Using this mechanism, you can communicate persistent state information between client applications and the application server, even if the application server is \n\n\n\nCreating multi-tiered applications 15-23 W r i thttp://www.doksihu ing MIDAS Web applications Forrás: stateless. For example, to enable incremental fetching in a stateless application server, you can do the following:\n• Use the client dataset’s BeforeGetRecords event to send the key value of the last record to the application server: TDataModule1::ClientDataSet1BeforeGetRecords(TObject *Sender; OleVariant &OwnerData) { TClientDataSet *pDS = (TClientDataSet )Sender; if (!pDS->Active) return; void *CurRecord = pDS->GetBookmark(); // save current record try { // locate the last record in the current packet. Note this only works if FetchOnDemand // is False. If FetchOnDemand is True, you can save the key value of the last record // fetch in an AfterGetRecords event handler and use that instead pDS->Last(); // locate the last record in the new packet OwnerData = pDS->FieldValues[\"Key\"]; // Send key value for the last record to app server \n\n\n\npDS->GotoBookmark(CurRecord); // return to current record } finally { pDS->FreeBookmark(CurRecord); } }\n• On the server, use the provider’s BeforeGetRecords event to locate the appropriate set of records: TRemoteDataModule1::Provider1BeforeGetRecords(TObject *Sender, OleVarient &OwnerData) { TLocateOptions opts; if (!VarIsEmpty(OwnerData)) { TDataSet *pDS = ((TDataSetProvider )Sender)->DataSet; if (pDS->Locate(\"Key\", OwnerData, opts)) pDS->Next; } Note The previous example uses a key value to mark the end of the record set rather than a bookmark. This is because bookmarks may not be valid between IAppServer calls if the server application pools database handles. Writing MIDAS Web applications If you want to create Web-based clients for your multi-tiered database application, you must replace the client tier with a special Web applications that acts simultaneously as a client to the application server and as a Web server application that is\n\n\n\ninstalled with a Web server on the same machine. This architecture is illustrated in Figure 15.1 15-24 Developer’s Guide Writing MIDAS Web applications Figure 15.1 Web-based multi-tiered database application W eb S erver M I D AS W eb Ap p licatio n Ap p licatio n S erver remo te d atab ase B ro wser There are two approaches that you can take to build the MIDAS Web application:\n• You can combine the MIDAS architecture with C++Builder’s ActiveX support to distribute a MIDAS client application as an ActiveX control. This allows any browser that supports ActiveX to run your client application as an in-process server.\n• You can use XML data packets to build an InternetExpress application. This allows browsers that supports javascript to interact with your client application through html pages. These two approaches are very different. Which one you choose depends on the following considerations:\n• Each approach relies on a different technology (ActiveX vs. javascript\n\n\n\nand XML) Consider what systems your end-users will use. The first approach requires a browser to support ActiveX (which limits clients to a Windows platform). The second approach requires a browser to support javascript and the DHTML capabilities introduced by Netscape 4 and Internet Explorer 4.\n• ActiveX controls must be downloaded to the browser to act as an in-process server. As a result, the clients using an ActiveX approach require much more memory than the clients of an html-based application.\n• The InternetExpress approach can be integrated with other HTML pages. An ActiveX client must run in a separate window.\n• The InternetExpress approach uses standard HTTP, thereby avoiding any firewall issues that confront an ActiveX application.\n• The ActiveX approach provides greater flexibility in how you program your application. You are not limited by the capabilities of the javascript libraries The client datasets used in the ActiveX approach surface more features (such as\n\n\n\nfilters, ranges, aggregation, optional parameters, delayed fetching of BLOBs or nested details, and so on) than the XML brokers used in the InternetExpress approach. Caution Your Web client application may look and act differently when viewed from different browsers. Test your application with the browsers you expect your end-users to use. Creating multi-tiered applications 15-25 W r i thttp://www.doksihu ing MIDAS Web applications Forrás: Distributing a client application as an ActiveX control The MIDAS architecture can be combined with C++Builder’s ActiveX features to distribute a MIDAS client application as an ActiveX control. When you distribute your client application as an ActiveX control, create the application server as you would for any other multi-tiered application. For details on creating the application server, see “Creating the application server” on page 15-11. When creating the client application, you must use an Active Form as the basis instead of an\n\n\n\nordinary form. See “Creating an Active Form for the client application,” below, for details. Once you have built and deployed your client application, it can be accessed from any ActiveX-enabled Web browser on another machine. For a Web browser to successfully launch your client application, the Web server must be running on the machine that has the client application. If the client application uses DCOM to communicate between the client application and the application server, the machine with the Web browser must be enabled to work with DCOM. If the machine with the Web browser is a Windows 95 machine, it must have installed DCOM95, which is available from Microsoft. Creating an Active Form for the client application 1 Because the client application will be deployed as an ActiveX control, you must have a Web server that runs on the same system as the client application. You can use a ready-made server such as Microsoft’s Personal Web server or you can write your own using the\n\n\n\nsocket components described in Chapter 31, “Working with sockets.” 2 Create the client application following the steps described in “Creating the client application” on page 15-16, except start by choosing File|New|Active Form, rather than beginning the client project as an ordinary C++Builder project. 3 If your client application uses a data module, add a call to explicitly create the data module in the active form initialization. 4 When your client application is finished, compile the project, and select Project | Web Deployment Options. In the Web Deployment Options dialog, you must do the following: 1 On the Project page, specify the Target directory, the URL for the target directory, and the HTML directory. Typically, the Target directory and the HTML directory will be the same as the projects directory for your Web Server. The target URL is typically the name of the server machine that is specified in the Windows Network|DNS settings. 2 On the Additional Files page,\n\n\n\ninclude midas.dll with your client application 5 Finally, select Project|WebDeploy to deploy the client application as an active form. Any Web browser that can run Active forms can run your client application by specifying the .HTM file that was created when you deployed the client application 15-26 Developer’s Guide Writing MIDAS Web applications This .HTM file has the same name as your client application project, and appears in the directory specified as the Target directory. Building Web applications using InternetExpress MIDAS clients can request that the application server provide data packets that are coded in XML instead of OleVariants. By combining XML-coded data packets, special javascript libraries of database functions, and C++Builder’s Web server application support, you can create thin client applications that can be accessed using a Web browser that supports javascript. These applications make up C++Builder’s InternetExpress support. Before building an\n\n\n\nInternetExpress application, you should understand C++Builder’s Web server application architecture. This is described in Chapter 30, “Creating Internet server applications.” On the InternetExpress page of the component palette, you can find a set of components that extend this Web server application architecture to act as a MIDAS client. Using these components, the Web application generates HTML pages that contain a mixture of HTML, XML, and javascript. The HTML governs the layout and appearance of the pages seen by end users in their browsers. The XML encodes the data packets and delta packets that represent database information. The javascript allows the HTML controls to interpret and manipulate the data in these XML data packets. If the InternetExpress application uses DCOM to connect to the application server, you must take additional steps to ensure that the application server grants access and launch permissions to its clients. See “Granting permission to access and\n\n\n\nlaunch the application server” on page 15-29 for details. Tip You can use the components on the InternetExpress page to build Web server applications with “live” data even if you do not have an application server. Simply add the provider and its dataset to the Web module. Building an InternetExpress application The following steps describe how to build a Web application that creates HTML pages for allowing users to interact with the data from an application server via a javascript-enabled Web browser. 1 Choose File|New to display the New Items dialog box, and on the New page select Web Server application. This process is described in “Creating Web server applications” on page 30-6. 2 From the MIDAS page of the component palette, add a connection component to the Web Module that appears when you create a new Web server application. The type of connection component you add depends on the communication protocol you want to use. See “Choosing a connection protocol” on page\n\n\n\n15-9 for details 3 Set properties on your connection component to specify the application server with which it should establish a connection. To learn more about setting up the connection component, see “Connecting to the application server” on page 15-17. Creating multi-tiered applications 15-27 W r i thttp://www.doksihu ing MIDAS Web applications Forrás: 4 Instead of a client dataset, add an XML broker from the InternetExpress page of the component palette to the Web module. Like TClientDataSet, TXMLBroker represents the data from a provider on the application server and interacts with the application server through its IAppServer interface. However, unlike client datasets, XML brokers request data packets as XML instead of as OleVariants and interact with InternetExpress components instead of data controls. 5 Set the RemoteServer property of the XML broker to point to the connection component you added in step 2. Set the ProviderName property to indicate the provider on\n\n\n\nthe application server that provides data and applies updates. For more information about setting up the XML broker, see “Using an XML broker” on page 15-30. 6 Add a MIDAS page producer to the Web module for each separate page that users will see in their browsers. For each MIDAS page producer, you must set the IncludePathURL property to indicate where it can find the javascript libraries that augment its generated HTML controls with data management capabilities. 7 Right-click a Web page and choose Action Editor to display the Action editor. Add action items for every message you want to handle from browsers. Associate the page producers you added in step 6 with these actions by setting their Producer property or writing code in an OnAction event handler. For more information on adding action items using the Action editor, see “Adding actions to the dispatcher” on page 30-9. 8 Double-click each Web page to display the Web Page editor. (You can also display this editor by\n\n\n\nclicking the ellipses button in the Object Inspector next to the WebPageItems property.) In this editor you can add Web Items to design the pages that users see in their browsers. For more information about designing Web pages for your InternetExpress application, see “Creating Web pages with a MIDAS page producer” on page 15-32. 9 Build your Web application. Once you install this application with your Web server, browsers can call it by specifying the name of the application as the scriptname portion of the URL and the name of the Web Page component as the pathinfo portion. Using the javascript libraries The HTML pages generated by the InternetExpress components and the Web items they contain make use of several javascript libraries that ship with C++Builder: Table 15.4 15-28 Javascript libraries Library Description xmldom.js This library is a DOM-compatible XML parser written in javascript. It allows parsers that do not support XML to use XML data packets. Note that this\n\n\n\ndoes not include support for XML Islands, which are supported by IE5 and later. xmldb.js This library defines data access classes that manage XML data packets and XML delta packets. xmldisp.js This library defines classes that associate the data access classes in xmldb with HTML controls in the HTML page. Developer’s Guide Writing MIDAS Web applications Table 15.4 Javascript libraries (continued) Library Description xmlerrdisp.js This library defines classes that can be used when reconciling update errors. These classes are not used by any of the built-in InternetExpress components, but are useful when writing a Reconcile producer. xmlshow.js This library includes functions to display formatted XML data packets and XML delta packets. This library is not used by any of the InternetExpress components, but is useful when debugging. These libraries can be found in the Source/Webmidas directory. Once you have installed these libraries, you must set the IncludePathURL\n\n\n\nproperty of all MIDAS page producers to indicate where they can be found. It is possible to write your own HTML pages using the javascript classes provided in these libraries instead of using Web items to generate your Web pages. However, you must ensure that your code does not do anything illegal, as these classes include minimal error checking (so as to minimize the size of the generated Web pages). The classes in the javascript libraries are an evolving standard, and are updated regularly. If you want to use them directly rather than relying on Web items to generate the javascript code, you can get the latest versions and documentation of how to use them from CodeCentral available through community.borlandcom Granting permission to access and launch the application server Requests from the InternetExpress application appear to the application server as originating from a guest account with the name IUSR computername, where computername is the name of the system running the Web\n\n\n\napplication. By default, this account does not have access or launch permission for the application server. If you try to use the Web application without granting these permissions, when the Web browser tries to load the requested page it times out with EOLE ACCESS ERROR. Note Because the application server runs under this guest account, it can’t be shut down by other accounts. To grant the Web application access and launch permissions, run DCOMCnfg.exe, which is located in the System32 directory of the machine that runs the application server. The following steps describe how to configure your application server: 1 When you run DCOMCnfg, select your application server in the list of applications on the Applications page. 2 Click the Properties button. When the dialog changes, select the Security page 3 Select Use Custom Access Permissions, and press the Edit button. Add the name IUSR computername to the list of accounts with access permission, where computername is the name of the\n\n\n\nmachine that runs the Web application. 4 Select Use Custom Launch Permissions, and press the Edit button. Add IUSR computername to this list as well. 5 Click the Apply button. Creating multi-tiered applications 15-29 W r i thttp://www.doksihu ing MIDAS Web applications Forrás: Using an XML broker The XML broker serves two major functions:\n• It fetches XML data packets from the application server and makes them available to the Web Items that generate HTML for the InternetExpress application.\n• It receives updates in the form of XML delta packets from browsers and applies them to the application server. Fetching XML data packets Before the XML broker can supply XML data packets to the components that generate HTML pages, it must fetch them from the application server. To do this, it uses the IAppServer interface of the application server, which it acquires through a connection component. You must set the following properties so that the XML producer can use the application\n\n\n\nserver’s IAppServer interface:\n• Set the RemoteServer property to the connection component that establishes the connection to the application server and"
    },
    {
        "link": "http://delphi-z.ru/sitemap.html",
        "document": "Все ссылки на файлы, расположенные на страницах сайта, добавлены пользователями и доступны для бесплатного скачивания. За содержание этих файлов администрация сайта ответственности не несет."
    },
    {
        "link": "https://en.delphipraxis.net/topic/11381-best-practices-for-database-development-in-delphi-with-firebird",
        "document": "Oy, that's a really open-ended subject. The RAD approach (using data-aware controls and connection/query components you create and configure at design-time) gets you results (= working application) fast but it tends to get messy fast as well, with business logic mixed into form and data moduls, poor reuse of code (unless you plan well ahead). This approach makes proper separation of application layers harder and is excellent at producing apps that are a nightmare to maintain and document. Code can be written to be self-documenting and serve as source for project documentation as well, but how do you deal with all the stuff set at designtime and scattered across dozens or even hundreds of dfm files?\n\nIn my opinion RAD is workable for smaller projects with a few database tables and a few forms as well. For anything more complex and expected to have a lifetime of many years with frequent updates it pays to use a proper layered approach (e.g. model-view-controller or similar), with a object-relational mapper (ORM) as interface to the database and a client UI that works with data objects instead of directly talking to database tables, queries, or stored procedures. All the FireDac stuff would be hidden inside the ORM.\n\nUnfortunately Delphi does not come with an ORM, but there are some 3rd-party offerings in that area, including open-source projects like MORMOT. The learning curve can be steep if you have never dealt with such a design before, but it is worth it IMO. I wrote my own ORM for a larger project at work 20 years ago, took about half a year (part time, programming was not my main task) since nothing suitable was available at that time. It has served me well and some of the programs are still in some use...\n\nAs for partitioning the app into modules that can be maintained independently: that is what packages are for, but it is not as straightforward as one would hope. It's DLL hell in disguise and you have to invest some serious though into how you partition your application. Packages are all or nothing, every unit used can only be contained in one single package. All other units requiring such a unit have to get it from the (shared) package, so you have to deploy not only your own packages but also all used RTL and VCL (or FMX) and 3rd-party packages.\n\nAs long as you do not change anything in the interface part of a packaged unit you can replace the build package in the production app with an updated package. If you change an interface you have to rebuild all packages using the modified one, plus the host app. Since forms etc. are declared in a unit interface that severely limits what you can change in such a form unit without major hassle.\n\nNote that this applies to units you want to use from other packages directly. It does not apply to units only used internally by a package. So it is possible to achieve a better isolation of modules if the only exposed part is a factory function for an interface the host app then uses to talk to the internal stuff of the package. In this scenario you can get away with only building with the core RTL and VCL packages and one shared package declaring the interface types used, and actually you can use DLLs (build with packages) instead of full-fledged packages. But this can still degenerate into a maintenance nightmare if you are nor careful..."
    },
    {
        "link": "https://stackoverflow.com/questions/2286222/database-connectivity-delphi",
        "document": "I'm using delphi for years, but never for database stuff, but recently started researching and testing.\n\nI must say, i'm impressed, most of things happens automatically, i'm used to write by hand in php and python.\n\ni'm going to develop a commercial system for a friend, (2 layers) 5 user computers, 1 database server.\n\nDatabase server will be a decent machine with (raid-1) 2 hard drives running (MySql5.1 or Postgre or Firebird, open to suggestions).\n• The more complex (harder to use)\n• ClientDataSet add complexity, but looks really useful\n\nAs you can see the desired features are:\n\nI can't test all in a real scenario (clients, server), so i hope that you guys with experience can help me out in which one to choose and why.\n\nEDIT: Thanks everyone, i think i will go with ADO (probably) or Zeos"
    },
    {
        "link": "https://stackoverflow.com/questions/14780256/delphi-2010-connect-to-mysql-and-firebird-database-without-lib-dlls",
        "document": "I am writing a portable application that connects to both a firebird database and a mysql database. I am writing the application in Delphi 2010, and using dbExpress components to connect to both databases. SQLconnection component uses dbxmys.dll and libmysql.dll for the mysql database, and dbxfb.dll and fbclient.dll for the firebird database.\n\nOn my development computer I had to move the dll files into /windows/system/. I think this is because of the system paths, in order to find the correct files and connect. I tried this on another client machine, and the software could not connect because the dll files were not found. Because this is a portable application I do not want to include a sub directory of the application directory to include the dll files, however I do not think the a client machine can run the applicaiton without having mySQL and Firebird installed and the pathing set correctly.\n\nIs there a better way to do this? I have concidered making a sub directory and forcing my application to look there, (since firebird and mySQL can be installed anywhere) if they were included I would know for sure were they were at on any computer my app is launched from. But I don't really want to take this approach.\n\nWhat are my options as far as direct db connection, or solving the dll requirement problem, I am not an experienced software developer. Thanks in advance.\n\nUpdate: The DLLs are now in the same directory with the exe, and the application launches fine. I Still do not want to use any dlls. I have found a few components that do not require dlls, but they also require payment, finding another free option would be ideal."
    },
    {
        "link": "https://zeoslib.sourceforge.io/viewtopic.php?t=83751",
        "document": "The forum for ZeosLib 7.2 Report problems. Ask for help, post proposals for the new version and Zeoslib 7.2 features here. This is a forum that will be edited once the 7.2.x version goes into RC/stable!!\n\n \n\n My personal intention for 7.2 is to speed up the internals as optimal a possible for all IDE's. Hope you can help?! Have fun with testing 7.2\n\n\n\n\n\n \n\n I was lurking around the forums for long, but now the time arrived for an actual registration Therefore - first of all - let me Embrace Zeos a little bit!\n\n \n\n I started to develop applications with database backends about 6 years ago. I quickly met the standard issues with available components (not cross-platform; not supporting all mainstream databases; buggy or simply CRAZY expensive) and then I found Zeos. Since then this became the first component I install after a dev machine meltdown (I experiment with Windows APIs a lot ). It's really good to know that there is an actively maintained suite to build our applications upon. For free. So thank you for all the extremely good work and keep it up!\n\n \n\n A recent job change forced me to upgrade from Delphi 7 to 10.2 so I started to patch / rewrite some of my past applications. There is one which is using a small (~7-10 tables) database backend, with about 5 worker threads. All threads should be able to read (and occasionally write) all tables. In the past I solved this by using ZQuery and writing separate DLLs for each database type but this is a lot pain to maintain. Furthermore I quickly realized that by using ZTables even the data-processing performance will improve where it's the most critical so if I rebuild this from scratch - why not to implement a better way.\n\n \n\n I read a lot about multithreading applications with databases, but I am really curious if there are actually best practices to follow?\n\n My main problem here is that the golden rule (each thread must have it's own database connection) introduces a new issue - if a thread is updating a table, no other threads will know that (on database level) the data was changed. This can be solved by sending a signal to refresh, but (according to my prior testing) this operation can be slow. An other idea is to \"lock\" the table which will be modified (in the application level; with a critical section or so) and update them all from code but this feels a bit hacky if you know what I mean.\n\n \n\n So please, do not restrain yourselves. Hit me with the best practices or ideas of a multithreaded database application! Hello all,I was lurking around the forums for long, but now the time arrived for an actual registrationTherefore - first of all - let me Embrace Zeos a little bit!I started to develop applications with database backends about 6 years ago. I quickly met the standard issues with available components (not cross-platform; not supporting all mainstream databases; buggy or simply CRAZY expensive) and then I found Zeos. Since then this became the first component I install after a dev machine meltdown (I experiment with Windows APIs a lot). It's really good to know that there is an actively maintained suite to build our applications upon. For free. So thank you for all the extremely good work and keep it up!A recent job change forced me to upgrade from Delphi 7 to 10.2 so I started to patch / rewrite some of my past applications. There is one which is using a small (~7-10 tables) database backend, with about 5 worker threads. All threads should be able to read (and occasionally write) all tables. In the past I solved this by using ZQuery and writing separate DLLs for each database type but this is a lot pain to maintain. Furthermore I quickly realized that by using ZTables even the data-processing performance will improve where it's the most critical so if I rebuild this from scratch - why not to implement a better way.I read a lot about multithreading applications with databases, but I am really curious if there are actually best practices to follow?My main problem here is that the golden rule (each thread must have it's own database connection) introduces a new issue - if a thread is updating a table, no other threads will know that (on database level) the data was changed. This can be solved by sending a signal to refresh, but (according to my prior testing) this operation can be slow. An other idea is to \"lock\" the table which will be modified (in the application level; with a critical section or so) and update them all from code but this feels a bit hacky if you know what I mean.So please, do not restrain yourselves. Hit me with the best practices or ideas of a multithreaded database application!\n\n\n\n Just keep in mind that even simultaneous access to two different tables is not safe if they belong to the same connection You mean same connection inside or between threads? I mean, let's say I have\n\n - Thread T1 with one ZConnection and two ZTables (to tables A and B)\n\n - Thread T2 with one ZConnection and four ZTables (to tables C, D, E and F)\n\n - Thread T3 with one ZConnection and one ZTable (to table G)\n\n All ZConnections are pointing to the database on the same host, all ZTables are using the ZConnection inside their own thread. This should be safe, even if all threads are reading / writing to all of their own tables; right?\n\n \n\n Another thing is if I create a thread for database connections ONLY. It would publish ZTables via let's say \"Function RequestTableA: TZTable;\", secured with critical sections. I'll also need to create \"Procedure ReleaseTableA;\" which releases the lock and resets any filters etc. This would be the easiest, but this model introduces some scary deadlock opportunities; plus we already step over the boundaries of threads... I got a similar idea yesterday and started working on mapping specific tables explicitly to specific threads. We'll see if I can change the business logic to allow this at the end.You mean same connection inside or between threads? I mean, let's say I have- Thread T1 with one ZConnection and two ZTables (to tables A and B)- Thread T2 with one ZConnection and four ZTables (to tables C, D, E and F)- Thread T3 with one ZConnection and one ZTable (to table G)All ZConnections are pointing to the database on the same host, all ZTables are using the ZConnection inside their own thread. This should be safe, even if all threads are reading / writing to all of their own tables; right?Another thing is if I create a thread for database connections ONLY. It would publish ZTables via let's say \"Function RequestTableA: TZTable;\", secured with critical sections. I'll also need to create \"Procedure ReleaseTableA;\" which releases the lock and resets any filters etc. This would be the easiest, but this model introduces some scary deadlock opportunities; plus we already step over the boundaries of threads...\n\nYou mean same connection inside or between threads? I mean, let's say I have\n\n - Thread T1 with one ZConnection and two ZTables (to tables A and B)\n\n - Thread T2 with one ZConnection and four ZTables (to tables C, D, E and F)\n\n - Thread T3 with one ZConnection and one ZTable (to table G)\n\n All ZConnections are pointing to the database on the same host, all ZTables are using the ZConnection inside their own thread. This should be safe, even if all threads are reading / writing to all of their own tables; right? Yes, as long as a thread uses its personal connection and dataset objects, Zeos is thread-safe just like a client lib is. I was talking about the case when\n\n - ZConnection\n\n - Thread T1 with ZTable A linked to ZConnection\n\n - Thread T2 with ZTable B linked to ZConnection\n\n This is potentially not safe mainly because in Zeos a transaction is not a separate object but is included into a connection. In theory, if you just read from two tables and do not change transaction state, it should be safe but I guess no special efforts were made to ensure this. Yes, as long as a thread uses its personal connection and dataset objects, Zeos is thread-safe just like a client lib is. I was talking about the case when- ZConnection- Thread T1 with ZTable A linked to ZConnection- Thread T2 with ZTable B linked to ZConnectionThis is potentially not safe mainly because in Zeos a transaction is not a separate object but is included into a connection. In theory, if you just read from two tables and do not change transaction state, it should be safe but I guess no special efforts were made to ensure this.\n\nHi!\n\n \n\n I tried to use 1 TZConnection for different TZReadOnlyQuery in different threads.\n\n As a result, I got Access Violation in case the threads are accessing at the same time.\n\n So I can not call a thread-protected ZConnection.\n\n But that was before the advent of ZEOS 7.2.4. Exactly the version on which I tried not remember.\n\n Personally, I stopped at Formula 1 thread = 1 connection.\n\n \n\n And yet, I do not use DataSet as a data warehouse, I overtake all data into my structures (array, Tlist),\n\n and process already in them.\n\n My application is built like this:\n\n 1. Data Acquisition Application\n\n 1.1. threads for data downloads from the Internet (JSON)\n\n 1.2. threads load this data into the database (parsing JSON and saving in relational form)\n\n \n\n 2. processing application\n\n 2.1. processing threads within the database\n\n 2.2. data load threads from the database to the application memory - a heap (4-6 GB)\n\n 2.3. threads for processing data in heap \n\n 2.4. threads of uploading processed data to DB\n\n 2.5. threads for clean data heap of unnecessary data\n\n \n\n All this works on the system of typical tasks.\n\n Each thread takes the most priority task from the queue, does its job, generates tasks for other types of threads.\n\n\n\n \n\n for me it seems that the problem is that you need to make sure, that updated in the database doesn't overlap. If you can get to that point, you can easily have one connection per thread: 1. Data Acquisition Application\n\n 1.1. threads for data downloads from the Internet (JSON)\n\n 1.2. threads load this data into the database (parsing JSON and saving in relational form) As long, as the threads that parse the data don't do overlapping inserts / updates, I don't see a reason to not have one connection per thread here? Maybe you need to make sure you work with tiReadCommited to see the work of other threads as soon as they commit their work to the database? Also keeping transactions short lived might help here?\n\n 2. processing application\n\n 2.1. processing threads within the database\n\n 2.2. data load threads from the database to the application memory - a heap (4-6 GB)\n\n 2.3. threads for processing data in heap \n\n 2.4. threads of uploading processed data to DB\n\n 2.5. threads for clean data heap of unnecessary data The same goes here: As long as threads that update the database don't do overlapping updates, there should be no problems in using a separate connection per thread? Or is there something here that I don't get?\n\n \n\n Best regards,\n\n \n\n Jan Hello stinkard,for me it seems that the problem is that you need to make sure, that updated in the database doesn't overlap. If you can get to that point, you can easily have one connection per thread:As long, as the threads that parse the data don't do overlapping inserts / updates, I don't see a reason to not have one connection per thread here? Maybe you need to make sure you work with tiReadCommited to see the work of other threads as soon as they commit their work to the database? Also keeping transactions short lived might help here?The same goes here: As long as threads that update the database don't do overlapping updates, there should be no problems in using a separate connection per thread? Or is there something here that I don't get?Best regards,Jan\n\nfor me it seems that the problem is that you need to make sure, that updated in the database doesn't overlap. If you can get to that point, you can easily have one connection per thread: Yes, I have no overlaps, and I use 1 connection in each DB thread. As long, as the threads that parse the data don't do overlapping inserts / updates, I don't see a reason to not have one connection per thread here? Maybe you need to make sure you work with tiReadCommited to see the work of other threads as soon as they commit their work to the database? Also keeping transactions short lived might help here? I use default settings of isolation level. No any problem.\n\n I had some problems with dead locks in DB. But using explicit table locks in the correct order at the beginning of a transaction block solved this problem. The same goes here: As long as threads that update the database don't do overlapping updates, there should be no problems in using a separate connection per thread? Or is there something here that I don't get? No proplems here. All is ok. Yes, I have no overlaps, and I use 1 connection in each DB thread.I use default settings of isolation level. No any problem.I had some problems with dead locks in DB. But using explicit table locks in the correct order at the beginning of a transaction block solved this problem.No proplems here. All is ok."
    },
    {
        "link": "https://blogs.embarcadero.com/6-easy-ways-to-connect-to-the-top-databases-you-should-know",
        "document": "The processing of data is the soul of computing. Almost every single computer ever invented was designed so that human beings could take information in the form of data and manipulate it in one way or another, either through visualizations or use it in other ways to make decisions about our lives, work, and future. If data processing is the soul, then the pieces of data itself are the bones we use to build the body of computing. In this article, we’ll show you how to access, manipulate, and master those building blocks, including how to use Python Windows GUI builder to add features and functionalities to Python; how to use Python libraries to perform cryptographic tasks; how to connect SQLite Database in Python4Delphi, and much more.\n\nWhat do people mean when they call something a database?\n\nAccording to Oracle, who specializes in the field, a Database is an organized collection of structured information, or data, typically stored electronically in a computer system. A database is usually controlled by a database management system (DBMS) which makes it easier to create, and generally control the database’s data and the programs which make the database work. Together, the data and the DBMS, along with the applications that are associated with them, are referred to as a database system, often shortened to just database.\n\nThe evolution of the database\n• The 1960s: Navigational databases such as the hierarchical database (which relied on a tree-like model and allowed only a one-to-many relationship), and the network database (a more flexible model that allowed multiple relationships), were the original systems used to store and manipulate data. Although simple, these early systems were inflexible.\n• The 2000s – Now: NoSQL databases came about as a response to the growth of the internet and the need for faster speed and processing of unstructured data. Today, cloud databases and self-driving databases are breaking new ground when it comes to how data is collected, stored, managed, and utilized.\n\nWhat types of databases are there?\n\nTo make a better decision about the types of databases you need, first, you need to learn more about the different kinds of databases.\n\nBelow are some common types of databases you may encounter either during your personal life or in your business, as collected by Indeed Editorial Team:\n\nWhy use Python for working with databases?\n• Python is perfectly fine for most applications for creating database clients.\n• Python provides a vast set of libraries to work with an extensive variety of databases.\n\nRead more here, to see “How Python is Ideal for Handling Data Intensive Tasks”:\n\nIn this tutorial, we’ll build Windows Apps with extensive Database capabilities by integrating Python’s Database libraries with Embarcadero’s Delphi, using Python4Delphi (P4D).\n\nP4D empowers Python users with Delphi’s award-winning VCL functionalities for Windows which enables us to build native Windows apps 5x faster. This integration enables us to create a modern GUI with Windows 10 looks and responsive controls for our Python Database applications. Python4Delphi also comes with an extensive range of demos, use cases, and tutorials.\n\nWe’re going to cover the following…\n\nHow to use SQLite, SQLAlchemy, pymongo, mongoengine, redis-py, and FireDac Python libraries to interact with databases\n\nAll of them would be integrated with Python4Delphi to create Windows Apps with Database capabilities.\n\nBefore we begin to work, download and install the latest Python for your platform. Follow the Python4Delphi installation instructions mentioned here. Alternatively, you can check out the easy instructions found in the Getting Started With Python4Delphi video by Jim McKeeth.\n\nFirst, open and run our Python GUI using project Demo1 from Python4Delphi with RAD Studio. Then insert the script into the lower Memo, click the Execute button, and get the result in the upper Memo. You can find the Demo1 source on GitHub. The behind the scene details of how Delphi manages to run your Python code in this amazing Python GUI can be found at this link.\n\nHow do I connect to a SQLite Database in Python4Delphi?\n\nDo you want to add the full power, functionalities, and flexibilities of SQL to your Python GUI or Windows App, without installing external libraries? You can build it easily by combining SQLite-a built-in DB-API 2.0 interface for SQLite databases in Python and Python4Delphi library, inside Delphi and C++Builder.\n\nSQLite is a C library that provides a lightweight disk-based database that doesn’t require a separate server process and allows accessing the database using a nonstandard variant of the SQL query language.\n\nSome applications can use SQLite for internal data storage. It’s also possible to prototype an application using SQLite and then port the code to a larger database such as PostgreSQL or Oracle.\n\nHere is a code example of using SQLite to create a simple database, insert data, and run a simple query\n\nThe following is a code example of SQLite to create a simple database, insert data, and run a simple query. You should run this inside the lower Memo of Python4Delphi Demo01 GUI:\n\nimport sqlite3 con = sqlite3.connect('example.db') cur = con.cursor() # Create table cur.execute('''CREATE TABLE stocks (date text, trans text, symbol text, qty real, price real)''') # Insert a row of data cur.execute(\"INSERT INTO stocks VALUES ('2006-01-05','BUY','RHAT',100,35.14)\") # Save (commit) the changes con.commit() # We can also close the connection if we are done with it. # Just be sure any changes have been committed or they will be lost. con.close() # The data you’ve saved is persistent and is available in subsequent sessions: con = sqlite3.connect('example.db') cur = con.cursor() # Do this instead t = ('RHAT',) cur.execute('SELECT * FROM stocks WHERE symbol=?', t) print(cur.fetchone()) # Larger example that inserts many records at a time purchases = [('2021-03-28', 'BUY', 'IBM', 1000, 45.00), ('2021-04-05', 'BUY', 'MSFT', 1000, 72.00), ('2021-04-06', 'SELL', 'IBM', 500, 53.00), ] cur.executemany('INSERT INTO stocks VALUES (?,?,?,?,?)', purchases) # Retrieve the data using iterator: for row in cur.execute('SELECT * FROM stocks ORDER BY price'): print(row) # We can also close the connection if we are done with it. # Just be sure any changes have been committed or they will be lost. # The data you’ve saved is persistent and is available in subsequent sessions: # Larger example that inserts many records at a time\n\nHere is the result of accessing the SQLite database in Python GUI\n\nCongratulations, you have successfully created a simple database, insert data, and run a simple query using SQLite in Python GUI for Delphi Windows App!\n\nHow do I connect to a MySQL Database in Python using SQLAlchemy?\n\nSQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. SQLAlchemy provides a full suite of well-known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language.\n\nThe following are Major SQLAlchemy features:\n• An industrial strength ORM, built from the core on the identity map, unit of work, and data mapper patterns. These patterns allow the transparent persistence of objects using a declarative configuration system. Domain models can be constructed and manipulated naturally, and changes are synchronized with the current transaction automatically.\n• A relationally-oriented query system, exposing the full range of SQL’s capabilities explicitly, including joins, subqueries, correlation, and most everything else, in terms of the object model. Writing queries with the ORM uses the same techniques of relational composition you use when writing SQL. While you can drop into literal SQL at any time, it’s virtually never needed.\n• A comprehensive and flexible system of eager loading for related collections and objects. Collections are cached within a session and can be loaded on individual access, all at once using joins, or by query per collection across the full result set.\n• A Core SQL construction system and a DBAPI interaction layer. The SQLAlchemy Core is separate from the ORM and is a full database abstraction layer in its own right, and includes an extensible Python-based SQL expression language, schema metadata, connection pooling, type coercion, and custom types.\n• All primary and foreign key constraints are assumed to be composite and natural. Surrogate integer primary keys are of course still the norm, but SQLAlchemy never assumes or hardcodes to this model.\n• Database introspection and generation. Database schemas can be “reflected” in one step into Python structures representing database metadata; those same structures can then generate CREATE statements right back out – all within the Core, independent of the ORM.\n\nThis section will guide you on how to run various SQL and Object Relational Mapper operations using Python’s SQLAlchemy library and then display it in the Delphi Windows GUI app using Python for Delphi.\n\nAfter installing Python4Delphi properly, you can get SQLAlchemy using pip or easy install to your command prompt:\n\nDon’t forget to put the path where your SQLAlchemy library installed, to the System Environment Variables:\n\nLet’s perform some introductory examples of the SQLAlchemy library:\n\nHere are the SQLAlchemy introductory examples in the Python GUI\n\nHow to connect to MongoDB using PyMongo + Python4Delphi\n\nThe PyMongo distribution contains tools for interacting with the MongoDB database from Python. The requirement of this library is, you need to install MongoDB on your computer first. You can easily install MongoDB in your Windows OS, by following these guides:\n\nThe PyMongo package is a native Python driver for MongoDB. PyMongo supports MongoDB 2.6, 3.0, 3.2, 3.4, 3.6, 4.0, 4.2, and 4.4.\n\nThe bson package is an implementation of the BSON format for Python. The gridfs package is a gridfs implementation on top of PyMongo.\n\nFirst, here is how you can get PyMongo:\n\nBelow is the code for Creating New Database, Connect to It, Insert New Data, and Find Them using PyMongo (Run the following code inside the lower Memo of Python4Delphi Demo01 GUI):\n\nHow to use MongoEngine?\n\nMongoEngine is a Python Object-Document Mapper for working with MongoDB. MongoEngine is based on the PyMongo driver and tested against multiple versions of MongoDB.\n\nMongoEngine is currently tested against MongoDB v3.4, v3.6, and v4.0. Future versions should be supported as well, but aren’t actively tested at the moment.\n\nFirst, here is how you can get MongoEngine:\n\nHere are some MongoEngine Python examples\n\nRun these simple examples of MongoEngine code inside the lower Memo of Python4Delphi Demo01 GUI:\n\nHow do I use Redis in Python?\n\nredis-py is the Python interface to the Redis key-value store. Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams.\n\nredis-py requires a running Redis server. You can easily install Redis in your Windows OS, by following these guides:\n• How To Install Redis on Windows 10, or\n• How To Install Redis on Windows 10 in 2020\n• You can get the installer here: microsoftarchive/redis\n\nHere is how you can install redis :\n\nRun the following code to Getting Started with redis-py:\n\nHere is the redis-py Demo Result in the Python GUI:\n\nBonus: How to use FireDAC in Python4Delphi\n\nFireDAC is a unique and very comprehensive set of Universal Data Access Components for developing multi-device database applications for Delphi and C++Builder. With its powerful common architecture, FireDAC enables native high-speed direct access from Delphi to Interbase, SQLite, MySQL, SQL Server, Oracle, PostgreSQL, IBM DB2, SQL Anywhere, Access, Firebird, Informix, and more.\n\nFireDAC is a powerful, yet easy-to-use access layer that supports, abstracts, and simplifies data access, providing all the features needed to build real-world high-load applications. FireDAC provides a common API for accessing different database back-ends, without giving up access to unique database-specific features and without compromising on performance. Use FireDAC in Windows, Android, iOS, and Mac OS X applications you are developing for PCs, tablets, and smartphones.\n\nYou can easily connect Python with FireDAC through Python4Delphi Demo.\n\nThe best advantage of P4D is, it makes it very easy to use Python as a scripting language for Delphi applications that comes with a very extensive range of customizable demos and tutorials that are ready to use to develop real-world apps, as we’ve mentioned earlier. In shorts: P4D gives you various real-world “Hello World!” apps that are ready to adjust to your needs!\n\nAn example of Demo10-Python4Delphi VCL with FireDAC Database\n\nWe have shown you 6 powerful Python libraries for interacting with popular databases ranging from SQL, NoSQL, MongoDB and Redis as well as how to use FireDAC with Python. All of those really great tools for accessing pretty much any database were wrapped well inside a powerful GUI provided by Python4Delphi. We can’t wait to see what you build with Python4Delphi!\n\nWant to know some more? Then check out Python4Delphi which easily allows you to build Python GUIs for Windows using Delphi."
    }
]