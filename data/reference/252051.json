[
    {
        "link": "https://medium.com/@ryan_forrester_/c-mutable-comprehensive-guide-6dfdce590152",
        "document": "The `mutable` keyword in C++ is often misunderstood or overlooked, yet it plays a crucial role in certain scenarios.\n\nThis article dives deep into the `mutable` keyword, exploring its uses, benefits, and potential pitfalls.\n\nWhat is `mutable` in C++?\n\nIn C++, `mutable` is a keyword that allows a member variable of a const object to be modified. It’s used to specify that a particular data member of a const object can be modified without affecting the object’s const-ness.\n\nIn this case, `setValue` won’t compile because it’s trying to modify `value` in a const function. However, if we declare `value` as `mutable`:\n\nNow `setValue` will compile and work as expected, even though it’s a const function.\n\nWhen to Use `mutable`\n\nThe `mutable` keyword is particularly useful in several scenarios:\n\nLet’s explore each of these use cases with practical examples.\n\nCaching is a common use case for `mutable`. Imagine a class that performs an expensive computation:\n\nIn this example, `cachedSum_` is declared `mutable`. This allows `getSum()` to modify `cachedSum_` even though it’s a const function. The first time `getSum()` is called, it computes the sum and caches it. Subsequent calls return the cached value, improving performance without compromising the const-correctness of the object.\n\n`mutable` can be used to implement lazy evaluation, where a value is only computed when it’s needed:\n\nHere, `upperCase_` is `mutable` and is only computed when `getUpperCase()` is called. This saves memory and computation time if the uppercase version is never needed.\n\nWhen dealing with multithreaded code, `mutable` can be used with synchronization primitives:\n\nIn this example, `mutex_` is declared `mutable`. This allows it to be locked and unlocked in const member functions, ensuring thread safety without compromising const-correctness.\n\nSometimes, an object might need to change its internal state without affecting its logical state. This is where `mutable` comes in handy:\n\nHere, `accessCount_` is `mutable`. It allows us to track how many times the data has been accessed without affecting the logical state of the object. This information might be useful for debugging or optimization purposes."
    },
    {
        "link": "https://geeksforgeeks.org/c-mutable-keyword",
        "document": "The mutable storage class specifier in C++ (or use of mutable keyword in C++) \n\nauto, register, static and extern are the storage class specifiers in C. typedef is also considered as a storage class specifier in C. C++ also supports all these storage class specifiers. In addition to this C++, adds one important storage class specifier whose name is mutable.\n\nWhat is the need of mutable? \n\nSometimes there is requirement to modify one or more data members of class / struct through const function even though you don’t want the function to update other members of class / struct. This task can be easily performed by using mutable keyword. Consider this example where use of mutable can be useful. Suppose you go to hotel and you give the order to waiter to bring some food dish. After giving order, you suddenly decide to change the order of food. Assume that hotel provides facility to change the ordered food and again take the order of new food within 10 minutes after giving the 1st order. After 10 minutes order can’t be cancelled and old order can’t be replaced by new order. See the following code for details.\n\nClosely observe the output of above program. The values of placedorder and bill data members are changed from const function because they are declared as mutable.\n\nThe keyword mutable is mainly used to allow a particular data member of const object to be modified. When we declare a function as const, the this pointer passed to function becomes const. Adding mutable to a variable allows a const pointer to change members. \n\nmutable is particularly useful if most of the members should be constant but a few need to be updatable. Data members declared as mutable can be modified even though they are the part of object declared as const. You cannot use the mutable specifier with names declared as static or const, or reference.\n\nAs an exercise predict the output of following two programs."
    },
    {
        "link": "https://tpointtech.com/mutable-keywords-in-cpp",
        "document": "are very useful keywords in C++. It is used to change or modify the class data member even if the object is a Let's take an example if there is a class containing five non-static variables. All these were assigned a value with the help of a class constructor. In the main function, you created an object and decided not to change that particular object, so you used const for that object. However, after some time, you wanted to change only two particular variables. Now, you have a problem: if you want to change only two variables, you cannot remove the const before the object. Now, the mutable keyword is used in this situation. Suppose you make those two non-static variables mutable in class. In that case, you can make changes for only that particular variable, and other variables remain in const and cannot be changed. A simple program to demonstrate the usage of #include<iostream> using namespace std; class MyClass { public: int variable1; mutable int variable2; MyClass(int x,int y){ variable1 = x; variable2 = y; } void setVariable2(int z) const{ variable2 =z; } void display() const { cout<< \"variable1 is \"<< variable1 << endl; cout << \"Variable2 is \"<< variable2 << endl; } }; int main(){ const MyClass my(10,20); cout<< \"Before changing the variable2 \"<< endl; my.display(); my.setVariable2(2000); cout<< \"After changing the variable2 \"<< endl; my.display(); } In this example, this simple program contains a and a class named again. In , there are two variables named and , those two belong to , and variable1 is not mutable as the variable2 is mutable. This class contains two methods or functions named , and other is the simple function . The method takes an argument and assigns that argument to the variable2. Another function display method is used to display both variable1 and variable2. Now, in the , an object is created, and the keyword is used to make it constant. Therefore, the variables in the object cannot be modified, but the second variable, can be modified or changed by using the method because the variable2 is mutable. Here, the keyword mutable is used for changing only a particular variable in the whole . Now, we will bind a daily life application for the above concept: #include <iostream> #include <string> #include <ctime> using namespace std; class BankAccount { string accountHolderName; int accountNumber; mutable double balance; mutable string lastTransactionDate; public: BankAccount(string name, int number, double initialBalance){ accountHolderName = name; accountNumber = number; balance = initialBalance; time_t now = time(0); lastTransactionDate = ctime(&now); } void deposit(double amount) const { balance += amount; time_t now = time(0); lastTransactionDate = ctime(&now); } void withdraw(double amount) const { if (balance >= amount) { balance -= amount; time_t now = time(0); lastTransactionDate = ctime(&now); } else { cout << \"Insufficient funds!\" << endl; } } void display() const { cout << \"Account Holder: \" << accountHolderName << endl; cout << \"Account Number: \" << accountNumber << endl; cout << \"Current Balance: \" << balance << endl; cout << \"Last Transaction Date: \" << lastTransactionDate; cout << \" \" << endl; } }; int main() { const BankAccount account(\"SriRam\", 12345, 1000.0); account.display(); account.deposit(500.0); account.display(); account.withdraw(200.0); account.display(); return 0; } The above program contains a and a . In the class, there is a constructor and other methods like , and . These all together make the class work as a bank functionality. This class is named as . It contains four variables: , which is of string datatype, , which is of int datatype, , which is of double datatype, and , which is of string datatype. Here, the two variables, and are mutable. The deposit method takes an argument, which is the amount to be added to the balance and updates the time of the last transaction. It makes the mutable variable to be changed. The also takes an argument, which is the amount to be subtracted from the balance, and again updates the time of the last transaction. If the sufficient amount is not present in the bank, it displays . After that, the display method is used to display all the four variables. In the , an object is created and named an account by taking four arguments: . The first display method is called. Now, some amount is deposited, and again, the display method is called. After that, the withdraw method is called again, and the display method is called. After every display method, we can see the changes in and , which are mutable and can be modified. Move all zeroes to end of array in C++"
    },
    {
        "link": "https://tutorialspoint.com/cplusplus-mutable-keyword",
        "document": "Mutable data members are those members whose values can be changed in runtime even if the object is of constant type. It is just the opposite of a constant.\n\nSometimes logic requires to use of only one or two data members as a variable and another one as a constant to handle the data. In that situation, mutability is a very helpful concept to manage classes.\n\nHere is the following example of a mutable keyword in C++.\n\nHere we will get the following output for it."
    },
    {
        "link": "https://stackoverflow.com/questions/749865/c-mutable-appropriate-in-this-case",
        "document": "As 'head geek' described, the answer to your question depends on how your data member is used.\n\nI distinguish two types of data members in a class.\n\nI use the common term 'attribute' to refer to data members that are the logical state or 'value' of the object. Typically attributes are rarely declared as mutable.\n\nI have coined the protologism 'contribute' it denote data members that are simply 'working memory/storage' and that are somewhat divorced from the state of the object. Contributes have no contextual relevance to the user of the object, they exist in the class only to contribute to the maintenance and efficient operation of the object. Contributes are usually declared in the class as mutable and are always private or protected.\n\nFor example let's say your object is a linked list, so you have a pointer to the first item in the list. I would consider this pointer a contribute because it does not represent the data in the list. Even if the list is sorted and the pointer is set to the new first item in the list, the user of the list object could care less how the list is maintained. Only that the list data has been modified or not and that the the list is sorted or not is relevant to the user's perspective. Even if you had a booean data member 'sorted' to quickly determine if the list is in a sorted state, that too would be a contribute because it is the list structure itself which imbues the sorted state, the 'sorted' variable member is used simply to efficiently remember the state without having to scan the list.\n\nAs another example, if you have a const method that searches the list. Suppose you know that typically the search will return the most recently previously searched for item, you would keep a pointer in your class to such a item so your method can first check if the last found item matches the search key before searching the entire list (if the method does indeed need to search the list and finds an item, the pointer would be updated). This pointer I would consider to be a contribute because it is only there to help speed up the search. Even though the search updates the pointer contribute, the method is effectively const because none of the items' data in the container are modified.\n\nSo, data members that are attributes are usually not declared mutable, and data members that contribute to the functioning of an object will usually be mutable."
    },
    {
        "link": "https://stackoverflow.com/questions/105014/does-the-mutable-keyword-have-any-purpose-other-than-allowing-a-data-member-to",
        "document": "Is this the only use of this keyword, or is there more to it than meets the eye? I have since used this technique in a class, marking a boost::mutex as mutable , allowing const functions to lock it for thread-safety reasons, but, to be honest, it feels like a bit of a hack.\n\nA while ago, I came across some code that marked a data member of a class with the mutable keyword. As far as I can see it simply allows you to modify a member in a const -qualified member method:\n\nIt allows the differentiation of bitwise const and logical const. Logical const is when an object doesn't change in a way that is visible through the public interface, like your locking example. Another example would be a class that computes a value the first time it is requested, and caches the result. Since c++11 can be used on a lambda to denote that things captured by value are modifiable (they aren't by default): int x = 0; auto f1 = [=]() mutable {x = 42;}; // OK auto f2 = [=]() {x = 42;}; // Error: a by-value capture cannot be modified in a non-mutable lambda\n\nThe keyword is a way to pierce the veil you drape over your objects. If you have a const reference or pointer to an object, you cannot modify that object in any way except when and how it is marked . With your reference or pointer you are constrained to:\n• only read access for any visible data members\n• permission to call only methods that are marked as . The exception makes it so you can now write or set data members that are marked . That's the only externally visible difference. Internally those methods that are visible to you can also write to data members that are marked . Essentially the const veil is pierced comprehensively. It is completely up to the API designer to ensure that doesn't destroy the concept and is only used in useful special cases. The keyword helps because it clearly marks data members that are subject to these special cases. In practice you can use obsessively throughout your codebase (you essentially want to \"infect\" your codebase with the \"disease\"). In this world pointers and references are with very few exceptions, yielding code that is easier to reason about and understand. For a interesting digression look up \"referential transparency\". Without the keyword you will eventually be forced to use to handle the various useful special cases it allows (caching, ref counting, debug data, etc.). Unfortunately is significantly more destructive than because it forces the API client to destroy the protection of the objects (s)he is using. Additionally it causes widespread destruction: ing a const pointer or reference allows unfettered write and method calling access to visible members. In contrast requires the API designer to exercise fine grained control over the exceptions, and usually these exceptions are hidden in methods operating on private data.\n\nMutable is used when you have a variable inside the class that is only used within that class to signal things like for example a mutex or a lock. This variable does not change the behaviour of the class, but is necessary in order to implement thread safety of the class itself. Thus if without \"mutable\", you would not be able to have \"const\" functions because this variable will need to be changed in all functions that are available to the outside world. Therefore, mutable was introduced in order to make a member variable writable even by a const function. The mutable specified informs both the compiler and the reader that it is safe and expected that a member variable may be modified within a const member function.\n\ndoes exist as you infer to allow one to modify data in an otherwise constant function. The intent is that you might have a function that \"does nothing\" to the internal state of the object, and so you mark the function , but you might really need to modify some of the objects state in ways that don't affect its correct functionality. The keyword may act as a hint to the compiler -- a theoretical compiler could place a constant object (such as a global) in memory that was marked read-only. The presence of hints that this should not be done. Here are some valid reasons to declare and use mutable data:\n• Statistics. Counting the number of calls to a function, given some or all of its arguments.\n• Memoization. Computing some expensive answer, and then storing it for future reference rather than recomputing it again.\n\nWell, yeah, that's what it does. I use it for members that are modified by methods that do not logically change the state of a class - for instance, to speed up lookups by implementing a cache: class CIniWrapper { public: CIniWrapper(LPCTSTR szIniFile); // non-const: logically modifies the state of the object void SetValue(LPCTSTR szName, LPCTSTR szValue); // const: does not logically change the object LPCTSTR GetValue(LPCTSTR szName, LPCTSTR szDefaultValue) const; // ... private: // cache, avoids going to disk when a named value is retrieved multiple times // does not logically change the public interface, so declared mutable // so that it can be used by the const GetValue() method mutable std::map<string, string> m_mapNameToValue; }; Now, you must use this with care - concurrency issues are a big concern, as a caller might assume that they are thread safe if only using methods. And of course, modifying data shouldn't change the behavior of the object in any significant fashion, something that could be violated by the example i gave if, for instance, it was expected that changes written to disk would be immediately visible to the app.\n\nUse \"mutable\" when for things that are LOGICALLY stateless to the user (and thus should have \"const\" getters in the public class' APIs) but are NOT stateless in the underlying IMPLEMENTATION (the code in your .cpp). The cases I use it most frequently are lazy initialization of state-less \"plain old data\" members. Namely, it is ideal in the narrow cases when such members are expensive to either build (processor) or carry around (memory) and many users of the object will never ask for them. In that situation you want lazy construction on the back end for performance, since 90% of the objects built will never need to build them at all, yet you still need to present the correct stateless API for public consumption.\n\nOne of the best example where we use mutable is, in deep copy. in copy constructor we send as argument. So the new object created will be of constant type. If we want to change (mostly we won't change, in rare case we may change) the members in this newly created const object we need to declare it as . storage class can be used only on non static non const data member of a class. Mutable data member of a class can be modified even if it's part of an object which is declared as const. class Test { public: Test(): x(1), y(1) {}; mutable int x; int y; }; int main() { const Test object; object.x = 123; //object.y = 123; /* * The above line if uncommented, will create compilation error. */ cout<< \"X:\"<< object.x << \", Y:\" << object.y; return 0; } Output:- X:123, Y:1 In the above example, we are able to change the value of member variable though it's part of an object which is declared as const. This is because the variable is declared as mutable. But if you try to modify the value of member variable , compiler will throw an error."
    },
    {
        "link": "https://stackoverflow.com/questions/40658109/const-member-function-mutable",
        "document": "As i am given to understand, the const specifier at the end of a member function means that the class's members cannot be modified, within that function, unless they are declared as mutable. Having said that i have the following:\n\nmns::list::list is a linked list implementation of mine which functions are not const.\n\nand i have a function in my main:\n\nGiven that HashTable::insert is a const function i assumed that i wouldn't be able to modify private member hashtable. But testhash() prints:\n\nwhich means the member was modified... right? So i seem to miss something here... Why was the private member vector hashtable modified?"
    },
    {
        "link": "https://medium.com/@dilshankmg/when-const-isnt-const-a-deep-dive-into-c-mutable-f940234d1947",
        "document": "In C++, mutable is used to modify class member variables from const member functions. By default, member variables of a class cannot be modified from a const member function.\n\nIt is typically used for class member variables that cache calculated values. You want to declare the class object const so the state cannot change, but need to modify cached values.\n\nA const object that caches calculated values that are expensive to compute. The cached values can be declared mutable so they can be updated even though the object is const.\n\nWe use mutable when we want some variables to be modifiable even when accessed through a const reference/pointer to an object. This is useful for things like caching, logging, etc.\n\nconst methods cannot modify normal (non-mutable) members. But const methods can modify mutable members.\n\nThe mutable keyword essentially overrides the constess of a specific member variable. Other member variables will still be const as expected.\n• It can unintentionally break the immutability of const object.\n• Usage should be restricted where performance gains are substantial and it makes logical sense. Appropriate comments explaining mutable usage are helpful.\n• Only member variables can be declared as mutable, not local variables or parameters.\n• The mutable keyword does not work on const objects declared immutable at compile time using constexpr.\n• Mutable allows modification of the variable, but not changing its address. So pointers or references declared as mutable cannot be made to point to different objects.\n\nIf “MyClass” is const, you cannot call setDataPointer() to change where ptrData points to, since that would mutate the class.\n\nBut if you declare ptrData as mutable, you can change what ptrData points to, but not ptrData itself.\n• Using mutable breaks the logical const correctness of the class from an external perspective. The class can be mutated even if const, which can be confusing.\n• Any thread safety guarantees on a const class are broken if it uses mutable since the state can now change.\n• Overuse of mutable can degrade encapsulation and modularity as implementation details “leak” out.\n• The purpose and need for mutability should be well documented to avoid confusion.\n• Mutable usage defeats the compiler’s ability to optimize based on assumptions about unchanged state.\n\nWhen compiler sees a variable or object declared const, it is able to make certain performance optimizations based on the assumption that the state will not change.\n\nHere, the compiler can optimize to cache the value of obj.x if it knows it won’t change. It may even optimize away multiple reads to just read it once.\n\nIf we declare x as mutable;\n\nNow, compiler cannot make any assumptions about obj.x staying the same between two reads. It cannot cache or optimize away reads, because x could have been changed by another thread or mutable member function.\n\nFAQ: Why static class members cannot be declared as mutable?\n• Mutable is used to modify class member variables in a const object.\n• However static members are associated with the class type, not individual objects.\n• So, mutable doesn’t apply to static members as they aren’t tied to an object’s state.\n\nFAQ: Can we declare a function as mutable?\n• No, only member variables can be declared as mutable, not functions.\n• Declaring a function mutable would not be meaningful.\n\nFAQ: Can we declare an object as mutable?\n• No, mutable is used on member variables of a class, not objects themselves.\n• Making an entire object mutable implicitly defeats the purpose of immutability.\n\nLet’s understand using an example.\n• Here two threads are able to modify the state of a const object due to mutable. This breaks thread safety expectations.\n\nFAQ: Why do any thread-safe guarantees on a const class get broken if it uses mutable?\n• const objects are assumed thread-safe as their state cannot change.\n• But mutable lets state change even in a const object.\n• So any assumptions of thread safety for const no longer hold if mutable is used."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/8wbeom/coding_guideline_avoid_const_member_variables",
        "document": "Avoid using the const keyword with member variables of a class or struct type.\n\nFor a class type, if a piece of data is not supposed to change after being initialized, enforce this by design of the public API, not via the `const` key word.\n\nFor a struct which is a \"dumb aggregate\", it isn't appropriate to use `const`.\n\nUsing `const` on a member variable can force your class to have a throwing move. For instance this class,\n\nhas a throwing move, because the use of `const` keyword on the member variable prevents the compiler from using the move constructor of `std::string` with `id`, instead the compiler generated move constructor for `A` will invoke the copy constructor of `A::id`, which can throw.\n\nEven if your member variable does not have a throwing copy constructor, e.g.,\n\nyou should still not use `const` -- what if someone later has to refactor `id` to be a `std::string` instead of an `int`? They might be forced down a rabbit hole of unnecessarily complex refactors, or have to accept a throwing move, which can cause incompatibility with some containers, or a significant performance hit if used with `std::vector` for instance.\n\nIn general, using `const` in a member variable is bad because you are enforcing an API invariant at too low a level -- you are enforcing it at so low a level that it interferes with move semantics. Typically there are reasonable alternatives.\n\nIf you want to implement a map that can be a drop-in replacement for `std::map`, don't use `std::pair<const Key, Value>`, instead store both Key and Value as mutable, and return the user a pair of references, the first of which is const: `std::pair<const Key &, Value &>`.\n\n`const`-correctness is great -- use it on function parameters, class member functions, function local variables, etc. Avoid it on member variables of a class-type.\n\nIf your class is immovable by design then you can ignore this guideline\n\nWould be interested in your reaction to this.\n\nAFAIK a large majority of the examples I've seen where types \"naturally\" have throwing moves are caused by `const` member variables.\n\nIn code bases where I work and have worked in the past, most if not all types to have non-throwing moves, and we have implemented alternate versions of e.g. `std::function` that are type-erased and no-throw move constructible and assume the function objects are no-throw move constructible. In many of these cases it is important to us to do this because the application has real-time constraints and we care a lot about eliminating unnecessary dynamic allocations -- typically a throwing move happens because a dynamic allocation is happening when we don't want it to, so we have designed a lot of infrastructure in a way to force programmers not to do that. (Contrast this with @quicknir's comment here for instance https://www.reddit.com/r/cpp/comments/8vzvkb/be_mindful_with_compilergenerated_move/e1s24ac/ not that he's wrong ofc, we're just solving a more restricted problem and then we can do it with small buffer optimization and without throwing move)\n\nI'm expecting that at some point we are going to run into obscure and painful problems around this, because I think the committee thought a lot when they decided to embrace throwing moves, but it hasn't happened to us yet.\n\nI'm very interested to see which of these scenarios plays out:\n\n1.) Embracing throwing moves in the stdlib is something that is necessary primarily for backwards compatibility, while code bases that have special needs and rely less on stdlib can avoid it practically all of the time,\n\n2.) For fundamental reasons, avoiding throwing moves won't really work, eventually we will start to hit walls where certain types or idioms cannot be implemented without throwing moves and we will have to back out or implement alternate pathways to support this etc."
    },
    {
        "link": "https://cplusplus.com/forum/general/3475",
        "document": "To helios: no offense, but what kind of advice is \"stay away from these mostly useless and utterly confusing constructs\" on a C++ forum? IMHO it is very important to learn how to write const-correct code. The Wiki page is useful. When I was learning how to \"parse\" declarations with consts all over the place, I took some notes, which I've attached here:This file explains how const works.The following declarations are identical:const char* p;char const* p;Both declare a pointer to a constant character. The second is slightlybetter in the sense that the declaration can be read from right-to-left:\"p is a pointer to a const char\". Read as such, it is easy to see thatthe line *p = 'c'; will not compile.The following declaration:char* const p;declares p to be a constant pointer to a character. That is:p = \"foo\"; // Does not compile*p = 'f'; // Compiles!And thus:const char* const p;char const* const p;both declare p to be a constant pointer to a constant character, andso none of the following lines of code compile:p = \"foo\";*p = 'f';Now throw another pointer into the mix:const char** p;char const** p;These are equivalent and declare p to be a pointer to a pointer to aconstant character. That is:p = ptr-to-ptr-to-char; // Compiles*p = ptr-to-char; // Compiles**p = 'f'; // Does not compileOr how about creative placement of const:char* const* p;This declares p to be a pointer to a constant pointer to a character.That is:p = ptr-to-constptr-to-char; // Compiles*p = ptr-to-char; // Does not compile*p = constptr-to-char; // Does not compile**p = 'f'; // CompilesAnd the ever-popular:char** const p;Which declares p to be a constant pointer to a pointer to a character.Or:p = ptr-to-ptr-to-char; // Does not compilep = constptr-to-ptr-to-char; // Does not compile*p = ptr-to-char; // Compiles**p = 'f'; // CompilesAnd now we get just plain const happy:const char* const* p;p is a pointer to a constant pointer to a constant character. The onlything you can do with this one (besides remove the code and rewrite) is:p = ptr-to-constptr-to-constchar;const char** const p;p is a constant pointer to a pointer to a constant character. The onlything you can do with this is:*p = ptr-to-constchar;And this beast:const char* const* const p;Well, it won't pass code review since nobody will understand it, but atany rate... We've achieved maximum constant-ness with this line. Youcan't do anything at all with p, what it points to, what that points to,or what \"what that\" points to. You can print it. That's about it.Ho-ho, and the fun is just beginning. Now throw in REFERENCES!const char& p;char const& p;These both declare p to be a reference to a constant character. That is,p cannot change.char& const p;const char& const p;char const& const p;char*& const p;const char*& const p;const char* const& const p;These all generate compiler errors, because there is no such thing asa constant reference I guess.const char*& p;char const*& p;p is a reference to a pointer to a constant character. One can change p,but not *p.char* const& p;p is a reference to a constant pointer to a character.const char* const& p;p is a reference to a constant pointer to a constant character.const char&* p;char const&* p;char& const* p;char&* const p;const char& const* p;const char&* const p;const char& const* const p;Fortunately pointers to references are not allowed. The above declarationsare illegal. The programmer who attempts to use the above declarationsshould be fired anyway.As for mutable and const member functions.Here's an example:Note the \"const\" after DoSomething(). This means that DoSomething() is a const member function. This says that DoSomething() will not modify any of its own data members when it executes. Why is saying this useful? Because it is a contract to Foo's user. Let's extend the example:(I've omitted things like constructors, etc, to distill the code to its bare essence)Suppose you have a variable of type Foo, and that Foo's data members wereactually initialized to something useful:Why do I say that the second call to PrintMe() better print the same values asthe first call? How can I even know as a user of Foo, since I can't see whatDoSomething() does? Because DoSomething() is a const member function. It isa contract to me, the user, that says that DoSomething() will not modify any of its(non-mutable, but more on that later) data members.Now notice that WorkHard() is not declared as a const member function. So:Because WorkHard() is not declared const, it means that WorkHard() might modify one or more of the data members. Hopefully the description of the function tells me exactly what it does. For example \"multiplies someData by 2, increments moreData and wrapsat 'Z' back to 'A'. Does not modify yetMoreData.\" Unfortuantely, in practice, too many developers don't document well and don't follow const-correctness, and all too often it actually becomes hard to know whether a member function will modify state or not without looking at the implementation of the function (sometimes it is not obvious).The point is... declaring a member function const is part of the API that you are giving to the programmer who will use your code.Now, on to mutable. First, a classroom example, and then I'll give you a real-world example of where I used mutable in my code (I cannot publish the code here, but I will explain why I needed/wanted to use mutable).So const is part of the API of the class to the programmer, to guarantee that the object won't \"change state\" across calls to the function. Sometimes, your object might have some very internal data that your user couldn't possibly care about. For example, let's say you have a class that can send messages on a socket.I declared Send() to be const, because it doesn't change any data members (sock).Now, suppose for whatever reason I, the programmer of Socket, want to copy theuser's data into an internal cache in the class. Let's also say that my user cannot possibly care about what is in the internal cache.So now Send() wants to copy the user's data into the cache, but it can't becauseSend() is a const member function. So I make my cache mutable, and now Send()can do this.Why, you ask, don't I just make Send() non-const and forget the mutable? Possibly two reasons. First, if there is a lot of code using Socket already, it might be impractical for me to change Send() this way without causing a lot of compile errors (because my users might have been relying on Send() being const when they wrote their const-correct code). Second, as I stipulated earlier, my users can't possibly care that the cache changed when Send() was called."
    }
]