[
    {
        "link": "https://gta.ufrj.br/ensino/eel878/sockets/sockaddr_inman.html",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-sockaddr_in",
        "document": "The SOCKADDR_IN structure specifies a transport address and port for the AF_INET address family.\n\nThe address family for the transport address. This member should always be set to AF_INET.\n\nAn IN_ADDR structure that contains an IPv4 transport address.\n\nReserved for system use. A WSK application should set the contents of this array to zero.\n\nAll of the data in the SOCKADDR_IN structure, except for the address family, must be specified in network-byte-order (big-endian)."
    },
    {
        "link": "https://stackoverflow.com/questions/48328708/c-create-a-sockaddr-struct",
        "document": "I am trying to create a that creates a sockaddr structure, here's what I've done:\n\nThis seems to be no problem with AF_INET (IPv4), I can without any problem, but when I try to use AF_INET6, give me Invalid argument.\n\nHere's the code I use to :\n\nHowever, I can just fine if I construct a myself:\n\nSo I cast the created by the function back to , and I can see that all the fields are same except . To my understanding, does not matter unless I'm dealing with a link-local IPv6 address.\n\nAm I missing anything here?"
    },
    {
        "link": "https://stackoverflow.com/questions/66206865/socket-programming-casting-sockaddr-in-to-sockaddr-why",
        "document": "Here is a sample socket programming snippet from the client side. My question revolves around the type-casting that casted sockaddr_in into sockaddr. My question is that why is that casting necessary there, what is going on there exactly?\n\nI've been reading the documentation and going throughout the header files to understand the structures however there is one last thing that I couldn't get.\n\nMy question is, at this line of the code:\n\nWhat is the purpose of this casting here which casted sockaddr_in to sockaddr. I understand that it is mandatory to cast here, but I would like to know why is it so? Thank you"
    },
    {
        "link": "https://cs.cmu.edu/~srini/15-441/S10/lectures/r01-sockets.pdf",
        "document": ""
    },
    {
        "link": "https://gta.ufrj.br/ensino/eel878/sockets/htonsman.html",
        "document": ""
    },
    {
        "link": "https://beej.us/guide/bgnet/html",
        "document": "Hey! Socket programming got you down? Is this stuff just a little too difficult to figure out from the pages? You want to do cool Internet programming, but you don’t have time to wade through a gob of s trying to figure out if you have to call before you , etc., etc.\n\nWell, guess what! I’ve already done this nasty business, and I’m dying to share the information with everyone! You’ve come to the right place. This document should give the average competent C programmer the edge s/he needs to get a grip on this networking noise.\n\nAnd check it out: I’ve finally caught up with the future (just in the nick of time, too!) and have updated the Guide for IPv6! Enjoy!\n\nThis document has been written as a tutorial, not a complete reference. It is probably at its best when read by individuals who are just starting out with socket programming and are looking for a foothold. It is certainly not the complete and total guide to sockets programming, by any means.\n\nHopefully, though, it’ll be just enough for those man pages to start making sense…\n\nThe code contained within this document was compiled on a Linux PC using Gnu’s compiler. It should, however, build on just about any platform that uses . Naturally, this doesn’t apply if you’re programming for Windows—see the section on Windows programming, below.\n\nOfficial Homepage and Books For Sale\n\nThis official location of this document is:\n\nThere you will also find example code and translations of the guide into various languages.\n\nTo buy nicely bound print copies (some call them “books”), visit:\n\nI’ll appreciate the purchase because it helps sustain my document-writing lifestyle!\n\nWhen compiling for a Solaris variant or SunOS, you need to specify some extra command-line switches for linking in the proper libraries. In order to do this, simply add “ ” to the end of the compile command, like so:\n\nIf you still get errors, you could try further adding a to the end of that command line. I don’t know what that does, exactly, but some people seem to need it.\n\nAnother place that you might find problems is in the call to . The prototype differs from that on my Linux box, so instead of:\n\nAs I don’t have a Sun box, I haven’t tested any of the above information—it’s just what people have told me through email.\n\nAt this point in the guide, historically, I’ve done a bit of bagging on Windows, simply due to the fact that I don’t like it very much. But then Windows and Microsoft (as a company) got a lot better. Windows 9 and 10 coupled with WSL (below) actually were decent operating systems. Not really a lot to complain about.\n\nWell, a little—for example, I’m writing this (in 2025) on a 2015 laptop that used to run Windows 10. Eventually it got too slow and I installed Linux on it. And have been using it ever since.\n\nAnd now the news is out that Windows 11 will require beefier hardware than Windows 10. I’m not a fan of that. The OS should be as unobtrusive as possible and not require you to spend more money. The extra CPU power should be for apps, not the OS!\n\nSo I still encourage you to try Linux , BSD , illumos or some other flavor of Unix, instead.\n\nHow’d that soapbox get there?\n\nBut people like what they like, and you Windows folk will be pleased to know that this information is generally applicable to Windows, with a few minor changes.\n\nOh, hey, the soapbox is back!\n\nOne thing that you should strongly consider is the Windows Subsystem for Linux . This basically allows you to install a Linux VM-ish thing on Windows 10. That will also definitely get you situated, and you’ll be able to build and run these programs as is.\n\nAnother thing you can do is install Cygwin , which is a collection of Unix tools for Windows. I’ve heard on the grapevine that doing so allows all these programs to compile unmodified, but I’ve never tried it.\n\nSome of you might want to do things the Pure Windows Way. That’s very gutsy of you, and this is what you have to do: run out and get Unix immediately! No, no—I’m kidding. I’m supposed to be Windows-friendly(er) these days…\n\nOkay, okay. I’ll get on with it.\n\nThis is what you’ll have to do: first, ignore pretty much all of the system header files I mention in here. Instead, include:\n\nis the “new” (circa 1994) version of the Windows socket library.\n\nUnfortunately, if you include , it automatically pulls in the older (version 1) header file which conflicts with ! Fun times.\n\nSo if you have to include , you need to define a macro to get it to not include the older header:\n\nWait! You also have to make a call to before doing anything else with the sockets library. You pass in the Winsock version you desire to this function (e.g. version 2.2). And then you can check the result to make sure that version is available.\n\nThe code to do that looks something like this:\n\nNote that call to in there. That’s what you want to call when you’re done with the Winsock library.\n\nYou also have to tell your compiler to link in the Winsock library, called for Winsock 2. Under VC++, this can be done through the menu, under . Click the tab, and look for the box titled “Object/library modules”. Add “ws2_32.lib” (or whichever lib is your preference) to that list.\n\nOnce you do that, the rest of the examples in this tutorial should generally apply, with a few exceptions. For one thing, you can’t use to close a socket—you need to use , instead. Also, only works with socket descriptors, not file descriptors (like for ).\n\nThere is also a socket class that you can use, Check your compiler’s help pages for more information.\n\nTo get more information about Winsock, check out the official page at Microsoft.\n\nFinally, I hear that Windows has no system call which is, unfortunately, used in some of my examples. Maybe you have to link in a POSIX library or something to get it to work, or you can use instead. takes no arguments, and takes about 48 billion arguments. If you’re not up to that, the is a little easier to digest…unfortunately a discussion about multithreading is beyond the scope of this document. I can only talk about so much, you know!\n\nExtra finally, Steven Mitchell has ported a number of the examples to Winsock. Check that stuff out.\n\nI’m generally available to help out with email questions so feel free to write in, but I can’t guarantee a response. I lead a pretty busy life and there are times when I just can’t answer a question you have. When that’s the case, I usually just delete the message. It’s nothing personal; I just won’t ever have the time to give the detailed answer you require.\n\nAs a rule, the more complex the question, the less likely I am to respond. If you can narrow down your question before mailing it and be sure to include any pertinent information (like platform, compiler, error messages you’re getting, and anything else you think might help me troubleshoot), you’re much more likely to get a response. For more pointers, read ESR’s document, How To Ask Questions The Smart Way .\n\nIf you don’t get a response, hack on it some more, try to find the answer, and if it’s still elusive, then write me again with the information you’ve found and hopefully it will be enough for me to help out.\n\nNow that I’ve badgered you about how to write and not write me, I’d just like to let you know that I fully appreciate all the praise the guide has received over the years. It’s a real morale boost, and it gladdens me to hear that it is being used for good! Thank you!\n\nYou are more than welcome to mirror this site, whether publicly or privately. If you publicly mirror the site and want me to link to it from the main page, drop me a line at .\n\nIf you want to translate the guide into another language, write me at and I’ll link to your translation from the main page. Feel free to add your name and contact info to the translation.\n\nPlease note the license restrictions in the Copyright, Distribution, and Legal section, below.\n\nIf you want me to host the translation, just ask. I’ll also link to it if you want to host it; either way is fine.\n\nWith specific exceptions for source code and translations, below, this work is licensed under the Creative Commons Attribution- Noncommercial- No Derivative Works 3.0 License. To view a copy of this license, visit\n\nor send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.\n\nOne specific exception to the “No Derivative Works” portion of the license is as follows: this guide may be freely translated into any language, provided the translation is accurate, and the guide is reprinted in its entirety. The same license restrictions apply to the translation as to the original guide. The translation may also include the name and contact information for the translator.\n\nThe C source code presented in this document is hereby granted to the public domain, and is completely free of any license restriction.\n\nEducators are freely encouraged to recommend or supply copies of this guide to their students.\n\nUnless otherwise mutually agreed by the parties in writing, the author offers the work as-is and makes no representations or warranties of any kind concerning the work, express, implied, statutory or otherwise, including, without limitation, warranties of title, merchantability, fitness for a particular purpose, noninfringement, or the absence of latent or other defects, accuracy, or the presence of absence of errors, whether or not discoverable.\n\nExcept to the extent required by applicable law, in no event will the author be liable to you on any legal theory for any special, incidental, consequential, punitive or exemplary damages arising out of the use of the work, even if the author has been advised of the possibility of such damages.\n\nThanks to everyone who has helped in the past and future with me getting this guide written. And thank you to all the people who produce the Free software and packages that I use to make the Guide: GNU, Linux, Slackware, vim, Python, Inkscape, pandoc, many others. And finally a big thank-you to the literally thousands of you who have written in with suggestions for improvements and words of encouragement.\n\nI dedicate this guide to some of my biggest heroes and inpirators in the world of computers: Donald Knuth, Bruce Schneier, W. Richard Stevens, and The Woz, my Readership, and the entire Free and Open Source Software Community.\n\nThis book is written in Markdown using the vim editor on an Arch Linux box loaded with GNU tools. The cover “art” and diagrams are produced with Inkscape. The Markdown is converted to HTML and LaTex/PDF by Python, Pandoc and XeLaTeX, using Liberation fonts. The toolchain is composed of 100% Free and Open Source Software.\n\nYou hear talk of “sockets” all the time, and perhaps you are wondering just what they are exactly. Well, they’re this: a way to speak to other programs using standard Unix file descriptors.\n\nOk—you may have heard some Unix hacker state, “Jeez, everything in Unix is a file!” What that person may have been talking about is the fact that when Unix programs do any sort of I/O, they do it by reading or writing to a file descriptor. A file descriptor is simply an integer associated with an open file. But (and here’s the catch), that file can be a network connection, a FIFO, a pipe, a terminal, a real on-the-disk file, or just about anything else. Everything in Unix is a file! So when you want to communicate with another program over the Internet you’re gonna do it through a file descriptor, you’d better believe it.\n\n“Where do I get this file descriptor for network communication, Mr. Smarty-Pants?” is probably the last question on your mind right now, but I’m going to answer it anyway: You make a call to the system routine. It returns the socket descriptor, and you communicate through it using the specialized and ( , ) socket calls.\n\n“But, hey!” you might be exclaiming right about now. “If it’s a file descriptor, why in the name of Neptune can’t I just use the normal and calls to communicate through the socket?” The short answer is, “You can!” The longer answer is, “You can, but and offer much greater control over your data transmission.”\n\nWhat next? How about this: there are all kinds of sockets. There are DARPA Internet addresses (Internet Sockets), path names on a local node (Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can safely ignore), and probably many others depending on which Unix flavor you run. This document deals only with the first: Internet Sockets.\n\nWhat’s this? There are two types of Internet sockets? Yes. Well, no. I’m lying. There are more, but I didn’t want to scare you. I’m only going to talk about two types here. Except for this sentence, where I’m going to tell you that “Raw Sockets” are also very powerful and you should look them up.\n\nAll right, already. What are the two types? One is “Stream Sockets”; the other is “Datagram Sockets”, which may hereafter be referred to as “ ” and “ ”, respectively. Datagram sockets are sometimes called “connectionless sockets”. (Though they can be ’d if you really want. See , below.)\n\nStream sockets are reliable two-way connected communication streams. If you output two items into the socket in the order “1, 2”, they will arrive in the order “1, 2” at the opposite end. They will also be error-free. I’m so certain, in fact, they will be error-free, that I’m just going to put my fingers in my ears and chant la la la la if anyone tries to claim otherwise.\n\nWhat uses stream sockets? Well, you may have heard of the or applications, yes? They use stream sockets. All the characters you type need to arrive in the same order you type them, right? Also, web browsers use the Hypertext Transfer Protocol (HTTP) which uses stream sockets to get pages. Indeed, if you telnet to a web site on port 80, and type “ ” and hit RETURN twice, it’ll dump the HTML back at you!\n\nHow do stream sockets achieve this high level of data transmission quality? They use a protocol called “The Transmission Control Protocol”, otherwise known as “TCP” (see RFC 793 for extremely detailed info on TCP). TCP makes sure your data arrives sequentially and error-free. You may have heard “TCP” before as the better half of “TCP/IP” where “IP” stands for “Internet Protocol” (see RFC 791 ). IP deals primarily with Internet routing and is not generally responsible for data integrity.\n\nCool. What about Datagram sockets? Why are they called connectionless? What is the deal, here, anyway? Why are they unreliable? Well, here are some facts: if you send a datagram, it may arrive. It may arrive out of order. If it arrives, the data within the packet will be error-free.\n\nDatagram sockets also use IP for routing, but they don’t use TCP; they use the “User Datagram Protocol”, or “UDP” (see RFC 768 ).\n\nWhy are they connectionless? Well, basically, it’s because you don’t have to maintain an open connection as you do with stream sockets. You just build a packet, slap an IP header on it with destination information, and send it out. No connection needed. They are generally used either when a TCP stack is unavailable or when a few dropped packets here and there don’t mean the end of the Universe. Sample applications: (trivial file transfer protocol, a little brother to FTP), (a DHCP client), multiplayer games, streaming audio, video conferencing, etc.\n\n“Wait a minute! and are used to transfer binary applications from one host to another! Data can’t be lost if you expect the application to work when it arrives! What kind of dark magic is this?”\n\nWell, my human friend, and similar programs have their own protocol on top of UDP. For example, the tftp protocol says that for each packet that gets sent, the recipient has to send back a packet that says, “I got it!” (an “ACK” packet). If the sender of the original packet gets no reply in, say, five seconds, he’ll re-transmit the packet until he finally gets an ACK. This acknowledgment procedure is very important when implementing reliable applications.\n\nFor unreliable applications like games, audio, or video, you just ignore the dropped packets, or perhaps try to cleverly compensate for them. (Quake players will know the manifestation of this effect by the technical term: accursed lag. The word “accursed”, in this case, represents any extremely profane utterance.)\n\nWhy would you use an unreliable underlying protocol? Two reasons: speed and speed. It’s way faster to fire-and-forget than it is to keep track of what has arrived safely and make sure it’s in order and all that. If you’re sending chat messages, TCP is great; if you’re sending 40 positional updates per second of the players in the world, maybe it doesn’t matter so much if one or two get dropped, and UDP is a good choice.\n\nSince I just mentioned layering of protocols, it’s time to talk about how networks really work, and to show some examples of how packets are built. Practically, you can probably skip this section. It’s good background, however.\n\nHey, kids, it’s time to learn about Data Encapsulation! This is very very important. It’s so important that you might just learn about it if you take the networks course here at Chico State . Basically, it says this: a packet is born, the packet is wrapped (“encapsulated”) in a header (and rarely a footer) by the first protocol (say, the TFTP protocol), then the whole thing (TFTP header included) is encapsulated again by the next protocol (say, UDP), then again by the next (IP), then again by the final protocol on the hardware (physical) layer (say, Ethernet).\n\nWhen another computer receives the packet, the hardware strips the Ethernet header, the kernel strips the IP and UDP headers, the TFTP program strips the TFTP header, and it finally has the data.\n\nNow I can finally talk about the infamous Layered Network Model (aka “ISO/OSI”). This Network Model describes a system of network functionality that has many advantages over other models. For instance, you can write sockets programs that are exactly the same without caring how the data is physically transmitted (serial, thin Ethernet, AUI, whatever) because programs on lower levels deal with it for you. The actual network hardware and topology is transparent to the socket programmer.\n\nWithout any further ado, I’ll present the layers of the full-blown model. Remember this for network class exams:\n\nThe Physical Layer is the hardware (serial, Ethernet, etc.). The Application Layer is just about as far from the physical layer as you can imagine—it’s the place where users interact with the network.\n\nNow, this model is so general you could probably use it as an automobile repair guide if you really wanted to. A layered model more consistent with Unix might be:\n\nAt this point in time, you can probably see how these layers correspond to the encapsulation of the original data.\n\nSee how much work there is in building a simple packet? Jeez! And you have to type in the packet headers yourself using “ ”! Just kidding. All you have to do for stream sockets is the data out. All you have to do for datagram sockets is encapsulate the packet in the method of your choosing and it out. The kernel builds the Transport Layer and Internet Layer on for you and the hardware does the Network Access Layer. Ah, modern technology.\n\nSo ends our brief foray into network theory. Oh yes, I forgot to tell you everything I wanted to say about routing: nothing! That’s right, I’m not going to talk about it at all. The router strips the packet to the IP header, consults its routing table, blah blah blah. Check out the IP RFC if you really really care. If you never learn about it, well, you’ll live.\n\nHere’s the part of the game where we get to talk code for a change.\n\nBut first, let’s discuss more non-code! Yay! First I want to talk about IP addresses and ports for just a tad so we have that sorted out. Then we’ll talk about how the sockets API stores and manipulates IP addresses and other data.\n\nIn the good old days back when Ben Kenobi was still called Obi Wan Kenobi, there was a wonderful network routing system called The Internet Protocol Version 4, also called IPv4. It had addresses made up of four bytes (A.K.A. four “octets”), and was commonly written in “dots and numbers” form, like so: .\n\nYou’ve probably seen it around.\n\nIn fact, as of this writing, virtually every site on the Internet uses IPv4.\n\nEveryone, including Obi Wan, was happy. Things were great, until some naysayer by the name of Vint Cerf warned everyone that we were about to run out of IPv4 addresses!\n\nRun out of addresses? How could this be? I mean, there are like billions of IP addresses in a 32-bit IPv4 address. Do we really have billions of computers out there?\n\nAlso, in the beginning, when there were only a few computers and everyone thought a billion was an impossibly large number, some big organizations were generously allocated millions of IP addresses for their own use. (Such as Xerox, MIT, Ford, HP, IBM, GE, AT&T, and some little company called Apple, to name a few.)\n\nIn fact, if it weren’t for several stopgap measures, we would have run out a long time ago.\n\nBut now we’re living in an era where we’re talking about every human having an IP address, every computer, every calculator, every phone, every parking meter, and (why not) every puppy dog, as well.\n\nAnd so, IPv6 was born. Since Vint Cerf is probably immortal (even if his physical form should pass on, heaven forbid, he is probably already existing as some kind of hyper-intelligent ELIZA program out in the depths of the Internet2), no one wants to have to hear him say again “I told you so” if we don’t have enough addresses in the next version of the Internet Protocol.\n\nWhat does this suggest to you?\n\nThat we need a lot more addresses. That we need not just twice as many addresses, not a billion times as many, not a thousand trillion times as many, but 79 MILLION BILLION TRILLION times as many possible addresses! That’ll show ’em!\n\nYou’re saying, “Beej, is that true? I have every reason to disbelieve large numbers.” Well, the difference between 32 bits and 128 bits might not sound like a lot; it’s only 96 more bits, right? But remember, we’re talking powers here: 32 bits represents some 4 billion numbers (232), while 128 bits represents about 340 trillion trillion trillion numbers (for real, 2128). That’s like a million IPv4 Internets for every single star in the Universe.\n\nForget this dots-and-numbers look of IPv4, too; now we’ve got a hexadecimal representation, with each two-byte chunk separated by a colon, like this:\n\nThat’s not all! Lots of times, you’ll have an IP address with lots of zeros in it, and you can compress them between two colons. And you can leave off leading zeros for each byte pair. For instance, each of these pairs of addresses are equivalent:\n\nThe address is the loopback address. It always means “this machine I’m running on now”. In IPv4, the loopback address is .\n\nFinally, there’s an IPv4-compatibility mode for IPv6 addresses that you might come across. If you want, for example, to represent the IPv4 address as an IPv6 address, you use the following notation: “ ”.\n\nIn fact, it’s such serious fun, that the Creators of IPv6 have quite cavalierly lopped off trillions and trillions of addresses for reserved use, but we have so many, frankly, who’s even counting anymore? There are plenty left over for every man, woman, child, puppy, and parking meter on every planet in the galaxy. And believe me, every planet in the galaxy has parking meters. You know it’s true.\n\nFor organizational reasons, it’s sometimes convenient to declare that “this first part of this IP address up through this bit is the network portion of the IP address, and the remainder is the host portion.\n\nFor instance, with IPv4, you might have , and we could say that the first three bytes are the network and the last byte was the host. Or, put another way, we’re talking about host on network (see how we zero out the byte that was the host).\n\nAnd now for more outdated information! Ready? In the Ancient Times, there were “classes” of subnets, where the first one, two, or three bytes of the address was the network part. If you were lucky enough to have one byte for the network and three for the host, you could have 24 bits-worth of hosts on your network (16 million or so). That was a “Class A” network. On the opposite end was a “Class C”, with three bytes of network, and one byte of host (256 hosts, minus a couple that were reserved).\n\nSo as you can see, there were just a few Class As, a huge pile of Class Cs, and some Class Bs in the middle.\n\nThe network portion of the IP address is described by something called the netmask, which you bitwise-AND with the IP address to get the network number out of it. The netmask usually looks something like . (E.g. with that netmask, if your IP is , then your network is AND which gives .)\n\nUnfortunately, it turned out that this wasn’t fine-grained enough for the eventual needs of the Internet; we were running out of Class C networks quite quickly, and we were most definitely out of Class As, so don’t even bother to ask. To remedy this, The Powers That Be allowed for the netmask to be an arbitrary number of bits, not just 8, 16, or 24. So you might have a netmask of, say , which is 30 bits of network, and 2 bits of host allowing for four hosts on the network. (Note that the netmask is ALWAYS a bunch of 1-bits followed by a bunch of 0-bits.)\n\nBut it’s a bit unwieldy to use a big string of numbers like as a netmask. First of all, people don’t have an intuitive idea of how many bits that is, and secondly, it’s really not compact. So the New Style came along, and it’s much nicer. You just put a slash after the IP address, and then follow that by the number of network bits in decimal. Like this: .\n\nOr, for IPv6, something like this: or .\n\nIf you’ll kindly remember, I presented you earlier with the Layered Network Model which had the Internet Layer (IP) split off from the Host-to-Host Transport Layer (TCP and UDP). Get up to speed on that before the next paragraph.\n\nTurns out that besides an IP address (used by the IP layer), there is another address that is used by TCP (stream sockets) and, coincidentally, by UDP (datagram sockets). It is the port number. It’s a 16-bit number that’s like the local address for the connection.\n\nThink of the IP address as the street address of a hotel, and the port number as the room number. That’s a decent analogy; maybe later I’ll come up with one involving the automobile industry.\n\nSay you want to have a computer that handles incoming mail AND web services—how do you differentiate between the two on a computer with a single IP address?\n\nWell, different services on the Internet have different well-known port numbers. You can see them all in the Big IANA Port List or, if you’re on a Unix box, in your file. HTTP (the web) is port 80, telnet is port 23, SMTP is port 25, the game DOOM used port 666, etc. and so on. Ports under 1024 are often considered special, and usually require special OS privileges to use.\n\nAnd that’s about it!\n\nBy Order of the Realm! There shall be two byte orderings, hereafter to be known as Lame and Magnificent!\n\nI joke, but one really is better than the other.\n\nThere really is no easy way to say this, so I’ll just blurt it out: your computer might have been storing bytes in reverse order behind your back. I know! No one wanted to have to tell you.\n\nThe thing is, everyone in the Internet world has generally agreed that if you want to represent the two-byte hex number, say , you’ll store it in two sequential bytes followed by . Makes sense, and, as Wilford Brimley would tell you, it’s the Right Thing To Do. This number, stored with the big end first, is called Big-Endian.\n\nUnfortunately, a few computers scattered here and there throughout the world, namely anything with an Intel or Intel-compatible processor, store the bytes reversed, so would be stored in memory as the sequential bytes followed by . This storage method is called Little-Endian.\n\nBut wait, I’m not done with terminology yet! The more-sane Big-Endian is also called Network Byte Order because that’s the order us network types like.\n\nYour computer stores numbers in Host Byte Order. If it’s an Intel 80x86, Host Byte Order is Little-Endian. If it’s a Motorola 68k, Host Byte Order is Big-Endian. If it’s a PowerPC, Host Byte Order is… well, it depends!\n\nA lot of times when you’re building packets or filling out data structures you’ll need to make sure your two- and four-byte numbers are in Network Byte Order. But how can you do this if you don’t know the native Host Byte Order?\n\nGood news! You just get to assume the Host Byte Order isn’t right, and you always run the value through a function to set it to Network Byte Order. The function will do the magic conversion if it has to, and this way your code is portable to machines of differing endianness.\n\nAll righty. There are two types of numbers that you can convert: (two bytes) and (four bytes). These functions work for the variations as well. Say you want to convert a from Host Byte Order to Network Byte Order. Start with “h” for “host”, follow it with “to”, then “n” for “network”, and “s” for “short”: h-to-n-s, or (read: “Host to Network Short”).\n\nYou can use every combination of “n”, “h”, “s”, and “l” you want, not counting the really stupid ones. For example, there is NOT a (“Short to Long Host”) function—not at this party, anyway. But there are:\n\nBasically, you’ll want to convert the numbers to Network Byte Order before they go out on the wire, and convert them to Host Byte Order as they come in off the wire.\n\nI don’t know of a 64-bit variant, sorry. And if you want to do floating point, check out the section on Serialization, far below.\n\nAssume the numbers in this document are in Host Byte Order unless I say otherwise.\n\nWell, we’re finally here. It’s time to talk about programming. In this section, I’ll cover various data types used by the sockets interface, since some of them are a real bear to figure out.\n\nFirst the easy one: a socket descriptor. A socket descriptor is the following type:\n\nThings get weird from here, so just read through and bear with me.\n\nMy First Struct™— . This structure is a more recent invention, and is used to prep the socket address structures for subsequent use. It’s also used in host name lookups, and service name lookups. That’ll make more sense later when we get to actual usage, but just know for now that it’s one of the first things you’ll call when making a connection.\n\nYou’ll load this struct up a bit, and then call . It’ll return a pointer to a new linked list of these structures filled out with all the goodies you need.\n\nYou can force it to use IPv4 or IPv6 in the field, or leave it as to use whatever. This is cool because your code can be IP version-agnostic.\n\nNote that this is a linked list: points at the next element—there could be several results for you to choose from. I’d use the first result that worked, but you might have different business needs; I don’t know everything, man!\n\nYou’ll see that the field in the is a pointer to a . This is where we start getting into the nitty-gritty details of what’s inside an IP address structure.\n\nYou might not usually need to write to these structures; oftentimes, a call to to fill out your for you is all you’ll need. You will, however, have to peer inside these s to get the values out, so I’m presenting them here.\n\nSome s are IPv4, some are IPv6, and some are both. I’ll make notes of which are what.\n\nAnyway, the holds socket address information for many types of sockets.\n\ncan be a variety of things, but it’ll be (IPv4) or (IPv6) for everything we do in this document. contains a destination address and port number for the socket. This is rather unwieldy since you don’t want to tediously pack the address in the by hand.\n\nTo deal with , programmers created a parallel structure: (“in” for “Internet”) to be used with IPv4.\n\nAnd this is the important bit: a pointer to a can be cast to a pointer to a and vice-versa. So even though wants a , you can still use a and cast it at the last minute!\n\nThis structure makes it easy to reference elements of the socket address. Note that (which is included to pad the structure to the length of a ) should be set to all zeros with the function . Also, notice that corresponds to in a and should be set to “ ”. Finally, the must be in Network Byte Order (by using !)\n\nLet’s dig deeper! You see the field is a . What is that thing? Well, not to be overly dramatic, but it’s one of the scariest unions of all time:\n\nWhoa! Well, it used to be a union, but now those days seem to be gone. Good riddance. So if you have declared to be of type , then references the 4-byte IP address (in Network Byte Order). Note that even if your system still uses the God-awful union for , you can still reference the 4-byte IP address in exactly the same way as I did above (this due to s).\n\nWhat about IPv6? Similar s exist for it, as well:\n\nNote that IPv6 has an IPv6 address and a port number, just like IPv4 has an IPv4 address and a port number.\n\nAlso note that I’m not going to talk about the IPv6 flow information or Scope ID fields for the moment… this is just a starter guide.\n\nLast but not least, here is another simple structure, that is designed to be large enough to hold both IPv4 and IPv6 structures. See, for some calls, sometimes you don’t know in advance if it’s going to fill out your with an IPv4 or IPv6 address. So you pass in this parallel structure, very similar to except larger, and then cast it to the type you need:\n\nWhat’s important is that you can see the address family in the field—check this to see if it’s or (for IPv4 or IPv6). Then you can cast it to a or if you wanna.\n\nFortunately for you, there are a bunch of functions that allow you to manipulate IP addresses. No need to figure them out by hand and stuff them in a with the operator.\n\nFirst, let’s say you have a , and you have an IP address “ ” or “ ” that you want to store into it. The function you want to use, , converts an IP address in numbers-and-dots notation into either a or a depending on whether you specify or . (“ ” stands for “presentation to network”—you can call it “printable to network” if that’s easier to remember.) The conversion can be made as follows:\n\nNow, the above code snippet isn’t very robust because there is no error checking. See, returns on error, or 0 if the address is messed up. So check to make sure the result is greater than 0 before using!\n\nAll right, now you can convert string IP addresses to their binary representations. What about the other way around? What if you have a and you want to print it in numbers-and-dots notation? (Or a that you want in, uh, “hex-and-colons” notation.) In this case, you’ll want to use the function (“ntop” means “network to presentation”—you can call it “network to printable” if that’s easier to remember), like this:\n\nWhen you call it, you’ll pass the address type (IPv4 or IPv6), the address, a pointer to a string to hold the result, and the maximum length of that string. (Two macros conveniently hold the size of the string you’ll need to hold the largest IPv4 or IPv6 address: and .)\n\nLastly, these functions only work with numeric IP addresses—they won’t do any nameserver DNS lookup on a hostname, like “ ”. You will use to do that, as you’ll see later on.\n\nLots of places have a firewall that hides the network from the rest of the world for their own protection. And often times, the firewall translates “internal” IP addresses to “external” (that everyone else in the world knows) IP addresses using a process called Network Address Translation, or NAT.\n\nAre you getting nervous yet? “Where’s he going with all this weird stuff?”\n\nWell, relax and buy yourself a non-alcoholic (or alcoholic) drink, because as a beginner, you don’t even have to worry about NAT, since it’s done for you transparently. But I wanted to talk about the network behind the firewall in case you started getting confused by the network numbers you were seeing.\n\nFor instance, I have a firewall at home. I have two static IPv4 addresses allocated to me by the DSL company, and yet I have seven computers on the network. How is this possible? Two computers can’t share the same IP address, or else the data wouldn’t know which one to go to!\n\nThe answer is: they don’t share the same IP addresses. They are on a private network with 24 million IP addresses allocated to it. They are all just for me. Well, all for me as far as anyone else is concerned. Here’s what’s happening:\n\nIf I log into a remote computer, it tells me I’m logged in from 192.0.2.33 which is the public IP address my ISP has provided to me. But if I ask my local computer what its IP address is, it says 10.0.0.5. Who is translating the IP address from one to the other? That’s right, the firewall! It’s doing NAT!\n\nis one of a few reserved networks that are only to be used either on fully disconnected networks, or on networks that are behind firewalls. The details of which private network numbers are available for you to use are outlined in RFC 1918 , but some common ones you’ll see are and , where is 0-255, generally. Less common is , where goes between 16 and 31.\n\nNetworks behind a NATing firewall don’t need to be on one of these reserved networks, but they commonly are.\n\nIPv6 has private networks, too, in a sense. They’ll start with (or maybe in the future ), as per RFC 4193 . NAT and IPv6 don’t generally mix, however (unless you’re doing the IPv6 to IPv4 gateway thing which is beyond the scope of this document)—in theory you’ll have so many addresses at your disposal that you won’t need to use NAT any longer. But if you want to allocate addresses for yourself on a network that won’t route outside, this is how to do it.\n\nBut I just want to know what to change in my code to get it going with IPv6! Tell me now!\n\nAlmost everything in here is something I’ve gone over, above, but it’s the short version for the impatient. (Of course, there is more than this, but this is what applies to the guide.)\n• None First of all, try to use to get all the info, instead of packing the structures by hand. This will keep you IP version-agnostic, and will eliminate many of the subsequent steps.\n• None Any place that you find you’re hard-coding anything related to the IP version, try to wrap up in a helper function.\n• None Change assignments to assignments, which are slightly different: Also, the value can be used as an initializer when the is declared, like so:\n• None Instead of use , being sure to add “6” to the fields as appropriate (see s, above). There is no field.\n• None Instead of use , being sure to add “6” to the fields as appropriate (see s, above).\n• None Instead of or , use .\n• None Instead of , use .\n• None Instead of , use the superior .\n• None Instead of , use the superior (although can still work with IPv6).\n• None no longer works. Use IPv6 multicast instead.\n\nThis is the section where we get into the system calls (and other library calls) that allow you to access the network functionality of a Unix box, or any box that supports the sockets API for that matter (BSD, Windows, Linux, Mac, what-have-you.) When you call one of these functions, the kernel takes over and does all the work for you automagically.\n\nThe place most people get stuck around here is what order to call these things in. In that, the pages are no use, as you’ve probably discovered. Well, to help with that dreadful situation, I’ve tried to lay out the system calls in the following sections in exactly (approximately) the same order that you’ll need to call them in your programs.\n\nThat, coupled with a few pieces of sample code here and there, some milk and cookies (which I fear you will have to supply yourself), and some raw guts and courage, and you’ll be beaming data around the Internet like the Son of Jon Postel!\n\nThis is a real workhorse of a function with a lot of options, but usage is actually pretty simple. It helps set up the s you need later on.\n\nA tiny bit of history: it used to be that you would use a function called to do DNS lookups. Then you’d load that information by hand into a , and use that in your calls.\n\nThis is no longer necessary, thankfully. (Nor is it desirable, if you want to write code that works for both IPv4 and IPv6!) In these modern times, you now have the function that does all kinds of good stuff for you, including DNS and service name lookups, and fills out the s you need, besides!\n\nYou give this function three input parameters, and it gives you a pointer to a linked-list, , of results.\n\nThe parameter is the host name to connect to, or an IP address.\n\nNext is the parameter , which can be a port number, like “80”, or the name of a particular service (found in The IANA Port List or the file on your Unix machine) like “http” or “ftp” or “telnet” or “smtp” or whatever.\n\nFinally, the parameter points to a that you’ve already filled out with relevant information.\n\nHere’s a sample call if you’re a server who wants to listen on your host’s IP address, port 3490. Note that this doesn’t actually do any listening or network setup; it merely sets up structures we’ll use later:\n\nNotice that I set the to , thereby saying that I don’t care if we use IPv4 or IPv6. You can set it to or if you want one or the other specifically.\n\nAlso, you’ll see the flag in there; this tells to assign the address of my local host to the socket structures. This is nice because then you don’t have to hardcode it. (Or you can put a specific address in as the first parameter to where I currently have , up there.)\n\nThen we make the call. If there’s an error ( returns non-zero), we can print it out using the function , as you see. If everything works properly, though, will point to a linked list of s, each of which contains a of some kind that we can use later! Nifty!\n\nFinally, when we’re eventually all done with the linked list that so graciously allocated for us, we can (and should) free it all up with a call to .\n\nHere’s a sample call if you’re a client who wants to connect to a particular server, say “www.example.net” port 3490. Again, this doesn’t actually connect, but it sets up the structures we’ll use later:\n\nI keep saying that is a linked list with all kinds of address information. Let’s write a quick demo program to show off this information. This short program will print the IP addresses for whatever host you specify on the command line:\n\nAs you see, the code calls on whatever you pass on the command line, that fills out the linked list pointed to by , and then we can iterate over the list and print stuff out or do whatever.\n\nNow that we have that under control, we’ll use the results we get from to pass to other socket functions and, at long last, get our network connection established! Keep reading!\n\nI guess I can put it off no longer—I have to talk about the system call. Here’s the breakdown:\n\nBut what are these arguments? They allow you to say what kind of socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).\n\nIt used to be people would hardcode these values, and you can absolutely still do that. ( is or , is or , and can be set to to choose the proper protocol for the given . Or you can call to look up the protocol you want, “tcp” or “udp”.)\n\nAnyway, enough of that. What you really want to do is use the values from the results of the call to , and feed them into directly like this:\n\nsimply returns to you a socket descriptor that you can use in later system calls, or on error. The global variable is set to the error’s value (see the man page for more details, and a quick note on using in multithreaded programs).\n\nFine, fine, fine, but what good is this socket? The answer is that it’s really no good by itself, and you need to read on and make more system calls for it to make any sense.\n\nOnce you have a socket, you might have to associate that socket with a port on your local machine. (This is commonly done if you’re going to for incoming connections on a specific port—multiplayer network games do this when they tell you to “connect to 192.168.5.10 port 3490”.) The port number is used by the kernel to match an incoming packet to a certain process’s socket descriptor. If you’re going to only be doing a (because you’re the client, not the server), this is probably unnecessary. Read it anyway, just for kicks.\n\nHere is the synopsis for the system call:\n\nis the socket file descriptor returned by . is a pointer to a that contains information about your address, namely, port and IP address. is the length in bytes of that address.\n\nWhew. That’s a bit to absorb in one chunk. Let’s have an example that binds the socket to the host the program is running on, port 3490:\n\nBy using the flag, I’m telling the program to bind to the IP of the host it’s running on. If you want to bind to a specific local IP address, drop the and put an IP address in for the first argument to .\n\nalso returns on error and sets to the error’s value.\n\nLots of old code manually packs the before calling . Obviously this is IPv4-specific, but there’s really nothing stopping you from doing the same thing with IPv6, except that using is going to be easier, generally. Anyway, the old code looks something like this:\n\nIn the above code, you could also assign to the field if you wanted to bind to your local IP address (like the flag, above). The IPv6 version of is a global variable that is assigned into the field of your . (There is also a macro that you can use in a variable initializer.)\n\nAnother thing to watch out for when calling : don’t go underboard with your port numbers. All ports below 1024 are RESERVED (unless you’re the superuser)! You can have any port number above that, right up to 65535 (provided they aren’t already being used by another program).\n\nSometimes, you might notice, you try to rerun a server and fails, claiming “Address already in use.” What does that mean? Well, a little bit of a socket that was connected is still hanging around in the kernel, and it’s hogging the port. You can either wait for it to clear (a minute or so), or add code to your program allowing it to reuse the port, like this:\n\nOne small extra final note about : there are times when you won’t absolutely have to call it. If you are ing to a remote machine and you don’t care what your local port is (as is the case with where you only care about the remote port), you can simply call , it’ll check to see if the socket is unbound, and will it to an unused local port if necessary.\n\nLet’s just pretend for a few minutes that you’re a telnet application. Your user commands you (just like in the movie TRON) to get a socket file descriptor. You comply and call . Next, the user tells you to connect to “ ” on port “ ” (the standard telnet port). Yow! What do you do now?\n\nLucky for you, program, you’re now perusing the section on —how to connect to a remote host. So read furiously onward! No time to lose!\n\nThe call is as follows:\n\nis our friendly neighborhood socket file descriptor, as returned by the call, is a containing the destination port and IP address, and is the length in bytes of the server address structure.\n\nAll of this information can be gleaned from the results of the call, which rocks.\n\nIs this starting to make more sense? I can’t hear you from here, so I’ll just have to hope that it is. Let’s have an example where we make a socket connection to “ ”, port :\n\nAgain, old-school programs filled out their own s to pass to . You can do that if you want to. See the similar note in the section, above.\n\nBe sure to check the return value from —it’ll return on error and set the variable .\n\nAlso, notice that we didn’t call . Basically, we don’t care about our local port number; we only care where we’re going (the remote port). The kernel will choose a local port for us, and the site we connect to will automatically get this information from us. No worries.\n\n—Will somebody please call me?\n\nOK, time for a change of pace. What if you don’t want to connect to a remote host. Say, just for kicks, that you want to wait for incoming connections and handle them in some way. The process is two step: first you , then you (see below).\n\nThe call is fairly simple, but requires a bit of explanation:\n\nis the usual socket file descriptor from the system call. is the number of connections allowed on the incoming queue. What does that mean? Well, incoming connections are going to wait in this queue until you them (see below) and this is the limit on how many can queue up. Most systems silently limit this number to about 20; you can probably get away with setting it to or .\n\nAgain, as per usual, returns and sets on error.\n\nWell, as you can probably imagine, we need to call before we call so that the server is running on a specific port. (You have to be able to tell your buddies which port to connect to!) So if you’re going to be listening for incoming connections, the sequence of system calls you’ll make is:\n\nI’ll just leave that in the place of sample code, since it’s fairly self-explanatory. (The code in the section, below, is more complete.) The really tricky part of this whole sha-bang is the call to .\n\nGet ready—the call is kinda weird! What’s going to happen is this: someone far far away will try to to your machine on a port that you are ing on. Their connection will be queued up waiting to be ed. You call and you tell it to get the pending connection. It’ll return to you a brand new socket file descriptor to use for this single connection! That’s right, suddenly you have two socket file descriptors for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to and . We’re there!\n\nThe call is as follows:\n\nis the ing socket descriptor. Easy enough. will usually be a pointer to a local . This is where the information about the incoming connection will go (and with it you can determine which host is calling you from which port). is a local integer variable that should be set to before its address is passed to . will not put more than that many bytes into . If it puts fewer in, it’ll change the value of to reflect that.\n\nGuess what? returns and sets if an error occurs. Betcha didn’t figure that.\n\nLike before, this is a bunch to absorb in one chunk, so here’s a sample code fragment for your perusal:\n\nAgain, note that we will use the socket descriptor for all and calls. If you’re only getting one single connection ever, you can the listening in order to prevent more incoming connections on the same port, if you so desire.\n\nand —Talk to me, baby!\n\nThese two functions are for communicating over stream sockets or connected datagram sockets. If you want to use regular unconnected datagram sockets, you’ll need to see the section on and , below.\n\nis the socket descriptor you want to send data to (whether it’s the one returned by or the one you got with ). is a pointer to the data you want to send, and is the length of that data in bytes. Just set to . (See the man page for more information concerning flags.)\n\nSome sample code might be:\n\nreturns the number of bytes actually sent out—this might be less than the number you told it to send! See, sometimes you tell it to send a whole gob of data and it just can’t handle it. It’ll fire off as much of the data as it can, and trust you to send the rest later. Remember, if the value returned by doesn’t match the value in , it’s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will probably manage to send the whole thing all in one go. Again, is returned on error, and is set to the error number.\n\nThe call is similar in many respects:\n\nis the socket descriptor to read from, is the buffer to read the information into, is the maximum length of the buffer, and can again be set to . (See the man page for flag information.)\n\nreturns the number of bytes actually read into the buffer, or on error (with set, accordingly).\n\nWait! can return . This can mean only one thing: the remote side has closed the connection on you! A return value of is ’s way of letting you know this has occurred.\n\nThere, that was easy, wasn’t it? You can now pass data back and forth on stream sockets! Whee! You’re a Unix Network Programmer!\n\nand —Talk to me, DGRAM-style\n\n“This is all fine and dandy,” I hear you saying, “but where does this leave me with unconnected datagram sockets?” No problemo, amigo. We have just the thing.\n\nSince datagram sockets aren’t connected to a remote host, guess which piece of information we need to give before we send a packet? That’s right! The destination address! Here’s the scoop:\n\nAs you can see, this call is basically the same as the call to with the addition of two other pieces of information. is a pointer to a (which will probably be another or or that you cast at the last minute) which contains the destination IP address and port. , an deep-down, can simply be set to or .\n\nTo get your hands on the destination address structure, you’ll probably either get it from , or from , below, or you’ll fill it out by hand.\n\nJust like with , returns the number of bytes actually sent (which, again, might be less than the number of bytes you told it to send!), or on error.\n\nEqually similar are and . The synopsis of is:\n\nAgain, this is just like with the addition of a couple fields. is a pointer to a local that will be filled with the IP address and port of the originating machine. is a pointer to a local that should be initialized to or . When the function returns, will contain the length of the address actually stored in .\n\nreturns the number of bytes received, or on error (with set accordingly).\n\nSo, here’s a question: why do we use as the socket type? Why not ? Because, you see, we want to not tie ourselves down to IPv4 or IPv6. So we use the generic which we know will be big enough for either.\n\nRemember, if you a datagram socket, you can then simply use and for all your transactions. The socket itself is still a datagram socket and the packets still use UDP, but the socket interface will automatically add the destination and source information for you.\n\nWhew! You’ve been ing and ing data all day long, and you’ve had it. You’re ready to close the connection on your socket descriptor. This is easy. You can just use the regular Unix file descriptor function:\n\nThis will prevent any more reads and writes to the socket. Anyone attempting to read or write the socket on the remote end will receive an error.\n\nJust in case you want a little more control over how the socket closes, you can use the function. It allows you to cut off communication in a certain direction, or both ways (just like does). Synopsis:\n\nis the socket file descriptor you want to shutdown, and is one of the following:\n\nreturns on success, and on error (with set accordingly).\n\nIf you deign to use on unconnected datagram sockets, it will simply make the socket unavailable for further and calls (remember that you can use these if you your datagram socket).\n\nIt’s important to note that doesn’t actually close the file descriptor—it just changes its usability. To free a socket descriptor, you need to use .\n\nNothing to it.\n\nThis function is so easy.\n\nIt’s so easy, I almost didn’t give it its own section. But here it is anyway.\n\nThe function will tell you who is at the other end of a connected stream socket. The synopsis:\n\nis the descriptor of the connected stream socket, is a pointer to a (or a ) that will hold the information about the other side of the connection, and is a pointer to an , that should be initialized to or .\n\nThe function returns on error and sets accordingly.\n\nOnce you have their address, you can use , , or to print or get more information. No, you can’t get their login name. (Ok, ok. If the other computer is running an ident daemon, this is possible. This, however, is beyond the scope of this document. Check out RFC 1413 for more info.)\n\nEven easier than is the function . It returns the name of the computer that your program is running on. The name can then be used by , above, to determine the IP address of your local machine.\n\nWhat could be more fun? I could think of a few things, but they don’t pertain to socket programming. Anyway, here’s the breakdown:\n\nThe arguments are simple: is a pointer to an array of chars that will contain the hostname upon the function’s return, and is the length in bytes of the array.\n\nThe function returns on successful completion, and on error, setting as usual.\n\nIt’s a client-server world, baby. Just about everything on the network deals with client processes talking to server processes and vice-versa. Take , for instance. When you connect to a remote host on port 23 with telnet (the client), a program on that host (called , the server) springs to life. It handles the incoming telnet connection, sets you up with a login prompt, etc.\n\nThe exchange of information between client and server is summarized in the above diagram.\n\nNote that the client-server pair can speak , , or anything else (as long as they’re speaking the same thing). Some good examples of client-server pairs are / , / , or / . Every time you use , there’s a remote program, , that serves you.\n\nOften, there will only be one server on a machine, and that server will handle multiple clients using . The basic routine is: server will wait for a connection, it, and a child process to handle it. This is what our sample server does in the next section.\n\nAll this server does is send the string “ ” out over a stream connection. All you need to do to test this server is run it in one window, and telnet to it from another with:\n\nwhere is the name of the machine you’re running it on.\n\nIn case you’re curious, I have the code in one big function for (I feel) syntactic clarity. Feel free to split it into smaller functions if it makes you feel better.\n\nYou can get the data from this server by using the client listed in the next section.\n\nThis guy’s even easier than the server. All this client does is connect to the host you specify on the command line, port 3490. It gets the string that the server sends.\n\nNotice that if you don’t run the server before you run the client, returns “Connection refused”. Very useful.\n\nWe’ve already covered the basics of UDP datagram sockets with our discussion of and , above, so I’ll just present a couple of sample programs: and .\n\nsits on a machine waiting for an incoming packet on port 4950. sends a packet to that port, on the specified machine, that contains whatever the user enters on the command line.\n\nBecause datagram sockets are connectionless and just fire packets off into the ether with callous disregard for success, we are going to tell the client and server to use specifically IPv6. This way we avoid the situation where the server is listening on IPv6 and the client sends on IPv4; the data simply would not be received. (In our connected TCP stream sockets world, we might still have the mismatch, but the error on for one address family would cause us to retry for the other.)\n\nHere is the source for :\n\nNotice that in our call to we’re finally using . Also, note that there’s no need to or . This is one of the perks of using unconnected datagram sockets!\n\nNext comes the source for :\n\nAnd that’s all there is to it! Run on some machine, then run on another. Watch them communicate! Fun G-rated excitement for the entire nuclear family!\n\nYou don’t even have to run the server this time! You can run by itself, and it just happily fires packets off into the ether where they disappear if no one is ready with a on the other side. Remember: data sent using UDP datagram sockets isn’t guaranteed to arrive!\n\nExcept for one more tiny detail that I’ve mentioned many times in the past: connected datagram sockets. I need to talk about this here, since we’re in the datagram section of the document. Let’s say that calls and specifies the ’s address. From that point on, may only send to and receive from the address specified by . For this reason, you don’t have to use and ; you can simply use and .\n\nThese aren’t really advanced, but they’re getting out of the more basic levels we’ve already covered. In fact, if you’ve gotten this far, you should consider yourself fairly accomplished in the basics of Unix network programming! Congratulations!\n\nSo here we go into the brave new world of some of the more esoteric things you might want to learn about sockets. Have at it!\n\nBlocking. You’ve heard about it—now what the heck is it? In a nutshell, “block” is techie jargon for “sleep”. You probably noticed that when you run , above, it just sits there until a packet arrives. What happened is that it called , there was no data, and so is said to “block” (that is, sleep there) until some data arrives.\n\nLots of functions block. blocks. All the functions block. The reason they can do this is because they’re allowed to. When you first create the socket descriptor with , the kernel sets it to blocking. If you don’t want a socket to be blocking, you have to make a call to :\n\nBy setting a socket to non-blocking, you can effectively “poll” the socket for information. If you try to read from a non-blocking socket and there’s no data there, it’s not allowed to block—it will return and will be set to or .\n\nGenerally speaking, however, this type of polling is a bad idea. If you put your program in a busy-wait looking for data on the socket, you’ll suck up CPU time like it was going out of style. A more elegant solution for checking to see if there’s data waiting to be read comes in the following section on .\n\nWhat you really want to be able to do is somehow monitor a bunch of sockets at once and then handle the ones that have data ready. This way you don’t have to continuously poll all those sockets to see which are ready to read.\n\nSo how can you avoid polling? Not slightly ironically, you can avoid polling by using the system call. In a nutshell, we’re going to ask the operating system to do all the dirty work for us, and just let us know when some data is ready to read on which sockets. In the meantime, our process can go to sleep, saving system resources.\n\nThe general gameplan is to keep an array of s with information about which socket descriptors we want to monitor, and what kind of events we want to monitor for. The OS will block on the call until one of those events occurs (e.g. “socket ready to read!”) or until a user-specified timeout occurs.\n\nUsefully, a ing socket will return “ready to read” when a new incoming connection is ready to be ed.\n\nThat’s enough banter. How do we use this?\n\nis our array of information (which sockets to monitor for what), is the count of elements in the array, and is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.\n\nLet’s have a look at that :\n\nSo we’re going to have an array of those, and we’ll set the field for each element to a socket descriptor we’re interested in monitoring. And then we’ll set the field to indicate the type of events we’re interested in.\n\nThe field is the bitwise-OR of the following:\n\nOnce you have your array of s in order, then you can pass it to , also passing the size of the array, as well as a timeout value in milliseconds. (You can specify a negative timeout to wait forever.)\n\nAfter returns, you can check the field to see if or is set, indicating that event occurred.\n\nHere’s an example where we’ll wait 2.5 seconds for data to be ready to read from standard input, i.e. when you hit :\n\nNotice again that returns the number of elements in the array for which events have occurred. It doesn’t tell you which elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero field (so you can stop scanning after you find that many).\n\nA couple questions might come up here: how to add new file descriptors to the set I pass to ? For this, simply make sure you have enough space in the array for all you need, or more space as needed.\n\nWhat about deleting items from the set? For this, you can copy the last element in the array over-top the one you’re deleting. And then pass in one fewer as the count to . Another option is that you can set any field to a negative number and will ignore it.\n\nHow can we put it all together into a chat server that you can to?\n\nWhat we’ll do is start a listener socket, and add it to the set of file descriptors to . (It will show ready-to-read when there’s an incoming connection.)\n\nThen we’ll add new connections to our array. And we’ll grow it dynamically if we run out of space.\n\nWhen a connection is closed, we’ll remove it from the array.\n\nAnd when a connection is ready-to-read, we’ll read the data from it and send that data to all the other connections so they can see what the other users typed.\n\nSo give this poll server a try. Run it in one window, then from a number of other terminal windows. You should be able to see what you type in one window in the other ones (after you hit RETURN).\n\nNot only that, but if you hit and type to exit , the server should detect the disconnection and remove you from the array of file descriptors.\n\nIn the next section, we’ll look at a similar, older function called . Both and offer similar functionality and performance, and only really differ in how they’re used. might be slightly more portable, but is perhaps a little clunkier in use. Choose the one you like the best, as long as it’s supported on your system.\n\nThis function is somewhat strange, but it’s very useful. Take the following situation: you are a server and you want to listen for incoming connections as well as keep reading from the connections you already have.\n\nNo problem, you say, just an and a couple of s. Not so fast, buster! What if you’re blocking on an call? How are you going to data at the same time? “Use non-blocking sockets!” No way! You don’t want to be a CPU hog. What, then?\n\ngives you the power to monitor several sockets at the same time. It’ll tell you which ones are ready for reading, which are ready for writing, and which sockets have raised exceptions, if you really want to know that.\n\nWithout any further ado, I’ll offer the synopsis of :\n\nThe function monitors “sets” of file descriptors; in particular , , and . If you want to see if you can read from standard input and some socket descriptor, , just add the file descriptors and to the set . The parameter should be set to the values of the highest file descriptor plus one. In this example, it should be set to , since it is assuredly higher than standard input ( ).\n\nWhen returns, will be modified to reflect which of the file descriptors you selected which is ready for reading. You can test them with the macro , below.\n\nBefore progressing much further, I’ll talk about how to manipulate these sets. Each set is of the type . The following macros operate on this type:\n\nFinally, what is this weirded-out ? Well, sometimes you don’t want to wait forever for someone to send you some data. Maybe every 96 seconds you want to print “Still Going…” to the terminal even though nothing has happened. This time structure allows you to specify a timeout period. If the time is exceeded and still hasn’t found any ready file descriptors, it’ll return so you can continue processing.\n\nThe has the follow fields:\n\nJust set to the number of seconds to wait, and set to the number of microseconds to wait. Yes, that’s _micro_seconds, not milliseconds. There are 1,000 microseconds in a millisecond, and 1,000 milliseconds in a second. Thus, there are 1,000,000 microseconds in a second. Why is it “usec”? The “u” is supposed to look like the Greek letter μ (Mu) that we use for “micro”. Also, when the function returns, might be updated to show the time still remaining. This depends on what flavor of Unix you’re running.\n\nYay! We have a microsecond resolution timer! Well, don’t count on it. You’ll probably have to wait some part of your standard Unix timeslice no matter how small you set your .\n\nOther things of interest: If you set the fields in your to , will timeout immediately, effectively polling all the file descriptors in your sets. If you set the parameter to NULL, it will never timeout, and will wait until the first file descriptor is ready. Finally, if you don’t care about waiting for a certain set, you can just set it to NULL in the call to .\n\nThe following code snippet waits 2.5 seconds for something to appear on standard input:\n\nIf you’re on a line buffered terminal, the key you hit should be RETURN or it will time out anyway.\n\nNow, some of you might think this is a great way to wait for data on a datagram socket—and you are right: it might be. Some Unices can use select in this manner, and some can’t. You should see what your local man page says on the matter if you want to attempt it.\n\nSome Unices update the time in your to reflect the amount of time still remaining before a timeout. But others do not. Don’t rely on that occurring if you want to be portable. (Use if you need to track time elapsed. It’s a bummer, I know, but that’s the way it is.)\n\nWhat happens if a socket in the read set closes the connection? Well, in that case, returns with that socket descriptor set as “ready to read”. When you actually do from it, will return . That’s how you know the client has closed the connection.\n\nOne more note of interest about : if you have a socket that is ing, you can check to see if there is a new connection by putting that socket’s file descriptor in the set.\n\nAnd that, my friends, is a quick overview of the almighty function.\n\nBut, by popular demand, here is an in-depth example. Unfortunately, the difference between the dirt-simple example, above, and this one here is significant. But have a look, then read the description that follows it.\n\nThis program acts like a simple multi-user chat server. Start it running in one window, then to it (“ ”) from multiple other windows. When you type something in one session, it should appear in all the others.\n\nNotice I have two file descriptor sets in the code: and . The first, , holds all the socket descriptors that are currently connected, as well as the socket descriptor that is listening for new connections.\n\nThe reason I have the set is that actually changes the set you pass into it to reflect which sockets are ready to read. Since I have to keep track of the connections from one call of to the next, I must store these safely away somewhere. At the last minute, I copy the into the , and then call .\n\nBut doesn’t this mean that every time I get a new connection, I have to add it to the set? Yup! And every time a connection closes, I have to remove it from the set? Yes, it does.\n\nNotice I check to see when the socket is ready to read. When it is, it means I have a new connection pending, and I it and add it to the set. Similarly, when a client connection is ready to read, and returns , I know the client has closed the connection, and I must remove it from the set.\n\nIf the client returns non-zero, though, I know some data has been received. So I get it, and then go through the list and send that data to all the rest of the connected clients.\n\nAnd that, my friends, is a less-than-simple overview of the almighty function.\n\nQuick note to all you Linux fans out there: sometimes, in rare circumstances, Linux’s can return “ready-to-read” and then not actually be ready to read! This means it will block on the after the says it won’t! Why you little—! Anyway, the workaround solution is to set the flag on the receiving socket so it errors with (which you can just safely ignore if it occurs). See the reference page for more info on setting a socket to non-blocking.\n\nIn addition, here is a bonus afterthought: there is another function called which behaves much the same way does, but with a different system for managing the file descriptor sets. Check it out!\n\nRemember back in the section about , above, when I said that might not send all the bytes you asked it to? That is, you want it to send 512 bytes, but it returns 412. What happened to the remaining 100 bytes?\n\nWell, they’re still in your little buffer waiting to be sent out. Due to circumstances beyond your control, the kernel decided not to send all the data out in one chunk, and now, my friend, it’s up to you to get the data out there.\n\nYou could write a function like this to do it, too:\n\nIn this example, is the socket you want to send the data to, is the buffer containing the data, and is a pointer to an containing the number of bytes in the buffer.\n\nThe function returns on error (and is still set from the call to ). Also, the number of bytes actually sent is returned in . This will be the same number of bytes you asked it to send, unless there was an error. will do its best, huffing and puffing, to send the data out, but if there’s an error, it gets back to you right away.\n\nFor completeness, here’s a sample call to the function:\n\nWhat happens on the receiver’s end when part of a packet arrives? If the packets are variable length, how does the receiver know when one packet ends and another begins? Yes, real-world scenarios are a royal pain in the donkeys. You probably have to encapsulate (remember that from the data encapsulation section way back there at the beginning?) Read on for details!\n\nIt’s easy enough to send text data across the network, you’re finding, but what happens if you want to send some “binary” data like s or s? It turns out you have a few options.\n• None Convert the number into text with a function like , then send the text. The receiver will parse the text back into a number using a function like .\n• None Just send the data raw, passing a pointer to the data to .\n• None Encode the number into a portable binary form. The receiver will decode it.\n\nActually all the methods, above, have their drawbacks and advantages, but, like I said, in general, I prefer the third method. First, though, let’s talk about some of the drawbacks and advantages to the other two.\n\nThe first method, encoding the numbers as text before sending, has the advantage that you can easily print and read the data that’s coming over the wire. Sometimes a human-readable protocol is excellent to use in a non-bandwidth-intensive situation, such as with Internet Relay Chat (IRC) . However, it has the disadvantage that it is slow to convert, and the results almost always take up more space than the original number!\n\nMethod two: passing the raw data. This one is quite easy (but dangerous!): just take a pointer to the data to send, and call send with it.\n\nThe receiver gets it like this:\n\nFast, simple—what’s not to like? Well, it turns out that not all architectures represent a (or for that matter) with the same bit representation or even the same byte ordering! The code is decidedly non-portable. (Hey—maybe you don’t need portability, in which case this is nice and fast.)\n\nWhen packing integer types, we’ve already seen how the -class of functions can help keep things portable by transforming the numbers into Network Byte Order, and how that’s the Right Thing to do. Unfortunately, there are no similar functions for types. Is all hope lost?\n\nFear not! (Were you afraid there for a second? No? Not even a little bit?) There is something we can do: we can pack (or “marshal”, or “serialize”, or one of a thousand million other names) the data into a known binary format that the receiver can unpack on the remote side.\n\nWhat do I mean by “known binary format”? Well, we’ve already seen the example, right? It changes (or “encodes”, if you want to think of it that way) a number from whatever the host format is into Network Byte Order. To reverse (unencode) the number, the receiver calls .\n\nBut didn’t I just get finished saying there wasn’t any such function for other non-integer types? Yes. I did. And since there’s no standard way in C to do this, it’s a bit of a pickle (that a gratuitous pun there for you Python fans).\n\nThe thing to do is to pack the data into a known format and send that over the wire for decoding. For example, to pack s, here’s something quick and dirty with plenty of room for improvement :\n\nThe above code is sort of a naive implementation that stores a in a 32-bit number. The high bit (31) is used to store the sign of the number (“1” means negative), and the next seven bits (30-16) are used to store the whole number portion of the . Finally, the remaining bits (15-0) are used to store the fractional portion of the number.\n\nOn the plus side, it’s small, simple, and fast. On the minus side, it’s not an efficient use of space and the range is severely restricted—try storing a number greater-than 32767 in there and it won’t be very happy! You can also see in the above example that the last couple decimal places are not correctly preserved.\n\nWhat can we do instead? Well, The Standard for storing floating point numbers is known as IEEE-754 . Most computers use this format internally for doing floating point math, so in those cases, strictly speaking, conversion wouldn’t need to be done. But if you want your source code to be portable, that’s an assumption you can’t necessarily make. (On the other hand, if you want things to be fast, you should optimize this out on platforms that don’t need to do it! That’s what and its ilk do.)\n\nHere’s some code that encodes floats and doubles into IEEE-754 format . (Mostly—it doesn’t encode NaN or Infinity, but it could be modified to do that.)\n\nI put some handy macros up there at the top for packing and unpacking 32-bit (probably a ) and 64-bit (probably a ) numbers, but the function could be called directly and told to encode -worth of data ( of which are reserved for the normalized number’s exponent).\n\nThe above code produces this output:\n\nAnother question you might have is how do you pack s? Unfortunately for you, the compiler is free to put padding all over the place in a , and that means you can’t portably send the whole thing over the wire in one chunk. (Aren’t you getting sick of hearing “can’t do this”, “can’t do that”? Sorry! To quote a friend, “Whenever anything goes wrong, I always blame Microsoft.” This one might not be Microsoft’s fault, admittedly, but my friend’s statement is completely true.)\n\nBack to it: the best way to send the over the wire is to pack each field independently and then unpack them into the when they arrive on the other side.\n\nThat’s a lot of work, is what you’re thinking. Yes, it is. One thing you can do is write a helper function to help pack the data for you. It’ll be fun! Really!\n\nIn the book The Practice of Programming by Kernighan and Pike, they implement -like functions called and that do exactly this. I’d link to them, but apparently those functions aren’t online with the rest of the source from the book.\n\nAt this point, I’m going to drop a pointer to a Protocol Buffers implementation in C which I’ve never used, but looks completely respectable. Python and Perl programmers will want to check out their language’s and functions for accomplishing the same thing. And Java has a big-ol’ Serializable interface that can be used in a similar way.\n\nBut if you want to write your own packing utility in C, K&P’s trick is to use variable argument lists to make -like functions to build the packets. Here’s a version I cooked up on my own based on that which hopefully will be enough to give you an idea of how such a thing can work.\n\nAnd here is a demonstration program of the above code that packs some data into and then unpacks it into variables. Note that when calling with a string argument (format specifier “ ”), it’s wise to put a maximum length count in front of it to prevent a buffer overrun, e.g. “ ”. Be wary when unpacking data you get over the network—a malicious user might send badly-constructed packets in an effort to attack your system!\n\nWhether you roll your own code or use someone else’s, it’s a good idea to have a general set of data packing routines for the sake of keeping bugs in check, rather than packing each bit by hand each time.\n\nWhen packing the data, what’s a good format to use? Excellent question. Fortunately, RFC 4506 , the External Data Representation Standard, already defines binary formats for a bunch of different types, like floating point types, integer types, arrays, raw data, etc. I suggest conforming to that if you’re going to roll the data yourself. But you’re not obligated to. The Packet Police are not right outside your door. At least, I don’t think they are.\n\nIn any case, encoding the data somehow or another before you send it is the right way of doing things!\n\nWhat does it really mean to encapsulate data, anyway? In the simplest case, it means you’ll stick a header on there with either some identifying information or a packet length, or both.\n\nWhat should your header look like? Well, it’s just some binary data that represents whatever you feel is necessary to complete your project.\n\nOkay. For instance, let’s say you have a multi-user chat program that uses s. When a user types (“says”) something, two pieces of information need to be transmitted to the server: what was said and who said it.\n\nSo far so good? “What’s the problem?” you’re asking.\n\nThe problem is that the messages can be of varying lengths. One person named “tom” might say, “Hi”, and another person named “Benjamin” might say, “Hey guys what is up?”\n\nSo you all this stuff to the clients as it comes in. Your outgoing data stream looks like this:\n\nAnd so on. How does the client know when one message starts and another stops? You could, if you wanted, make all messages the same length and just call the we implemented, above. But that wastes bandwidth! We don’t want to 1024 bytes just so “tom” can say “Hi”.\n\nSo we encapsulate the data in a tiny header and packet structure. Both the client and server know how to pack and unpack (sometimes referred to as “marshal” and “unmarshal”) this data. Don’t look now, but we’re starting to define a protocol that describes how a client and server communicate!\n\nIn this case, let’s assume the user name is a fixed length of 8 characters, padded with . And then let’s assume the data is variable length, up to a maximum of 128 characters. Let’s have a look a sample packet structure that we might use in this situation:\n• None (1 byte, unsigned)—The total length of the packet, counting the 8-byte user name and chat data.\n• None (8 bytes)—The user’s name, NUL-padded if necessary.\n• None (n-bytes)—The data itself, no more than 128 bytes. The length of the packet should be calculated as the length of this data plus 8 (the length of the name field, above).\n\nWhy did I choose the 8-byte and 128-byte limits for the fields? I pulled them out of the air, assuming they’d be long enough. Maybe, though, 8 bytes is too restrictive for your needs, and you can have a 30-byte name field, or whatever. The choice is up to you.\n\nUsing the above packet definition, the first packet would consist of the following information (in hex and ASCII):\n\nAnd the second is similar:\n\nWhen you’re sending this data, you should be safe and use a command similar to , above, so you know all the data is sent, even if it takes multiple calls to to get it all out.\n\nLikewise, when you’re receiving this data, you need to do a bit of extra work. To be safe, you should assume that you might receive a partial packet (like maybe we receive “ ” from Benjamin, above, but that’s all we get in this call to ). We need to call over and over again until the packet is completely received.\n\nBut how? Well, we know the number of bytes we need to receive in total for the packet to be complete, since that number is tacked on the front of the packet. We also know the maximum packet size is 1+8+128, or 137 bytes (because that’s how we defined the packet).\n\nThere are actually a couple things you can do here. Since you know every packet starts off with a length, you can call just to get the packet length. Then once you have that, you can call it again specifying exactly the remaining length of the packet (possibly repeatedly to get all the data) until you have the complete packet. The advantage of this method is that you only need a buffer large enough for one packet, while the disadvantage is that you need to call at least twice to get all the data.\n\nAnother option is just to call and say the amount you’re willing to receive is the maximum number of bytes in a packet. Then whatever you get, stick it onto the back of a buffer, and finally check to see if the packet is complete. Of course, you might get some of the next packet, so you’ll need to have room for that.\n\nWhat you can do is declare an array big enough for two packets. This is your work array where you will reconstruct packets as they arrive.\n\nEvery time you data, you’ll append it into the work buffer and check to see if the packet is complete. That is, the number of bytes in the buffer is greater than or equal to the length specified in the header (+1, because the length in the header doesn’t include the byte for the length itself). If the number of bytes in the buffer is less than 1, the packet is not complete, obviously. You have to make a special case for this, though, since the first byte is garbage and you can’t rely on it for the correct packet length.\n\nOnce the packet is complete, you can do with it what you will. Use it, and remove it from your work buffer.\n\nWhew! Are you juggling that in your head yet? Well, here’s the second of the one-two punch: you might have read past the end of one packet and onto the next in a single call. That is, you have a work buffer with one complete packet, and an incomplete part of the next packet! Bloody heck. (But this is why you made your work buffer large enough to hold two packets—in case this happened!)\n\nSince you know the length of the first packet from the header, and you’ve been keeping track of the number of bytes in the work buffer, you can subtract and calculate how many of the bytes in the work buffer belong to the second (incomplete) packet. When you’ve handled the first one, you can clear it out of the work buffer and move the partial second packet down the to front of the buffer so it’s all ready to go for the next .\n\nI never said it was easy. Ok, I did say it was easy. And it is; you just need practice and pretty soon it’ll come to you naturally. By Excalibur I swear it!\n\nSo far, this guide has talked about sending data from one host to one other host. But it is possible, I insist, that you can, with the proper authority, send data to multiple hosts at the same time!\n\nWith UDP (only UDP, not TCP) and standard IPv4, this is done through a mechanism called broadcasting. With IPv6, broadcasting isn’t supported, and you have to resort to the often superior technique of multicasting, which, sadly I won’t be discussing at this time. But enough of the starry-eyed future—we’re stuck in the 32-bit present.\n\nBut wait! You can’t just run off and start broadcasting willy-nilly; You have to set the socket option before you can send a broadcast packet out on the network. It’s like a one of those little plastic covers they put over the missile launch switch! That’s just how much power you hold in your hands!\n\nBut seriously, though, there is a danger to using broadcast packets, and that is: every system that receives a broadcast packet must undo all the onion-skin layers of data encapsulation until it finds out what port the data is destined to. And then it hands the data over or discards it. In either case, it’s a lot of work for each machine that receives the broadcast packet, and since it is all of them on the local network, that could be a lot of machines doing a lot of unnecessary work. When the game Doom first came out, this was a complaint about its network code.\n\nNow, there is more than one way to skin a cat… wait a minute. Is there really more than one way to skin a cat? What kind of expression is that? Uh, and likewise, there is more than one way to send a broadcast packet. So, to get to the meat and potatoes of the whole thing: how do you specify the destination address for a broadcast message? There are two common ways:\n• None Send the data to a specific subnet’s broadcast address. This is the subnet’s network number with all one-bits set for the host portion of the address. For instance, at home my network is , my netmask is , so the last byte of the address is my host number (because the first three bytes, according to the netmask, are the network number). So my broadcast address is . Under Unix, the command will actually give you all this data. (If you’re curious, the bitwise logic to get your broadcast address is OR (NOT ).) You can send this type of broadcast packet to remote networks as well as your local network, but you run the risk of the packet being dropped by the destination’s router. (If they didn’t drop it, then some random smurf could start flooding their LAN with broadcast traffic.)\n• None Send the data to the “global” broadcast address. This is , aka . Many machines will automatically bitwise AND this with your network number to convert it to a network broadcast address, but some won’t. It varies. Routers do not forward this type of broadcast packet off your local network, ironically enough.\n\nSo what happens if you try to send data on the broadcast address without first setting the socket option? Well, let’s fire up good old and and see what happens.\n\nYes, it’s not happy at all…because we didn’t set the socket option. Do that, and now you can anywhere you want!\n\nIn fact, that’s the only difference between a UDP application that can broadcast and one that can’t. So let’s take the old application and add one section that sets the socket option. We’ll call this program :\n\nWhat’s different between this and a “normal” UDP client/server situation? Nothing! (With the exception of the client being allowed to send broadcast packets in this case.) As such, go ahead and run the old UDP program in one window, and in another. You should be now be able to do all those sends that failed, above.\n\nAnd you should see responding that it got the packets. (If doesn’t respond, it could be because it’s bound to an IPv6 address. Try changing the in to to force IPv4.)\n\nWell, that’s kind of exciting. But now fire up on another machine next to you on the same network so that you have two copies going, one on each machine, and run again with your broadcast address… Hey! Both s get the packet even though you only called once! Cool!\n\nIf the gets data you send directly to it, but not data on the broadcast address, it could be that you have a firewall on your local machine that is blocking the packets. (Yes, Pat and Bapper, thank you for realizing before I did that this is why my sample code wasn’t working. I told you I’d mention you in the guide, and here you are. So nyah.)\n\nAgain, be careful with broadcast packets. Since every machine on the LAN will be forced to deal with the packet whether it s it or not, it can present quite a load to the entire computing network. They are definitely to be used sparingly and appropriately.\n\nWhere can I get those header files?\n\nIf you don’t have them on your system already, you probably don’t need them. Check the manual for your particular platform. If you’re building for Windows, you only need to .\n\nWhat do I do when reports “Address already in use”?\n\nYou have to use with the option on the listening socket. Check out the section on and the section on for an example.\n\nHow do I get a list of open sockets on the system?\n\nUse the . Check the page for full details, but you should get some good output just typing:\n\nThe only trick is determining which socket is associated with which program.\n\nHow can I view the routing table?\n\nRun the command (in on most Linuxes) or the command . Or the command .\n\nHow can I run the client and server programs if I only have one computer? Don’t I need a network to write network programs?\n\nFortunately for you, virtually all machines implement a loopback network “device” that sits in the kernel and pretends to be a network card. (This is the interface listed as “ ” in the routing table.)\n\nPretend you’re logged into a machine named “ ”. Run the client in one window and the server in another. Or start the server in the background (“ ”) and run the client in the same window. The upshot of the loopback device is that you can either or (since “ ” is likely defined in your file) and you’ll have the client talking to the server without a network!\n\nIn short, no changes are necessary to any of the code to make it run on a single non-networked machine! Huzzah!\n\nHow can I tell if the remote side has closed connection?\n\nYou can tell because will return .\n\nHow do I implement a “ping” utility? What is ICMP? Where can I find out more about raw sockets and ?\n\nAll your raw sockets questions will be answered in W. Richard Stevens’ UNIX Network Programming books. Also, look in the subdirectory in Stevens’ UNIX Network Programming source code, available online .\n\nHow do I change or shorten the timeout on a call to ?\n\nInstead of giving you exactly the same answer that W. Richard Stevens would give you, I’ll just refer you to in the UNIX Network Programming source code .\n\nThe gist of it is that you make a socket descriptor with , set it to non-blocking, call , and if all goes well will return immediately and will be set to . Then you call with whatever timeout you want, passing the socket descriptor in both the read and write sets. If it doesn’t timeout, it means the call completed. At this point, you’ll have to use with the option to get the return value from the call, which should be zero if there was no error.\n\nFinally, you’ll probably want to set the socket back to be blocking again before you start transferring data over it.\n\nNotice that this has the added benefit of allowing your program to do something else while it’s connecting, too. You could, for example, set the timeout to something low, like 500 ms, and update an indicator onscreen each timeout, then call again. When you’ve called and timed-out, say, 20 times, you’ll know it’s time to give up on the connection.\n\nLike I said, check out Stevens’ source for a perfectly excellent example.\n\nHow do I build for Windows?\n\nFirst, delete Windows and install Linux or BSD. . No, actually, just see the section on building for Windows in the introduction.\n\nHow do I build for Solaris/SunOS? I keep getting linker errors when I try to compile!\n\nThe linker errors happen because Sun boxes don’t automatically compile in the socket libraries. See the section on building for Solaris/SunOS in the introduction for an example of how to do this.\n\nWhy does keep falling out on a signal?\n\nSignals tend to cause blocked system calls to return with set to . When you set up a signal handler with , you can set the flag , which is supposed to restart the system call after it was interrupted.\n\nMy favorite solution to this involves a statement. You know this irritates your professors to no end, so go for it!\n\nSure, you don’t need to use in this case; you can use other structures to control it. But I think the statement is actually cleaner.\n\nHow can I implement a timeout on a call to ?\n\nUse ! It allows you to specify a timeout parameter for socket descriptors that you’re looking to read from. Or, you could wrap the entire functionality in a single function, like this:\n\nNotice that returns in case of a timeout. Why not return ? Well, if you recall, a return value of on a call to means that the remote side closed the connection. So that return value is already spoken for, and means “error”, so I chose as my timeout indicator.\n\nHow do I encrypt or compress the data before sending it through the socket?\n\nOne easy way to do encryption is to use SSL (secure sockets layer), but that’s beyond the scope of this guide. (Check out the OpenSSL project for more info.)\n\nBut assuming you want to plug in or implement your own compressor or encryption system, it’s just a matter of thinking of your data as running through a sequence of steps between both ends. Each step changes the data in some way.\n• server reads data from file (or wherever)\n\nNow the other way around:\n• client writes data to file (or wherever)\n\nIf you’re going to compress and encrypt, just remember to compress first.\n\nJust as long as the client properly undoes what the server does, the data will be fine in the end no matter how many intermediate steps you add.\n\nSo all you need to do to use my code is to find the place between where the data is read and the data is sent (using ) over the network, and stick some code in there that does the encryption.\n\nWhat is this “ ” I keep seeing? Is it related to ?\n\nYes, yes it is. See the section on for details.\n\nHow can I write a server that accepts shell commands from a client and executes them?\n\nFor simplicity, lets say the client s, s, and s the connection (that is, there are no subsequent system calls without the client connecting again).\n\nThe process the client follows is this:\n\nMeanwhile, the server is handling the data and executing it:\n• the connection from the client\n\nBeware! Having the server execute what the client says is like giving remote shell access and people can do things to your account when they connect to the server. For instance, in the above example, what if the client sends “ ”? It deletes everything in your account, that’s what!\n\nSo you get wise, and you prevent the client from using any except for a couple utilities that you know are safe, like the utility:\n\nBut you’re still unsafe, unfortunately: what if the client enters “ ”? The safest thing to do is to write a little routine that puts an escape (“ ”) character in front of all non-alphanumeric characters (including spaces, if appropriate) in the arguments for the command.\n\nAs you can see, security is a pretty big issue when the server starts executing things the client sends.\n\nI’m sending a slew of data, but when I , it only receives 536 bytes or 1460 bytes at a time. But if I run it on my local machine, it receives all the data at the same time. What’s going on?\n\nYou’re hitting the MTU—the maximum size the physical medium can handle. On the local machine, you’re using the loopback device which can handle 8K or more no problem. But on Ethernet, which can only handle 1500 bytes with a header, you hit that limit. Over a modem, with 576 MTU (again, with header), you hit the even lower limit.\n\nYou have to make sure all the data is being sent, first of all. (See the function implementation for details.) Once you’re sure of that, then you need to call in a loop until all your data is read.\n\nRead the section Son of Data Encapsulation for details on receiving complete packets of data using multiple calls to .\n\nI’m on a Windows box and I don’t have the system call or any kind of . What to do?\n\nIf they’re anywhere, they’ll be in POSIX libraries that may have shipped with your compiler. Since I don’t have a Windows box, I really can’t tell you the answer, but I seem to remember that Microsoft has a POSIX compatibility layer and that’s where would be. (And maybe even .)\n\nSearch the help that came with VC++ for “fork” or “POSIX” and see if it gives you any clues.\n\nIf that doesn’t work at all, ditch the / stuff and replace it with the Win32 equivalent: . I don’t know how to use —it takes a bazillion arguments, but it should be covered in the docs that came with VC++.\n\nI’m behind a firewall—how do I let people outside the firewall know my IP address so they can connect to my machine?\n\nUnfortunately, the purpose of a firewall is to prevent people outside the firewall from connecting to machines inside the firewall, so allowing them to do so is basically considered a breach of security.\n\nThis isn’t to say that all is lost. For one thing, you can still often through the firewall if it’s doing some kind of masquerading or NAT or something like that. Just design your programs so that you’re always the one initiating the connection, and you’ll be fine.\n\nIf that’s not satisfactory, you can ask your sysadmins to poke a hole in the firewall so that people can connect to you. The firewall can forward to you either through it’s NAT software, or through a proxy or something like that.\n\nBe aware that a hole in the firewall is nothing to be taken lightly. You have to make sure you don’t give bad people access to the internal network; if you’re a beginner, it’s a lot harder to make software secure than you might imagine.\n\nDon’t make your sysadmin mad at me.\n\nHow do I write a packet sniffer? How do I put my Ethernet interface into promiscuous mode?\n\nFor those not in the know, when a network card is in “promiscuous mode”, it will forward ALL packets to the operating system, not just those that were addressed to this particular machine. (We’re talking Ethernet-layer addresses here, not IP addresses–but since ethernet is lower-layer than IP, all IP addresses are effectively forwarded as well. See the section Low Level Nonsense and Network Theory for more info.)\n\nThis is the basis for how a packet sniffer works. It puts the interface into promiscuous mode, then the OS gets every single packet that goes by on the wire. You’ll have a socket of some type that you can read this data from.\n\nUnfortunately, the answer to the question varies depending on the platform, but if you Google for, for instance, “windows promiscuous ioctl” you’ll probably get somewhere. For Linux, there’s what looks like a useful Stack Overflow thread , as well.\n\nHow can I set a custom timeout value for a TCP or UDP socket?\n\nIt depends on your system. You might search the net for and (for use with ) to see if your system supports such functionality.\n\nThe Linux man page suggests using or as a substitute.\n\nHow can I tell which ports are available to use? Is there a list of “official” port numbers?\n\nUsually this isn’t an issue. If you’re writing, say, a web server, then it’s a good idea to use the well-known port 80 for your software. If you’re writing just your own specialized server, then choose a port at random (but greater than 1023) and give it a try.\n\nIf the port is already in use, you’ll get an “Address already in use” error when you try to . Choose another port. (It’s a good idea to allow the user of your software to specify an alternate port either with a config file or a command line switch.)\n\nThere is a list of official port numbers maintained by the Internet Assigned Numbers Authority (IANA). Just because something (over 1023) is in that list doesn’t mean you can’t use the port. For instance, Id Software’s DOOM uses the same port as “mdqs”, whatever that is. All that matters is that no one else on the same machine is using that port when you want to use it.\n\nIn the Unix world, there are a lot of manuals. They have little sections that describe individual functions that you have at your disposal.\n\nOf course, would be too much of a thing to type. I mean, no one in the Unix world, including myself, likes to type that much. Indeed I could go on and on at great length about how much I prefer to be terse but instead I shall be brief and not bore you with long-winded diatribes about how utterly amazingly brief I prefer to be in virtually all circumstances in their entirety.\n\nThank you. What I am getting at is that these pages are called “man pages” in the Unix world, and I have included my own personal truncated variant here for your reading enjoyment. The thing is, many of these functions are way more general purpose than I’m letting on, but I’m only going to present the parts that are relevant for Internet Sockets Programming.\n\nBut wait! That’s not all that’s wrong with my man pages:\n• They are incomplete and only show the basics from the guide.\n• There are many more man pages than this in the real world.\n• They are different than the ones on your system.\n• The header files might be different for certain functions on your system.\n• The function parameters might be different for certain functions on your system.\n\nIf you want the real information, check your local Unix man pages by typing , where “whatever” is something that you’re incredibly interested in, such as “ ”. (I’m sure Microsoft Visual Studio has something similar in their help section. But “man” is better because it is one byte more concise than “help”. Unix wins again!)\n\nSo, if these are so flawed, why even include them at all in the Guide? Well, there are a few reasons, but the best are that (a) these versions are geared specifically toward network programming and are easier to digest than the real ones, and (b) these versions contain examples!\n\nOh! And speaking of the examples, I don’t tend to put in all the error checking because it really increases the length of the code. But you should absolutely do error checking pretty much any time you make any of the system calls unless you’re totally 100% sure it’s not going to fail, and you should probably do it even then!\n\nOnce you’ve gone through the trouble of getting a socket and setting it up for incoming connections with , then you call to actually get yourself a new socket descriptor to use for subsequent communication with the newly connected client.\n\nThe old socket that you are using for listening is still there, and will be used for further calls as they come in.\n\nwill normally block, and you can use to peek on the listening socket descriptor ahead of time to see if it’s “ready to read”. If so, then there’s a new connection waiting to be ed! Yay! Alternatively, you could set the flag on the listening socket using , and then it will never block, choosing instead to return with set to .\n\nThe socket descriptor returned by is a bona fide socket descriptor, open and connected to the remote host. You have to it when you’re done with it.\n\nreturns the newly connected socket descriptor, or on error, with set appropriately.\n\nAssociate a socket with an IP address and port number\n\nWhen a remote machine wants to connect to your server program, it needs two pieces of information: the IP address and the port number. The call allows you to do just that.\n\nFirst, you call to load up a with the destination address and port information. Then you call to get a socket descriptor, and then you pass the socket and address into , and the IP address and port are magically (using actual magic) bound to the socket!\n\nIf you don’t know your IP address, or you know you only have one IP address on the machine, or you don’t care which of the machine’s IP addresses is used, you can simply pass the flag in the parameter to . What this does is fill in the IP address part of the with a special value that tells that it should automatically fill in this host’s IP address.\n\nWhat what? What special value is loaded into the ’s IP address to cause it to auto-fill the address with the current host? I’ll tell you, but keep in mind this is only if you’re filling out the by hand; if not, use the results from , as per above. In IPv4, the field of the structure is set to . In IPv6, the field of the structure is assigned into from the global variable . Or, if you’re declaring a new , you can initialize it to .\n\nLastly, the parameter should be set to .\n\nReturns zero on success, or on error (and will be set accordingly).\n\nOnce you’ve built a socket descriptor with the call, you can that socket to a remote server using the well-named system call. All you need to do is pass it the socket descriptor and the address of the server you’re interested in getting to know better. (Oh, and the length of the address, which is commonly passed to functions like this.)\n\nUsually this information comes along as the result of a call to , but you can fill out your own if you want to.\n\nIf you haven’t yet called on the socket descriptor, it is automatically bound to your IP address and a random local port. This is usually just fine with you if you’re not a server, since you really don’t care what your local port is; you only care what the remote port is so you can put it in the parameter. You can call if you really want your client socket to be on a specific IP address and port, but this is pretty rare.\n\nOnce the socket is ed, you’re free to and data on it to your heart’s content.\n\nSpecial note: if you a UDP socket to a remote host, you can use and as well as and . If you want.\n\nReturns zero on success, or on error (and will be set accordingly).\n\nAfter you’ve finished using the socket for whatever demented scheme you have concocted and you don’t want to or or, indeed, do anything else at all with the socket, you can it, and it’ll be freed up, never to be used again.\n\nThe remote side can tell if this happens one of two ways. One: if the remote side calls , it will return . Two: if the remote side calls , it’ll receive a signal and send() will return and will be set to .\n\nWindows users: the function you need to use is called , not . If you try to use on a socket descriptor, it’s possible Windows will get angry… And you wouldn’t like it when it’s angry.\n\nReturns zero on success, or on error (and will be set accordingly).\n\nGet information about a host name and/or service and load up a with the result.\n\nis an excellent function that will return information on a particular host name (such as its IP address) and load up a for you, taking care of the gritty details (like if its IPv4 or IPv6). It replaces the old functions and .The description, below, contains a lot of information that might be a little daunting, but actual usage is pretty simple. It might be worth it to check out the examples first.\n\nThe host name that you’re interested in goes in the parameter. The address can be either a host name, like “www.example.com”, or an IPv4 or IPv6 address (passed as a string). This parameter can also be if you’re using the flag (see below).\n\nThe parameter is basically the port number. It can be a port number (passed as a string, like “80”), or it can be a service name, like “http” or “tftp” or “smtp” or “pop”, etc. Well-known service names can be found in the IANA Port List or in your file.\n\nLastly, for input parameters, we have . This is really where you get to define what the function is going to do. Zero the whole structure before use with . Let’s take a look at the fields you need to set up before use.\n\nThe can be set to a variety of things, but here are a couple important ones. (Multiple flags can be specified by bitwise-ORing them together with the operator). Check your man page for the complete list of flags.\n\ncauses the of the result to the filled out with the host’s canonical (real) name. causes the result’s IP address to be filled out with (IPv4) or (IPv6); this causes a subsequent call to to auto-fill the IP address of the with the address of the current host. That’s excellent for setting up a server when you don’t want to hardcode the address.\n\nIf you do use the , flag, then you can pass in the (since will fill it in for you later).\n\nContinuing on with the input parameters, you’ll likely want to set to which tells to look for both IPv4 and IPv6 addresses. You can also restrict yourself to one or the other with or .\n\nNext, the field should be set to or , depending on which type of socket you want.\n\nFinally, just leave at to automatically choose your protocol type.\n\nNow, after you get all that stuff in there, you can finally make the call to !\n\nOf course, this is where the fun begins. The will now point to a linked list of s, and you can go through this list to get all the addresses that match what you passed in with the hints.\n\nNow, it’s possible to get some addresses that don’t work for one reason or another, so what the Linux man page does is loops through the list doing a call to and (or if you’re setting up a server with the flag) until it succeeds.\n\nFinally, when you’re done with the linked list, you need to call to free up the memory (or it will be leaked, and Some People will get upset).\n\nReturns zero on success, or nonzero on error. If it returns nonzero, you can use the function to get a printable version of the error code in the return value.\n\nReturns the name of the system\n\nYour system has a name. They all do. This is a slightly more Unixy thing than the rest of the networky stuff we’ve been talking about, but it still has its uses.\n\nFor instance, you can get your host name, and then call to find out your IP address.\n\nThe parameter should point to a buffer that will hold the host name, and is the size of that buffer in bytes. won’t overwrite the end of the buffer (it might return an error, or it might just stop writing), and it will -terminate the string if there’s room for it in the buffer.\n\nReturns zero on success, or on error (and will be set accordingly).\n\nGet an IP address for a hostname, or vice-versa\n\nPLEASE NOTE: these two functions are superseded by and ! In particular, doesn’t work well with IPv6.\n\nThese functions map back and forth between host names and IP addresses. For instance, if you have “www.example.com”, you can use to get its IP address and store it in a .\n\nConversely, if you have a or a , you can use to get the hostname back. is IPv6 compatible, but you should use the newer shinier instead.\n\ntakes a string like “www.yahoo.com”, and returns a which contains tons of information, including the IP address. (Other information is the official host name, a list of aliases, the address type, the length of the addresses, and the list of addresses—it’s a general-purpose structure that’s pretty easy to use for our specific purposes once you see how.)\n\ntakes a or and brings you up a corresponding host name (if there is one), so it’s sort of the reverse of . As for parameters, even though is a , you actually want to pass in a pointer to a . should be , and should be .\n\nSo what is this that gets returned? It has a number of fields that contain information about the host in question.\n\nReturns a pointer to a resultant on success, or on error.\n\nInstead of the normal and all that stuff you’d normally use for error reporting, these functions have parallel results in the variable , which can be printed using the functions or . These work just like the classic , , and functions you’re used to.\n\nLook up the host name and service name information for a given .\n\nThis function is the opposite of , that is, this function takes an already loaded and does a name and service name lookup on it. It replaces the old and functions.\n\nYou have to pass in a pointer to a (which in actuality is probably a or that you’ve cast) in the parameter, and the length of that in the .\n\nThe resultant host name and service name will be written to the area pointed to by the and parameters. Of course, you have to specify the max lengths of these buffers in and .\n\nFinally, there are several flags you can pass, but here a a couple good ones. will cause the to only contain the host name, not the whole domain name. will cause the function to fail if the name cannot be found with a DNS lookup (if you don’t specify this flag and the name can’t be found, will put a string version of the IP address in instead).\n\nAs always, check your local man pages for the full scoop.\n\nReturns zero on success, or non-zero on error. If the return value is non-zero, it can be passed to to get a human-readable string. See for more information.\n\nReturn address info about the remote side of the connection\n\nOnce you have either ed a remote connection, or ed to a server, you now have what is known as a peer. Your peer is simply the computer you’re connected to, identified by an IP address and a port. So…\n\nsimply returns a filled with information about the machine you’re connected to.\n\nWhy is it called a “name”? Well, there are a lot of different kinds of sockets, not just Internet Sockets like we’re using in this guide, and so “name” was a nice generic term that covered all cases. In our case, though, the peer’s “name” is it’s IP address and port.\n\nAlthough the function returns the size of the resultant address in , you must preload with the size of .\n\nReturns zero on success, or on error (and will be set accordingly).\n\nHolds the error code for the last system call\n\nThis is the variable that holds error information for a lot of system calls. If you’ll recall, things like and return on error, and they set the exact value of to let you know specifically which error occurred.\n\nThe header file lists a bunch of constant symbolic names for errors, such as , , , etc. Your local man pages will tell you what codes can be returned as an error, and you can use these at run time to handle different errors in different ways.\n\nOr, more commonly, you can call or to get a human-readable version of the error.\n\nOne thing to note, for you multithreading enthusiasts, is that on most systems is defined in a threadsafe manner. (That is, it’s not actually a global variable, but it behaves just like a global variable would in a single-threaded environment.)\n\nThe value of the variable is the latest error to have transpired, which might be the code for “success” if the last action succeeded.\n\nThis function is typically used to do file locking and other file-oriented stuff, but it also has a couple socket-related functions that you might see or use from time to time.\n\nParameter is the socket descriptor you wish to operate on, should be set to , and can be one of the following commands. (Like I said, there’s more to than I’m letting on here, but I’m trying to stay socket-oriented.)\n\nReturns zero on success, or on error (and will be set accordingly).\n\nDifferent uses of the system call actually have different return values, but I haven’t covered them here because they’re not socket-related. See your local man page for more information.\n\nJust to make you really unhappy, different computers use different byte orderings internally for their multibyte integers (i.e. any integer that’s larger than a ). The upshot of this is that if you a two-byte from an Intel box to a Mac (before they became Intel boxes, too, I mean), what one computer thinks is the number , the other will think is the number , and vice-versa.\n\nThe way to get around this problem is for everyone to put aside their differences and agree that Motorola and IBM had it right, and Intel did it the weird way, and so we all convert our byte orderings to “big-endian” before sending them out. Since Intel is a “little-endian” machine, it’s far more politically correct to call our preferred byte ordering “Network Byte Order”. So these functions convert from your native byte order to network byte order and back again.\n\nNote that the types involved are 32-bit (4 byte, probably ) and 16-bit (2 byte, very likely ) numbers. 64-bit machines might have a for 64-bit s, but I’ve not seen it. You’ll just have to write your own.\n\nAnyway, the way these functions work is that you first decide if you’re converting from host (your machine’s) byte order or from network byte order. If “host”, the the first letter of the function you’re going to call is “h”. Otherwise it’s “n” for “network”. The middle of the function name is always “to” because you’re converting from one “to” another, and the penultimate letter shows what you’re converting to. The last letter is the size of the data, “s” for short, or “l” for long. Thus:\n\nEach function returns the converted value.\n\nConvert IP addresses from a dots-and-number string to a and back\n\nThese functions are deprecated because they don’t handle IPv6! Use or instead! They are included here because they can still be found in the wild.\n\nAll of these functions convert from a (part of your , most likely) to a string in dots-and-numbers format (e.g. “192.168.5.10”) and vice-versa. If you have an IP address passed on the command line or something, this is the easiest way to get a to to, or whatever. If you need more power, try some of the DNS functions like or attempt a coup d’État in your local country.\n\nThe function converts a network address in a to a dots-and-numbers format string. The “n” in “ntoa” stands for network, and the “a” stands for ASCII for historical reasons (so it’s “Network To ASCII”—the “toa” suffix has an analogous friend in the C library called which converts an ASCII string to an integer).\n\nThe function is the opposite, converting from a dots-and-numbers string into a (which is the type of the field in your ).\n\nFinally, the function is an older function that does basically the same thing as . It’s theoretically deprecated, but you’ll see it a lot and the police won’t come get you if you use it.\n\nreturns non-zero if the address is a valid one, and it returns zero if the address is invalid.\n\nreturns the dots-and-numbers string in a static buffer that is overwritten with each call to the function.\n\nreturns the address as an , or if there’s an error. (That is the same result as if you tried to convert the string “ ”, which is a valid IP address. This is why is better.)\n\nThese functions are for dealing with human-readable IP addresses and converting them to their binary representation for use with various functions and system calls. The “n” stands for “network”, and “p” for “presentation”. Or “text presentation”. But you can think of it as “printable”. “ntop” is “network to printable”. See?\n\nSometimes you don’t want to look at a pile of binary numbers when looking at an IP address. You want it in a nice printable form, like , or . In that case, is for you.\n\ntakes the address family in the parameter (either or ). The parameter should be a pointer to either a or containing the address you wish to convert to a string. Finally and are the pointer to the destination string and the maximum length of that string.\n\nWhat should the maximum length of the string be? What is the maximum length for IPv4 and IPv6 addresses? Fortunately there are a couple of macros to help you out. The maximum lengths are: and .\n\nOther times, you might have a string containing an IP address in readable form, and you want to pack it into a or a . In that case, the opposite function is what you’re after.\n\nalso takes an address family (either or ) in the parameter. The parameter is a pointer to a string containing the IP address in printable form. Lastly the parameter points to where the result should be stored, which is probably a or .\n\nThese functions don’t do DNS lookups—you’ll need for that.\n\nreturns the parameter on success, or on failure (and is set).\n\nreturns on success. It returns if there was an error ( is set), or if the input isn’t a valid IP address.\n\nTell a socket to listen for incoming connections\n\nYou can take your socket descriptor (made with the system call) and tell it to listen for incoming connections. This is what differentiates the servers from the clients, guys.\n\nThe parameter can mean a couple different things depending on the system you on, but loosely it is how many pending connections you can have before the kernel starts rejecting new ones. So as the new connections come in, you should be quick to them so that the backlog doesn’t fill. Try setting it to 10 or so, and if your clients start getting “Connection refused” under heavy load, set it higher.\n\nBefore calling , your server should call to attach itself to a specific port number. That port number (on the server’s IP address) will be the one that clients connect to.\n\nReturns zero on success, or on error (and will be set accordingly).\n\nSince so many functions return on error and set the value of the variable to be some number, it would sure be nice if you could easily print that in a form that made sense to you.\n\nMercifully, does that. If you want more description to be printed before the error, you can point the parameter to it (or you can leave as and nothing additional will be printed).\n\nIn a nutshell, this function takes values, like , and prints them nicely, like “Connection reset by peer.”\n\nThe function is very similar to , except it returns a pointer to the error message string for a given value (you usually pass in the variable ).\n\nThis function is very similar to in that they both watch sets of file descriptors for events, such as incoming data ready to , socket ready to data to, out-of-band data ready to , errors, etc.\n\nThe basic idea is that you pass an array of s in , along with a timeout in milliseconds (1000 milliseconds in a second). The can be negative if you want to wait forever. If no event happens on any of the socket descriptors by the timeout, will return.\n\nEach element in the array of s represents one socket descriptor, and contains the following fields:\n\nBefore calling , load with the socket descriptor (if you set to a negative number, this is ignored and its field is set to zero) and then construct the field by bitwise-ORing the following macros:\n\nOnce the call returns, the field will be constructed as a bitwise-OR of the above fields, telling you which descriptors actually have had that event occur. Additionally, these other fields might be present:\n\nReturns the number of elements in the array that have had event occur on them; this can be zero if the timeout occurred. Also returns on error (and will be set accordingly).\n\nOnce you have a socket up and connected, you can read incoming data from the remote side using the (for TCP sockets) and (for UDP sockets).\n\nBoth functions take the socket descriptor , a pointer to the buffer , the size (in bytes) of the buffer , and a set of that control how the functions work.\n\nAdditionally, the takes a , that will tell you where the data came from, and will fill in with the size of . (You must also initialize to be the size of or .)\n\nSo what wondrous flags can you pass into this function? Here are some of them, but you should check your local man pages for more information and what is actually supported on your system. You bitwise-or these together, or just set to if you want it to be a regular vanilla .\n\nWhen you call , it will block until there is some data to read. If you want to not block, set the socket to non-blocking or check with or to see if there is incoming data before calling or .\n\nReturns the number of bytes actually received (which might be less than you requested in the parameter), or on error (and will be set accordingly).\n\nIf the remote side has closed the connection, will return . This is the normal method for determining if the remote side has closed the connection. Normality is good, rebel!\n\nCheck if sockets descriptors are ready to read/write\n\nThe function gives you a way to simultaneously check multiple sockets to see if they have data waiting to be d, or if you can data to them without blocking, or if some exception has occurred.\n\nYou populate your sets of socket descriptors using the macros, like , above. Once you have the set, you pass it into the function as one of the following parameters: if you want to know when any of the sockets in the set is ready to data, if any of the sockets is ready to data to, and/or if you need to know when an exception (error) occurs on any of the sockets. Any or all of these parameters can be if you’re not interested in those types of events. After returns, the values in the sets will be changed to show which are ready for reading or writing, and which have exceptions.\n\nThe first parameter, is the highest-numbered socket descriptor (they’re just s, remember?) plus one.\n\nLastly, the , , at the end—this lets you tell how long to check these sets for. It’ll return after the timeout, or when an event occurs, whichever is first. The has two fields: is the number of seconds, to which is added , the number of microseconds (1,000,000 microseconds in a second).\n\nThe helper macros do the following:\n\nNote for Linux users: Linux’s can return “ready-to-read” and then not actually be ready to read, thus causing the subsequent call to block. You can work around this bug by setting flag on the receiving socket so it errors with , then ignoring this error if it occurs. See the man page for more info on setting a socket to non-blocking.\n\nReturns the number of descriptors in the set on success, if the timeout was reached, or on error (and will be set accordingly). Also, the sets are modified to show which sockets are ready.\n\nSockets are fairly configurable beasts. In fact, they are so configurable, I’m not even going to cover it all here. It’s probably system-dependent anyway. But I will talk about the basics.\n\nObviously, these functions get and set certain options on a socket. On a Linux box, all the socket information is in the man page for socket in section 7. (Type: “ ” to get all these goodies.)\n\nAs for parameters, is the socket you’re talking about, level should be set to . Then you set the to the name you’re interested in. Again, see your man page for all the options, but here are some of the most fun ones:\n\nAs for the parameter , it’s usually a pointer to an indicating the value in question. For booleans, zero is false, and non-zero is true. And that’s an absolute fact, unless it’s different on your system. If there is no parameter to be passed, can be .\n\nThe final parameter, , should be set to the length of , probably , but varies depending on the option. Note that in the case of , this is a pointer to a , and it specifies the maximum size object that will be stored in (to prevent buffer overflows). And will modify the value of to reflect the number of bytes actually set.\n\nWarning: on some systems (notably Sun and Windows), the option can be a instead of an , and is set to, for example, a character value of instead of an value of . Again, check your own man pages for more info with “ ” and “ ”!\n\nReturns zero on success, or on error (and will be set accordingly).\n\nThese functions send data to a socket. Generally speaking, is used for TCP connected sockets, and is used for UDP unconnected datagram sockets. With the unconnected sockets, you must specify the destination of a packet each time you send one, and that’s why the last parameters of define where the packet is going.\n\nWith both and , the parameter is the socket, is a pointer to the data you want to send, is the number of bytes you want to send, and allows you to specify more information about how the data is to be sent. Set to zero if you want it to be “normal” data. Here are some of the commonly used flags, but check your local man pages for more details:\n\nReturns the number of bytes actually sent, or on error (and will be set accordingly). Note that the number of bytes actually sent might be less than the number you asked it to send! See the section on handling partial s for a helper function to get around this.\n\nAlso, if the socket has been closed by either side, the process calling will get the signal . (Unless was called with the flag.)\n\nStop further sends and receives on a socket\n\nThat’s it! I’ve had it! No more s are allowed on this socket, but I still want to data on it! Or vice-versa! How can I do this?\n\nWhen you a socket descriptor, it closes both sides of the socket for reading and writing, and frees the socket descriptor. If you just want to close one side or the other, you can use this call.\n\nAs for parameters, is obviously the socket you want to perform this action on, and what action that is can be specified with the parameter. can be to prevent further s, to prohibit further s, or to do both.\n\nNote that doesn’t free up the socket descriptor, so you still have to eventually the socket even if it has been fully shut down.\n\nThis is a rarely used system call.\n\nReturns zero on success, or on error (and will be set accordingly).\n\nReturns a new socket descriptor that you can use to do sockety things with. This is generally the first call in the whopping process of writing a socket program, and you can use the result for subsequent calls to , , , or a variety of other functions.\n\nIn usual usage, you get the values for these parameters from a call to , as shown in the example below. But you can fill them in by hand if you really want to.\n\nThe new socket descriptor to be used in subsequent calls, or on error (and will be set accordingly).\n\nThese are the basic structures for all syscalls and functions that deal with internet addresses. Often you’ll use to fill these structures out, and then will read them when you have to.\n\nIn memory, the and share the same beginning structure as , and you can freely cast the pointer of one type to the other without any harm, except the possible end of the universe.\n\nJust kidding on that end-of-the-universe thing…if the universe does end when you cast a to a , I promise you it’s pure coincidence and you shouldn’t even worry about it.\n\nSo, with that in mind, remember that whenever a function says it takes a you can cast your , , or to that type with ease and safety.\n\nis the structure used with IPv4 addresses (e.g. “192.0.2.10”). It holds an address family ( ), a port in , and an IPv4 address in .\n\nThere’s also this field in which some people claim must be set to zero. Other people don’t claim anything about it (the Linux documentation doesn’t even mention it at all), and setting it to zero doesn’t seem to be actually necessary. So, if you feel like it, set it to zero using .\n\nNow, that is a weird beast on different systems. Sometimes it’s a crazy with all kinds of s and other nonsense. But what you should do is only use the field in this structure, because many systems only implement that one.\n\nand are very similar, except they’re used for IPv6.\n\nis a struct you can pass to or when you’re trying to write IP version-agnostic code and you don’t know if the new address is going to be IPv4 or IPv6. The structure is large enough to hold both types, unlike the original small .\n\nYou’ve come this far, and now you’re screaming for more! Where else can you go to learn more about all this stuff?\n\nFor old-school actual hold-it-in-your-hand pulp paper books, try some of the following excellent books. These redirect to affiliate links with a popular bookseller, giving me nice kickbacks. If you’re merely feeling generous, you can paypal a donation to .\n\nUnix Network Programming, volumes 1-2 by W. Richard Stevens. Published by Addison-Wesley Professional and Prentice Hall. ISBNs for volumes 1-2: 978-0131411555 , 978-0130810816 .\n\nInternetworking with TCP/IP, volume I by Douglas E. Comer. Published by Pearson. ISBN 978-0136085300 .\n\nTCP/IP Illustrated, volumes 1-3 by W. Richard Stevens and Gary R. Wright. Published by Addison Wesley. ISBNs for volumes 1, 2, and 3 (and a 3-volume set): 978-0201633467 , 978-0201633542 , 978-0201634952 , (978-0201776317 ).\n\nTCP/IP Network Administration by Craig Hunt. Published by O’Reilly & Associates, Inc. ISBN 978-0596002978 .\n\nAdvanced Programming in the UNIX Environment by W. Richard Stevens. Published by Addison Wesley. ISBN 978-0321637734 .\n\nAnd here are some relevant Wikipedia pages:\n\nRFCs —the real dirt! These are documents that describe assigned numbers, programming APIs, and protocols that are used on the Internet. I’ve included links to a few of them here for your enjoyment, so grab a bucket of popcorn and put on your thinking cap:\n\nRFC 1 —The First RFC; this gives you an idea of what the “Internet” was like just as it was coming to life, and an insight into how it was being designed from the ground up. (This RFC is completely obsolete, obviously!)\n\nThe IETF has a nice online tool for searching and browsing RFCs ."
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/009696799/functions/htonl.html",
        "document": "The uint32_t and uint16_t types are defined in <inttypes.h> .\n\nOn some implementations, these functions are defined as macros.\n\nThese functions shall convert 16-bit and 32-bit quantities between network byte order and host byte order.\n\nThe htonl() and htons() functions shall return the argument value converted from host to network byte order.\n\nThe ntohl() and ntohs() functions shall return the argument value converted from network to host byte order."
    },
    {
        "link": "https://stackoverflow.com/questions/19207745/htons-function-in-socket-programing",
        "document": "It has to do with the order in which bytes are stored in memory. The decimal number is in hexadecimal, so the bytes involved are and . Many devices store numbers in little-endian format, meaning that the least significant byte comes first. So in this particular example it means that in memory the number will be stored as\n\nThe function makes sure that numbers are stored in memory in network byte order, which is with the most significant byte first. It will therefore swap the bytes making up the number so that in memory the bytes will be stored in the order\n\nOn a little-endian machine, the number with the swapped bytes is in hexadecimal, which is in decimal notation. Note that if you were working on a big-endian machine, the function would not need to do any swapping since the number would already be stored in the right way in memory.\n\nThe underlying reason for all this swapping has to do with the network protocols in use, which require the transmitted packets to use network byte order."
    },
    {
        "link": "http://qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.lib_ref/topic/h/htons.html",
        "document": "You must enable javascript in order to view this page or you can go here to view the webhelp."
    }
]