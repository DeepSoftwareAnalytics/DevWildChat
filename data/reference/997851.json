[
    {
        "link": "https://packaging.python.org/tutorials/installing-packages",
        "document": "This section covers the basics of how to install Python packages.\n\nIt’s important to note that the term “package” in this context is being used to describe a bundle of software to be installed (i.e. as a synonym for a distribution). It does not refer to the kind of package that you import in your Python source code (i.e. a container of modules). It is common in the Python community to refer to a distribution using the term “package”. Using the term “distribution” is often not preferred, because it can easily be confused with a Linux distribution, or another larger software distribution like Python itself.\n\nThis section describes the steps to follow before installing other Python packages. Ensure you can run Python from the command line¶ Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running: You should get some output like . If you do not have Python, please install the latest 3.x version from python.org or refer to the Installing Python section of the Hitchhiker’s Guide to Python. If you’re a newcomer and you get an error like this: File , line , in : name 'python3' is not defined It’s because this command and other suggested commands in this tutorial are intended to be run in a shell (also called a terminal or console). See the Python for Beginners getting started tutorial for an introduction to using your operating system’s shell and interacting with Python. If you’re using an enhanced shell like IPython or the Jupyter notebook, you can run system commands like those in this tutorial by prefacing them with a character: It’s recommended to write rather than plain in order to ensure that commands are run in the Python installation matching the currently running notebook (which may not be the same Python installation that the command refers to). Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the command in this tutorial with and the command with . Do not run any of the commands in this tutorial with : if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written. Ensure you can run pip from the command line¶ Additionally, you’ll need to make sure you have pip available. You can check this by running: If you installed Python from source, with an installer from python.org, or via Homebrew you should already have pip. If you’re on Linux and installed using your OS package manager, you may have to install pip separately, see Installing pip/setuptools/wheel with Linux Package Managers. If isn’t already installed, then first try to bootstrap it from the standard library: If that still doesn’t allow you to run :\n• None Run . This will install or upgrade pip. Additionally, it will install Setuptools and wheel if they’re not installed already. Be cautious if you’re using a Python install that’s managed by your operating system or another package manager. get-pip.py does not coordinate with those tools, and may leave your system in an inconsistent state. You can use to install in which is designed for locally-installed software. See section below for details, but here’s the basic venv command to use on a typical Linux system: This will create a new virtual environment in the subdirectory, and configure the current shell to use it as the default environment.\n\nPython “Virtual Environments” allow Python packages to be installed in an isolated location for a particular application, rather than being installed globally. If you are looking to safely install global command line tools, see Installing stand alone command line tools. Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded. Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application. Also, what if you can’t install packages into the global site-packages directory? For instance, on a shared host. In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments. Currently, there are two common tools for creating Python virtual environments:\n• None venv is available by default in Python 3.3 and later, and installs pip into created virtual environments in Python 3.4 and later (Python versions prior to 3.12 also installed Setuptools).\n• None virtualenv needs to be installed separately, but supports Python 2.7+ and Python 3.3+, and pip, Setuptools and wheel are always installed into created virtual environments by default (regardless of Python version). The basic usage is like so: For more information, see the venv docs or the virtualenv docs. The use of source under Unix shells ensures that the virtual environment’s variables are set within the current shell, and not in a subprocess (which then disappears, having no useful effect). In both of the above cases, Windows users should not use the source command, but should rather run the activate script directly from the command shell like so: Managing multiple virtual environments directly can become tedious, so the dependency management tutorial introduces a higher level tool, Pipenv, that automatically manages a separate virtual environment for each project and application that you work on.\n\nThe most common usage of pip is to install from the Python Package Index using a requirement specifier. Generally speaking, a requirement specifier is composed of a project name followed by an optional version specifier. A full description of the supported specifiers can be found in the Version specifier specification. Below are some examples. To install the latest version of “SomeProject”: To install greater than or equal to one version and less than another: To install a version that’s compatible with a certain version: In this case, this means to install any version “==1.4.*” version that’s also “>=1.4.2”.\n\npip can install from either Source Distributions (sdist) or Wheels, but if both are present on PyPI, pip will prefer a compatible wheel. You can override pip`s default behavior by e.g. using its –no-binary option. Wheels are a pre-built distribution format that provides faster installation compared to Source Distributions (sdist), especially when a project contains compiled extensions. If pip does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future.\n\nTo install packages that are isolated to the current user, use the flag: For more information see the User Installs section from the pip docs. Note that the flag has no effect when inside a virtual environment - all installation commands will affect the virtual environment. If defines any command-line scripts or console entry points, will cause them to be installed inside the user base’s binary directory, which may or may not already be present in your shell’s . (Starting in version 10, pip displays a warning when installing any scripts to a directory outside .) If the scripts are not available in your shell after installation, you’ll need to add the directory to your :\n• None On Linux and macOS you can find the user base binary directory by running and adding to the end. For example, this will typically print (with expanded to the absolute path to your home directory) so you’ll need to add to your . You can set your permanently by modifying ~/.profile.\n• None On Windows you can find the user base binary directory by running and replacing with . For example, this could return so you would need to set your to include . You can set your user permanently in the Control Panel. You may need to log out for the changes to take effect."
    },
    {
        "link": "https://activestate.com/resources/quick-reads/how-to-install-and-use-pip3",
        "document": "Pip3 is the official package manager and pip command for Python 3. It enables the installation and management of third party software packages with features and functionality not found in the Python standard library. Pip3 installs packages from PyPI (Python Package Index), but won’t resolve dependencies or help you solve dependency conflicts.The ActiveState Platform’s command line interface, the State Tool will automatically resolve dependencies for you to ensure your Python environment won’t be corrupted by installing incompatible dependencies.\n\npip3 is the official package manager and pip command for Python 3. It enables the installation and management of third party software packages with features and functionality not found in the Python standard library. Pip3 installs packages from PyPI (Python Package Index).\n\n\n\nCheck if pip3 is already installed by entering the following command in a terminal or command line:\n\nOutput should be similar to:\n\nYou can also check to see which version of pip3 is installed by entering:\n\nOutput should be similar to:\n\nConfirm which version of Python (if any) is installed on your computer by entering:\n\nOutput should be similar to:\n\nPython 3.4+ in most operating systems includes pip3 by default. If your python version is less than 3.4, then you should upgrade your Python version which will automatically install pip3.\n\nFor example, you can install the latest version of Python from ActiveState (Python 3.9), which includes pip3.\n\nIn operating system environments that already have Python 3 and pip3 installations, you can upgrade pip3, by entering:\n\nYou can downgrade to a previous version of pip3, in case a newer version is causing unexpected compatibility errors. For example, to downgrade to pip3 v19.0 run the following command:\n\nPip3 Virtualenv and Venv\n\nWhen pip3 is used in a virtual environment, it will generally install packages in a path similar to:\n\nCaution: \n\nLinux and MacOS have system Python, that you should leave alone if possible. System Python is configured to help the operating system work as intended.\n\nUbuntu 18.04 has both Python 2 and Python 3 installed by default, and hence has two pip variants for each Python version. ‘pip’, refers to Python 2. pip3 refers to Python 3.\n\nUbuntu 20.4 has only Python 3, but still requires a separate python-pip 3 installation.\n\nProcedure for installing pip3 on Ubuntu and Debian Linux:\n\nEnter the following command to update Linux:\n\nEnter the following command to install pip3:\n\nThe above command will also install all pip3 dependencies.\n\nTo find the location where pip3 installs packages in Ubuntu Linux, enter:\n\nOutput should be similar to:\n\nTo install or upgrade pip3 in a Windows environment that already has Python 3 installed:\n\nDownload the latest version of get-pip.py from\n\nYou can also use the curl command to download get-pip.py:\n\nCD into the directory where get-pip.py was downloaded to, and enter the following command to install pip3 and its dependencies:\n\nYou can verify that pip3 is installed by navigating to the default pip3 installation directory, eg. C:\\python38\\scripts\\, and enter:\n\nA common problem with running Python tools such as pip3 in Windows, is not having it in the environment path so that you can access it from anywhere. In most cases, you can navigate to the default <python_dir>/scripts directory in which the tool is installed in order to run it.\n\nTo run pip3 from any location, you need to add the directory in which it is installed in, as a System PATH environment variable:\n• Open the Control Panel and navigate to System.\n• Click on Advanced system settings in the upper left panel.\n• Under System Variables, scroll down then double-click the PATH variable.\n• Click New, and add the directory where pip3 is installed,\n\ne.g.C:\\Python38\\Scripts , and select OK.\n\nFigure 1: Environment Variables: Directory where pip3 is installed:\n\n\n\nTo install pip3 in a MacOS environment that already has Python 3 installed, enter:\n\nsudo apt install python3-pip \n\nTo install pip3 using the Homebrew package manager (if it is installed), enter:\n\nYou can also install pip3 using get-pip.py:\n• Download the latest version of get-pip.py from https://bootstrap.pypa.io/.\n• CD into the download directory, and enter the following command:\n\nget-pip.py will install pip3 for the python version which runs the script.\n\nPip3 has limited use in the Conda environment compared to other operating system environments.\n\nConda has many of the features found in pip3, but is otherwise a completely separate tool. It installs python modules and packages from the Anaconda Repository. Only after Conda has been used to install as many packages as possible in a project, should pip3 be used to install any remaining software.\n\nIt depends on whether you are familiar with pip3 and Conda, and with how package installations interact between the two methods. If you are relatively new to Conda and Python, then only use Conda to install packages in Conda environments. Otherwise pip3 can be used to install packages not found in the Anaconda Repository. Extra care needs to be taken with pip3 dependencies so that they do not conflict with Conda packages and dependencies.\n\nIf Python 3 and pip3 are installed outside of the Conda environment, then you can run pip3 from an Anaconda prompt just as you would from a Linux or Windows terminal or command line."
    },
    {
        "link": "https://docs.python.org/3/installing/index.html",
        "document": "As a popular open source development project, Python has an active supporting community of contributors and users that also make their software available for other Python developers to use under open source license terms.\n\nThis allows Python users to share and collaborate effectively, benefiting from the solutions others have already created to common (and sometimes even rare!) problems, as well as potentially contributing their own solutions to the common pool.\n\nThis guide covers the installation part of the process. For a guide to creating and sharing your own Python projects, refer to the Python packaging user guide.\n• None is the preferred installer program. Starting with Python 3.4, it is included by default with the Python binary installers.\n• None A virtual environment is a semi-isolated Python environment that allows packages to be installed for use by a particular application, rather than being installed system wide.\n• None is the standard tool for creating virtual environments, and has been part of Python since Python 3.3. Starting with Python 3.4, it defaults to installing into all created virtual environments.\n• None is a third party alternative (and predecessor) to . It allows virtual environments to be used on versions of Python prior to 3.4, which either don’t provide at all, or aren’t able to automatically install into created environments.\n• None The Python Package Index is a public repository of open source licensed packages made available for use by other Python users.\n• None the Python Packaging Authority is the group of developers and documentation authors responsible for the maintenance and evolution of the standard packaging tools and the associated metadata and file format standards. They maintain a variety of tools, documentation, and issue trackers on GitHub.\n• None is the original build and distribution system first added to the Python standard library in 1998. While direct use of is being phased out, it still laid the foundation for the current packaging and distribution infrastructure, and it not only remains part of the standard library, but its name lives on in other ways (such as the name of the mailing list used to coordinate Python packaging standards development). Changed in version 3.5: The use of is now recommended for creating virtual environments.\n\nThe standard packaging tools are all designed to be used from the command line. The following command will install the latest version of a module and its dependencies from the Python Package Index: For POSIX users (including macOS and Linux users), the examples in this guide assume the use of a virtual environment. For Windows users, the examples in this guide assume that the option to adjust the system PATH environment variable was selected when installing Python. It’s also possible to specify an exact or minimum version directly on the command line. When using comparator operators such as , or some other special character which get interpreted by shell, the package name and the version should be enclosed within double quotes: Normally, if a suitable module is already installed, attempting to install it again will have no effect. Upgrading existing modules must be requested explicitly: More information and resources regarding and its capabilities can be found in the Python Packaging User Guide. Creation of virtual environments is done through the module. Installing packages into an active virtual environment uses the commands shown above.\n\nThese are quick answers or links for some common tasks. … install in versions of Python prior to Python 3.4?¶ Python only started bundling with Python 3.4. For earlier versions, needs to be “bootstrapped” as described in the Python Packaging User Guide. … install packages just for the current user?¶ Passing the option to will install a package just for the current user, rather than for all users of the system. A number of scientific Python packages have complex binary dependencies, and aren’t currently easy to install using directly. At this point in time, it will often be easier for users to install these packages by other means rather than attempting to install them with . … work with multiple versions of Python installed in parallel?¶ On Linux, macOS, and other POSIX systems, use the versioned Python commands in combination with the switch to run the appropriate copy of : Appropriately versioned commands may also be available. On Windows, use the Python launcher in combination with the switch:"
    },
    {
        "link": "https://help.dreamhost.com/hc/en-us/articles/115000699011-Using-pip3-to-install-Python3-modules",
        "document": "This article explains how to use pip3 to install Python modules.\n\nTo run the following commands, you must log in to your server via SSH with your Shell user. View the following articles for more information:\n\nHow to use pip3\n\nBefore you install any modules, you need to make sure that pip3 is installed. The following sections provide more information about how to install, activate, and upgrade pip3.\n\nWhen you use a custom version of Python 3, pip3 is already installed. You can visit this page if you need to find additional ways to install it separately.\n\nAfter it's installed, run the following to activate your local Python environment: You now have access to pip3. Confirm this by running the following:\n\nWhen working with Python projects, it's recommended to create a virtual environment. This allows you to create an isolated environment, separate from the system version of Python. Any changes you make to this virtual environment only affect the single project and nothing else. In this way, it's a very safe way to test your projects, as they can be deleted and rebuilt very easily. See this article for further details. Installing a virtual environment is important if you want to run pip. Normally, pip attempts to install in the server's default Python system folder. This does not work since you do not have access to this folder. When you create a virtual environment, pip installs locally under your user, so you'll be able to install anything you like without any errors occurring. To use pip3 to easily install custom modules:\n• Make sure you're in the same directory as the virtual environment you created.\n• Run the following command to activate this new virtual environment. Make sure to change the directory to where you installed it. The following example assumes the name of your virtual environment is venv. The name of the current virtual environment appears to the left of the prompt. For example:\n• Use to install a module: For example, you can use if you're going to work with Openstack. View the following links for further module examples:"
    },
    {
        "link": "https://stackoverflow.com/questions/40832533/pip-or-pip3-to-install-packages-for-python-3",
        "document": "I have a Macbook with OS X El Captain. I think that Python 2.7 comes preinstalled on it. However, I installed Python 3.5 too. When I started using Python 3, I read that if I want to install a package, I should type:\n\nAnyway, now when I use\n\nI get installed for Python 3. I mean I can import it and use it without problems. Moreover, when I type just in the Terminal. I got this message about the usage:\n\nwhich is the same message I get when I type just .\n\nDoes it mean that in previous versions, things were different, and now and can be used interchangeably? If so, and for the sake of argument, how can I install packages for Python 2 instead of Python 3?"
    },
    {
        "link": "https://pypi.org/project/orchestra",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://orchestra.readthedocs.io/en/latest/getting_started.html",
        "document": "What follows is a simple 5-minute guide to getting up and running with Orchestra that assumes some basic Python and Django experience, but not much else. For a deeper introduction, you might want to check out our Key Concepts, and for in-depth information on using and developing with Orchestra, take a look at our API documentation.\n\nOrchestra requires a number of Python dependencies to run. You can install them by simply pulling down and installing our requirements.txt file:\n\nOrchestra requires Python 3 and Django version 1.11 or higher to run, so make sure you have them installed . We recommend setting up a virtual environment to isolate your Python dependencies, and we’re fond of virtualenvwrapper to make that process easier. Make sure to create your virual environment with Python 3 by passing --python=/path/to/bin/python3 if it isn’t your default development setup.\n\nOrchestra is a Django app, which means that it must be run within a Django project (for more details, read the Django tutorial on this topic). Start a project with django-admin startproject your_project , replacing your_project with your favorite project name (but don’t name it orchestra , which will conflict with our namespace). From here on out, this document will assume that you stuck with your_project , and you should replace it appropriately.\n\nNext, let’s get Orchestra installed and running. To get the code, just install using pip: .\n\nOrchestra has a number of custom settings that require configuration before use. First, download the default Orchestra settings file and place it next to the project settings file:\n• None Add to in the “General” section if you want to run the demo workflow (instructions below), and add if you want to run the journalism workflow.\n• None Adjust your email settings. By default, Orchestra will direct all messages to the console, but for a realistic registration workflow you’ll want to set up a real mail server that can actually send emails.\n• None Change settings like the from to more appropriate values.\n• None Optionally, add 3rd party credentials in the “3rd Party Integrations” section so that Orchestra can store files on Amazon S3, use Google Apps and Slack to help communicate with expert workers, and track usage in Google Analytics.\n\nThen, at the bottom of your existing settings file ( ), import the Orchestra settings:\n\nYou’ll also need to set up Orchestra’s URLs, so that Django knows where to route users when they view Orchestra in the browser. If you don’t have any URLs of your own yet, you can just download our barebones example file with .\n\nAlternatively, make sure to add the following code inside the variable in :\n\nAnd ensure the following imports are at the top of your :\n\nFinally, you’ll need to get the database set up. Create your database with . You’ll also want to make sure you have loaded our example workflows and set up some user accounts to try them out. To load the workflows, run:\n\nIf you would like to load all of the workflows, then run:\n\nThe example workflows we currently release with Orchestra are:\n• None A simple demo workflow with one human and one machine step. Its app label is , its workflow slug is , and the latest version is .\n• None A more complicated journalism workflow. Its app label is , its workflow slug is , and the latest version is .\n\nEach of our example workflows provides a set of sample users already configured with proper certifications. To load them, run:\n\nTo load sample data for both of these workflows, run:\n\nIn addition, you can use the Orchestra admin (http://127.0.0.1:8000/orchestra/admin) to create new users and certifications of your own at any time once Orchestra is running. If you haven’t created an admin account for your Django project, you can load a sample one (username: , password: ) with . Note that when you log into Django with the account, you will see errors related to the Orchesta timer. This is because the admin user is not a Worker on the platform, and thus has no time-tracking information.\n\nWe provide the option to use the third-party package django-hijack to act on behalf of users. To enable this setting, ensure that the following setting is set , in addition to including the urls referenced above.\n\nNow Orchestra should be ready to go! If you’re confused about any of the above, check out our barebones example project."
    },
    {
        "link": "https://pypi.org/project/red",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://wiki.tripwireinteractive.com/index.php/Red_Orchestra_2_(modding)",
        "document": "To obtain the Red Orchestra 2: Heroes of Stalingrad (RO2) Software Development Kit (SDK), users will need to:\n• Launch Steam while logged into an account that owns RO 2 (and has it installed)\n• Navigate to the Library page on Steam\n• Select \"Tools\" from the drop down box above the accounts owned game titles\n\nThis will download the all the files necessary to run the SDK to the clients machine. To launch the SDK users will need to follow the same steps. However since the SDK is already downloaded to the clients machine it will now launch instead. The minimum requirements to run the SDK for content creation (Level Design) are as follows:\n\nHere follows a list of topics that one should be familiar with before trying to attempt any modding."
    },
    {
        "link": "https://socket.dev/pypi/package/orchestra-sdk",
        "document": "Socket, the leader in open source security, is now available on Google Cloud Marketplace for simplified procurement and enhanced protection against supply chain attacks."
    },
    {
        "link": "https://docs.xenserver.com/en-us/xenserver/developer/sdk-guide/python.html",
        "document": "The directory contains the following folders that are relevant to Python developers:\n• : This directory contains the XenServer Python module XenAPI.py.\n• The XenServer 8.4 SDK (version 24.32.0 and later) supports only Python 3.\n\nThe Python module is also available as a package on PyPi. To install the package, enable the virtual environment where it will be used and run\n\nExamples on the usage of the XenServer Powershell module can be found at XenAPI.py usage examples on GitHub."
    },
    {
        "link": "https://docs.xenserver.com/en-us/xenserver/developer/sdk-guide.html",
        "document": "Welcome to the developer’s guide for XenServer. Here you will find the information you need in order to understand and use the Software Development Kit (SDK) that XenServer provides. This information will provide you with some of the architectural background and thinking that underpins the APIs, the tools that have been provided, and how to quickly get off the ground.\n\nXenServer includes a Remote Procedure Call (RPC) based API providing programmatic access to the extensive set of XenServer management features and tools. You can call the XenServer Management API from a remote system or from local to the XenServer host.\n\nIt’s possible to write applications that use the XenServer Management API directly through raw RPC calls. However, the task of developing third-party applications is greatly simplified by using a language binding. These language bindings expose the individual API calls as first-class functions in the target language. The XenServer SDK provides language bindings for the C, C#, Go, Java, Python, and PowerShell programming languages.\n\nThe first step towards using the SDK is to install XenServer. XenServer is available for download at https://www.xenserver.com/downloads. For detailed instructions on how to set up your development host, see the Install XenServer.\n\nWhen the installation is complete, note the host IP address and the host password.\n\nThe SDK is packaged as a ZIP file and is available as a free download from https://www.xenserver.com/downloads.\n\nThe Python module is also available as a package on PyPi. See section SDK Languages - Python for details.\n\nThe extracted contents of the SDK ZIP file are in the directory. Where necessary, subdirectories have their own individual README files.\n\nThe contents of the SDK ZIP consist of library binaries and their source code. Previous releases of the SDK ZIP included a number of examples for each of the SDK languages to help you get started with the SDK. These examples have now been removed from the SDK ZIP and are available at XenServer SDK usage examples on GitHub. The examples provided aren’t the same across all the SDK languages. If you intend to use one language, it’s advisable to browse the sample code available in the others as well.\n\nThe top level of the directory includes the XenServer Management API Reference document. This document provides an overview of the API types and classes.\n\nThe API supports two wire formats, one based upon XML-RPC and one based upon JSON-RPC (v1.0 and v2.0 are both recognised). For more information on the API semantics and the wire protocol of the RPC messages, see section XenServer Management API. The format supported by each of the SDK languages is specified in the following paragraphs.\n\nThe XenServer SDK provides support for the following languages:\n\nBesides using raw RPC or one of the supplied SDK languages, third-party software developers can integrate with XenServer hosts by using the xe command line interface . The xe CLI is installed by default on XenServer hosts. A stand-alone remote CLI is also available for Linux. On Windows, the CLI executable is installed along with XenCenter.\n\nThe CLI allows almost every API call to be directly invoked from a script or other program, silently taking care of the required session management. The xe CLI syntax and capabilities are described in detail in the Command line interface documentation."
    },
    {
        "link": "https://wiki.xenproject.org/wiki/Xen_Project_Beginners_Guide",
        "document": "This guide was written to introduce beginners to basic Xen Project concepts and allow you to get started with Xen Project with no prior knowledge. Some prior Linux experience is required however, and some knowledge of networking, lvm and grub will go a long way! You will need to use root-level access at various points, so some experience with that (likely through sudo) is necessary.\n\nBy completing this guide you will have installed a fully functional Xen Project hypervisor and started your first guest operating systems, connected them to your network and have been introduced to fundamental concepts such as virtual machine storage and virtual networking.\n\nTo make this process easy we will be using a Linux distribution called Debian. This document was originally written for use with Debian 6/7 (called \"Squeeze\" and “Wheezy”) and has been tested with newer releases through Debian 10 (\"Buster\"). It should continue work with future releases as well. Debian ships with support for Xen Project release 4.x, providing everything you need to get started!\n\nThough this guide looks long at first, don’t let it daunt you. It is very in-depth and comprehensive, and doesn’t expect you to know all that much beforehand. The goal instead is to teach you all the things you need to know to build a functioning Xen Project Hypervisor. :)\n\nWhat is this Xen Project software all about?\n\nXen Project creates a Virtual Machine Monitor (VMM) also known as a hypervisor: a software system that allows the execution of multiple virtual guest operating systems simultaneously on a single physical machine. In particular, the project creates a Type 1 or “bare-metal” hypervisor, meaning that it runs directly on top of the physical machine as opposed to within an operating system.\n\nGuest virtual machines running on a Xen Project Hypervisor are known as “domains”. A special domain known as domain0 (or dom0) is responsible for controlling the hypervisor and starting other guest operating systems. These other guest operating systems are called domUs. This is because these domains are “unprivileged” in the sense they cannot control the hypervisor or start/stop other domains.\n\nOur hypervisor supports two primary types of virtualization: paravirtualization (PV) and hardware virtualized machine (HVM) also known as “full virtualization”. Paravirtualization uses modified guest operating systems that we refer to as \"enlightened\" guests. These operating systems are aware that they are being virtualized and as such don’t require virtual hardware devices. Instead they make special calls to the hypervisor that allow them to access CPUs, storage and network resources.\n\nIn contrast, HVM guests need not be modified, as the hypervisor will create a fully virtual set of hardware devices for the machine resembling a physical x86 computer. This emulation requires more overhead than the paravirtualization approach but allows unmodified guest operating systems like Microsoft Windows to run on top of the hypervisor. HVMs are supported through virtualization extensions in the CPU. Several iterations of these extensions have been introduced in the last decade or so, collectively known as Intel VT and AMD-V and development continues. The technology is now prevalent; all recent servers, many desktops and some mobile systems should be equipped with at least some extensions.\n\nXen virtualization is now seen as on a spectrum, with PV at one end and HVM at the other. In between are various enhancements to improve performance: HVM with PV drivers, PVHVM or “Paravirtualization on HVM”, and most recently PVH. Each strives to provide the best of both worlds by reducing expensive emulation. To keep things simple for the purposes of this guide, we will create a generic PV guest and optionally, an HVM guest. For a closer look at how the various modes (PV, HVM, PVHVM, PVH etc.) fit into the picture, see\n\nA brief look at Xen Project architecture\n\nTo understand how storage, networking and other resources are delivered to guest systems we need to quickly delve into how the different bits of the software interact.\n\nThis is the basic architecture of the Xen Project Hypervisor. We see that the hypervisor sits on the bare metal (the actual computer hardware). The guest VMs all sit on the hypervisor layer, as does dom0, the \"Control Domain\". The Control Domain is a VM like the guest VMs, except that it has two basic functional differences:\n\n1. The Control Domain has the ability to talk to the hypervisor to instruct it to start and stop guest VMs.\n\n2. The Control Domain by default contains the device drivers needed to address the hardware. This stops the problem that often plagued Linux users in the 1990s: You install your software on a new piece of hardware, only to find that you lack the drivers to use it. Since those early days, Linux and the BSDs have become quite good at supporting more pieces of hardware fairly quickly after they are birthed. Xen Project leverages that support by using the drivers in the Control Domain's operating system to access many types of hardware.\n\n\n\n Dom0 forms the interface to the hypervisor. Through special instructions dom0 communicates to the Xen Project software and changes the configuration of the hypervisor. This includes instantiating new domains and related tasks.\n\nAnother crucial part of dom0’s role is as the primary interface to the hardware. The hypervisor doesn’t contain device drivers. Instead the devices are attached to dom0 and use standard Linux drivers. Dom0 then shares these resources with guest operating systems.\n\nTo implement paravirtualization, each paravirtualized datapath consists of two parts: 1) a “backend” that lives in dom0, which provides the virtual device and 2) a “frontend” driver within the guest domain, which allows the guest OS to access the virtual device. The backend and frontend use a high-speed software interface based on shared memory to transfer data between the guest and dom0.\n\nThe two important paravirtualized datapaths are: net-back/net-front, and blk-back/blk-front - which are the paravirtualized networking and storage systems, respectively. There are also paravirtualized interrupts, timers, page-tables and more.\n\nYou can read more about how the Xen Project system is architected, paravirtualization and the benefits of such here:\n• Details of Paravirtualization (PV) and how it is used on Xen Project\n\nIn the case of HVM guests, dom0 uses hardware virtualization extensions provided by the CPU. The most basic of these is virtualization of the CPU itself. Support was later added for page-table management (MMU) and I/O virtualization (IOMMU). Dom0 also emulates some hardware using components of qemu (the Quick Emulator). Emulation in software requires the most overhead, however, so performance is reduced.\n\nThis guide requires a number of items, this checklist is what you will need:\n• 64bit x86 computer with at least 1GB of RAM (this can be a server, desktop or laptop)\n• Intel VT or AMD-V support (optional for PV, required for HVM and some PV optimizations)\n• Sufficient storage space for your dom0 and whatever guests you want to install\n• A CD/DVD burner + blank CD/DVD (you can use USB but that's not covered here - see the Debian site for details)\n• Internet access and some way to download Debian and burn it to the CD/DVD (e.g. another computer)\n• installation ISO for a licensed copy of Windows or a trial copy of Windows Server 2008R2 (only if you want a Windows HVM)\n\nA word about VT/AMD-V: If you want to be sure you can use the hardware extensions, it is important to check that both the CPU chipset and the motherboard support virtualization. It is quite possible to have virtualization features in the chipset that cannot be enabled because the mobo isn't designed for it. Also, if you plan to use an HVM instance for more that demonstration purposes, the underlying hardware should support at least VT-d and VT-i or AMD-V and AMD-Vi. Having said all of that, sometimes the easiest (or only way) to see what is supported is to check the BIOS.\n\nNOTE: This is not strictly required for PV guests. However, it is highly recommended so that you have the widest number of options for virtualization modes once you get underway.\n\nIn order to support HVM guests we need to ensure that virtualization extensions are enabled in the BIOS. If you find your system doesn’t support these extensions you cannot use the hypervisor to virtualize unmodified operating systems. Paravirtualization will work fine though.\n\nThe virtualization options appear differently in different BIOS builds but often are referred to as “Enable Intel VT” for Intel chipsets, \"Enable AMD-V\" for AMD or simply “Enable Virtualization Technology”. Oftentimes this option can be found under the “Advanced Chipset Features” menu in the BIOS or by using Search if the BIOS supports that. It is worthwhile digging around on this a bit. The options may be specified individually, for example: VT-x and VT-d or AMD-V and AMD-IOMMU (aka AMD-Vi or AMD-RVI). You may even find one is enabled by default but the other is not!\n\nConsult your motherboard documentation for more assistance in enabling virtualization extensions on your system.\n\nYou can find the most recent Debian ISO images at this URL:\n\nThe netinst image is sufficient for our purposes.\n\nBurn the ISO to disk using your computer's standard utilities. Linux has wodim (among others) or use the built in ISO burning feature in Windows.\n\nDebian is a simple, stable and well supported Linux distribution. It has included Xen Project Hypervisor support since Debian 3.1 “Sarge” released in 2005.\n\nDebian uses the simple Apt package management system which is both powerful and simple to use. Installing a package is as simple as the following example:\n\nwhere htop is the application desired to install.\n\nSimple tasks such as configuring startup scripts, setting up the network etc are covered by this tutorial so don’t worry if you haven’t used Debian before!\n\nMany popular distributions are based off of Debian and also use the Apt package manager, if you have used Ubuntu, Linux Mint or Damn Small Linux you will feel right at home.\n\nInsert the Debian CD/DVD and configure the CDROM drive as your default boot device in the BIOS or use the system boot menu if your BIOS supports it (usually F12).\n\nYou should see a menu, choose the default “Install” option to begin the installation process. Install the system The Debian installer is very straight forward. Follow the prompts until you reach the disk partitioning section.\n\nChoose advanced/custom, we are going to configure a few partitions here, one for /boot another for /, one more for swap and a final partition to setup as an LVM volume group for our guest machines.\n\nFirst create the /boot partition by choosing the disk and hitting enter, make the partition 300MB and format it as ext2, choose /boot as the mountpoint.\n\nRepeat the process for / but of course changing the mountpoint to / and making it 15GB or so large. Format it as ext3.\n\nCreate another partition approximately 1.5x the amount of RAM you have in size and elect to have it used as a swap volume.\n\nFinally create a partition that consumes the rest of the diskspace but don’t format it or assign a mount point.\n\nWe should now have a layout that looks like this assuming your disk device is /dev/sda :\n\nWhen you reach the package selection stage only install the base system. We won’t require any GUI or other packages for this guide. (If you want to set up a graphical desktop environment in dom0, that's not a problem, but you may want to wait until after you've completed this guide to avoid complicating things.)\n\nYou can find out details of the Debian installation process from the Debian documentation.\n\nContinue through the installer then reboot and login at the prompt as root.\n\nIf you've got any hardware you're not sure open source drivers are available for, you may want to install non-free firmware files via:\n\nIf this does not work straight away make sure your has entries including and perhaps while you're at it, e.g. like this:\n\nAdd the same to and the lines (changing 'stretch' to the name of the current Debian release if you're using some newer release).\n\nWe've still got a few more steps to complete before we're ready to launch a domU, but let's install the Xen Project software now and use it to check the BIOS settings.\n\nThe Debian Xen Project packages consist primarily of a Xen Project-enabled Linux kernel, the hypervisor itself, a modified version of QEMU that support the hypervisor’s HVM mode and a set of userland tools.\n\nAll of this can be installed via an Apt meta-package called xen-linux-system. A meta-package is basically a way of installing a group of packages automatically. Apt will of course resolve all dependencies and bring in all the extra libraries we need.\n\nNow we have a Xen Project hypervisor, a Xen Project kernel and the userland tools installed. When you next boot the system, the boot menu should include entries for starting Debian with the Xen hypervisor. One of them should be highlighted, to start Xen by default. Do that now, logging in as root again.\n\nNext, let's check to see if virtualization is enabled in the BIOS. There are a few ways to do that.\n\nThe most comprehensive is to review the Xen section of dmesg created during the boot process. This will be your first use of xl, the very versatile Xen tool, which we will come back to shortly to create and manage domUs:\n\nIncluded in the output will be references to the CPU flags set in the BIOS to enable virtualization: 'vmx' for Intel, 'svm' for AMD. It will also detail other hardware virtualization extensions: VT-d features, Hardware Assisted Paging (HAP), I/O Virtualization and so on.\n\nAnother way is to check the flags set in the CPU on boot:\n\negrep will return any line containing one or more of those same text fragments (vmx/svm or more recently, just 'hypervisor'). If nothing comes back and you think it should, you may wish to look through the flags yourself:\n\nIf the virtualization extensions don't appear, take a closer look at the BIOS settings. A few round-trips through the BIOS are often required to get all the bits working right.\n\nLVM is the Linux Logical Volume Manager. It is a technology that allows Linux to manage block devices in a more abstract manner.\n\nLVM introduces the concept of a “logical volume”, effectively a virtualized block device composed of blocks written to one or more physical devices. Unlike proper disk partitions, these blocks don’t need to be contiguous.\n\nBecause of this abstraction logical volumes can be created, deleted, resized and even snapshotted without affecting other logical volumes.\n\nLVM creates logical volumes within what is called a volume group, which is simply a set of logical volumes that share the same physical storage, known as physical volumes.\n\nThe process of setting up LVM can be summarized as allocating a physical volume, creating a volume group on top of this, then creating logical volumes to store data.\n\nBecause of these features and superior performance over file backed virtual machines we recommend the use of LVM if you are going to store VM data locally.\n\nNow lets install LVM and get started!\n\nNow that we have LVM installed let's configure it to use /dev/sda4 as its physical volume\n\nOk, now LVM has somewhere to store its blocks (known as extents for future reference). Let's create a volume group called ‘vg0’ using this physical volume:\n\nNow LVM is setup and initialized so that we can later create logical volumes for our virtual machines.\n\nFor the interested below is a number of useful commands and tricks when using LVM.\n\nFor example, creating a 100 gigabyte volume called database-data on a volume group called vg0.\n\nYou can then remove this volume with the following:\n\nNote that you have to provide the path to the volume here.\n\nMore on LVM on Debian here.\n\nIf you already have a volume setup that you would like to copy, LVM has a cool feature that allows you to create a CoW (copy on write) clone called a snapshot. This means that you can make an \"instant\" copy that will only store the changes compared to the original. There are a number of caveats to this that will be discussed in a yet unwritten article. The most important thing to note is that the \"size\" of the snapshot is only the amount of space allocated to store changes. So you can make the snapshot \"size\" a lot smaller than the source volume.\n\nTo create a snapshot use the following command:\n\nOnce again note the use of the full path.\n\nNext we need to set up our system so that we can attach virtual machines to the external network. This is done by creating a virtual switch within dom0. The switch will take packets from the virtual machines and forward them on to the physical network so they can see the internet and other machines on your network.\n\nThe piece of software we use to do this is called the Linux bridge and its core components reside inside the Linux kernel. In this case, the bridge acts as our virtual switch. The Debian kernel is compiled with the Linux bridging module so all we need to do is install the control utilities:\n\nManagement of the bridge is usually done using the command. The initial setup for our Xen bridge, though, is a \"set it once and forget it\" kind of thing, so we are instead going to configure our bridge through Debian’s networking infrastructure. It can be configured via /etc/network/interfaces.\n\nOpen this file with the editor of your choice. If you selected a minimal installation, the nano text editor should already be installed. Open the file:\n\nDepending on your hardware you probably see a file pretty similar to this:\n\nThis file is very simple. Each stanza represents a single interface.\n\nBreaking it down, “auto eth0” means that eth0 will be configured when ifup -a is run (which happens at boot time). This means that the interface will automatically be started/stopped for you. (\"eth0 is its traditional name - you'll probably see something more current like \"ens1\", \"en0sp2\" or even \"enx78e7d1ea46da\")\n\n“iface eth0” then describes the interface itself. In this case, it specifies that it should be configured by DHCP - we are going to assume that you have DHCP running on your network for this guide. If you are using static addressing you probably know how to set that up.\n\nWe are going to edit this file so it resembles such:\n\nAs well as adding the bridge stanza, be sure to change dhcp to manual in the line, so that IP (Layer 3) is assigned to the bridge, not the interface. The interface will provide the physical and data-link layers (Layers 1 & 2) only.\n\nNow restart networking (for a remote machine, make sure you have a backup way to access the host if this fails):\n\nand check to make sure that it worked:\n\nIf all is well, the bridge will be listed and your interface will appear in the interfaces column:\n\nBridged networking will now start automatically every boot.\n\nIf the bridge isn't operating correctly, go back and check the edits to the file very carefully.\n\nReboot before continuing. During the reboot, note the list of OS choices and check to see what the default start-up choice is. \"Debian GNU/Linux, with Xen hypervisor\" (or equivalent) means Xen is loading by default. If both the start-up default is fine, skip the next section and go directly to Basic Xen Project Commands.\n\nGRUB, the bootloader installed during installation, tells the computer which operating system to start and how. To use the hypervisor, Xen must be started before the operating system. Depending on your use-case for Xen, you may or may not want GRUB to default to loading Xen.\n\nGRUB2's configuration is stored in the file /boot/grub/grub.cfg\n\nWe aren’t going to edit this file directly, as it changes every time we update our kernel. Debian configures GRUB for us using a number of automated scripts that handle upgrades etc, these scripts are stored in /etc/grub.d/* and can be configured via\n\nTo change the default operating system change the GRUB_DEFAULT line in that file (or add it if it's not already there).\n\ncauses the first OS in the boot list to be the default, and so on. So, if Xen was, say, the third OS choice, change the line to\n\nto have Xen load by default.\n\nThen regenerate the /boot/grub/grub.cfg file by running:\n\nAt the next reboot confirm the correct default boot option is selected.\n\nBefore we dive into creating some guest domains we will quickly cover some basic commands. In the examples below, we use xl command line tool. Older versions of the Xen Project software used the xm command line tool. xl and xm are command line compatible (the format of the output may be slightly different). If, for example, you come across \"xm\" while reading old documentation, say, just substitute \"xl\".\n\nreturns the information about the hypervisor and dom0 including version, free memory etc.\n\nshows running domains in real time and is similar to the “top” command under Linux. This can be used to visualize CPU, memory usage and block device access.\n\nWe will cover some more commands during the creation of our guest domains.\n\nPV guests are notoriously “different” to install. Fortunately, though, there are tools that help us prepare “images” or snapshots of the operating systems to run inside guest domains.\n\nDebian contains a number of tools for creating Xen Project guests, the easiest of which is known as xen-tools. This software suite manages the downloading and installing of guest operating systems including both Debian and RHEL based DomUs. In this guide we are going to use xen-tools to prepare a Debian paravirtualized domU.\n\nxen-tools can use LVM storage for storing the guest operating systems. In this guide we created the volume group “vg0” in the Setting up LVM Storage section.\n\nWhen guests are paravirtualized there is no “BIOS” or bootloader resident within the guest filesystem and for a long time guests were provided with kernels external to the guest image. This however is bad for maintainability (guests cannot upgrade their kernels without access to the dom0) and is not as flexible in terms of boot options as they must be passed via the config file.\n\nThe Xen Project community wrote a utility known as pygrub which is a python application for PV guests that enables the dom0 to parse the GRUB configuration of the domU and extract its kernel, initrd and boot parameters. This allows for kernel upgrades etc inside of our guest machines along with a GRUB menu. Using pygrub or the stub-dom implementation known as pv-grub is best practice for starting PV guests. In some cases pv-grub is arguably more secure but as it is not included with Debian we won’t use it here though it is recommended in production environments where guests cannot be trusted.\n\nApart from this PV guests are very similar to their HVM and physical OS counterparts.\n\nWe can now create a guest operating system with this tool. It effectively automates the process of setting up a PV guest from scratch right to the point of creating config files and starting the guest. The process can be summarized as follows:\n• Install operating system using debootstrap (or rinse etc, only debootstrap covered here)\n• Run a series of scripts to generate guest config files like fstab/inittab/menu.lst\n\nThese 9 steps can be carried out manually but the manual process is outside the scope of this guide. We instead will execute the below command (for --dist you could in place of Wheezy e.g. use Squeeze, or even Precise or Quantal for a Ubuntu install):\n\nThis command instructs xen-create-image (the primary binary of the xen-tools toolkit) to create a guest domain with 512MB of memory, 2 vcpus, using storage from the vg0 volume group we created, use DHCP for networking, pygrub to extract the kernel from the image when booted and lastly we specify that we want to deploy a Debian Wheezy operating system.\n\nThis process will take a few minutes. Once it is complete, it will provide a summary of the installation. Take note of the root password for the guest.\n\nNot every distribution provides the xen-tools package for an automated PV creation and configuration, and some Xen users prefer more control of the setup process.\n\nAlpine Linux is such a distro. It provides detailed instructions on installing and starting a PV domU manually, using PVGRUB2 rather than pygrub.\n\nIt also provides valuable information regarding the startup options available.\n\nTo start the guest, run (as root or using sudo):\n\nThe -c in this command tells xl that we wish to connect to the guest virtual console, a paravirtualized serial port within the domain that xen-create-image configured to listen with a getty. This is analogous to running:\n\nYou can leave the guest virtual console by pressing ctrl+] and re-enter it by running the “xl console <domain>” command.\n\nYou can later shutdown this guest either from within the domain or from dom0 with the following:\n\nThat completes our section on setting up your first paravirtualized domain! If you don’t have any interest in setting up a HVM domain, skip ahead to Starting a GUI guest, below.\n\nHVM guests are quite a bit different to their PV counterparts. Because they require the emulation of hardware there are more moving pieces that need to be configured etc.\n\nThe main point worth mentioning here is that HVM requires the emulation of ATA, Ethernet and other devices, while virtualized CPU and Memory access is performed in hardware to achieve good performance. Because of this the default emulated devices are very slow and we generally try to use PV drivers within HVM domains. We will be installing a set of Windows PV drivers that greatly increase performance once we have our Windows guest running.\n\nThis extra emulation is provided by QEMU which will have been installed along with the Xen software.\n\nTo set up the HVM domU, we need to create a logical volume to store our Windows VM hard disk, create a config file that tells the hypervisor to start the domain in HVM mode and boot from the DVD in order to install Windows.\n\nFirst, create the new logical volume - name the volume \"windows\", set the size to 20GB and use the volume group vg0 we created earlier.\n\nNext open a new file with your text editor of choice:\n\nPaste the config below into the file and save it, NOTE this assumes your Windows iso is located in /root/ with the filename windows.iso. In the line below, be sure the xen version number matches your installation (e.g. xen-4.11, not 4.0):\n\nThe line specifies valid VNC connection addresses. will limit connections to the local machine. will accept unauthenticated remote connections from anywhere so is not suitable except in a secure network.\n\nStart the guest as described below in Starting a GUI guest and proceed with Windows' installation.\n\nOnce you have installed Windows by formatting the disk and by following the prompts the domain will restart - however this time we want to prevent it booting from DVD so destroy the domain with\n\nThen change the boot line in the config file to read boot=\"c\"' restart the domain with\n\nReconnect with VNC and finish the installation. When this process is complete you should then proceed to download the GPLPV drivers for Windows by James Harper.\n\nSigned drivers can be obtained from Univention's website.\n\nMany thanks for Univention for making signed drivers available to the Xen Project community and of course a massive thanks to James for all his work on making Windows in guest VMs such a smooth experience.\n\nOn finalizing the installation and rebooting you should notice much improved disk and network performance and the hypervisor will now be able to gracefully shutdown your Windows domains.\n\nAnother slightly different version of James Harper's drivers can be found here.\n\nHere is the command to start the domain and connect to it via VNC from your graphical machine.\n\nThe VNC display should be available on port 5900 of your dom0 IP, for instance using gvncviewer:\n\nIf this does not work try it without the port number and if you are trying from a GUI on dom0, try specifying localhost instead of the dom0 ip:\n\nThat concludes our introduction to the Xen Project software, by now you can setup both PV and HVM domains on a bare dom0 hypervisor!\n\nYou can now move onto building your own guest images or try out some prebuilt Guest VM Images."
    },
    {
        "link": "https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/5/html/virtualization/sect-virtualization-installing_the_virtualization_packages-installing_xen_packages_on_an_existing_red_hat_enterprise_linux_system",
        "document": "The section describes the steps necessary to install the virtualization packages on a working Red Hat Enterprise Linux system.\n\nRegistering your system with the subscription-manager command Your machines must be registered on your Red Hat account to receive packages and updates. To register an unregistered installation of Red Hat Enterprise Linux, run the command and follow the prompts.\n\nTo use virtualization on Red Hat Enterprise Linux you need the and packages. The package contains the hypervisor and basic virtualization tools. The package contains a modified Linux kernel which runs as a virtual machine guest on the hypervisor.\n\nAdditional virtualization packages are available for management and configuration.\n\nProvides the command for creating virtual machines. is an API library for interacting with hypervisors. uses the virtualization framework and the command line tool to manage and control virtual machines. The package contains a module that permits applications written in the Python programming language to use the interface supplied by the API. , also known as , provides a graphical tool for administering virtual machines. It uses library as the management API."
    },
    {
        "link": "https://wiki.xenproject.org/wiki/Compiling_Xen_From_Source",
        "document": "The purpose of this document is to guide users through the process of installing Xen Project software from source (either from the tarball releases or from a source code repository).\n\nThis document was written targeting the Xen Project 4.2 release, but an attempt will be made to point out differences from previous releases where relevant.\n\nAn assumption is made of some familiarity with the general concept of building software and with using your distributions package manager to install relevant build tools etc.\n\nBefore embarking on the process of building Xen Project software yourself it is worth considering whether this is even necessary. There are many distributions around these days which have excellent support for Xen available right from the package manager, a partial list is available at Dom0 Kernels for Xen. Where possible it is highly recommended that users consume Xen Project via their chosen distribution wherever possible. Using the distribution packaging will give you a much more integrated solution and allow you to take advantage of all the resources provided by your distribution (e.g. documentation, support etc). You can find articles on how to install Xen Project on various distributions in Category:Host Install.\n\nThe remainder of this document assumes that you have considered this and really do want to build from source.\n\nBefore installing Xen Project you will first need to install your domain 0 OS, unless you have already done so. Host OS Install Considerations contains some things which you might want to consider while doing this.\n\nThe primary ways to obtain the Xen Project source code for a stable release are via the release tarballs or by cloning from the appropriate Mercurial source repository. For the development version of Xen Project (xen-unstable) Git is the primary source and Mercurial is the secondary source.\n\nThe latest Xen Project releases are linked to from The Xen.org download page\n\nThe source code repositories are hosted using the Git version control system on xenbits.\n\nEach stable release has its own branch stable-X.Y (e.g. stable-4.2 on Xen.git summary page). The code intended for the next stable point release is added to the branch staging-X.Y (e.g. staging-4.2 on Xen.git summary page), and after they pass automated tests they will be pushed to stable-X.Y for the next release. The point releases are tagged in the main tree with RELEASE-X.Y.Z (e.g. RELEASE-4.2.2 on Xen.git summary page). The result of automated tests are available on xen-devel mailing list.\n\nXen Project Repositories contains information on the various repositories for the stable and development branches.\n\nTo clone the source first install Git using your distro's package manager. Then execute the following command:\n\nWhere URL is the URL of the repository you wish to clone. In our case we should use:\n\nAs the default HEAD in xen.git is master, your local repository will also have a branch called master pointing to the upstream branch. If you wish to use different HEAD (say, staging), you can:\n\nYou can also checkout any tags, branches as you wish.\n\nPlease note that XenProject.org has moved to using Git. The following section is deprecated. We do maintain Mercurial repositories mirroring Git ones, so we retain following section for reference.\n\nXen Project's source code repositories are hosted using the Mercurial version control system on xenbits.\n\nEach stable release has it's own branch xen-X.Y-testing.hg (e.g. xen-4.2-testing.hg) where code intended for the next stable point release is added. The Xen Project development branch is known as xen-unstable and has its own repository xen-unstable.hg.\n\nEach stable and development branch is available in two forms either tested (the main branch) or untested (the staging branch). When commits are made to a Xen Project tree they are first added to the staging branch and only propagated to the main branch after automated testing has passed. For example all commits to the Xen Project development branch will initially appear in staging/xen-unstable.hg and then propagate to xen-unstable.hg after automated testing has completed. The automated test results are posted to the xen-devel mailing list.\n\nXen Project Repositories contains information on the various repositories for the stable and development branches.\n\nTo clone the source first install the mercurial tool using your distributions package manager. Then execute the following command:\n\nWhere URL is the URL of the repository you wish to clone. e.g. to clone the latest tested xen-unstable tree:\n\nOr to clone the staging (e.g. not yet tested) xen-unstable tree:\n\nYou may want to get a specific changeset (revision), for example when trying to replicate someone else's build, or when dealing with other patches you have to apply afterwards. You can do this with the -r option. For example, to get changeset 25364:\n\nThe README at the top level of the Xen Project source code tree contains a quick-start guide to building the software. This provides a quick overview of the process and requirements for building Xen Project software and will generally contain the most up to date information specific to the particular source tree you are looking at. After obtaining the Xen Project source this is the first document you should read.\n\nThis section documents all known requirements to build from source.\n\nLinux distributions shipping with grub2 will need to ensure that their /sbin/installkernel script, which has to be provided by each Linux distribution, copies the the kernel configuration upon a custom kernel install time. The requirement for the config file comes from upstream grub2 /etc/grub.d/20_linux_xen which will only add xen as an instance to your grub.cfg if and only if it finds in your config file either of:\n\nWithout this a user compiling and installing their own kernel with proper support for xen and with the xen hypervisor present will not get their respective grub2 update script to pick up the xen hypervisor. Debian testing has proper support for this, OpenSUSE required this change upstream on mkinitrd, so OpenSUSE folks will want to get the latest /sbin/installkernel hosted on the OpenSUSE mkinitrd repository on github.\n\nFedora might need a similar update. Please edit this wiki once you confirm.\n\nXen Project uses several external libraries and tools. The primary list of these prerequisites is the list present in the README file.\n\nEven this list assumes some sort of basic development environment. A good starting point for this is to use your distributions development install package option.\n\nUnder Debian / Ubuntu (and derived distributions) install the build-essential package:\n\nyou also need to install these additional debs:\n\nAnd if you're building on Wheezy onward:\n\nOne useful shortcut can be to use your distributions package manager to install all the prerequisite packages is to install those packages which are noted as being required to build the distribution's own Xen packages. e.g. under Debian or a Debian derived distribution:\n\nHowever you need to be mindful of new prerequisites added between whatever version of Xen Project software is in your distribution and the version you are building when using this trick.\n\nIf you're now on the latest OpenSUSE you'll note its now a rolling distribution base. The default instructions do not actually encourage you to install the source repositories, and even if you did install them the instructions disable them by default, so be sure to install them and enable them otherwise the command zypper source-install -d won't work. To enable the required repository if you already had it installed:\n\nNow get the build dependencies for Xen\n\nHere's a list of things not currentloy picked up by the build dependencies which have been found to be needed:\n\nWhile at it also get the build dependencies for Linux:\n\nThese instructions are kept separate from RHEL / Centos as Fedora is updated more frequently, so you are expected to do less work to build the latest and greatest Xen.\n\nInstall things not picked up by the current build dependencies:\n\nGet build dependencies for Linux, the kernel, while at it:\n\nUnder RHEL, CentOS, Fedora based distributions you want to install the Development Tools package groups:\n\n(On old CentOS and Fedora, a group called Development Libraries should, if available, installed too. That is not present in recent releases of the distributions any longer, though).\n\nThen install known build dependencies (confirmation needed if this works on RHEL / Centos):\n\nYou also need to install these additional rpms:\n\nIf on CentOS, for some of this packages (e.g., dev86 and pandoc), enabling the EPEL additional repository is necessary.\n\nHaving installed this you should then install each of the prerequisites listed in the README using your distribution's package management tool. In general the Xen Project code tries to only depend upon external tools and libraries which are commonly available in distributions therefore obtaining the prerequisites other than from your distribution's package management system is out of scope for this document. If you have trouble locating a particular prerequisite then please contact the xen-users mailing list.\n\nFrom Xen Project 4.2 onwards, the software uses the commonly used autoconf tool to provide compile time configurability of the toolstack. This allows some control of what features are built into Xen Project, as well as compile time sanity checking. To configure Xen Project, simply run the provided configure script:\n\nTo see the various options run the configure script with --help e.g.:\n\nThis step is only required from Xen Project 4.2 onwards. Prior to Xen Project 4.2 these options could be configured by passing a variable on the make command line during build & install or by writing the variable to a file named .config at the top level of the source tree.\n\nUse http:// Rather Than git:// to Clone Additional Repositories\n\nWhen building the software from Mercurial, the build system will automatically clone several additional repositories from the network. Some of these repositories use the version control system which uses its own protocol on a specific port. Sometimes this causes issues due to firewalls etc blocking the git port. This can be worked around by instructing the Xen build system to clone such repositories using a less efficient HTTP based protocol:\n\nPrior to Xen Project 4.2 this could be achieved by writing GIT_HTTP=y to your .config:\n\nXen Project 4.2 onwards defaults to installing libraries into /usr/lib by default and from 4.3 onwards defaults to installing to /usr/local/lib by default.\n\nUsers on systems which use /usr/local/lib64 for 64-bit libraries should use the --libdir option. e.g:\n\nFailure to do this usually results in errors about libraries not found or using older versions of the libraries which will likely not work.\n\n_NB_: If you are using `--prefix=/usr` you should use `--libdir=/usr/lib64` too.\n\nIf the target system uses systemd, do not forget to enable it:\n\nOn some distros (e.g. Debian and Ubuntu) Xen Project may install the python parts of the code into the wrong place (See Debian bug #693721). Therefore it is necessary to set PYTHON_PREFIX_ARG=--install-layout=deb:\n\nSome versions of Ubuntu have a bug which requires instead that PYTHON_PREFIX_ARG is to set the empty string:\n\nAs of 4.2 this option is not yet supported by the configure script and therefore should still be set via .config or on the make command line.\n\nThe most common symptom of this issue is pygrub failing to work, with output similar to:\n\n\n\n To build all components (hypervisor, tools, docs, stubdomains, etc) you can use the dist target.\n\nIf you wish to just (re)build a single component you can use the appropriate dist-COMPONENT target:\n\nIf you want to rebuild a tree as if from a fresh check then you can use the world target. This is effectively the same as clean and the dist\n\nAll of the above targets will build and install the appropriate component into the dist subdirectory but not actually install onto the system.\n\nTo install onto the local machine simply call the install target (as root):\n\nAs with dist you can also install individual components using the appropriate install-COMPONENT target:\n\nIf you want to install onto a remote machine then you can simply copy the dist directory over and TBD\n\nA better option is to make a \"package-ball\" -- a package which is the equivalent of a tarball with no dependency checking or set-up. There are target for either deb-based systems:\n\nPackages are placed in the dist/ directory.\n\nInstalling the resulting package is functionally equivalent to the make install target above, but because the files are tracked by the package manager, it is easier to remove or update.\n\nAfter installing (either via make install or a packageballl) you rebuild your dynamic linker cache by running:\n\nTo get more information on the available targets use the help target:\n\nWhen on Linux and using grub2 after installing Xen you will also need to make sure grub2 will pick up your new shiny Xen hypervisor. Distributions differ on how to do this. This section documents how to do this for known distributions.\n• If SeaBIOS fails to compile when building Xen 4.2 on a system with a non-English locale, try setting LC_ALL to en_US.UTF-8 before calling make:\n\nThe Linux kernel now supports different hypervisors with one kernel. There is also no requirement for a domain 0 (or guest) kernel to match your hypervisor so you are free to pick the kernel which best suits your needs (e.g. many distributions supply a kernel which is compatible with Xen Project, which is a quick and easy path). Dom0 Kernels for Xen contains some guidance on this issue.\n\nIf compiling Linux from source for either dom0 or a guest you can now enable Xen support for both through one simple kernel configuration helper, this was added as of v4.2:\n\nThis lets you build a kernel which can support xen dom0 or xen guests on i386, x86-64 and arm64.\n\nA few system services should be manually enabled after the installation:\n\nAfter making those changes reboot the system.\n\nOnce the Xen Project code is installed there is still some host level setup required. Category:Host Configuration covers this."
    }
]