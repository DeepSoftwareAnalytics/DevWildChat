[
    {
        "link": "https://vuejs.org/guide/components/provide-inject",
        "document": "Usually, when we need to pass data from the parent to a child component, we use props. However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:\n\nNotice although the component may not care about these props at all, it still needs to declare and pass them along just so can access them. If there is a longer parent chain, more components would be affected along the way. This is called \"props drilling\" and definitely isn't fun to deal with.\n\nWe can solve props drilling with and . A parent component can serve as a dependency provider for all its descendants. Any component in the descendant tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.\n\nTo provide data to a component's descendants, use the function: If not using , make sure is called synchronously inside : The function accepts two arguments. The first argument is called the injection key, which can be a string or a . The injection key is used by descendant components to lookup the desired value to inject. A single component can call multiple times with different injection keys to provide different values. The second argument is the provided value. The value can be of any type, including reactive state such as refs: Providing reactive values allows the descendant components using the provided value to establish a reactive connection to the provider component.\n\nTo provide data to a component's descendants, use the option: For each property in the object, the key is used by child components to locate the correct value to inject, while the value is what ends up being injected. If we need to provide per-instance state, for example data declared via the , then must use a function value: // use function syntax so that we can access `this` However, do note this does not make the injection reactive. We will discuss making injections reactive below.\n\nIn addition to providing data in a component, we can also provide at the app level:\n\nApp-level provides are available to all components rendered in the app. This is especially useful when writing plugins, as plugins typically wouldn't be able to provide values using components.\n\nTo inject data provided by an ancestor component, use the option: Injections are resolved before the component's own state, so you can access injected properties in : If multiple parents provide data with the same key, inject will resolve to the first parent in its parent chain. When using the array syntax for , the injected properties are exposed on the component instance using the same key. In the example above, the property was provided under the key , and injected as . The local key is the same as the injection key. If we want to inject the property using a different local key, we need to use the object syntax for the option: Here, the component will locate a property provided with the key , and then expose it as .\n\nBy default, assumes that the injected key is provided somewhere in the parent chain. In the case where the key is not provided, there will be a runtime warning.\n\nIf we want to make an injected property work with optional providers, we need to declare a default value, similar to props:\n\n// `value` will be \"default value\" // if no data matching \"message\" was provided In some cases, the default value may need to be created by calling a function or instantiating a new class. To avoid unnecessary computation or side effects in case the optional value is not used, we can use a factory function for creating the default value: The third parameter indicates the default value should be treated as a factory function.\n\nWhen using reactive provide / inject values, it is recommended to keep any mutations to reactive state inside of the provider whenever possible. This ensures that the provided state and its possible mutations are co-located in the same component, making it easier to maintain in the future. There may be times when we need to update the data from an injector component. In such cases, we recommend providing a function that is responsible for mutating the state: Finally, you can wrap the provided value with if you want to ensure that the data passed through cannot be mutated by the injector component.\n\nSo far, we have been using string injection keys in the examples. If you are working in a large application with many dependency providers, or you are authoring components that are going to be used by other developers, it is best to use Symbol injection keys to avoid potential collisions.\n\nIt's recommended to export the Symbols in a dedicated file:"
    },
    {
        "link": "https://codemag.com/Article/2101091/The-Complete-Guide-to-Provide-Inject-API-in-Vue-3-Part-1",
        "document": "By Bilal Haidar\n\n Published in: CODE Magazine: 2021 - January/February\n\n Last updated: January 31, 2025\n\nThis is the first article of two on the topic of developing Vue 3 plug-ins. With the introduction of the Composition API, developing plug-ins in Vue 3 has dramatically changed, for the better, as is expected. Now you have the option of developing plug-ins that only work with the new Composition API or you can still use the old method of developing plug-ins to incorporate the new Application API that supports the Options API. This also provides your plug-in functionality via the Provide/Inject API to support the Composition API.\n\nThe Composition API is optional and can be added. Therefore, be careful when developing a Vue 3 plug-in with it. You need to support apps that still use the Options API while making it compatible with the new Composition API.\n\nToday, I'm providing you with a complete guide to understanding and using the Provide/Inject API in Vue 3. It constitutes the core that Vue 3 plug-ins are built on. Building on this knowledge, I'll look at how to build a Vue 3 plug-in that supports both the Options API and the Composition API in the next article.\n\nWhen you write HTML markup, you define attributes on your HTML elements. Examples of attributes are the ID, NAME, and other headings. The browser then parses the HTML and creates a Document Object Model (DOM) in JavaScript. It converts the HTML attributes to properties on the DOM objects. The properties of a single DOM relate to attributes with the same or similar names, but it's not a one-to-one relationship.\n\nThe concept of Vue Props relates to the HTML attributes and DOM properties.\n\nVue promotes building up single page apps (SPAs) by composing components inside each other in a tree-form. A parent component passes data to its child components by using properties.\n\nA Vue or property is a custom attribute that you add on a Vue component and bind to some sort of data. The binding can be static when you set the value of a property to a static data. It can also be dynamic by setting the value to a variable that you define inside the component. Irrespective of this, the child components receive their data via properties.\n\nA Vue component uses the property to receive any set of properties from the parent component. A line of code is worth a thousand words. Listing 1 shows how you define a property on a Vue component. Figure 1 illustrates the one-way data flow in Vue.\n\n, by nature, are reactive. This means that when you change the value binding of a , the new value is propagated to the child components automatically. In turn, Vue detects a change in component properties and re-renders all affected components. Most probably, the affected components are the child components themselves.\n\nHowever, in some cases the parent component uses those same properties that you pass to the child components. It uses them inside the component source code or inside the component markup. In this case, the parent component is also re-rendered. A parent component re-rendering causes the re-rendering of the entire tree of components inside it.\n\nTo learn more about Vue Props, check out the official documentation (https://v3.vuejs.org/guide/component-props.html).\n\nNow that you're familiar with Vue Props, how to define and use them inside your components, and how they function internally, let's move on and discuss the Prop Drilling problem. React ecosystem first coined this term and now it's a common problem among Vue developers.\n\nBefore diving in, let's consider and note three important Vue concepts that are essential to understand the problem at hand.\n• You build a Vue app by composing components inside each other to form a tree of components.\n• Parent components use properties to pass data to their child components.\n• Component properties are reactive. The moment the parent component mutates the data, Vue re-renders all the child components that use the data.\n\nProp Drilling happens when a parent component wants to pass down some properties to deeply nested components in the component hierarchy. The middle component(s) has no need for these properties but passes them down to the target component(s) that need these properties.\n\nImagine that the component in Figure 2 holds the property that Component F needs in order to render its UI. Every time the component changes that property, Vue passes the new property value down to Component F and, at the same time, it re-renders the entire component hierarchy including Component F itself. This re-rendering includes components B, D, and F all together. In fact, only Component F should re-render.\n\nThis is just a sample component hierarchy. In medium and large apps, there might be several layers of such components that need to be re-rendered along the way. The app performance might be highly affected and that's something you want to avoid.\n\nVue offers a couple of ways to overcome the Prop Drilling problem. Vuex and Provide/Inject API are two.\n\nVuex is a state management library for Vue. It serves as a centralized store for all the components in an app, with rules ensuring that the state can only be mutated in a predictable fashion. Literally any component in the app can query the store inside Vuex and locate the data. Whether you allow every component to access the store or not or whether you are using smart vs. dumb components is up to you. That's another topic for another day.\n\nPersonally, I'd employ Vuex in a bigger app where there are a hundred or more components interacting to form the apps function. The next section introduces an alternative to Vuex for small/medium apps that you can use right away.\n\nYou can learn and read more about Vuex by checking their official website (https://vuex.vuejs.org/guide).\n\nThe Provide/Inject API in Vue is equivalent to the Context API in React development. This concept is based on two main elements: The Dependency Provider and Dependency Consumer. Figure 3 shows a schematic of this concept.\n\nIn this scenario, the component takes the role of the dependency provider. It provides the dependency property. Component F takes the role of the dependency injector. It injects the property.\n\nThe parent component provides a dependency, let's say a property, and somewhere within the same parent chain, a descendent component(s) injects the property and makes use of it. Regardless of how deep the component hierarchy is, if the provider and descendant components are in the same hierarchy, this mechanism works perfectly.\n\nA Vue app using the Provide/Inject API has better performance metrics as Vue re-renders only the affected descendent components and not all the components along the component hierarchy.\n\nBack to Figure 3, when the component, which is the provider component in this case, changes the property value, Vue only re-renders Component F. Component F is the only component using this property. So, the rest of the components inside the hierarchy are left as they are without re-rendering. That's an important reason to use the Provide/Inject API in your apps.\n\nOne last note before closing about reactivity. The dependency property the component provides by default is not reactive. Therefore, you must wrap the content of the provided property by Vue 3 function. This way, when the component changes the provided property, the component automatically injecting this dependency reacts to this change.\n\nIn the next sections, I'll go through live examples on using the Provide/Inject API. You can learn and read more about Provide/Inject API by checking the official documentation (https://v3.vuejs.org/guide/component-provide-inject.html).\n\nLet's go through an example demonstrating the concept of Prop Drilling and see how Vue re-renders all components inside the component hierarchy.\n\nThe example code is an imaginary app that displays a collection of cat images using an external third-party API. Figure 4 shows the component hierarchy of the app.\n\nThis consists of the , , and components. The component lives inside the component. Two instances of the component live inside the .\n\nYou can play with this sample app here: https://stackblitz.com/edit/vue3-prop-drilling.\n\nThe goal is to store some state inside the component that both components need to render their UI. For this app, the state is an object that tracks the third-party Cat API authorization key and Search API URL.\n\nThe component accepts a property to receive the state from the parent App component. In turn, the component defines a property to receive the state from the parent component. The component acts as a mediator that receives the state from the component and passes it down to both instances of the components.\n\nThe component renders a single instance of the component and passes to it a single property named . It binds the property to a variable named that it defines on the data option as follows:\n\nThe settings data variable consists of the and properties.\n\nLet's move on to check the component.\n\nThe component renders two different instances of the component. For each instance, it passes down the property and the property that represents the number of the component instance.\n\nThe receives the property from the parent component. It defines the property as follows:\n\nThe property is of type . The component receives this property and passes it down to the component without using it inside its markup.\n\nFinally, the component. It defines the following markup:\n\nIt makes use of an HTML element to display a single image. It binds the source of the image to the property. It defines a property named that it receives from the parent component. In addition, it uses the lifecycle hook to query the Cats API for a new image to display.\n\nListing 2 shows the entire source code of this component. You can learn more about Vue Lifecycle Hooks by checking their online documentation (https://v3.vuejs.org/guide/composition-api-lifecycle-hooks.html#lifecycle-hooks).\n\nNow that you understand the internal code of the sample app, let's add a button inside the App component to trigger a change on the property it holds.\n\nThe button defines a event handler that sets the property to an empty string.\n\nIn addition, let's register the lifecycle hook on the component. Vue triggers this hook when the data changes, before the DOM is patched. This way, you can track when Vue re-renders this component.\n\nLet's add the same hook onto both the and components.\n\nFinally, let's the property inside the component so that when its value changes, the component triggers a new call to the Cats API to retrieve a new cat image.\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components. Click the Change Props button and check the logs. Figure 6 shows the logs.\n\nThe component is re-rendered. This happens because the App component changes the settings property and at the same time it's binding it to the property on the component. The component is also re-rendered despite the fact that it's not using this property but instead is just passing it over to the two component instances.\n\nClearly, the Prop Drilling problem prevails in this example. A parent component passes down the property to the middle one in the hierarchy. It passes the property down to a child component without making use of it inside the middle one's markup. The target component uses the property. The Prop Drilling forces Vue to re-render the middle component, even though it's just a carrier to the property and isn't using it internally.\n\nNext, we'll look at how to fix this problem by using the Provide/Inject API.\n\nIn this section, I'll be using the Provide/Inject API in Vue 3 to overcome the side-effects of Prop Drilling when passing data from a parent component to another nested deeply in the component hierarchy.\n\nFirst, I start by using the Provide/Inject API in the Option API. Then, I use the Provide/Inject API available in the new Composition API. You can read about the new Composition API by checking Shawn Wildermuth's article in CODE Magazine about Vue's Composition API.\n\nUsing the Provide/Inject API in the Options API\n\nVue offers the option as part of its Option API. In this section, I'll use this option to provide the property.\n\nLocate the component and replace its markup with the following:\n\nIt uses an instance of the component without passing any properties.\n\nNow let's provide the property via the provide option inside the component. Add the following option inside the component:\n\nVue offers two forms for using the provide option. Either you define the provide option as an object with properties, or you define it as a function returning an object. The latter gives you more flexibility in terms of defining what data you want to provide and making the provided data reactive.\n\nBy default, the data you provide is not reactive. This means, if the data you provide changes inside the dependency provider component, the new changes won't be reflected inside the dependency injector component.\n\nTo make the data reactive, start by using the provide option as a function. Then, wrap your data inside a function to make it reactive and read-only.\n\nThe code uses the function that belongs to the new reactive Composition API library in Vue 3. Vue 3 internally implements the property using the reactivity API. The function returns a property that's an instance of the object. Read about Computed properties in Vue by checking their official documentation. (https://v3.vuejs.org/guide/computed.html).\n\nSo far, the component provides a property named . Let's move on to the component.\n\nThe component receives no more properties from the parent component. Its markup now looks like this:\n\nThe only property it passes to the component is the property. Nothing interesting really.\n\nLet's move on to the component. It uses the same markup as before. However, let's see how it injects the property. It uses the inject option to receive what the component provides.\n\nThe component, as you now know, provides the property as a property. It uses the function that belongs to the Composition API inside the Options API, the option in this case. That's why you access this property differently in this situation. Let's check how.\n\nLet's change the function like so:\n\nThe code now watches the property and not only settings. I mentioned previously that Vue 3 returns an instance of object for any property. Internally, this object makes use of the object. Therefore, you access the value of a object, and consequently a property, by accessing its property.\n\nThis is only valid for the scenario where you make use of the new Composition API objects inside the Options API. For all computed properties that you define with the Options API, you continue to access their values by using the name of the property only. The same applies when you are using the Composition API alone.\n\nNow, back to the component. The code now monitors any changes on the provided property and loads a new image accordingly.\n\nFinally, you change the function to use the new property as follows:\n\nNotice how the function now accesses the to get the Cats API details. Listing 3 shows the entire source code of this component.\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components only.\n\nClick the Change Props button and check the logs. Figure 7 shows the logs.\n\nVue re-renders only the FavoriteCat component. No other components are affected across the component hierarchy. This is the ultimate solution you're after, with some help from the Provide/Inject API, of course. You can play with this sample app here: ( https://stackblitz.com/edit/vue3-prop-drilling-provide-inject).\n\nUsing the Provide/Inject API in the Composition API\n\nNow that you know how to solve the problem of Prop Drilling inside the Options API, let's switch gears and learn how to overcome Prop Drilling when using only the Composition API in Vue 3.\n\nStarting at the component, paste the following inside the markup section:\n\nThe component uses the CatsCollection component and the button click-event handler now calls a new function named .\n\nAdd a new function to the component. It sits at the core of the new Composition API and provides all the functionality of the component. Listing 4 shows the entire source code of this function. The function starts by defining a settings property by using the function to wrap the object. It then provides the settings object via the function. Once again, the component provides the object via a property to ensure any changes inside the component are propagated into the entire component hierarchy.\n\nThe function then defines the function to change the value of the settings object. This is the same function that the button above uses to trigger a change on the settings data. Finally, the function returns an object with the exposed items to the markup. In this case, it's just the function.\n\nThat's all that you must add to the component to provide the property when using the Composition API.\n\nThe component remains the same without any change. Let's move on to the component and study its changes to adapt to the Composition API.\n\nAll of the functionality inside the component is now encapsulated inside the function. Listing 5 shows the entire source code of this function. The function starts by injecting the property via the function.\n\nAs a reminder, the settings variable represents a computed property and therefore, to access its value, you should access the property on this object.\n\nIt then defines a new object to hold the image URL that the component retrieves from the remote Cats API.\n\nThe function makes use of the lifecycle hook to load the image for the first time.\n\nYou can learn more about using the lifecycle hooks in Vue 3 Composition API by checking their official documentation (https://v3.vuejs.org/api/composition-api.html#lifecycle-hooks).\n\nThe function makes use of the function to monitor and react to any changes on the injected property.\n\nThe function in the Composition API works the same as in the Options API. The first parameter is an function that returns the property to watch. In this case, it's the property. Whenever the component changes the property, the component is notified on the spot via the handler. You can read more about the function in the Composition API by checking their official documentation (https://v3.vuejs.org/api/computed-watch-api.html#watch).\n\nFinally, the function returns an object to expose its functionality into the markup section of the component.\n\nIt returns the as a computed property wrapping the property that it receives from the component. It also returns to the markup reactive property that holds the image URL to display.\n\nTo recap on the function, Vue calls it with two input parameters: and . The parameter is just a copy of the object that you define on the component itself. Whatever properties the component receives are also available to the function. The property contains additional data like attrs, slots, and . Learn about the function in the Composition API by checking their official documentation (https://v3.vuejs.org/api/composition-api.html#setup).\n\nNow let's run the app and check the console logs to understand how Vue reacts to this change and how it re-renders the affected components only.\n\nClick the Change Props button and check the logs. Figure 8 shows the logs.\n\nVue re-renders only the component. No other components are affected across the component hierarchy. Once again, you're solving the problem of Prop Drilling by using the Provide/Inject API inside the new Composition API. You can play with this sample app here: (https://stackblitz.com/edit/vue3-prop-drilling-composition-api-provide-inject.\n\nThe Provide/Inject API in Vue 3 is a major building block in managing state in your app. In small or even medium apps, you can use the Provide/Inject API to manage the state at different levels inside the component hierarchy. You might opt to skip Vuex depending on the requirements and the complexity of the app at hand.\n\nProvide/Inject API helps modularize your app in terms of managing the state at different layers of the component hierarchy. Providing data at the App component makes the state available globally across all components in the app. Depending on your needs and requirements, you can provide data at different levels inside the app.\n\nIn the next article, I'll be using the Provide/Inject API inside a custom Vue 3 plug-in. The plug-in will provide global state at the app level to allow all the components in the hierarchy to inject and access the state."
    },
    {
        "link": "https://stackoverflow.com/questions/65340740/vue-3-inject-can-only-be-used-inside-setup-or-functional-components",
        "document": "I can't understand why I'm getting this error. I am trying to use the Vuex store in a composition function but it keeps throwing me this error about inject (I'm not even using inject). My app makes an await api call to the backend and if there is an error calls my composition function.\n\nHere is my composition function\n\nIf I remove this line then it doesn't throw that error\n\nUPDATE: this is how the function is called."
    },
    {
        "link": "https://vuejs.org/api/composition-api-dependency-injection",
        "document": "Provides a value that can be injected by descendant components.\n• None takes two arguments: the key, which can be a string or a symbol, and the value to be injected. When using TypeScript, the key can be a symbol casted as - a Vue provided utility type that extends , which can be used to sync the value type between and . Similar to lifecycle hook registration APIs, must be called synchronously during a component's phase.\n\nInjects a value provided by an ancestor component or the application (via ).\n• None The first argument is the injection key. Vue will walk up the parent chain to locate a provided value with a matching key. If multiple components in the parent chain provides the same key, the one closest to the injecting component will \"shadow\" those higher up the chain. If no value with matching key was found, returns unless a default value is provided. The second argument is optional and is the default value to be used when no matching value was found. The second argument can also be a factory function that returns values that are expensive to create. In this case, must be passed as the third argument to indicate that the function should be used as a factory instead of the value itself. Similar to lifecycle hook registration APIs, must be called synchronously during a component's phase. When using TypeScript, the key can be of type of - a Vue-provided utility type that extends , which can be used to sync the value type between and .\n• None Assuming a parent component has provided values as shown in the previous example:\n\nReturns true if inject() can be used without warning about being called in the wrong place (e.g. outside of ). This method is designed to be used by libraries that want to use internally without triggering a warning to the end user."
    },
    {
        "link": "https://stackoverflow.com/questions/58815788/how-to-provide-passed-injection-from-vue-functional-component",
        "document": "I have $validator provided by . Inside I use render function with other async component ( ).\n\ninjections live inside , but how to pass it down to the by using functional component?\n\nI can imagine only rewriting of FnChild as non-functional component and using in\n\nUPD: as was pointed in answers, you don't need any inject/provide inside functional component, it just works.\n\nMy specific case was related to v-validate and auto-injection of new in each component. And in my specific case it was a component with slot, which was overriding because I had no inside it. Structure is a simple like this:\n\nParent had validator injected, but ComponentWithSlot hadn't, so new instance was recreated by v-validate for ComponentWithSlot and it was provided down to the FnChild instead of from component.\n\nSo once I've added into , everything is fine and now correctly receives from ."
    },
    {
        "link": "https://vuejs.org/guide/components/events",
        "document": "A component can emit custom events directly in template expressions (e.g. in a handler) using the built-in method:\n\nThe parent can then listen to it using :\n\nThe modifier is also supported on component event listeners:\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to to provide this value:\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\nOr, if the event handler is a method:\n\nThen the value will be passed as the first parameter of that method:\n\nA component can explicitly declare the events it will emit using the macro option:\n\nThe method that we used in the isn't accessible within the section of a component, but returns an equivalent function that we can use instead: The macro cannot be used inside a function, it must be placed directly within , as in the example above. If you're using an explicit function instead of , events should be declared using the option, and the function is exposed on the context: As with other properties of the context, can safely be destructured:\n\nThe option and macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the call and returns a boolean to indicate whether the event is valid or not."
    },
    {
        "link": "https://vuejs.org/guide/components/events.html",
        "document": "A component can emit custom events directly in template expressions (e.g. in a handler) using the built-in method:\n\nThe parent can then listen to it using :\n\nThe modifier is also supported on component event listeners:\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to to provide this value:\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\nOr, if the event handler is a method:\n\nThen the value will be passed as the first parameter of that method:\n\nA component can explicitly declare the events it will emit using the macro option:\n\nThe method that we used in the isn't accessible within the section of a component, but returns an equivalent function that we can use instead: The macro cannot be used inside a function, it must be placed directly within , as in the example above. If you're using an explicit function instead of , events should be declared using the option, and the function is exposed on the context: As with other properties of the context, can safely be destructured:\n\nThe option and macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the call and returns a boolean to indicate whether the event is valid or not."
    },
    {
        "link": "https://learnvue.co/articles/vue-emit-guide",
        "document": "Many Vue patterns involve passing data from a parent component to its children using . But what if we need a child to affect its parent?\n\nUsing , we can trigger events and pass data up the component heirarchy. This is useful for things like:\n• closing modals from inside the modal itself\n• making our parent component respond to one of its children\n\nWhen we emit an event, we invoke a method with one or more arguments:\n• – the name of our event. Our parent component will listen for this.\n• – any value(s) that we want to pass with our event\n\nHere’s an example of an inline emit, . We are emitting an event called and passing it a value of\n\nThen, using the or directive, a parent component can listen to our custom event and receive the value.\n\nEvery time we click our button, emits an event called with a random value between 0 and 1. Then, captures this event and adds that value to\n\nWe can pass as many arguments as we want and our listener will receive all of them.\n\nSo now, we know how to emit inline events in our template, but in more complicated examples, it's better if we emit an event from the section of our SFC instead. This is useful when we want to perform some logic before emitting an event.\n\nIn Vue 3, we have 2 different ways to do this:\n\nLet’s check out an example for each.\n\nWhen we are using , we don't have access to the component instance or the setup function's argument.\n\nSoooo. How do we get ?\n\nIn this case, we have a compiler macro called that let us:\n• specify events that our component emits\n• have access to the same value as so we can emit events\n\nIn the simplest case, array of strings, with each one being the name of an event.\n\nHowever, if we pass an object, we can add a validator function for each event that lets us check we're emitting events with proper values.\n\nLike event listeners, the validator accepts however many values as we pass in.\n\nThis works similar to prop validation, where if our validator returns , we'll get a warning in our console. While the event with the unvalidated value will still be emitted, the console warning provides valuable feedback during development.\n\nUsing is called the runtime declaration since it creates a runtime check for your component events.\n\nHowever, if we want to unleash the full power of Typescript, we can also used type-based . This is typically the method that I choose to use.\n\nHere's the initial component that we wrote with this syntax.\n\nSo when we used the type-based method, we can specify our eventName as and then add any payload options after that.\n\nHowever, in the upcoming Vue 3.3 release, we're going to get an even cleaner way to write this. See this tweet by Evan You to learn more.\n\nIn the Composition API, if we use the function, we don't have access to our component with - meaning we can't call to send our event.\n\nInstead, we can access our method by using the second argument of our function – .\n\nhas access to your components slots, attributes, and most importantly for us, its emit method.\n\nWe can call with the same event name and values that we used before.\n\nLike most things in Vue 3, we have the choice of using the Options API or the Composition API.\n\nIn the Options API, we can call to emit a custom event.\n\nLet's take a look at an example where we have that contains a label and a text input. Whenever the text changes, we want to emit an event with the uppercased value of our input.\n\nInstead of calling from our template, we can call a component method instead. Inside, we can call and pass it our value.\n\nWhile this is a simple example, extracting this logic outside of our component gives us easier access to other properties in our data and helps keep our logic organized in larger files.\n\nIf we're not using , we can still keep track custom events for a component by defining the option in our .\n\nThis is important for keeping good component documentation and for getting errors from Vue if we try to use an event not declared in .\n\nAlso, defining events makes component events take priority over the native events.\n\nFor example, if we define an event called (an existing HTML event), we can override the default action.\n\nIn Vue 3, event names can automatically be converted between the different cases. Similar to props, it's best to stick to each programming language’s conventions and use in your script and in your template.\n\nHowever, if you're using Vue 2, event names don't have automatic case conversion and since directive automatically converts your event names to lower case so camelCase named events impossible to listen to.\n\nFor example, if we emitted an event called , listening for would not work.\n\nThe ability to emit custom events in Vue is one of the most important techniques to understand before working on larger Vue projects.\n\nI hope this overview of Vue helped explain the different ways to use this powerful feature in all sorts of Vue apps."
    },
    {
        "link": "https://freecodecamp.org/news/how-event-handling-works-in-vue-3-guide-for-devs",
        "document": "Event handling in Vue 3 allows developers to respond to user interactions like clicks, key presses, form submissions, and more.\n\nVue provides simple and flexible ways to manage these interactions, enabling you to build dynamic and engaging applications.\n\nIn this guide, we'll cover:\n\nBy the end, you'll be able to handle a wide range of events and improve user interaction in your Vue applications.\n\nVue makes it easy to handle basic events like , , and directly in your template. You can use the symbol (short for ) to listen for events on DOM elements.\n• None : The symbol is shorthand for . It listens for the event and calls the method when the button is clicked.\n• None : In Vue 3's Composition API, creates reactive variables. When the button is clicked, the reacts to variable updates, and the change is reflected in the DOM automatically.\n\nThis simple mechanism of listening to events and binding methods is foundational to handling user interactions in Vue.\n\nVue event modifiers allow you to control how events are handled, preventing default behavior or stopping propagation, for example. Common event modifiers include , , , , and .\n\nThe modifier calls , preventing the default behavior of events like form submission.\n\nExample: Using to Handle Form Submission\n• None : Prevents the form from refreshing the page when submitted, allowing the function to process the form data instead.\n• None : Two-way data binding between the form input and the reactive variable. It updates in real time as the user types.\n\nWhen to use : Use when handling forms or other elements where you want to prevent the default behavior, such as preventing links from navigating.\n\nThe modifier calls , preventing the event from bubbling up to parent elements.\n• : Clicking the button only triggers and prevents the click from propagating to the parent . Without , clicking the button would also trigger .\n\nWhen to use : Use it to prevent parent elements from reacting to child element events.\n\nThe modifier ensures that the event listener is only called once.\n• : The method is triggered the first time the button is clicked. Subsequent clicks do nothing because the event listener is removed after the first execution.\n\nWhen to use : Use it for actions that should only happen once, such as a one-time form submission.\n\nThe modifier makes the event handler trigger during the capture phase rather than the bubbling phase.\n\nExample: Handling an Event in the Capture Phase\n• : The click on the parent is handled first, before the child button’s click event, because the phase happens before the bubbling phase.\n\nWhen to use : Useful when you need to intercept an event before it reaches its target.\n\nIn Vue, child components can emit custom events to communicate with parent components. This pattern is commonly used to pass data or trigger methods in parent components.\n• None : This is used in the child component to define custom events. Here, the child emits a with a payload of . (you can learn more details of emit from here)\n• None Event Handling in Parent: The parent component listens for and responds by updating its with the event payload.\n\nWhen to use custom events: Use them for communication between parent and child components, especially for passing data from child to parent.\n\nVue’s simplifies handling form inputs by creating two-way data binding between the form field and a data variable.\n• None : This binds the input field directly to the variable, allowing automatic updates as the user types. (you can learn more details of v-model from here)\n• None The method processes the form data and displays it in the paragraph below the form.\n\nVue also makes it easy to handle keyboard events such as , , and .\n• : Listens for the keypress and triggers the function when pressed. This is useful for form submissions or other actions that should be triggered by a specific key press.\n\nEvent handling in Vue 3 is pretty straightforward and flexible. From basic click events to custom events and form handling, Vue's event system allows you to create interactive, dynamic applications.\n\nBy using event modifiers and custom events, you can fine-tune how events are handled in your app. Understanding these techniques will enable you to create responsive, user-friendly interfaces."
    },
    {
        "link": "https://bairesdev.com/blog/vue-emits",
        "document": ""
    }
]