[
    {
        "link": "https://geeksforgeeks.org/python-checking-triangular-inequality-on-list-of-lists",
        "document": "Given a list of lists, the task is to find whether a sublist satisfies the triangle inequality. The triangle inequality states that for any triangle, the sum of the lengths of any two sides must be greater than or equal to the length of the remaining side. In other words, a triangle is valid if sum of its two sides is greater than the third side. If three sides are a, b and c, then three conditions should be met.\n\nTime Complexity: O(n), where n is the length of the list test_list \n\nAuxiliary Space: O(n) additional space of size n is created where n is the number of elements in the res list\n\nAnother approach you can use is to use the filter function to filter the sublists in the input list that satisfy the triangle inequality.\n\nHere is an example of how you can do this:\n\nThe time complexity of this approach is O(n), where n is the number of sublists in the input list, because the filter function iterates over each element in the input list and applies the filtering function to it. The space complexity is also O(n), because the valid_sublists list will have a size equal to the number of sublists that satisfy the triangle inequality."
    },
    {
        "link": "https://stackoverflow.com/questions/9966173/logic-of-triangle-inequality-as-python-conditionals",
        "document": "It is easier to just do:\n\nThis is exactly what you're doing. You are calculating correctly, but then doing which checks if it is a right triangle.\n\nBelow I mention how your code can be simplified:\n\n\"if bool return True else return False\" is the SAME as \"return bool\" in any almost any modern programming language. The former is unnecessarily verbose and should never be used."
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://geeksforgeeks.org/check-whether-triangle-valid-not-sides-given",
        "document": "Check whether triangle is valid or not if sides are given\n\nGiven three sides, check whether triangle is valid or not.\n\nInput : a = 7, b = 10, c = 5 \n\nOutput : Valid\n\nWe can draw a triangle with the given three edge lengths.\n\n\n\nInput : a = 1, b = 10, c = 12 \n\nOutput : Invalid\n\nWe can not draw a triangle with the given three edge lengths.\n\nApproach: A triangle is valid if sum of its two sides is greater than the third side. If three sides are a, b and c, then three conditions should be met.\n\n// C++ program to check if three sides form a triangle or not // function to check if three sider form a triangle or not // This code is contributed by Aditya Kumar (adityakumar129) // C program to check if three sides form a triangle or not // function to check if three sider form a triangle or not // Java program to check validity of any triangle # Python3 program to check if three # function to check if three sides // This code is contributed by Nitin Mittal. // Javascript program to check if three // function to check if three sider // PHP program to check if three // function to check if three sider"
    },
    {
        "link": "https://codesansar.com/python-programming-examples/check-validity-triangle-given-sides.htm",
        "document": "Python Program to Check Validity of Triangle Given Three Sides\n\nThis program checks whether given three sides of a triangle forms a valid triangle or not.\n\nIf a, b and c are three sides of triangle then following conditions must be satisfied for a valid triangle."
    },
    {
        "link": "https://stackoverflow.com/questions/58060370/what-is-the-preferred-way-of-returning-a-boolean-in-a-python-function",
        "document": "Is one of these preferred over the other?\n\nI prefer #2, but I can see why people might like #1 too."
    },
    {
        "link": "https://stackoverflow.com/questions/53060094/best-practices-to-return-boolean-value-from-function-hardcode-or-from-variable",
        "document": "Which is best practices to return Boolean value from a function:\n\nAccording to me returning hardcode value ( or ) is good.\n\n[More details] I always return two parameter from every function, and . A is Boolean object i.e. value is or . A is dictionary object.\n\nAs have a value i.e. is referring address of .\n\nSo returning reference variable name is good practices or actual bool value ?"
    },
    {
        "link": "https://realpython.com/python-return-statement",
        "document": "The Python statement is a special statement that you can use inside a function or method to send the function’s result back to the caller. A statement consists of the keyword followed by an optional return value. The return value of a Python function can be any Python object, and you can use them to perform further computation in your programs.\n\nUsing the statement effectively is a core skill if you want to code custom functions that are Pythonic and robust.\n\nIn this tutorial, you’ll learn that:\n• You use to send objects from your functions back to the caller code.\n• You can use to return one single value or multiple values separated by commas.\n• You should try to keep your code readable and maintainable by avoiding complex statements.\n\nWith this knowledge, you’ll be able to write more readable, maintainable, and concise functions in Python. If you’re totally new to Python functions, then you can check out Defining Your Own Python Function before diving into this tutorial.\n\nMost programming languages allow you to assign a name to a code block that performs a concrete computation. These named code blocks can be reused quickly because you can use their name to call them from different places in your code. Programmers call these named code blocks subroutines, routines, procedures, or functions depending on the language they use. In some languages, there’s a clear difference between a routine or procedure and a function. Sometimes that difference is so strong that you need to use a specific keyword to define a procedure or subroutine and another keyword to define a function. For example the Visual Basic programming language uses and to differentiate between the two. In general, a procedure is a named code block that performs a set of actions without computing a final value or result. On the other hand, a function is a named code block that performs some actions with the purpose of computing a final value or result, which is then sent back to the caller code. Both procedures and functions can act upon a set of input values, commonly known as arguments. In Python, these kinds of named code blocks are known as functions because they always send a value back to the caller. The Python documentation defines a function as follows: A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body. (Source) Even though the official documentation states that a function “returns some value to the caller,” you’ll soon see that functions can return any Python object to the caller code. In general, a function takes arguments (if any), performs some operations, and returns a value (or object). The value that a function returns to the caller is generally known as the function’s return value. All Python functions have a return value, either explicit or implicit. You’ll cover the difference between explicit and implicit return values later in this tutorial. To write a Python function, you need a header that starts with the keyword, followed by the name of the function, an optional list of comma-separated arguments inside a required pair of parentheses, and a final colon. The second component of a function is its code block, or body. Python defines code blocks using indentation instead of brackets, and keywords, and so on. So, to define a function in Python you can use the following syntax: When you’re coding a Python function, you need to define a header with the keyword, the name of the function, and a list of arguments in parentheses. Note that the list of arguments is optional, but the parentheses are syntactically required. Then you need to define the function’s code block, which will begin one level of indentation to the right. In the above example, you use a statement. This kind of statement is useful when you need a placeholder statement in your code to make it syntactically correct, but you don’t need to perform any action. statements are also known as the null operation because they don’t perform any action. Note: The full syntax to define functions and their arguments is beyond the scope of this tutorial. For an in-depth resource on this topic, check out Defining Your Own Python Function. To use a function, you need to call it. A function call consists of the function’s name followed by the function’s arguments in parentheses: You’ll need to pass arguments to a function call only if the function requires them. The parentheses, on the other hand, are always required in a function call. If you forget them, then you won’t be calling the function but referencing it as a function object. To make your functions return a value, you need to use the Python statement. That’s what you’ll cover from this point on.\n\nThe Python statement is a special statement that you can use inside a function or method to send the function’s result back to the caller. A statement consists of the keyword followed by an optional return value. The return value of a Python function can be any Python object. Everything in Python is an object. So, your functions can return numeric values ( , , and values), collections and sequences of objects ( , , , or objects), user-defined objects, classes, functions, and even modules or packages. You can omit the return value of a function and use a bare without a return value. You can also omit the entire statement. In both cases, the return value will be . In the next two sections, you’ll cover the basics of how the statement works and how you can use it to return the function’s result back to the caller code. An explicit statement immediately terminates a function execution and sends the return value back to the caller code. To add an explicit statement to a Python function, you need to use followed by an optional return value: When you define , you add an explicit statement ( ) at the end of the function’s code block. is the explicit return value of . This means that any time you call , the function will send back to the caller. Note: You can use explicit statements with or without a return value. If you build a statement without specifying a return value, then you’ll be implicitly returning . If you define a function with an explicit statement that has an explicit return value, then you can use that return value in any expression: Since returns a numeric value, you can use that value in a math expression or any other kind of expression in which the value has a logical or coherent meaning. This is how a caller code can take advantage of a function’s return value. Note that you can use a statement only inside a function or method definition. If you use it anywhere else, then you’ll get a : When you use outside a function or method, you get a telling you that the statement can’t be used outside a function. Note: Regular methods, class methods, and static methods are just functions within the context of Python classes. So, all the statement concepts that you’ll cover apply to them as well. You can use any Python object as a return value. Since everything in Python is an object, you can return strings, lists, tuples, dictionaries, functions, classes, instances, user-defined objects, and even modules or packages. For example, say you need to write a function that takes a list of integers and returns a list containing only the even numbers in the original list. Here’s a way of coding this function: uses a list comprehension to create a list that filters out the odd numbers in the original . Then the function returns the resulting list, which contains only even numbers. A common practice is to use the result of an expression as a return value in a statement. To apply this idea, you can rewrite as follows: The list comprehension gets evaluated and then the function returns with the resulting list. Note that you can only use expressions in a statement. Expressions are different from statements like conditionals or loops. Note: Even though comprehensions are built using and (optionally) keywords, they’re considered expressions rather than statements. That’s why you can use them in a statement. For a further example, say you need to calculate the mean of a sample of numeric values. To do that, you need to divide the sum of the values by the number of values. Here’s an example that uses the built-in functions and : In , you don’t use a local variable to store the result of the calculation. Instead, you use the expression directly as a return value. Python first evaluates the expression and then returns the result of the evaluation, which in this case is the value . A Python function will always have a return value. There is no notion of procedure or routine in Python. So, if you don’t explicitly use a return value in a statement, or if you totally omit the statement, then Python will implicitly return a default value for you. That default return value will always be . Say you’re writing a function that adds to a number , but you forget to supply a statement. In this case, you’ll get an implicit statement that uses as a return value: # No return statement at all If you don’t supply an explicit statement with an explicit return value, then Python will supply an implicit statement using as a return value. In the above example, adds to and stores the value in but it doesn’t return . That’s why you get instead of . To fix the problem, you need to either or directly . An example of a function that returns is . The goal of this function is to print objects to a text stream file, which is normally the standard output (your screen). So, this function doesn’t need an explicit statement because it doesn’t return anything useful or meaningful: The call to prints to the screen. Since this is the purpose of , the function doesn’t need to return anything useful, so you get as a return value. Note: The Python interpreter doesn’t display . So, to show a return value of in an interactive session, you need to explicitly use . Regardless of how long and complex your functions are, any function without an explicit statement, or one with a statement without a return value, will return .\n\nIf you’re working in an interactive session, then you might think that printing a value and returning a value are equivalent operations. Consider the following two functions and their output: Both functions seem to do the same thing. In both cases, you see printed on your screen. There’s only a subtle visible difference—the single quotation marks in the second example. But take a look at what happens if you return another data type, say an object: There’s no visible difference now. In both cases, you can see on your screen. That behavior can be confusing if you’re just starting with Python. You might think that returning and printing a value are equivalent actions. Now, suppose you’re getting deeper into Python and you’re starting to write your first script. You open a text editor and type the following code: takes two numbers, adds them, and returns the result. On line 5, you call to sum plus . Since you’re still learning the difference between returning and printing a value, you might expect your script to print to the screen. However, that’s not what happens, and you get nothing on your screen. Try it out by yourself. Save your script to a file called and run it from your command line as follows: If you run from your command line, then you won’t see any result on your screen. That’s because when you run a script, the return values of the functions that you call in the script don’t get printed to the screen like they do in an interactive session. If you want that your script to show the result of calling on your screen, then you need to explicitly call . Check out the following update of : Now, when you run , you’ll see the number on your screen. So, if you’re working in an interactive session, then Python will show the result of any function call directly to your screen. But if you’re writing a script and you want to see a function’s return value, then you need to explicitly use .\n\nYou can use a statement to return multiple values from a function. To do that, you just need to supply several return values separated by commas. For example, suppose you need to write a function that takes a sample of numeric data and returns a summary of statistical measures. To code that function, you can use the Python standard module , which provides several functions for calculating mathematical statistics of numeric data. Here’s a possible implementation of your function: In , you take advantage of Python’s ability to return multiple values in a single statement by returning the mean, median, and mode of the sample at the same time. Note that, to return multiple values, you just need to write them in a comma-separated list in the order you want them returned. Note: If your functions needs several different return types, then you’re dealing with a more complex scenario. In this case, you can get some help from How to Use Type Hints for Multiple Return Types in Python. Once you’ve coded , you can take advantage of a powerful Python feature known as iterable unpacking to unpack the three measures into three separated variables, or you can just store everything in one variable: Here, you unpack the three return values of into the variables , , and . Note that in the last example, you store all the values in a single variable, , which turns out to be a Python . Note: You can build a Python by just assigning several comma-separated values to a single variable. There’s no need to use parentheses to create a . That’s why multiple return values are packed in a . The built-in function is also an example of a function that returns multiple values. The function takes two (non-complex) numbers as arguments and returns two numbers, the quotient of the two input values and the remainder of the division: The call to returns a tuple containing the quotient and remainder that result from dividing the two non-complex numbers provided as arguments. This is an example of a function with multiple return values.\n\nUsing the Python Statement: Best Practices So far, you’ve covered the basics of how the Python statement works. You now know how to write functions that return one or multiple values to the caller. Additionally, you’ve learned that if you don’t add an explicit statement with an explicit return value to a given function, then Python will add it for you. That value will be . In this section, you’ll cover several examples that will guide you through a set of good programming practices for effectively using the statement. These practices will help you to write more readable, maintainable, robust, and efficient functions in Python. Some programmers rely on the implicit statement that Python adds to any function without an explicit one. This can be confusing for developers who come from other programming languages in which a function without a return value is called a procedure. There are situations in which you can add an explicit to your functions. In other situations, however, you can rely on Python’s default behavior:\n• If your function performs actions but doesn’t have a clear and useful value, then you can omit returning because doing that would just be superfluous and confusing. You can also use a bare without a return value just to make clear your intention of returning from the function.\n• If your function has multiple statements and returning is a valid option, then you should consider the explicit use of instead of relying on the Python’s default behavior. These practices can improve the readability and maintainability of your code by explicitly communicating your intent. When it comes to returning , you can use one of three possible approaches:\n• Omit the statement and rely on the default behavior of returning .\n• Use a bare without a return value, which also returns . Here’s how this works in practice: Whether or not to return explicitly is a personal decision. However, you should consider that in some cases, an explicit can avoid maintainability problems. This is especially true for developers who come from other programming languages that don’t behave like Python does. When writing custom functions, you might accidentally forget to return a value from a function. In this case, Python will return for you. This can cause subtle bugs that can be difficult for a beginning Python developer to understand and debug. You can avoid this problem by writing the statement immediately after the header of the function. Then you can make a second pass to write the function’s body. Here’s a template that you can use when coding your Python functions: If you get used to starting your functions like this, then chances are that you’ll no longer miss the statement. With this approach, you can write the body of the function, test it, and rename the variables once you know that the function works. This practice can increase your productivity and make your functions less error-prone. It can also save you a lot of debugging time. As you saw before, it’s a common practice to use the result of an expression as a return value in Python functions. If the expression that you’re using gets too complex, then this practice can lead to functions that are difficult to understand, debug, and maintain. For example, if you’re doing a complex calculation, then it would be more readable to incrementally calculate the final result using temporary variables with meaningful names. Consider the following function that calculates the variance of a sample of numeric data: The expression that you use here is quite complex and difficult to understand. It’s also difficult to debug because you’re performing multiple operations in a single expression. To work around this particular problem, you can take advantage of an incremental development approach that improves the readability of the function. Take a look at the following alternative implementation of : In this second implementation of , you calculate the variance in several steps. Each step is represented by a temporary variable with a meaningful name. Temporary variables like , , and are often helpful when it comes to debugging your code. If, for example, something goes wrong with one of them, then you can call to know what’s happening before the statement runs. In general, you should avoid using complex expressions in your statement. Instead, you can break your code into multiple steps and use temporary variables for each step. Using temporary variables can make your code easier to debug, understand, and maintain. Functions that don’t have an explicit statement with a meaningful return value often preform actions that have side effects. A side effect can be, for example, printing something to the screen, modifying a global variable, updating the state of an object, writing some text to a file, and so on. Modifying global variables is generally considered a bad programming practice. Just like programs with complex expressions, programs that modify global variables can be difficult to debug, understand, and maintain. When you modify a global variable, you’re potentially affecting all the functions, classes, objects, and any other parts of your programs that rely on that global variable. To understand a program that modifies global variables, you need to be aware of all the parts of the program that can see, access, and change those variables. So, good practice recommends writing self-contained functions that take some arguments and return a useful value (or values) without causing any side effect on global variables. Additionally, functions with an explicit statement that return a meaningful value are easier to test than functions that modify or update global variables. The following example show a function that changes a global variable. The function uses the statement, which is also considered a bad programming practice in Python: In this example, you first create a global variable, , with an initial value of . Inside , you use a statement to tell the function that you want to modify a global variable. The last statement increments by . The result of calling will depend on the initial value of . Different initial values for will generate different results, so the function’s result can’t be controlled by the function itself. To avoid this kind of behavior, you can write a self-contained that takes arguments and returns a coherent value that depends only on the input arguments: # Explicitly assign a new value to counter Now the result of calling depends only on the input arguments rather than on the initial value of . This makes the function more robust and easier to test. Note: For a better understanding of how to test your Python code, check out Test-Driven Development With PyTest. If you’d like a deeper dive into using global variables in functions, then Using and Creating Global Variables in Your Python Functions is for you. Additionally, when you need to update , you can do so explicitly with a call to . This way, you’ll have more control over what’s happening with throughout your code. In general, it’s a good practice to avoid functions that modify global variables. If possible, try to write self-contained functions with an explicit statement that returns a coherent and meaningful value. Python functions are not restricted to having a single statement. If a given function has more than one statement, then the first one encountered will determine the end of the function’s execution and also its return value. A common way of writing functions with multiple statements is to use conditional statements that allow you to provide different statements depending on the result of evaluating some conditions. Suppose you need to code a function that takes a number and returns its absolute value. If the number is greater than , then you’ll return the same number. If the number is less than , then you’ll return its opposite, or non-negative value. Here’s a possible implementation for this function: has two explicit statements, each of them wrapped in its own statement. It also has an implicit statement. If happens to be , then neither condition is true, and the function ends without hitting any explicit statement. When this happens, you automatically get . Take a look at the following call to using as an argument: When you call using as an argument, you get as a result. That’s because the flow of execution gets to the end of the function without reaching any explicit statement. Unfortunately, the absolute value of is , not . To fix this problem, you can add a third statement, either in a new clause or in a final clause: Now, checks every possible condition, , , and . The purpose of this example is to show that when you’re using conditional statements to provide multiple statements, you need to make sure that every possible option gets its own statement. Otherwise, your function will have a hidden bug. Finally, you can implement in a more concise, efficient, and Pythonic way using a single statement: In this case, your function hits the first statement if . In all other cases, whether or , it hits the second statement. With this new implementation, your function looks a lot better. It’s more readable, concise, and efficient. Note: There’s a convenient built-in Python function called for computing the absolute value of a number. The function in the above example is intended only to illustrate the point under discussion. If you’re using statements to provide several statements, then you don’t need an clause to cover the last condition. Just add a statement at the end of the function’s code block and at the first level of indentation. Another common use case for the combination of and statements is when you’re coding a predicate or Boolean-valued function. This kind of function returns either or according to a given condition. For example, say you need to write a function that takes two integers, and , and returns if is divisible by . Otherwise, the function should return . Here’s a possible implementation: returns if the remainder of dividing by is equal to . Otherwise, it returns . Note that in Python, a value is falsy, so you need to use the operator to negate the truth value of the condition. Sometimes you’ll write predicate functions that involve operators like the following: In these cases, you can directly use a Boolean expression in your statement. This is possible because these operators return either or . Following this idea, here’s a new implementation of : If is divisible by , then returns , which is falsy in Python. So, to return , you need to use the operator. Note: Python follows a set of rules to determine the truth value of an object. For example, the following objects are considered falsy:\n• Numeric types with a zero value like , , , , and\n• Empty sequences and collections like , , , , , and\n• Objects that implement with a return value of or with a return value of Any other object will be considered truthy. On the other hand, if you try to use conditions that involve Boolean operators like and in the way you saw before, then your predicate functions won’t work correctly. That’s because these operators behave differently. They return one of the operands in the condition rather than or : In general, returns the first false operand or the last operand. On the other hand, returns the first true operand or the last operand. So, to write a predicate that involves one of these operators, you’ll need to use an explicit statement or a call to the built-in function . Suppose you want to write a predicate function that takes two values and returns if both are true and otherwise. Here’s your first approach to this function: Since returns operands instead of or , your function doesn’t work correctly. There are at least three possibilities for fixing this problem: If you use the first approach, then you can write as follows: The statement checks if and are both truthy. If so, then returns . Otherwise, it returns . If, on the other hand, you use a Python conditional expression or ternary operator, then you can write your predicate function as follows: Here, you use a conditional expression to provide a return value for . The conditional expression is evaluated to if both and are truthy. Otherwise, the final result is . Finally, if you use , then you can code as follows: returns if and are true and otherwise. It’s up to you what approach to use for solving this problem. However, the second solution seems more readable. What do you think? A statement inside a loop performs some kind of short-circuit. It breaks the loop execution and makes the function return immediately. To better understand this behavior, you can write a function that emulates . This built-in function takes an iterable and returns if at least one of its items is truthy. To emulate , you can code a function like the following: If any in is true, then the flow of execution enters in the block. The statement breaks the loop and returns immediately with a return value of . If no value in is true, then returns . This function implements a short-circuit evaluation. For example, suppose that you pass an iterable that contains a million items. If the first item in that iterable happens to be true, then the loop runs only one time rather than a million times. This can save you a lot of processing time when running your code. It’s important to note that to use a statement inside a loop, you need to wrap the statement in an statement. Otherwise, the loop will always break in its first iteration. As soon as a function hits a statement, it terminates without executing any subsequent code. Consequently, the code that appears after the function’s statement is commonly called dead code. The Python interpreter totally ignores dead code when running your functions. So, having that kind of code in a function is useless and confusing. Consider the following function, which adds code after its statement: The statement in this example will never execute because that statement appears after the function’s statement. Identifying dead code and removing it is a good practice that you can apply to write better functions. It’s worth noting that if you’re using conditional statements to provide multiple statements, then you can have code after a statement that won’t be dead as long as it’s outside the statement: Even though the call to is after a statement, it’s not dead code. When is evaluated to , the call is run and you get printed to your screen. When you’re writing a function that returns multiple values in a single statement, you can consider using a object to make your functions more readable. is a collection class that returns a subclass of that has fields or attributes. You can access those attributes using dot notation or an indexing operation. The initializer of takes several arguments. However, to start using in your code, you just need to know about the first two:\n• holds the name of the tuple-like class that you’re creating. It needs to be a string.\n• holds the names of the fields or attributes of the tuple-like class. It can be a sequence of strings such as or a single string with each name separated by whitespace or commas, such as or . Using a when you need to return multiple values can make your functions significantly more readable without too much effort. Consider the following update of using a as a return value: Inside , you create a called . This object can have named attributes that you can access by using dot notation or by using an indexing operation. In this example, those attributes are , , and . You can create a object and use it as a return value. To do that, you need to instantiate like you’d do with any Python class. Note that you need to supply a concrete value for each named attribute, just like you did in your statement. # Get the mean by its attribute name # Get the median by its index # Unpack the values into three variables When you call with a sample of numeric data, you get a object containing the mean, median, and mode of the sample. Note that you can access each element of the tuple by using either dot notation or an indexing operation. Finally, you can also use an iterable unpacking operation to store each value in its own independent variable.\n\nIn Python, functions are first-class objects. A first-class object is an object that can be assigned to a variable, passed as an argument to a function, or used as a return value in a function. So, you can use a function object as a return value in any statement. A function that takes a function as an argument, returns a function as a result, or both is a higher-order function. A closure factory function is a common example of a higher-order function in Python. This kind of function takes some arguments and returns an inner function. The inner function is commonly known as a closure. A closure carries information about its enclosing execution scope. This provides a way to retain state information between function calls. Closure factory functions are useful when you need to write code based on the concept of lazy or delayed evaluation. Suppose you need to write a helper function that takes a number and returns the result of multiplying that number by a given factor. You can code that function as follows: takes and as arguments and returns their product. Since rarely changes in your application, you find it annoying to supply the same factor in every function call. So, you need a way to retain the state or value of between calls to and change it only when needed. To retain the current value of between calls, you can use a closure. The following implementation of uses a closure to retain the value of between calls: Inside , you define an inner function called and return it without calling it. The function object you return is a closure that retains information about the state of . In other words, it remembers the value of between calls. That’s why remembers that was equal to and remembers that was equal to . Note that you can freely reuse and because they don’t forget their respective state information. You can also use a function to create closures. Sometimes the use of a function can make your closure factory more concise. Here’s an alternative implementation of using a function: This implementation works just like the original example. In this case, the use of a function provides a quick and concise way to code .\n\nAnother way of using the statement for returning function objects is to write decorator functions. A decorator function takes a function object as an argument and returns a function object. The decorator processes the decorated function in some way and returns it or replaces it with another function or callable object. Decorators are useful when you need to add extra logic to existing functions without modifying them. For example, you can code a decorator to log function calls, validate the arguments to a function, measure the execution time of a given function, and so on. The following example shows a decorator function that you can use to get an idea of the execution time of a given Python function: The syntax above the header of is equivalent to the expression . In this case, you can say that is decorating . Python runs decorator functions as soon as you import or run a module or a script. So, when you call , you’re really calling the return value of , which is the function object . The call to the decorated will return the mean of the sample and will also measure the execution time of the original . In this case, you use to measure the execution time inside the decorator. lives in a module called that provides a set of time-related functions. returns the time in seconds since the epoch as a floating-point number. The difference between the time before and after the call to will give you an idea of the function’s execution time. Note: In , you use the function , which suspends the execution of the calling code for a given number of seconds. For a better understanding on how to use , check out Python sleep(): How to Add Time Delays to Your Code. Other common examples of decorators in Python are , , and . If you want to dive deeper into Python decorators, then take a look at Primer on Python Decorators. You can also check out Python Decorators 101.\n\nThe Python statement allows you to send any Python object from your custom functions back to the caller code. This statement is a fundamental part of any Python function or method. If you master how to use it, then you’ll be ready to code robust functions. Next, you’ll find common questions that sum up the most important concepts you’ve learned in this tutorial. You can use these questions to check, recap, and solidify your knowledge. After each question, you’ll find an answer hidden in a collapsible section. Click the Show/Hide toggle to reveal it. But first, try to come up with the answer on your own. What’s the difference between explicit and implicit return statements?Show/Hide An explicit statement immediately ends the function’s execution and sends the specified value back to the caller. For example, a function can return a number, a list, or any other object. If no return statement is present, Python adds one implicitly, which returns . How do I return single or multiple values from my functions to the caller code?Show/Hide In Python, the statement allows you to send values back to the caller from a function. To return a single value, use the keyword followed by the value. This can be any data type, such as a number, string, list, or object. To return multiple values, list them after the return keyword separated by commas. Python packs these values into a tuple. You can then unpack the tuple into separate variables or store it as a single variable. What are the best practices I should apply when using the return statement?Show/Hide First, explicitly return when appropriate. If your function should return , do so explicitly with for clarity. However, if your function performs actions without a clear return value, you can omit the statement and rely on Python implicitly returning . Additionally, avoid complex return expressions. Instead, break them down to improve readability and debugging. You can also use short-circuiting in loops to simplify your code. Employ statements inside loops to exit early when a condition is met, saving processing time. You should also prefer self-contained functions over those that modify global variables, and when using conditional returns, handle all possible conditions with appropriate return statements to avoid hidden bugs. Creating a closure factory function involves making a function that returns another function. This inner function retains access to the variables from the outer function. It’s perfect for situations where you want to keep some state information between calls. For decorator functions, you write a function that takes another function, adds some extra functionality, and returns this new function. Decorators are great for tasks like logging and timing that aren’t central to the original function’s purpose. Do you want to take a quick quiz to evaluate your new skills? If so, then click the link below: Test your knowledge with our interactive “The Python return Statement” quiz. You’ll receive a score upon completion to help you track your learning progress: In this quiz, you can practice your understanding of how to use the Python return statement when writing functions. Additionally, you'll cover some good programming practices related to the use of return. With this knowledge, you'll be able to write readable, robust, and maintainable functions in Python."
    },
    {
        "link": "https://w3schools.com/python/python_booleans.asp",
        "document": "Booleans represent one of two values: or .\n\nIn programming you often need to know if an expression is or .\n\nYou can evaluate any expression in Python, and get one of two answers, or .\n\nWhen you compare two values, the expression is evaluated and Python returns the Boolean answer:\n\nWhen you run a condition in an if statement, Python returns or :\n\nThe function allows you to evaluate any value, and give you or in return,\n\nAlmost any value is evaluated to if it has some sort of content.\n\nAny string is , except empty strings.\n\nAny number is , except .\n\nAny list, tuple, set, and dictionary are , except empty ones.\n\nIn fact, there are not many values that evaluate to , except empty values, such as , , , , the number , and the value . And of course the value evaluates to .\n\nOne more value, or object in this case, evaluates to , and that is if you have an object that is made from a class with a function that returns or :\n\nYou can create functions that returns a Boolean Value:\n\nYou can execute code based on the Boolean answer of a function:\n\nPython also has many built-in functions that return a boolean value, like the function, which can be used to determine if an object is of a certain data type:"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-return-boolean-from-function-450805",
        "document": "In Python programming, returning boolean values from functions is a fundamental skill that enables developers to create more precise and logical code. This tutorial will guide you through the essential techniques of returning boolean values, helping you understand how to implement conditional logic and make your functions more expressive and efficient.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL python((\"Python\")) -.-> python/BasicConceptsGroup([\"Basic Concepts\"]) python((\"Python\")) -.-> python/ControlFlowGroup([\"Control Flow\"]) python((\"Python\")) -.-> python/FunctionsGroup([\"Functions\"]) python/BasicConceptsGroup -.-> python/booleans(\"Booleans\") python/ControlFlowGroup -.-> python/conditional_statements(\"Conditional Statements\") python/FunctionsGroup -.-> python/function_definition(\"Function Definition\") python/FunctionsGroup -.-> python/arguments_return(\"Arguments and Return Values\") python/FunctionsGroup -.-> python/lambda_functions(\"Lambda Functions\") subgraph Lab Skills python/booleans -.-> lab-450805{{\"How to return boolean from function\"}} python/conditional_statements -.-> lab-450805{{\"How to return boolean from function\"}} python/function_definition -.-> lab-450805{{\"How to return boolean from function\"}} python/arguments_return -.-> lab-450805{{\"How to return boolean from function\"}} python/lambda_functions -.-> lab-450805{{\"How to return boolean from function\"}} end"
    }
]