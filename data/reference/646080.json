[
    {
        "link": "https://docs.python.org/3/library/csv.html",
        "document": "The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in RFC 4180. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.\n\nThe module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.\n\nThe module’s and objects read and write sequences. Programmers can also read and write data in dictionary form using the and classes.\n\nThe module defines the following functions: Return a reader object that will process lines from the given csvfile. A csvfile must be an iterable of strings, each in the reader’s defined csv format. A csvfile is most commonly a file-like object or list. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed unless the format option is specified (in which case unquoted fields are transformed into floats). Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. csvfile can be any object with a method. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about dialects and formatting parameters, see the Dialects and Formatting Parameters section. To make it as easy as possible to interface with modules which implement the DB API, the value is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a call. All other non-string data are stringified with before being written. Associate dialect with name. name must be a string. The dialect can be specified either by passing a sub-class of , or by fmtparams keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about dialects and formatting parameters, see section Dialects and Formatting Parameters. Delete the dialect associated with name from the dialect registry. An is raised if name is not a registered dialect name. Return the dialect associated with name. An is raised if name is not a registered dialect name. This function returns an immutable . Return the names of all registered dialects. Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes the new limit. The module defines the following classes: Create an object that operates like a regular reader but maps the information in each row to a whose keys are given by the optional fieldnames parameter. The fieldnames parameter is a sequence. If fieldnames is omitted, the values in the first row of file f will be used as the fieldnames and will be omitted from the results. If fieldnames is provided, they will be used and the first row will be included in the results. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering. If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by restkey (which defaults to ). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with the value of restval (which defaults to ). All other optional or keyword arguments are passed to the underlying instance. If the argument passed to fieldnames is an iterator, it will be coerced to a . Changed in version 3.6: Returned rows are now of type . Changed in version 3.8: Returned rows are now of type . Create an object which operates like a regular writer but maps dictionaries onto output rows. The fieldnames parameter is a of keys that identify the order in which values in the dictionary passed to the method are written to file f. The optional restval parameter specifies the value to be written if the dictionary is missing a key in fieldnames. If the dictionary passed to the method contains a key not found in fieldnames, the optional extrasaction parameter indicates what action to take. If it is set to , the default value, a is raised. If it is set to , extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying instance. Note that unlike the class, the fieldnames parameter of the class is not optional. If the argument passed to fieldnames is an iterator, it will be coerced to a . The class is a container class whose attributes contain information for how to handle doublequotes, whitespace, delimiters, etc. Due to the lack of a strict CSV specification, different applications produce subtly different CSV data. instances define how and instances behave. All available names are returned by , and they can be registered with specific and classes through their initializer ( ) functions like this: The class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name . The class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name . The class defines the usual properties of a CSV file generated on UNIX systems, i.e. using as line terminator and quoting all fields. It is registered with the dialect name . The class is used to deduce the format of a CSV file. The class provides two methods: Analyze the given sample and return a subclass reflecting the parameters found. If the optional delimiters parameter is given, it is interpreted as a string containing possible valid delimiter characters. Analyze the sample text (presumed to be in CSV format) and return if the first row appears to be a series of column headers. Inspecting each column, one of two key criteria will be considered to estimate if the sample contains a header:\n• None the second through n-th rows contain numeric values\n• None the second through n-th rows contain strings where at least one value’s length differs from that of the putative header of that column. Twenty rows after the first row are sampled; if more than half of columns + rows meet the criteria, is returned. This method is a rough heuristic and may produce both false positives and negatives. An example for use: The module defines the following constants: Instructs objects to quote all fields. Instructs objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator. Instructs objects to quote all non-numeric fields. Instructs objects to convert all non-quoted fields to type float. Instructs objects to never quote fields. When the current delimiter occurs in output data it is preceded by the current escapechar character. If escapechar is not set, the writer will raise if any characters that require escaping are encountered. Instructs objects to perform no special processing of quote characters. Instructs objects to quote all fields which are not . This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) field as and to otherwise behave as . Instructs objects to always place quotes around fields which are strings. This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) string as and to otherwise behave as . The module defines the following exception: Raised by any of the functions when an error is detected.\n\nTo make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the class containing various attributes describing the format of the CSV file. When creating or objects, the programmer can specify a string or a subclass of the class as the dialect parameter. In addition to, or instead of, the dialect parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the class. A one-character string used to separate fields. It defaults to . Controls how instances of quotechar appearing inside a field should themselves be quoted. When , the character is doubled. When , the escapechar is used as a prefix to the quotechar. It defaults to . On output, if doublequote is and no escapechar is set, is raised if a quotechar is found in a field. A one-character string used by the writer to escape the delimiter if quoting is set to and the quotechar if doublequote is . On reading, the escapechar removes any special meaning from the following character. It defaults to , which disables escaping. Changed in version 3.11: An empty escapechar is not allowed. The string used to terminate lines produced by the . It defaults to . The is hard-coded to recognise either or as end-of-line, and ignores lineterminator. This behavior may change in the future. A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters. It defaults to . Changed in version 3.11: An empty quotechar is not allowed. Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the QUOTE_* constants and defaults to . When , spaces immediately following the delimiter are ignored. The default is . When , raise exception on bad CSV input. The default is .\n\nThe simplest example of reading a CSV file: The corresponding simplest possible writing example is: Since is used to open a CSV file for reading, the file will by default be decoded into unicode using the system default encoding (see ). To decode a file using a different encoding, use the argument of open: The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file. A slightly more advanced use of the reader — catching and reporting errors: And while the module doesn’t directly support parsing strings, it can easily be done:"
    },
    {
        "link": "https://docs.python.org/2/library/csv.html",
        "document": "The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. There is no “CSV standard”, so the format is operationally defined by the many applications which read and write it. The lack of a standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.\n\nThe module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.\n\nThe module’s and objects read and write sequences. Programmers can also read and write data in dictionary form using the and classes.\n\nThe module defines the following functions: Return a reader object which will iterate over lines in the given csvfile. csvfile can be any object which supports the iterator protocol and returns a string each time its method is called — file objects and list objects are both suitable. If csvfile is a file object, it must be opened with the ‘b’ flag on platforms where that makes a difference. An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed. Changed in version 2.5: The parser is now stricter with respect to multi-line quoted fields. Previously, if a line ended within a quoted field without a terminating newline character, a newline would be inserted into the returned field. This behavior caused problems when reading files which contained carriage return characters within fields. The behavior was changed to return the field without inserting newlines. As a consequence, if newlines embedded within fields are important, the input should be split into lines in a manner which preserves the newline characters. Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. csvfile can be any object with a method. If csvfile is a file object, it must be opened with the ‘b’ flag on platforms where that makes a difference. An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. To make it as easy as possible to interface with modules which implement the DB API, the value is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a call. Floats are stringified with before being written. All other non-string data are stringified with before being written. Associate dialect with name. name must be a string or Unicode object. The dialect can be specified either by passing a sub-class of , or by fmtparams keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. Delete the dialect associated with name from the dialect registry. An is raised if name is not a registered dialect name. Return the dialect associated with name. An is raised if name is not a registered dialect name. Changed in version 2.5: This function now returns an immutable . Previously an instance of the requested dialect was returned. Users could modify the underlying class, changing the behavior of active readers and writers. Return the names of all registered dialects. Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes the new limit. The module defines the following classes: Create an object which operates like a regular reader but maps the information read into a dict whose keys are given by the optional fieldnames parameter. The fieldnames parameter is a sequence whose elements are associated with the fields of the input data in order. These elements become the keys of the resulting dictionary. If the fieldnames parameter is omitted, the values in the first row of the file f will be used as the fieldnames. If the row read has more fields than the fieldnames sequence, the remaining data is added as a sequence keyed by the value of restkey. If the row read has fewer fields than the fieldnames sequence, the remaining keys take the value of the optional restval parameter. Any other optional or keyword arguments are passed to the underlying instance. Create an object which operates like a regular writer but maps dictionaries onto output rows. The fieldnames parameter is a sequence of keys that identify the order in which values in the dictionary passed to the method are written to the file f. The optional restval parameter specifies the value to be written if the dictionary is missing a key in fieldnames. If the dictionary passed to the method contains a key not found in fieldnames, the optional extrasaction parameter indicates what action to take. If it is set to a is raised. If it is set to , extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying instance. Note that unlike the class, the fieldnames parameter of the is not optional. Since Python’s objects are not ordered, there is not enough information available to deduce the order in which the row should be written to the file f. The class is a container class relied on primarily for its attributes, which are used to define the parameters for a specific or instance. The class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name . The class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name . The class is used to deduce the format of a CSV file. The class provides two methods: Analyze the given sample and return a subclass reflecting the parameters found. If the optional delimiters parameter is given, it is interpreted as a string containing possible valid delimiter characters. Analyze the sample text (presumed to be in CSV format) and return if the first row appears to be a series of column headers. An example for use: The module defines the following constants: Instructs objects to quote all fields. Instructs objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator. Instructs objects to quote all non-numeric fields. Instructs the reader to convert all non-quoted fields to type float. Instructs objects to never quote fields. When the current delimiter occurs in output data it is preceded by the current escapechar character. If escapechar is not set, the writer will raise if any characters that require escaping are encountered. Instructs to perform no special processing of quote characters. The module defines the following exception: Raised by any of the functions when an error is detected.\n\nTo make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the class having a set of specific methods and a single method. When creating or objects, the programmer can specify a string or a subclass of the class as the dialect parameter. In addition to, or instead of, the dialect parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the class. A one-character string used to separate fields. It defaults to . Controls how instances of quotechar appearing inside a field should themselves be quoted. When , the character is doubled. When , the escapechar is used as a prefix to the quotechar. It defaults to . On output, if doublequote is and no escapechar is set, is raised if a quotechar is found in a field. A one-character string used by the writer to escape the delimiter if quoting is set to and the quotechar if doublequote is . On reading, the escapechar removes any special meaning from the following character. It defaults to , which disables escaping. The string used to terminate lines produced by the . It defaults to . The is hard-coded to recognise either or as end-of-line, and ignores lineterminator. This behavior may change in the future. A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters. It defaults to . Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the constants (see section Module Contents) and defaults to . When , whitespace immediately following the delimiter is ignored. The default is . When , raise exception on bad CSV input. The default is .\n\nobjects ( instances and objects returned by the function) have the following public methods. A row must be a sequence of strings or numbers for objects and a dictionary mapping fieldnames to strings or numbers (by passing them through first) for objects. Note that complex numbers are written out surrounded by parens. This may cause some problems for other programs which read CSV files (assuming they support complex numbers at all). Write the row parameter to the writer’s file object, formatted according to the current dialect. Write all elements in rows (an iterable of row objects as described above) to the writer’s file object, formatted according to the current dialect. Writer objects have the following public attribute: A read-only description of the dialect in use by the writer. DictWriter objects have the following public method: Write a row with the field names (as specified in the constructor).\n\nThe simplest example of reading a CSV file: The corresponding simplest possible writing example is: A slightly more advanced use of the reader — catching and reporting errors: And while the module doesn’t directly support parsing strings, it can easily be done: The module doesn’t directly support reading and writing Unicode, but it is 8-bit-clean save for some problems with ASCII NUL characters. So you can write functions or classes that handle the encoding and decoding for you as long as you avoid encodings like UTF-16 that use NULs. UTF-8 is recommended. below is a generator that wraps to handle Unicode CSV data (a list of Unicode strings). is a generator that encodes the Unicode strings as UTF-8, one string (or row) at a time. The encoded strings are parsed by the CSV reader, and decodes the UTF-8-encoded cells back into Unicode: For all other encodings the following and classes can be used. They take an additional encoding parameter in their constructor and make sure that the data passes the real reader or writer encoded as UTF-8: Iterator that reads an encoded stream and reencodes the input to UTF-8 A CSV reader which will iterate over lines in the CSV file \"f\", which is encoded in the given encoding. A CSV writer which will write rows to CSV file \"f\", which is encoded in the given encoding. # ... and reencode it into the target encoding"
    },
    {
        "link": "http://2017.compciv.org/guide/topics/python-standard-library/csv.html",
        "document": "Comma-separated value data is likely the structured data format that we’re all most familiar with, due to CSV being easily-consumed by spreadsheet applications. It’s not a coincidence that CSV is easy to understand and inspect because it is just text, and a hugely popular format for data interchange.\n\nThat said, it is not as simple as its name would seem to promise. Assuming that each line of a CSV text file is a new row is hugely naive because of all the edge cases that arise in real-world dirty data. This is why we turn to Python’s csv library for both the reading of CSV data, and the writing of CSV data.\n\nUnderstanding CSV as just text values separated by commas¶ The name “comma-separated values” promises a data format with the easiest kind of parsing: use a comma to separate each data value. For simple data, it seems self-evident where the columns will go: Saving that as a text file and opening up in a spreadsheet would result in this simple table: If we wanted to parse each row’s age value, we could read the above text as one big string and split the string by lines: Try the above snippet in the interactive shell, and test out what actually is. Let’s pretend we wanted to print out the age “column” of each row, each row being a line of text, and being a list of lines of text: We could use a regular expression to extract the pattern that represents the age (a number at the end of the line). But we could also do something simpler: split the string by comma, which gives us a list of strings. And then the age value is the last value in that list: To print out the ages of each line using a for-loop: Unfortunately, the CSV specification is not simply, “a comma means that there is a column”. Take this example, in which the name isn’t , but . This throws an obvious wrench in our data structure: the “James Bond” column now has 4 columns, if we go only by literal commas: How are commas that are part of a data field handled? In some situations by double quoting the field: But what happens when a text field contains a comma and double quotes? Then you need to double-quote the field. But when we realize that there are many ways for text data to get messy – including the inclusion of newline characters within a column, rather than just what we use to delimit rows – then it becomes obvious the official CSV specification is more or less considered a disaster. Certainly, it is not possible to sanely extract data from CSV-formatted text using the string method and regular expressions alone. We need to use Python’s build in library.\n\nWhat is deserialization and serialization¶ Before moving on to the specifics of CSV, it’s important to see the big picture. As I’ve said from the very beginning, virtually all of the important data we deal with comes as plain text, whether it is: However, it’s not just raw text that we want. It needs to be structured text – text without structure is just noise. But when there is structure, then we can turn text into data objects – particularly, lists and dictionaries – that we can use in our programs. The csv library is Python’s built-in, no-fuss way of turning raw text into a list of lists, or list of dicts. If you can open a text file for reading, you can convert it into data via ‘s methods. Conversely, if you have lists and dicts in Python, you can serialize them to be stored as text, which means you can port your data objects in such a way that someone else can deserialize and import them for their own programs. Basically, all of what we learn here are the steps needed to turn raw text into data objects, and as far as we’re concerned, it’s just more libraries and functions to remember. I’ll be honest: if you thought reading and writing files was complicated, then I have to warn you that the library throws in extra layer of “is-this-thing-a-file-or-what-is-it??” confusion. Or at least it did for me – not until very late in my Python programming experience did it make sense to me why all the steps for converting raw text into data objects via csv were needed. But I’ll try to present the library as a list of useful recipes. You might not get all of the steps, but if you just follow, and repeat them, you’ll eventually understand the nuance of turning text into data, and vice versa. The important thing is, just by doing these steps, you’ll be able to turn text into data. And virtually all of the important data we deal with is text from someone else that we need to import into our program.\n\nFirst, to bring the library into our programs, we have to import it. Include this at the beginning of your work: For this lesson, let’s use a trivial data file. You can view it at this URL: The contents are simply this: And let’s have an end goal to our data work: we want to calculate the total age of each person in this data list You can do this however you like. You can copy/paste the simple bit of text and load it in as a string, and then invoke so that the variable is a list of text lines: Or you could download the contents of the URL as text and save yourself the copy-pasting of that data: Or you could do the full steps, from downloading the data, to saving a local copy, to then reading text from a file object: You can save those 4 lines of text in a text file named . Or you can store it in a string, with the variable name of . I’ll assume that for the remainder of this exercise, you have a variable named which is the result of either of these data loading steps: The function accepts either a file object, or a list of CSV-formmated text strings. So either of these setups would work in instantiating the object: If you managed to turn the raw text data into a file, which you then opened as a file-object, then this would work: Or, just pass in a list of CSV-formatted text strings: What is . Using reveals that it is a type-object with apparently no useful methods, such as or . In fact, we’re not meant to have any kind of special interaction with . It should be treated as a collection-type object to iterate through. For example, this is how to print each value for each line: Age is: age Age is: 24 Age is: 19 Age is: 42 Each in the iterator is a object. Index is the name value, and is the age value. As with all file operations, once we’ve iterated through a file object/stream, in this case, the stream that has wrapped around, re-running our loop from above will return nothing, because is exhausted of data. We have to re-load it with data, i.e. re-open and re-consume the text stream: However, we don’t have to interact with via a for-loop. We can pass into the function, which converts into a list of lists: Forcing the object to turn into a list is basically the same thing as creating an empty list, and looping through and appending each object of the iteration to the empty list: Either way, if you’re doing this in the shell, you can inspect the data structure as you please: Take a look at the last line of this interactive output. That is, what does the value look like to us humans and what do we want it to mean, versus, what does the Python interpreter think it is? Most humans associate “age” with anumber, so, Alice’s age is the number . However, in a plaintext import, numbers are always treated as text – the ``csv.reader() does not do any processing other than figuring the structure of the data based on the use of commas. That means our original goal of adding up ages will not work with simple, naive addition of values: If you’re coming here from R and its functionality <http://stackoverflow.com/questions/13265153/how-do-i-import-a-csv-file-in-r>`_, you’ll have to go to a high-level library like Pandas to get the same convenience in Python. We will be using for serious data-crunching. but as always, I recommend you think of the low-level ways of solving this problem, so you don’t mistake for magic. What can we use to convert a text string of numbers into actual numbers? The function: Let’s put it all together, from the code deserialziing raw text into Python data structures, to using a loop to read each age value, to writing the logic necessary to track the total age: Note that I add a couple of lines of boilerplate:\n• I initialize a variable with which I use to track the sum of ages.\n• I assign to . as the first row of the text data is just the column names. We don’t really need the column names to do the summation of ages, it just makes clearer why I skip the first row of in the for loop: Of course there are variations depending on how much you like brevity. Here’s a variation that doesn’t waste time turning into a list, when we can iterate through the reader object as if it were a list: And this is why we learn list comprehensions, a beautiful bit of Python syntax sugar:\n\nLet’s use the same simple data set found here: But this time, let’s parse the data using the class, which you can read about in the official documentation. Basically, works just like , except instead of giving us a list of lists, we get a list of dictionaries: Using the interactive shell to inspect the and objects: Initializing the class is the same process as , but the two methods differ in they process the lines of text. The method assumes that the first line is the column headers, and thus are not meant to be actual data. That’s why the version produced only 3 rows, compared to the 4 rows produced by , due to the header/column-heads being counted as a data row. Not much changes beyond that. To count up the ages using a list of dicts looks like this, but note how I don’t have to skip the first row in because I know it isn’t simply a header row: Note the column accessor is, depending on how you think of things, easier to grok because it uses a human-readable reference: Whereas with the list created by csv.reader, we have to remember that index 1 contains the age value in the dataset. Simple enough in a simple dataset, but not reasonabe in certain real-world scenarios. for all the situations when the data structure is better than a list. In particular, when datasets have a lot of columns, it is pretty much impossible to refer to columns by their numerical order. Take, for example, the NYPD Stop and Frisk Data (landing page). You can download the 2015 data here: The first thing you’ll notice is that there are a huge number of columns, more than a 100+. If we want to do a count of how many blacks were stopped and frisked in 2015, then we need to find the column, which might require reading the data documentation to find that it is column 82 (81 with a 0 index): 'blacks were stopped, out of' However, with dictionaries, we just have to know that there is a column named : 'blacks were stopped, out of' However, there are some datasets in which you don’t need that kind of dictionary key access. For example, a 2-column dataset. Or a dataset that has no headers."
    },
    {
        "link": "https://geeksforgeeks.org/reading-csv-files-in-python",
        "document": "A CSV (Comma Separated Values) file is a form of plain text document that uses a particular format to organize tabular information. CSV file format is a bounded text document that uses a comma to distinguish the values. Every row in the document is a data log. Each log is composed of one or more fields, divided by commas. It is the most popular file format for importing and exporting spreadsheets and databases.\n\n\n\nThere are various ways to read a CSV file in Python that use either the CSV module or the pandas library.\n• csv Module: The CSV module is one of the modules in Python that provides classes for reading and writing tabular information in CSV file format.\n• pandas Library: The pandas library is one of the open-source Python libraries that provide high-performance, convenient data structures and data analysis tools and techniques for Python programming. \n\n\n\n\n\nReading a CSV File Format in Python:\n\nConsider the below CSV file named ‘Giants.CSV’:\n\n\n\nAt first, the CSV file is opened using the open() method in ‘r’ mode(specifies read mode while opening a file) which returns the file object then it is read by using the reader() method of CSV module that returns the reader object that iterates throughout the lines in the specified CSV document.\n\nNote: The ‘with’ keyword is used along with the open() method as it simplifies exception handling and automatically closes the CSV file.\n\nExample: This code reads and prints the contents of a CSV file named ‘Giants.csv’ using the module in Python. It opens the file in read mode, reads the lines, and prints them one by one using a loop. The function is used to read the CSV file, and the data from each row is printed to the console.\n\nIt is similar to the previous method, the CSV file is first opened using the open() method then it is read by using the DictReader class of csv module which works like a regular reader but maps the information in the CSV file into a dictionary. The very first line of the file consists of dictionary keys.\n\nExample: This code reads and prints the contents of a CSV file named ‘Giants.csv’ using the module with . It opens the file in read mode, reads the lines, and prints them one by one. reads the CSV file and treats the first row as headers, creating a dictionary for each row where the header values are the keys. The code prints each row as a dictionary, making it easier to work with structured CSV data.\n\nIt is very easy and simple to read a CSV file using pandas library functions. Here read_csv() method of pandas library is used to read data from CSV files.\n\nExample: This code uses the library to read and display the contents of a CSV file named ‘Giants.csv.’ It reads the CSV file and stores it as a DataFrame using the function. Finally, it prints the entire DataFrame, which provides a structured and tabular representation of the CSV data. This is a common approach when working with tabular data in Python, as offers powerful tools for data manipulation and analysis.\n\nNote: To know more about pandas.csv_read() click here.\n\nWhat is the difference between using the csv module and pandas to read CSV files?\n\nHow do I read a CSV file in Python as a table?\n\nHow to read CSV file from folder in Python?\n\nHow do I read specific columns from a CSV file using pandas?\n\nCan I read a CSV file from a URL directly in Python?"
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/io.html",
        "document": "The pandas I/O API is a set of top level functions accessed like that generally return a pandas object. The corresponding functions are object methods that are accessed like . Below is a table containing available and .\n\nis an informal performance comparison for some of these IO methods.\n\nThe workhorse function for reading text files (a.k.a. flat files) is . See the for some advanced strategies. Either a path to a file (a , , or ), URL (including http, ftp, and S3 locations), or any object with a method (such as an open file or ). sep str, defaults to for , for Delimiter to use. If sep is , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: . Specifies whether or not whitespace (e.g. or ) will be used as the delimiter. Equivalent to setting . If this option is set to , nothing should be passed in for the parameter. Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so header=0 denotes the first line of data rather than the first line of the file. List of column names to use. If file contains no header row, then you should explicitly pass . Duplicates in this list are not allowed. Column(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. can be used to force pandas to use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line. The default value of instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header. The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with . This can be avoided through . This ensures that the columns are taken as is and the trailing data are ignored. Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True: Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop. dtype Type name or dict of column -> type, default Data type for data or columns. E.g. Use or together with suitable settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed. Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when “numpy_nullable” is set, pyarrow is used for all dtypes if “pyarrow” is set. The dtype_backends are still experimential. Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine. The “pyarrow” engine was added as an engine, and some features are unsupported, or may not work correctly, with this engine. Dict of functions for converting values in certain columns. Keys can either be integers or column labels. Values to consider as . Values to consider as . Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise: Number of lines at bottom of file to skip (unsupported with engine=’c’). Number of rows of file to read. Useful for reading pieces of large files. Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set , or specify the type with the parameter. Note that the entire file is read into a single regardless, use the or parameter to return the data in chunks. (Only valid with C parser) If a filepath is provided for , map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead. Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See below for a list of the values interpreted as NaN by default. Whether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default NaN values used for parsing.\n• None If is , and are not specified, only the default NaN values are used for parsing.\n• None If is , and are specified, only the NaN values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as NaN. Note that if is passed in as , the and parameters will be ignored. Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing can improve the performance of reading a large file. Indicate number of NA values placed in non-numeric columns. If , skip over blank lines rather than interpreting as NaN values. parse_dates boolean or list of ints or names or list of lists or dict, default .\n• None If -> try parsing the index.\n• None If -> try parsing columns 1, 2, 3 each as a separate date column.\n• None If -> combine columns 1 and 3 and parse as a single date column.\n• None If -> parse columns 1, 3 as date and call result ‘foo’. If and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing. A strict version of this argument is now the default, passing it has no effect. If and parse_dates specifies combining multiple columns then keep the original columns. Function to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments. Use instead, or read in as and then apply as-needed. If used in conjunction with , will parse dates according to this format. For anything more complex, please read in as and then apply as-needed. If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. Return object for iteration or getting chunks with . Return object for iteration. See below. For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , } and other key-value pairs are forwarded to , , , or . As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . Character to recognize as decimal point. E.g. use for European data. Specifies which converter the C engine should use for floating-point values. The options are for the ordinary converter, for the high-precision converter, and for the round-trip converter. Character to break file into lines. Only valid with C parser. The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored. Control field quoting behavior per constants. Use one of (0), (1), (2) or (3). When is specified and is not , indicate whether or not to interpret two consecutive elements inside a field as a single element. One-character string used to escape delimiter when quoting is . Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ), fully commented lines are ignored by the parameter but not by . For example, if , parsing ‘#empty\n\na,b,c\n\n1,2,3’ with will result in ‘a,b,c’ being treated as the header. Encoding to use for UTF when reading/writing (e.g. ). List of Python standard encodings. If provided, this parameter will override values (default or not) for the following parameters: , , , , , and . If it is necessary to override values, a ParserWarning will be issued. See documentation for more details. Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :\n• None ‘error’, raise an ParserError when a bad line is encountered.\n• None ‘warn’, print a warning when a bad line is encountered and skip that line.\n• None ‘skip’, skip bad lines without raising or warning when they are encountered. You can indicate the data type for the whole or individual columns: Fortunately, pandas offers more than one way to ensure that your column(s) contain only one . If you’re unfamiliar with these concepts, you can see to learn more about dtypes, and to learn more about conversion in pandas. For instance, you can use the argument of : Or you can use the function to coerce the dtypes after reading in the data, which will convert all valid parsing to floats, leaving the invalid parsing as . Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to out the data anomalies, then is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the argument of would certainly be worth trying. In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example, will result with containing an dtype for certain chunks of the column, and for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a of , which is used for columns with mixed dtypes. Setting will result in nullable dtypes for every column. columns can be parsed directly by specifying or . Individual columns can be parsed as a using a dict specification: Specifying will result in an unordered whose are the unique values observed in the data. For more control on the categories and order, create a ahead of time, and pass that for that column’s . When using , “unexpected” values outside of are treated as missing values. This matches the behavior of . With , the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the function, or as appropriate, another converter such as . When is a with homogeneous ( all numeric, all datetimes, etc.), the conversion is done automatically. A file may or may not have a header row. pandas assumes the first row should be used as the column names: By specifying the argument in conjunction with you can indicate other names to use and whether or not to throw away the header row (if any): If the header is in a row other than the first, pass the row number to . This will skip the preceding rows: Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to . If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data: There is no more duplicate data because duplicate columns ‘X’, …, ‘X’ become ‘X’, ‘X.1’, …, ‘X.N’. The argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable: The argument can also be used to specify which columns not to use in the final result: In this case, the callable is specifying that we exclude the “a” and “c” columns from the output. If the parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well. If , then will not ignore blank lines: The presence of ignored lines might create ambiguities involving line numbers; the parameter uses row numbers (ignoring commented/empty lines), while uses line numbers (including commented/empty lines): If both and are specified, will be relative to the end of . For example: Sometimes comments or meta data may be included in a file: By default, the parser includes the comments in the output: We can suppress the comments using the keyword: The argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result: Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. Full list of Python standard encodings. If a file has one more column of data than the number of column names, the first column will be used as the ’s row names: Ordinarily, you can achieve this behavior using the option. There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass : If a subset of data is being parsed using the option, the specification is based on that subset, not the original data. To better facilitate working with datetime data, uses the keyword arguments and to allow users to specify a variety of columns and date/time formats to turn the input text data into objects. The simplest case is to just pass in : # Use a column as an index, and parse it as dates. It is often the case that we may want to store date and time data separately, or store various date fields separately. the keyword can be used to specify a combination of columns to parse the dates and/or times from. You can specify a list of column lists to , the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names: By default the parser removes the component date columns, but you can choose to retain them via the keyword: Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, indicates that the second and third columns should each be parsed as separate date columns while means the two columns should be parsed into a single column. You can also use a dict to specify custom name columns: It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The specification is based off of this new set of columns rather than the original data columns: If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use after . read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed. Combining date columns inside read_csv is deprecated. Use on the relevant result columns instead. Finally, the parser allows you to specify a custom . Performance-wise, you should try these methods of parsing dates in order:\n• None If you know the format, use , e.g.: or .\n• None If you different formats for different columns, or want to pass any extra options (such as ) to , then you should read in your data as dtype, and then use . pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with . To parse the mixed-timezone values as a datetime column, read in as dtype and then call with . Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00): Note that format inference is sensitive to . With , it will guess “01/12/2011” to be December 1st. With (default) it will guess “01/12/2011” to be January 12th. If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is ), then a warning will be raised and each row will be parsed individually by . The safest way to parse dates is to explicitly set . In the case that you have mixed datetime formats within the same column, you can pass or, if your datetime formats are all ISO8601 (possibly not identically-formatted): While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a keyword is provided: allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify as Pandas will auto-detect whether the file object is opened in text or binary mode. The parameter can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example: For large numbers that have been written with a thousands separator, you can set the keyword to a string of length 1 so that integers will be parsed correctly: By default, numbers with a thousands separator will be parsed as strings: The keyword allows integers to be parsed correctly: To control which values are parsed as missing values (which are signified by ), specify a string in . If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a , like or an like ), the corresponding equivalent values will also imply a missing value (in this case effectively are recognized as ). To completely override the default values that are recognized as missing, specify . Let us consider some examples: In the example above and will be recognized as , in addition to the defaults. A string will first be interpreted as a numerical , then as a . Above, only an empty field will be recognized as . Above, both and as strings are . The default values, in addition to the string are recognized as . like values will be parsed as (positive infinity), and as (negative infinity). These will ignore the case of the value, meaning , will also be parsed as . The common values , , , and are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the and options as follows: Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default: Traceback (most recent call last) in in in in in in in in in : Error tokenizing data. C error: Expected 3 fields in line 3, saw 4 You can elect to skip bad lines: Or pass a callable function to handle the bad line if . The bad line will be a list of strings that was split by the : The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped. name a,a is of type a 'name,type\n\nname a,a is of type a\n\nname b,\"b\" is of type b\"' 0 name a a is of type a The line was not processed in this case, as a “bad line” here is caused by an escape character. You can also use the parameter to eliminate extraneous column data that appear in some lines but not others: Traceback (most recent call last) in in in in in in \"Usecols do not match columns, columns expected but not found: \" : Usecols do not match columns, columns expected but not found: [0, 1, 2] In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of . This ensures that lines with not enough fields are filled with . 1 name a a is of type a NaN NaN 2 name b b is of type b\" NaN NaN The keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a instance. Suppose you had data with unenclosed quotes: By default, uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote. We can get around this using : All of the dialect options can be specified separately by keyword arguments: Another common dialect option is , to skip any whitespace after a delimiter: The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects. Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the option: \"hello, \\\"Bob\\\", nice to see you\",5 0 hello, \"Bob\", nice to see you 5 While reads delimited data, the function works with data files that have known and fixed column widths. The function parameters to are largely the same as with two extra parameters, and a different usage of the parameter:\n• None : A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.\n• None : A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.\n• None : Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’). In order to parse this file into a , we simply need to supply the column specifications to the function along with the file name: Note how the parser automatically picks column names X.<column number> when argument is specified. Alternatively, you can supply just the column widths for contiguous columns: The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file. By default, will try to infer the file’s by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided (default delimiter is whitespace). supports the parameter for specifying the types of parsed columns to be different from the inferred type. Consider a file with one less entry in the header than the number of data column: In this special case, assumes that the first column is to be used as the index of the : Note that the dates weren’t automatically parsed. In that case you would need to do as before: Suppose you have data indexed by two columns: The argument to can take a list of column numbers to turn multiple columns into a for the index of the returned object: By specifying list of row locations for the argument, you can read in a for the columns. Specifying non-consecutive rows will skip the intervening rows. is also able to interpret a more common format of multi-columns indices. If an is not specified (e.g. you don’t have an index, or wrote it with , then any on the columns index will be . is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the class of the csv module. For this, you have to specify . It’s best to use to combine multiple files. See the for an example. Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following: By specifying a to , the return value will be an iterable object of type : Specifying will also return the object: Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine. Where possible, pandas uses the C parser (specified as ), but it may fall back to Python if C-unsupported options are specified. Currently, options unsupported by the C and pyarrow engines include: Specifying any of the above options will produce a unless the python engine is selected explicitly using . Options that are unsupported by the pyarrow engine which are not covered by the list above include: Specifying these options with will raise a . You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file: A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the keyword argument as shown below: All URLs which are not local files or HTTP(s) are handled by fsspec, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the s3fs library: When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the S3Fs documentation. The same is true for several of the storage backends, and you should follow the links at fsimpl1 for implementations built into and fsimpl2 for those not included in the main distribution. You can also pass parameters directly to the backend driver. Since does not utilize the environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter: More sample configurations and documentation can be found at S3Fs documentation. If you do have S3 credentials, you can still access public data by specifying an anonymous connection, such as also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store. The and objects have an instance method which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.\n• None : A string path to the file to write or a file object. If a file object it must be opened with\n• None : Whether to write out the column names (default True)\n• None : Column label(s) for index column(s) if desired. If None (default), and and are True, then the index names are used. (A sequence should be given if the uses MultiIndex).\n• None : a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3\n• None : Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric\n• None : Character used to quote fields (default ‘”’)\n• None : Character used to escape and when appropriate (default None)\n• None : Number of rows to write at a time The object has an instance method which allows control over the string representation of the object. All arguments are optional:\n• None default None, for example a StringIO object\n• None default None, which columns to write\n• None default None, minimum width of each column.\n• None default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string\n• None default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the .\n• None default True, set to False for a with a hierarchical index to print every MultiIndex key at each row.\n• None default True, will print the names of the indices The object also has a method, but with only the , , arguments. There is also a argument which, if set to , will additionally output the length of the Series.\n\nA or can be converted to a valid JSON string. Use with optional parameters:\n• None : the pathname or buffer to write the output. This can be in which case a JSON string is returned.\n• The format of the JSON string\n• None : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.\n• None : The number of decimal places to use when encoding floating point values, default 10.\n• None : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.\n• None : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.\n• None : If orient, then will write each record per line as json.\n• None : string, writer mode when writing to path. ‘w’ for write, ‘a’ for append. Default ‘w’ Note ’s, ’s and will be converted to and objects will be converted based on the and parameters. There are a number of different options for the format of the resulting JSON file / string. Consider the following and : Column oriented (the default for ) serializes the data as nested JSON objects with column labels acting as the primary index: # Not available for Series Index oriented (the default for ) similar to column oriented but the index labels are now primary: Record oriented serializes the data to a JSON array of column -> value records, index labels are not included. This is useful for passing data to plotting libraries, for example the JavaScript library : Value oriented is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included: # Not available for Series Split oriented serializes to a JSON object containing separate entries for values, index and columns. Name is also included for : Table oriented serializes to the JSON Table Schema, allowing for the preservation of metadata including but not limited to dtypes and index names. Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the option as it uses ordered containers. Writing to a file, with a date index and a date column: If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:\n• None if the dtype is unsupported (e.g. ) then the , if provided, will be called for each value, otherwise an exception is raised.\n• None if an object is unsupported it will attempt the following:\n• None check if the object has defined a method and call it. A method should return a which will then be JSON serialized.\n• None invoke the if one was provided.\n• None convert the object to a by traversing its contents. However this will often fail with an or give unexpected results. In general the best approach for unsupported objects or dtypes is to provide a . For example: can be dealt with by specifying a simple : Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a if is not supplied or is . To explicitly force parsing, pass\n• None : a VALID JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json\n• None : type of object to recover (series or frame), default ‘frame’\n• The format of the JSON string\n• None : if True, infer dtypes, if a dict of column to dtype, then use those, if , then don’t infer dtypes at all, default is True, apply only to the data.\n• None : boolean, try to convert the axes to the proper dtypes, default is\n• None : a list of columns to parse for dates; If , then try to parse date-like columns, default is .\n• None : boolean, default . If parsing dates, then parse the default date-like columns.\n• None : boolean, default . Set to enable usage of higher precision (strtod) function when decoding string to double values. Default ( ) is to use fast but less precise builtin functionality.\n• None : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.\n• None : reads file as one json object per line.\n• None : The encoding to use to decode py3 bytes.\n• None : when used in combination with , return a which reads in lines per iteration.\n• None : Either , the built-in JSON parser, or which dispatches to pyarrow’s . The is only available when The parser will raise one of if the JSON is not parseable. If a non-default was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see Orient Options for an overview. The default of , , and will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to . should only be set to if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes. Large integer values may be converted to dates if and the data and / or column labels appear ‘date-like’. The exact threshold depends on the specified. ‘date-like’ means that the column label meets one of the following criteria: When reading JSON data, automatic coercing into dtypes has some quirks:\n• None an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization\n• None a column that was data will be converted to if it can be done safely, e.g. a column of\n• None bool columns will be converted to on reconstruction Thus there are times where you may want to specify specific dtypes via the keyword argument. Don’t convert any data (but still convert axes and dates): Dates written in nanoseconds need to be read back in nanoseconds: # Try to parse timestamps as milliseconds -> Won't Work # Or specify that all timestamps are in nanoseconds By setting the argument you can control the default dtypes used for the resulting DataFrame. pandas provides a utility function to take a dict or list of dicts and this semi-structured data into a flat table. The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict. pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark. For line-delimited json files, pandas can also return an iterator which reads in lines at a time. This can be useful for large files or to read from a stream. # reader is an iterator that returns ``chunksize`` lines each iteration Line-limited json can also be read using the pyarrow reader by specifying . Table Schema is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient to build a JSON string with two fields, and . The field contains the key, which itself contains a list of column name to type pairs, including the or (see below for a list of types). The field also contains a field if the (Multi)index is unique. The second field, , contains the serialized data with the orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec. The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types: A few notes on the generated table schema:\n• None The object contains a field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.\n• None All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.\n• None datetimes with a timezone (before serializing), include an additional field with the time zone name (e.g. ).\n• None Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field with the period’s frequency, e.g. .\n• None Categoricals use the type and an constraint listing the set of possible values. Additionally, an field is included:\n• None A field, containing an array of labels, is included if the index is unique :\n• None The behavior is the same with MultiIndexes, but in this case the is an array:\n• None The default naming roughly follows these rules:\n• None For series, the is used. If that’s none, then the name is\n• None For , the stringified version of the column name is used\n• None For (not ), is used, with a fallback to if that is None.\n• None For , is used. If any level has no name, then is used. also accepts as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner. Please note that the literal string ‘index’ as the name of an is not round-trippable, nor are any names beginning with within a . These are used by default in to indicate missing values and the subsequent read cannot distinguish the intent. When using along with user-defined , the generated schema will contain an additional key in the respective element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. ). The key carries the name of the extension, if you have properly registered the , pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.\n\nThe method can read Excel 2007+ ( ) files using the Python module. Excel 2003 ( ) files can be read using . Binary Excel ( ) files can be read using . All formats can be read using engine. The instance method is used for saving a to Excel. Generally the semantics are similar to working with data. See the for some advanced strategies. When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used. In the most basic use-case, takes a path to an Excel file, and the indicating which sheet to parse. When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to read in ( ) and ( ) files.\n• None For the engine xlrd, pandas is using to read in ( ) files.\n• None For the engine pyxlsb, pandas is using to read in ( ) files.\n• None For the engine odf, pandas is using to read in ( ) files.\n• None For the engine calamine, pandas is using to read in ( ), ( ), ( ), ( ), ( ) files. To facilitate working with multiple sheets from the same file, the class can be used to wrap the file and can be passed into There will be a performance benefit for reading multiple sheets as the file is read into memory only once. The class can also be used as a context manager. The property will generate a list of the sheet names in the file. The primary use-case for an is parsing multiple sheets with different parameters: # For when Sheet1's format differs from Sheet2 Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to with no loss in performance. can also be called with a object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling with . The second argument is , not to be confused with . An ExcelFile’s attribute provides access to a list of sheets.\n• None The arguments allows specifying the sheet or sheets to read.\n• None The default value for is 0, indicating to read the first sheet\n• None Pass a string to refer to the name of a particular sheet in the workbook.\n• None Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.\n• None Pass a list of either strings or integers, to return a dictionary of specified sheets.\n• None Pass a to return a dictionary of all available sheets. Using None to get all sheets: Using a list to get multiple sheets: # Returns the 1st and 4th sheet, as a dictionary of DataFrames. can read more than one sheet, by setting to either a list of sheet names, a list of sheet positions, or to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively. can read a index, by passing a list of columns to and a column by passing a list of rows to . If either the or have serialized level names those will be read in as well by specifying the rows/columns that make up the levels. For example, to read in a index without names: If the index has level names, they will parsed as well, using the same parameters. If the source file has both index and columns, lists specifying each should be passed to and : Missing values in columns specified in will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of . It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. takes a keyword to allow you to specify a subset of columns to parse. You can specify a comma-delimited set of Excel columns and ranges as a string: If is a list of integers, then it is assumed to be the file column indices to be parsed. Element order is ignored, so is the same as . If is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in or inferred from the document header row(s). Those strings define which columns will be parsed: Element order is ignored, so is the same as . If is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that like dates (but are not actually formatted as dates in excel), you can use the keyword to parse those strings to datetimes: It is possible to transform the contents of Excel cells via the option. For instance, to convert a column to boolean: This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype: As an alternative to converters, the type for an entire column can be specified using the keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type or . To write a object to a sheet of an Excel file, you can use the instance method. The arguments are largely the same as described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the should be written. For example: Files with a extension will be written using (if available) or . The will be written in a way that tries to mimic the REPL output. The will be placed in the second row instead of the first. You can place it in the first row by setting the option in to : In order to write separate to separate sheets in a single Excel file, one can pass an . When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to create a new sheet and to append data to an existing sheet. The openpyxl engine writes to ( ) and ( ) files.\n• None For the engine xlsxwriter, pandas is using to write to ( ) files.\n• None For the engine odf, pandas is using to write to ( ) files. pandas supports writing Excel files to buffer-like objects such as or using . # By setting the 'engine' in the ExcelWriter constructor. # Seek to the beginning and read to copy the workbook to a variable in memory is optional but recommended. Setting the engine determines the version of workbook produced. Setting will produce an Excel 2003-format workbook (xls). Using either or will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced. pandas chooses an Excel writer via two methods:\n• None the filename extension (via the default specified in config options) By default, pandas uses the XlsxWriter for , openpyxl for . If you have multiple engines installed, you can set the default engine through and . pandas will fall back on openpyxl for files if Xlsxwriter is not available. To specify which writer you want to use, you can pass an engine keyword argument to and to . The built-in engines are: # By setting the 'engine' in the DataFrame 'to_excel()' methods. # By setting the 'engine' in the ExcelWriter constructor. The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the ’s method.\n• None : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default ). Using the Xlsxwriter engine provides many options for controlling the format of an Excel worksheet created with the method. Excellent examples can be found in the Xlsxwriter documentation here: https://xlsxwriter.readthedocs.io/working_with_pandas.html\n\nis a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent PyTables library. See the for some advanced strategies pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe. See: https://docs.python.org/3/library/pickle.html for more. Objects can be written to the file just like adding key-value pairs to a dict: In a current or later Python session, you can retrieve stored objects: # dotted (attribute) access provides get as well Deletion of the object specified by the key: # Working with, and automatically closing the store using a context manager supports a top-level API using for reading and for writing, similar to how and work. HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting . The examples above show storing using , which write the HDF5 to in a fixed array format, called the format. These types of stores are not appendable once written (though you can simply remove them and rewrite). Nor are they queryable; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The format stores offer very fast writing and slightly faster reading than stores. This format is specified by default when using or or by or . A format will raise a if you try to retrieve using a : Traceback (most recent call last) in \"key must be provided when HDF5 \" # if there is an error, close the store if we opened it. in in in in # start, stop applied to rows, so 0th axis only in \"a Fixed format store. this store must be selected in its entirety\" \"cannot pass a where specification when reading \" \"from a Fixed format store. this store must be selected in its entirety\" : cannot pass a where specification when reading from a Fixed format store. this store must be selected in its entirety supports another format on disk, the format. Conceptually a is shaped very much like a DataFrame, with rows and columns. A may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by or to or or . This format can be set as an option as well to enable to by default store in the format. You can also create a by passing or to a operation. Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. ), which will generate a hierarchy of sub-stores (or in PyTables parlance). Keys can be specified without the leading ‘/’ and are always absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and below, so be . # remove all nodes under this level You can walk through the group hierarchy using the method which will yield a tuple for each group key along with the relative keys of its contents. Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node. Traceback (most recent call last) in \"\"\"allow attribute access to get stores\"\"\" in in in \"cannot create a storer if the object is not existing \" \"nor a value are passed\" : cannot create a storer if the object is not existing nor a value are passed # you can directly access the actual PyTables node but using the root node Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a . Passing as a parameter to append will set a larger minimum for the string columns. Storing are currently supported. For string columns, passing to append will change the default nan representation on disk (which converts to/from ), this defaults to . Storing MultiIndex as tables is very similar to storing/selecting from homogeneous index . # the levels are automatically included as data columns The keyword is reserved and cannot be use as a level name. and operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data. A query is specified using the class under the hood, as a boolean expression.\n• None and are supported indexers of .\n• None if are specified, these can be used as additional indexers.\n• None level name in a MultiIndex, with default name , , … if not provided. These rules are similar to how boolean expressions are used in pandas for indexing.\n• None will be automatically expanded to the comparison operator\n• None is the not operator, but can only be used in very limited circumstances\n• None If a list/tuple of expressions is passed they will be combined via The following are valid expressions: The are on the left-hand side of the sub-expression: The right-hand side of the sub-expression (after a comparison operator) can be:\n• None functions that will be evaluated, e.g.\n• None variables that are defined in the local names space, e.g. Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this The latter will not work and will raise a .Note that there’s a single quote followed by a double quote in the variable. If you interpolate, use the format specifier which will quote . The keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a : and parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table. will raise a if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is not a data_column. will raise a if the query expression is not valid. You can store and query using the type. Terms can be specified in the format: , where float may be signed (and fractional), and unit can be for the timedelta. Here’s an example: Selecting from a can be achieved by using the name of the level. If the levels names are , the levels are automatically made available via the keyword with the level of the you want to select from. # the levels are automatically included as data columns with keyword level_n You can create/modify an index for a table with after data is already in the table (after and operation). Creating a table index is highly encouraged. This will speed your queries a great deal when you use a with the indexed dimension as the . Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing to . # we have automagically already created an index (in the first section) # change an index by passing new parameters Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end. Then create the index when finished appending. See here for how to create a completely-sorted-index (CSI) on an existing store. You can designate (and index) certain columns that you want to be able to perform queries (other than the columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify to force all columns to be . # this is in-memory version of this type of selection # we have automagically created this index and the B/C/string/string2 There is some performance degradation by making lots of columns into , so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!). You can pass or to and to return an iterator on the results. The default is 50,000 rows returned in a chunk. You can also use the iterator with which will open, then automatically close the store when finished iterating. Note, that the chunksize keyword applies to the source rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks. Here is a recipe for generating a query and using it to create equal sized return chunks. To retrieve a single indexable or data column, use the method . This will, for example, enable you to get the index very quickly. These return a of the result, indexed by the row number. These do not currently accept the selector. Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an of the resulting locations. These coordinates can also be passed to subsequent operations. Sometime your query can involve creating a list of rows to select. Usually this would be a resulting from an indexing operation. This example selects the months of a datetimeindex which are 5. If you want to inspect the stored object, retrieve via . You could use this programmatically to say get the number of rows in an object. The methods and can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries. The method splits a given single DataFrame into multiple tables according to , a dictionary that maps the table names to a list of ‘columns’ you want in that table. If is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument defines which table is the selector table (which you can make queries from). The argument will drop rows from the input to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely , that row will be dropped from all tables. If is False, THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES. Remember that entirely rows are not written to the HDFStore, so if you choose to call , some tables may have more rows than others, and therefore may not work or it may return unexpected results. # you can also create the tables individually You can delete from a table selectively by specifying a . In deleting rows, it is important to understand the deletes rows by erasing the rows, then moving the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the . Data is ordered (on the disk) in terms of the . Here’s a simple use case. You store panel-type data, with dates in the and ids in the . The data is then interleaved like this: It should be clear that a delete operation on the will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the will be very expensive. In this case it would almost certainly be faster to rewrite the table using a that selects all but the missing data. Please note that HDF5 DOES NOT RECLAIM SPACE in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, WILL TEND TO INCREASE THE FILE SIZE. To the file, use . allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: and .\n• None specifies if and how hard data is to be compressed. and disables compression and enables compression.\n• None specifies which compression library to use. If nothing is specified the default library is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:\n• None zlib: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.\n• \n• None blosc:blosclz This is the default compressor for\n• None blosc:lz4hc: A tweaked version of LZ4, produces better compression ratios at the expense of speed.\n• None blosc:snappy: A popular compressor used in many places.\n• None blosc:zlib: A classic; somewhat slower than the previous ones, but achieving better compression ratios.\n• None blosc:zstd: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed. If is defined as something other than the listed libraries a exception is issued. If the library specified with the option is missing on your platform, compression defaults to without further ado. Enable compression for all objects within the file: Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled: offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied utility . In addition, can change compression levels after the fact. Furthermore will the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the method. is not-threadsafe for writing. The underlying only supports concurrent reads (via threading or processes). If you need reading and writing at the same time , you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (GH 2397) for more information.\n• None If you use locks to manage write access between multiple processes, you may want to use before releasing write locks. For convenience you can use to do this for you.\n• None Once a is created columns (DataFrame) are fixed; only exactly the same columns can be appended\n• None Be aware that timezones (e.g., ) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use with the updated timezone definition. will show a if a column name cannot be used as an attribute selector. identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a clause and are generally a bad idea. will map an object dtype to the underlying dtype. This means the following types are known to work: categorical : see the section below columns are not supported, and WILL FAIL. You can write data that contains dtypes to a . Queries work the same as if it was an object array. However, the dtyped data is stored in a more efficient manner. The underlying implementation of uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the , in the first append. Subsequent appends, may introduce a string for a column larger than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur. Pass on the first table creation to a-priori specify the minimum length of a particular string column. can be an integer, or a dict mapping a column name to an integer. You can pass as a key to allow all or to have this min_itemsize. Passing a dict will cause all passed columns to be created as automatically. If you are not passing any , then the will be the maximum of the length of any string passed # A and B have a size of 30 # A is created as a data_column with a size of 30 String columns will serialize a (a missing value) with the string representation. This defaults to the string value . You could inadvertently turn an actual value into a missing value. # here you need to specify a different nan rep\n• None format come with a writing performance penalty as compared to stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.\n• None You can pass to , specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.\n• None You can pass to the first , to set the TOTAL number of rows that will expect. This will optimize read/write performance.\n• None Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)\n• None A will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See Here for more information and some solutions.\n\nThe module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Where available, users may first want to opt for Apache Arrow ADBC drivers. These drivers should provide the best performance, null handling, and type detection. For a full list of ADBC drivers and their development status, see the ADBC Driver Implementation Status documentation. Where an ADBC driver is not available or may be missing functionality, users should opt for installing SQLAlchemy alongside their database driver library. Examples of such drivers are psycopg2 for PostgreSQL or pymysql for MySQL. For SQLite this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the SQLAlchemy docs. If SQLAlchemy is not installed, you can use a in place of a SQLAlchemy engine, connection, or URI string. See also some for some advanced strategies. The function is a convenience wrapper around and (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters. In the following example, we use the SQlite SQL database engine. You can use a temporary SQLite database where data are stored in “memory”. To connect using an ADBC driver you will want to install the using your package manager. Once installed, you can use the DBAPI interface provided by the ADBC driver to connect to your database. To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on and the URI formatting, see the examples below and the SQLAlchemy documentation If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the SQLAlchemy docs for an explanation of how the database connection is handled. When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour. Assuming the following data is in a , we can insert it into the database using . With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the parameter when calling . For example, the following writes to the database in batches of 1000 rows at a time: Ensuring consistent data type management across SQL databases is challenging. Not every SQL database offers the same types, and even when they do the implementation of a given type can vary in ways that have subtle effects on how types can be preserved. For the best odds at preserving database types users are advised to use ADBC drivers when available. The Arrow type system offers a wider array of types that more closely match database types than the historical pandas/NumPy type system. To illustrate, note this (non-exhaustive) listing of types available in different databases and pandas backends: Not implemented as of writing, but theoretically possible If you are interested in preserving database types as best as possible throughout the lifecycle of your DataFrame, users are encouraged to leverage the argument of This will prevent your data from being converted to the traditional pandas/NumPy type system, which often converts SQL types in ways that make them impossible to round-trip. In case an ADBC driver is not available, will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype , pandas will try to infer the data type. You can always override the default type by specifying the desired SQL type of any of the columns by using the argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy type instead of the default type for string columns: Due to the limited support for timedelta’s in the different database flavors, columns with type will be written as integer values as nanoseconds to the database and a warning will be raised. The only exception to this is when using the ADBC PostgreSQL driver in which case a timedelta will be written to the database as an Columns of dtype will be converted to the dense representation as you would get with (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does not generate a categorical. Using ADBC or SQLAlchemy, is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used. The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data. When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone. is also capable of reading datetime data that is timezone aware or naive. When reading types, pandas will convert the data to UTC. The parameter controls the SQL insertion clause used. Possible values are:\n• None : Uses standard SQL clause (one per row).\n• None : Pass multiple values in a single clause. It uses a SQL syntax not supported by all backends. This usually provides better performance for analytic databases like and , but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy documentation.\n• None callable with signature : This can be used to implement a more performant insertion method based on specific backend dialect features. Example of a callable using PostgreSQL COPY clause: # Alternative to_sql() *method* for DBs that support COPY FROM data_iter : Iterable that iterates the values to be inserted # gets a DBAPI connection that can provide a cursor will read a database table given the table name and optionally a subset of columns to read. In order to use , you must have the ADBC driver or SQLAlchemy optional dependency installed. ADBC drivers will map database types directly back to arrow types. For other drivers note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume is an integer column in a table. Then, intuitively, will return integer-valued series, while will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity. You can also specify the name of the column as the index, and specify a subset of columns to be read. And you can explicitly force columns to be parsed as dates: If needed you can explicitly specify a format string, or a dict of arguments to pass to : You can check if a table exists using Reading from and writing to different schema’s is supported through the keyword in the and functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example: You can query using raw SQL in the function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic. Of course, you can specify a more “complex” query. The function supports a argument. Specifying this will return an iterator through chunks of the query result: To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information see the examples the SQLAlchemy documentation You can use SQLAlchemy constructs to describe your query. Use to specify query parameters in a backend-neutral way If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions You can combine SQLAlchemy expressions with parameters passed to using The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the Python DB-API. You can create connections like so: And then issue the following queries:"
    },
    {
        "link": "https://stackoverflow.com/questions/14257373/how-to-skip-the-headers-when-processing-a-csv-file-using-python",
        "document": "I am using below referred code to edit a csv using Python. Functions called in the code form upper part of the code.\n\nProblem: I want the below referred code to start editing the csv from 2nd row, I want it to exclude 1st row which contains headers. Right now it is applying the functions on 1st row only and my header row is getting changed.\n\nI tried to solve this problem by initializing variable to but it didn't work.\n\nPlease help me in solving this issue."
    },
    {
        "link": "https://docs.python.org/3/library/csv.html",
        "document": "The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in RFC 4180. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.\n\nThe module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.\n\nThe module’s and objects read and write sequences. Programmers can also read and write data in dictionary form using the and classes.\n\nThe module defines the following functions: Return a reader object that will process lines from the given csvfile. A csvfile must be an iterable of strings, each in the reader’s defined csv format. A csvfile is most commonly a file-like object or list. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed unless the format option is specified (in which case unquoted fields are transformed into floats). Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. csvfile can be any object with a method. If csvfile is a file object, it should be opened with . An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the class or one of the strings returned by the function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about dialects and formatting parameters, see the Dialects and Formatting Parameters section. To make it as easy as possible to interface with modules which implement the DB API, the value is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a call. All other non-string data are stringified with before being written. Associate dialect with name. name must be a string. The dialect can be specified either by passing a sub-class of , or by fmtparams keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about dialects and formatting parameters, see section Dialects and Formatting Parameters. Delete the dialect associated with name from the dialect registry. An is raised if name is not a registered dialect name. Return the dialect associated with name. An is raised if name is not a registered dialect name. This function returns an immutable . Return the names of all registered dialects. Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes the new limit. The module defines the following classes: Create an object that operates like a regular reader but maps the information in each row to a whose keys are given by the optional fieldnames parameter. The fieldnames parameter is a sequence. If fieldnames is omitted, the values in the first row of file f will be used as the fieldnames and will be omitted from the results. If fieldnames is provided, they will be used and the first row will be included in the results. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering. If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by restkey (which defaults to ). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with the value of restval (which defaults to ). All other optional or keyword arguments are passed to the underlying instance. If the argument passed to fieldnames is an iterator, it will be coerced to a . Changed in version 3.6: Returned rows are now of type . Changed in version 3.8: Returned rows are now of type . Create an object which operates like a regular writer but maps dictionaries onto output rows. The fieldnames parameter is a of keys that identify the order in which values in the dictionary passed to the method are written to file f. The optional restval parameter specifies the value to be written if the dictionary is missing a key in fieldnames. If the dictionary passed to the method contains a key not found in fieldnames, the optional extrasaction parameter indicates what action to take. If it is set to , the default value, a is raised. If it is set to , extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying instance. Note that unlike the class, the fieldnames parameter of the class is not optional. If the argument passed to fieldnames is an iterator, it will be coerced to a . The class is a container class whose attributes contain information for how to handle doublequotes, whitespace, delimiters, etc. Due to the lack of a strict CSV specification, different applications produce subtly different CSV data. instances define how and instances behave. All available names are returned by , and they can be registered with specific and classes through their initializer ( ) functions like this: The class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name . The class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name . The class defines the usual properties of a CSV file generated on UNIX systems, i.e. using as line terminator and quoting all fields. It is registered with the dialect name . The class is used to deduce the format of a CSV file. The class provides two methods: Analyze the given sample and return a subclass reflecting the parameters found. If the optional delimiters parameter is given, it is interpreted as a string containing possible valid delimiter characters. Analyze the sample text (presumed to be in CSV format) and return if the first row appears to be a series of column headers. Inspecting each column, one of two key criteria will be considered to estimate if the sample contains a header:\n• None the second through n-th rows contain numeric values\n• None the second through n-th rows contain strings where at least one value’s length differs from that of the putative header of that column. Twenty rows after the first row are sampled; if more than half of columns + rows meet the criteria, is returned. This method is a rough heuristic and may produce both false positives and negatives. An example for use: The module defines the following constants: Instructs objects to quote all fields. Instructs objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator. Instructs objects to quote all non-numeric fields. Instructs objects to convert all non-quoted fields to type float. Instructs objects to never quote fields. When the current delimiter occurs in output data it is preceded by the current escapechar character. If escapechar is not set, the writer will raise if any characters that require escaping are encountered. Instructs objects to perform no special processing of quote characters. Instructs objects to quote all fields which are not . This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) field as and to otherwise behave as . Instructs objects to always place quotes around fields which are strings. This is similar to , except that if a field value is an empty (unquoted) string is written. Instructs objects to interpret an empty (unquoted) string as and to otherwise behave as . The module defines the following exception: Raised by any of the functions when an error is detected.\n\nTo make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the class containing various attributes describing the format of the CSV file. When creating or objects, the programmer can specify a string or a subclass of the class as the dialect parameter. In addition to, or instead of, the dialect parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the class. A one-character string used to separate fields. It defaults to . Controls how instances of quotechar appearing inside a field should themselves be quoted. When , the character is doubled. When , the escapechar is used as a prefix to the quotechar. It defaults to . On output, if doublequote is and no escapechar is set, is raised if a quotechar is found in a field. A one-character string used by the writer to escape the delimiter if quoting is set to and the quotechar if doublequote is . On reading, the escapechar removes any special meaning from the following character. It defaults to , which disables escaping. Changed in version 3.11: An empty escapechar is not allowed. The string used to terminate lines produced by the . It defaults to . The is hard-coded to recognise either or as end-of-line, and ignores lineterminator. This behavior may change in the future. A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters. It defaults to . Changed in version 3.11: An empty quotechar is not allowed. Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the QUOTE_* constants and defaults to . When , spaces immediately following the delimiter are ignored. The default is . When , raise exception on bad CSV input. The default is .\n\nThe simplest example of reading a CSV file: The corresponding simplest possible writing example is: Since is used to open a CSV file for reading, the file will by default be decoded into unicode using the system default encoding (see ). To decode a file using a different encoding, use the argument of open: The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file. A slightly more advanced use of the reader — catching and reporting errors: And while the module doesn’t directly support parsing strings, it can easily be done:"
    },
    {
        "link": "https://stackoverflow.com/questions/3428532/how-to-import-a-csv-file-using-python-with-headers-intact-where-first-column-is",
        "document": "This is an elaboration of a previous question, but as I delve deeper into python, I just get more confused as to how python handles csv files.\n\nI have a csv file, and it must stay that way (e.g., cannot convert it to text file). It is the equivalent of a 5 rows by 11 columns array or matrix, or vector.\n\nI have been attempting to read in the csv using various methods I have found here and other places (e.g. ) so that it preserves the relationship between columns and rows, where the first row and the first column = non-numerical values. The rest are float values, and contain a mixture of positive and negative floats.\n\nWhat I wish to do is import the csv and compile it in python so that if I were to reference a column header, it would return its associated values stored in the rows. For example:\n\nAnd so forth...\n\nI am looking for techniques for handling this kind of data structure. I am very new to python."
    },
    {
        "link": "https://geeksforgeeks.org/working-csv-files-python",
        "document": "Python is one of the important fields for data scientists and many programmers to handle a variety of data. CSV (Comma-Separated Values) is one of the prevalent and accessible file formats for storing and exchanging tabular data.\n\nIn article explains What is CSV. Working with CSV files in Python, Reading, and Writing to a CSV file, and Storing Emails in CSV files .\n\nCSV (Comma Separated Values) is a simple file format used to store tabular data, such as a spreadsheet or database. A CSV file stores tabular data (numbers and text) in plain text. Each line of the file is a data record. Each record consists of one or more fields, separated by commas. The use of the comma as a field separator is the source of the name for this file format. For working CSV files in Python, there is an inbuilt module called CSV.\n\nBelow are some operations that we perform while working with Python CSV files in Python\n\nReading from a CSV file is done using the reader object. The CSV file is opened as a text file with Python’s built-in open() function, which returns a file object. In this example, we first open the CSV file in READ mode, file object is converted to csv.reader object and further operation takes place. Code and detailed explanation is given below.\n\nThe above example uses a CSV file aapl.csv which can be downloaded from here .\n\nRun this program with the aapl.csv file in the same directory.\n• None Let us try to understand this piece of code.\n• None Here, we first open the CSV file in READ mode. The file object is named as csvfile . The file object is converted to csv.reader object. We save the csv.reader object as csvreader.\n• csvreader is an iterable object. Hence, .next() method returns the current row and advances the iterator to the next row. Since, the first row of our csv file contains the headers (or field names), we save them in a list called fields\n• None Now, we iterate through the remaining rows using a for loop. Each row is appended to a list called rows . If you try to print each row, one can find that a row is nothing but a list containing all the field values.\n• csvreader.line_num is nothing but a counter which returns the number of rows that have been iterated.\n\nWe can read a CSV file into a dictionary using the module in Python and the class. Here’s an example:\n\nSuppose, we have a employees.csv file and content inside it will be:\n\nIn this example, reads each row of the CSV file as a dictionary where the keys are the column headers, and the values are the corresponding values in each row. The dictionaries are then appended to a list ( in this case).\n\nTo write to a CSV file, we first open the CSV file in WRITE mode. The file object is converted to csv.writer object and further operations takes place. Code and detailed explanation is given below.\n\nLet us try to understand the above code in pieces.\n• fields rows have been already defined. fields is a list containing all the field names. rows is a list of lists. Each row is a list containing the field values of that row.\n• None Here, we first open the CSV file in WRITE mode. The file object is named as csvfile . The file object is converted to csv.writer object. We save the csv.writer object as csvwriter\n• None Now we use writerow method to write the first row which is nothing but the field names.\n• writerows method to write multiple rows at once.\n\nTo write a dictionary to a CSV file, the file object (csvfile) is converted to a DictWriter object. Detailed example with explanation and code is given below.\n\nIn this example, we write a dictionary mydict to a CSV file.\n• csvfile ) is converted to a DictWriter object. Here, we specify the fieldnames\n• None writeheader method simply writes the first row of your csv file using the pre-specified fieldnames.\n• writerows method simply writes all the rows but in each row, it writes only the values(not keys).\n\nSo, in the end, our CSV file looks like this:\n\nConsider that a CSV file looks like this in plain text:\n• None We notice that the delimiter is not a comma but a semi-colon. Also, the rows are separated by two newlines instead of one. In such cases, we can specify the delimiter and line terminator.\n\nWe can read a Python CSV files with Pandas using the pandas.read_csv( ) function. Here’s an example:\n\nSuppose, we have a employees.csv file and content inside it will be:\n\nIn this example, reads the CSV file into a Pandas DataFrame. The resulting DataFrame can be used for various data manipulation and analysis tasks.\n\nWe can access specific columns, filter data, and perform various operations using pandas DataFrame functionality. For example, if we want to access the “name” column, we can use\n\nWe can use Pandas to write CSV files. It can done by using pd.DataFrame() function. In this example, the Pandas library is used to convert a list of dictionaries ( ) into a DataFrame, representing tabular data. The DataFrame is then written to a Python CSV file named “output.csv” using the method, creating a structured and readable data file for further analysis or sharing.\n\nHere we are importing the csv module and then simply using the same concept of storing the emails in the form of comma-separated entity also with their names. We’re opening the file open() function and specifying that we need that as a csv file and then writing the each column into the csv file using writer object."
    },
    {
        "link": "https://pythonmorsels.com/csv-reading",
        "document": "How can you read a CSV file in Python?\n\nThe Python Standard Library has a module, which has a function within it:\n\nWe can use the function by passing it an iterable of lines. This usually involves passing a file object, because files are iterables in Python, and as we loop over them, we'll get back each line in our file (see reading a file line-by-line in Python).\n\nHere we have a CSV file called :\n\nLet's use Python's built-in function to open our file for reading.\n\nNow we can call pass the file object we got back to :\n\nWhen we call we'll get back a object:\n\nWe can loop over that object to get the rows within it:\n\nWhen we loop over a object, the will loop over the file object that we originally gave it and convert each line in our file to a list of strings:\n\nEach list represents one row in our file, and each string in each list represents the data in one column in that row.\n\nNote that doesn't know or care about the headers in our file: it treats every row equally.\n\nWe can try to work around this lack of headers by recognizing that objects are both iterables and iterators. So just like file objects, we can pass objects to Python's function to get just their next row.\n\nSo if we wanted to skip over the first row in our file (skipping over the header line) we could pass to the function to consume the first row, and then we could continue looping over it after that:\n\nThis works because iterators are consumed as we loop over them. That first row was consumed by our call and then we kept looping to get the rest of our rows.\n\nIf you'd prefer to think in terms of the headers in your file, rather than in terms of the indexes of each data column, you could use instead of .\n\nJust like with objects, we can loop over objects to get the rows within our file. But unlike objects, instead of getting back lists representing each row, we'll get back dictionaries:\n\nOur object parses the first row in our file and treats that row as our header row. It uses those headers as keys in each of the dictionaries that it gives us as we loop over it.\n\nSo every dictionary that it gives us will have the same keys representing those headers:\n\nBut the values in each dictionary will be different: the values for each dictionary row represent the data that corresponds to each header:\n\nWe can use Python's module to parse comma-delimited data, but we can also use it to parse other types of delimited data.\n\nBoth and accept an optional argument, which defaults to a comma ( ).\n\nHere we have a tab-delimited file called :\n\nWe can use to read this file by specifying a delimiter of a tab character ( ):\n\nAs we loop over rows in our object, the will split up each of line by tab characters instead of by commas:\n\nUse or to read CSV files in Python\n\nYou can use to get back lists representing each row in your file. Or if you prefer to rely on the headers in your file, you can use to get dictionaries representing each of those rows."
    }
]