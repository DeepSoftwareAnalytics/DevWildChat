[
    {
        "link": "https://developer.chrome.com/docs/extensions/mv2/manifest",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nEvery extension has a JSON-formatted manifest file, named , that provides important information.\n\nThe following code shows the supported manifest fields for Extensions, with links to the page that discusses each field."
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/manifest",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nEvery extension must have a file in its root directory that lists important information about the structure and behavior of that extension. This page explains the structure of extension manifests and the features they can include.\n\nThe following example manifests show the basic manifest structure and some commonly used features as a starting point for creating your own manifest:\n\nThe following is a list of all supported manifest keys."
    },
    {
        "link": "https://dev.to/scriptjsh/a-guide-to-chrome-extension-configuration-manifestjson-file-15kn",
        "document": "The file plays a vital role in the development of Chrome extensions. It serves as a configuration file that provides essential information about the extension to the Chrome browser. Understanding its structure and properties is crucial for building powerful and functional extensions. In this article, we will explore the file in detail, discussing its purpose, key components, and best practices for creating robust Chrome extensions.\n\nThe file is a crucial component of a Chrome extension which serves as a configuration file that provides important information about your extension to the Chrome browser. This file acts as a central hub, defining various properties and settings for your extension.\n• Extension Details: This section contains general information about your extension, such as its name, version, description, and author details.\n\nThe indicates the version of the manifest file format being used. 2 refers to the current version.\n• Permissions: In this section, you declare the permissions your extension requires to function correctly. These permissions can include accessing specific websites, interacting with tabs, retrieving data from the browser's storage, or requesting additional user permissions. It is crucial to specify only the necessary permissions to maintain user trust.\n\nThe section lists the required permissions for the extension, such as tabs for accessing tab-related functions, storage for accessing the browser's storage, and https://www.example.com/ for accessing a specific website.\n• Background Scripts/Event Pages: If your extension requires scripts to run continuously in the background or handle events, you can specify them in this section. These scripts can perform tasks like monitoring browser events, handling incoming requests, or performing periodic actions.\n\nThe section defines a background script called , which run persistently in the background.\n• Content Scripts: Content scripts allow your extension to interact with and modify web pages. You can define which URLs your content scripts can access and specify when and how they should be injected into web pages.\n\nThe section specifies a content script called which will be injected into web pages that match the specified URL pattern (’https://www.example.com/).\n• Browser Actions/Page Actions: This section is used if your extension needs to add a button or an icon to the browser’s toolbar. Browser actions represent actions available to the user throughout their browsing experience, while page actions appear only on specific pages based on conditions defined by your extension.\n\nThe section adds a button to the browser’s toolbar with icons of different sizes. Clicking the button triggers a popup displayed by the file.\n• Options Page: If your extension requires user-configurable options, you can define an options page in this section. The options page provides a dedicated interface for users to customise the behaviour of your extension.\n\nThe options_page section specifies an options page called options.html for configuring the extension.\n• Icons: You can specify various icons for your extensions to represent it in different contexts, such as the browser’s toolbar, settings page, or the Chrome Web Store.\n\nThe section provides icons of different sizes to represent the extension in various contexts.\n\nNote: Remember to replace the filenames, URLs, and icon paths with your actual file locations and URLs.\n• Minimal Permissions: Request only the necessary permission s required for your extension’s functionality. This helps build user trust and improves the installation experience.\n• Error Handling: Handle errors gracefully when your extension’s background scripts and event pages to prevent issues from affecting the browsing experience.\n• Efficient Content Scripts: Optimise your content scripts to minimise their impact on page loading and performance.\n• Consistent Iconography: Provide Visually appealing and consistent icons to represent your extension in different contexts, enhancing its recognition and usability.\n• Testing and Debugging: Regularly test your extension, debug any issues, and utilise browser developer tools for troubleshooting.\n\nThe file serves as the backbone of a Chrome extension, providing crucial configuration details to the browser. Understanding its structure, components, and best practices is essential for building successful extensions. By properly configuring the file, developers can define their extension’s behaviour, appearance, and capabilities, ultimately creating a seamless and engaging user experience. With this knowledge, you are well-equipped to embark on your journey of creating powerful Chrome extensions."
    },
    {
        "link": "https://stackoverflow.com/questions/11814270/chrome-extension-manifest-version-2",
        "document": "I have a chrome extension that has a reference to the jquery file.\n\n this is my popup html (only the head tag):\n\nso in \"MyExtensionScript.js\" i thought i could use jquery but apparently the $ function is not defined.\n\n This is my manifest.json file:\n\nin version 1 of the manifest it worked, but now it doesn't. I tried to use the \"web_accessible_resources\" and add to them \"http://www.MySite.com/Resources/JS/JQuery/jquery-1.7.2.min.js\" but that didn't work also. any ideas?\n\n also, i have a script injected to the current page and returning me a message (in my case some html source of the current page), will this behavior be affected by the transition to manifest version 2? Thanks all :)\n\nEDIT: I have a web application that enables cross domain scripting (using JSONP). In my extension i had a script calling a web service in my site with $.getJSON. now it doesn't work. i'm pretty sure that it has to do with the new manifest version but how can i enable again the cross domain scripting?"
    },
    {
        "link": "https://stackoverflow.com/questions/73590004/can-manifest-json-have-both-2-and-3-versions",
        "document": "It seems that Chrome Store refuses to accept manifest 2, and FireFox does not understand manifest 3. That is, I can no longer create one extension ZIP file and upload to both Chrome Store and FireFox Store.\n\nIs there a way to have both 2 and 3 versions in one manifest.json file at the same time?"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/api/storage",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nTo use the storage API, declare the permission in the extension manifest. For example:\n\nThe Storage API provides an extension-specific way to persist user data and state. It's similar to the web platform's storage APIs (IndexedDB, and Storage), but was designed to meet the storage needs of extensions. The following are a few key features:\n• All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n• The JSON serializable values are stored as object properties.\n• The Storage API is asynchronous with bulk read and write operations.\n• Even if the user clears the cache and browsing history, the data persists.\n• Stored settings persist even when using split incognito.\n\nWhile extensions can use the interface (accessible from ) in some contexts (popup and other HTML pages), we don't recommend it for the following reasons:\n• Extension service workers can't use the Web Storage API.\n• Data saved using the Web Storage API is lost when the user clears their browsing history.\n\nTo move data from web storage APIs to extension storage APIs from a service worker:\n• Prepare an offscreen document html page and script file. The script file should contain a conversion routine and an handler.\n• In the extension service worker, check for your data.\n• After the returned Promise resolves, call to start the conversion routine.\n\nThere are also some nuances to how web storage APIs work in extensions. Learn more in the Storage and Cookies article.\n\nThe Storage API is divided into the following storage areas:\n\nThe Storage API has the following usage limitations:\n• Storing data often comes with performance costs, and the API includes storage quotas. We recommend being careful about what data you store so that you don't lose the ability to store data.\n• Storage can take time to complete. Make sure to structure your code to account for that time.\n\nFor details on storage area limitations and what happens when they're exceeded, see the quota information for , , and .\n\nThe following sections demonstrate common use cases for the Storage API.\n\nTo track changes made to storage, add a listener to its event. When anything changes in storage, that event fires. The sample code listens for these changes:\n\nWe can take this idea even further. In this example, we have an options page that allows the user to toggle a \"debug mode\" (implementation not shown here). The options page immediately saves the new settings to , and the service worker uses to apply the setting as soon as possible.\n\nBecause service workers don't run all the time, Manifest V3 extensions sometimes need to asynchronously load data from storage before they execute their event handlers. To do this, the following snippet uses an async event handler that waits for the global to be populated before executing its logic.\n\nYou can view and edit data stored using the API in DevTools. To learn more, see the View and edit extension storage page in the DevTools documentation.\n\nThe following samples demonstrate the , , and storage areas:\n\nTo see other demos of the Storage API, explore any of the following samples:\n\n\"TRUSTED_CONTEXTS\" \n\n Specifies contexts originating from the extension itself. \"TRUSTED_AND_UNTRUSTED_CONTEXTS\" \n\n Specifies contexts originating from outside the extension.\n• Fired when one or more items change. The function looks like:\n• The parameter looks like:\n• The function looks like:\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• Gets one or more items from storage. The function looks like:\n• A single key to get, list of keys to get, or a dictionary specifying default values (see description of the object). An empty list or object will return an empty result object. Pass in to get the entire contents of storage.\n• The parameter looks like:\n• Object with items in their key-value mappings.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• Gets the amount of space (in bytes) being used by one or more items. The function looks like:\n• A single key or list of keys to get the total usage for. An empty list will return 0. Pass in to get the total usage of all of storage.\n• The parameter looks like:\n• Amount of space being used in storage, in bytes.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• Gets all keys from storage. The function looks like:\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• Removes one or more items from storage. The function looks like:\n• A single key or a list of keys for items to remove.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• The function looks like:\n• An object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected. Primitive values such as numbers will serialize as expected. Values with a and will typically serialize to , with the exception of (serializes as expected), , and (serialize using their representation).\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• Sets the desired access level for the storage area. The default will be only trusted contexts. The function looks like:\n• \n• The access level of the storage area.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• The new value of the item, if there is a new value.\n• The old value of the item, if there was an old value. Items in the storage area are local to each machine.\n• The maximum amount (in bytes) of data that can be stored in local storage, as measured by the JSON stringification of every value plus every key's length. This value will be ignored if the extension has the permission. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or a rejected Promise if using async/await. Items in the storage area are set by an enterprise policy configured by the domain administrator, and are read-only for the extension; trying to modify this namespace results in an error. For information on configuring a policy, see Manifest for storage areas. Items in the storage area are stored in-memory and will not be persisted to disk.\n• The maximum amount (in bytes) of data that can be stored in memory, as measured by estimating the dynamically allocated memory usage of every value and key. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected. Items in the storage area are synced using Chrome Sync.\n• The maximum number of items that can be stored in sync storage. Updates that would cause this limit to be exceeded will fail immediately and set when using a callback, or when a Promise is rejected.\n• The storage.sync API no longer has a sustained write operation quota.\n• The maximum number of , , or operations that can be performed each hour. This is 1 every 2 seconds, a lower ceiling than the short term higher writes-per-minute limit. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum number of , , or operations that can be performed each minute. This is 2 per second, providing higher throughput than writes-per-hour over a shorter period of time. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum total amount (in bytes) of data that can be stored in sync storage, as measured by the JSON stringification of every value plus every key's length. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum size (in bytes) of each individual item in sync storage, as measured by the JSON stringification of its value plus its key length. Updates containing items larger than this limit will fail immediately and set when using a callback, or when a Promise is rejected. Fired when one or more items change.\n• The parameter looks like:"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/mv2/reference/storage",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nThe Storage API provides an extension-specific way to persist user data and state. It's similar to the web platform's storage APIs (IndexedDB, and Storage), but was designed to meet the storage needs of extensions. The following are a few key features:\n• All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n• The JSON serializable values are stored as object properties.\n• The Storage API is asynchronous with bulk read and write operations.\n• Even if the user clears the cache and browsing history, the data persists.\n• Stored settings persist even when using split incognito.\n\nEven though extensions can use the [ ][mdn-storage] interface (accessible from ) in some contexts (popup and other HTML pages), it is not recommended for the following reasons:\n• Data saved using the interface is lost when the user clears their browsing history.\n\nTo move data from web storage APIs to extension storage APIs from a service worker:\n• Create an offscreen document with a conversion routine and an [ ][on-message] handler.\n• In the extension service worker check for your data.\n• If your data isn't found, [create][create-offscreen] an offscreen document and call [ ][send-message] to start the conversion routine.\n\nThere are also some nuances with how web storage APIs work in extensions. Learn more in the [Storage and Cookies][storage-and-cookies] article.\n\nThe Storage API is divided into the following four buckets (\"storage areas\"):\n\nTo use the storage API, declare the permission in the extension manifest. For example:\n\nThe following samples demonstrate the , , and storage areas:\n\nTo learn more about the storage area, see Manifest for storage areas.\n\nDon't think of adding to the Storage API as putting things in a big truck. Think of adding to storage as being like putting something in a pipe. The pipe may have material in it already, and it may even be filled. Always assume a delay between when you add to storage and when it is actually recorded.\n\nFor details on storage area limitations and what happens when they are exceeded, see the quota information for , , and .\n\nThe following sections demonstrate common use cases for the Storage API.\n\nTo track changes made to storage, you can add a listener to its event. When anything changes in storage, that event fires. The sample code listens for these changes:\n\nWe can take this idea even further. In this example, we have an options page that allows the user to toggle a \"debug mode\" (implementation not shown here). The options page immediately saves the new settings to , and the service worker uses to apply the setting as soon as possible.\n\nSince service workers are not always running, Manifest V3 extensions sometimes need to asynchronously load data from storage before they execute their event handlers. To do this, the following snippet uses an async event handler that waits for the global to be populated before executing its logic.\n\nTo see other demos of the Storage API, explore any of the following examples:\n\n\"TRUSTED_CONTEXTS\" \n\n Specifies contexts originating from the extension itself. \"TRUSTED_AND_UNTRUSTED_CONTEXTS\" \n\n Specifies contexts originating from outside the extension.\n• Fired when one or more items change. The function looks like:\n• The parameter looks like:\n• The function looks like:\n• The parameter looks like:\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• Gets one or more items from storage. The function looks like:\n• A single key to get, list of keys to get, or a dictionary specifying default values (see description of the object). An empty list or object will return an empty result object. Pass in to get the entire contents of storage.\n• The parameter looks like:\n• Object with items in their key-value mappings.\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• Gets the amount of space (in bytes) being used by one or more items. The function looks like:\n• A single key or list of keys to get the total usage for. An empty list will return 0. Pass in to get the total usage of all of storage.\n• The parameter looks like:\n• Amount of space being used in storage, in bytes.\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• Gets all keys from storage. The function looks like:\n• The parameter looks like:\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• Removes one or more items from storage. The function looks like:\n• A single key or a list of keys for items to remove.\n• The parameter looks like:\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• The function looks like:\n• An object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected. Primitive values such as numbers will serialize as expected. Values with a and will typically serialize to , with the exception of (serializes as expected), , and (serialize using their representation).\n• The parameter looks like:\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• Sets the desired access level for the storage area. The default will be only trusted contexts. The function looks like:\n• \n• The access level of the storage area.\n• The parameter looks like:\n• Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\n• The new value of the item, if there is a new value.\n• The old value of the item, if there was an old value. Items in the storage area are local to each machine.\n• The maximum amount (in bytes) of data that can be stored in local storage, as measured by the JSON stringification of every value plus every key's length. This value will be ignored if the extension has the permission. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or a rejected Promise if using async/await. Items in the storage area are set by an enterprise policy configured by the domain administrator, and are read-only for the extension; trying to modify this namespace results in an error. For information on configuring a policy, see Manifest for storage areas. Items in the storage area are synced using Chrome Sync.\n• The maximum number of items that can be stored in sync storage. Updates that would cause this limit to be exceeded will fail immediately and set when using a callback, or when a Promise is rejected.\n• The storage.sync API no longer has a sustained write operation quota.\n• The maximum number of , , or operations that can be performed each hour. This is 1 every 2 seconds, a lower ceiling than the short term higher writes-per-minute limit. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum number of , , or operations that can be performed each minute. This is 2 per second, providing higher throughput than writes-per-hour over a shorter period of time. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum total amount (in bytes) of data that can be stored in sync storage, as measured by the JSON stringification of every value plus every key's length. Updates that would cause this limit to be exceeded fail immediately and set when using a callback, or when a Promise is rejected.\n• The maximum size (in bytes) of each individual item in sync storage, as measured by the JSON stringification of its value plus its key length. Updates containing items larger than this limit will fail immediately and set when using a callback, or when a Promise is rejected. Fired when one or more items change.\n• The parameter looks like:"
    },
    {
        "link": "https://stackoverflow.com/questions/4213882/how-to-sync-chrome-extension-options",
        "document": "I've made a Chrome extension with an options page. The data is saved in localstorage and works just fine.\n\nChrome doesn't sync the localstorage to the cloud, just the extensions. This means that any user data will not sync to other computers of the same google account.\n\nI can not find an API at http://developer.chrome.com/extensions/docs.html which allows me to sync the user-chosen preferences.\n\nWhat methods do you suggest?"
    },
    {
        "link": "https://m2kdevelopments.medium.com/12-understanding-chrome-extensions-storage-93f0e3daa67e",
        "document": "The API is an API that store persistent data, get and modify the data. In our opinion it is one of the most important API used in chrome extensions projects. See the Chrome Storage API documentation for more info\n\nUnlike a lot of the other APIs we’ve looked at in previous articles works in all parts of the extensions; content scripts, background scripts and popup/extensions pages.\n\nHow is Chrome Storage API different from Web Storage API?\n\nFor those familiar with web dev, you might be wondering why use API when can store data using Web Storage API ( )? Good question.\n• You can use retrieve data in you background scripts/service workers with as opposed to Web Storage.\n• Content scripts running on different websites have all access to the same data and it not segments per domain.\n• Unlike the Web Storage API, data will persists even after the clearing the browsing history. In fact data will persists even after cache is cleared.\n• If the chrome extensions is running in an incognito window. The extension can access to the data.\n\nWhat Kind of Data can we storage in Chrome Storage API?\n\nSimilar to the data sent via function the data stored in API is a JSON with serializable values. In others words primitive types such as Numbers, Strings and Booleans and Arrays and Objects consists of primitive types. For instance\n\nThere are four types of storage areas , , , and . More often than not, will be used in chrome extensions projects.\n• Local: In this area data is stored locally on the browser the extension is installed on. The limit of data that be stored in 5MB but that can be increased to an indefinite amount. We will show you how later in this article.\n• Sync: The sync area stores data locally at first but syncs the data with all the chrome browsers the users is logged into and synced with. The storage limit is significantly much less than local.\n• Sessions: In this area data persists for the duration of the browser sessions. Usually used to hold sensitive data. It denials content scripts access to the data by default. But can be changes by running this function\n• Managed: “Managed storage is read-only storage for policy installed extensions and managed by system administrators using a developer-defined schema and enterprise policies.” See Documentation for Administrators.\n\nHow to declare in Manifest.json\n\nIf you want to go beyond the 5MB limit\n\nHow to save data to Chrome Storage API?\n\nTo save data using the Chrome Stoage API we’ll use the function. As mention, in the beginning section of the this article, we can only store primitive types or a collection of primitive types. In addition the function runs asynchronously.\n\nIn this particular example and are the keys in which the data is stored. The same would apply to the other storage areas as well.\n\nHow to retrieve data from Chrome Storage API?\n\nTo retrieve data use the function. This function also runs asynchronously. Moreover, there are multiple ways for retrieve data.\n\nThe same would apply to the other storage areas as well.\n\nHow to listen of storage changes\n\nSometimes you want run code even data can just been added or modified. Chrome Storage API provides a listener for such as purpose. You can run this listener in any part of the extension, content script, background script and extension pages (pop up UI).\n\nIn this extension we will be scraping the links from Google Search page and storing them in the local area. For the source code you can clone this repository here: https://github.com/BuildChromeExtensions/googlesearchlinks\n\nWe need a manifest.json content scripts, background script, popup script and popup UI. Your project should look like this."
    },
    {
        "link": "https://stackoverflow.com/questions/16312818/does-chrome-storage-sync-store-data-in-the-cloud",
        "document": "In the chrome extensions docs, on this page about local storage options, it says:\n\nTo store user data for your extension, you can use either storage.sync or storage.local. When using storage.sync, the stored data will automatically be synced to any Chrome browser that the user is logged into, provided the user has sync enabled.\n\nI am confused about what \"any Chrome browser that the user is logged into\" means. If I'm at home and use an extension which stores some data using , and then turn off my computer and go to work and use another computer with the same extension installed, will the data from my home computer be available? If so, what do I have to be logged into? My google account? And where is this data being stored? On my Google drive? If not, in what sense is the data synced?"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nContent scripts are files that run in the context of web pages. Using the standard Document Object Model (DOM), they are able to read details of the web pages the browser visits, make changes to them, and pass information to their parent extension.\n\nContent scripts can access the following extension APIs directly:\n\nContent scripts are unable to access other APIs directly. But they can access them indirectly by exchanging messages with other parts of your extension.\n\nYou can also access other files in your extension from a content script, using APIs like . To do this, you need to declare them as web-accessible resources. Note that this also exposes the resources to any first-party or third-party scripts running on the same site.\n\nContent scripts live in an isolated world, allowing a content script to make changes to its JavaScript environment without conflicting with the page or other extensions' content scripts.\n\nAn extension may run in a web page with code similar to the following example.\n\nThat extension could inject the following content script using one of the techniques outlined in the Inject scripts section.\n\nWith this change, both alerts appear in sequence when the button is clicked.\n\nContent scripts can be declared statically, declared dynamically, or programmatically injected.\n\nUse static content script declarations in manifest.json for scripts that should be automatically run on a well known set of pages.\n\nStatically declared scripts are registered in the manifest under the key. They can include JavaScript files, CSS files, or both. All auto-run content scripts must specify match patterns.\n\nDynamic content scripts are useful when the match patterns for content scripts are not well known or when content scripts shouldn't always be injected on known hosts.\n\nIntroduced in Chrome 96, dynamic declarations are similar to static declarations, but the content script object is registered with Chrome using methods in the namespace rather than in manifest.json. The Scripting API also allows extension developers to:\n\nLike static declarations, dynamic declarations can include JavaScript files, CSS files, or both.\n\nUse programmatic injection for content scripts that need to run in response to events or on specific occasions.\n\nTo inject a content script programmatically, your extension needs host permissions for the page it's trying to inject scripts into. Host permissions can either be granted by requesting them as part of your extension's manifest or temporarily using .\n\nThe following is a different versions of an activeTab-based extension.\n\nContent scripts can be injected as files.\n\nOr, a function body can be injected and executed as a content script.\n\nBe aware that the injected function is a copy of the function referenced in the call, not the original function itself. As a result, the function's body must be self contained; references to variables outside of the function will cause the content script to throw a .\n\nWhen injecting as a function, you can also pass arguments to the function.\n\nTo customize specified page matching, include the following fields in a declarative registration.\n\nThe content script will be injected into a page if both of the following are true:\n• Its URL matches any pattern and any pattern.\n• The URL doesn't also match an or pattern. Because the property is required, , , and can only be used to limit which pages will be affected.\n\nThe following extension injects the content script into but not into .\n\nGlob properties follow a different, more flexible syntax than match patterns. Acceptable glob strings are URLs that may contain \"wildcard\" asterisks and question marks. The asterisk ( ) matches any string of any length, including the empty string, while the question mark ( ) matches any single character.\n\nFor example, the glob matches any of the following:\n\nHowever, it does not match the following:\n\nThis extension injects the content script into and , but not into :\n\nThis extension injects the content script into and , but not into or :\n\nOne, all, or some of these can be included to achieve the correct scope.\n\nThe field controls when JavaScript files are injected into the web page. The preferred and default value is . See the RunAt type for other possible values.\n\nFor declarative content scripts specified in the manifest, the field allows the extension to specify if JavaScript and CSS files should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab:\n\nWhen programmatically registering content scripts using , the parameter can be used to specify if the content script should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab. This can only be used with tabId, and cannot be used if frameIds or documentIds are specified:\n\nExtensions may want to run scripts in frames that are related to a matching frame, but don't themselves match. A common scenario when this is the case is for frames with URLs that were created by a matching frame, but whose URLs don't themselves match the script's specified patterns.\n\nThis is the case when an extension wants to inject in frames with URLs that have , , , and schemes. In these cases, the URL won't match the content script's pattern (and, in the case of and , don't even include the parent URL or origin in the URL at all, as in or ). However, these frames can still be associated with the creating frame.\n\nTo inject into these frames, extensions can specify the property on a content script specification in the manifest.\n\nWhen specified and set to , Chrome will look at the origin of the initiator of the frame to determine whether the frame matches, rather than at the URL of the frame itself. Note that this might also be different than the target frame's origin (e.g., URLs have a null origin).\n\nThe initiator of the frame is the frame that created or navigated the target frame. While this is commonly the direct parent or opener, it may not be (as in the case of a frame navigating an iframe within an iframe).\n\nBecause this compares the origin of the initiator frame, the initiator frame could be on at any path from that origin. To make this implication clear, Chrome requires any content scripts specified with set to to also specify a path of .\n\nWhen both and are specified, takes priority.\n\nAlthough the execution environments of content scripts and the pages that host them are isolated from each other, they share access to the page's DOM. If the page wishes to communicate with the content script, or with the extension through the content script, it must do so through the shared DOM.\n\nAn example can be accomplished using :\n\nThe non-extension page, example.html, posts messages to itself. This message is intercepted and inspected by the content script and then posted to the extension process. In this way, the page establishes a line of communication to the extension process. The reverse is possible through similar means.\n\nTo access an extension file from a content script, you can call to get the absolute URL of your extension asset as shown in the following example ( ):\n\nTo use fonts or images in a CSS file, you can use to construct a URL as shown in the following example ( ):\n\nAll assets must be declared as web accessible resources in the file:\n\nWhile isolated worlds provide a layer of protection, using content scripts can create vulnerabilities in an extension and the web page. If the content script receives content from a separate website, such as by calling , be careful to filter content against cross-site scripting attacks before injecting it. Only communicate over HTTPS in order to avoid \"man-in-the-middle\" attacks.\n\nBe sure to filter for malicious web pages. For example, the following patterns are dangerous, and disallowed in Manifest V3:"
    },
    {
        "link": "https://stackoverflow.com/questions/11553600/how-to-inject-css-using-content-script-file-in-chrome-extension",
        "document": "I'm trying to inject my CSS from JavaScript which is injected as content script:\n\nI found similar question about injecting CSS, but I encountered a problem while using code from accepted answer. Here's my contents:\n\nAfter I load some page this message appears in console:\n\nDenying load of chrome-extension://phkgaaiaakklogbhkdnpjncedlbamani/fix.css. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.\n\nIs there any way to fix this? Or, maybe, some other way to inject a CSS from that JavaScript file?"
    },
    {
        "link": "https://medium.com/@charlesdouglasosborn/how-to-add-style-and-webfonts-to-a-chrome-extension-content-script-css-47d354025980",
        "document": "The idea of a content script is a piece of javascript which is inserted onto the page (injected if you will). This gives you a certain degree of control over the page. Normally you’ll want to have an interface for users to interact with the new javascript you have added — such as some new button or modal. However as there is CSS from the original page this can cause conflicts. Often you’ll want to style these elements for which you have 2 options:\n\nThis has the benefit of keeping everything separate. You can then style your content inside it how you wish. This has the added benefit of allowing you to also rely on libraries like jQuery or Angular without fear of this conflicting with libraries. Its definitely a good option (and one you’ll noticed used by the most popular content scripts). But sometimes you might not want to so for that you can…\n\nWhen you insert your extension and css you will need to ensure that every class has every attribute set to default (or risk the pages CSS style your script very different). The way I’ve done this in the past is using SCSS.\n\nBy having a base class which has the general defaults, you’re then able to extend your classes from this. Make sure that you call your css classes something very unique though to not cause conflicts, i.e. something relevant to your app and long. You’ll also want to make sure you do this for every element you insert i.e. if you add a header, you’ll need to override that style in the same way. Example:\n\nNow that you have this though, what about beautiful fonts? Well you can’t inject them in as if you own the site, so the best way to go about it is to download the webfonts you want, and then add them into your CSS.\n\nTo download webfonts from Google, find the font you want i.e.\n\nClick on the download link (top right):\n\nThen place the fonts you want into a new folder in your extension.\n\nTo reference these files in your CSS you’ll then to do the following:\n\nWhen you reference this font in the future you use the font-family you’ve specified there to bring it in (again keep it unique to stop conflicts).\n\nFinally, because of the way extensions work in Manifest 2.0, you’ll also need to set that these in the Web Accessible part of your manifest:\n\nAnd voila! A way for you to be able to style your content scripts as you would like to without needing to use an iFrame ☺\n\nAre you based in NYC? Merlin Guides is hiring if so, if you’re interested please apply to one of our roles here (and include this article!)."
    },
    {
        "link": "https://stackoverflow.com/questions/20725770/chrome-extension-content-scripts-custom-ui",
        "document": "I'm in the process of writing a chrome extension which displays some custom UI in multiple web pages via script injection. The script which I am injecting into the page appends some Dom items onto the document's body which can be interacted with by the user. The problem is, the items' styles are being affected by the page's css. I have solved this for the most part by applying css to each item as it's inserted into the dom.\n\nThe problem with this is, I end up with huge blocks of styling that look like this:\n\nThis whole method is going to become a problem because:\n• First: any property which I don't apply here is applied to my items by the page's css, this changes the style and usability of my elements.\n• Second: I feel like this method is inefficient.\n• Third: My content script contains jquery and some others which i'm afraid will also interfere with the page and it's own version of these\n\nIs there a better way to display these dom elements, inject these scripts, and style them? I would like as little clash with the parent page as possible. An idea that I came up with was covering the entire page in a transparent iframe and injecting everything into that, but I don't believe the items would display since the iframe would be transparent."
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/manifest/content-scripts",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThe key specifies a statically loaded JavaScript or CSS file to be used every time a page is opened that matches a certain URL pattern. Extensions can also inject content scripts programmatically, see Injecting Scripts for details.\n\nThese are the supported keys for . Only the key and either or are required.\n\nEach file must contain a relative path to a resource in the extension's root directory. Leading slashes ( ) are automatically trimmed. The key specifies when each file will be injected.\n\nOnly the property is required. Then you can use , , and to customize which URLs to inject code into. The key will trigger a warning.\n\nGlob URLs are those that contain \"wildcards\" * and question marks. The wildcard * matches any string of any length, including an empty string, while the question mark ? matches any single character.\n\nThe content script is injected into a page if:\n• Its URL matches any and patterns.\n• And the URL doesn't match or patterns.\n\nThe key specifies if the content script should be injected into all frames matching the specified URL requirements. If set to it will only inject into the topmost frame. It can be used along with to inject into an frame.\n\nTo inject into other frames like , , and , set the to . For details, see Inject in related frames\n\nBy default, content scripts are injected when the document and all resources are finished loading, and live in a private isolated execution environment that isn't accessible to the page or other extensions. You can change these defaults in the following keys:\n\nSee the Run on every page tutorial to build an extension that injects a content script in the manifest."
    }
]