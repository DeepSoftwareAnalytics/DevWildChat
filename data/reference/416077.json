[
    {
        "link": "https://stackoverflow.com/questions/5031569/loading-columns-for-an-extjs-dynamically",
        "document": "I am having trouble figuring out what I need to do to load the columns for an ExtJS grid dynamically. I want to be able to send the column headers as JSON and have the grid take that and generate the columns needed.\n\nMore specifically, I am wanting to do this using the GroupingHeader plugin, but I really just want to figure out how to do it without the added complexity of the GroupingHeader plugin first and then I can tackle that problem :)\n\nHere is some sample JSON data that I have for the column headers:\n\nThis is the data that I would need to do the grouping, where the would be the grouped header and the would be the column headers. Right now, I'm happy just getting the to show up as columns and then I can work on getting the grouping to work.\n\nIf anyone could point me in the right direction or give me some hints on where to begin, that would be extremely helpful! I'm not beyond figuring this out on my own, but I just need a little bump to get started because I can't seem to figure out from looking at the ExtJS examples and doing some Google searches."
    },
    {
        "link": "https://docs.sencha.com/ext/7.0.0/guides/components/grids.html",
        "document": "Ext.grid.Panel is one of the centerpieces of ExtJS. It's an incredibly versatile component that provides an easy way to display, sort, group, and edit data.\n\nLet's get started by creating a basic Ext.grid.Panel. Here's all you need to know to get a simple grid up and running:\n\nExt.grid.Panel is simply a component that displays data contained in a Ext.data.Store. Ext.data.Store can be thought of as a collection of records, or Ext.data.Model instances.\n\nThe benefit of this setup is separating our concerns. Ext.grid.Panel is only concerned with displaying the data, while Ext.data.Store takes care of fetching and saving the data using Ext.data.proxy.Proxy.\n\nFirst, we need to define a Ext.data.Model. A model is just a collection of fields that represents a type of data. Let's define a model that represents a \"User\":\n\nNext let's create a Ext.data.Store that contains several \"User\" instances.\n\nFor sake of ease, we configured Ext.data.Store to load its data inline. In a real world application, you would most likely configure the Ext.data.Store to use an Ext.data.proxy.Proxy to load data from the server.\n\nNow, we have a model, which defines our data structure. We have also loaded several model instances into an Ext.data.Store. Now we're ready to display the data using Ext.grid.Panel.\n\nIn this example, we configured the Grid with renderTo to immediately render the Grid into the HTML document.\n\nIn many situations, the grid will be a descendant of Ext.container.Viewport, which means rendering is already handled.\n\nAnd that's all there is to it.\n\nWe just created an Ext.grid.Panel that renders itself to the body element. We also told the Grid panel to get its data from the that we previously created.\n\nFinally, we defined the Grid panel's columns and gave them a dataIndex property. This associates a field from our model to a column.\n\nThe \"Name\" column has a fixed of \"100px\" and has sorting and hiding disabled. The \"Email Address\" column is hidden by default (it can be shown again by using the menu on any other column header). Finally, the \"Phone Number\" column flexes to fit the remainder of the Grid panel's total width.\n\nFor a larger example, see the Basic Grid Example.\n\nYou can use the renderer property of the column config to change the way in which data is displayed. A is a function that modifies the underlying value and returns a new value for display. Some of the most common renderers are included in Ext.util.Format, but you can write your own as well:\n\nSee the Kitchen Sink's Basic Grid for a live demo that uses custom renderers.\n\nIn accordance with accessibility guidelines, grid cells accept focus, and the focus rendition my be specified in the theme.\n\nArrow keys navigate the focus position in two dimensions. TAB tabs out of the grid into the following focusable element.\n\nThis is known as Navigable Mode, and is the default mode for handling focus within a grid.\n\nIf there are focusable elements within a cell (Such as [[Ext.grid.column.ActionColumn action columns]] then the actionable items may be accessed by using the ENTER or F2 key to enter Actionable Mode wherin focus navigation takes place within cells using the TAB key.\n\nCell editing which is discussed below is a special case of Actionable Mode.\n\nESC or F2 exits actionable mode, and focus pops up to the encapsulating cell of the recently focused actionable item.\n\nGrid panels can be used to simply display data. However, it is often necessary to interact with the Grid's data. All Grid panels have an Ext.selection.Model, which determines how data is selected. The most versatile Selection Model is Ext.grid.selection.SpreadsheetModel, which may be configured to select cells, rows, or columns, and to optionally display a selection checkbox if selecting rows.\n\nSee the Kitchen Sink's Spreadsheet Model for an example.\n\nOther selection models include Ext.selection.RowModel, where entire rows are selected, and Ext.selection.CellModel, where individual cells are selected. These are less flexible than the SpreadsheetModel.\n\nGrid panels use Ext.selection.RowModel by default, but it's easy to switch to an Ext.grid.selection.SpreadsheetModel:\n\nGrid panel has built-in support for editing. Let's look at the two main editing modes - row editing and cell editing.\n\nCell editing allows you to edit the data in a Grid panel one cell at a time. The first step in implementing cell editing is to configure an editor for each Ext.grid.column.Column in your Grid Panel that should be editable. This is done using the Ext.grid.column.Column#editor config. The simplest way is to specify just the xtype of the field you want to use as an editor:\n\nIf you need more control over how the editor field behaves, the Ext.grid.column.Column#editor config can also take a config object for a Field. For example, if we are using a Ext.form.field.Text and we want to require a value:\n\nYou can use any class in the \"Ext.form.field.*\" package as an editor field. Lets suppose we want to edit a column that contains dates. We can use a Ext.form.field.Date editor:\n\nAny Ext.grid.column.Column in a Ext.grid.Panel that do not have a ] configured will not be editable.\n\nNow that we've configured which columns we want to be editable, to enable editing we need to configure the Ext.grid.Panel with a Ext.grid.plugin.CellEditing:\n\nAnd that's all it takes to create an editable Grid using cell editing. See Cell Editing for a working example.\n\nRow editing enables you to edit an entire row at a time, rather than editing cell by cell. Row editing works in exactly the same way as cell editing - all we need to do is change the plugin type to Ext.grid.plugin.RowEditing.\n\nSee Row Editing for a working example.\n\nOrganizing the rows into groups is easy. First we specify a groupField property on our store:\n\nNext, we configure a Grid with Ext.grid.feature.Grouping that will handle displaying the rows in groups:\n\nSee the Kitchen Sink's Grouping Grid Panel for a live example.\n\nSometimes your data set is too large to display all on one page. Ext.grid.Panel supports displaying individual pages from the dataset using a Ext.toolbar.Paging, which loads pages using previous/next buttons.\n\nBefore we can set up paging on a Ext.grid.Panel, we have to configure the Ext.data.Store to support paging. In the below example we add Ext.data.Store#pageSize to the Ext.data.Store, and we configure our Ext.data.reader.Reader with a Ext.data.reader.Reader#totalProperty:\n\nThe Ext.data.reader.Reader#totalProperty config tells Ext.data.reader.Json where to get the total number of results in the JSON response. This Ext.data.Store is configured to consume a JSON response that looks something like this:\n\nNow that we've set up our Ext.data.Store to support paging, all that's left is to configure a Ext.toolbar.Paging. You could put the Ext.toolbar.Paging anywhere in your application layout, but typically it is docked to the Ext.grid.Panel:\n\nSee the Paging Grid for a working example.\n\nGrids and Trees enable buffered rendering of extremely large datasets as an alternative to using a paging toolbar. Your users can scroll through thousands of records without the performance penalties of renderering all the records on screen at once.\n\nOnly enough rows are rendered to fill the visible area of the Grid with a little Ext.grid.Panel-cfg-leadingBufferZone overflow either side to allow scrolling. As scrolling proceeds, new rows are rendered in the direction of scroll, and rows are removed from the receding side of the table.\n\nGrids use buffered rendering by default, so you no longer need to add the plugin to your Grid component.\n\nSee Big Data of Filtered Tree for working examples.\n\nSince ExtJS 5.0, developers have had the ability to embed components within grid cells using the Widget Column class.\n\nIn versions prior to 6.2.0, components embedded in this way had no access to the grid's . The field referenced by the column's was bound to the component's .\n\nIn 6.2.0, components embedded in grids have access to the ViewModel and all the data within it. The ViewModel contains two row-specific properties:\n\nSince ExtJS 6.2.0, developers have had the ability to configure a component to be displayed in an expansion row below (or, configurably, above) the data row.\n\nThe embedded component has access to the grid's ViewModel.\n\nSee Using Components in Grids guide for more details."
    },
    {
        "link": "https://stackoverflow.com/questions/10993045/creating-a-dynamic-grid-with-extjs",
        "document": "That is a pretty old post so you may have more workarounds coming soon, but that error is because you do not have a model config or fields config defined for your store. The model will also need to be defined dynamically if you want your grid created with json data alone.\n\nAs far as I know, the fields config is pretty forgiving, so you may be able to just set this with a maximum possible number of fields like 20 or 30 or so, but the field names would have to match with the json field names for it to be usable. I.e. if you use:\n\nThen your json data would need to come from the database like:\n\nAnother thing I've done in the past is to have a reference store loaded first which contained a record with the name and datatype for each of the dynamic fields (meta data). Then I iterated through this reference store and added a model field and the column definition at each iteration, then I loaded the grid's store which now had the correct data model defined and the grid would have the correct column defintion.\n\nYou may have do something like that if you don't want to make your database return generic column names as covered above, because I don't know how you will load the data into your grid store initially before you give it a data model to use.\n\nI haven't tried it yet, but I just came across this in the 4.1 docs (scroll down to the \"Response MetaData\" section in the intro). It describes using metaData in your json response to accomplish exactly what you are going for with a dynamic model and grid columns.\n\nYou would probably still have to do the iteration I described above once you process the metaData, but you can use it to cut out that additional request to get the meta data.\n\nI suppose if your field configuration doesn't change with each request then it would be easier to simply to do the extra request at the beginning, but if you want something really dynamic this would do it."
    },
    {
        "link": "https://docs.sencha.com/extjs/7.0.0-CE/guides/components/grids.html",
        "document": "Ext.grid.Panel is one of the centerpieces of ExtJS. It's an incredibly versatile component that provides an easy way to display, sort, group, and edit data.\n\nLet's get started by creating a basic Ext.grid.Panel. Here's all you need to know to get a simple grid up and running:\n\nExt.grid.Panel is simply a component that displays data contained in a Ext.data.Store. Ext.data.Store can be thought of as a collection of records, or Ext.data.Model instances.\n\nThe benefit of this setup is separating our concerns. Ext.grid.Panel is only concerned with displaying the data, while Ext.data.Store takes care of fetching and saving the data using Ext.data.proxy.Proxy.\n\nFirst, we need to define a Ext.data.Model. A model is just a collection of fields that represents a type of data. Let's define a model that represents a \"User\":\n\nNext let's create a Ext.data.Store that contains several \"User\" instances.\n\nFor sake of ease, we configured Ext.data.Store to load its data inline. In a real world application, you would most likely configure the Ext.data.Store to use an Ext.data.proxy.Proxy to load data from the server.\n\nNow, we have a model, which defines our data structure. We have also loaded several model instances into an Ext.data.Store. Now we're ready to display the data using Ext.grid.Panel.\n\nIn this example, we configured the Grid with renderTo to immediately render the Grid into the HTML document.\n\nIn many situations, the grid will be a descendant of Ext.container.Viewport, which means rendering is already handled.\n\nAnd that's all there is to it.\n\nWe just created an Ext.grid.Panel that renders itself to the body element. We also told the Grid panel to get its data from the that we previously created.\n\nFinally, we defined the Grid panel's columns and gave them a dataIndex property. This associates a field from our model to a column.\n\nThe \"Name\" column has a fixed of \"100px\" and has sorting and hiding disabled. The \"Email Address\" column is hidden by default (it can be shown again by using the menu on any other column header). Finally, the \"Phone Number\" column flexes to fit the remainder of the Grid panel's total width.\n\nFor a larger example, see the Basic Grid Example.\n\nYou can use the renderer property of the column config to change the way in which data is displayed. A is a function that modifies the underlying value and returns a new value for display. Some of the most common renderers are included in Ext.util.Format, but you can write your own as well:\n\nSee the Kitchen Sink's Basic Grid for a live demo that uses custom renderers.\n\nIn accordance with accessibility guidelines, grid cells accept focus, and the focus rendition my be specified in the theme.\n\nArrow keys navigate the focus position in two dimensions. TAB tabs out of the grid into the following focusable element.\n\nThis is known as Navigable Mode, and is the default mode for handling focus within a grid.\n\nIf there are focusable elements within a cell (Such as [[Ext.grid.column.ActionColumn action columns]] then the actionable items may be accessed by using the ENTER or F2 key to enter Actionable Mode wherin focus navigation takes place within cells using the TAB key.\n\nCell editing which is discussed below is a special case of Actionable Mode.\n\nESC or F2 exits actionable mode, and focus pops up to the encapsulating cell of the recently focused actionable item.\n\nGrid panels can be used to simply display data. However, it is often necessary to interact with the Grid's data. All Grid panels have an Ext.selection.Model, which determines how data is selected. The most versatile Selection Model is Ext.grid.selection.SpreadsheetModel, which may be configured to select cells, rows, or columns, and to optionally display a selection checkbox if selecting rows.\n\nSee the Kitchen Sink's Spreadsheet Model for an example.\n\nOther selection models include Ext.selection.RowModel, where entire rows are selected, and Ext.selection.CellModel, where individual cells are selected. These are less flexible than the SpreadsheetModel.\n\nGrid panels use Ext.selection.RowModel by default, but it's easy to switch to an Ext.grid.selection.SpreadsheetModel:\n\nGrid panel has built-in support for editing. Let's look at the two main editing modes - row editing and cell editing.\n\nCell editing allows you to edit the data in a Grid panel one cell at a time. The first step in implementing cell editing is to configure an editor for each Ext.grid.column.Column in your Grid Panel that should be editable. This is done using the Ext.grid.column.Column#editor config. The simplest way is to specify just the xtype of the field you want to use as an editor:\n\nIf you need more control over how the editor field behaves, the Ext.grid.column.Column#editor config can also take a config object for a Field. For example, if we are using a Ext.form.field.Text and we want to require a value:\n\nYou can use any class in the \"Ext.form.field.*\" package as an editor field. Lets suppose we want to edit a column that contains dates. We can use a Ext.form.field.Date editor:\n\nAny Ext.grid.column.Column in a Ext.grid.Panel that do not have a ] configured will not be editable.\n\nNow that we've configured which columns we want to be editable, to enable editing we need to configure the Ext.grid.Panel with a Ext.grid.plugin.CellEditing:\n\nAnd that's all it takes to create an editable Grid using cell editing. See Cell Editing for a working example.\n\nRow editing enables you to edit an entire row at a time, rather than editing cell by cell. Row editing works in exactly the same way as cell editing - all we need to do is change the plugin type to Ext.grid.plugin.RowEditing.\n\nSee Row Editing for a working example.\n\nOrganizing the rows into groups is easy. First we specify a groupField property on our store:\n\nNext, we configure a Grid with Ext.grid.feature.Grouping that will handle displaying the rows in groups:\n\nSee the Kitchen Sink's Grouping Grid Panel for a live example.\n\nSometimes your data set is too large to display all on one page. Ext.grid.Panel supports displaying individual pages from the dataset using a Ext.toolbar.Paging, which loads pages using previous/next buttons.\n\nBefore we can set up paging on a Ext.grid.Panel, we have to configure the Ext.data.Store to support paging. In the below example we add Ext.data.Store#pageSize to the Ext.data.Store, and we configure our Ext.data.reader.Reader with a Ext.data.reader.Reader#totalProperty:\n\nThe Ext.data.reader.Reader#totalProperty config tells Ext.data.reader.Json where to get the total number of results in the JSON response. This Ext.data.Store is configured to consume a JSON response that looks something like this:\n\nNow that we've set up our Ext.data.Store to support paging, all that's left is to configure a Ext.toolbar.Paging. You could put the Ext.toolbar.Paging anywhere in your application layout, but typically it is docked to the Ext.grid.Panel:\n\nSee the Paging Grid for a working example.\n\nGrids and Trees enable buffered rendering of extremely large datasets as an alternative to using a paging toolbar. Your users can scroll through thousands of records without the performance penalties of renderering all the records on screen at once.\n\nOnly enough rows are rendered to fill the visible area of the Grid with a little Ext.grid.Panel#cfg-leadingBufferZone overflow either side to allow scrolling. As scrolling proceeds, new rows are rendered in the direction of scroll, and rows are removed from the receding side of the table.\n\nGrids use buffered rendering by default, so you no longer need to add the plugin to your Grid component.\n\nSee Big Data of Filtered Tree for working examples.\n\nSince ExtJS 5.0, developers have had the ability to embed components within grid cells using the Widget Column class.\n\nIn versions prior to 6.2.0, components embedded in this way had no access to the grid's . The field referenced by the column's was bound to the component's .\n\nIn 6.2.0, components embedded in grids have access to the ViewModel and all the data within it. The ViewModel contains two row-specific properties:\n\nSince ExtJS 6.2.0, developers have had the ability to configure a component to be displayed in an expansion row below (or, configurably, above) the data row.\n\nThe embedded component has access to the grid's ViewModel.\n\nSee Using Components in Grids guide for more details."
    },
    {
        "link": "https://docs.modx.com/3.x/en/extending-modx/custom-manager-pages/modext/modext-tutorials/7.-ext-js-tutoral-advanced-grid",
        "document": "The budget raised through OpenCollective is transparent, including payouts, and any contributor can apply to be paid for their work on MODX.\n\nExt JS can save us time by handling formatting of tables. But an Ext JS Grid is more than a simple table: they can include sortable columns and they can paginate long result sets or let the users select rows. Ext JS Grids do a lot of stuff that a basic HTML table does not. So how do we make one?\n• A page to display the grid (this is the obvious page you were already thinking of)\n• A dynamic PHP page to query the data that populates the table (called a \"store\")\n\nThis can be a simple HTML page. In our example here, we're putting this alongside the MODX index.php in your docroot. Just like all the examples before, we include the Ext JS CSS and Javascript.\n\nThis is a PHP file or a Snippet – here we're putting this alongside your MODX index.php file, so we have to add a few extra lines to gain access to the $modx object. Normally this code would be in a Snippet or in a CMP, so you'd already have access to the $modx object.\n\nYou can view the store.php in a browser and you should see some JSON data. If you're trying to see what's being posted to this file from the grid page, use the MODX log function to log the posted data."
    },
    {
        "link": "https://docs.sencha.com/extjs/6.5.0/classic/Ext.data.Store.html",
        "document": ""
    },
    {
        "link": "https://docs.sencha.com/extjs/7.8.0/modern/Ext.data.Store.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/32886162/how-to-create-pagination-on-sencha-ext-data-store",
        "document": "I am trying to create a table with pagination, and it seems that it must be done using the Ext.data.Store. So I create one in the following way:\n\nThe collention being passed as data (the _this.collection.toJSON()) is the following:\n\nHowever in the final result table ExtJS does not limit the result to only 3 results per page.\n\nI have searched the documentation and googled a lot and I have come to nowhere. I have also seen people using a proxy option to receive the data, and to perform modifications to the server in order to make the server support pagination.\n\nI cannot do that here, the data I receive comes this way and this way it will be until the end because I cannot change the server. Moreover, it is wrong to change the backend server's logic because of front-end GUI details.\n\nWhat can I do? This should be straight forward. The Store object has all the data it needs to display, it just needs to split it into pages, that is nothing out of this world, if the only way of doing this is by modifying the server then I don't know..."
    },
    {
        "link": "https://stackoverflow.com/questions/21422041/extjs-paging-and-buffering-grid-based-on-remote-data-without-remote-paging-and",
        "document": "In ExtJs, remote data can be easily displayed in a paged grid. But for this to happen, the server side must support paging. Furthermore, local sorting and filtering in a paged grid is not useful, because it only filters the elements of the current page. In order to get consistent results, remote filtering and sorting is required. For buffered stores in infinite scrolling grids the same applies.\n\nBut this is not always the right solution. Especially when remote data retrieval takes some time, the user experience on filtering will degrade. Also we cannot use javascript functions to filter or sort.\n\nA solution would be to have ExtJs reading all the data at once, and use that local copy of the data to filter and sort the data. We would the need a intermediate store for the whole dataset, and the main store linked to the grid to display the data. But this would require that the main proxy has the intermediate store as datasource, and as far as I understand, a proxy cannot have another store as datasource.\n\nDoes someone have an idea how to solve this issue ? I'm not sure if the sketched solution is viable, but what I need is somehow to reconcile having a remote .json datasource and using local paging, filtering and sorting.\n\nHow can I achieve this ?"
    },
    {
        "link": "https://cailiandist.oss-cn-beijing.aliyuncs.com/docs/extjs-602-docs/extjs/6.0.2/classic/Ext.data.Store.html",
        "document": ""
    }
]