[
    {
        "link": "https://w3schools.com/cpp/cpp_arrays_multi.asp",
        "document": "A multi-dimensional array is an array of arrays.\n\nTo declare a multi-dimensional array, define the variable type, specify the name of the array followed by square brackets which specify how many elements the main array has, followed by another set of square brackets which indicates how many elements the sub-arrays have:\n\nAs with ordinary arrays, you can insert values with an array literal - a comma-separated list inside curly braces. In a multi-dimensional array, each element in an array literal is another array literal.\n\nEach set of square brackets in an array declaration adds another dimension to an array. An array like the one above is said to have two dimensions.\n\nArrays can have any number of dimensions. The more dimensions an array has, the more complex the code becomes. The following array has three dimensions:\n\nTo access an element of a multi-dimensional array, specify an index number in each of the array's dimensions.\n\nThis statement accesses the value of the element in the first row (0) and third column (2) of the letters array.\n\nTo change the value of an element, refer to the index number of the element in each of the dimensions:\n\nTo loop through a multi-dimensional array, you need one loop for each of the array's dimensions.\n\nThe following example outputs all elements in the letters array:\n\nThis example shows how to loop through a three-dimensional array:\n\nMulti-dimensional arrays are great at representing grids. This example shows a practical use for them. In the following example we use a multi-dimensional array to represent a small game of Battleship:\n\n// We put \"1\" to indicate there is a ship.\n\nbool ships[4][4] = {\n\n { 0, 1, 1, 0 },\n\n { 0, 0, 0, 0 },\n\n { 0, 0, 1, 0 },\n\n { 0, 0, 1, 0 }\n\n};\n\n\n\n// Keep track of how many hits the player has and how many turns they have played in these variables\n\nint hits = 0;\n\nint numberOfTurns = 0;\n\n\n\n// Allow the player to keep going until they have hit all four ships\n\nwhile (hits < 4) {\n\n int row, column;\n\n\n\n cout << \"Selecting coordinates\n\n\";\n\n\n\n // Ask the player for a row\n\n cout << \"Choose a row number between 0 and 3: \";\n\n cin >> row;\n\n\n\n // Ask the player for a column\n\n cout << \"Choose a column number between 0 and 3: \";\n\n cin >> column;\n\n\n\n // Check if a ship exists in those coordinates\n\n if (ships[row][column]) {\n\n // If the player hit a ship, remove it by setting the value to zero.\n\n ships[row][column] = 0;\n\n\n\n // Increase the hit counter\n\n hits++;\n\n\n\n // Tell the player that they have hit a ship and how many ships are left\n\n cout << \"Hit! \" << (4-hits) << \" left.\n\n\n\n\";\n\n } else {\n\n // Tell the player that they missed\n\n cout << \"Miss\n\n\n\n\";\n\n }\n\n\n\n // Count how many turns the player has taken\n\n numberOfTurns++;\n\n}\n\n\n\n cout << \"Victory!\n\n\";\n\ncout << \"You won in \" << numberOfTurns << \" turns\"; Run Example »"
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/arrays",
        "document": "foo[5]; foo[2] = 75; // access to an element of the array."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/arrays-cpp?view=msvc-170",
        "document": "An array is a sequence of objects of the same type that occupy a contiguous area of memory. Traditional C-style arrays are the source of many bugs, but are still common, especially in older code bases. In modern C++, we strongly recommend using or instead of C-style arrays described in this section. Both of these standard library types store their elements as a contiguous block of memory. However, they provide greater type safety, and support iterators that are guaranteed to point to a valid location within the sequence. For more information, see Containers.\n\nIn a C++ array declaration, the array size is specified after the variable name, not after the type name as in some other languages. The following example declares an array of 1000 doubles to be allocated on the stack. The number of elements must be supplied as an integer literal or else as a constant expression. That's because the compiler has to know how much stack space to allocate; it can't use a value computed at run-time. Each element in the array is assigned a default value of 0. If you don't assign a default value, each element initially contains whatever random values happen to be at that memory location.\n\nThe first element in the array is the zeroth element. The last element is the (n-1) element, where n is the number of elements the array can contain. The number of elements in the declaration must be of an integral type and must be greater than 0. It is your responsibility to ensure that your program never passes a value to the subscript operator that is greater than .\n\nA zero-sized array is legal only when the array is the last field in a or and when the Microsoft extensions are enabled ( or isn't set).\n\nStack-based arrays are faster to allocate and access than heap-based arrays. However, stack space is limited. The number of array elements can't be so large that it uses up too much stack memory. How much is too much depends on your program. You can use profiling tools to determine whether an array is too large.\n\nYou may require an array that's too large to allocate on the stack, or whose size isn't known at compile time. It's possible to allocate this array on the heap by using a expression. The operator returns a pointer to the first element. The subscript operator works on the pointer variable the same way it does on a stack-based array. You can also use pointer arithmetic to move the pointer to any arbitrary elements in the array. It's your responsibility to ensure that:\n• you always keep a copy of the original pointer address so that you can delete the memory when you no longer need the array.\n• you don't increment or decrement the pointer address past the array bounds.\n\nThe following example shows how to define an array on the heap at run time. It shows how to access the array elements using the subscript operator and by using pointer arithmetic:\n\nYou can initialize an array in a loop, one element at a time, or in a single statement. The contents of the following two arrays are identical:\n\nWhen an array is passed to a function, it's passed as a pointer to the first element, whether it's a stack-based or heap-based array. The pointer contains no other size or type information. This behavior is called pointer decay. When you pass an array to a function, you must always specify the number of elements in a separate parameter. This behavior also implies that the array elements aren't copied when the array gets passed to a function. To prevent the function from modifying the elements, specify the parameter as a pointer to elements.\n\nThe following example shows a function that accepts an array and a length. The pointer points to the original array, not a copy. Because the parameter isn't , the function can modify the array elements.\n\nDeclare and define the array parameter as to make it read-only within the function block:\n\nThe same function can also be declared in these ways, with no change in behavior. The array is still passed as a pointer to the first element:\n\nArrays constructed from other arrays are multidimensional arrays. These multidimensional arrays are specified by placing multiple bracketed constant expressions in sequence. For example, consider this declaration:\n\nIt specifies an array of type , conceptually arranged in a two-dimensional matrix of five rows and seven columns, as shown in the following figure:\n\nThe image is a grid 7 cells wide and 5 cells high. Each cell contains the index of the cell. The first cell index is labeled 0,0. The next cell in that row is 0,1 and so on to the last cell in that row which is 0,6. The next row starts with the index 1,0. The cell after that has an index of 1,1. The last cell in that row is 1,6. This pattern repeats until the last row, which starts with the index 4,0. The last cell in the last row has an index of 4,6. :::image-end\n\nYou can declare multidimensioned arrays that have an initializer list (as described in Initializers). In these declarations, the constant expression that specifies the bounds for the first dimension can be omitted. For example:\n\nThe preceding declaration defines an array that is three rows by four columns. The rows represent factories and the columns represent markets to which the factories ship. The values are the transportation costs from the factories to the markets. The first dimension of the array is left out, but the compiler fills it in by examining the initializer.\n\nUse of the indirection operator (*) on an n-dimensional array type yields an n-1 dimensional array. If n is 1, a scalar (or array element) is yielded.\n\nC++ arrays are stored in row-major order. Row-major order means the last subscript varies the fastest.\n\nYou can also omit the bounds specification for the first dimension of a multidimensional array in function declarations, as shown here:\n\nThe function is written such that adding new factories doesn't require any code changes, just a recompilation.\n\nArrays of objects that have a class constructor are initialized by the constructor. When there are fewer items in the initializer list than elements in the array, the default constructor is used for the remaining elements. If no default constructor is defined for the class, the initializer list must be complete, that is, there must be one initializer for each element in the array.\n\nConsider the class that defines two constructors:\n\nThe first element of is constructed using the constructor ; the remaining two elements are constructed using the default constructor.\n\nStatic member arrays (whether or not) can be initialized in their definitions (outside the class declaration). For example:\n\nYou can access individual elements of an array by using the array subscript operator ( ). If you use the name of a one-dimensional array without a subscript, it gets evaluated as a pointer to the array's first element.\n\nWhen you use multidimensional arrays, you can use various combinations in expressions.\n\nIn the preceding code, is a three-dimensional array of type . The pointer points to an array of type of size three. In this example, the array is used with one, two, and three subscripts. Although it's more common to specify all subscripts, as in the statement, sometimes it's useful to select a specific subset of array elements, as shown in the statements that follow .\n\nLike other operators, the subscript operator ( ) can be redefined by the user. The default behavior of the subscript operator, if not overloaded, is to combine the array name and the subscript using the following method:\n\nAs in all addition that involves pointer types, scaling is done automatically to adjust for the size of the type. The resultant value isn't n bytes from the origin of ; instead, it's the nth element of the array. For more information about this conversion, see Additive operators.\n\nSimilarly, for multidimensional arrays, the address is derived using the following method:\n\nWhen an identifier of an array type appears in an expression other than , address-of ( ), or initialization of a reference, it's converted to a pointer to the first array element. For example:\n\nThe pointer points to the first element of the array . Arrays, unlike pointers, aren't modifiable l-values. That's why the following assignment is illegal:"
    },
    {
        "link": "https://geeksforgeeks.org/cpp-multidimensional-array",
        "document": "A multidimensional array is an array with more than one dimension. It means that it can grow in different directions i.e. instead of changing the length only, it can also change in width, depth or more. It is the homogeneous collection of items where each element is accessed using multiple indices.\n\nwhere s1, s2,…, sn is the size of each dimension.\n\nFor 1D array, the length of the array is simply its size too. But multidimensional arrays have extra dimensions. So, the size of each dimension is considered separately. The number of elements is the product of all its dimensions’ size. It is similar to calculating area in 2D and volume in 3D.\n\nFor example, consider the below array:\n• None The size in bytes can be calculated by multiplying the number of elements by size of each element or we can just use sizeof operator.\n• None In this case, size in bytes = 4*8 = 32 bytes\n\nTo verify the above calculation, we can use sizeof() method to find the size of an array.\n\nWe can have any number of dimensions in an array as per requirement, but the complexity of handling them also increases exponentially. That is why, the most widely used multidimensional arrays are:\n\nA two-dimensional array in C++ is a collection of elements organized the form of rows and columns. It can be visualized as a table or a grid, where each element is accessed using two indices: one for the row and one for the column. Like a one-dimensional array, two-dimensional array indices also range from 0 to n-1 for both rows and columns.\n\nLike 1D arrays, 2D arrays can also be initialized using a list of values enclosed inside {} curly brackets, but as 2D arrays have two dimensions, the list is nested inside another list to initialize each dimension one by one. It means that each row values are nested inside one big list.\n\nNesting can also be omitted, and values will still be assigned sequentially.\n\nThe above array has 2 rows and 4 columns. The elements are filled in a way that the first 4 elements are filled in the first row and the next 4 elements are filled in the second row. The values will be initialized sequentially.\n\nIt is to be noted that the number of values should not exceed the total number of elements an array can store. It can have less values (partial initialization) but cannot have more values.\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nElements of a 2-dimensional array have to be accessed using row and column indices. It is similar to matrix element position, but the only difference is that here indexing starts from 0.\n\nwhere, i is the index of row and j is the index of the column. The range of indexes should be:\n\nAny values other than that leads to the segmentation fault.\n\nThe value at any index can be updated by using = assignment operator.\n\nThe new_value should be of same data type.\n\nTwo loops nested inside each other are needed to traverse a 2D array, one for moving though each dimension. First loop is used to move though the rows of 2D array, while other is used to move though columns in each row to access all the elements of the row.\n\nA three-dimensional array in C++ is a collection of elements organized in a 3D cuboid-like structure. It can be visualized as a series of two-dimensional arrays stacked on top of each other. Each element is accessed using three indices: one for the depth, one for the row, and one for the column.\n\nTo declare a 3D array in C++, we need to specify its third dimension along with 2D dimensions.\n\nwhere depth is the number of 2D arrays in it.\n\nLike 2D arrays, 3D arrays can also be initialized using a list of values enclosed inside {} curly brackets. However, in a 3D array, the values are grouped into 2D arrays, and each 2D array is nested inside another set of curly brackets.\n\nAlternatively, nesting can be omitted, and the values will still be filled sequentially:\n\nThis array has 2 layers (depth), 2 rows per layer, and 3 columns per row. The values are filled sequentially across the layers.\n\nIt is important to note that the number of values should not exceed the total number of elements the array can store. If fewer values are provided, the rest of the array is initialized to 0 (partial initialization).\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nThe elements of a 3D array are accessed using three indices: depth, row, and column. These indices must be within the following ranges:\n\nTo update a value at any index of a 3D array, use the assignment operator = while accessing the element:\n\nTo traverse a 3D array, you need three nested loops: one for each dimension (depth, row, column).\n\nIn C++, you can pass multidimensional arrays to functions. Since multidimensional arrays have more than one dimension, the function signature needs to account for all dimensions.\n\nTo pass a 2D array to a function, you can specify the number of columns (or other dimensions) in the function signature. The number of rows can be deduced automatically.\n\nTo pass a 3D array to a function, you need to specify the size of the second and third dimensions."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/array",
        "document": "An array declaration is any simple declaration whose declarator has the form\n\nA declaration of the form T a[N];, declares a as an array object that consists of N contiguously allocated objects of type . The elements of an array are numbered ​0​, …, N - 1, and may be accessed with the subscript operator [], as in a[0], …, a[N - 1].\n\nArrays can be constructed from any fundamental type (except void), pointers, pointers to members, classes, enumerations, or from other arrays of known bound (in which case the array is said to be multi-dimensional). In other words, only object types except for array types of unknown bound can be element types of array types. Array types of incomplete element type are also incomplete types.\n\nThere are no arrays of references or arrays of functions.\n\nApplying cv-qualifiers to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.\n\nWhen used with new[]-expression, the size of an array may be zero; such an array has no elements:\n\nObjects of array type cannot be modified as a whole: even though they are lvalues (e.g. an address of array can be taken), they cannot appear on the left hand side of an assignment operator:\n\nThere is an implicit conversion from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:\n\nWhen the element type of an array is another array, it is said that the array is multidimensional:\n\nNote that when array-to-pointer decay is applied, a multidimensional array is converted to a pointer to its first element (e.g., a pointer to its first row or to its first plane): array-to-pointer decay is applied only once.\n\nIf expr is omitted in the declaration of an array, the type declared is \"array of unknown bound of T\", which is a kind of incomplete type, except when used in a declaration with an aggregate initializer:\n\nBecause array elements cannot be arrays of unknown bound, multidimensional arrays cannot have unknown bound in a dimension other than the first:\n\nIf there is a preceding declaration of the entity in the same scope in which the bound was specified, an omitted array bound is taken to be the same as in that earlier declaration, and similarly for the definition of a static data member of a class:\n\nReferences and pointers to arrays of unknown bound can be formed, but cannot(until C++20)and can(since C++20) be initialized or assigned from arrays and pointers to arrays of known bound. Note that in the C programming language, pointers to arrays of unknown bound are compatible with pointers to arrays of known bound and are thus convertible and assignable in both directions.\n\nPointers to arrays of unknown bound cannot participate in pointer arithmetic and cannot be used on the left of the subscript operator, but can be dereferenced.\n\nAlthough arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array prvalues may be formed by using a type alias to construct an array temporary using brace-initialized functional cast.\n\nArray xvalues may be formed directly by accessing an array member of a class rvalue or by using std::move or another cast or function call that returns an rvalue reference.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/getch-function-in-c-plus-plus",
        "document": "In this article, we’ll take a look at using the getch() function in C/C++.\n\nThe getch() function is very useful if you want to read a character input from the keyboard.\n\nWhile this is not a part of the C standard, this is still a POSIX C function. So, we can still use this function from Windows / Linux / Mac.\n\nLet’s take a look at using this function, using a few examples.\n\nThis function takes in a single character from the standard input ( ), and returns an integer.\n\nThis is there as part of the header file, so you must include it in your program.\n\nThis function does not take any parameters.\n\nHere, returns the ASCII value of the character read from .\n\nFor example, if we give the character ‘0’ as input, it will return the ASCII value of ‘0’, which is 49.\n\nNow, in C / C++, we can directly convert a character to an integer. So on typecasting, the ASCII value 49 will be cast to the value of ‘0’!\n\nLet’s now look at some examples.\n\nUsing getch() in C/C++ - Some Examples\n\nAs a simple example, let’s first look at reading a single character.\n\nI got this output, after I typed ‘a’ on my keyboard. Let’s now look at a program, which waits for 5 characters from the keyboard.\n\nNote that will NOT display the input from the keyboard. So, when you type the input, the cursor won’t show the input.\n\nLet’s display the complete string only after we get all 5 characters\n\nIndeed, when I typed “Hello”, I did get the output correctly.\n\nNotice that I have 6 characters in my output string, since we need to reserve 1 byte for ‘\\0’. So is “Hello\\0”.\n\nIn this article, we learned about using the getch() function in C / C++ to receive character input from the keyboard.\n\nFor more content on C and C++, do go through our tutorial section on C programming!\n• Linux Manual Page on getch() function in C"
    },
    {
        "link": "https://geeksforgeeks.org/getch-function-in-c-with-examples",
        "document": "getch() is a nonstandard function and is present in conio.h header file which is mostly used by MS-DOS compilers like Turbo C. It is not part of the C standard library or ISO C, nor is it defined by POSIX.\n\nLike these functions, getch() also reads a single character from the keyboard. But it does not use any buffer, so the entered character is immediately returned without waiting for the enter key.\n\nSyntax: \n\n\n\n\n\nParameters: This method does not accept any parameters.\n\nReturn value: This method returns the ASCII value of the key pressed.\n\nExample:\n• None getch() method pauses the Output Console until a key is pressed.\n• None It does not use any buffer to store the input character.\n• None The entered character is immediately returned without waiting for the enter key.\n• None The entered character does not show up on the console.\n• None The getch() method can be used to accept hidden inputs like password, ATM pin numbers, etc.\n\nExample: To accept hidden passwords using getch()\n\nNote: Below code won’t run on Online compilers, but on MS-DOS compilers like Turbo IDE.\n\n\n\n// C code to illustrate working of // Now the hidden input is stored in pwd[] // So any operation can be done on it // Here we are just printing // Now the console will wait // for a key to be pressed"
    },
    {
        "link": "https://stackoverflow.com/questions/59811334/what-is-the-relationship-between-include-conio-h-and-getch-method",
        "document": "is declared inside the header file of , so you need to set the preprocessor directive in order to you use . Without you can not use .\n\nNote: is not supported by all C/C++ implementations and is not part of the C standard libraries. Rather use or for catching a character from the input if you want to compile C or C++ code on Unix or Linux.\n\nMam, thank you for pointing out me. But, it would be very helpful to understand if you put some clarification of using it, mam.\n\nBeside the case, that this is not the question you have asked for, this is not how Stack Overflow works. This is not a tutorial platform; it is a platform to ask for help if you did not understand a certain topic. You need to declare what you did not understand and we can help you.\n\nIf you look for a tutorial about , here is one:\n\nBy the way, I´m not a Mam, but Ok."
    },
    {
        "link": "https://centron.de/en/tutorial/using-the-getch-function-in-c-c",
        "document": "How to Install SonarQube on Ubuntu 24.04 – Step-by-Step Guide\n\nInstalling SonarQube on Ubuntu 24.04 SonarQube is an open-source platform used to continuously inspect and manage code quality. It detects bugs, vulnerabilities, and tracks code quality through static analysis with…"
    },
    {
        "link": "https://stackoverflow.com/questions/1377403/alternative-function-in-iostream-h-for-getch-of-conio-h",
        "document": "The functions are compiler extensions to the language, not part of C or C++. There isn't a direct replacement in standard C++.\n\nFor getch(), is probably the closest equivalent -- but bear in mind that this will read from buffered standard input, whereas I think the conio.h does an unbuffered read.\n\nAny implementation of is going to be very platform-dependent -- not all screens or terminals have a notion of clearing, and those that do have wildly differing ways to access that functionality.\n\nIf you need to treat the terminal as something other than a set of character streams, your best bet is probably to look for a library which hides the details of the underlying terminal, screen or console from you. If you're on a UNIXish system, look at the curses or ncurses library; I don't know of any suggestions for other OSes."
    },
    {
        "link": "https://stackoverflow.com/questions/46695812/summing-2d-array-columns-in-c",
        "document": "There are quite a few errors on your code, and it has quite a weird structure, but trying not to change it too much (so it's still easy for you to follow the fixes), let's see it fixed then I'll explain it (please note that this version will compile and run in practice):\n\nOk, so, first, you should only declare the array after you know what \"n\" and \"m\" variables are. Edit: also, not all compilers will accept declaring the dynamic array that way, but again, I tried to keep your original structure as much as possible.\n\nSecond, in your input loop, you should index the array by \"i\" and \"ii\", but you were always indexing by \"n\" and \"m\", that is, only writing to the latest index, which would even cause an exception.\n\nLast, while summing, again you should use \"i\" and \"ii\" as array indices, so you correctly scan the array.\n\nAnd that is it."
    },
    {
        "link": "https://stackoverflow.com/questions/47719719/sum-of-each-row-and-column-in-2d-array-c",
        "document": "Although this compiles, it is poorly-defined code, and is unnecessarily subject to failure if the global variables and are not set correctly. There is no need for that level of coupling, and if you do use that level of coupling, the variables and are superfluous. You should be using:\n\nThis allows the code to be used to print any shape of matrix using VLA (variable length array) notations. The variables and should be unnecessary; the parameters and seem to be pointless too since you ignore the values passed to the function, setting both to at the start of the loops.\n\nThe code in the (renamed) function maintains the question's variable names, though they aren't the names I'd use in my own code. (For those, see the \"Analysis of another answer\" section.)\n\nNote that this prints the inputs so that the outputs can be checked manually against the inputs. This is a useful technique in debugging.\n\nIn an answer (revision 1), Jozeph has shown code which, it is claimed, works. When indented in an orthodox format, the code is:\n\nThere are multiple problems with this code, some already identified but repeated in a marginally different form here:\n• The size of the matrix is identified by the values in the file scope (global) variables and .\n• The size of the matrix is also identified by the parameters and .\n• The values in the parameters and are unused; they're just a peculiar way of defining two local loop variables.\n• Assuming it is possible to , the first pair of nested loops (which sum the rows) is OK.\n• Assuming it is possible to (square matrix), the second pair of nested loop (which sum the columns) is OK, but it is mostly by accident rather than design.\n• However, if the global variables are not in sync with the parameters, then the calculations in the first pair of nested loops are incorrect because the loops use the size x but the function assumes the array has size x .\n• Similarly, if the global variables are not in sync with the parameters, or if the matrix is not square, the calculations in the second pair of nested loops are incorrect. It doesn't even produce one 'column sum' for each column.\n\nHere is an adaptation of my original answer to include the proposed answer (shown above) with some debug (read-only) printing added. It also includes a minor variant of my original proposed function — the variables are renamed to suit my prejudices (short names for loop variables, longer names for function parameters, etc), plus the debug printing code. The code also prints row sums before column sums to match the proposed answer's sequence, and it identifies the rows starting at row 1, column 1 instead of row 0, column 0.\n\nThere's also a 'bogus' variant of my answer ( ) that uses the and variables to size the array; it produces the wrong answers when and are not in synchrony with and . There's also a 'bogus' variant of the proposed answer ( ) which does at least sum columns correctly if the array size in and matches both and .\n\nThe output from the code shown is:\n\nYou can tweak when the debug is set on or off to get different amounts of output, but careful scrutiny of the results shows various discrepancies with the actual sums of rows and columns for the matrices defined in the program.\n\nThe fact that the proposed answer gets the 'right' answer on square matrices when the globals are synchronized with the parameters shows why it is important to do thorough testing.\n\nIf the code is only meant to handle square matrices, you'd not have both and (and you wouldn't need both and ). But you shouldn't tie the function to the global variables are all; you should define and (or just one of them if the matrix must be square).\n\nThis also shows why an MCVE (Minimal, Complete, Verifiable Example) is important. The values in the variables and are not documented in the question or the proposed answer, so it was necessary to tease out the implications of what they represent."
    },
    {
        "link": "https://geeksforgeeks.org/program-to-find-sum-of-elements-in-a-given-2d-array",
        "document": "Program to find sum of elements in a given 2D array\n\nGiven a 2D array of order M * N, the task is to find out the sum of elements of the matrix.\n\nThe sum of each element of the 2D array can be calculated by traversing through the matrix and adding up the elements.\n\nBelow is the implement the above approach-\n\nAnother Method: Using STL. Calling the inbuilt function for sum of elements of an array in STL. We use accumulate( first, last, sum) function to return the sum of 1D array.\n\nBelow is the implementation of idea.\n\nTime Complexity: O(n*m) (where n = no. of rows and m = no. of column)\n\nAnother Approach : Using pointers\n\nWe can also use pointers to find the sum of elements in a 2D array. We can use a pointer to point to the first element of the array and iterate through each element in the array by incrementing the pointer.\n• Define a function named sum that takes a 2D array of integers as input and returns an integer value.\n• In the sum function, declare a pointer ptr of type integer and assign it the address of the first element of the 2D array using &arr[0][0].\n• Declare another pointer end of type integer and assign it the address of the element one beyond the last element of the 2D array, by adding 1 to the address of the last element of the array &arr[M-1][N-1]. This way we can make imaginary indexes.\n• Declare an integer variable sum and initialize it to zero.\n• Using a loop that iterates over the elements of the 2D array, add each element to sum by dereferencing the pointer p.\n\nThis is because the function sum() iterates through each element of the matrix using a pointer, taking O(M*N) time.\n\nThis is because the function sum() uses a constant amount of extra space for the pointers and the sum variable, taking O(1) space."
    },
    {
        "link": "https://geeksforgeeks.org/program-to-find-the-sum-of-each-row-and-each-column-of-a-matrix",
        "document": "Program to find the Sum of each Row and each Column of a Matrix\n\nGiven a matrix mat of size m × n, the task is to compute the sum of each row and each column of the matrix.\n\nInput: mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] \n\n Output: Sum of row 0 = 10 \n\nSum of row 1 = 26 \n\nSum of row 2 = 42 \n\nSum of row 3 = 58 \n\nSum of column 0 = 28 \n\nSum of column 1 = 32 \n\nSum of column 2 = 36 \n\nSum of column 3 = 40 Input: mat= [ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4] ] \n\nOutput: Sum of row 0 = 4 \n\nSum of row 1 = 8 \n\nSum of row 2 = 12 \n\nSum of row 3 = 16 \n\nSum of column 0 = 10 \n\nSum of column 1 = 10 \n\nSum of column 2 = 10 \n\nSum of column 3 = 10\n\nThe idea is to compute the sum of each row and each column separately. First, iterate through each row, summing up its elements and storing the result. Then, iterate through each column, summing up its elements and storing the result. This ensures that all row sums are calculated before moving to column sums. The final result contains row sums followed by column sums.\n\n// C++ program to find the sum // of each row and column of a matrix // of each row and column of a matrix # of each row and column of a matrix // C# program to find the sum // of each row and column of a matrix // of each row and column of a matrix\n\nTime Complexity: O(m * n), as we traverse the entire matrix twice (once for rows and once for columns).\n\nAuxiliary Space: O(m + n), as we store the sum of each row and each column in the result array."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/114387",
        "document": "std; main() { array[4][5], array1[4], array2[5], sum1, sum2; sum1=0; sum2=0; ( x=0; x<4; x++) ( y=0; y<5; y++) { cout<< <<x<< <<y<< <<endl; cin>>array[x][y]; } { ( x=0; x<4; x++) ( y=0; y<5; y++) { sum1+=array[x]; sum2+=array[y]; strcpy (array1,sum1); strcpy (array2,sum2); cout<<array1<<endl; cout<<array2<<endl; } } system ( ); 0; } Put the code you need help with here. So here's another interesting task. I know, i'm on the right path, just something doesn't work here. Basicly I have to sum rows and columns of 2d array and then store the results in separate arrays, as far as the code is now, can see it quite clearly. any advice?!\n\n\n\n \n\n First off, you really need to fix your placement of curly braces and indentation:\n\n \n\n \n\n \n\n Then, strcpy() is used to copy c-strings, so it's not ideal for an array of ints. need to change your logic a little:\n\n \n\n \n\n \n\n \n\n Printing the arrays also needs a for loop:\n\n \n\n \n\n \n\n Hope that helps, please don't hesitate to ask if you have any further questions.\n\n \n\n All the best,\n\n NwN Hi there,First off, you really need to fix your placement of curly braces and indentation:Then, strcpy() is used to copy c-strings, so it's not ideal for an array of ints. need to change your logic a little:Printing the arrays also needs a for loop:Hope that helps, please don't hesitate to ask if you have any further questions.All the best,NwN\n\n\n\n std::cout; main() { array[6][7], columntotal[6] = {0}, rowtotal[7] = {0}; x, y, z = 1; //x & y are just used to iterate around loops, z will be used to fill up the array with some numbers. (x = 0; x < 6; ++x) //Just fill up the array with some numbers. { (y = 0; y < 7; ++y) { array[x][y] = z; ++z; } } (x = 0; x < 6; ++x) { (y = 0; y < 7; ++y) { columntotal[x] = columntotal[x] + array[x][y]; } } (x = 0; x < 6; ++x) //Output the value of each column. { cout << columntotal[x] << ; } 0; } \n\n \n\n That will sum columns. I'll leave it to you to figure out how to sum the rows. Btw, you are not using any functions from <cmath> so no need to include that header file.\n\n \n\n As for the problems in your original code: \n\n \n\n \n\n When accessing the elements in a 2d array, you must always refer to both dimensions to get the information. \n\n \n\n \n\n Would be valid for example. \n\n \n\n \n\n \n\n The way you are using strcpy here is incorrect. Also, strcopy requires inclusion of <cstring>. Hmm anyway I suggest reading about what strcopy does: \n\n And not using it in this program, because you don't need to. \n\n \n\n You should also avoid using: \n\n \n\n \n\n Try perhaps to use getchar() or something and try not to use system(\"anything\").\n\n \n\n Here is a simple way to do what you want to achieve:That will sum columns. I'll leave it to you to figure out how to sum the rows. Btw, you are not using any functions from so no need to include that header file.As for the problems in your original code:When accessing the elements in a 2d array, you must always refer to both dimensions to get the information.Would be valid for example.The way you are using strcpy here is incorrect. Also, strcopy requires inclusion of . Hmm anyway I suggest reading about what strcopy does: http://www.cplusplus.com/reference/cstring/strcpy/ And not using it in this program, because you don't need to.You should also avoid using:Try perhaps to use getchar() or something and try not to use system(\"anything\").\n\nGreat! thanks all your advices helped to get sums properly now and sort out all the mess in my code :) but still I have to sleep on this! This is a task for school therefore i have teachers rules to follow, yes i can use <cstring>, guess that would make things easier, functions there are quite useful.\n\n\n\n \n\n how to print rows and columns\n\n \n\n \n\n \n\n You should also avoid using: system (\"pause\");\n\n \n\n \n\n Why? Its just school homework. If its there, and easy to use... whats the problem?\n\n \n\n IRL, you won't use console for output. (Whens the last time you've seen a console application on sale?). So, using system(\"anything\") won't hurt u once you get out of classrooms either...\n\n how to do rows and columnshow to print rows and columnsWhy? Its just school homework. If its there, and easy to use... whats the problem?IRL, you won't use console for output. (Whens the last time you've seen a console application on sale?). So, using system(\"anything\") won't hurt u once you get out of classrooms either...\n\nWhy? Its just school homework. If its there, and easy to use... whats the problem? \n\n \n\n http://www.cplusplus.com/forum/articles/11153/\n\n \n\n It's never too early to start good coding habits, unless you want to be the guy responsible for your company's million dollar law suit because of a vulnerability you neglected. You can never take security serious enough and part of the problem starts with people learning unsafe habits during their education.\n\n \n\n IRL, you won't use console for output. (Whens the last time you've seen a console application on sale?). So, using system(\"anything\") won't hurt u once you get out of classrooms either... \n\n \n\n I take it you're a windows-user. On Unix/Linux, which are still the main part of the servers out there, command line utilities are the norm rather than exceptions.\n\n \n\n All the best,\n\n NwN http://www.cplusplus.com/forum/articles/11153/It's never too early to start good coding habits, unless you want to be the guy responsible for your company's million dollar law suit because of a vulnerability you neglected. You cantake security serious enough and part of the problem starts with people learning unsafe habits during their education.I take it you're a windows-user. On Unix/Linux, which are still the main part of the servers out there, command line utilities are the norm rather than exceptions.All the best,NwN\n\n\n\n \n\n \n\n Of course if you're using namespace std, you can leave off the std:: bit. You just press return to finish. If you place this at the end of programs (to pause them), it will be just fine.Of course if you're using namespace std, you can leave off the std:: bit. You just press return to finish."
    }
]