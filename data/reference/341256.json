[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties",
        "document": "A property is a member that provides a flexible mechanism to read, write, or compute the value of a data field. Properties appear as public data members, but they're implemented as special methods called accessors. This feature enables callers to access data easily and still helps promote data safety and flexibility. The syntax for properties is a natural extension to fields. A field defines a storage location:\n\nA property definition contains declarations for a and accessor that retrieves and assigns the value of that property:\n\nThe preceding example shows an automatically implemented property. The compiler generates a hidden backing field for the property. The compiler also implements the body of the and accessors. Any attributes are applied to the automatically implemented property. You can apply the attribute to the compiler-generated backing field by specifying the tag on the attribute.\n\nYou can initialize a property to a value other than the default by setting a value after the closing brace for the property. You might prefer the initial value for the property to be the empty string rather than . You would specify that as shown in the following code:\n\nIn C# 13, you can add validation or other logic in the accessor for a property using the keyword preview feature. The keyword accesses the compiler synthesized backing field for a property. It enables you to write a property accessor without explicitly declaring a separate backing field.\n\nThe keyword is a preview feature in C# 13. You must be using .NET 9 and set your element to in your project file in order to use the contextual keyword. You should be careful using the keyword feature in a class that has a field named . The new keyword shadows a field named in the scope of a property accessor. You can either change the name of the variable, or use the token to reference the identifier as . You can learn more by reading the feature specification for the keyword.\n\nThe preceding example allows a caller to create a using the default constructor, without setting the property. The property changed type to a nullable string. Beginning in C# 11, you can require callers to set a property:\n\nThe preceding code makes two changes to the class. First, the property declaration includes the modifier. That means any code that creates a new must set this property using an object initializer. Second, the constructor that takes a parameter has the System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute attribute. This attribute informs the compiler that this constructor sets all members. Callers using this constructor aren't required to set properties with an object initializer.\n\nProperty accessors often consist of single-line statements. The accessors assign or return the result of an expression. You can implement these properties as expression-bodied members. Expression body definitions consist of the token followed by the expression to assign to or retrieve from the property.\n\nRead-only properties can implement the accessor as an expression-bodied member. The following example implements the read-only property as an expression-bodied member:\n\nThe property is a computed property. There's no backing field for . The property computes it each time.\n\nThe preceding examples showed read / write properties. You can also create read-only properties, or give different accessibility to the set and get accessors. Suppose that your class should only enable changing the value of the property from other methods in the class. You could give the set accessor accessibility instead of or :\n\nThe property can be read from any code, but it can be assigned only from code in the class.\n\nYou can add any restrictive access modifier to either the set or get accessors. An access modifier on an individual accessor must be more restrictive than the access of the property. The preceding code is legal because the property is , but the set accessor is . You couldn't declare a property with a accessor. Property declarations can also be declared , , , or, even .\n\nThere are two special access modifiers for accessors:\n• A accessor can have as its access modifier. That accessor can be called only from an object initializer or the type's constructors. It's more restrictive than on the accessor.\n• An automatically implemented property can declare a accessor without a accessor. In that case, the compiler allows the accessor to be called only from the type's constructors. It's more restrictive than the accessor on the accessor.\n\nModify the class so as follows:\n\nThe preceding example requires callers to use the constructor that includes the parameter. Callers can't use object initializers to assign a value to the property. To support initializers, you can make the accessor an accessor, as shown in the following code:\n\nThese modifiers are often used with the modifier to force proper initialization.\n\nYou can mix the concept of a computed property with a private field and create a cached evaluated property. For example, update the property so that the string formatting happens on the first access:\n\nThis implementation works because the and properties are readonly. People can change their name. Updating the and properties to allow accessors requires you to invalidate any cached value for . You modify the accessors of the and property so the field is calculated again:\n\nThis final version evaluates the property only when needed. The previously calculated version is used if valid. Otherwise, the calculation updates the cached value. Developers using this class don't need to know the details of the implementation. None of these internal changes affect the use of the Person object.\n\nBeginning with C# 13, you can create properties in classes. The implementing declaration for a property can't be an automatically implemented property. An automatically implemented property uses the same syntax as a declaring partial property declaration.\n\nProperties are a form of smart fields in a class or object. From outside the object, they appear like fields in the object. However, properties can be implemented using the full palette of C# functionality. You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.\n• Simple properties that require no custom accessor code can be implemented either as expression body definitions or as automatically implemented properties.\n• Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.\n• A get property accessor is used to return the property value, and a set property accessor is used to assign a new value. An init property accessor is used to assign a new value only during object construction. These accessors can have different access levels. For more information, see Restricting Accessor Accessibility.\n• The value keyword is used to define the value the or accessor is assigning.\n• Properties can be read-write (they have both a and a accessor), read-only (they have a accessor but no accessor), or write-only (they have a accessor, but no accessor). Write-only properties are rare.\n\nFor more information, see Properties in the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values",
        "document": "Default values of C# types (C# reference)\n\nThe following table shows the default values of C# types:\n\nUse the operator to produce the default value of a type, as the following example shows:\n\nYou can use the literal to initialize a variable with the default value of its type:\n\nFor a value type, the implicit parameterless constructor also produces the default value of the type, as the following example shows:\n\nAt run time, if the System.Type instance represents a value type, you can use the Activator.CreateInstance(Type) method to invoke the parameterless constructor to obtain the default value of the type.\n\nA structure type (which is a value type) may have an explicit parameterless constructor that may produce a non-default value of the type. Thus, we recommend using the operator or the literal to produce the default value of a type.\n\nFor more information, see the following sections of the C# language specification:"
    },
    {
        "link": "https://stackoverflow.com/questions/3071359/set-a-default-value-to-a-property",
        "document": "No, there is no built-in way to set the value of a property with metadata. You could use a factory of some sort that would build instances of a class with reflection and then that could set the default values. But in short, you need to use the constructors (or field setters, which are lifted to the constructor) to set the default values.\n\nIf you have several overloads for your constructor, you may want to look at constructor chaining.\n\nUsing C# 6+, you are able to do something like this...\n\nOh, it gets more fun because people have even requested something like this...\n\n... the advantage being that you could control the scope of the field to only be accesible in the property code so you don't have to worry about anything else in your class playing with the state without using the getter/setter."
    },
    {
        "link": "https://stackoverflow.com/questions/46099105/how-do-i-set-default-values-to-all-properties-of-a-class-in-a-method-or-construc",
        "document": "The operator wants you to give it a type, not an instance of the class. This works, for example:\n\nYou don't actually need to do what you're doing at all. Just leave the default values alone. The compiler has already taken care of it by the time your constructor executes. Indeed, the easiest way to get the default value of a property, in your particular case where all the properties are known not to be explicitly initialized, is to take whatever value it already has:\n\nThat serves no purpose: \"Make it what it already is\". But that's what your code is trying to do, because the uninitialized value each property already has is the value you're hoping to assign to it.\n\nIt is a bad idea to add a lot of code that spins around, wastes time, and does absolutely nothing at all.\n\nBut if you did need to do this (and I can't overstress that you don't), you would do it by creating an uninitialized value of the correct type:"
    },
    {
        "link": "https://w3schools.com/cs/cs_method_parameters_default.php",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties",
        "document": "A property is a member that provides a flexible mechanism to read, write, or compute the value of a data field. Properties appear as public data members, but they're implemented as special methods called accessors. This feature enables callers to access data easily and still helps promote data safety and flexibility. The syntax for properties is a natural extension to fields. A field defines a storage location:\n\nA property definition contains declarations for a and accessor that retrieves and assigns the value of that property:\n\nThe preceding example shows an automatically implemented property. The compiler generates a hidden backing field for the property. The compiler also implements the body of the and accessors. Any attributes are applied to the automatically implemented property. You can apply the attribute to the compiler-generated backing field by specifying the tag on the attribute.\n\nYou can initialize a property to a value other than the default by setting a value after the closing brace for the property. You might prefer the initial value for the property to be the empty string rather than . You would specify that as shown in the following code:\n\nIn C# 13, you can add validation or other logic in the accessor for a property using the keyword preview feature. The keyword accesses the compiler synthesized backing field for a property. It enables you to write a property accessor without explicitly declaring a separate backing field.\n\nThe keyword is a preview feature in C# 13. You must be using .NET 9 and set your element to in your project file in order to use the contextual keyword. You should be careful using the keyword feature in a class that has a field named . The new keyword shadows a field named in the scope of a property accessor. You can either change the name of the variable, or use the token to reference the identifier as . You can learn more by reading the feature specification for the keyword.\n\nThe preceding example allows a caller to create a using the default constructor, without setting the property. The property changed type to a nullable string. Beginning in C# 11, you can require callers to set a property:\n\nThe preceding code makes two changes to the class. First, the property declaration includes the modifier. That means any code that creates a new must set this property using an object initializer. Second, the constructor that takes a parameter has the System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute attribute. This attribute informs the compiler that this constructor sets all members. Callers using this constructor aren't required to set properties with an object initializer.\n\nProperty accessors often consist of single-line statements. The accessors assign or return the result of an expression. You can implement these properties as expression-bodied members. Expression body definitions consist of the token followed by the expression to assign to or retrieve from the property.\n\nRead-only properties can implement the accessor as an expression-bodied member. The following example implements the read-only property as an expression-bodied member:\n\nThe property is a computed property. There's no backing field for . The property computes it each time.\n\nThe preceding examples showed read / write properties. You can also create read-only properties, or give different accessibility to the set and get accessors. Suppose that your class should only enable changing the value of the property from other methods in the class. You could give the set accessor accessibility instead of or :\n\nThe property can be read from any code, but it can be assigned only from code in the class.\n\nYou can add any restrictive access modifier to either the set or get accessors. An access modifier on an individual accessor must be more restrictive than the access of the property. The preceding code is legal because the property is , but the set accessor is . You couldn't declare a property with a accessor. Property declarations can also be declared , , , or, even .\n\nThere are two special access modifiers for accessors:\n• A accessor can have as its access modifier. That accessor can be called only from an object initializer or the type's constructors. It's more restrictive than on the accessor.\n• An automatically implemented property can declare a accessor without a accessor. In that case, the compiler allows the accessor to be called only from the type's constructors. It's more restrictive than the accessor on the accessor.\n\nModify the class so as follows:\n\nThe preceding example requires callers to use the constructor that includes the parameter. Callers can't use object initializers to assign a value to the property. To support initializers, you can make the accessor an accessor, as shown in the following code:\n\nThese modifiers are often used with the modifier to force proper initialization.\n\nYou can mix the concept of a computed property with a private field and create a cached evaluated property. For example, update the property so that the string formatting happens on the first access:\n\nThis implementation works because the and properties are readonly. People can change their name. Updating the and properties to allow accessors requires you to invalidate any cached value for . You modify the accessors of the and property so the field is calculated again:\n\nThis final version evaluates the property only when needed. The previously calculated version is used if valid. Otherwise, the calculation updates the cached value. Developers using this class don't need to know the details of the implementation. None of these internal changes affect the use of the Person object.\n\nBeginning with C# 13, you can create properties in classes. The implementing declaration for a property can't be an automatically implemented property. An automatically implemented property uses the same syntax as a declaring partial property declaration.\n\nProperties are a form of smart fields in a class or object. From outside the object, they appear like fields in the object. However, properties can be implemented using the full palette of C# functionality. You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.\n• Simple properties that require no custom accessor code can be implemented either as expression body definitions or as automatically implemented properties.\n• Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.\n• A get property accessor is used to return the property value, and a set property accessor is used to assign a new value. An init property accessor is used to assign a new value only during object construction. These accessors can have different access levels. For more information, see Restricting Accessor Accessibility.\n• The value keyword is used to define the value the or accessor is assigning.\n• Properties can be read-write (they have both a and a accessor), read-only (they have a accessor but no accessor), or write-only (they have a accessor, but no accessor). Write-only properties are rare.\n\nFor more information, see Properties in the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    },
    {
        "link": "https://stackoverflow.com/questions/4948816/getters-setters-and-properties-best-practices-java-vs-c-sharp",
        "document": "I'm taking a C# class right now and I'm trying to find out the best way of doing things. I come from a Java background and so I'm only familiar with Java best-practices; I'm a C# novice!\n\nIn Java if I have a private property, I do this;\n\nIn C#, I see that there are many ways of doing this.\n\nI can do it like Java:\n\nOr I can do it this way:\n\nWhich one should I use, and what are the caveats or subtleties involved with each approach? When creating classes, I am following general best-practices that I know from Java (especially reading Effective Java). So for example, I am favoring immutability (providing setters only when necessary). I'm just curious to see how these practices fit in with the various ways of providing setters and getters in C#; essentially, how would I translate best-practices from the Java world into C#?\n\nI was posting this as a comment to Jon Skeet's answer but then it got long:\n\nWhat about a non-trivial property (i.e., with significant processing and validation perhaps)? Could I still expose it via a public property but with the logic encapsulated in and ? Why would/should I do this over having dedicated setter and getter methods (with associated processing and validation logic)."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-properties",
        "document": "Properties combine aspects of both fields and methods. To the user of an object, a property appears to be a field; accessing the property requires the same syntax. To the implementer of a class, a property is one or two code blocks, representing a accessor and/or a or accessor. The code block for the accessor is executed when the property is read; the code block for the or accessor is executed when the property is assigned a value. A property without a accessor is considered read-only. A property without a accessor is considered write-only. A property that has both accessors is read-write. You can use an accessor instead of a accessor to enable the property to be set as part of object initialization but otherwise make it read-only.\n\nUnlike fields, properties aren't classified as variables. Therefore, you can't pass a property as a or parameter.\n\nProperties have many uses:\n• They can validate data before allowing a change.\n• They can transparently expose data on a class where that data is retrieved from some other source, such as a database.\n• They can take an action when data is changed, such as raising an event, or changing the value of other fields.\n\nProperties are declared in the class block by specifying the access level of the field, followed by the type of the property, followed by the name of the property, and followed by a code block that declares a -accessor and/or a accessor. For example:\n\nIn this example, is declared as a property so that the accessor can make sure that the value is set between 1 and 12. The property uses a private field to track the actual value. The real location of a property's data is often referred to as the property's \"backing store.\" It's common for properties to use private fields as a backing store. The field is marked private in order to make sure that it can only be changed by calling the property. For more information about public and private access restrictions, see Access Modifiers. Automatically implemented properties provide simplified syntax for simple property declarations. For more information, see Automatically implemented properties.\n\nBeginning with C# 13, you can use field backed properties to add validation to the accessor of an automatically implemented property, as shown in the following example:\n\nThe body of the accessor resembles that of a method. It must return a value of the property type. The C# compiler and Just-in-time (JIT) compiler detect common patterns for implementing the accessor, and optimizes those patterns. For example, a accessor that returns a field without performing any computation is likely optimized to a memory read of that field. Automatically implemented properties follow this pattern and benefit from these optimizations. However, a virtual accessor method can't be inlined because the compiler doesn't know at compile time which method might actually be called at run time. The following example shows a accessor that returns the value of a private field :\n\nWhen you reference the property, except as the target of an assignment, the accessor is invoked to read the value of the property. For example:\n\nThe accessor must be an expression-bodied member, or end in a return or throw statement, and control can't flow off the accessor body.\n\nThe accessor can be used to return the field value or to compute it and return it. For example:\n\nIn the previous example, if you don't assign a value to the property, it returns the value .\n\nThe accessor resembles a method whose return type is void. It uses an implicit parameter called , whose type is the type of the property. The compiler and JIT compiler also recognize common patterns for a or accessor. Those common patterns are optimized, directly writing the memory for the backing field. In the following example, a accessor is added to the property:\n\nWhen you assign a value to the property, the accessor is invoked by using an argument that provides the new value. For example:\n\nIt's an error to use the implicit parameter name, , for a local variable declaration in a accessor.\n\nThe code to create an accessor is the same as the code to create a accessor except that you use the keyword instead of . The difference is that the accessor can only be used in the constructor or by using an object-initializer.\n\nProperties can be marked as , , , , , or . These access modifiers define how users of the class can access the property. The and accessors for the same property can have different access modifiers. For example, the might be to allow read-only access from outside the type, and the can be or . For more information, see Access Modifiers.\n\nA property can be declared as a static property by using the keyword. Static properties are available to callers at any time, even if no instance of the class exists. For more information, see Static Classes and Static Class Members.\n\nA property can be marked as a virtual property by using the virtual keyword. Virtual properties enable derived classes to override the property behavior by using the override keyword. For more information about these options, see Inheritance.\n\nA property overriding a virtual property can also be sealed, specifying that for derived classes it's no longer virtual. Lastly, a property can be declared abstract. Abstract properties don't define an implementation in the class, and derived classes must write their own implementation. For more information about these options, see Abstract and Sealed Classes and Class Members.\n\nThis example demonstrates instance, static, and read-only properties. It accepts the name of the employee from the keyboard, increments by 1, and displays the Employee name and number.\n\nThis example demonstrates how to access a property in a base class that is hidden by another property that has the same name in a derived class:\n\nThe following are important points in the previous example:\n• The property in the derived class hides the property in the base class. In such a case, the modifier is used in the declaration of the property in the derived class:\n• The cast is used to access the hidden property in the base class:\n\nFor more information about hiding members, see the new Modifier.\n\nIn this example, two classes, and , implement an abstract class, , and override its abstract property. Note the use of the override modifier on the properties. The program accepts the side as an input and calculates the areas for the square and cube. It also accepts the area as an input and calculates the corresponding side for the square and cube."
    },
    {
        "link": "https://stackoverflow.com/questions/2334968/what-is-the-best-practice-for-using-net-properties",
        "document": "I am a little confused about how much I SHOULD do with properties. I have heard that properties should always represent a logical property of the class. Get and Set should almost never throw exceptions with the exception of ArgumentOutOfRange. Is that true? Is the following example totally wrong?\n\nAlso, If a method in the same class wants to change the value of a property should it go through the set accessor of the property or just modify the private variable _Registered directly?\n\nIf you have any additional advice when using properties please include! Thanks"
    },
    {
        "link": "https://w3schools.com/cs/cs_properties.php",
        "document": "Before we start to explain properties, you should have a basic understanding of \"Encapsulation\".\n\nThe meaning of Encapsulation, is to make sure that \"sensitive\" data is hidden from users. To achieve this, you must:\n• provide and methods, through properties, to access and update the value of a field\n\nYou learned from the previous chapter that variables can only be accessed within the same class (an outside class has no access to it). However, sometimes we need to access them - and it can be done with properties.\n\nA property is like a combination of a variable and a method, and it has two methods: a and a method:\n\nThe property is associated with the field. It is a good practice to use the same name for both the property and the private field, but with an uppercase first letter.\n\nThe method returns the value of the variable .\n\nThe method assigns a to the variable. The keyword represents the value we assign to the property.\n\nNow we can use the property to access and update the field of the class:\n\nC# also provides a way to use short-hand / automatic properties, where you do not have to define the field for the property, and you only have to write and inside the property.\n\nThe following example will produce the same result as the example above. The only difference is that there is less code:\n• Better control of class members (reduce the possibility of yourself (or others) to mess up the code)\n• Fields can be made read-only (if you only use the method), or write-only (if you only use the method)\n• Flexible: the programmer can change one part of the code without affecting other parts"
    }
]