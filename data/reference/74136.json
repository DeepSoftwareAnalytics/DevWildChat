[
    {
        "link": "https://stackoverflow.com/questions/55807542/how-to-fix-nameerror-sys-not-defined",
        "document": "I have some Pygame code that is working fine up until I try to close the program. The program keeps telling me that sys is not defined. I am using the more python programming for the absolute beginner to get the hang of Pygame.\n\nMy expected result is that the window will close but instead the window stays open and this error is spat out: NameError: name 'sys' is not defined"
    },
    {
        "link": "https://stackoverflow.com/questions/17761697/python-sys-is-not-defined",
        "document": "Move outside of the - block:\n\nIf any of the imports before the line fails, the rest of the block is not executed, and is never imported. Instead, execution jumps to the exception handling block, where you then try to access a non-existing name.\n\nis a built-in module anyway, it is always present as it holds the data structures to track imports; if importing fails, you have bigger problems on your hand (as that would indicate that all module importing is broken)."
    },
    {
        "link": "https://github.com/vlachoudis/bCNC/issues/1481",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/87973d/what_does_it_mean_when_you_get_a_sys_not_defined",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://geeksforgeeks.org/handling-nameerror-exception-in-python",
        "document": "There are several standard exceptions in Python and NameError is one among them. NameError is raised when the identifier being accessed is not defined in the local or global scope. General causes for NameError being raised are :\n\nIn the below example code, the print statement is misspelled hence NameError will be raised.\n\nWhen the below program is executed, NameError will be raised as the variable geek is never defined.\n\nIn the following example, even though the variable geek is defined in the program, it is defined after its usage. Since Python interprets the code from top to bottom, this will raise NameError\n\nIn the below example program, the variable geek is defined within the local scope of the assign function. Hence, it cannot be accessed globally. This raises NameError.\n\nTo specifically handle NameError in Python, you need to mention it in the except statement. In the following example code, if only the NameError is raised in the try block then an error message will be printed on the console."
    },
    {
        "link": "https://docs.python.org/3/library/sys.html",
        "document": "This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. It is always available. Unless explicitly noted otherwise, all variables are read-only."
    },
    {
        "link": "https://docs.python.org/3/tutorial/modules.html",
        "document": "If you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Therefore, if you want to write a somewhat longer program, you are better off using a text editor to prepare the input for the interpreter and running it with that file as input instead. This is known as creating a script. As your program gets longer, you may want to split it into several files for easier maintenance. You may also want to use a handy function that you’ve written in several programs without copying its definition into each program.\n\nTo support this, Python has a way to put definitions in a file and use them in a script or in an interactive instance of the interpreter. Such a file is called a module; definitions from a module can be imported into other modules or into the main module (the collection of variables that you have access to in a script executed at the top level and in calculator mode).\n\nA module is a file containing Python definitions and statements. The file name is the module name with the suffix appended. Within a module, the module’s name (as a string) is available as the value of the global variable . For instance, use your favorite text editor to create a file called in the current directory with the following contents:\n\nNow enter the Python interpreter and import this module with the following command:\n\nThis does not add the names of the functions defined in directly to the current namespace (see Python Scopes and Namespaces for more details); it only adds the module name there. Using the module name you can access the functions:\n\nIf you intend to use a function often you can assign it to a local name:\n\nA module can contain executable statements as well as function definitions. These statements are intended to initialize the module. They are executed only the first time the module name is encountered in an import statement. (They are also run if the file is executed as a script.) Each module has its own private namespace, which is used as the global namespace by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables. On the other hand, if you know what you are doing you can touch a module’s global variables with the same notation used to refer to its functions, . Modules can import other modules. It is customary but not required to place all statements at the beginning of a module (or script, for that matter). The imported module names, if placed at the top level of a module (outside any functions or classes), are added to the module’s global namespace. There is a variant of the statement that imports names from a module directly into the importing module’s namespace. For example: This does not introduce the module name from which the imports are taken in the local namespace (so in the example, is not defined). There is even a variant to import all names that a module defines: This imports all names except those beginning with an underscore ( ). In most cases Python programmers do not use this facility since it introduces an unknown set of names into the interpreter, possibly hiding some things you have already defined. Note that in general the practice of importing from a module or package is frowned upon, since it often causes poorly readable code. However, it is okay to use it to save typing in interactive sessions. If the module name is followed by , then the name following is bound directly to the imported module. This is effectively importing the module in the same way that will do, with the only difference of it being available as . It can also be used when utilising with similar effects: For efficiency reasons, each module is only imported once per interpreter session. Therefore, if you change your modules, you must restart the interpreter – or, if it’s just one module you want to test interactively, use , e.g. . When you run a Python module with the code in the module will be executed, just as if you imported it, but with the set to . That means that by adding this code at the end of your module: you can make the file usable as a script as well as an importable module, because the code that parses the command line only runs if the module is executed as the “main” file: If the module is imported, the code is not run: This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite). When a module named is imported, the interpreter first searches for a built-in module with that name. These module names are listed in . If not found, it then searches for a file named in a list of directories given by the variable . is initialized from these locations:\n• None The directory containing the input script (or the current directory when no file is specified).\n• None (a list of directory names, with the same syntax as the shell variable ).\n• None The installation-dependent default (by convention including a directory, handled by the module). More details are at The initialization of the sys.path module search path. On file systems which support symlinks, the directory containing the input script is calculated after the symlink is followed. In other words the directory containing the symlink is not added to the module search path. After initialization, Python programs can modify . The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory. This is an error unless the replacement is intended. See section Standard Modules for more information. To speed up loading modules, Python caches the compiled version of each module in the directory under the name , where the version encodes the format of the compiled file; it generally contains the Python version number. For example, in CPython release 3.3 the compiled version of spam.py would be cached as . This naming convention allows compiled modules from different releases and different versions of Python to coexist. Python checks the modification date of the source against the compiled version to see if it’s out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the same library can be shared among systems with different architectures. Python does not check the cache in two circumstances. First, it always recompiles and does not store the result for the module that’s loaded directly from the command line. Second, it does not check the cache if there is no source module. To support a non-source (compiled only) distribution, the compiled module must be in the source directory, and there must not be a source module.\n• None You can use the or switches on the Python command to reduce the size of a compiled module. The switch removes assert statements, the switch removes both assert statements and __doc__ strings. Since some programs may rely on having these available, you should only use this option if you know what you’re doing. “Optimized” modules have an tag and are usually smaller. Future releases may change the effects of optimization.\n• None A program doesn’t run any faster when it is read from a file than when it is read from a file; the only thing that’s faster about files is the speed with which they are loaded.\n• None The module can create .pyc files for all modules in a directory.\n• None There is more detail on this process, including a flow chart of the decisions, in PEP 3147.\n\nPython comes with a library of standard modules, described in a separate document, the Python Library Reference (“Library Reference” hereafter). Some modules are built into the interpreter; these provide access to operations that are not part of the core of the language but are nevertheless built in, either for efficiency or to provide access to operating system primitives such as system calls. The set of such modules is a configuration option which also depends on the underlying platform. For example, the module is only provided on Windows systems. One particular module deserves some attention: , which is built into every Python interpreter. The variables and define the strings used as primary and secondary prompts: These two variables are only defined if the interpreter is in interactive mode. The variable is a list of strings that determines the interpreter’s search path for modules. It is initialized to a default path taken from the environment variable , or from a built-in default if is not set. You can modify it using standard list operations:\n\nPackages are a way of structuring Python’s module namespace by using “dotted module names”. For example, the module name designates a submodule named in a package named . Just like the use of modules saves the authors of different modules from having to worry about each other’s global variable names, the use of dotted module names saves the authors of multi-module packages like NumPy or Pillow from having to worry about each other’s module names. Suppose you want to design a collection of modules (a “package”) for the uniform handling of sound files and sound data. There are many different sound file formats (usually recognized by their extension, for example: , , ), so you may need to create and maintain a growing collection of modules for the conversion between the various file formats. There are also many different operations you might want to perform on sound data (such as mixing, adding echo, applying an equalizer function, creating an artificial stereo effect), so in addition you will be writing a never-ending stream of modules to perform these operations. Here’s a possible structure for your package (expressed in terms of a hierarchical filesystem): sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... When importing the package, Python searches through the directories on looking for the package subdirectory. The files are required to make Python treat directories containing the file as packages (unless using a namespace package, a relatively advanced feature). This prevents directories with a common name, such as , from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, can just be an empty file, but it can also execute initialization code for the package or set the variable, described later. Users of the package can import individual modules from the package, for example: This loads the submodule . It must be referenced with its full name. An alternative way of importing the submodule is: This also loads the submodule , and makes it available without its package prefix, so it can be used as follows: Yet another variation is to import the desired function or variable directly: Again, this loads the submodule , but this makes its function directly available: Note that when using , the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an exception is raised. Contrarily, when using syntax like , each item except for the last must be a package; the last item can be a module or a package but can’t be a class or function or variable defined in the previous item. Now what happens when the user writes ? Ideally, one would hope that this somehow goes out to the filesystem, finds which submodules are present in the package, and imports them all. This could take a long time and importing sub-modules might have unwanted side-effects that should only happen when the sub-module is explicitly imported. The only solution is for the package author to provide an explicit index of the package. The statement uses the following convention: if a package’s code defines a list named , it is taken to be the list of module names that should be imported when is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package. For example, the file could contain the following code: This would mean that would import the three named submodules of the package. Be aware that submodules might become shadowed by locally defined names. For example, if you added a function to the file, the would only import the two submodules and , but not the submodule, because it is shadowed by the locally defined function: # !!! refers to the 'reverse' function now !!! # <-- this name shadows the 'reverse.py' submodule # in the case of a 'from sound.effects import *' If is not defined, the statement does not import all submodules from the package into the current namespace; it only ensures that the package has been imported (possibly running any initialization code in ) and then imports whatever names are defined in the package. This includes any names defined (and submodules explicitly loaded) by . It also includes any submodules of the package that were explicitly loaded by previous statements. Consider this code: In this example, the and modules are imported in the current namespace because they are defined in the package when the statement is executed. (This also works when is defined.) Although certain modules are designed to export only names that follow certain patterns when you use , it is still considered bad practice in production code. Remember, there is nothing wrong with using ! In fact, this is the recommended notation unless the importing module needs to use submodules with the same name from different packages. When packages are structured into subpackages (as with the package in the example), you can use absolute imports to refer to submodules of siblings packages. For example, if the module needs to use the module in the package, it can use . You can also write relative imports, with the form of import statement. These imports use leading dots to indicate the current and parent packages involved in the relative import. From the module for example, you might use: Note that relative imports are based on the name of the current module. Since the name of the main module is always , modules intended for use as the main module of a Python application must always use absolute imports. Packages support one more special attribute, . This is initialized to be a sequence of strings containing the name of the directory holding the package’s before the code in that file is executed. This variable can be modified; doing so affects future searches for modules and subpackages contained in the package. While this feature is not often needed, it can be used to extend the set of modules found in a package."
    },
    {
        "link": "https://geeksforgeeks.org/python-sys-module",
        "document": "The sys module in Python provides various functions and variables that are used to manipulate different parts of the Python runtime environment. It allows operating on the interpreter as it provides access to the variables and functions that interact strongly with the interpreter. Let’s consider the below example.\n\nIn this example, sys.version is used which returns a string containing the version of Python Interpreter with some additional information. This shows how the sys module interacts with the interpreter. Let us dive into the article to get more information about the sys module.\n\nThe sys modules provide variables for better control over input or output. We can even redirect the input and output to other devices. This can be done using three variables –\n\nstdin: It can be used to get input from the command line directly. It is used for standard input. It internally calls the input() method. It, also, automatically adds ‘\n\n’ after each sentence.\n\nThis code reads lines from the standard input until the user enters ‘q’. For each line, it prints “Input : ” followed by the line. Finally, it prints “Exit”.\n\nstdout: A built-in file object that is analogous to the interpreter’s standard output stream in Python. stdout is used to display output directly to the screen console. Output can be of any form, it can be output from a print statement, an expression statement, and even a prompt direct for input. By default, streams are in text mode. In fact, wherever a print function is called within the code, it is first written to sys.stdout and then finally on to the screen.\n\nThis code will print the string “Geeks” to the standard output. The object represents the standard output stream, and the method writes the specified string to the stream.\n\nstderr: Whenever an exception occurs in Python it is written to sys.stderr.\n\nThis code will print the string “Hello World” to the standard error stream. The object represents the standard error stream, and the function writes the specified strings to the stream.\n\nCommand-line arguments are those which are passed during the calling of the program along with the calling statement. To achieve this using the sys module, the sys module provides a variable called sys.argv. It’s main purpose are:\n• None It is a list of command-line arguments.\n• None len(sys.argv) provides the number of command-line arguments.\n• None sys.argv[0] is the name of the current Python script.\n\nExample: Consider a program for adding numbers and the numbers are passed along with the calling statement.\n\nThis code calculates the sum of the command-line arguments passed to the Python script. It imports the module to access the command-line arguments and then iterates over the arguments, converting each one to an integer and adding it to a running total. Finally, it prints the total sum of the arguments.\n\nsys.exit([arg]) can be used to exit the program. The optional argument arg can be an integer giving the exit or another type of object. If it is an integer, zero is considered “successful termination”.\n\nNote: A string can also be passed to the sys.exit() method.\n\nThis code checks if the age is less than 18. If it is, it exits the program with a message “Age less than 18”. Otherwise, it prints the message “Age is not less than 18”. The function takes an optional message as an argument, which is displayed when the program exits.\n\nsys.path is a built-in variable within the sys module that returns the list of directories that the interpreter will search for the required module.\n\nWhen a module is imported within a Python file, the interpreter first searches for the specified module among its built-in modules. If not found it looks through the list of directories defined by sys.path.\n\nNote: sys.path is an ordinary list and can be manipulated.\n\nExample 1: Listing out all the paths\n\nThis code will print the system paths that Python uses to search for modules. The list contains the directories that Python will search for modules when it imports them.\n\nExample 2: Truncating the value of sys.path\n\nThis code will print an error message because the module is not in the list. The list is a list of directories that Python will search for modules when it imports them. By setting the list to an empty list, the code effectively disables Python’s ability to find any modules.\n\nsys.modules return the name of the Python modules that the current shell has imported.\n\nThis code will print a dictionary of all the modules that have been imported by the current Python interpreter. The dictionary keys are the module names, and the dictionary values are the module objects.\n\nsys.getrefcount() method is used to get the reference count for any given object. This value is used by Python as when this value becomes 0, the memory for that particular value is deleted.\n\nThis code prints the reference count of the object . The reference count of an object is the number of times it is referenced by other objects. An object is garbage collected when its reference count reaches 0, meaning that it is no longer referenced by any other objects"
    },
    {
        "link": "https://soamtripathy.hashnode.dev/sys-module-in-python",
        "document": ""
    },
    {
        "link": "https://python101.pythonlibrary.org/chapter20_sys.html",
        "document": "The sys module provides system specific parameters and functions. We will be narrowing our study down to the following:\n\nThe value of sys.argv is a Python list of command line arguments that were passed to the Python script. The first argument, argv[0] is the name of the Python script itself. Depending on the platform that you are running on, the first argument may contain the full path to the script or just the file name. You should study the documentation for additional details. Let’s try out a few examples to familiarize ourselves with this little tool: If you run this in the interpreter, you will receive a list with an empty string. Let’s create a file named “sysargv.py” with the following contents: Now run the code in IDLE. You should see it print out a list with a single element that contains the path to your script in it. Let’s try passing the script some arguments. Open up a terminal / console screen and change directories (use the “cd” command) to where your script is. Then run something like this: You will notice that it outputs the following to the screen: The first argument is the name of the script we wrote. The next two arguments in the list are the ones we passed to our script on the command line.\n\nThe value of sys.executable is the absolute path to the Python interpreter. This is useful when you are using someone else’s machine and need to know where Python is installed. On some systems, this command will fail and it will return an empty string or None. Here’s how to use it:\n\nThe sys.exit() function allows the developer to exit from Python. The exit function takes an optional argument, typically an integer, that gives an exit status. Zero is considered a “successful termination”. Be sure to check if your operating system has any special meanings for its exit statuses so that you can follow them in your own application. Note that when you call exit, it will raise the SystemExit exception, which allows cleanup functions to work in the finally clauses of try / except blocks. Let’s take a look at how to call this: When you run this code in IDLE, you will see the SystemExit error raised. Let’s create a couple of scripts to test this out. First you’ll want to create a master script, a program that will call another Python script. Let’s name it “call_exit.py”. Put the following code into it: Now create another Python script called “exit.py” and save it in the same folder. Put the following code into it: Now let’s try running this code: In the screenshot above, you can see that the exit script we wrote returned a zero, so it ran successfully. You have also learned how to call another Python script from within Python!\n\nThe sys module’s path value is a list of strings that specifies the search path for modules. Basically this tells Python what locations to look in when it tries to import a module. According to the Python documentation, sys.path is initialized from an environment variable called PYTHONPATH, plus an installation-dependent default. Let’s give it a try: This can be very useful for debugging why a module isn’t getting imported. You can also modify the path. Because it’s a list, we can add or delete paths from it. Here’s how to add a path: I’ll leave deleting a path as an exercise for the reader.\n\nThe sys.platform value is a platform identifier. You can use this to append platform specific modules to sys.path, import different modules depending on platform or run different pieces of code. Let’s take a look: This tells us that Python is running on a Windows machine. Here’s an example of how we might use this information: The code above shows how we might check to see if we’re using a particular operating system. If we’re on Windows, we’ll get some information from the Window’s Registry using a Python module called _winreg. If we’re on Linux, we might execute the ls command to get information about the directory we’re in.\n\nThe stdin, stdout and stderr map to file objects that correspond to the interpreter’s standard input, output and error streams, respectively. stdin is used for all input given to the interpreter except for scripts whereas stdout is used for the output of print and expression statements. The primary reason I mention this is that you will sometimes need to redirect stdout or stderr or both to a file, such as a log or to some kind of display in a custom GUI you have created. You could also redirect stdin, but I have rarely seen this done.\n\nThere are many other values and methods in the sys module. Be sure to look it up in the Python documentation, section 27.1. You have learned a lot in this chapter. You now know how to exit a Python program, how to get platform information, working with arguments passed on the command line and much more. In the next chapter, we’ll be learning about Python threads!"
    }
]