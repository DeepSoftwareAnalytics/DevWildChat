[
    {
        "link": "https://selenium-python.readthedocs.io/api.html",
        "document": "This chapter covers all the interfaces of Selenium WebDriver.\n\nThe API definitions in this chapter show the absolute location of classes. However, the recommended import style is as given below:\n\nThen, you can access the classes like this:\n\nThe special keys class ( ) can be imported like this:\n\nThe exception classes can be imported like this (Replace the with the actual class name given below):\n\nConventions used in the API\n\nSome attributes are callable (or methods) and others are non-callable (properties). All the callable attributes are ending with round brackets.\n\nHere is an example for property:\n\nHere is an example of a method:\n\nExceptions that may happen in all the webdriver code. The Element Click command could not be completed because the element receiving the events is obscuring the element that was requested to be clicked. Thrown when an element is present in the DOM but interactions with that element will hit another element due to paint order. Thrown when trying to select an unselectable element. Thrown when an element is present on the DOM, but it is not visible, and so is not able to be interacted with. Most commonly encountered when trying to click or read text of an element that is hidden from view. Thrown when activating an IME engine has failed. Thrown when IME support is not available. This exception is thrown for every IME-related method call if IME support is not available on the machine. Navigation caused the user agent to hit a certificate warning, which is usually the result of an expired or invalid TLS certificate. The arguments passed to a command are either invalid or malformed. Thrown when attempting to add a cookie under a different domain than the current URL. The coordinates provided to an interaction’s operation are invalid. Thrown when a command could not be completed because the element is in an invalid state. This can be caused by attempting to clear an element that isn’t both editable and resettable. Thrown when the selector which is used to find an element does not return a WebElement. Currently this only happens when the selector is an xpath expression and it is either syntactically invalid (i.e. it is not a xpath expression) or the expression does not select WebElements (e.g. “count(//input)”). Occurs if the given session id is not in the list of active sessions, meaning the session either does not exist or that it’s not active. Thrown when frame or window target to be switched doesn’t exist. An error occurred while executing JavaScript supplied by the user. Thrown when the target provided to the move() method is invalid, i.e. out of document. Thrown when switching to no presented alert. This can be caused by calling an operation on the Alert() class when an alert is not yet on the screen. Thrown when the attribute of element could not be found. You may want to check if the attribute exists in the particular browser you are testing against. Some browsers may have different property names for the same property. (IE8’s .innerText vs. Firefox .textContent) No cookie matching the given path name was found amongst the associated cookies of the current browsing context’s active document. Raised when driver is not specified and cannot be located. Thrown when element could not be found. If you encounter this exception, you may want to check the following:\n• None Check your selector used in your find_by…\n• None Element may not yet be on the screen at the time of the find operation, (webpage is still loading) see selenium.webdriver.support.wait.WebDriverWait() for how to write a wait wrapper to wait for an element to appear. Thrown when frame target to be switched doesn’t exist. Thrown when trying to access the shadow root of an element when it does not have a shadow root attached. Thrown when window target to be switched doesn’t exist. To find the current set of active window handles, you can get a list of the active window handles in the following way: A new session could not be created. Thrown when a reference to an element is now “stale”. Stale means the element no longer appears on the DOM of the page. Possible causes of StaleElementReferenceException include, but not limited to:\n• None You are no longer on the same page, or the page may have refreshed since the element was located.\n• None The element may have been removed and re-added to the screen, since it was located. Such as an element being relocated. This can happen typically with a javascript framework when values are updated and the node is rebuilt.\n• None Element may have been inside an iframe or another context which was refreshed. Thrown when a command does not complete in enough time. Thrown when an unexpected alert has appeared. Usually raised when an unexpected modal is blocking the webdriver from executing commands. Thrown when a support class did not get an expected web element. The requested command matched a known URL but did not match any methods for that URL.\n\nABC’s allow custom implementations of Webdriver to be registered so that isinstance type checks will succeed. Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://www.selenium.dev/documentation/legacy/json_wire_protocol/.\n• None session_id - String ID of the browser session started and controlled by this WebDriver.\n• None capabilities - Dictionary of effective capabilities of this browser session as returned by the remote server. See https://www.selenium.dev/documentation/legacy/desired_capabilities/ Create a new driver that will issue commands using the wire protocol.\n• None command_executor - Either a string representing URL of the remote server or a custom\n• None keep_alive - Whether to configure remote_connection.RemoteConnection to use\n• None file_detector - Pass custom file detector object during instantiation. If None, then default LocalFileDetector() will be used. Adds a virtual authenticator with the given options. Goes one step backward in the browser history. Creates a web element with the specified . Delete all cookies in the scope of the session. Deletes a single cookie with the given name. Downloads a file with the specified file name to the target directory. file_name: The name of the file to download. target_directory: The path to the directory to save the downloaded file. Sends a command to be executed by a command.CommandExecutor.\n• None driver_command: The name of the command to execute as a string.\n• None params: A dictionary of named parameters to send with the command.\n• None *args: Any applicable arguments for your JavaScript.\n• None *args: Any applicable arguments for your JavaScript. Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards.\n• None file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager.\n• None args - Optional arguments that get passed to the file detector class during\n• None kwargs - Keyword arguments, passed the same way as args. Find an element given a By strategy and locator. Find elements given a By strategy and locator. Goes one step forward in the browser history. Get a single cookie by name. Returns the cookie if found, None if not. Returns a set of dictionaries, corresponding to cookies visible in the current session. Returns the list of credentials owned by the authenticator. Retrieves the downloadable files as a map of file names and their corresponding URLs. Gets the log for a given log type.\n• None log_type: type of log that which will be returned Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension. Gets the screenshot of the current window as a binary data. Gets the x,y position of the current window. Gets the x, y coordinates of the window as well as height and width of the current window. Gets the width and height of the current window. Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout.\n• None time_to_wait: Amount of time to wait (in seconds) Maximizes the current window that webdriver is using. Store common javascript scripts to be executed later by a unique hashable ID. The driver makes a best effort to return a PDF based on the provided parameters. Quits the driver and closes every associated window. Removes all credentials from the authenticator. The authenticator is no longer valid after removal, so no methods may be called. Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension. Set the amount of time to wait for a page load to complete before throwing an error.\n• None time_to_wait: The amount of time to wait Set the amount of time that the script should wait during an execute_async_script call before throwing an error.\n• None time_to_wait: The amount of time to wait (in seconds) Sets whether the authenticator will simulate success or fail on user verification. verified: True if the authenticator will pass user verification, False otherwise. Sets the x,y position of the current window. (window.moveTo)\n• None x: the x-coordinate in pixels to set the window position\n• None y: the y-coordinate in pixels to set the window position Sets the x, y coordinates of the window as well as height and width of the current window. This method is only supported for W3C compatible browsers; other browsers should use and . Sets the width and height of the current window. (window.resizeTo)\n• None width: the width in pixels to set the window to\n• None height: the height in pixels to set the window to This method may be overridden to define custom startup behavior. Creates a new session with the desired capabilities.\n• None capabilities - a capabilities dict to start the session with. This method may be overridden to define custom shutdown behavior. Returns the drivers current capabilities being used. Gets the URL of the current page. Returns the handle of the current window. Gets a list of the available log types. This only works with w3c compliant browsers. Returns the name of the underlying browser for this instance. Gets the current orientation of the device. Gets the source of the current page.\n• None SwitchTo: an object containing all options to switch focus into Get all the timeouts that have been set on the current session. Returns the title of the current page. Returns the id of the virtual authenticator. Returns the handles of all windows within the current session.\n\nABC’s will allow custom types to be registered as a WebElement to pass type checks. Generally, all interesting operations that interact with a document will be performed through this interface. All method calls will do a freshness check to ensure that the element reference is still valid. This essentially determines whether the element is still attached to the DOM. If this test fails, then an is thrown, and all future calls to this instance will fail. Find an element given a By strategy and locator. Find elements given a By strategy and locator. Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn’t exist, it returns the value of the attribute with the same name. If there’s no attribute with that name, is returned. Values which are considered truthy, that is equals “true” or “false”, are returned as booleans. All other non- values are returned as strings. For attributes or properties which do not exist, is returned. To obtain the exact value of the attribute or property, use or methods respectively.\n• None name - Name of the attribute/property to retrieve. # Check if the \"active\" CSS class is applied to an element. Gets the given attribute of the element. Unlike , this method only returns attributes declared in the element’s HTML markup.\n• None name - Name of the attribute to retrieve. Gets the given property of the element.\n• None name - Name of the property to retrieve. Whether the element is visible to a user. Returns whether the element is enabled. Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename.\n• None filename: The full path you wish to save your screenshot to. This should end with a extension.\n• None value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields: This can also be used to set file inputs. # Generally it's better to wrap the file path in one of the methods # in os.path to return the actual path to support cross OS testing. The value of a CSS property. Returns the ARIA Level of the current webelement. Returns the ARIA role of the current web element. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using : The location of the element in the renderable canvas. THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or zero coordinates if the element is not visible. Internal reference to the WebDriver instance this element was found from. A dictionary with the size and location of the element. Gets the screenshot of the current element as a base64 encoded string. Gets the screenshot of the current element as a binary data. Returns a shadow root of the element if there is one or an error. Only works from Chromium 96, Firefox 96, and Safari 16.4 onwards.\n• None NoSuchShadowRoot - if no shadow root was attached to element\n\nAn expectation for checking if an alert is currently present and switching to it. An expectation that all of multiple expected conditions is true. Equivalent to a logical ‘AND’. Returns: When any ExpectedCondition is not met: False. When all ExpectedConditions are met: A List with each ExpectedCondition’s return value. An expectation that any of multiple expected conditions is true. Equivalent to a logical ‘OR’. Returns results of the first matching condition, or False if none do. An expectation for checking if the given attribute is included in the specified element. An expectation to locate an element and check if the selection state specified is in that state. locator is a tuple of (by, path) is_selected is a boolean An expectation for the element to be located is selected. locator is a tuple of (by, path) An expectation for checking if the given element is selected. An Expectation for checking an element is visible and enabled such that you can click it. element is either a locator (text) or an WebElement An expectation for checking the selection is selected. An expectation for checking whether the given frame is available to switch to. If the frame is available it switches the given driver to the specified frame. An Expectation for checking that an element is either invisible or not present on the DOM. element is either a locator (text) or an WebElement An Expectation for checking that an element is either invisible or not present on the DOM. locator used to find the element An expectation that a new window will be opened and have the number of windows handles increase. An expectation that none of 1 or multiple expected conditions is true. An expectation for the number of windows to be a certain value. An expectation for checking that there is at least one element present on a web page. locator is used to find the element returns the list of WebElements once they are located An expectation for checking that an element is present on the DOM of a page. This does not necessarily mean that the element is visible. locator - used to find the element returns the WebElement once it is located Wait until an element is no longer attached to the DOM. element is the element to wait for. returns False if the element is still attached to the DOM, true otherwise. An expectation for checking if the given text is present in the specified element. An expectation for checking if the given text is present in the element’s attribute. An expectation for checking if the given text is present in the element’s value. An expectation for checking that the title contains a case-sensitive substring. title is the fragment of title expected returns True when the title matches, False otherwise An expectation for checking the title of a page. title is the expected title, which must be an exact match returns True if the title matches, false otherwise. An expectation for checking the current url. url is the expected url, which must not be an exact match returns True if the url is different, false otherwise. An expectation for checking that the current url contains a case- sensitive substring. url is the fragment of url expected, returns True when the url matches, False otherwise An expectation for checking the current url. pattern is the expected pattern. This finds the first occurrence of pattern in the current url and as such does not require an exact full match. An expectation for checking the current url. url is the expected url, which must be an exact match returns True if the url matches, false otherwise. An expectation for checking that an element, known to be present on the DOM of a page, is visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. element is the WebElement returns the (same) WebElement once it is visible An expectation for checking that all elements are present on the DOM of a page and visible. Visibility means that the elements are not only displayed but also has a height and width that is greater than 0. locator - used to find the elements returns the list of WebElements once they are located and visible An expectation for checking that there is at least one element visible on a web page. locator is used to find the element returns the list of WebElements once they are located An expectation for checking that an element is present on the DOM of a page and visible. Visibility means that the element is not only displayed but also has a height and width that is greater than 0. locator - used to find the element returns the WebElement once it is located and visible"
    },
    {
        "link": "https://selenium-python.readthedocs.io/getting-started.html",
        "document": "If you have installed Selenium Python bindings, you can start using it from Python like this. The above script can be saved into a file (eg:- ), then it can be run like this: The which you are running should have the module installed.\n\nThe module provides all the WebDriver implementations. Currently supported WebDriver implementations are Firefox, Chrome, IE and Remote. The class provide keys in the keyboard like RETURN, F1, ALT etc. The class is used to locate elements within a document. Next, the instance of Firefox WebDriver is created. The method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. Be aware that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded: The next line is an assertion to confirm that title has the word “Python” in it: WebDriver offers a number of ways to find elements using the method. For example, the input text element can be located by its attribute using the method and using By.NAME as its first parameter. A detailed explanation of finding elements is available in the Locating Elements chapter: Next, we are sending keys, this is similar to entering keys using your keyboard. Special keys can be sent using the class imported from . To be safe, we’ll first clear any pre-populated text in the input field (e.g. “Search”) so it doesn’t affect our search results: After submission of the page, you should get the result if there is any. To ensure that some results are found, make an assertion: Finally, the browser window is closed. You can also call the method instead of . The method will exit the browser whereas will close one tab, but if just one tab was open, by default most browsers will exit entirely.:\n\nSelenium is mostly used for writing test cases. The package itself doesn’t provide a testing tool/framework. You can write test cases using Python’s unittest module. Alternatively, you may consider pytest for writing tests. In this chapter, we use as the framework of choice. Here is the modified example which uses the unittest module. This is a test for the search functionality: You can run the above test case from a shell like this: The above result shows that the test has been successfully completed. Note: To run the above test in IPython or Jupyter, you should pass a couple of arguments to the function as shown below:\n\nInitially, all the basic modules required are imported. The unittest module is a built-in Python module based on Java’s JUnit. This module provides the framework for organizing the test cases. The module provides all the WebDriver implementations. Currently supported WebDriver implementations are: Firefox, Chrome, IE and Remote. The class provides keys in the keyboard like RETURN, F1, ALT etc. The class is used to locate elements within a document. The test case class is inherited from . Inheriting from the class is the way to tell module that this is a test case: The method is part of initialization. This method will get called before every test function which you are going to write in this test case class. Here you are creating an instance of a Firefox WebDriver. This is the test case method. The test case method should always start with characters . The first line inside this method creates a local reference to the driver object created in method. The method will navigate to a page given by the URL. WebDriver will wait until the page has fully loaded (that is, the “onload” event has fired) before returning control to your test or script. Be aware that if your page uses a lot of AJAX on load then WebDriver may not know when it has completely loaded: The next line is an assertion to confirm that title has the word “Python” in it: WebDriver offers a number of ways to find elements using the method. For example, the input text element can be located by its attribute using the method. Detailed explanation of finding elements is available in the Locating Elements chapter: Next, we are sending keys, this is similar to entering keys using your keyboard. Special keys can be sent using the class imported from : After submission of the page, you should get the result as per search if there is any. To ensure that some results are found, make an assertion: The method will get called after every test method. This is a place to do all cleanup actions. In the current method, the browser window is closed. You can also call the method instead of . The method will exit the entire browser, whereas will close a tab, but if it is the only tab opened, by default most browsers will exit entirely.: Final lines are some boiler plate code to run the test suite:"
    },
    {
        "link": "https://selenium.dev/documentation/webdriver/elements/finders",
        "document": "Locating the elements based on the provided locator values.\n\nOne of the most fundamental aspects of using Selenium is obtaining element references to work with. Selenium offers a number of built-in locator strategies to uniquely identify an element. There are many ways to use the locators in very advanced scenarios. For the purposes of this documentation, let’s consider this HTML snippet:\n\nMany locators will match multiple elements on the page. The singular find element method will return a reference to the first element found within a given context.\n\nWhen the find element method is called on the driver instance, it returns a reference to the first element in the DOM that matches with the provided locator. This value can be stored and used for future element actions. In our example HTML above, there are two elements that have a class name of “tomatoes” so this method will return the element in the “vegetables” list.\n\nRather than finding a unique locator in the entire DOM, it is often useful to narrow the search to the scope of another located element. In the above example there are two elements with a class name of “tomatoes” and it is a little more challenging to get the reference for the second one.\n\nOne solution is to locate an element with a unique attribute that is an ancestor of the desired element and not an ancestor of the undesired element, then call find element on that object:\n\nThe Shadow DOM is an encapsulated DOM tree hidden inside an element. With the release of v96 in Chromium Browsers, Selenium can now allow you to access this tree with easy-to-use shadow root methods. NOTE: These methods require Selenium 4.0 or greater.\n\nA nested lookup might not be the most effective location strategy since it requires two separate commands to be issued to the browser.\n\nTo improve the performance slightly, we can use either CSS or XPath to find this element in a single command. See the Locator strategy suggestions in our Encouraged test practices section.\n\nFor this example, we’ll use a CSS Selector:\n\nThere are several use cases for needing to get references to all elements that match a locator, rather than just the first one. The plural find elements methods return a collection of element references. If there are no matches, an empty list is returned. In this case, references to all fruits and vegetable list items will be returned in a collection.\n\nOften you get a collection of elements but want to work with a specific element, which means you need to iterate over the collection and identify the one you want.\n\n# Get all the elements available with tag name 'p' // Get all the elements available with tag name 'p' // Get all the elements available with tag 'p' // Get all the elements available with tag name 'p'\n\nIt is used to find the list of matching child WebElements within the context of parent element. To achieve this, the parent WebElement is chained with ‘findElements’ to access child elements\n\n// Get element with tag name 'div' // Get all the elements available with tag name 'p' ##get elements from parent element using TAG_NAME # Get element with tag name 'div' # Get all the elements available with tag name 'p' ##get elements from parent element using XPATH ##NOTE: in order to utilize XPATH from current element, you must add \".\" to beginning of path # Get first element of tag 'ul' # get children of tag 'ul' with tag 'li' // Get element with tag name 'div' // Get all the elements available with tag name 'p' // Get element with tag name 'div' // Get all the elements available with tag name 'p' // Get element with tag name 'div' // Get all the elements available with tag name 'p'\n\nIt is used to track (or) find DOM element which has the focus in the current browsing context."
    },
    {
        "link": "https://geeksforgeeks.org/send_keys-element-method-selenium-python",
        "document": "Selenium’s Python Module is built to perform automated testing with Python. Selenium Python bindings provides a simple API to write functional/acceptance tests using Selenium WebDriver. To open a webpage using Selenium Python, checkout – Navigating links using get method – Selenium Python . Just being able to go to places isn’t terribly useful. What we’d really like to do is to interact with the pages, or, more specifically, the HTML elements within a page. There are multiple strategies to find an element using Selenium, checkout – Locating Strategies .\n\nThis article revolves around how to use method in Selenium. method is used to send text to any field, such as input field of a form or even to anchor tag paragraph, etc. It replaces its contents on the webpage in your browser. If you wish to learn these types of the elements method you can enroll in our software testing course\n\nTo find an element one needs to use one of the locating strategies, For example,\n\nAlso, to find multiple elements, we can use –\n\nTo enter text into a field, for example,\n\nOne can simulate pressing the arrow keys by using the “Keys” class:\n\nAlso note, it is possible to call send_keys on any element, which makes it possible to test keyboard shortcuts such as those used on Gmail. One can easily clear the contents of a text field or textarea with the clear method:\n\nHow to use send_keys method in Selenium Python ?\n\nLet’s use https://www.geeksforgeeks.org/ to illustrate this method in Selenium Python. Here we get element of search and enter “Arrays” in the same."
    },
    {
        "link": "https://browserstack.com/guide/python-selenium-to-run-web-automation-test",
        "document": "New features are regularly added to web applications to boost user engagement. To ensure these updates work as intended and that the user interface remains functional, automated testing is crucial. Selenium is a widely-used tool for this type of automation testing.\n\nSelenium is an open-source automation testing tool that supports various scripting languages such as C#, Java, Perl, Ruby, JavaScript, and others. The choice of scripting language can be made based on the specific requirements of the application being tested.\n\nPython is one of the most popular choices when it comes to scripting with 51% of the developers using it, as suggested by the StackOverflow 2024 annual survey.\n\nWhy do Developers prefer Python for writing Selenium Test Scripts?\n\nDevelopers prefer Python for writing Selenium test scripts because of its simplicity, readability, and ease of use. Python’s clear and concise syntax allows for faster script development and easier maintenance, which is crucial in testing scenarios.\n\nAdditionally, Python has a rich set of libraries and frameworks that complement Selenium, making it easier to handle complex tasks such as data manipulation, reporting, and integration with other tools.\n\nPython’s extensive community support and documentation also provide valuable resources for troubleshooting and improving test scripts. These factors make Python a popular choice for Selenium automation.\n\nGetting started with Selenium using Python involves setting up an environment where you can write and run automated test scripts for web applications.\n\nSelenium, combined with Python, offers a powerful and easy-to-learn toolset for automating browser interactions. Python’s simple syntax makes it ideal for quickly writing clear and maintainable test scripts.\n\nTo begin, you’ll need to install the Selenium WebDriver, set up a compatible browser, and learn the basics of locating web elements, interacting with them, and running test cases. This combination is perfect for testing dynamic and responsive web applications efficiently.\n\nSelenium Python Example: How to run your first Test?\n\nTo run Selenium Python Tests here are the steps to follow:\n\nFirst, you’ll need to import the WebDriver and Keys classes from Selenium. These classes help you interact with a web browser and emulate keyboard actions.\n• webdriver: Allows you to control the browser.\n\nTo interact with a browser, you’ll need to create an instance of WebDriver. In this example, we use Chrome:\n\nMake sure chromedriver is in the same directory as your Python script. This command opens a new Chrome browser window.\n\nUse the .get() method to navigate to a website. This method waits for the page to load completely:\n\nThis will open Python’s official website in the browser.\n\nOnce the page is loaded, you can retrieve and print the page title to verify you’re on the right page:\n\nYou should see:\n\nTo perform a search, locate the search bar element, enter a query, and submit it. Here’s how to find the search bar by its name attribute and interact with it:\n• send_keys(“getting started with python”): Types the query into the search bar.\n\nAfter submitting the search query, you can check the updated URL to confirm the search results page:\n\nYou should see a URL similar to:\n\nFinally, close the browser session to end the test:\n\nHere is the complete script for your first Selenium test in Python. Save this code in a file named selenium_test.py and run it using python selenium_test.py:\n\nSelenium allows you to perform a variety of actions on web elements. You have already touched upon entering input, here’s how to interact with buttons, and dropdowns:\n\nAssuming you want to click a button with the ID “submit-button” after entering the input in the search bar :\n\nIf you need to click a link by its text:\n• find_element_by_id(“submit-button”): Finds the button with the ID “submit-button”.\n\nThough dropdowns are not present on this site, they are quite common for web application testing\n\nFor dropdown menus, Selenium provides the Select class to handle options within <select> elements.\n\nExample: Selecting an Option from a Dropdown\n\nAssuming you have a dropdown menu with the ID “dropdown-menu”:\n• select_by_visible_text(“Option 1”): Selects an option by its visible text.\n• select_by_value(“option1”): Selects an option by its value attribute.\n• select_by_index(0): Selects an option by its index in the dropdown.\n\nThe HTML Document Object Model (DOM) represents the structure of a web page as a tree of objects. Selenium allows you to interact with these elements using various locator strategies.\n\nIn our first test script, we have already used some of the methods used to navigate DOM elements. This section will be a slightly more detailed view into how you can use different methods to locate and interact with elements on the Python.org website.\n\nTo click the “Downloads” link, you can use the .find_element_by_link_text() method, but here’s how to use other locators to achieve the same, example by using find_element_by_xpath:\n\nlocates the “Downloads” link based on its visible text.\n\nTo access the main header text, you can use different locators to find the header element.\n• Class Name: “introduction” is used to find the header element based on its class.\n\nExample: Filling Out and Submitting the Search Form\n\nTo interact with the search form, you can use the .find_element_by_name() method to locate the input field.\n• Name Attribute: find_element_by_name(“q”) locates the search input field by its name attribute.\n\nWhen working with multiple browser windows or tabs, or dealing with iframes (frames), you may need to switch contexts to interact with different elements.\n• window_handles: Retrieves a list of window handles. Switch to a specific window using switch_to.window().\n\nExample: Switching to an iFrame\n\nTo switch to and interact with elements within an iframe:\n\nDynamic content can load at different times, so using waits helps ensure elements are present before interacting with them.\n• implicitly_wait(): Sets a default wait time for finding elements. If an element is not immediately found, WebDriver will wait up to the specified time.\n• WebDriverWait(driver, 10): Creates an instance of WebDriverWait, specifying a maximum wait time of 10 seconds.\n• wait.until(EC.presence_of_element_located((By.NAME, “q”))): Pauses the script until the search bar element is found by its name attribute. If the element is not found within 10 seconds, a TimeoutException will be raised.\n\nTo ensure that the application behaves as expected, you can use assertions and validations.\n• Assertions: Used to check if the conditions are met. For example, checking if the title or text of elements matches expected values.\n• assert: Verifies conditions and will raise an AssertionError if the condition is not true.\n\nWeb applications often use JavaScript alerts, confirmation dialogs, or prompts to interact with users. Selenium provides ways to handle these pop-ups effectively.\n\nJavaScript alerts are simple pop-up messages that require user interaction to dismiss. Selenium allows you to interact with these alerts using the switch_to.alert() method.\n• switch_to.alert: Switches the context to the alert. Once switched, you can interact with the alert.\n• alert.accept(): Accepts the alert, which is equivalent to clicking “OK” on the alert.\n\nProperly closing the browser session is crucial for releasing resources and ensuring that your automation script runs cleanly.\n• driver.quit(): Closes all browser windows and ends the WebDriver session. This is the preferred method for cleanup as it ensures the browser process is terminated and resources are freed.\n• driver.close(): Closes the current window. If it’s the only window open, it will end the session. Use driver.quit() for complete cleanup.\n\nIntegrating Selenium tests with a testing framework provides structured test cases, reporting, and additional functionality such as setup and teardown methods.\n\nunittest is a built-in Python testing framework that provides a structured approach to writing and running tests, including test case management, fixtures, and test discovery. Integrating Selenium with unittest allows for organized test cases, setup and teardown methods, and detailed test reports, making it easier to manage and maintain automated tests.\n• unittest.TestCase: Defines a test case class. Each method within the class represents a test case.\n• setUpClass(): Initializes resources needed for the tests. Runs once before any test methods are executed.\n• tearDownClass(): Cleans up resources. Runs once after all test methods have completed.\n• unittest.main(): Runs the tests and provides output in the console.\n\npytest is a powerful and flexible Python testing framework that simplifies writing tests with its rich feature set, including fixtures, parameterized tests, and detailed assertions. Integrating Selenium with pytest enhances test organization, facilitates advanced setup/teardown functionality, and generates comprehensive test reports, improving test reliability and clarity.\n• pytest.fixture(): Defines a fixture that sets up and tears down resources. The scope=”module” ensures the fixture is run once per module.\n• yield: Provides the driver instance to the test function and performs cleanup after the test completes.\n• assert: Checks that the condition is met. pytest will report the assertion failure if the\n• How to install GeckoDriver for Selenium Python?\n• How to perform Web Scraping using Selenium and Python\n• How to Create and Use Action Class in Selenium Python\n• How to download a file using Selenium and Python\n• How to Press Enter without Element in Selenium Python?\n• Get Current URL in Selenium using Python: Tutorial\n\nBest Practices using Selenium WebDriver with Python\n\nHere are five best practices for using Selenium WebDriver with Python:\n• Use Explicit Waits: Prefer explicit waits over implicit waits to handle dynamic content. Explicit waits ensure that your script interacts with elements only when they are ready, reducing the chances of encountering timing issues.\n• Organize Tests with Frameworks: Integrate Selenium tests with testing frameworks like unittest or pytest to structure your test cases, manage setup and teardown, and generate detailed test reports.\n• Use Page Object Model (POM): Implement the Page Object Model to separate test logic from page-specific code. This design pattern promotes code reusability, maintainability, and easier updates.\n• Handle Exceptions Carefully: Implement error handling and logging to manage unexpected situations, such as element not found or timeout errors. This helps in debugging and provides insights into test failures.\n• Optimize Browser Performance: Run tests in headless mode or use browser profiles to speed up test execution and reduce resource consumption. Also, ensure that browser drivers are up-to-date for compatibility and performance improvements.\n\nRunning Selenium Python tests on BrowserStack’s Real Device Cloud offers numerous advantages that significantly enhance testing efficiency and effectiveness.\n\nBrowserStack provides access to a wide range of real devices and browsers, ensuring that tests reflect real-world scenarios and uncover device-specific issues. The platform supports scalable parallel execution, allowing multiple tests to run simultaneously across various configurations, which accelerates the development cycle.\n\nCross-platform testing on BrowserStack ensures consistent application performance across different environments. Additionally, it offers real-time debugging features such as live logs, screenshots, and video recordings, which aid in quick troubleshooting.\n\nSeamless integration with CI/CD pipelines further automates the testing process, enabling tests to run on every code change and providing immediate feedback on application quality. Overall, BrowserStack Automate enables comprehensive, efficient, and reliable testing, fostering continuous development and deployment."
    },
    {
        "link": "https://medium.com/@aifakhri/page-object-models-implementation-with-pytest-b9673744b8c0",
        "document": "Each page in our use case (the-internet.herokuapp.com) already contains a unique web component. However, I will not cover all the web pages on the site, I will cover 4 pages that are common and unique:\n\nAnd I have explored these pages and created a manual test case that will be used as a guideline to build our testing framework. Below I will explain how we create these page objects.\n\nThis web page provides a form authentication example. This function is commonly found in many web applications.\n\nWhat we want to test here is the login function of the form. Hence, we need to identify the web element in the form, we could use inspect element to identify the elements:\n\nThen we need to identify the locator that is associated with how user interact with this element in the initial login page:\n\nThen we need to turn those locators into methods.\n\nHere is the methods for entering username and password into the form:\n\nFrom the picture above, the method is using the method from the common.py library because it is the first element we want to find after we navigate from the home page to this web page. While the method uses the method because the page is finished loading the whole page.\n\nThe next thing we do is to click the login button with this method based on the locator strategy above:\n\nThen we identify whether the login is successful based on the flashcard in the web page:\n\nAfterwards, we still need to be able to check, whether the logout button is operational from the hidden flashcard in the login page:\n\nHere is the locator strategy for verifying login and logout pages.\n\nNote that the alert button for both login has the same ID, hence we could use these locator strategies for both methods. With these locator strategies, we could create method:\n\nCombining all web elements we’ve gathered from the picture above, we could model methods and locator strategy as follow for this page:\n\nThis web page demonstrates how a user can add and remove a web element in a web page. So, what we want to do here is to add a new button one time, and delete the new button one time. Here is the web element that I think can be used in our test:\n\nLuckily both button elements have different class, hence we could simplify our locator strategy as follow:\n\nWith these strategy we could create a page object class as follow:\n\nThe method needs to use because we need to wait for this page to be loaded for. For the we also use the element, because the DOM is changing, hence we need to wait and add an exception in case the delete button is not there after we click add element. Lastly, method we use find because the web page is finished loading.\n\nThis page is showcasing how to interact with a context menu which is a custom addition that appears in the right-click menu. What we want to test for this is how we could successfully interact with the context menu element and respond the alert that appears after we click it:\n\nSelenium handles the right-click differently than the left-click. They define it as the context click, which has its own class called ActionChain class. The operation of the context click would be defined in the file because we might want to use this in the future:\n\nHere is the web element that evokes the context menu:\n\nFrom image above and the context click method from we could create a locator strategy and methods:\n\nNext to handle an Alert, we could use Selenium method from Selenium's module, which has been imported in the file:\n\nInside our Page Object class this method is used to check whether the alert is there (by inspecting its text) and also accept the alert:\n\nAlso, we need to test whether the alert can be closed, hence we need an element to indicate whether the alert is closed, here is my idea for such element:\n\nI chose this because when we close the alert, we are still on the same web page. Hence, this static element is useful to validate our testing. Here is the locator strategy and method:\n\nHere is the complete Page Object class for this web page:\n\nThis page shows the behavior of an asynchronous change of a web element . Hence, we want to test this behavior. In this web page there are two elements that have its own button that controls the asynchronous behavior:\n\nIf you dig deep into these buttons, both elements are so similar:\n\nHere is my locator strategy to distinguish both button elements:\n\nThese locator strategy seems tricky but we could create a single method for both strategy:\n\nIn the control button method, we want to click the button then wait for the element to be synced. Hence we need another strategy to check whether the element is already synced:\n\nThis strategy is based on the behavior when asynchronous process after we click the control button for each checkbox and input text:\n\nThen we need a locator strategy to check whether the element is already deleted or enabled:\n\nWe could put these strategies in a single method, but what we want to check with these elements are different. Hence it is better to use different method too:\n\nBoth methods are using the method because of the asynchronous behavior.\n\nHere is the complete python code for this Page Object:"
    },
    {
        "link": "https://browserstack.com/guide/page-object-model-in-selenium-python",
        "document": "Maintaining automation test scripts can become challenging as applications grow. The Page Object Model (POM) simplifies this by organizing web elements and actions into reusable page classes, making tests more readable and easier to maintain.\n\nThis article explores the implementation of the Page Object Model in Selenium using Python, enabling efficient cross-browser testing for your website.\n\nWhat is Page Object Model (POM) in Selenium?\n\nThe Page Object Model (POM) is a structured approach to writing Selenium automation tests. Instead of writing locators and actions directly in test cases, POM stores them in dedicated page classes. This makes automation scripts cleaner, easier to maintain, and more reusable. If the application’s UI changes, updates are needed only in the page class, not in every test script.\n\nThere are many benefits to creating a POM, such as:\n• Testing Quality: The POM helps you write tests that are easy to understand and maintain. This can help improve the quality of your testing process to improve the readability and reliability of the scripts.\n• Site Maintenance: It is easier to maintain the site over time. Suppose if something got changed on any page, you could easily find the functions and locators that need to be changed by that page class.\n• Team Collaboration: The POM can help with collaboration between team members and significantly improve the efficiency of your team.\n• Overall Productivity: The POM can make it easier for new team members to get up to speed and boost overall team productivity.\n• Reusing Code: Using POM, you can reuse your functions in different Test Scripts by importing them from Page Class. It doesn’t require writing the same functions in different test cases.\n\nWith all of these benefits, it is clear that a POM can be a valuable tool for any organization. By creating one, you can help improve the quality of your software testing process and team collaboration.\n\nPage Factory is a method of implementing the Page Object Model (POM) in Selenium. It enhances POM by initializing web elements at runtime and providing additional features for better test efficiency.\n\nTo support the Page Object pattern, Page Factory in Python uses a dictionary to declare all web elements, where dictionary keys act as WebElement or class member variables with extended WebElement methods.\n\nUnlike the standard POM, Page Factory initializes all web elements at once when the page class is instantiated. Additionally, it enhances WebElement methods, such as extending the click() method to include an explicit wait until the element is clickable, improving test stability.\n\nPage Object Model in Selenium with Python using Selenium page factory\n\nIt is easy implement page factory in Selenium with Python by using the selenium-page-factory package. Install it by using\n\nTo use selenium-page-factory every Page in the Page Object Model should have a WebDriver object as a class member as shown below:\n\nA well-structured project keeps test scripts organized and easy to maintain. Below is a typical folder structure for implementing Page Object Model (POM) with Page Factory in Selenium using Python.\n\nTo install packages you can use pip.\n\nPOM structure has a structure for all the pages. This package consists of class files related to every pages. Each page class contains methods specific to the actions that can be performed on that page.\n\nThe following is the Page Class for the Sign In Page. The PageFactory class is imported from its module, and a new class named SignInPage is created, inheriting from PageFactory. Each page class must initialize the driver within the __init__ method. Locators are stored in a dictionary, where the key represents the locator name, and the value is a tuple containing the locator type and its corresponding value.\n\nNext, all the necessary functions for interacting with the page are defined, such as entering the username and password. The syntax for writing these functions is as follows:\n\nAll page classes follow the same structure. Below is an example of a page class for the Home Page.\n\nHere is the code snippet for test_browserstack.py\n\nIn this test case, all the methods defined within the page classes are utilized.\n• First, we need to import those page classes.\n• Initialize the driver for the chrome web driver.\n\nThis approach allows test cases to be executed using the Page Object Model, ensuring that the methods inside page classes can be reused across multiple test cases.\n\nSince the pytest framework is used, the test case can be executed by running a pytest command.\n\nHere is the video of our test run.\n\nBrowserStack gives you instant access to Selenium Grid of 3500+ real devices and desktop browsers. Running your Selenium tests with Python on BrowserStack is simple yet effective, always.\n\nWe need to replace browser = webdriver.Chrome() to\n\nIt will start running your test cases on the BrowserStack cloud.\n\nPage Object Model is a great way to organize your code and make it more reusable and understandable. It helps a lot when you need to do maintenance with your test scripts. In Automation Testing, our code often breaks due to changes in selectors which need to be fixed many times in the code. Page Factory helps debug that change and organize code in such a way that we can easily change our selectors.\n\nRun your test cases in parallel on multiple browsers using BrowserStack Automate as it’s difficult to test your Web App on multiple browsers with their different versions locally. But, BrowserStack provides you with 3500+ real devices and web browsers to test your application using Selenium. You can also test that in parallel to accelerate CI/CD pipelines."
    },
    {
        "link": "https://williamguomd.github.io/Page%20Object%20Design%20in%20Python%20and%20Selenium.html",
        "document": "I have seen many people using python for web application automation test, however many of them forget the general best practice. In this article, I will give a complete example on Page Object designing in web application automation test. If you are not familiar with Page Object, feel free to refer my previous post Page Object Model and Fluent Design I and Page Object Model and Fluent Design II.\n\nIn my example, I am using pytest as unit test framework and PyCharm as IDE. If you are not familiar with pytest fixture, refer Data Driven Test in pytest –fixture. In addition, I strongly suggest to set a seperate virtual environment for your project — PyCharm can help you on this easily.\n\nFirstly let’s build a BasePage as the parent of all page classes. To simplify, I have not put too many functions in the class so far.\n\nThen we build a real page. you can see clearly it extends from BasePage.\n\nIn terms of the elements in the page, Selenium Python does not support PageFactory as Selenium Java API does. We can put the locators of the elements in a separate file to make the maintenance easier. You can also put them in the same page class actually.\n\nThe next is page test. Same as I introduced in JAVA section, we need a general page test class to set driver, open page, and etc. Here we need to use the pytest fixture feature. Firstly in the conftest.py file we build following fixture. BTW: “request” is a pytest built-in fixture. with request.cls.driver = web_driver, any class use this fixture will get an attribute driver automatically.\n\nHere is the general page test class. All other page test class should extends from this calss. And it use fixture “driver_init“\n\nIn both BaseTest and Test_Regression, there is no attribute definition of driver, however since we use the driver_init fixture, we can use it directly in the page test class. Actually this is a powerful feature of python — Independent Injection. Following is the overview on the project file structure.\n\n\n\nIf you can integrate the data driven approach I introduced in another post, a python + selenium automation test framework is coming to a rough stage. Wish you have fun~~~"
    },
    {
        "link": "https://frugaltesting.com/blog/page-object-model-and-page-factory-in-selenium-with-python",
        "document": "In test automation, efficiency, maintainability, and reusability of test scripts are crucial for long-term success. Page Object Model (POM) and Page Factory are two essential design patterns in Selenium with Python that help achieve these goals.\n\nWith POM, each web page is represented as a class, and the interactions with page elements are defined as methods, promoting the \"separation of concerns\" principle.\n\nOn the other hand, Page Factory acts as a lightweight implementation of POM, offering a more efficient way to initialize web elements.\n\nThe Page Object Model (POM) is a widely used design pattern in Selenium POM framework that enhances test automation by organizing UI elements into page objects. The POM design pattern improves maintainability and reusability by separating test logic from the UI structure. In a page object model framework, each web page is represented by a POM class, making test scripts more modular.\n\nBy the end of this blog, you’ll understand when to use POM, how it improves test automation and the key differences that distinguish POM from Page Factory.\n\nWhy you should keep scrolling:\n\n🚀To understand what Page Object Model (POM) and Page Factory are and how they work in Selenium with Python.\n\n🚀 To learn how to set up and implement these design patterns in your automation framework.\n\n🚀 To explore the critical differences between POM and Page Factory and when to use each approach.\n\nThe Page Object Model (POM) is a design pattern widely used in Selenium test automation to create maintainable, reusable, and scalable test scripts. In POM, each web page of the application is represented as a separate class.\n\nThis class contains web elements (like buttons, text boxes, and links) and corresponding methods that interact with them, making it easier to perform user actions on the page.\n\nBy following this structure, test scripts become more readable and maintainable as the logic to locate elements is separated from the actual test logic.\n\nThis separation of concerns ensures that even if the user interface changes, only the Page Object needs to be updated, not the test scripts.\n\nThe Selenium Page Object Model helps in reducing code duplication, enhancing readability, and making the framework more maintainable. Instead of directly referencing locators in the test scripts, POM allows testers to use the Page Object Model design pattern, where locators are defined as class variables. This makes it easy to handle changes in the UI structure. To better understand, consider a Page Object Model example for a login page.\n\nThe login page class will have locators for the username, password, and login button along with methods like enter_username(), enter_password(), and click_login(). This modular approach is a key reason why the Page Object Model in Selenium is widely used for building robust test automation frameworks.\n\nThe Page Object Model (POM) is used in Selenium to create more maintainable, scalable, and readable test automation frameworks. POM provides a structured approach where each page of the application is represented as a separate class with web element locators and page-specific methods.\n\nThis approach allows for better separation of concerns, making it easier to maintain and update test scripts when there are changes in the user interface. This design pattern improves the modularity and reusability of code, as the same page elements and actions can be used across multiple test cases.\n\nAnother reason to use POM in Selenium is to reduce code duplication and promote code reusability. By storing element locators in a single location (Page Class), you can avoid hardcoding locators in every test script.\n\nThe advantages of Page Object Model include reduced code duplication, better test scalability, and easier updates when UI changes occur. The POM model in Selenium supports a structured approach to automation, while Page Factory in Selenium helps initialize elements dynamically using pagefactory.initelements.\n\nPage Factory is an enhancement of the Page Object Model (POM) used in Selenium to create a more efficient and faster way to initialize web elements. It provides a mechanism to initialize web elements using @FindBy annotations, making it easier to locate elements on a page. Instead of declaring locators manually, Page Factory in Selenium initializes them automatically when the Page Object class is instantiated.\n\nThe key difference between Page Factory and Page Object Model is that Page Factory uses lazy initialization, meaning elements are only loaded when they are accessed.\n\nBy using Page Factory, testers can use annotations like @FindBy, @CacheLookup, and @FindAll to define element locators efficiently. What is Page Factory in Selenium? Simply put, it’s a more streamlined approach to initializing and interacting with web elements, reducing the chances of errors and improving the performance of Selenium tests.\n\nBenefits of Using Page Factory in Selenium\n\nPage Factory in Selenium provides an efficient way to initialize web elements using @FindBy annotations, making the code cleaner and more maintainable. Unlike traditional approaches where locators are declared manually, Page Factory automates the process, ensuring faster element initialization. It follows the concept of lazy initialization, meaning elements are only loaded when they are accessed, which improves memory efficiency and reduces execution time.\n\nAnother key benefit of using Page Factory in Selenium is the ability to use @CacheLookup to cache frequently used web elements, resulting in faster test execution. The Page Factory approach also makes test scripts more readable and maintainable.\n\nInstead of searching for elements in every test case, you can store locators in the Page Object class, making it easier to handle changes in the UI.\n\nStep-by-Step Process to Implement Page Object Model (POM) in Selenium with Python\n• Set Up Project Structure\n• Create folders like pages/, tests/, utils/, and config/ to organize page classes, test scripts, utilities, and configuration files.\n• Create Page Classes\n• In the pages/ folder, create a Page Class for each web page.\n• Define web element locators (e.g., By.ID, By.XPATH) and reusable methods (e.g., enter_username(), click_button()) to interact with elements.\n• Set Up Web Driver Utility\n• Create a driver setup file in utils/ to initialize and configure the Selenium WebDriver.\n• Write Test Scripts\n• In the tests/ folder, import the required Page Classes and call their methods in test scripts. Add assertions to validate test outcomes.\n• Use Configuration Files\n• Store global settings like base URLs and credentials in config/ to avoid hardcoding values in scripts.\n\nHow to Set Up Page Factory in Selenium with Python??\n• Create folders for pages/, tests/, utils/, and config/ to separate page classes, test scripts, utilities, and configuration files.\n• Import necessary modules like from selenium.webdriver.common.by import By and from selenium.webdriver.support.page_factory import PageFactory in the Page Class.\n• In the pages/ folder, create a Page Class for each page (e.g., LoginPage) and define web element locators using @FindBy annotations.\n• Use PageFactory.init_elements() to initialize all the web elements in the class.\n• Add methods to perform actions like enter_username(), click_login(), etc., for user interactions with the page elements.\n• Import the Page Class in the test script and call the methods to perform tests.\n\nPage Object Model (POM) vs Page Factory: Key Differences You Should Know\n\nBoth Page Object Model (POM) and Page Factory aim to improve test automation efficiency. Let’s see the key differences between them in terms of code readability, reusability, and element initialization.\n\nThe Page Object Model (POM) plays a vital role in creating maintainable and efficient test automation frameworks. It provides a well-structured approach to organizing automation code by separating web element locators and page-specific methods from the actual test logic.\n\nThis makes it easier to manage code updates when changes are made to the UI, as only the Page Class needs to be updated, not the test scripts.\n\nPOM enables the creation of reusable code that can be shared across multiple automation test scenarios, saving time and effort.\n\nThis reusability is especially beneficial for complex data-driven scenarios, where multiple test cases share common page interactions like login, form submissions, or navigation.\n\nPOM also supports automated cross-browser testing by allowing seamless execution of tests across different browser environments. It enables testers to define browser capabilities for multiple browser versions, devices, and operating systems. When combined with a cloud-based cross-browser testing platform, POM allows testers to run tests on different combinations of browsers simultaneously, ensuring better coverage and faster execution.\n\nBy encapsulating all actual test scenarios within test scripts and keeping element definitions in Page Classes, POM reduces the time required for maintenance and provides a scalable, modular structure for large-scale test automation.\n\nExample of Page Object Model (POM) in Selenium\n\nThe Page Object Model (POM) is a structured approach where each web page is represented as a Page Class. This class acts as an object repository for all web elements like buttons, input fields, and links, which are identified using a locator type (e.g., By.ID, By.NAME, or By.XPATH) and a location strategy.\n\nInstead of referencing locators directly in test scripts, they are stored in the Page Class, making it easier to maintain the framework. Updates to locators in the Page Class automatically reflect in all related test scripts.\n\nIn the POM approach, methods are created to interact with object elements, such as enter_username(), enter_password(), and click_login() on a login screen. Driver objects are used to call these methods, ensuring reusability and reducing maintenance efforts.\n\nStatic methods or instance methods are used to manage load times and handle dynamic elements with wait conditions. By following the POM structure, test automation frameworks become more scalable, maintainable, and readable.\n\nExample of Page Factory in Selenium\n\nThe Page Factory in Selenium is an advanced implementation of the Page Object Model (POM), which makes it easier to initialize and interact with web elements.\n\nUnlike traditional POM, where web elements are defined and initialized manually, Page Factory uses @FindBy annotations to define locators and automatically initializes them using PageFactory.init_elements(). This approach eliminates boilerplate code, enhances readability, and supports lazy initialization, meaning elements are only loaded when they are accessed.\n\nPage Factory is widely used in modern test automation frameworks to reduce maintenance efforts and increase test efficiency. It works well for large-scale web applications where frequent UI changes occur.\n\nInstead of updating multiple scripts when locators change, testers only need to update the Page Class, making test maintenance simple.\n\nWith support for @CacheLookup, Page Factory speeds up frequently used web elements by caching them, which significantly improves execution speed.\n\nPage Object Model (POM) and Page Factory: When to Use Each Approach??\n\nWhen to Use Page Object Model (POM)?\n\nThe Page Object Model (POM) is best used when you want to have full control over how locators are defined and accessed. It is ideal for testers and developers who prefer a clear, explicit, and simple approach. POM is useful in scenarios where the UI elements remain static or change infrequently.\n\nSince the locators are declared as instance variables and initialized manually, it offers more control and better readability, making it easier for beginners to understand. POM works well in situations where explicit waits are required, and manual handling of elements is necessary for dynamic elements that load at different times.\n\nWhen to Use Page Factory?\n\nThe Page Factory approach should be used when you want a cleaner, shorter, and more maintainable codebase. It is useful in applications where web elements are frequently reused across multiple test scripts. @FindBy annotations reduce the boilerplate code for locator declarations, while PageFactory.init_elements() automates the initialization process.\n\nLazy initialization makes it ideal for large-scale, complex web applications where the loading of web elements can vary. Page Factory is preferred when you want to optimize the test execution speed using @CacheLookup to cache frequently accessed elements, especially in large test suites.\n\nMany page object model best practices recommend maintaining an object repository in Selenium to manage locators efficiently. Understanding the difference between POM and Page Factory is essential for implementing a robust page object model framework architecture. The POM full form in Selenium stands for Page Object Model, which simplifies automation by creating independent classes for each page. By leveraging page object model design pattern, teams can optimize their test automation strategy and improve code readability.\n• Name your methods clearly (e.g., click_login_button() instead of clickButton()) to improve readability and make the code self-explanatory.\n\nKeep Locators Centralized in the Page Class\n• Store all locators (like By.ID, By.XPATH) at the top of the Page Class to make them easy to update when UI changes occur.\n• Avoid hardcoding URLs, credentials, and environment details. Use a config file to store them and access them dynamically.\n• Write reusable methods like enter_text() or click_button() to avoid repetitive code for similar actions.\n\nUse Explicit Waits Instead of Implicit Waits\n• Use explicit waits instead of implicit waits for elements that load dynamically, ensuring your tests are stable and less flaky.\n• Avoid repeating the same logic across multiple methods or test scripts. Instead, create utility methods for common actions.\n• Each method should perform a single action, like clicking a button or entering text, to make the code more maintainable and modular.\n\nIn this blog, we explored the Page Object Model (POM) and Page Factory, two essential design patterns in Selenium that enhance the maintainability, reusability, and scalability of test automation frameworks. By encapsulating web elements and actions within Page Classes, POM follows the \"separation of concerns\" principle, which makes the framework more modular and maintainable, especially when dealing with complex test scenarios. Page Factory, on the other hand, introduces automation-friendly enhancements like @FindBy annotations and lazy initialization, significantly reducing boilerplate code and improving test efficiency, making it ideal for both simple tests and more intricate workflows.The blog also highlighted the key differences between POM and Page Factory, explaining when to use each approach based on factors like project size, UI changes, and the need for regression testing.\n\nWe provided a step-by-step guide for setting up POM and Page Factory in Selenium with Python, including project structure, driver setup, page class creation, and test execution.Object model frameworks like POM and Page Factory help streamline the testing process by ensuring test reusability and reducing maintenance efforts. We wrapped it up with real-world example scenarios, including logging into a web application, performing a product search, and simulating checkout workflows.Lastly, we shared top tips for writing maintainable POM code, such as keeping locators centralized, following the DRY (Don't Repeat Yourself) principle, and ensuring method clarity, ensuring that your automation framework is scalable, efficient, and easy to maintain .\n\nCompanies like Frugal Testing specialize in automation solutions, helping businesses streamline their testing strategies. Additionally, organizations looking for load testing services can optimize performance testing for scalable applications.\n\nNo, Page Factory is not deprecated. It is still supported in Selenium to improve code readability, reduce boilerplate code, and enable lazy initialization of web elements.\n\n👉What is the factory design pattern in Selenium?\n\n‍The Factory Design Pattern creates objects dynamically at runtime. In Selenium, it is used in Page Factory to initialize web elements automatically using @FindBy annotations.\n\n‍The Page Component Object Model (PCOM) is an advanced form of POM where reusable components (like headers, footers, or menus) are treated as separate classes to reduce redundancy and enhance maintainability.\n\n‍The Document Object Model (DOM) represents the structure of a webpage as a tree-like model, where elements (tags) are nodes, allowing Selenium to locate and interact with elements on the page.\n\n👉What is the difference between POM XML and TestNG XML?\n\n‍POM XML is a Maven configuration file used to manage dependencies and plugins, while TestNG XML defines the test suite, test classes, and execution order for TestNG-based test automation."
    },
    {
        "link": "https://pytest-with-eric.com/automation/pytest-selenium",
        "document": "As a website test automation engineer, have you ever struggled with repeatedly doing the same UI/UX actions?\n\nHuman manual testing is error-prone, time-consuming and in fact… just boring.\n\nIt also lacks scale - testing time grows linearly with complexity and number of tests.\n\nFeedback is slow and fairly manual, introducing many unknown variables due to human senses and memory.\n\nSo how can you improve this? How can you automate Web Browser UI testing?\n\nWell, there are several tools in the market, most notably Selenium.\n\nSelenium is a popular Web Browser automation that allows your to simulate website interactions with code.\n\nNow combine that with all you’ve learnt on Pytest and you’ll quickly discover what a game changer that is.\n\nIn this article, you’ll learn how to run basic Web Browser UI tests using Pytest and Selenium.\n\nWe’ll first look at a basic title check example, then run a DuckDuckGo search, test webpage logins and use the plugin to achieve similar objectives (in a simpler more “Pytesty” way).\n\nLastly, you’ll also learn more about the Page Object Model design principle and how to use this in your projects, or at work in a production setting, whatever your need is.\n\nYou can combine it with Pytest fixtures, parameters and much more to scale and automate Web Browser UI testing.\n\nSo let’s get started. If you’re feeling itchy, feel free to check out the code directly.\n\nIf you don’t have huge experience in Web UI/UX development, you may be wondering… why do I need automation to test the Web UI?\n\nCan’t we just pay a bunch of people to go do specific tasks on the Web UI and come back with a bug report?\n\nWell, that’s not the most optimum solution.\n\nComputers are incredible at doing repetitive tasks with very high precision.\n\nWhile backend unit, end-to-end, integration, regression, and functionality testing are very important — so is Web User Interface or experience testing.\n\nIt focuses on verifying the visual and interactive bits of a website, ensuring your users can interact with it as intended across different devices and browsers.\n• User Satisfaction: A well-functioning UI is essential for user satisfaction, prevents frustration and ensures a positive user experience.\n• Cross-Platform Compatibility: With the plethora of devices and browsers available today, ensuring your application looks and works consistently across all platforms is vital.\n• Brand Reputation: The quality of your web UI reflects your brand. A smooth, bug-free user interface enhances your brand’s reputation, while issues can lead to negative perceptions.\n• Agile Development Support: In agile environments, features are rapidly developed and deployed. Web UI testing ensures that these new features integrate seamlessly without affecting your existing user experience.\n\nOverall, Web UI testing is as much about keeping your users happy as it is about catching bugs.\n\nLet’s take a short tour down memory lane on Selenium.\n\nSelenium WebDriver is an open-source automation tool designed for web application testing.\n\nIt emerged from the limitations of its predecessor, Selenium Remote Control (RC), offering a more efficient way to control browsers programmatically.\n\nFounded in 2004 by Jason Huggins, Selenium WebDriver was created out of the need for an automated testing tool that could interact with a web page as a user would, including clicking links, filling out forms, and validating text.\n\nSelenium WebDriver became part of the Selenium Suite, revolutionizing web testing by providing a unified interface to write test scripts that work across different browsers seamlessly.\n\nIts adoption skyrocketed due to its ability to integrate with programming languages like Java, Python, C++ and C#, making it accessible to a broad range of developers and testers.\n\nToday, Selenium WebDriver supports multiple browsers, including Chrome, Firefox, and Safari, and operates on various operating systems.\n\nIts utility in executing tests in parallel, across different environments, significantly reduces the time for feedback cycles in CI/CD workflows.\n\nThis, along with being open-source and extensive community support, makes Selenium WebDriver one of the most popular and widely used tools today.\n\nOK, so the importance of Web UI testing in your CI/CD Pipelines is clear.\n\nHowever, Web UI testing comes with its own set of challenges that are important to address.\n• Slowness — One of the most notable issues is the inherent slowness. Tests often require interacting with the web interface in real-time, simulating user actions which can be time-consuming.\n• Debugging Challenges — Unlike unit tests that can precisely pinpoint failures within the code, Web UI tests lack this granularity, making it difficult to identify the root cause of issues.\n• Flaky Tests — Web UI tests can be flaky, meaning their outcomes can vary between runs without changes to the code. This inconsistency can be due to various factors, like network delays, browser inconsistencies, or dynamic content taking ages to load or simulating varying user actions.\n• Dynamic Content: Modern web applications may contain dynamic content that changes in response to user actions or events. Testing these elements can be difficult as the content may not be present at all times.\n• Test Maintenance: As applications evolve, their UIs change, which can lead to a high maintenance cost for tests. Updating tests to align with new UI elements can be time-consuming and requires constant vigilance.\n\nWhile you can address some of these challenges with Selenium and Pytest, you still need more sophisticated tooling, especially for mobile or tablet testing.\n\nHaving learnt so much about the need for Web UI testing, let’s get your hands dirty doing the cool stuff.\n\nI wanted to take the opportunity to introduce a common test design pattern.\n\nSomething we’ve not talked about previously on this website, although we have been using it in practice.\n\nThe Arrange, Act, Assert (AAA) model is a simple yet powerful pattern for structuring tests.\n\nThis model breaks down a test case into three clear sections:\n\nIn this initial step, you set up the conditions for your test.\n\nThis involves initializing objects, setting up fixtures, and hooks, configuring mocks or stubs, and preparing any data needed for the test.\n\nIt’s the core action that triggers the behaviour you want to verify.\n\nThis could be a function call, a method execution, or any operation that produces an outcome based on the arranged conditions.\n\nThe final step is where you verify the outcome of the action.\n\nYou check whether the actual results match your expected results, using assertions to validate the behaviour of your code under test.\n\nBy clearly separating the setup, execution, and verification phases of a test, you enhance clarity and ensure that each test focuses on a single behaviour, following the best practices of test-driven development (TDD).\n\nBefore diving into the source code, let’s set up your local environment so you can follow along.\n\nThe project has the following structure.\n\nSome knowledge of Python (used v3.12 for this example but any recent version should work) and Pytest is expected.\n\nNote — I’m using Pipenv to manage virtual environments and packages instead of Conda but feel free to use what’s best for you.\n\nThis guide covers the background, motivation and also how to use Pipenv.\n\nOnce you’re all set up with dependencies let’s move on.\n\nFirst, let’s set up our Chrome Browser Driver, defined as a fixture (function scoped as default).\n\nCheck which version of Chromium you’re using and download the driver from here.\n\nAt the time of writing, I picked the latest one from this downloads page.\n\nAs mentioned in the code you can also install the binary on the fly if you wish to, I just find it easier to download the driver, add it to the path and be done.\n\nThe method as the name suggests is a sticky wait until an action completes or an element is found.\n\nNotice the use of indicating the use of Pytest fixture setup and teardown functionality.\n\nThis is the Arrange step.\n\ndef test_title(chrome_browser): \n\n \"\"\" \n\n Test the title of the Python.org website \n\n \"\"\" \n\n chrome_browser.get(\"https://www.python.org\") \n\n assert chrome_browser.title == \"Welcome to Python.org\"\n\n\n\nWe pass the above fixture parameter to our test and get the Python official webpage.\n\nUsing the fixture to get the webpage is the Act phase and lastly asserting the title is the Assert phase.\n\nYou can assert pretty much any HTML, CSS or Javascript property (it just boils down to finding the element and carrying out the interaction).\n\nYou’ll notice a Chrome browser spin up and shut down. This is part of the test and hence why it’s kinda slow, depending on network and local system speeds.\n\nNow let’s get a bit more complex.\n\nIn this example, we’ll write a simple test that opens the popular DuckDuckGo search engine, locates the search box and searches for a phrase.\n\nYou’ll then assert that the search term is in the title.\n\nHere’s what it looks like done manually.\n\nNow let’s write out the test.\n\ndef test_search(chrome_browser): \n\n \"\"\" \n\n Test the search functionality of the DuckDuckGo website \n\n \"\"\" \n\n url = \"https://duckduckgo.com/\" \n\n search_term = \"Pytest with Eric\" \n\n \n\n chrome_browser.get(url) \n\n \n\n \n\n search_box = chrome_browser.find_element(By.ID, value=\"searchbox_input\") \n\n \n\n \n\n search_box.send_keys(search_term + Keys.RETURN) \n\n \n\n \n\n assert search_term in chrome_browser.title\n• Find the element by ID which we can do by right-clicking inspect on the search box itself (see screenshot)\n• Use the method to submit the text and hit the return button\n• Assert the search term in the title.\n\nRunning the test gives us\n\nHere’s a different bit more complex example.\n\nI’ve used this practice website to simulate a basic website login.\n\nYou can use any website or even spin up your own auth system, I just kept things simple without OAuth or 2FA to show how this works.\n\ndef test_login_functionality(chrome_browser): \n\n \"\"\" \n\n Test the login functionality of the Practice Test Automation website \n\n \"\"\" \n\n url = \"https://practicetestautomation.com/practice-test-login/\" \n\n \n\n \n\n chrome_browser.get(url) \n\n \n\n \n\n chrome_browser.find_element(By.ID, \"username\").send_keys(\"student\") \n\n chrome_browser.find_element(By.ID, \"password\").send_keys(\"Password123\") \n\n \n\n \n\n chrome_browser.find_element(By.ID, \"submit\").click() \n\n \n\n \n\n \n\n try: \n\n logout_button = chrome_browser.find_element( \n\n By.CLASS_NAME, \"wp-block-button__link\" \n\n ) \n\n assert logout_button.is_displayed(), \"Logout button is not displayed.\" \n\n except NoSuchElementException: \n\n assert False, \"Logout button does not exist.\" \n\n \n\n \n\n try: \n\n logout_button = chrome_browser.find_element(By.LINK_TEXT, \"Log out\") \n\n assert logout_button.is_displayed(), \"Logout button is not displayed.\" \n\n except NoSuchElementException: \n\n assert False, \"Logout button does not exist.\"\n\n\n\nThe first parts are pretty much identical.\n• Find the element ID of the username and password fields and enter the values of username and password (given on the website).\n• Find the element ID of the submit button and click it.\n\nOnce logged in, we want to assert that a Logout button is displayed.\n\nNow inspecting the page, you can see that the Logout button is indeed displayed but without an ID.\n\nHowever, it does have a CSS class.\n\nSo we find the element by the class name and use the property to assert its presence.\n\nAnother option is to use the link text (the text that displays on the button itself).\n\nNow you can have several permutations to write “Log out” but you get my point.\n\nUsing the element ID is by far the most reliable way to access the correct element however in its absence you can resolve to other strategies.\n\nRunning this also returns the expected pass with the in case of failures.\n\nExample Test 4 (Using the plugin)\n\nAll of this has been super interesting.\n\nYour ability to run tests against Web Browser UIs in Pytest seems great.\n\nIs there something more native? Built just for Pytest?\n\nIndeed there is.\n\nThe plugin gives you an out-of-the-box fixture that you can directly import and use into your tests.\n\nWithout having to define your fixtures, manage and set up teardowns.\n\nLet’s see how to use this (make sure to install the plugin before).\n\ndef test_pytest_selenium_plugin_example(selenium): \n\n \"\"\" \n\n Test the title and description of the Pytest with Eric website using the pytest-selenium plugin \n\n \"\"\" \n\n selenium.get(\"https://pytest-with-eric.com\") \n\n \n\n \n\n selenium.implicitly_wait(10) \n\n assert selenium.title == \"Pytest With Eric\" \n\n \n\n \n\n \n\n meta_description = selenium.find_element(By.XPATH, \"//meta[@name='description']\") \n\n \n\n \n\n content_value = meta_description.get_attribute(\"content\") \n\n \n\n \n\n expected_content = \"Learn to write production level Python Unit Tests with Pytest\" \n\n assert content_value == expected_content\n\n\n\nIt’s pretty much similar to what you’ve learnt so far.\n\nThe only difference is the fixture .\n\nAlso, note we’re using the element locator to find the field in the meta description.\n\nNow you still need to define the driver used and you can easily do so via the command line using\n\nI don’t know about you but I don’t particularly like passing command-line arguments so I’ve defined these in the config file.\n\nIf you’re unfamiliar with config files I recommend checking out this guide on Pytest config files.\n\nThis guide goes into in great detail.\n\nHere’s what mine looks like.\n\nWe’ve used the config setting to pass the argument.\n\nI can now cleanly run my test.\n\nIn other articles, we discussed abstracting implementation from the tests.\n\nIn simple words, don’t test the implementation of your code rather test it like a black box.\n\nLet’s do something similar here.\n\nIf you examine the tests, you’ll see the web page element IDs hardcoded in the tests.\n\nThis is not ideal especially if you choose to share the elements across several test modules or files.\n\nIf the element ID (username box ID, search button ID etc.) changes, you’ll need to change it in different places.\n\nWe can solve this problem with a very simple design principle called “The Page Object Model” (POM).\n\nThis is a very simple concept — separate the page and all its elements and actions into its class.\n\nThen import and use that class in the tests.\n\nLet’s see what this looks like\n\n\"\"\" \n\nLogin Page Class for https://practicetestautomation.com/practice-test-login/ \n\n\"\"\" \n\n \n\nfrom selenium.webdriver.common.by import By \n\nfrom selenium.common.exceptions import NoSuchElementException \n\n \n\n \n\nclass LoginPage: \n\n def __init__(self, driver): \n\n self.driver = driver \n\n \n\n def open_page(self, url): \n\n self.driver.get(url) \n\n \n\n def enter_username(self, username): \n\n self.driver.find_element(By.ID, \"username\").send_keys( \n\n username \n\n ) \n\n \n\n def enter_password(self, password): \n\n self.driver.find_element(By.ID, \"password\").send_keys( \n\n password \n\n ) \n\n \n\n def click_login(self): \n\n self.driver.find_element(By.ID, \"submit\").click() \n\n \n\n def verify_successful_login(self): \n\n try: \n\n logout_button = self.driver.find_element(By.LINK_TEXT, \"Log out\") \n\n return logout_button.is_displayed() \n\n except NoSuchElementException: \n\n assert False, \"Logout button does not exist.\"\n\n\n\nHere we have different methods for\n\nThe page element IDs are defined in one place and can be cleanly shared across many tests and modules.\n\nNow we can rewrite the test as follows.\n\nimport pytest \n\nfrom tests.pages.login_page import LoginPage \n\n \n\n\n\ndef test_login_functionality(chrome_browser): \n\n \"\"\" \n\n Test the login functionality of the Practice Test Automation website \n\n \"\"\" \n\n url = \"https://practicetestautomation.com/practice-test-login/\" \n\n login_page = LoginPage(chrome_browser) \n\n \n\n \n\n login_page.open_page(url) \n\n \n\n \n\n login_page.enter_username(\"student\") \n\n login_page.enter_password(\"Password123\") \n\n \n\n \n\n login_page.click_login() \n\n \n\n \n\n assert login_page.verify_successful_login()\n\n\n\nYou can immediately see how clean and portable the test looks.\n\nWe can do the same for our DuckDuckGo Search Class.\n\n\"\"\" \n\nSearchPage class to interact with the search page on DuckDuckGo \n\n\"\"\" \n\n \n\nfrom selenium.webdriver.common.keys import Keys \n\nfrom selenium.webdriver.common.by import By \n\n \n\nclass SearchPage: \n\n def __init__(self, driver): \n\n self.driver = driver \n\n \n\n def open_page(self, url): \n\n self.driver.get(url) \n\n \n\n def search(self, search_term): \n\n search_box = self.driver.find_element(By.ID, value=\"searchbox_input\") \n\n search_box.send_keys(search_term + Keys.RETURN)\n\n\n\nCorrespondingly the test\n\n import pytest \n\nfrom tests.pages.search_page import SearchPage \n\n \n\n\n\ndef test_search_functionality(chrome_browser): \n\n \"\"\" \n\n Test the search functionality of the DuckDuckGo website \n\n \"\"\" \n\n url = \"https://duckduckgo.com/\" \n\n search_term = \"Pytest with Eric\" \n\n search_page = SearchPage(chrome_browser) \n\n \n\n \n\n search_page.open_page(url) \n\n \n\n \n\n search_page.search(search_term) \n\n \n\n \n\n assert search_term in chrome_browser.title\n\n\n\nNote — I’ve used markers such as and to classify tests, making them easy to select and run.\n\nTo learn more about Pytest markers check out this detailed guide which explains various ways to help you classify and run your tests such as , , , and so on.\n\nHaving learnt so much about using Pytest with Selenium including several practice examples and the page object model, it’s time to explore some best practices.\n\nWhat are the “thou should-dos”?\n• Use Pytest Fixtures for Efficient Test Setup and Teardown — Use fixtures to initialize the Selenium WebDriver, manage test data, and close browser sessions in line with desired fixture scopes.\n• Adopt the Page Object Model (POM) — The Page Object Model is an essential design pattern in Selenium tests. It involves creating a separate class for each web page, encapsulating all the interactions with that page. This abstraction makes your tests more readable, maintainable, and reusable.\n• Implement a Robust Selector Strategy — Avoid using brittle selectors that can easily break with UI changes. Prioritize unique ID, name, or class selectors.\n• Parallelize Tests to Speed Up Execution — Plugins like significantly reduce the time required to run your entire test suite by running tests in parallel.\n• Integrate with CI Systems — Automate the execution of your Pytest Selenium tests within your CI/CD pipeline to catch issues early (ideally before releasing to production).\n• Organize Tests with Marks and Parameterization — Pytest marks allow you to categorize tests, making it easy to run subsets of the test suite. Parameterization, on the other hand, lets you run the same test with different inputs, maximizing test coverage with minimal code for example (testing across many browsers and more test cases).\n• Use Explicit Waits (where possible) — Rely on explicit waits rather than implicit waits or . Explicit waits are a more reliable way to wait for elements to become available or conditions to be met, reducing flakiness in your tests.\n\nExample from the Selenium Docs from selenium import webdriver \n\nfrom selenium.webdriver.common.by import By \n\nfrom selenium.webdriver.support.wait import WebDriverWait \n\nfrom selenium.webdriver.support import expected_conditions as EC \n\n \n\ndriver = webdriver.Firefox() \n\ndriver.get(\"http://somedomain/url_that_delays_loading\") \n\ntry: \n\n element = WebDriverWait(driver, 10).until( \n\n EC.presence_of_element_located((By.ID, \"myDynamicElement\")) \n\n ) \n\nfinally: \n\n driver.quit()\n\n\n\nHaving reviewed some of the best practices when working with Pytest and Selenium, what if you find yourself facing common issues?\n\nOne of the most frequent issues faced during Selenium testing is the “Element Not Found” error.\n\nThis occurs when Selenium attempts to interact with a web element that is not available in the Document Object Model (DOM) at the time of execution.\n• Check the Locator Accuracy: Ensure the locator (ID, XPath, CSS Selector, etc.) used to find the element is correct.\n• Use Explicit Waits: Instead of relying on static sleep, use explicit waits to wait for an element to become present or clickable.\n\nTiming issues occur when a test tries to interact with a web page that hasn’t finished loading or when asynchronous operations are still in progress.\n• Implement Smart Waits: Leverage Selenium’s explicit and implicit wait mechanisms to handle dynamic content. Explicit waits are particularly useful for waiting for specific conditions (like element visibility) before proceeding.\n• Adjust Implicit Waits: While explicit waits are preferred, adjusting the implicit wait time can provide a safety net for the entire test execution.\n\nYour Chrome or Firefox driver may fail to connect or act flaky.\n• Ensure you’ve downloaded the correct driver for the correct platform.\n• If you’re running tests on a CI/CD platform, make sure to download the correct browser driver for that test runner image.\n• Double-check your configuration and read the docs for any explicit configuration options.\n• Check that your driver is added to the path and is running.\n\nThis article has been somewhat different.\n\nIn the sense that it’s my first one on this website discussing Web UI and testing front-end elements.\n\nHowever, given the widespread popularity of Selenium and repeated requests from readers, I decided why not.\n\nHere we covered some basics of Selenium and talked about the need for Web Browser UI testing.\n\nWe then looked at several examples to understand the concept like testing a webpage login, title checks, and search checks and even studied the important concept of the Page Object Model (POM).\n\nLastly, we learnt about the best practices when working with Pytest and Selenium and strategies to debug failing tests.\n\nWith all this experience go out and explore the world of testing web pages, the internet is your oyster.\n\nIf you have ideas for improvement or like me to cover anything specific, please send me a message via Twitter, GitHub or Email.\n\nLink to Example Code: Pytest Selenium Example\n\nMaximizing Quality - A Comprehensive Look at Testing in Software Development\n\nWhat is Setup and Teardown in Pytest? (Importance of a Clean Test Environment)\n\nPytest Config Files - A Practical Guide To Good Config Management\n\nWhat Is And How To Save Time Using Pytest Config\n\nUltimate Guide To Pytest Markers And Good Test Management\n\nWhat Are Pytest Fixture Scopes? (How To Choose The Best Scope For Your Test)\n\nSave Money On You CI/CD Pipelines Using Pytest Parallel (with Example)\n\nWeb UI Testing Made Easy with Python, Pytest and Selenium WebDriver\n\n6 | Page Object Model | Selenium Python\n\npytest-selenium Plugin Documentation\n\nSelenium Pytest Tutorial: A Comprehensive Guide, with Examples & Best Practices"
    },
    {
        "link": "https://docs.pytest.org/en/stable/how-to/fixtures.html",
        "document": "How to use fixtures¶\n\nAt a basic level, test functions request fixtures they require by declaring them as arguments. When pytest goes to run a test, it looks at the parameters in that test function’s signature, and then searches for fixtures that have the same names as those parameters. Once pytest finds them, it runs those fixtures, captures what they returned (if anything), and passes those objects into the test function as arguments. In this example, “requests” (i.e. ), and when pytest sees this, it will execute the fixture function and pass the object it returns into as the argument. Here’s roughly what’s happening if we were to do it by hand: One of pytest’s greatest strengths is its extremely flexible fixture system. It allows us to boil down complex requirements for tests into more simple and organized functions, where we only need to have each one describe the things they are dependent on. We’ll get more into this further down, but for now, here’s a quick example to demonstrate how fixtures can use other fixtures: Notice that this is the same example from above, but very little changed. The fixtures in pytest request fixtures just like tests. All the same requesting rules apply to fixtures that do for tests. Here’s how this example would work if we did it by hand: One of the things that makes pytest’s fixture system so powerful, is that it gives us the ability to define a generic setup step that can be reused over and over, just like a normal function would be used. Two different tests can request the same fixture and have pytest give each test their own result from that fixture. This is extremely useful for making sure tests aren’t affected by each other. We can use this system to make sure each test gets its own fresh batch of data and is starting from a clean state so it can provide consistent, repeatable results. Here’s an example of how this can come in handy: Each test here is being given its own copy of that object, which means the fixture is getting executed twice (the same is true for the fixture). If we were to do this by hand as well, it would look something like this: A test/fixture can request more than one fixture at a time¶ Tests and fixtures aren’t limited to requesting a single fixture at a time. They can request as many as they like. Here’s another quick example to demonstrate: Fixtures can be requested more than once per test (return values are cached)¶ Fixtures can also be requested more than once during the same test, and pytest won’t execute them again for that test. This means we can request fixtures in multiple fixtures that are dependent on them (and even again in the test itself) without those fixtures being executed more than once. If a requested fixture was executed once for every time it was requested during a test, then this test would fail because both and would see as an empty list (i.e. ), but since the return value of was cached (along with any side effects executing it may have had) after the first time it was called, both the test and were referencing the same object, and the test saw the effect had on that object.\n\nFixtures requiring network access depend on connectivity and are usually time-expensive to create. Extending the previous example, we can add a parameter to the invocation to cause a fixture function, responsible to create a connection to a preexisting SMTP server, to only be invoked once per test module (the default is to invoke once per test function). Multiple test functions in a test module will thus each receive the same fixture instance, thus saving time. Possible values for are: , , , or . The next example puts the fixture function into a separate file so that tests from multiple test modules in the directory can access the fixture function: Here, the needs the fixture value. pytest will discover and call the marked fixture function. Running the test looks like this: $ pytest test_module.py platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y rootdir: /home/sweet/project collected 2 items test_module.py ================================= FAILURES ================================= smtp_connection = <smtplib.SMTP object at 0xdeadbeef0001> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg > assert 0 # for demo purposes :7: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef0001> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError test_module.py:: - assert 0 test_module.py:: - assert 0 You see the two failing and more importantly you can also see that the exactly same object was passed into the two test functions because pytest shows the incoming argument values in the traceback. As a result, the two test functions using run as quick as a single one because they reuse the same instance. If you decide that you rather want to have a session-scoped instance, you can simply declare it: # the returned fixture value will be shared for Fixtures are created when first requested by a test, and are destroyed based on their :\n• None : the default scope, the fixture is destroyed at the end of the test.\n• None : the fixture is destroyed during teardown of the last test in the class.\n• None : the fixture is destroyed during teardown of the last test in the module.\n• None : the fixture is destroyed during teardown of the last test in the package where the fixture is defined, including sub-packages and sub-directories within it.\n• None : the fixture is destroyed at the end of the test session. Pytest only caches one instance of a fixture at a time, which means that when using a parametrized fixture, pytest may invoke a fixture more than once in the given scope. In some cases, you might want to change the scope of the fixture without changing the code. To do that, pass a callable to . The callable must return a string with a valid scope and will be executed only once - during the fixture definition. It will be called with two keyword arguments - as a string and with a configuration object. This can be especially useful when dealing with fixtures that need time for setup, like spawning a docker container. You can use the command-line argument to control the scope of the spawned containers for different environments. See the example below.\n\nWhen we run our tests, we’ll want to make sure they clean up after themselves so they don’t mess with any other tests (and also so that we don’t leave behind a mountain of test data to bloat the system). Fixtures in pytest offer a very useful teardown system, which allows us to define the specific steps necessary for each fixture to clean up after itself. This system can be leveraged in two ways. “Yield” fixtures instead of . With these fixtures, we can run some code and pass an object back to the requesting fixture/test, just like with the other fixtures. The only differences are:\n• None is swapped out for .\n• None Any teardown code for that fixture is placed after the . Once pytest figures out a linear order for the fixtures, it will run each one up until it returns or yields, and then move on to the next fixture in the list to do the same thing. Once the test is finished, pytest will go back down the list of fixtures, but in the reverse order, taking each one that yielded, and running the code inside it that was after the statement. As a simple example, consider this basic email module: Let’s say we want to test sending email from one user to another. We’ll have to first make each user, then send the email from one user to the other, and finally assert that the other user received that message in their inbox. If we want to clean up after the test runs, we’ll likely have to make sure the other user’s mailbox is emptied before deleting that user, otherwise the system may complain. Here’s what that might look like: Because is the last fixture to run during setup, it’s the first to run during teardown. There is a risk that even having the order right on the teardown side of things doesn’t guarantee a safe cleanup. That’s covered in a bit more detail in Safe teardowns. If a yield fixture raises an exception before yielding, pytest won’t try to run the teardown code after that yield fixture’s statement. But, for every fixture that has already run successfully for that test, pytest will still attempt to tear them down as it normally would. While yield fixtures are considered to be the cleaner and more straightforward option, there is another choice, and that is to add “finalizer” functions directly to the test’s request-context object. It brings a similar result as yield fixtures, but requires a bit more verbosity. In order to use this approach, we have to request the request-context object (just like we would request another fixture) in the fixture we need to add teardown code for, and then pass a callable, containing that teardown code, to its method. We have to be careful though, because pytest will run that finalizer once it’s been added, even if that fixture raises an exception after adding the finalizer. So to make sure we don’t run the finalizer code when we wouldn’t need to, we would only add the finalizer once the fixture would have done something that we’d need to teardown. Here’s how the previous example would look using the method: It’s a bit longer than yield fixtures and a bit more complex, but it does offer some nuances for when you’re in a pinch. Finalizers are executed in a first-in-last-out order. For yield fixtures, the first teardown code to run is from the right-most fixture, i.e. the last test parameter. For finalizers, the first fixture to run is last call to . This is so because yield fixtures use behind the scenes: when the fixture executes, registers a function that resumes the generator, which in turn calls the teardown code.\n\nThe fixture system of pytest is very powerful, but it’s still being run by a computer, so it isn’t able to figure out how to safely teardown everything we throw at it. If we aren’t careful, an error in the wrong spot might leave stuff from our tests behind, and that can cause further issues pretty quickly. For example, consider the following tests (based off of the mail example from above): This version is a lot more compact, but it’s also harder to read, doesn’t have a very descriptive fixture name, and none of the fixtures can be reused easily. There’s also a more serious issue, which is that if any of those steps in the setup raise an exception, none of the teardown code will run. One option might be to go with the method instead of yield fixtures, but that might get pretty complex and difficult to maintain (and it wouldn’t be compact anymore). The safest and simplest fixture structure requires limiting fixtures to only making one state-changing action each, and then bundling them together with their teardown code, as the email examples above showed. The chance that a state-changing operation can fail but still modify state is negligible, as most of these operations tend to be transaction-based (at least at the level of testing where state could be left behind). So if we make sure that any successful state-changing action gets torn down by moving it to a separate fixture function and separating it from other, potentially failing state-changing actions, then our tests will stand the best chance at leaving the test environment the way they found it. For an example, let’s say we have a website with a login page, and we have access to an admin API where we can generate users. For our test, we want to:\n• None Go to the login page of our site\n• None Log in as the user we created\n• None Assert that their name is in the header of the landing page We wouldn’t want to leave that user in the system, nor would we want to leave that browser session running, so we’ll want to make sure the fixtures that create those things clean up after themselves. Here’s what that might look like: For this example, certain fixtures (i.e. and ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them. The way the dependencies are laid out means it’s unclear if the fixture would execute before the fixture. But that’s ok, because those are atomic operations, and so it doesn’t matter which one runs first because the sequence of events for the test is still linearizable. But what does matter is that, no matter which one runs first, if the one raises an exception while the other would not have, neither will have left anything behind. If executes before , and raises an exception, the driver will still quit, and the user was never made. And if was the one to raise the exception, then the driver would never have been started and the user would never have been made.\n\nSometimes you may want to run multiple asserts after doing all that setup, which makes sense as, in more complex systems, a single action can kick off multiple behaviors. pytest has a convenient way of handling this and it combines a bunch of what we’ve gone over so far. All that’s needed is stepping up to a larger scope, then having the act step defined as an autouse fixture, and finally, making sure all the fixtures are targeting that higher level scope. Let’s pull an example from above, and tweak it a bit. Let’s say that in addition to checking for a welcome message in the header, we also want to check for a sign out button, and a link to the user’s profile. Let’s take a look at how we can structure that so we can run multiple asserts without having to repeat all those steps again. For this example, certain fixtures (i.e. and ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them. Notice that the methods are only referencing in the signature as a formality. No state is tied to the actual test class as it might be in the framework. Everything is managed by the pytest fixture system. Each method only has to request the fixtures that it actually needs without worrying about order. This is because the act fixture is an autouse fixture, and it made sure all the other fixtures executed before it. There’s no more changes of state that need to take place, so the tests are free to make as many non-state-changing queries as they want without risking stepping on the toes of the other tests. The fixture is defined inside the class as well, because not every one of the other tests in the module will be expecting a successful login, and the act may need to be handled a little differently for another test class. For example, if we wanted to write another test scenario around submitting bad credentials, we could handle it by adding something like this to the test file:\n\nFixture functions can be parametrized in which case they will be called multiple times, each time executing the set of dependent tests, i.e. the tests that depend on this fixture. Test functions usually do not need to be aware of their re-running. Fixture parametrization helps to write exhaustive functional tests for components which themselves can be configured in multiple ways. Extending the previous example, we can flag the fixture to create two fixture instances which will cause all tests using the fixture to run twice. The fixture function gets access to each parameter through the special object: The main change is the declaration of with , a list of values for each of which the fixture function will execute and can access a value via . No test function code needs to change. So let’s just do another run: $ pytest -q test_module.py ================================= FAILURES ================================= smtp_connection = <smtplib.SMTP object at 0xdeadbeef0004> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg > assert 0 # for demo purposes :7: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef0004> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef0005> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 > assert b\"smtp.gmail.com\" in msg :6: AssertionError -------------------------- Captured stdout setup --------------------------- finalizing <smtplib.SMTP object at 0xdeadbeef0004> smtp_connection = <smtplib.SMTP object at 0xdeadbeef0005> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError ------------------------- Captured stdout teardown ------------------------- finalizing <smtplib.SMTP object at 0xdeadbeef0005> test_module.py:: - assert 0 test_module.py:: - assert 0 test_module.py:: - AssertionError: asser... test_module.py:: - assert 0 We see that our two test functions each ran twice, against the different instances. Note also, that with the connection the second test fails in because a different server string is expected than what arrived. pytest will build a string that is the test ID for each fixture value in a parametrized fixture, e.g. and in the above examples. These IDs can be used with to select specific cases to run, and they will also identify the specific case when one is failing. Running pytest with will show the generated IDs. Numbers, strings, booleans and will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name. It is possible to customise the string used in a test ID for a certain fixture value by using the keyword argument: The above shows how can be either a list of strings to use or a function which will be called with the fixture value and then has to return a string to use. In the latter case if the function returns then pytest’s auto-generated ID will be used. Running the above tests results in the following test IDs being used:\n\npytest minimizes the number of active fixtures during test runs. If you have a parametrized fixture, then all the tests using it will first execute with one instance and then finalizers are called before the next fixture instance is created. Among other things, this eases testing of applications which create and use global state. The following example uses two parametrized fixtures, one of which is scoped on a per-module basis, and all the functions perform calls to show the setup/teardown flow: Let’s run the tests in verbose mode and with looking at the print-output: $ pytest -v -s test_module.py platform linux -- Python 3.x.y, pytest-8.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python cachedir: .pytest_cache rootdir: /home/sweet/project collected 8 items test_module.py::test_0[1] SETUP otherarg 1 RUN test0 with otherarg 1 PASSED TEARDOWN otherarg 1 test_module.py::test_0[2] SETUP otherarg 2 RUN test0 with otherarg 2 PASSED TEARDOWN otherarg 2 test_module.py::test_1[mod1] SETUP modarg mod1 RUN test1 with modarg mod1 PASSED test_module.py::test_2[mod1-1] SETUP otherarg 1 RUN test2 with otherarg 1 and modarg mod1 PASSED TEARDOWN otherarg 1 test_module.py::test_2[mod1-2] SETUP otherarg 2 RUN test2 with otherarg 2 and modarg mod1 PASSED TEARDOWN otherarg 2 test_module.py::test_1[mod2] TEARDOWN modarg mod1 SETUP modarg mod2 RUN test1 with modarg mod2 PASSED test_module.py::test_2[mod2-1] SETUP otherarg 1 RUN test2 with otherarg 1 and modarg mod2 PASSED TEARDOWN otherarg 1 test_module.py::test_2[mod2-2] SETUP otherarg 2 RUN test2 with otherarg 2 and modarg mod2 PASSED TEARDOWN otherarg 2 TEARDOWN modarg mod2 You can see that the parametrized module-scoped resource caused an ordering of test execution that lead to the fewest possible “active” resources. The finalizer for the parametrized resource was executed before the resource was setup. In particular notice that test_0 is completely independent and finishes first. Then test_1 is executed with , then test_2 with , then test_1 with and finally test_2 with . The parametrized resource (having function scope) was set up before and teared down after every test that used it.\n\nUse fixtures in classes and modules with ¶ Sometimes test functions do not directly need access to a fixture object. For example, tests may require to operate with an empty directory as the current working directory but otherwise do not care for the concrete directory. Here is how you can use the standard and pytest fixtures to achieve it. We separate the creation of the fixture into a file: and declare its use in a test module via a marker: Due to the marker, the fixture will be required for the execution of each test method, just as if you specified a “cleandir” function argument to each of them. Let’s run it to verify our fixture is activated and the tests pass: You can specify multiple fixtures like this: and you may specify fixture usage at the test module level using : It is also possible to put fixtures required by all tests in your project into an ini-file: Note this mark has no effect in fixture functions. For example, this will not work as expected: This generates a deprecation warning, and will become an error in Pytest 8."
    },
    {
        "link": "https://docs.pytest.org/en/6.2.x/explanation/fixtures.html",
        "document": "Software test fixtures initialize test functions. They provide a fixed baseline so that tests execute reliably and produce consistent, repeatable, results. Initialization may setup services, state, or other operating environments. These are accessed by test functions through arguments; for each fixture used by a test function there is typically a parameter (named after the fixture) in the test function’s definition.\n\npytest fixtures offer dramatic improvements over the classic xUnit style of setup/teardown functions:\n• None fixtures have explicit names and are activated by declaring their use from test functions, modules, classes or whole projects.\n• None fixtures are implemented in a modular manner, as each fixture name triggers a fixture function which can itself use other fixtures.\n• None fixture management scales from simple unit to complex functional testing, allowing to parametrize fixtures and tests according to configuration and component options, or to re-use fixtures across function, class, module or whole test session scopes.\n• None teardown logic can be easily, and safely managed, no matter how many fixtures are used, without the need to carefully handle errors by hand or micromanage the order that cleanup steps are added.\n\nIn addition, pytest continues to support classic xunit-style setup. You can mix both styles, moving incrementally from classic to new style, as you prefer. You can also start out from existing unittest.TestCase style or nose based projects.\n\nFixtures are defined using the @pytest.fixture decorator, described below. Pytest has useful built-in fixtures, listed here for reference:\n\nBefore we dive into what fixtures are, let’s first look at what a test is. In the simplest terms, a test is meant to look at the result of a particular behavior, and make sure that result aligns with what you would expect. Behavior is not something that can be empirically measured, which is why writing tests can be challenging. “Behavior” is the way in which some system acts in response to a particular situation and/or stimuli. But exactly how or why something is done is not quite as important as what was done. You can think of a test as being broken down into four steps: Arrange is where we prepare everything for our test. This means pretty much everything except for the “act”. It’s lining up the dominoes so that the act can do its thing in one, state-changing step. This can mean preparing objects, starting/killing services, entering records into a database, or even things like defining a URL to query, generating some credentials for a user that doesn’t exist yet, or just waiting for some process to finish. Act is the singular, state-changing action that kicks off the behavior we want to test. This behavior is what carries out the changing of the state of the system under test (SUT), and it’s the resulting changed state that we can look at to make a judgement about the behavior. This typically takes the form of a function/method call. Assert is where we look at that resulting state and check if it looks how we’d expect after the dust has settled. It’s where we gather evidence to say the behavior does or does not align with what we expect. The in our test is where we take that measurement/observation and apply our judgement to it. If something should be green, we’d say . Cleanup is where the test picks up after itself, so other tests aren’t being accidentally influenced by it. At it’s core, the test is ultimately the act and assert steps, with the arrange step only providing the context. Behavior exists between act and assert. “Fixtures”, in the literal sense, are each of the arrange steps and data. They’re everything that test needs to do its thing. At a basic level, test functions request fixtures by declaring them as arguments, as and in the example below. In pytest, “fixtures” are functions you define that serve this purpose. But they don’t have to be limited to just the arrange steps. They can provide the act step, as well, and this can be a powerful technique for designing more complex tests, especially given how pytest’s fixture system works. But we’ll get into that further down. We can tell pytest that a particular function is a fixture by decorating it with . Here’s a simple example of what a fixture in pytest might look like: Tests don’t have to be limited to a single fixture, either. They can depend on as many fixtures as you want, and fixtures can use other fixtures, as well. This is where pytest’s fixture system really shines. Don’t be afraid to break things up if it makes things cleaner.\n\nSo fixtures are how we prepare for a test, but how do we tell pytest what tests and fixtures need which fixtures? At a basic level, test functions request fixtures by declaring them as arguments, as in the in the previous example. At a basic level, pytest depends on a test to tell it what fixtures it needs, so we have to build that information into the test itself. We have to make the test “request” the fixtures it depends on, and to do this, we have to list those fixtures as parameters in the test function’s “signature” (which is the line). When pytest goes to run a test, it looks at the parameters in that test function’s signature, and then searches for fixtures that have the same names as those parameters. Once pytest finds them, it runs those fixtures, captures what they returned (if anything), and passes those objects into the test function as arguments. In this example, “requests” (i.e. ), and when pytest sees this, it will execute the fixture function and pass the object it returns into as the argument. Here’s roughly what’s happening if we were to do it by hand: One of pytest’s greatest strengths is its extremely flexible fixture system. It allows us to boil down complex requirements for tests into more simple and organized functions, where we only need to have each one describe the things they are dependent on. We’ll get more into this further down, but for now, here’s a quick example to demonstrate how fixtures can use other fixtures: Notice that this is the same example from above, but very little changed. The fixtures in pytest request fixtures just like tests. All the same requesting rules apply to fixtures that do for tests. Here’s how this example would work if we did it by hand: One of the things that makes pytest’s fixture system so powerful, is that it gives us the abilty to define a generic setup step that can reused over and over, just like a normal function would be used. Two different tests can request the same fixture and have pytest give each test their own result from that fixture. This is extremely useful for making sure tests aren’t affected by each other. We can use this system to make sure each test gets its own fresh batch of data and is starting from a clean state so it can provide consistent, repeatable results. Here’s an example of how this can come in handy: Each test here is being given its own copy of that object, which means the fixture is getting executed twice (the same is true for the fixture). If we were to do this by hand as well, it would look something like this: A test/fixture can request more than one fixture at a time¶ Tests and fixtures aren’t limited to requesting a single fixture at a time. They can request as many as they like. Here’s another quick example to demonstrate: Fixtures can be requested more than once per test (return values are cached)¶ Fixtures can also be requested more than once during the same test, and pytest won’t execute them again for that test. This means we can request fixtures in multiple fixtures that are dependent on them (and even again in the test itself) without those fixtures being executed more than once. If a requested fixture was executed once for every time it was requested during a test, then this test would fail because both and would see as an empty list (i.e. ), but since the return value of was cached (along with any side effects executing it may have had) after the first time it was called, both the test and were referencing the same object, and the test saw the effect had on that object.\n\nFixtures requiring network access depend on connectivity and are usually time-expensive to create. Extending the previous example, we can add a parameter to the invocation to cause a fixture function, responsible to create a connection to a preexisting SMTP server, to only be invoked once per test module (the default is to invoke once per test function). Multiple test functions in a test module will thus each receive the same fixture instance, thus saving time. Possible values for are: , , , or . The next example puts the fixture function into a separate file so that tests from multiple test modules in the directory can access the fixture function: Here, the needs the fixture value. pytest will discover and call the marked fixture function. Running the test looks like this: $ pytest test_module.py platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y cachedir: $PYTHON_PREFIX/.pytest_cache rootdir: $REGENDOC_TMPDIR collected 2 items test_module.py ================================= FAILURES ================================= smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg > assert 0 # for demo purposes :7: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError ========================= short test summary info ========================== FAILED test_module.py::test_ehlo - assert 0 FAILED test_module.py::test_noop - assert 0 You see the two failing and more importantly you can also see that the exactly same object was passed into the two test functions because pytest shows the incoming argument values in the traceback. As a result, the two test functions using run as quick as a single one because they reuse the same instance. If you decide that you rather want to have a session-scoped instance, you can simply declare it: # the returned fixture value will be shared for Fixtures are created when first requested by a test, and are destroyed based on their :\n• None : the default scope, the fixture is destroyed at the end of the test.\n• None : the fixture is destroyed during teardown of the last test in the class.\n• None : the fixture is destroyed during teardown of the last test in the module.\n• None : the fixture is destroyed during teardown of the last test in the package.\n• None : the fixture is destroyed at the end of the test session. Pytest only caches one instance of a fixture at a time, which means that when using a parametrized fixture, pytest may invoke a fixture more than once in the given scope. In some cases, you might want to change the scope of the fixture without changing the code. To do that, pass a callable to . The callable must return a string with a valid scope and will be executed only once - during the fixture definition. It will be called with two keyword arguments - as a string and with a configuration object. This can be especially useful when dealing with fixtures that need time for setup, like spawning a docker container. You can use the command-line argument to control the scope of the spawned containers for different environments. See the example below.\n\nWhen we run our tests, we’ll want to make sure they clean up after themselves so they don’t mess with any other tests (and also so that we don’t leave behind a mountain of test data to bloat the system). Fixtures in pytest offer a very useful teardown system, which allows us to define the specific steps necessary for each fixture to clean up after itself. This system can be leveraged in two ways. “Yield” fixtures instead of . With these fixtures, we can run some code and pass an object back to the requesting fixture/test, just like with the other fixtures. The only differences are:\n• None is swapped out for .\n• None Any teardown code for that fixture is placed after the . Once pytest figures out a linear order for the fixtures, it will run each one up until it returns or yields, and then move on to the next fixture in the list to do the same thing. Once the test is finished, pytest will go back down the list of fixtures, but in the reverse order, taking each one that yielded, and running the code inside it that was after the statement. As a simple example, let’s say we want to test sending email from one user to another. We’ll have to first make each user, then send the email from one user to the other, and finally assert that the other user received that message in their inbox. If we want to clean up after the test runs, we’ll likely have to make sure the other user’s mailbox is emptied before deleting that user, otherwise the system may complain. Here’s what that might look like: Because is the last fixture to run during setup, it’s the first to run during teardown. There is a risk that even having the order right on the teardown side of things doesn’t guarantee a safe cleanup. That’s covered in a bit more detail in Safe teardowns. If a yield fixture raises an exception before yielding, pytest won’t try to run the teardown code after that yield fixture’s statement. But, for every fixture that has already run successfully for that test, pytest will still attempt to tear them down as it normally would. While yield fixtures are considered to be the cleaner and more straighforward option, there is another choice, and that is to add “finalizer” functions directly to the test’s request-context object. It brings a similar result as yield fixtures, but requires a bit more verbosity. In order to use this approach, we have to request the request-context object (just like we would request another fixture) in the fixture we need to add teardown code for, and then pass a callable, containing that teardown code, to its method. We have to be careful though, because pytest will run that finalizer once it’s been added, even if that fixture raises an exception after adding the finalizer. So to make sure we don’t run the finalizer code when we wouldn’t need to, we would only add the finalizer once the fixture would have done something that we’d need to teardown. Here’s how the previous example would look using the method: It’s a bit longer than yield fixtures and a bit more complex, but it does offer some nuances for when you’re in a pinch.\n\nThe fixture system of pytest is very powerful, but it’s still being run by a computer, so it isn’t able to figure out how to safely teardown everything we throw at it. If we aren’t careful, an error in the wrong spot might leave stuff from our tests behind, and that can cause further issues pretty quickly. For example, consider the following tests (based off of the mail example from above): This version is a lot more compact, but it’s also harder to read, doesn’t have a very descriptive fixture name, and none of the fixtures can be reused easily. There’s also a more serious issue, which is that if any of those steps in the setup raise an exception, none of the teardown code will run. One option might be to go with the method instead of yield fixtures, but that might get pretty complex and difficult to maintain (and it wouldn’t be compact anymore). The safest and simplest fixture structure requires limiting fixtures to only making one state-changing action each, and then bundling them together with their teardown code, as the email examples above showed. The chance that a state-changing operation can fail but still modify state is neglibible, as most of these operations tend to be transaction-based (at least at the level of testing where state could be left behind). So if we make sure that any successful state-changing action gets torn down by moving it to a separate fixture function and separating it from other, potentially failing state-changing actions, then our tests will stand the best chance at leaving the test environment the way they found it. For an example, let’s say we have a website with a login page, and we have access to an admin API where we can generate users. For our test, we want to:\n• None Go to the login page of our site\n• None Log in as the user we created\n• None Assert that their name is in the header of the landing page We wouldn’t want to leave that user in the system, nor would we want to leave that browser session running, so we’ll want to make sure the fixtures that create those things clean up after themselves. Here’s what that might look like: For this example, certain fixtures (i.e. and ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them. The way the dependencies are laid out means it’s unclear if the fixture would execute before the fixture. But that’s ok, because those are atomic operations, and so it doesn’t matter which one runs first because the sequence of events for the test is still linearizable. But what does matter is that, no matter which one runs first, if the one raises an exception while the other would not have, neither will have left anything behind. If executes before , and raises an exception, the driver will still quit, and the user was never made. And if was the one to raise the exception, then the driver would never have been started and the user would never have been made.\n\nFixture availability is determined from the perspective of the test. A fixture is only available for tests to request if they are in the scope that fixture is defined in. If a fixture is defined inside a class, it can only be requested by tests inside that class. But if a fixture is defined inside the global scope of the module, than every test in that module, even if it’s defined inside a class, can request it. Similarly, a test can also only be affected by an autouse fixture if that test is in the same scope that autouse fixture is defined in (see Autouse fixtures are executed first within their scope). A fixture can also request any other fixture, no matter where it’s defined, so long as the test requesting them can see all fixtures involved. For example, here’s a test file with a fixture ( ) that requests a fixture ( ) from a scope it wasn’t defined in: From the tests’ perspectives, they have no problem seeing each of the fixtures they’re dependent on: So when they run, will have no problem finding , because pytest searched from the tests’ perspectives. The scope a fixture is defined in has no bearing on the order it will be instantiated in: the order is mandated by the logic described here. The file serves as a means of providing fixtures for an entire directory. Fixtures defined in a can be used by any test in that package without needing to import them (pytest will automatically discover them). You can have multiple nested directories/packages containing your tests, and each directory can have its own with its own fixtures, adding on to the ones provided by the files in parent directories. For example, given a test file structure like this: The boundaries of the scopes can be visualized like this: The directories become their own sort of scope where fixtures that are defined in a file in that directory become available for that whole scope. Tests are allowed to search upward (stepping outside a circle) for fixtures, but can never go down (stepping inside a circle) to continue their search. So would be able to find the fixture defined in , but the one defined in would be unavailable to it because it would have to step down a level (step inside a circle) to find it. The first fixture the test finds is the one that will be used, so fixtures can be overriden if you need to change or extend what one does for a particular scope. You can also use the file to implement local per-directory plugins. Fixtures don’t have to be defined in this structure to be available for tests, though. They can also be provided by third-party plugins that are installed, and this is how many pytest plugins operate. As long as those plugins are installed, the fixtures they provide can be requested from anywhere in your test suite. Because they’re provided from outside the structure of your test suite, third-party plugins don’t really provide a scope like files and the directories in your test suite do. As a result, pytest will search for fixtures stepping out through scopes as explained previously, only reaching fixtures defined in plugins last. For example, given the following file structure: If is installed and provides the fixture , and is installed and provides the fixture , then this is what the test’s search for fixtures would look like: pytest will only search for and in the plugins after searching for them first in the scopes inside .\n\nWhen pytest wants to execute a test, once it knows what fixtures will be executed, it has to figure out the order they’ll be executed in. To do this, it considers 3 factors: Names of fixtures or tests, where they’re defined, the order they’re defined in, and the order fixtures are requested in have no bearing on execution order beyond coincidence. While pytest will try to make sure coincidences like these stay consistent from run to run, it’s not something that should be depended on. If you want to control the order, it’s safest to rely on these 3 things and make sure dependencies are clearly established. Within a function request for fixtures, those of higher-scopes (such as ) are executed before lower-scoped fixtures (such as or ). The test will pass because the larger scoped fixtures are executing first. The order breaks down to this: Fixtures of the same order execute based on dependencies¶ When a fixture requests another fixture, the other fixture is executed first. So if fixture requests fixture , fixture will execute first, because depends on and can’t operate without it. Even if doesn’t need the result of , it can still request if it needs to make sure it is executed after . If we map out what depends on what, we get something that look like this: The rules provided by each fixture (as to what fixture(s) each one has to come after) are comprehensive enough that it can be flattened to this: Enough information has to be provided through these requests in order for pytest to be able to figure out a clear, linear chain of dependencies, and as a result, an order of operations for a given test. If there’s any ambiguity, and the order of operations can be interpreted more than one way, you should assume pytest could go with any one of those interpretations at any point. For example, if didn’t request , i.e.the graph would look like this: Because nothing requested other than , and also requests , it’s now unclear if should go before/after , , or . The only rules that were set for is that it must execute after and before . pytest doesn’t know where should go in the case, so it should be assumed that it could go anywhere between and . This isn’t necessarily bad, but it’s something to keep in mind. If the order they execute in could affect the behavior a test is targetting, or could otherwise influence the result of a test, then the order should be defined explicitely in a way that allows pytest to linearize/”flatten” that order. Autouse fixtures are executed first within their scope¶ Autouse fixtures are assumed to apply to every test that could reference them, so they are executed before other fixtures in that scope. Fixtures that are requested by autouse fixtures effectively become autouse fixtures themselves for the tests that the real autouse fixture applies to. So if fixture is autouse and fixture is not, but fixture requests fixture , then fixture will effectively be an autouse fixture as well, but only for the tests that applies to. In the last example, the graph became unclear if didn’t request . But if was autouse, then and would effectively also be autouse because depends on them. As a result, they would all be shifted above non-autouse fixtures within that scope. So if the test file looked like this: the graph would look like this: Because can now be put above in the graph, pytest can once again linearize the graph to this: In this example, makes and effectively autouse fixtures as well. Be careful with autouse, though, as an autouse fixture will automatically execute for every test that can reach it, even if they don’t request it. For example, consider this file: Even though nothing in is requesting , it still is executed for the tests inside it anyway: But just because one autouse fixture requested a non-autouse fixture, that doesn’t mean the non-autouse fixture becomes an autouse fixture for all contexts that it can apply to. It only effectively becomes an auotuse fixture for the contexts the real autouse fixture (the one that requested the non-autouse fixture) can apply to. For example, take a look at this test file: It would break down to something like this: For and inside , effectively makes an autouse fixture, which is why and are executed for both tests, despite not being requested, and why and are executed before for . If this made an actual autouse fixture, then would also execute for the tests inside , since they can reference if they wanted to. But it doesn’t, because from the perspective of the tests, isn’t an autouse fixture, since they can’t see .\n\nSometimes you may want to run multiple asserts after doing all that setup, which makes sense as, in more complex systems, a single action can kick off multiple behaviors. pytest has a convenient way of handling this and it combines a bunch of what we’ve gone over so far. All that’s needed is stepping up to a larger scope, then having the act step defined as an autouse fixture, and finally, making sure all the fixtures are targetting that highler level scope. Let’s pull an example from above, and tweak it a bit. Let’s say that in addition to checking for a welcome message in the header, we also want to check for a sign out button, and a link to the user’s profile. Let’s take a look at how we can structure that so we can run multiple asserts without having to repeat all those steps again. For this example, certain fixtures (i.e. and ) are implied to exist elsewhere. So for now, let’s assume they exist, and we’re just not looking at them. Notice that the methods are only referencing in the signature as a formality. No state is tied to the actual test class as it might be in the framework. Everything is managed by the pytest fixture system. Each method only has to request the fixtures that it actually needs without worrying about order. This is because the act fixture is an autouse fixture, and it made sure all the other fixtures executed before it. There’s no more changes of state that need to take place, so the tests are free to make as many non-state-changing queries as they want without risking stepping on the toes of the other tests. The fixture is defined inside the class as well, because not every one of the other tests in the module will be expecting a successful login, and the act may need to be handled a little differently for another test class. For example, if we wanted to write another test scenario around submitting bad credentials, we could handle it by adding something like this to the test file:\n\nFixture functions can be parametrized in which case they will be called multiple times, each time executing the set of dependent tests, i. e. the tests that depend on this fixture. Test functions usually do not need to be aware of their re-running. Fixture parametrization helps to write exhaustive functional tests for components which themselves can be configured in multiple ways. Extending the previous example, we can flag the fixture to create two fixture instances which will cause all tests using the fixture to run twice. The fixture function gets access to each parameter through the special object: The main change is the declaration of with , a list of values for each of which the fixture function will execute and can access a value via . No test function code needs to change. So let’s just do another run: $ pytest -q test_module.py ================================= FAILURES ================================= smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 assert b\"smtp.gmail.com\" in msg > assert 0 # for demo purposes :7: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_ehlo(smtp_connection): response, msg = smtp_connection.ehlo() assert response == 250 > assert b\"smtp.gmail.com\" in msg :6: AssertionError -------------------------- Captured stdout setup --------------------------- finalizing <smtplib.SMTP object at 0xdeadbeef> smtp_connection = <smtplib.SMTP object at 0xdeadbeef> def test_noop(smtp_connection): response, msg = smtp_connection.noop() assert response == 250 > assert 0 # for demo purposes :13: AssertionError ------------------------- Captured stdout teardown ------------------------- finalizing <smtplib.SMTP object at 0xdeadbeef> ========================= short test summary info ========================== FAILED test_module.py::test_ehlo[smtp.gmail.com] - assert 0 FAILED test_module.py::test_noop[smtp.gmail.com] - assert 0 FAILED test_module.py::test_ehlo[mail.python.org] - AssertionError: asser... FAILED test_module.py::test_noop[mail.python.org] - assert 0 We see that our two test functions each ran twice, against the different instances. Note also, that with the connection the second test fails in because a different server string is expected than what arrived. pytest will build a string that is the test ID for each fixture value in a parametrized fixture, e.g. and in the above examples. These IDs can be used with to select specific cases to run, and they will also identify the specific case when one is failing. Running pytest with will show the generated IDs. Numbers, strings, booleans and will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name. It is possible to customise the string used in a test ID for a certain fixture value by using the keyword argument: The above shows how can be either a list of strings to use or a function which will be called with the fixture value and then has to return a string to use. In the latter case if the function returns then pytest’s auto-generated ID will be used. Running the above tests results in the following test IDs being used:"
    },
    {
        "link": "https://docs.pytest.org/en/stable/explanation/fixtures.html",
        "document": "pytest fixtures are designed to be explicit, modular and scalable.\n\nIn testing, a fixture provides a defined, reliable and consistent context for the tests. This could include environment (for example a database configured with known parameters) or content (such as a dataset). Fixtures define the steps and data that constitute the arrange phase of a test (see Anatomy of a test). In pytest, they are functions you define that serve this purpose. They can also be used to define a test’s act phase; this is a powerful technique for designing more complex tests. The services, state, or other operating environments set up by fixtures are accessed by test functions through arguments. For each fixture used by a test function there is typically a parameter (named after the fixture) in the test function’s definition. We can tell pytest that a particular function is a fixture by decorating it with . Here’s a simple example of what a fixture in pytest might look like: Tests don’t have to be limited to a single fixture, either. They can depend on as many fixtures as you want, and fixtures can use other fixtures, as well. This is where pytest’s fixture system really shines.\n\npytest fixtures offer dramatic improvements over the classic xUnit style of setup/teardown functions:\n• None fixtures have explicit names and are activated by declaring their use from test functions, modules, classes or whole projects.\n• None fixtures are implemented in a modular manner, as each fixture name triggers a fixture function which can itself use other fixtures.\n• None fixture management scales from simple unit to complex functional testing, allowing to parametrize fixtures and tests according to configuration and component options, or to reuse fixtures across function, class, module or whole test session scopes.\n• None teardown logic can be easily, and safely managed, no matter how many fixtures are used, without the need to carefully handle errors by hand or micromanage the order that cleanup steps are added. In addition, pytest continues to support How to implement xunit-style set-up. You can mix both styles, moving incrementally from classic to new style, as you prefer. You can also start out from existing unittest.TestCase style.\n\npytest does its best to put all the fixtures for a given test in a linear order so that it can see which fixture happens first, second, third, and so on. If an earlier fixture has a problem, though, and raises an exception, pytest will stop executing fixtures for that test and mark the test as having an error. When a test is marked as having an error, it doesn’t mean the test failed, though. It just means the test couldn’t even be attempted because one of the things it depends on had a problem. This is one reason why it’s a good idea to cut out as many unnecessary dependencies as possible for a given test. That way a problem in something unrelated isn’t causing us to have an incomplete picture of what may or may not have issues. Here’s a quick example to help explain: If, for whatever reason, had a bug and it raises an exception, we wouldn’t be able to know if or would also have problems. After throws an exception, pytest won’t run any more fixtures for , and it won’t even try to run itself. The only things that would’ve run would be and .\n\nIf you want to make test data from files available to your tests, a good way to do this is by loading these data in a fixture for use by your tests. This makes use of the automatic caching mechanisms of pytest. Another good approach is by adding the data files in the folder. There are also community plugins available to help to manage this aspect of testing, e.g. pytest-datadir and pytest-datafiles.\n\npytest does not do any special processing for and signals ( is handled naturally by the Python runtime via ), so fixtures that manage external resources which are important to be cleared when the Python process is terminated (by those signals) might leak resources. The reason pytest does not handle those signals to perform fixture cleanup is that signal handlers are global, and changing them might interfere with the code under execution. If fixtures in your suite need special care regarding termination in those scenarios, see this comment in the issue tracker for a possible workaround."
    },
    {
        "link": "https://stackoverflow.com/questions/74590160/using-a-class-based-test-as-a-fixture",
        "document": "Fixtures can be methods defined in a class, but then they are not available outside of the class. As the pytest documentation on fixtures states:\n\nFixture availability is determined from the perspective of the test. A fixture is only available for tests to request if they are in the scope that fixture is defined in. If a fixture is defined inside a class, it can only be requested by tests inside that class.\n\nThis means that you have to use a plain function to define re-usable fixtures. You can still access the class used by each test, however, via the attribute. Make sure to have the fixture take both the and the scopes:\n\nJust put that fixture in your file. You can use a different scope, provided it doesn't exceed the scope of the fixture (so your choices are and here).\n\nYou can then use that fixture with no actual test body to test the login:\n\nThis does seem a bit redundant, of course.\n\nUse the fixture for other classes the same way:"
    },
    {
        "link": "https://lambdatest.com/blog/end-to-end-tutorial-for-pytest-fixtures-with-examples",
        "document": "While writing your Selenium automation scripts, you’d often require data that you want to share across multiple tests. This is done by using objects which are used to instantiate the particular dataset. In pytest, this can be easily done with the help of fixtures.\n\nConsider a test scenario where MySQL queries are executed on a database. The execution time here depends on the size of the database and the operations can be highly CPU intensive depending on its size.\n\nIn such cases, repetitive implementation and execution are avoided by using pytest fixtures as they feed data to the tests such as DB connections. They also help to instantiate Selenium WebDriver for browsers under test, URLs to test, etc.\n\nIn this blog, we look at pytest fixtures and why you should use it for Python automation testing.\n\npytest fixtures are functions attached to the tests which run before the test function is executed. Fixtures are a set of resources that have to be set up before and cleaned up once the Selenium test automation execution is completed.\n\nThe pytest fixture function is automatically called by the pytest framework when the name of the argument and the fixture is the same.\n\nA function is marked as fixture using the following marker:\n\nShown below is a sample pytest fixture function for this Selenium Python tutorial:\n\nIn the sample code shown above, the fixture function is fixture_func() method. It is called when the test_fixture() function is invoked for execution. The return value of the fixture function is passed as an argument to test_fixture(). Assert is raised if the value returned by fixture_func() does not match the expected output.\n\nThe scope of a fixture function indicates the number of times a fixture function is invoked. Here are the detailed description of the pytest fixtures scope in this Selenium Python tutorial:\n• Function: This is the default value of the fixture scope. Fixture with function scope is executed once per session.\n• Package (or Session): A pytest fixture with scope as Session is created only once for the entire Selenium test automation session. Session scope is ideal for usage as WebDriver handles are available for the Selenium test automation session.\n• Module: As the name indicates, a fixture function with scope as Module is created (or invoked) only once per module.\n• Class: The fixture function is created once per class object.\n\nThe scope of pytest fixture function can be supplied with the @pytest.fixture marker.\n\nAs of now, the latest versions of Python and pytest are 3.13.2 and 8.3.4, respectively. However, this blog uses Python 3.6.6 and pytest 5.4.1.\n\nIn automated browser testing with Selenium, the web browser has to be loaded before the Selenium test automation is performed. Loading the browser before every test is not a good practice.\n\nRather, the web browser should be loaded once before the tests have started and closed once the tests are complete. pytest fixtures are extremely useful when you are performing automated browser testing.\n\nCommon Selenium WebDriver implementation can be a part of the fixture function, particularly – initialization of the Selenium WebDriver for browser under test & cleanup of resources after the completion of tests.\n\nFor demonstrating automated browser testing with pytest fixtures and Selenium WebDriver, I’ll consider the Selenium test automation scenarios mentioned below in this Selenium Python tutorial:\n• Select the first two checkboxes.\n• Send ‘Happy Testing at LambdaTest’ to the textbox with id = sampletodotext.\n• Click the Add Button and verify whether the text has been added or not.\n• Navigate to the official website of Google.\n• Click on the first test result.\n• Raise an Assert if the page title does not match the expected title.\n\nAs there are two different Selenium test automation cases, we would need two pytest fixtures functions for initialization and de-initialization of resources for Chrome and Firefox browser respectively.\n\nAll the necessary modules for this Selenium Python tutorial example are imported at the beginning of the implementation. Two pytest fixtures functions are created, one for each Selenium test automation case as different browsers are used for testing.\n\nThe chrome_driver_init() function is decorated with the @pytest.fixture indicating that it will be used as a fixture function. The scope of the fixture is set to class.\n\nThe request.cls will be set to None for a scope that is not of type class. Since the scope of the pytest fixtures function is set to class, request.cls is nothing but the test class that is using the function. For the test Test_URL_Chrome(), request.cls.driver will be the same as Test_URL_Chrome.driver which is the reference to the Chrome WebDriver instance.\n\nThe code after yield is run as a finalizer. Once the test is executed, the Selenium WebDriver is shut down using the close method of Selenium test automation.\n\nThe implementation for the other fixture function i.e. driver_init() is the same, except that the browser being used is Firefox.\n\nTo ensure that the WebDriver is initialized only once, the fixtures are applied to the respective base classes i.e. BaseTest() and Basic_Chrome_Test(). The test classes would be extended from the respective base class.\n\nThe fixture functions [driver_init() and chrome_driver_init()] are passed as arguments to the corresponding test functions. Test_URL is the test class that is extended from the base class BasicTest.\n\nTest_URL_Chrome is the test class that is extended from the base class Basic_Chrome_Test. Both classes contain a single test. The tests locate the required web elements on the web page.\n\nOnce located, appropriate Selenium methods [find_element_by_name(), find_element_by_id()] and necessary operations [i.e. click(), submit(), send_keys(), etc.] are performed on those elements. As this part of the Selenium Python tutorial focuses on pytest fixtures, we would not get into the minute details of the Selenium test automation implementation.\n\nThe following command is used for executing Selenium test automation:\n\nShown below in this Selenium Python tutorial is the execution snapshot which indicates that both the tests executed successfully.\n\nWhat if you need to execute the same tests on different web browsers e.g. Chrome, Firefox, Opera, etc., with separate pytest fixtures functions that instantiate the Selenium WebDriver for the required web browser.\n\nIt is recommended to have a single fixture function that can be executed across different input values. This can be achieved via parameterized pytest fixtures, which I’ll show next in this Selenium Python tutorial.\n\nParameterized driver_init fixture that takes input as Chrome and Firefox are below:\n\nDeclaration of params with @pytest.fixture contains a list of values (i.e. Chrome, Firefox) for each of which the fixture function will be executed. The value can be accessed using request.param function. Porting the code from a normal (i.e. non-parameterized) fixture to a parameterized fixture does not require any change in the feature implementation.\n\nTo demonstrate parameterized pytest features, I would execute the following test cases on Chrome and Firefox browsers:\n• Select the first two checkboxes.\n• Send ‘Happy Testing at LambdaTest’ to the textbox with id = sampletodotext.\n• Click the Add Button and verify whether the text has been added or not.\n\nAs the Selenium test automation needs to be executed on Chrome and Firefox browsers, we first create a parameterized fixture function that takes these as arguments. Depending on the browser being used for testing, an appropriate WebDriver instance for the browser is initiated i.e. if the param value is chrome, WebDriver for Chrome browser is initialized.\n\nAs shown below in this Selenium Python tutorial, request.param is used to read the value from the fixture function. The remaining implementation of the Fixture function remains the same as a non-parameterized fixture function.\n\nAs shown below in this Selenium Python tutorial, request.param is used to read the value from the pytest fixtures function. The remaining implementation of the Fixture function remains the same as a non-parameterized fixture function.\n\nRest of the implementation remains the same as Test Case (1) which is demonstrated in the section Automated Browser Testing using Selenium & pytest Fixtures. The only change is that we have used a parameterized fixture function to execute the test on Chrome and Firefox browsers.\n\nShown below is the Selenium test automation execution on the browsers under test:\n\nAs seen in the terminal snapshot, the test code test_open_url() is invoked separately for input values chrome and firefox.\n\nAlong with parameterized test fixtures, pytest also provides decorators using which you can parameterize test functions. The @pytest.mark.parametrize decorator enables the parameterization of arguments for a test function. Using this decorator, you can use a data-driven approach to testing as Selenium test automation can be executed across different input combinations.\n\nHere is how @pytest.mark.parametrize decorator can be used to pass input values:\n\nAs shown in the official documentation of parameterization in pytest, the expected output can also be supplied along with the input parameters.\n\nIn this pytest tutorial, learn how to use parameterization in pytest to write concise and maintainable test cases by running the same test code with multiple data sets.\n\nTo demonstrate parameterization in test functions, we perform Selenium test automation where separate web pages are opened for Chrome and Firefox browsers. Assert is raised if the page title does not match the expected title.\n\nAs shown in the implementation above for this Selenium Python tutorial, two input arguments of type string (test_browser and test_url) are supplied to the @pytest.mark.parametrize decorator. The input values are separated by comma (,) and enclosed under [].\n\nThe test function uses the input arguments added via the decorator for performing the Selenium test automation.\n\nThe rest of the implementation is self-explanatory and we would not get into details of the same. Shown below in this Selenium Python tutorial is the execution snapshot which indicates that Selenium test automation was executed across both the input combinations.\n\nThere might be cases where pytest fixtures have to be shared across different tests. Sharing of pytest fixtures can be achieved by adding the pytest fixtures functions to be exposed in conftest.py. It is a good practice to keep conftest.py in the root folder from where the Selenium test automation execution is performed.\n\nShown below is conftest.py where parameterized fixture function driver_init() is added.\n\nAs driver_init() fixture function is now a part of conftest.py, the implementation of fixture function is removed from the test code and @pytest.mark.usefixtures decorator with input as fixture function is added in the test file.\n\nBelow is the snippet of the implementation in the test file:\n\nRest of the implementation remains the same as the one demonstrated in the section Parameterized pytest Fixtures. As seen from the code snippet, the fixture implementation is no longer a part of the test code as it is now shifted to conftest.py. We do not import conftest.py in the test code as the pytest framework automatically checks its presence in the root directory when compilation is performed.\n\nThere are cases where a test might not be relevant for a particular platform or browser. Rather than executing the Selenium test automation case for that platform and expecting it to fail, it would be better if the test is skipped with a valid reason.\n\nA skip in pytest means that the test is expected to pass only on if certain conditions are met. Common cases are executing certain cross browser tests on the latest browsers such as Chrome, Firefox, etc. and skipping on Internet Explorer with a reason.\n\nA xfail means that the test is expected to fail due to some reason. A common example is a test for a feature that is yet to be implemented. If the test marked as xfail still happens to pass, it is marked as xpass (and not pass).\n\nxfail tests are indicated using the following marker:\n\nTests can be skipped for execution using the following marker:\n\nTests that skip, xpass, or xfail are reported separately in the test summary. Detailed information about skipped/xfailed tests is not available by default in the summary and can be enabled using the –r option\n\nA test function that has to be skipped for execution can be marked using the skip decorator along with an optional reason for skipping the test.\n\nFor conditional skip, the @pytest.mark.skipif marker can be used to skip the function if a condition is True. In the example shown below for this Selenium Python tutorial, test_function() will not be executed (i.e. skipped) if the Python version is less than 3.8.\n\nThe xfail marker is used to mark a test function that is expected to fail.\n\nIf a test fails only under a certain condition, the test can be marked as xfail with a condition and an optional reason that is printed alongside the xfailed test.\n\nxfail and skip markers can also be used along with fixtures in pytest. The respective markers can be supplied along with the parameters in a parameterized fixture.\n\nTo demonstrate the usage of xfail and skip markers with parameterized fixtures, we take sample test cases which are executed on Chrome, Firefox, and Safari browsers. As seen in the snippet above:\n• Test on Firefox is marked as xfail.\n• Test on Chrome is a regular test and marked with a marker pytest.mark.basic.\n• Test on Safari is marked as skip hence, it will not be executed.\n\nThe test case to be executed on Firefox is marked as xfail but the test case passes. Hence, the final status of the test on Firefox is xpass. Test on Chrome browser is marked with a marker pytest.mark.basic. It executes successfully and hence the status is pass.\n\nThe final test is on Safari browser and is marked with the skip marker. Hence, it is skipped for execution.\n\nShown below in this Selenium Python tutorial is the execution snapshot:\n\nWe use the earlier example to demonstrate usage of xfail and skip markers, with the markers applied on the individual test cases.\n\nThe test cases test_chrome_url() and test_firefox_url() are marked as xfail but they execute successfully. Hence, the result for these test cases is xpass. On the other hand, the final test test_safari_url() is marked with pytest.mark.skip marker and hence, will be skipped from execution.\n\nShown below is the execution snapshot:\n\nTo further enhance your Python testing with pytest fixtures, you can consider using cloud-based testing platforms such as LambdaTest.\n\nIt is an AI-powered test execution platform that lets you perform automation testing with pytest on real browsers, ensuring comprehensive test coverage and eliminating the hassle of local environment configuration. You can leverage its cloud grid capabilities to execute tests in parallel, significantly reducing test execution time and improving overall test efficiency.\n\npytest fixtures are functions that are run before each function to which it is applied is executed. Fixtures can be used for simple unit testing as well as testing for complex scenarios. pytest fixtures are ideal for usage in cross browser testing as browser resources need not be instantiated every time when a test is executed.\n\nFunction, module, class, and session are the different scopes available with fixture functions. pytest Fixtures, as well as test functions, can be parameterized. conftest.py is used to share fixtures across tests.\n\nFeel free to retweet and share this article with your peers! Do let us know of any queries or doubts you might have in the comment section down below. That’s it for now!"
    }
]