[
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/modeling/relationships",
        "document": "This document provides a simple introduction to the representation of relationships in object models and relational databases, including how EF Core maps between the two.\n\nA relationship defines how two entities relate to each other. For example, when modeling posts in a blog, each post is related to the blog it is published on, and the blog is related to all the posts published on that blog.\n\nIn an object-oriented language like C#, the blog and post are typically represented by two classes: and . For example:\n\nIn the classes above, there is nothing to indicate that and are related. This can be added to the object model by adding a reference from to the on which it is published:\n\nLikewise, the opposite direction of the same relationship can be represented as a collection of objects on each :\n\nThis connection from to and, inversely, from back to is known as a \"relationship\" in EF Core.\n\nRelational databases represent relationships using foreign keys. For example, using SQL Server or Azure SQL, the following tables can be used to represent our and classes:\n\nIn this relational model, the and tables are each given a \"primary key\" column. The value of the primary key uniquely identifies each post or blog. In addition, the table is given a \"foreign key\" column. The primary key column is referenced by the foreign key column of the table. This column is \"constrained\" such that any value in the column of must match a value in the column of . This match determines which blog every post is related to. For example, if the value in one row of the table is 7, then the post represented by that row is published in the blog with the primary key 7.\n\nEF Core relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model.\n\nIn the most basic sense, this involves:\n• Associating the references between entity types with the primary and foreign keys to form a single relationship configuration.\n\nOnce this mapping is made, EF changes the foreign key values as needed when the references between objects change, and changes the references between objects as needed when the foreign key values change.\n\nFor example, the entity types shown above can be updated with primary and foreign key properties:\n\nThe primary key property of , , and the foreign key property of , , can then be associated with the references (\"navigations\") between the entity types ( and ). This is done automatically by EF when building a simple relationship like this, but can also be specified explicitly when overriding the method of your . For example:\n\nNow all these properties will behave coherently together as a representation of a single relationship between and .\n\nEF supports many different types of relationships, with many different ways these relationships can be represented and configured. To jump into examples for different kinds of relationships, see:\n• One-to-many relationships, in which a single entity is associated with any number of other entities.\n• One-to-one relationships, in which a single entity is associated with another single entity.\n• Many-to-many relationships, in which any number of entities are associated with any number of other entities.\n\nIf you are new to EF, then trying the examples linked in in the bullet points above is a good way to get a feel for how relationships work.\n\nTo dig deeper into the properties of entity types involved in relationship mapping, see:\n• Foreign and principal keys in relationships, which covers how foreign keys map to the database.\n• Relationship navigations, which describes how navigations are layered over a foreign key to provide an object-oriented view of the relationship.\n\nEF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. Most of the examples show the model building API. To find out more about other options, see:\n• Relationship conventions, which discover entity types, their properties, and the relationships between the types.\n• Relationship mapping attributes, which can be used an alternative to the model building API for some aspects of relationship configuration.\n• Cascade deletes, which describe how related entities can be automatically deleted when or is called.\n• Owned entity types use a special type of \"owning\" relationship that implies a stronger connection between the two types than the \"normal\" relationships discussed here. Many of the concepts described here for normal relationships are carried over to owned relationships. However, owned relationships also have their own special behaviors.\n\nRelationships defined in the model can be used in various ways. For example:\n• Relationships can be used to query related data in any of three ways:\n• Eagerly as part of a LINQ query, using .\n• Lazily using lazy-loading proxies, or lazy-loading without proxies.\n• Explicitly using the or methods.\n• Relationships can be used in data seeding through matching of PK values to FK values.\n• Relationships can be used to track graphs of entities. Relationships are then used by the change tracker to:\n• Detect changes in relationships and perform fixup\n• Send foreign key updates to the database with or"
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/change-tracking/relationship-changes",
        "document": "Relationships in an Entity Framework Core (EF Core) model are represented using foreign keys (FKs). An FK consists of one or more properties on the dependent or child entity in the relationship. This dependent/child entity is associated with a given principal/parent entity when the values of the foreign key properties on the dependent/child match the values of the alternate or primary key (PK) properties on the principal/parent.\n\nForeign keys are a good way to store and manipulate relationships in the database, but are not very friendly when working with multiple related entities in application code. Therefore, most EF Core models also layer \"navigations\" over the FK representation. Navigations form C#/.NET references between entity instances that reflect the associations found by matching foreign key values to primary or alternate key values.\n\nNavigations can be used on both sides of the relationship, on one side only, or not at all, leaving only the FK property. The FK property can be hidden by making it a shadow property. See Relationships for more information on modelling relationships.\n\nThe following model contains four entity types with relationships between them. The comments in the code indicate which properties are foreign keys, primary keys, and navigations.\n\nThe three relationships in this model are:\n• Each blog can have many posts (one-to-many):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from a post to the associated blog. is the inverse navigation for .\n• is a collection navigation from a blog to all the associated posts. is the inverse navigation for .\n• Each blog can have one assets (one-to-one):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from the assets to the associated blog. is the inverse navigation for .\n• is a reference navigation from the blog to the associated assets. is the inverse navigation for .\n• Each post can have many tags and each tag can have many posts (many-to-many):\n• Many-to-many relationships are a further layer over two one-to-many relationships. Many-to-many relationships are covered later in this document.\n• is a collection navigation from a post to all the associated tags. is the inverse navigation for .\n• is a collection navigation from a tag to all the associated posts. is the inverse navigation for .\n\nSee Relationships for more information on how to model and configure relationships.\n\nEF Core keeps navigations in alignment with foreign key values and vice versa. That is, if a foreign key value changes such that it now refers to a different principal/parent entity, then the navigations are updated to reflect this change. Likewise, if a navigation is changed, then the foreign key values of the entities involved are updated to reflect this change. This is called \"relationship fixup\".\n\nFixup first occurs when entities are queried from the database. The database has only foreign key values, so when EF Core creates an entity instance from the database it uses the foreign key values to set reference navigations and add entities to collection navigations as appropriate. For example, consider a query for blogs and its associated posts and assets:\n\nFor each blog, EF Core will first create a instance. Then, as each post is loaded from the database its reference navigation is set to point to the associated blog. Likewise, the post is added to the collection navigation. The same thing happens with , except in this case both navigations are references. The navigation is set to point to the assets instance, and the navigation is set to point to the blog instance.\n\nLooking at the change tracker debug view after this query shows two blogs, each with one assets and two posts being tracked:\n\nThe debug view shows both key values and navigations. Navigations are shown using the primary key values of the related entities. For example, in the output above indicates that the collection navigation contains two related posts with primary keys 1 and 2 respectively. Similarly, for each post associated with the first blog, the line indicates that the navigation references the Blog with primary key 1.\n\nRelationship fixup also happens between entities returned from a tracking query and entities already tracked by the DbContext. For example, consider executing three separate queries for blogs, posts, and assets:\n\nLooking again at the debug views, after the first query only the two blogs are tracked:\n\nThe reference navigations are null, and the collection navigations are empty because no associated entities are currently being tracked by the context.\n\nAfter the second query, the reference navigations have been fixed up to point to the newly tracked instances. Likewise, the reference navigations are set to point to the appropriate already tracked instance.\n\nFinally, after the third query, the collection navigations now contain all related posts, and the references point to the appropriate instance:\n\nThis is the same end-state as was achieved with the original single query, since EF Core fixed up navigations as entities were tracked, even when coming from multiple different queries.\n\nThe easiest way to change the relationship between two entities is by manipulating a navigation, while leaving EF Core to fixup the inverse navigation and FK values appropriately. This can be done by:\n• Adding or removing an entity from a collection navigation.\n• Changing a reference navigation to point to a different entity, or setting it to null.\n\nFor example, let's move one of the posts from the Visual Studio blog to the .NET blog. This requires first loading the blogs and posts, and then moving the post from the navigation collection on one blog to the navigation collection on the other blog:\n\nThis is the debug view printed after running the code above:\n\nThe navigation on the .NET Blog now has three posts ( ). Likewise, the navigation on the Visual Studio blog only has one post ( ). This is to be expected since the code explicitly changed these collections.\n\nMore interestingly, even though the code did not explicitly change the navigation, it has been fixed-up to point to the Visual Studio blog ( ). Also, the foreign key value has been updated to match the primary key value of the .NET blog. This change to the FK value in then persisted to the database when SaveChanges is called:\n\nIn the previous example, a post was moved from one blog to another by manipulating the collection navigation of posts on each blog. The same thing can be achieved by instead changing the reference navigation to point to the new blog. For example:\n\nThe debug view after this change is exactly the same as it was in the previous example. This is because EF Core detected the reference navigation change and then fixed up the collection navigations and FK value to match.\n\nIn the previous section, relationships were manipulated by navigations leaving foreign key values to be updated automatically. This is the recommended way to manipulate relationships in EF Core. However, it is also possible to manipulate FK values directly. For example, we can move a post from one blog to another by changing the foreign key value:\n\nNotice how this is very similar to changing the reference navigation, as shown in the previous example.\n\nThe debug view after this change is again exactly the same as was the case for the previous two examples. This is because EF Core detected the FK value change and then fixed up both the reference and collection navigations to match.\n\nEF Core performs the following actions when it detects that a new dependent/child entity has been added to a collection navigation:\n• If the entity is not tracked, then it is tracked. (The entity will usually be in the state. However, if the entity type is configured to use generated keys and the primary key value is set, then the entity is tracked in the state.)\n• If the entity is associated with a different principal/parent, then that relationship is severed.\n• The entity becomes associated with the principal/parent that owns the collection navigation.\n• Navigations and foreign key values are fixed up for all entities involved.\n\nBased on this we can see that to move a post from one blog to another we don't actually need to remove it from the old collection navigation before adding it to the new one. So the code from the example above can be changed from:\n\nEF Core sees that the post has been added to a new blog and automatically removes it from the collection on the first blog.\n\nRemoving a dependent/child entity from the collection navigation of the principal/parent causes severing of the relationship to that principal/parent. What happens next depends on whether the relationship is optional or required.\n\nBy default for optional relationships, the foreign key value is set to null. This means that the dependent/child is no longer associated with any principal/parent. For example, let's load a blog and posts and then remove one of the posts from the collection navigation:\n\nLooking at the change tracking debug view after this change shows that:\n• The FK has been set to null ( )\n• The reference navigation has been set to null ( )\n• The post has been removed from collection navigation ( )\n\nNotice that the post is not marked as . It is marked as so that the FK value in the database will be set to null when SaveChanges is called.\n\nSetting the FK value to null is not allowed (and is usually not possible) for required relationships. Therefore, severing a required relationship means that the dependent/child entity must be either re-parented to a new principal/parent, or removed from the database when SaveChanges is called to avoid a referential constraint violation. This is known as \"deleting orphans\", and is the default behavior in EF Core for required relationships.\n\nFor example, let's change the relationship between blog and posts to be required and then run the same code as in the previous example:\n\nLooking at the debug view after this change shows that:\n• The post has been marked as such that it will be deleted from the database when SaveChanges is called.\n• The reference navigation has been set to null ( ).\n• The post has been removed from collection navigation ( ).\n\nNotice that the remains unchanged since for a required relationship it cannot be set to null.\n\nCalling SaveChanges results in the orphaned post being deleted:\n\nBy default, marking orphans as happens as soon as the relationship change is detected. However, this process can be delayed until SaveChanges is actually called. This can be useful to avoid making orphans of entities that have been removed from one principal/parent, but will be re-parented with a new principal/parent before SaveChanges is called. ChangeTracker.DeleteOrphansTiming is used to set this timing. For example:\n\nAfter removing the post from the first collection the object is not marked as as it was in the previous example. Instead, EF Core is tracking that the relationship is severed even though this is a required relationship. (The FK value is considered null by EF Core even though it cannot really be null because the type is not nullable. This is known as a \"conceptual null\".)\n\nCalling SaveChanges at this time would result in the orphaned post being deleted. However, if as in the example above, post is associated with a new blog before SaveChanges is called, then it will be fixed up appropriately to that new blog and is no longer considered an orphan:\n\nSaveChanges called at this point will update the post in the database rather than deleting it.\n\nIt is also possible to turn off automatic deletion of orphans. This will result in an exception if SaveChanges is called while an orphan is being tracked. For example, this code:\n\nDeletion of orphans, as well as cascade deletes, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the delete orphan timing to will ensure orphans are never deleted unless EF Core is explicitly instructed to do so.\n\nChanging the reference navigation of a one-to-many relationship has the same effect as changing the collection navigation on the other end of the relationship. Setting the reference navigation of dependent/child to null is equivalent to removing the entity from the collection navigation of the principal/parent. All fixup and database changes happen as described in the previous section, including making the entity an orphan if the relationship is required.\n\nFor one-to-one relationships, changing a reference navigation causes any previous relationship to be severed. For optional relationships, this means that the FK value on the previously related dependent/child is set to null. For example:\n\nThe debug view before calling SaveChanges shows that the new assets has replaced the existing assets, which is now marked as with a null FK value:\n\nThis results in an update and an insert when SaveChanges is called:\n\nRunning the same code as in the previous example, but this time with a required one-to-one relationship, shows that the previously associated is now marked as , since it becomes an orphan when the new takes its place:\n\nThis then results in a delete and an insert when SaveChanges is called:\n\nThe timing of marking orphans as deleted can be changed in the same way as shown for collection navigations and has the same effects.\n\nWhen an entity is marked as , for example by calling DbContext.Remove, then references to the deleted entity are removed from the navigations of other entities. For optional relationships, the FK values in dependent entities are set to null.\n\nFor example, let's mark the Visual Studio blog as :\n\nLooking at the change tracker debug view before calling SaveChanges shows:\n• The blog is marked as .\n• The assets related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n• Each post related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n\nThe fixup behavior for required relationships is the same as for optional relationships except that the dependent/child entities are marked as since they cannot exist without a principal/parent and must be removed from the database when SaveChanges is called to avoid a referential constraint exception. This is known as \"cascade delete\", and is the default behavior in EF Core for required relationships. For example, running the same code as in the previous example but with a required relationship results in the following debug view before SaveChanges is called:\n\nAs expected, the dependents/children are now marked as . However, notice that the navigations on the deleted entities have not changed. This may seem strange, but it avoids completely shredding a deleted graph of entities by clearing all navigations. That is, the blog, asset, and posts still form a graph of entities even after having been deleted. This makes it much easier to un-delete a graph of entities than was the case in EF6 where the graph was shredded.\n\nBy default, cascade delete happens as soon as the parent/principal is marked as . This is the same as for deleting orphans, as described previously. As with deleting orphans, this process can be delayed until SaveChanges is called, or even disabled entirely, by setting ChangeTracker.CascadeDeleteTiming appropriately. This is useful in the same way as it is for deleting orphans, including for re-parenting children/dependents after deletion of a principal/parent.\n\nCascade deletes, as well as deleting orphans, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the cascade delete timing to will ensure cascade deletes never happen unless EF Core is explicitly instructed to do so.\n\nMany-to-many relationships in EF Core are implemented using a join entity. Each side of the many-to-many relationship is related to this join entity with a one-to-many relationship. This join entity can be explicitly defined and mapped, or it can be created implicitly and hidden. In both cases the underlying behavior is the same. We will look at this underlying behavior first to understand how tracking of many-to-many relationships works.\n\nConsider this EF Core model that creates a many-to-many relationship between posts and tags using an explicitly defined join entity type:\n\nNotice that the join entity type contains two foreign key properties. In this model, for a post to be related to a tag, there must be a PostTag join entity where the foreign key value matches the primary key value, and where the foreign key value matches the primary key value. For example:\n\nLooking at the change tracker debug view after running this code shows that the post and tag are related by the new join entity:\n\nNotice that the collection navigations on and have been fixed up, as have the reference navigations on . These relationships can be manipulated by navigations instead of FK values, just as in all the preceding examples. For example, the code above can be modified to add the relationship by setting the reference navigations on the join entity:\n\nThis results in exactly the same change to FKs and navigations as in the previous example.\n\nManipulating the join table manually can be cumbersome. Many-to-many relationships can be manipulated directly using special collection navigations that \"skip over\" the join entity. For example, two skip navigations can be added to the model above; one from Post to Tags, and the other from Tag to Posts:\n\nThis many-to-many relationship requires the following configuration to ensure the skip navigations and normal navigations are all used for the same many-to-many relationship:\n\nSee Relationships for more information on mapping many-to-many relationships.\n\nSkip navigations look and behave like normal collection navigations. However, the way they work with foreign key values is different. Let's associate a post with a tag, but this time using a skip navigation:\n\nNotice that this code doesn't use the join entity. It instead just adds an entity to a navigation collection in the same way as would be done if this were a one-to-many relationship. The resulting debug view is essentially the same as before:\n\nNotice that an instance of the join entity was created automatically with FK values set to the PK values of the tag and post that are now associated. All the normal reference and collection navigations have been fixed up to match these FK values. Also, since this model contains skip navigations, these have also been fixed up. Specifically, even though we added the tag to the skip navigation, the inverse skip navigation on the other side of this relationship has also been fixed up to contain the associated post.\n\nIt is worth noting that the underlying many-to-many relationships can still be manipulated directly even when skip navigations have been layered on top. For example, the tag and Post could be associated as we did before introducing skip navigations:\n\nThis will still result in the skip navigations being fixed up correctly, resulting in the same debug view output as in the previous example.\n\nIn the previous section we added skip navigations in addition to fully defining the two underlying one-to-many relationships. This is useful to illustrate what happens to FK values, but is often unnecessary. Instead, the many-to-many relationship can be defined using only skip navigations. This is how the many-to-many relationship is defined in the model at the very top of this document. Using this model, we can again associate a Post and a Tag by adding a post to the skip navigation (or, alternately, adding a tag to the skip navigation):\n\nLooking at the debug view after making this change reveals that EF Core has created an instance of to represent the join entity. This join entity contains both and foreign key properties which have been set to match the PK values of the post and tag that are associated.\n\nSee Relationships for more information about implicit join entities and the use of entity types.\n\nSo far all the examples have used a join entity type (whether explicit or implicit) that contains only the two foreign key properties needed for the many-to-many relationship. Neither of these FK values need to be explicitly set by the application when manipulating relationships because their values come from the primary key properties of the related entities. This allows EF Core to create instances of the join entity without missing data.\n\nEF Core supports adding additional properties to the join entity type. This is known as giving the join entity a \"payload\". For example, let's add property to the join entity:\n\nThis payload property will not be set when EF Core creates a join entity instance. The most common way to deal with this is to use payload properties with automatically generated values. For example, the property can be configured to use a store-generated timestamp when each new entity is inserted:\n\nA post can now be tagged in the same way as before:\n\nLooking at the change tracker debug view after calling SaveChanges shows that the payload property has been set appropriately:\n\nFollowing on from the previous example, let's add a payload property that does not use an automatically generated value:\n\nA post can now be tagged in the same way as before, and the join entity will still be created automatically. This entity can then be accessed using one of the mechanisms described in Accessing Tracked Entities. For example, the code below uses DbSet<TEntity>.Find to access the join entity instance:\n\nOnce the join entity has been located it can be manipulated in the normal way--in this example, to set the payload property before calling SaveChanges.\n\nAlternately, the join entity can be created explicitly to associate a post with a tag. For example:\n\nFinally, another way to set payload data is by either overriding SaveChanges or using the DbContext.SavingChanges event to process entities before updating the database. For example:"
    },
    {
        "link": "https://stackoverflow.com/questions/51311008/entity-framework-core-assign-foreign-key-constraint-in-onmodelcreating",
        "document": "I'm trying to figure out how to programmatically generate my database using Entity Framework Core and I'm running into issues assigning a foreign key to a field in a table. I need the field Address to reference the Address object and load it when I go to retrieve a record from the database. If I create the database using , it creates the tables correctly except that the field AddressId is not a foreign key to the Address table. I have tried doing my research on this, and ran into this article, which uses a method called , however whatever is returning from Entity() doesn't know about . I get this error if I try manually typing it in I get:\n\nSo obviously that approach isn't valid. I tried following this documentation, but I don't really understand what it is doing and how to apply it to my situation. In their case they have a couple tables, blog and posts, where blog has many posts and post has a blog. I tried following along the best I could, but I don't really understand all the jargon and what it is accomplishing.\n\nHow can I go about simply assigning the value found in AddressId as a foreign key to a record in Addresses? This is the code I am using.\n• I am using the Microsoft.EntityFrameworkCore.SQLite & SQLite.Core libraries for my provider."
    },
    {
        "link": "https://stackoverflow.com/questions/11974022/entity-framework-maintaining-foreign-key-relationships",
        "document": "I have a Single Location Table that has multiple foreign key relationships in it. It has foreign keys to a state table, a city table, a country table, and a user table. Now I have the table model mapped properly in the Entity framework, but if I try to access the foreign key id field in the Location table to add a new foreign key mapping I cannot access it, instead I get a Reference field, such as StateReference.\n\nNow I have found some articles saying, just use the entitykey.StateReference. I tried it and it works but seems really clunky to me. What I have noticed though is it also supplies me with a field State instead of StateID. So, from that I am assuming that one would just be able to pass in the state name to the Location object and entity framework would figure the relationship out almost automatically. I am not able to locate or figure out the proper syntax for this anywhere.\n\nIf I am way off base here could someone please point in the right direction and correct me? I have been pounding at this for awhile and cannot seem to get it. Or if What I am saying is correct can someone give me some basic code to display the syntax. I am making a web service in VS2010 so I am using ef v1 if I understand correctly. Below is the Code for my Location Object."
    },
    {
        "link": "https://github.com/dotnet/EntityFramework.Docs/blob/main/entity-framework/core/modeling/relationships.md",
        "document": "This document provides a simple introduction to the representation of relationships in object models and relational databases, including how EF Core maps between the two.\n\nA relationship defines how two entities relate to each other. For example, when modeling posts in a blog, each post is related to the blog it is published on, and the blog is related to all the posts published on that blog.\n\nIn an object-oriented language like C#, the blog and post are typically represented by two classes: and . For example:\n\nIn the classes above, there is nothing to indicate that and are related. This can be added to the object model by adding a reference from to the on which it is published:\n\nLikewise, the opposite direction of the same relationship can be represented as a collection of objects on each :\n\nThis connection from to and, inversely, from back to is known as a \"relationship\" in EF Core.\n\nRelational databases represent relationships using foreign keys. For example, using SQL Server or Azure SQL, the following tables can be used to represent our and classes:\n\nIn this relational model, the and tables are each given a \"primary key\" column. The value of the primary key uniquely identifies each post or blog. In addition, the table is given a \"foreign key\" column. The primary key column is referenced by the foreign key column of the table. This column is \"constrained\" such that any value in the column of must match a value in the column of . This match determines which blog every post is related to. For example, if the value in one row of the table is 7, then the post represented by that row is published in the blog with the primary key 7.\n\nEF Core relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model.\n\nIn the most basic sense, this involves:\n• Associating the references between entity types with the primary and foreign keys to form a single relationship configuration.\n\nOnce this mapping is made, EF changes the foreign key values as needed when the references between objects change, and changes the references between objects as needed when the foreign key values change.\n\nFor example, the entity types shown above can be updated with primary and foreign key properties:\n\nThe primary key property of , , and the foreign key property of , , can then be associated with the references (\"navigations\") between the entity types ( and ). This is done automatically by EF when building a simple relationship like this, but can also be specified explicitly when overriding the method of your . For example:\n\nNow all these properties will behave coherently together as a representation of a single relationship between and .\n\nEF supports many different types of relationships, with many different ways these relationships can be represented and configured. To jump into examples for different kinds of relationships, see:\n• One-to-many relationships, in which a single entity is associated with any number of other entities.\n• One-to-one relationships, in which a single entity is associated with another single entity.\n• Many-to-many relationships, in which any number of entities are associated with any number of other entities.\n\nIf you are new to EF, then trying the examples linked in in the bullet points above is a good way to get a feel for how relationships work.\n\nTo dig deeper into the properties of entity types involved in relationship mapping, see:\n• Foreign and principal keys in relationships, which covers how foreign keys map to the database.\n• Relationship navigations, which describes how navigations are layered over a foreign key to provide an object-oriented view of the relationship.\n\nEF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. Most of the examples show the model building API. To find out more about other options, see:\n• Relationship conventions, which discover entity types, their properties, and the relationships between the types.\n• Relationship mapping attributes, which can be used an alternative to the model building API for some aspects of relationship configuration.\n• Cascade deletes, which describe how related entities can be automatically deleted when or is called.\n• Owned entity types use a special type of \"owning\" relationship that implies a stronger connection between the two types than the \"normal\" relationships discussed here. Many of the concepts described here for normal relationships are carried over to owned relationships. However, owned relationships also have their own special behaviors.\n\nRelationships defined in the model can be used in various ways. For example:\n• Relationships can be used to query related data in any of three ways:\n• Eagerly as part of a LINQ query, using .\n• Lazily using lazy-loading proxies, or lazy-loading without proxies.\n• Explicitly using the or methods.\n• Relationships can be used in data seeding through matching of PK values to FK values.\n• Relationships can be used to track graphs of entities. Relationships are then used by the change tracker to:\n• Detect changes in relationships and perform fixup\n• Send foreign key updates to the database with or"
    },
    {
        "link": "https://stackoverflow.com/questions/54206356/remove-foreign-key-added-by-convention-in-entity-framework-core",
        "document": "Reach devs & technologists worldwide about your product, service or employer brand"
    },
    {
        "link": "https://stackoverflow.com/questions/30351762/entity-framework-error-deleting-entity-with-foreign-key-relationship",
        "document": "I am having a problem deleting some entities due to a foreign key relationship. I understand the following error message and have been doing everything I can think of to delete the entities without incurring this error:\n\nHere is an image of the two tables in question:\n\nI am trying to delete QuizWithQuestion entities. I have made the idQuizQuestion column nullable. So, the foreign key is nullable on the QuizUserAnswer side. In the mapping files, I have specified that the relationship is optional:\n\nI have tried many, many snippets of code, so I will post the current state of the code in the hope that my intention is clear:\n\nAnother attempt looks like this:\n\nHow can I delete these darn entities (I'm so close to writing a stored procedure)?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/change-tracking/relationship-changes",
        "document": "Relationships in an Entity Framework Core (EF Core) model are represented using foreign keys (FKs). An FK consists of one or more properties on the dependent or child entity in the relationship. This dependent/child entity is associated with a given principal/parent entity when the values of the foreign key properties on the dependent/child match the values of the alternate or primary key (PK) properties on the principal/parent.\n\nForeign keys are a good way to store and manipulate relationships in the database, but are not very friendly when working with multiple related entities in application code. Therefore, most EF Core models also layer \"navigations\" over the FK representation. Navigations form C#/.NET references between entity instances that reflect the associations found by matching foreign key values to primary or alternate key values.\n\nNavigations can be used on both sides of the relationship, on one side only, or not at all, leaving only the FK property. The FK property can be hidden by making it a shadow property. See Relationships for more information on modelling relationships.\n\nThe following model contains four entity types with relationships between them. The comments in the code indicate which properties are foreign keys, primary keys, and navigations.\n\nThe three relationships in this model are:\n• Each blog can have many posts (one-to-many):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from a post to the associated blog. is the inverse navigation for .\n• is a collection navigation from a blog to all the associated posts. is the inverse navigation for .\n• Each blog can have one assets (one-to-one):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from the assets to the associated blog. is the inverse navigation for .\n• is a reference navigation from the blog to the associated assets. is the inverse navigation for .\n• Each post can have many tags and each tag can have many posts (many-to-many):\n• Many-to-many relationships are a further layer over two one-to-many relationships. Many-to-many relationships are covered later in this document.\n• is a collection navigation from a post to all the associated tags. is the inverse navigation for .\n• is a collection navigation from a tag to all the associated posts. is the inverse navigation for .\n\nSee Relationships for more information on how to model and configure relationships.\n\nEF Core keeps navigations in alignment with foreign key values and vice versa. That is, if a foreign key value changes such that it now refers to a different principal/parent entity, then the navigations are updated to reflect this change. Likewise, if a navigation is changed, then the foreign key values of the entities involved are updated to reflect this change. This is called \"relationship fixup\".\n\nFixup first occurs when entities are queried from the database. The database has only foreign key values, so when EF Core creates an entity instance from the database it uses the foreign key values to set reference navigations and add entities to collection navigations as appropriate. For example, consider a query for blogs and its associated posts and assets:\n\nFor each blog, EF Core will first create a instance. Then, as each post is loaded from the database its reference navigation is set to point to the associated blog. Likewise, the post is added to the collection navigation. The same thing happens with , except in this case both navigations are references. The navigation is set to point to the assets instance, and the navigation is set to point to the blog instance.\n\nLooking at the change tracker debug view after this query shows two blogs, each with one assets and two posts being tracked:\n\nThe debug view shows both key values and navigations. Navigations are shown using the primary key values of the related entities. For example, in the output above indicates that the collection navigation contains two related posts with primary keys 1 and 2 respectively. Similarly, for each post associated with the first blog, the line indicates that the navigation references the Blog with primary key 1.\n\nRelationship fixup also happens between entities returned from a tracking query and entities already tracked by the DbContext. For example, consider executing three separate queries for blogs, posts, and assets:\n\nLooking again at the debug views, after the first query only the two blogs are tracked:\n\nThe reference navigations are null, and the collection navigations are empty because no associated entities are currently being tracked by the context.\n\nAfter the second query, the reference navigations have been fixed up to point to the newly tracked instances. Likewise, the reference navigations are set to point to the appropriate already tracked instance.\n\nFinally, after the third query, the collection navigations now contain all related posts, and the references point to the appropriate instance:\n\nThis is the same end-state as was achieved with the original single query, since EF Core fixed up navigations as entities were tracked, even when coming from multiple different queries.\n\nThe easiest way to change the relationship between two entities is by manipulating a navigation, while leaving EF Core to fixup the inverse navigation and FK values appropriately. This can be done by:\n• Adding or removing an entity from a collection navigation.\n• Changing a reference navigation to point to a different entity, or setting it to null.\n\nFor example, let's move one of the posts from the Visual Studio blog to the .NET blog. This requires first loading the blogs and posts, and then moving the post from the navigation collection on one blog to the navigation collection on the other blog:\n\nThis is the debug view printed after running the code above:\n\nThe navigation on the .NET Blog now has three posts ( ). Likewise, the navigation on the Visual Studio blog only has one post ( ). This is to be expected since the code explicitly changed these collections.\n\nMore interestingly, even though the code did not explicitly change the navigation, it has been fixed-up to point to the Visual Studio blog ( ). Also, the foreign key value has been updated to match the primary key value of the .NET blog. This change to the FK value in then persisted to the database when SaveChanges is called:\n\nIn the previous example, a post was moved from one blog to another by manipulating the collection navigation of posts on each blog. The same thing can be achieved by instead changing the reference navigation to point to the new blog. For example:\n\nThe debug view after this change is exactly the same as it was in the previous example. This is because EF Core detected the reference navigation change and then fixed up the collection navigations and FK value to match.\n\nIn the previous section, relationships were manipulated by navigations leaving foreign key values to be updated automatically. This is the recommended way to manipulate relationships in EF Core. However, it is also possible to manipulate FK values directly. For example, we can move a post from one blog to another by changing the foreign key value:\n\nNotice how this is very similar to changing the reference navigation, as shown in the previous example.\n\nThe debug view after this change is again exactly the same as was the case for the previous two examples. This is because EF Core detected the FK value change and then fixed up both the reference and collection navigations to match.\n\nEF Core performs the following actions when it detects that a new dependent/child entity has been added to a collection navigation:\n• If the entity is not tracked, then it is tracked. (The entity will usually be in the state. However, if the entity type is configured to use generated keys and the primary key value is set, then the entity is tracked in the state.)\n• If the entity is associated with a different principal/parent, then that relationship is severed.\n• The entity becomes associated with the principal/parent that owns the collection navigation.\n• Navigations and foreign key values are fixed up for all entities involved.\n\nBased on this we can see that to move a post from one blog to another we don't actually need to remove it from the old collection navigation before adding it to the new one. So the code from the example above can be changed from:\n\nEF Core sees that the post has been added to a new blog and automatically removes it from the collection on the first blog.\n\nRemoving a dependent/child entity from the collection navigation of the principal/parent causes severing of the relationship to that principal/parent. What happens next depends on whether the relationship is optional or required.\n\nBy default for optional relationships, the foreign key value is set to null. This means that the dependent/child is no longer associated with any principal/parent. For example, let's load a blog and posts and then remove one of the posts from the collection navigation:\n\nLooking at the change tracking debug view after this change shows that:\n• The FK has been set to null ( )\n• The reference navigation has been set to null ( )\n• The post has been removed from collection navigation ( )\n\nNotice that the post is not marked as . It is marked as so that the FK value in the database will be set to null when SaveChanges is called.\n\nSetting the FK value to null is not allowed (and is usually not possible) for required relationships. Therefore, severing a required relationship means that the dependent/child entity must be either re-parented to a new principal/parent, or removed from the database when SaveChanges is called to avoid a referential constraint violation. This is known as \"deleting orphans\", and is the default behavior in EF Core for required relationships.\n\nFor example, let's change the relationship between blog and posts to be required and then run the same code as in the previous example:\n\nLooking at the debug view after this change shows that:\n• The post has been marked as such that it will be deleted from the database when SaveChanges is called.\n• The reference navigation has been set to null ( ).\n• The post has been removed from collection navigation ( ).\n\nNotice that the remains unchanged since for a required relationship it cannot be set to null.\n\nCalling SaveChanges results in the orphaned post being deleted:\n\nBy default, marking orphans as happens as soon as the relationship change is detected. However, this process can be delayed until SaveChanges is actually called. This can be useful to avoid making orphans of entities that have been removed from one principal/parent, but will be re-parented with a new principal/parent before SaveChanges is called. ChangeTracker.DeleteOrphansTiming is used to set this timing. For example:\n\nAfter removing the post from the first collection the object is not marked as as it was in the previous example. Instead, EF Core is tracking that the relationship is severed even though this is a required relationship. (The FK value is considered null by EF Core even though it cannot really be null because the type is not nullable. This is known as a \"conceptual null\".)\n\nCalling SaveChanges at this time would result in the orphaned post being deleted. However, if as in the example above, post is associated with a new blog before SaveChanges is called, then it will be fixed up appropriately to that new blog and is no longer considered an orphan:\n\nSaveChanges called at this point will update the post in the database rather than deleting it.\n\nIt is also possible to turn off automatic deletion of orphans. This will result in an exception if SaveChanges is called while an orphan is being tracked. For example, this code:\n\nDeletion of orphans, as well as cascade deletes, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the delete orphan timing to will ensure orphans are never deleted unless EF Core is explicitly instructed to do so.\n\nChanging the reference navigation of a one-to-many relationship has the same effect as changing the collection navigation on the other end of the relationship. Setting the reference navigation of dependent/child to null is equivalent to removing the entity from the collection navigation of the principal/parent. All fixup and database changes happen as described in the previous section, including making the entity an orphan if the relationship is required.\n\nFor one-to-one relationships, changing a reference navigation causes any previous relationship to be severed. For optional relationships, this means that the FK value on the previously related dependent/child is set to null. For example:\n\nThe debug view before calling SaveChanges shows that the new assets has replaced the existing assets, which is now marked as with a null FK value:\n\nThis results in an update and an insert when SaveChanges is called:\n\nRunning the same code as in the previous example, but this time with a required one-to-one relationship, shows that the previously associated is now marked as , since it becomes an orphan when the new takes its place:\n\nThis then results in a delete and an insert when SaveChanges is called:\n\nThe timing of marking orphans as deleted can be changed in the same way as shown for collection navigations and has the same effects.\n\nWhen an entity is marked as , for example by calling DbContext.Remove, then references to the deleted entity are removed from the navigations of other entities. For optional relationships, the FK values in dependent entities are set to null.\n\nFor example, let's mark the Visual Studio blog as :\n\nLooking at the change tracker debug view before calling SaveChanges shows:\n• The blog is marked as .\n• The assets related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n• Each post related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n\nThe fixup behavior for required relationships is the same as for optional relationships except that the dependent/child entities are marked as since they cannot exist without a principal/parent and must be removed from the database when SaveChanges is called to avoid a referential constraint exception. This is known as \"cascade delete\", and is the default behavior in EF Core for required relationships. For example, running the same code as in the previous example but with a required relationship results in the following debug view before SaveChanges is called:\n\nAs expected, the dependents/children are now marked as . However, notice that the navigations on the deleted entities have not changed. This may seem strange, but it avoids completely shredding a deleted graph of entities by clearing all navigations. That is, the blog, asset, and posts still form a graph of entities even after having been deleted. This makes it much easier to un-delete a graph of entities than was the case in EF6 where the graph was shredded.\n\nBy default, cascade delete happens as soon as the parent/principal is marked as . This is the same as for deleting orphans, as described previously. As with deleting orphans, this process can be delayed until SaveChanges is called, or even disabled entirely, by setting ChangeTracker.CascadeDeleteTiming appropriately. This is useful in the same way as it is for deleting orphans, including for re-parenting children/dependents after deletion of a principal/parent.\n\nCascade deletes, as well as deleting orphans, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the cascade delete timing to will ensure cascade deletes never happen unless EF Core is explicitly instructed to do so.\n\nMany-to-many relationships in EF Core are implemented using a join entity. Each side of the many-to-many relationship is related to this join entity with a one-to-many relationship. This join entity can be explicitly defined and mapped, or it can be created implicitly and hidden. In both cases the underlying behavior is the same. We will look at this underlying behavior first to understand how tracking of many-to-many relationships works.\n\nConsider this EF Core model that creates a many-to-many relationship between posts and tags using an explicitly defined join entity type:\n\nNotice that the join entity type contains two foreign key properties. In this model, for a post to be related to a tag, there must be a PostTag join entity where the foreign key value matches the primary key value, and where the foreign key value matches the primary key value. For example:\n\nLooking at the change tracker debug view after running this code shows that the post and tag are related by the new join entity:\n\nNotice that the collection navigations on and have been fixed up, as have the reference navigations on . These relationships can be manipulated by navigations instead of FK values, just as in all the preceding examples. For example, the code above can be modified to add the relationship by setting the reference navigations on the join entity:\n\nThis results in exactly the same change to FKs and navigations as in the previous example.\n\nManipulating the join table manually can be cumbersome. Many-to-many relationships can be manipulated directly using special collection navigations that \"skip over\" the join entity. For example, two skip navigations can be added to the model above; one from Post to Tags, and the other from Tag to Posts:\n\nThis many-to-many relationship requires the following configuration to ensure the skip navigations and normal navigations are all used for the same many-to-many relationship:\n\nSee Relationships for more information on mapping many-to-many relationships.\n\nSkip navigations look and behave like normal collection navigations. However, the way they work with foreign key values is different. Let's associate a post with a tag, but this time using a skip navigation:\n\nNotice that this code doesn't use the join entity. It instead just adds an entity to a navigation collection in the same way as would be done if this were a one-to-many relationship. The resulting debug view is essentially the same as before:\n\nNotice that an instance of the join entity was created automatically with FK values set to the PK values of the tag and post that are now associated. All the normal reference and collection navigations have been fixed up to match these FK values. Also, since this model contains skip navigations, these have also been fixed up. Specifically, even though we added the tag to the skip navigation, the inverse skip navigation on the other side of this relationship has also been fixed up to contain the associated post.\n\nIt is worth noting that the underlying many-to-many relationships can still be manipulated directly even when skip navigations have been layered on top. For example, the tag and Post could be associated as we did before introducing skip navigations:\n\nThis will still result in the skip navigations being fixed up correctly, resulting in the same debug view output as in the previous example.\n\nIn the previous section we added skip navigations in addition to fully defining the two underlying one-to-many relationships. This is useful to illustrate what happens to FK values, but is often unnecessary. Instead, the many-to-many relationship can be defined using only skip navigations. This is how the many-to-many relationship is defined in the model at the very top of this document. Using this model, we can again associate a Post and a Tag by adding a post to the skip navigation (or, alternately, adding a tag to the skip navigation):\n\nLooking at the debug view after making this change reveals that EF Core has created an instance of to represent the join entity. This join entity contains both and foreign key properties which have been set to match the PK values of the post and tag that are associated.\n\nSee Relationships for more information about implicit join entities and the use of entity types.\n\nSo far all the examples have used a join entity type (whether explicit or implicit) that contains only the two foreign key properties needed for the many-to-many relationship. Neither of these FK values need to be explicitly set by the application when manipulating relationships because their values come from the primary key properties of the related entities. This allows EF Core to create instances of the join entity without missing data.\n\nEF Core supports adding additional properties to the join entity type. This is known as giving the join entity a \"payload\". For example, let's add property to the join entity:\n\nThis payload property will not be set when EF Core creates a join entity instance. The most common way to deal with this is to use payload properties with automatically generated values. For example, the property can be configured to use a store-generated timestamp when each new entity is inserted:\n\nA post can now be tagged in the same way as before:\n\nLooking at the change tracker debug view after calling SaveChanges shows that the payload property has been set appropriately:\n\nFollowing on from the previous example, let's add a payload property that does not use an automatically generated value:\n\nA post can now be tagged in the same way as before, and the join entity will still be created automatically. This entity can then be accessed using one of the mechanisms described in Accessing Tracked Entities. For example, the code below uses DbSet<TEntity>.Find to access the join entity instance:\n\nOnce the join entity has been located it can be manipulated in the normal way--in this example, to set the payload property before calling SaveChanges.\n\nAlternately, the join entity can be created explicitly to associate a post with a tag. For example:\n\nFinally, another way to set payload data is by either overriding SaveChanges or using the DbContext.SavingChanges event to process entities before updating the database. For example:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/saving/cascade-delete",
        "document": "Entity Framework Core (EF Core) represents relationships using foreign keys. An entity with a foreign key is the child or dependent entity in the relationship. This entity's foreign key value must match the primary key value (or an alternate key value) of the related principal/parent entity.\n\nIf the principal/parent entity is deleted, then the foreign key values of the dependents/children will no longer match the primary or alternate key of any principal/parent. This is an invalid state, and will cause a referential constraint violation in most databases.\n\nThere are two options to avoid this referential constraint violation:\n\nThe first option is only valid for optional relationships where the foreign key property (and the database column to which it is mapped) must be nullable.\n\nThe second option is valid for any kind of relationship and is known as \"cascade delete\".\n\nCascading deletes are needed when a dependent/child entity can no longer be associated with its current principal/parent. This can happen because the principal/parent is deleted, or it can happen when the principal/parent still exists but the dependent/child is no longer associated with it.\n\nConsider this simple model where is the principal/parent in a relationship with , which is the dependent/child. is a foreign key property, the value of which must match the primary key of the blog to which the post belongs.\n\nBy convention, this relationship is configured as a required, since the foreign key property is non-nullable. Required relationships are configured to use cascade deletes by default. See Relationships for more information on modeling relationships.\n\nWhen deleting a blog, all posts are cascade deleted. For example:\n\nSaveChanges generates the following SQL, using SQL Server as an example:\n\nRather than deleting the blog, we could instead sever the relationship between each post and its blog. This can be done by setting the reference navigation to null for each post:\n\nThe relationship can also be severed by removing each post from the collection navigation:\n\nIn either case the result is the same: the blog is not deleted, but the posts that are no longer associated with any blog are deleted:\n\nDeleting entities that are no longer associated with any principal/dependent is known as \"deleting orphans\".\n\nCascading behaviors can be applied to:\n• Entities in the database that have not been loaded into the context\n\nEF Core always applies configured cascading behaviors to tracked entities. This means that if the application loads all relevant dependent/child entities into the DbContext, as is shown in the examples above, then cascading behaviors will be correctly applied regardless of how the database is configured.\n\nMany database systems also offer cascading behaviors that are triggered when an entity is deleted in the database. EF Core configures these behaviors based on the cascade delete behavior in the EF Core model when a database is created using EnsureCreated or EF Core migrations. For example, using the model above, the following table is created for posts when using SQL Server:\n\nNotice that the foreign key constraint defining the relationship between blogs and posts is configured with .\n\nIf we know that the database is configured like this, then we can delete a blog without first loading posts and the database will take care of deleting all the posts that were related to that blog. For example:\n\nNotice that there is no for posts, so they are not loaded. SaveChanges in this case will delete just the blog, since that's the only entity being tracked:\n\nThis would result in an exception if the foreign key constraint in the database is not configured for cascade deletes. However, in this case the posts are deleted by the database because it has been configured with when it was created.\n\nSome databases, most notably SQL Server, have limitations on the cascade behaviors that form cycles. For example, consider the following model:\n\nThis model has three relationships, all required and therefore configured to cascade delete by convention:\n• Deleting a blog will cascade delete all the related posts\n• Deleting the author of posts will cause the authored posts to be cascade deleted\n• Deleting the owner of a blog will cause the blog to be cascade deleted\n\nThis is all reasonable (if a bit draconian in blog management policies!) but attempting to create a SQL Server database with these cascades configured results in the following exception:\n\nThere are two ways to handle this situation:\n• Change one or more of the relationships to not cascade delete.\n• Configure the database without one or more of these cascade deletes, then ensure all dependent entities are loaded so that EF Core can perform the cascading behavior.\n\nTaking the first approach with our example, we could make the post-blog relationship optional by giving it a nullable foreign key property:\n\nAn optional relationship allows the post to exist without a blog, which means cascade delete will no longer be configured by default. This means there is no longer a cycle in cascading actions, and the database can be created without error on SQL Server.\n\nTaking the second approach instead, we can keep the blog-owner relationship required and configured for cascade delete, but make this configuration only apply to tracked entities, not the database:\n\nNow what happens if we load both a person and the blog they own, then delete the person?\n\nEF Core will cascade the delete of the owner so that the blog is also deleted:\n\nHowever, if the blog is not loaded when the owner is deleted:\n\nThen an exception will be thrown due to violation of the foreign key constraint in the database:\n\nOptional relationships have nullable foreign key properties mapped to nullable database columns. This means that the foreign key value can be set to null when the current principal/parent is deleted or is severed from the dependent/child.\n\nLet's look again at the examples from When cascading behaviors happen, but this time with an optional relationship represented by a nullable foreign key property:\n\nThis foreign key property will be set to null for each post when its related blog is deleted. For example, this code, which is the same as before:\n\nWill now result in the following database updates when SaveChanges is called:\n\nLikewise, if the relationship is severed using either of the examples from above:\n\nThen the posts are updated with null foreign key values when SaveChanges is called:\n\nSee Changing Foreign Keys and Navigations for more information on how EF Core manages foreign keys and navigations as their values are changed.\n\nDatabases can also be configured to cascade nulls like this when a principal/parent in an optional relationship is deleted. However, this is much less common than using cascading deletes in the database. Using cascading deletes and cascading nulls in the database at the same time will almost always result in relationship cycles when using SQL Server. See the next section for more information on configuring cascading nulls.\n\nCascade behaviors are configured per relationship using the OnDelete method in OnModelCreating. For example:\n\nSee Relationships for more information on configuring relationships between entity types.\n\naccepts a value from the, admittedly confusing, DeleteBehavior enum. This enum defines both the behavior of EF Core on tracked entities, and the configuration of cascade delete in the database when EF is used to create the schema.\n\nThe following table shows the result of each value on the foreign key constraint created by EF Core migrations or EnsureCreated.\n\nThe behaviors of (the database default) and in relational databases are typically either identical or very similar. Despite what may imply, both of these options cause referential constraints to be enforced. The difference, when there is one, is when the database checks the constraints. Check your database documentation for the specific differences between and on your database system.\n\nSQL Server doesn't support , so is used instead.\n\nThe only values that will cause cascading behaviors on the database are and . All other values will configure the database to not cascade any changes.\n\nThe tables in the following sections cover what happens to dependent/child entities when the principal/parent is deleted, or its relationship to the dependent/child entities is severed. Each table covers one of:\n• When dependents/children are loaded and tracked by the DbContext and when they exist only in the database\n• The default for required relationships like this is .\n• Using anything other than cascade delete for required relationships will result in an exception when SaveChanges is called.\n• Typically, this is an from EF Core since the invalid state is detected in the loaded children/dependents.\n• forces EF Core to not check fixup dependents before sending them to the database, so in this case the database throws an exception, which is then wrapped in a by SaveChanges.\n• is rejected when creating the database since the foreign key column is not nullable.\n• Since dependents/children are loaded, they are always deleted by EF Core, and never left for the database to delete.\n• Severing a relationship is not valid here since the dependents/children are not loaded.\n• The default for required relationships like this is .\n• Using anything other than cascade delete for required relationships will result in an exception when SaveChanges is called.\n• Typically, this is a because the dependents/children are not loaded, and hence the invalid state can only be detected by the database. SaveChanges then wraps the database exception in a .\n• is rejected when creating the database since the foreign key column is not nullable.\n• The default for optional relationships like this is .\n• Dependents/children are never deleted unless or are configured.\n• All other values cause the dependent FKs to be set to null by EF Core...\n• ...except which tells EF Core not to touch the foreign keys of dependents/children when the principal/parent is deleted. The database therefore throws an exception, which is wrapped as a by SaveChanges.\n• Severing a relationship is not valid here since the dependents/children are not loaded.\n• The default for optional relationships like this is .\n• Dependents/children must be loaded to avoid a database exception unless the database has been configured to cascade either deletes or nulls."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/391117/deleting-each-row-and-re-adding-when-saving-to-database",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]