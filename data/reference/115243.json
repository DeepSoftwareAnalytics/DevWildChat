[
    {
        "link": "https://stackoverflow.com/questions/53932195/android-studio-3-2-1-artifactresolveexception-could-not-resolve-all-artifacts-f",
        "document": "After I update Android Studio to 3.2.1 and gradle version in my project I am getting following build error.\n\nI have already checked lots of questions related this question but no luck.\n\nI just followed @CoolMind answer it solve the gradle issue, but there is another issue comes which is This\n\nAnd I followed those answers which is given in this question but not solve my problem"
    },
    {
        "link": "https://stackoverflow.com/questions/61986128/gradle-threw-an-error-while-downloading-artifacts-from-the-network-exception",
        "document": "I just started with app development with flutter, but am not even able to run the test app. This is what come on console :\n\nI have active Internet connection. I also downloaded the gradle 6.4.1 and extracted it in android-studio >> plugins, This what is been shown on gradle-wrapper.properties :"
    },
    {
        "link": "https://developer.android.com/studio/known-issues",
        "document": "This page tracks known issues with Android Studio Meerkat and Android Gradle plugin 8.9.0. If you experience an issue not already included here, please report a bug.\n\nUpgrade to preview: Each release of Android Studio and the Android Gradle plugin aims to improve stability and performance, and add new features. To experience the benefits of upcoming releases now, download and install Android Studio Preview.\n\nThis section describes known issues that exist in the latest stable version of Android Studio.\n\nRun configuration without \"Before launch\" Gradle-aware Make leads to deployment error\n\nThere was an issue in Android Studio Ladybug Feature Drop Canary 9 that removed run configuration information from projects that were opened with that version. If you opened your project with that version at some point, and running your app results in the error \"loading build artifacts,\" verify that the active run configuration has the \"Gradle-aware Make\" step in the \"Before launch\" section. To verify this click Run/Debug Configurations > Edit Configurations, click the active run configuration and confirm that there is a \"Gradle-aware Make\" step in the \"Before launch\" section.\n\n'Apply Changes & Restart Activity' does not restart the activity on API level 35 devices or emulators\n\nWhen you deploy code changes to an API 35 device with 'Apply Changes & Restart Activity', the app won't be restarted and you won't see the effect of the changes. If you rerun the application you will see the effect of the code changes. Our team is actively investigating this.\n\nIf the Firebase Assistant Window (Tools > Firebase from the main menu) displays an error message, invalidate the caches and restart Android Studio to fix the error.\n\nThe ability to isolate a view using the embedded Layout Inspector is temporarily unavailable. We're working on fixing this issue in a future release.\n\nCompose nodes are not all inspectable using Layout Inspector\n\nIf you notice that not all Compose nodes are inspectable when you're using Layout Inspector, this is likely due to a bug that has been fixed in Compose version 1.5.0-alpha04. If you're experiencing this issue, make sure that you upgrade to Compose version 1.5.0-alpha04 or higher.\n\nStarting with Android Studio Chipmunk, if you're seeing or in the issues panel, make sure to include a dependency to in your module.\n\nIf you're seeing in the issues panel, make sure to include a dependency to in your module.\n\nIf you're seeing or in the issues panel, make sure to include a dependency to in your module.\n\nError when using different passwords for key and keystore\n\nStarting with version 4.2, Android Studio now runs on JDK 11. This update causes an underlying behavior change related to signing keys.\n\nWhen you navigate to Build > Generate Signed Bundle / APK and attempt to configure app signing for an app bundle or an APK, entering different passwords for the key and keystore may result in the following error:\n\nTo work around this issue, enter the same password for both the key and keystore.\n\nStudio tries to import previous .vmoptions and sanitize them to work with the garbage collector used by JDK 11. If that process fails, the IDE may not start for certain users who set custom VM options in the .vmoptions file.\n\nTo work around this issue, we recommend commenting out custom options in .vmoptions (using the “#” character). The .vmoptions file can be found in the following locations:\n\nIf Studio still doesn't start after trying this workaround, see Studio doesn't start after upgrade below.\n\nApps using the Database Inspector may crash when running on the Android 11 emulator, with an error like the following appearing in logcat:\n\nTo fix this issue, upgrade your Android 11 emulator to version 9 or higher by navigating to Tools > SDK Manager. In the SDK Platforms tab, check the box labeled Show Package Details and select revision 9 or higher of the Android 11 emulator.\n\nIf Studio doesn't start after an upgrade, the problem may be due to an invalid Android Studio configuration imported from a previous version of Android Studio or an incompatible plugin. As a workaround, try deleting (or renaming, for backup purposes) the directory below, depending on the Android Studio version and operating system, and start Android Studio again. This will reset Android Studio to its default state, with all third-party plugins removed.\n\nFor Android Studio 4.1 and later:\n\nNote that the configuration directory for Canary and Beta releases of Android Studio is instead of for the . For example, Android Studio 4.1 Canary builds use , instead of the directory that is used for Release Candidates and Stable releases.\n\nCompilation errors may arise in Kotlin MPP code due to missing symbols. Upgrading your Kotlin plugin to version 1.4 should resolve this issue.\n\nOn Linux, certain keyboard shortcuts conflict with default Linux keyboard shortcuts and those of popular window managers, such as KDE and GNOME. These conflicting keyboard shortcuts may not work as expected in Android Studio.\n\nMore information about this issue (including potential workarounds) can be found in IntelliJ's bug tracker.\n\nOn ChromeOS, text might appear much smaller than in previous releases. To work around this issue, do the following:\n• In the Settings window, navigate to Editor > Font.\n\nThis section describes known issues related to the code editor.\n\nThere are some known interactions between the iBus daemon on Linux and Android Studio. In some scenarios, the IDE stops responding to keyboard input or starts inputting random characters. This bug is triggered by some missing synchronization between iBus and XLib + AWT, and has already been reported upstream to JetBrains and iBus. There are three current workarounds for this issue:\n• Workaround 1: Force iBus into synchronous mode. Before starting Android Studio, run the following on the command line:\n• Workaround 2: Disable iBus input in Android Studio. To disable iBus input for Android Studio only, run the following on the command line: This workaround only disables input methods for Android Studio, not any other applications you may be running. Note that if you restart the daemon while Android Studio is running (for example, by running ), you effectively disable the input methods for all other applications and may also crash Android Studio's JVM with a segmentation fault.\n• Workaround 3: Double-check the shortcut bindings to make sure that the Next input shortcut is not set to Control+Space, since this is also the code completion shortcut in Android Studio. Ubuntu 14.04 (Trusty) makes Super+Space the default shortcut, but settings from previous versions may still be around. To check your shortcut bindings, run on the command line to open the IBus Preferences window. Under Keyboard Shortcuts, check the Next input method. If it is set to Control+Space, change it to Super+Space, or another shortcut of your choice.\n\nThis section describes known issues related to project configuration and Gradle sync.\n\nThe issue is that the Gradle daemon is trying to use IPv4 instead of IPv6.\n• Workaround 1: On Linux, put the following in your or :\n• Workaround 2: in Android Studio's vmoptions file, change the line to For more information, see the Networking IPv6 User Guide.\n\n\"peer not authenticated\" errors from Gradle sync or SDK Manager\n\nThe root cause of these errors is a missing certificate in . To resolve these errors, proceed as follows:\n• If you're behind a proxy, try to connect directly. If the direct connection works, then in order to connect via the proxy you may need to use to add the proxy server's certificate to the cacerts file.\n• Re-install a supported, unmodified JDK. There's a known issue affecting Ubuntu users, which results in an empty . To work around this issue, execute the following on the command line:\n\nThis section describes known issues related to deploying your app to a connected device.\n\n[Mac OS only] Incremental updates are not applied due to an issue with Gradle file watching on projects saved under\n\nGradle issue 18149 affects Android Gradle Plugin versions 7.0 and higher because they require Gradle version 7.0 and higher. Starting in Gradle 7.0, file watching is enabled by default. If you are working on Mac OS and your project is saved under , Gradle file watching will not properly track file changes. This will cause the Build System to not see any file changes and it will therefore not update the APK(s). The incremental deployment code will then do nothing because the local APK state is the same as on the device.\n\nTo work around this issue you should move your project's directory to your user directory, that is, under . The Build System will then be properly notified about file changes by Gradle file watching and incremental changes will be successfully applied.\n\nThe Android Emulator on macOS High Sierra (10.13) requires HAXM 6.2.1+ for best compatibility and stability with macOS. However, macOS 10.13 has a more involved process to install kernel extensions such as HAXM. You need to manually allow the kernel extension itself to be installed as follows:\n• First, attempt to install the latest version of HAXM from the SDK Manager.\n• In MacOS, go to System Preferences > Security and Privacy.\n• None If you see an alert that System software from developer \"Intel Corporation Apps\" was blocked from loading, click Allow:\n\nFor more information and workarounds, see this Apple webpage and issue 62395878.\n\nThis section describes known issues that are related to Apply Changes.\n\nNew app name not applied\n\nIf you rename your app and then try to apply that change, the updated name might not be reflected. To work around this issue, click Run to re-deploy your app and see your changes.\n\nIf you're using a device that runs Android 8.0 or 8.1, you might encounter \"VERIFICATION_ERROR\" messages when trying to apply certain types of changes (especially if you're using Kotlin). This message is caused by an issue with the Android Runtime that is fixed in Android 9.0 and higher. Although the issue causes Apply Changes to fail, you can still Run your app again to see your changes. However, we recommend that you upgrade the device to Android 9.0 or greater.\n\nThis section describes known issues related to debugging and testing your app.\n\nJUnit tests missing resources in classpath when run from Android Studio\n\nIf you have specific resource folders in your Java modules, then those resources won't be found when running tests from the IDE. Running tests using Gradle from the command line will work. Executing the Gradle task from the IDE will also work. See issue 64887 for more details.\n\nThis issue occurs because as of IntelliJ 13, which requires that you only have a single folder as the classpath. IntelliJ's builder copies all resources into that build folder, but Gradle doesn't copy over the resources.\n• Workaround 1: Run the Gradle task from the IDE rather than running a unit test.\n• Workaround 2: Update your build script to manually copy resources into the build folder. See comment #13 for more information.\n\nRunning JUnit tests may compile the code twice\n\nWhen creating a new project, the template JUnit configuration might be created with two \"Before launch\" steps: Make and Gradle-aware Make. This configuration is then propagated to all created JUnit run configurations.\n• To fix the issue for the current project, click Run > Edit Configurations and change the default JUnit configuration to only include the Gradle-aware Make step.\n• To fix the issue for all future projects, click File > Close Project. You should see the welcome screen. Then click Configure > Project Defaults > Run Configurations and change the JUnit configuration to only include the Gradle-aware Make step.\n\nNot all run configurations that are available when right-clicking a test method are valid. Specifically, the following configurations are not valid:\n• Gradle run configurations (which have a Gradle logo as the icon) don't work.\n• JUnit run configurations (which have an icon without the green Android) don't apply to instrumentation tests, which cannot be run on the local JVM.\n\nAndroid Studio also remembers the run configuration created in a given context (for example, right-clicking a specific class or method), and will not offer to run in a different configuration in the future. To fix this, clickand remove the incorrectly-created configurations.\n\nWhile your app is paused at a breakpoint in your native code, the Auto and Dual debuggers may not immediately recognize new Java breakpoints that you set. To avoid this issue, add Java breakpoints either before starting a debug session or while the app is paused on a Java breakpoint. For more information, see issue 229949.\n\nStepping out of the native debugger\n\nWhile using the Auto or Dual debugger to debug Java and native code, if you step into a native function from your Java code (for example, the debugger pauses execution at a line in your Java code that calls a native function and you click Step Into ) and you want to return to your Java code, click Resume Program (instead of Step Out or Step Over ). Your app process will still be paused, so click Resume Program in the -java tab to resume it. For more information, see issue 224385.\n\nWhile using the native debugger for the first time after upgrading to Android Studio 4.2 and higher, the native debugger may stop responding while loading libraries from the Android device. This issue is a sticky problem that continues to happen even if you stop and restart the debugger. To fix this problem, delete the LLDB cache at .\n\nThis error occurs on Linux-based platforms when starting the native debugger. It indicates that one of the libraries required by the native debugger is not installed on the local system. The name of the missing library may be already printed in the file. If not, you can use a terminal to navigate to the Android Studio installation directory and execute the command line to learn which libraries are missing. Typically, the missing library is as some recent Linux distributions have already upgraded to .\n\nThis section describes known issues with the Profilers.\n\nNative Memory Profiler: Profiling not available during app startup\n\nThe Native Memory Profiler is currently unavailable during app startup. This option will be available in an upcoming release.\n\nAs a workaround, you can use the Perfetto standalone command-line profiler to capture startup profiles.\n\nYou may experience \"Recording failed to stop\" errors in the Android Studio CPU Profiler when you select the Sample Java Methods or Trace Java Methods configurations. These are often timeout errors, especially if you see the following error message in the file:\n\nThe timeout errors tend to affect traced methods more than sampled methods and longer recordings more than shorter recordings. As a temporary workaround, it may be helpful to try shorter recordings to see if the error disappears.\n\nIf you experience timeout issues with the Profiler, please file a bug that includes the make/model of your device(s) and any relevant entries from and logcat.\n\nWhen using Platform Tools 29.0.3, native debugging and the Android Studio Profilers might not work properly, and you might see either \"AdbCommandRejectedException\" or \"Failed to connect port\" in the file when you select Help > Show Log. Upgrading the Platform Tools to 29.0.4 or higher fixes both issues.\n\nTo upgrade the Platform Tools, do the following:\n• Open the SDK Manager from Android Studio by clicking Tools > SDK Manager or click SDK Manager in the toolbar.\n• Click the checkbox next to Android SDK Platform-Tools so it shows a checkmark. A download icon should appear in the left column.\n\nUsing the CMake simple highlighter plugin prevents content from appearing in the Build Output window. The build runs and the Build Output tab appears, but there is no output printed (issue #204791544).\n\nInstalling a newer version of Android Studio before an older version might prevent the older version from launching. For example, if you first install the canary version of Android Studio, and then try to install and launch the stable version, the stable version might not launch. In cases like this, you must clear the cache to get the stable (older) version to launch. On macOS, to clear the cache delete the directory. On Windows, to clear the cache use Disk Cleanup.\n\nThe Espresso Test Recorder doesn't work with projects that include Compose. To create UI tests for projects that include Compose, see Testing your Compose layout.\n\nIf you're using a non-English keyboard layout, a default Logcat keyboard shortcut might conflict with the layout and prevent you from typing certain characters when editing text in Android Studio. To work around this issue, delete or re-map the conflicting Logcat keymap. To edit the Logcat keymaps in Android Studio, go to Android Studio > Settings > Keymap and search for in the list of keymaps. For more information, see issue #263475910.\n\nThis issue will be resolved by the removal of the Logcat shortcut in Android Studio Electric Eel Patch 1.\n\nKnown issues with the Android Gradle Plugin\n\nThis section describes known issues that exist in the latest stable version of the Android Gradle plugin.\n\nNot all dynamic-feature library dependencies are lint checked\n\nWhen running lint with from an app module, dynamic-feature library dependencies aren't checked unless they're also app dependencies (issue #191977888). As a workaround, the lint task can be run on those libraries.\n\nJAR signing (v1 scheme) does not support file names containing carriage return characters (issue #63885809).\n\nModifying variant outputs at build time might not work\n\nUsing the Variant API to manipulate variant outputs is broken with the new plugin. It still works for simple tasks, such as changing the APK name during build time, as shown below:\n\nHowever, more complicated tasks that involve accessing objects no longer work. That's because variant-specific tasks are no longer created during the configuration stage. This results in the plugin not knowing all of its outputs up front, but it also means faster configuration times.\n\nmanifestOutputFile is no longer available\n\nThe method is no longer available, and you get the following error when you call it:\n\nInstead of calling to get the manifest file for each variant, you can call to return the path of the directory that contains all generated manifests. You can then locate a manifest and apply your logic to it. The sample below dynamically changes the version code in the manifest:\n\nUsing AGP 7.3.0 with KAPT in Kotlin 1.7.x causes the AIDL source sets for specific build variants to be removed. You can still use the other AIDL source sets, including those of , build types, product flavors, and combinations of product flavors. If you need to use the variant-specific AIDL source sets, continue to use Kotlin 1.6.21.\n\nThis section describes known issues that have been fixed in a recent release. If you are experiencing any of these issues, you should update Android Studio to the latest stable or preview version.\n• Missing lint output: There is no lint text output printed to when the lint task is (issue #191897708). Fixed in AGP 7.1.0-alpha05.\n• Problems with unit testing an app project that uses the Hilt plugin: The unit test classpath contains the non-instrumented app classes, which means Hilt does not instrument the app classes to handle dependency injection when running unit tests (issue #213534628). Fixed in AGP 7.1.1.\n• Lint exceptions in Kotlin projects: Kotlin projects that set may encounter null pointer exceptions or errors (issue #158777858).\n• IDE freezes on macOS Big Sur: Android Studio 4.1 might freeze when you open a dialog.\n• Restart to apply memory settings from previous version of IDE: After updating Android Studio, you need to restart Android Studio to apply any memory settings migrated from an earlier version of the IDE.\n• Manifest class with custom permission strings is no longer generated by default: If you want to generate the class, set .\n• None APK installation error on LineageOS: Deploying your app to devices running certain versions of LineageOS or CyanogenMod might fail and throw an exception. On Android Studio 3.6 Beta 1 and higher, the IDE handles this exception by performing a full app install when you deploy your app to LineageOS or CyanogenMod devices, which might result in longer deploy times.\n• Broken XML code style: When editing XML code, the IDE applied an incorrect code style when you selected Code > Reformat Code from the menu bar.\n• None Out of memory errors when scanning C++-based projects: When Gradle scans a project that has C++ code in more than one location on the same drive, the scan includes all directories below the first common directory. Scanning a large number of directories and files may lead to out of memory errors. For more information on this issue, read the bug associated with the issue."
    },
    {
        "link": "https://docs.gradle.org/current/userguide/troubleshooting.html",
        "document": "If you followed the installation instructions, and aren’t able to execute your Gradle build, here are some tips that may help. If you installed Gradle outside of just invoking the Gradle Wrapper, you can check your Gradle installation by running in a terminal. You should see something like this: ❯ gradle --version ------------------------------------------------------------ Gradle {gradleVersion} ------------------------------------------------------------ Build time: 2024-06-17 18:10:00 UTC Revision: 6028379bb5a8512d0b2c1be6403543b79825ef08 Kotlin: 1.9.23 Groovy: 3.0.21 Ant: Apache Ant(TM) version 1.10.13 compiled on January 4 2023 Launcher JVM: 11.0.23 (Eclipse Adoptium 11.0.23+9) Daemon JVM: /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home (no JDK specified, using current Java home) OS: Mac OS X 14.5 aarch64 If not, here are some things you might see instead. If you get \"command not found: gradle\", you must ensure that Gradle is correctly added to your . JAVA_HOME is set to an invalid directory If you get an error like: ERROR: JAVA_HOME is set to an invalid directory Set the JAVA_HOME variable in your environment to match the location of your Java installation: You must ensure that a Java Development Kit version 8 or higher is properly installed, the environment variable is set, and Java is added to your . If you get \"permission denied\", that means that Gradle likely exists in the correct place, but it is not executable. You can fix this using on *nix-based systems. If works, but all of your builds fail with the same error, it is possible that one of your Gradle build configuration scripts is broken. You can verify the problem with Gradle scripts by running , which executes configuration scripts but no Gradle tasks. If the error persists, it means the build configuration is problematic. If not, the problem exists when executing one or more requested tasks (Gradle executes configuration scripts first, followed by build steps).\n\nCommon dependency resolution issues, such as resolving version conflicts, are covered in Troubleshooting Dependency Resolution. You can see a dependency tree and see which resolved dependency versions differed from what was requested by clicking the Dependencies view and using the search functionality, specifying the resolution reason. The actual build scan with filtering criteria is available for exploration.\n\nMany infrequent errors within IDEs can be solved by \"refreshing\" Gradle. See also more documentation on working with Gradle in IntelliJ IDEA and in Eclipse. This only works for Gradle projects linked to IntelliJ. From the main menu, go to > > . Then click on the Refresh icon. If you’re using Buildship for the Eclipse IDE, you can re-synchronize your Gradle build by opening the \"Gradle Tasks\" view and clicking the \"Refresh\" icon, or by executing the > command from the context menu while editing a Gradle script. If your Gradle build fails before running any tasks, you may be encountering network configuration problems. When Gradle is unable to communicate with the Gradle daemon process, the build will immediately fail with a message similar to this: $ gradle help Starting a Gradle Daemon, 1 stopped Daemon could not be reused, use --status for details FAILURE: Build failed with an exception. * What went wrong: A new daemon was started but could not be connected to: pid=DaemonInfo{pid=55913, address=[7fb34c82-1907-4c32-afda-888c9b6e2279 port:42751, addresses:[/127.0.0.1]], state=Busy, ... This can occur when network address translation (NAT) masquerade is used. When NAT masquerade is enabled, connections that should be considered local to the machine are masked to appear from external IP addresses. Gradle refuses to connect to any external IP address as a security precaution. The solution to this problem is to adjust your network configuration such that local connections are not modified to appear as from external addresses. You can monitor the detected network setup and the connection requests in the daemon log file ( ). 2021-08-12T12:01:50.755+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding IP addresses for network interface enp0s3 2021-08-12T12:01:50.759+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Is this a loopback interface? false 2021-08-12T12:01:50.769+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding remote address /fe80:0:0:0:85ba:3f3e:1b88:c0e1%enp0s3 2021-08-12T12:01:50.770+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding remote address /10.0.2.15 2021-08-12T12:01:50.770+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding IP addresses for network interface lo 2021-08-12T12:01:50.771+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Is this a loopback interface? true 2021-08-12T12:01:50.771+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding loopback address /0:0:0:0:0:0:0:1%lo 2021-08-12T12:01:50.771+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.InetAddresses] Adding loopback address /127.0.0.1 2021-08-12T12:01:50.775+0200 [DEBUG] [org.gradle.internal.remote.internal.inet.TcpIncomingConnector] Listening on [7fb34c82-1907-4c32-afda-888c9b6e2279 port:42751, addresses:[localhost/127.0.0.1]]. ... 2021-08-12T12:01:50.797+0200 [INFO] [org.gradle.launcher.daemon.server.DaemonRegistryUpdater] Advertising the daemon address to the clients: [7fb34c82-1907-4c32-afda-888c9b6e2279 port:42751, addresses:[localhost/127.0.0.1]] ... 2021-08-12T12:01:50.923+0200 [ERROR] [org.gradle.internal.remote.internal.inet.TcpIncomingConnector] Cannot accept connection from remote address /10.0.2.15."
    },
    {
        "link": "https://github.com/gradle/gradle/issues/16008",
        "document": "When build a small android project, I replaced the google maven repo with alibaba's mirror, which results in the error above. However, the URL reported in the exception actually has the wanted jar.\n\nMy is as follows:\n\nThe project is attached as well, but the android sdk and relevant environment variables have to be setup to run it."
    },
    {
        "link": "https://docs.gradle.org/current/userguide/declaring_repositories.html",
        "document": "Gradle needs to know where it can download the dependencies used in the project. For example, the dependency can be downloaded from the public Maven Central repository . Gradle will find and download the source code (as a ) from Maven Central and use it build the project. You can add any number of repositories for your dependencies by configuring the block in your file: Gradle can resolve dependencies from one or many repositories based on Maven, Ivy or flat directory formats. If a library is available from more than one of the listed repositories, Gradle will simply pick the first one.\n\nOrganizations building software may want to leverage public binary repositories to download and consume open source dependencies. Popular public repositories include Maven Central and the Google Android repository. Gradle provides built-in shorthand notations for these widely-used repositories: Under the covers Gradle resolves dependencies from the respective URL of the public repository defined by the shorthand notation. All shorthand notations are available via the RepositoryHandler API.\n\nMost enterprise projects establish a binary repository accessible only within their intranet. In-house repositories allow teams to publish internal binaries, manage users and security, and ensure uptime and availability. Specifying a custom URL is useful for declaring less popular but publicly-available repositories. Repositories with custom URLs can be specified as Maven or Ivy repositories by calling the corresponding methods available on the RepositoryHandler API:\n\nGradle supports a wide range of sources for dependencies, both in terms of format and in terms of connectivity. You may resolve dependencies from:\n• \n• a wide variety of remote protocols such as HTTPS, SFTP, AWS S3 and Google Cloud Storage based on the presence of artifacts."
    },
    {
        "link": "https://developer.android.com/build",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nThe Android build system compiles app resources and source code and packages them into APKs or Android App Bundles that you can test, deploy, sign, and distribute.\n\nIn Gradle build overview and Android build structure, we discussed build concepts and the structure of an Android app. Now it's time to configure the build.\n\nGradle and the Android Gradle plugin help you configure the following aspects of your build:\n\nWhether your source code is written in Java, Kotlin, or both, there are several places you must choose a JDK or Java language version for your build. See Java versions in Android builds for details.\n\nCreating custom build configurations requires you to make changes to one or more build configuration files. These plain-text files use a domain-specific language (DSL) to describe and manipulate the build logic using Kotlin script, which is a flavor of the Kotlin language. You can also use Groovy, which is a dynamic language for the Java Virtual Machine (JVM), to configure your builds.\n\nYou don't need to know Kotlin script or Groovy to start configuring your build because the Android Gradle plugin introduces most of the DSL elements you need. To learn more about the Android Gradle plugin DSL, read the DSL reference documentation. Kotlin script also relies on the underlying Gradle Kotlin DSL\n\nWhen starting a new project, Android Studio automatically creates some of these files for you and populates them based on sensible defaults. For an overview of the created files, see Android build structure.\n\nThe Gradle wrapper ( ) is a small application included with your source code that downloads and launches Gradle itself. This creates more-consistent build execution. Developers download the application source and run . This downloads the required Gradle distribution, and launches Gradle to build your application.\n\nThe file contains a property, , that describes which version of Gradle is used to run your build.\n\nThe file (for the Kotlin DSL) or file (for the Groovy DSL) is located in the root project directory. This settings file defines project-level repository settings and informs Gradle which modules it should include when building your app. Multi-module projects need to specify each module that should go into the final build.\n\nFor most projects, the file looks like the following by default:\n\nThe top-level file (for the Kotlin DSL) or file (for the Groovy DSL) is located in the root project directory. It typically defines the common versions of plugins used by modules in your project.\n\nThe following code sample describes the default settings and DSL elements in the top-level build script after creating a new project:\n\nThe module-level (for the Kotlin DSL) or file (for the Groovy DSL) is located in each directory. It lets you configure build settings for the specific module it is located in. Configuring these build settings lets you provide custom packaging options, such as additional build types and product flavors, and override settings in the app manifest or top-level build script.\n\nThe module-level build file for your application includes settings that indicate Android SDK versions used when compiling, selecting platform behaviors, and specifying the minimum version that your application runs on.\n\nThe determines which Android and Java APIs are available when compiling your source code. To use the latest Android features, use the latest Android SDK when compiling. Some Android platform APIs might not be available in older API levels. You can conditionally guard use of newer features or use AndroidX compatibility libraries to use newer features with lower Android API levels. Each Android SDK provides a subset of Java APIs for use in your application. The table at Which Java APIs can I use in my Java or Kotlin source code shows which Java API level is available based on the Android SDK version. The newer Java APIs are supported on earlier versions of Android through desugaring, which must be enabled in your build. Android Studio displays warnings if your conflicts with the current version of Android Studio, AGP, or your project's library dependency requirements. The specifies the lowest version of Android that you want your app to support. Setting restricts which devices can install your app. Supporting lower versions of Android might require more conditional checks in your code or more use of AndroidX compatibility libraries. You should weigh the maintenance cost of supporting lower versions against the percentage of users that are still using those lower versions. See the version chart in the New project wizard of Android Studio for the current version-use percentages. When editing your code in Android Studio or running checks during your build, lint will warn about APIs that you use that are not available in the . You should fix these by making newer features conditional or by using for backward compatibility.\n• It sets runtime behavior of your application.\n• It attests which version of Android you've tested against. If you run on a device that's using a higher version of Android than your , Android runs your app in a compatibility mode that behaves similarly to the lower version indicated in your . For example, when API 23 introduced the runtime permissions model, not all apps were ready to immediately adopt it. By setting to 22, those apps could run on API 23 devices without using runtime permissions, and could use features included in the latest version. Google Play distribution policy enforces additional policies on target API level. The value of must be less than or equal to that of .\n\nThis sample Android app module build script outlines some of the basic DSL elements and settings:\n\n* The first section in the build configuration applies the Android Gradle plugin * to this build and makes the android block available to specify * Locate (and possibly download) a JDK used to build your kotlin * source code. This also acts as a default for sourceCompatibility, * targetCompatibility and jvmTarget. Note that this does not affect which JDK * is used to run the Gradle build itself, and does not need to take into * account the JDK version required by Gradle plugins (such as the * The android block is where you configure all your Android-specific * The app's namespace . Used primarily to access app resources. * compileSdk specifies the Android API level Gradle should use to * compile your app. This means your app can use the API features included in * The defaultConfig block encapsulates default settings and entries for all * build variants and can override some attributes in main/AndroidManifest.xml * dynamically from the build system. You can configure product flavors to override * these values for different versions of your app. // Defines the minimum API level required to run the app. // Specifies the API level used to test the app. // Defines the version number of your app. // Defines a user-friendly version name for your app. * The buildTypes block is where you can configure multiple build types * By default, the build system defines two build types: debug and release. The * debug build type is not explicitly shown in the default build configuration, * but it includes debugging tools and is signed with the debug key. The release * build type applies ProGuard settings and is not signed by default. * By default, Android Studio configures the release build type to enable code * shrinking, using minifyEnabled, and specifies the default ProGuard rules file. * The productFlavors block is where you can configure multiple product flavors * This lets you create different versions of your app that can * override the defaultConfig block with their own settings. Product flavors * are optional, and the build system does not create them by default. * This example creates a free and paid product flavor. Each product flavor * then specifies its own application ID, so that they can exist on the Google * If you declare product flavors, you must also declare flavor dimensions * and assign each flavor to a flavor dimension. * To override source and target compatibility (if different from the * toolchain JDK version), add the following. All of these * default to the same value as kotlin.jvmToolchain. If you're using the * same version for these values and kotlin.jvmToolchain, you can * The dependencies block in the module-level build configuration file * specifies dependencies required to build only the module itself. * To learn more, go to Add build dependencies * The first line in the build configuration applies the Android Gradle plugin * to this build and makes the android block available to specify * Locate (and possibly download) a JDK used to build your kotlin * source code. This also acts as a default for sourceCompatibility, * targetCompatibility and jvmTarget. Note that this does not affect which JDK * is used to run the Gradle build itself, and does not need to take into * account the JDK version required by Gradle plugins (such as the * The android block is where you configure all your Android-specific * The app's namespace . Used primarily to access app resources. * compileSdk specifies the Android API level Gradle should use to * compile your app. This means your app can use the API features included in * The defaultConfig block encapsulates default settings and entries for all * build variants and can override some attributes in main/AndroidManifest.xml * dynamically from the build system. You can configure product flavors to override * these values for different versions of your app. // Defines the minimum API level required to run the app. // Specifies the API level used to test the app. // Defines the version number of your app. // Defines a user-friendly version name for your app. * The buildTypes block is where you can configure multiple build types * By default, the build system defines two build types: debug and release. The * debug build type is not explicitly shown in the default build configuration, * but it includes debugging tools and is signed with the debug key. The release * build type applies ProGuard settings and is not signed by default. * By default, Android Studio configures the release build type to enable code * shrinking, using minifyEnabled, and specifies the default ProGuard rules file. * The productFlavors block is where you can configure multiple product flavors * This lets you create different versions of your app that can * override the defaultConfig block with their own settings. Product flavors * are optional, and the build system does not create them by default. * This example creates a free and paid product flavor. Each product flavor * then specifies its own application ID, so that they can exist on the Google * If you declare product flavors, you must also declare flavor dimensions * and assign each flavor to a flavor dimension. * To override source and target compatibility (if different from the * tool chain JDK version), add the following. All of these * default to the same value as kotlin.jvmToolchain. If you're using the * same version for these values and kotlin.jvmToolchain, you can * The dependencies block in the module-level build configuration file * specifies dependencies required to build only the module itself. * To learn more, go to Add build dependencies\n\nGradle also includes two properties files, located in your root project directory, that you can use to specify settings for the Gradle build toolkit itself:\n\nRemap the NDK to a shorter path (Windows only)\n\nIn Windows, tools in the installed NDK folder, such as , end up with long paths. The tools don't support long paths well.\n\nTo create a shorter path, in , set the property to request that the Android Gradle plugin create a symlink to the NDK. The path of that symlink can be shorter than the existing NDK folder. For example, results in the following symlink:\n\nWhen you make changes to the build configuration files in your project, Android Studio requires that you sync your project files so that it can import your build configuration changes and run some checks to make sure your configuration doesn't create build errors.\n\nTo sync your project files, click Sync Now in the notification bar that appears when you make a change, as shown in figure 2, or click Sync Project from the menu bar. If Android Studio finds any errors with your configuration — for example, your source code uses API features that are only available in an API level higher than your — the Messages window describes the issue.\n\nAndroid Studio logically groups source code and resources for each module into source sets. When you create a new module, Android Studio creates a source set within the module. A module's source set includes the code and resources used by all its build variants.\n\nAdditional source set directories are optional, and Android Studio doesn't automatically create them for you when you configure new build variants. However, creating source sets, similar to , helps organize files and resources that Gradle should only use when building certain versions of your app:\n\nFor example, to generate the \"fullDebug\" version of your app, the build system merges code, settings, and resources from following source sets:\n\nNote: When you create a new file or directory in Android Studio, use the File > New menu options to create it for a specific source set. The source sets you can choose from are based on your build configurations, and Android Studio automatically creates the required directories if they don't already exist.\n\nIf different source sets contain different versions of the same file, Gradle uses the following priority order when deciding which file to use. Source sets on the left override the files and settings of source sets to the right:\n\nThis allows Gradle to use files that are specific to the build variant you are trying to build while reusing activities, application logic, and resources that are common to other versions of your app.\n\nWhen merging multiple manifests, Gradle uses the same priority order so each build variant can define different components or permissions in the final manifest. To learn more about creating custom source sets, read Create source sets.\n\nIf your build contains multiple modules with common dependencies, or you have multiple independent projects with common dependencies, we recommend that you use a version catalog or bill of materials (BOM) to specify the common versions.\n\nBuilding Android apps with Bazel is possible but not officially supported. Android Studio does not officially support Bazel projects.\n\nTo better understand the current limitations of building with Bazel, see the known issues."
    },
    {
        "link": "https://developer.android.com/build/gradle-build-overview",
        "document": "Android applications are typically built using the Gradle build system. Before we dive into the details of how to configure your build, we'll explore the concepts behind the build so you can see the system as a whole.\n\nA build system transforms your source code into an executable application. Builds often involve multiple tools, to analyze, compile, link, and package your application or library. Gradle uses a task-based approach to organize and run these commands.\n\nTasks encapsulate commands that translate their inputs into outputs. Plugins define tasks and their configuration. Applying a plugin to your build registers its tasks, and wires them together using their inputs and outputs. For example, applying the Android Gradle Plugin (AGP) to your build file will register all the tasks necessary to build an APK, or an Android Library. The plugin lets you build a jar from Java source code. Similar plugins exist for Kotlin, and other languages, but other plugins are meant to extend plugins. For example, the plugin is meant to add protobuf support to existing plugins like AGP or .\n\nGradle prefers convention over configuration so plugins will come with good default values out of the box, but you can further configure the build through a declarative Domain-Specific Language (DSL). The DSL is designed so you can specify what to build, rather than how to build it. The logic in the plugins manages the \"how\". That configuration is specified across several build files in your project (and subprojects).\n\nTask inputs can be files and directories as well as other information encoded as Java types (integer, strings, or custom classes). Outputs can only be directory or files as they have to be written on disk. Wiring a task output into another task input, links the tasks together so that one has to run before the other.\n\nWhile Gradle supports writing arbitrary code and task declarations in your build files, this can make it more difficult for tooling to understand your build and for you to maintain. For example, you can write tests for code inside plugins but not in build files. Instead, you should restrict build logic and task declarations to plugins (that you or someone else define) and declare how you want to use that logic in your build files.\n\nWhat happens when a Gradle build runs?\n\nGradle builds run in three phases. Each of these phases executes different parts of code that you define in your build files.\n• Initialization determines which projects and subprojects are included in the build, and sets up classpaths containing your build files and applied plugins. This phase focuses on a settings file where you declare projects to build and the locations from which to fetch plugins and libraries.\n• Configuration registers tasks for each project, and executes the build file to apply the user's build specification. It's important to understand that your configuration code won't have access to data or files produced during execution.\n• Execution performs the actual \"building\" of your application. The output of configuration is a Directed Acyclic Graph (DAG) of tasks, representing all required build steps that were requested by the user (the tasks provided on the command line or as defaults in the build files). This graph represents the relationship between tasks, either explicit in a task's declaration, or based on its inputs and outputs. If a task has an input that is the output of another task, then it must run after the other task. This phase runs out-of-date tasks in the order defined in the graph; if a task's inputs haven't changed since its last execution, Gradle will skip it.\n\nFor more information see the Gradle Build lifecycle.\n\nGradle uses a Domain-Specific Language (DSL) to configure builds. This declarative approach focuses on specifying your data rather than writing step-by-step (imperative) instructions. You can write your build files using Kotlin or Groovy, but we strongly recommend using Kotlin.\n\nDSLs attempt to make it easier for everyone, domain experts and programmers, to contribute to a project, defining a small language that represents data in a more natural way. Gradle plugins can extend the DSL to configure the data they need for their tasks.\n\nFor example, configuring the Android part of your build might look like:\n\nBehind the scenes, the DSL code is similar to:\n\nEach block in the DSL is represented by a function that takes a lambda to configure it, and a property with the same name to access it. This makes the code in your build files feel more like a data specification.\n\nThe Maven build system introduced a dependency specification, storage and management system. Libraries are stored in repositories (servers or directories), with metadata including their version and dependencies on other libraries. You specify which repositories to search, versions of the dependencies you want to use, and the build system downloads them during the build.\n\nMaven Artifacts are identified by group name (company, developer, etc), artifact name (the name of the library) and version of that artifact. This is typically represented as .\n\nThis approach significantly improves build management. You'll often hear such repositories called \"Maven repositories\", but it's all about the way the artifacts are packaged and published. These repositories and metadata have been reused in several build systems, including Gradle (and Gradle can publish to these repositories). Public repositories allow sharing for all to use, and company repositories keep internal dependencies in-house.\n\nYou can also modularize your project into subprojects (also known as \"modules\" in Android Studio), which can also be used as dependencies. Each subproject produces outputs (such as jars) that can be consumed by subprojects or your top-level project. This can improve build time by isolating which parts need to be rebuilt, as well as better separate responsibilities in the application.\n\nWe'll go into more detail on how to specify dependencies in Add build dependencies.\n\nWhen you create an Android application, you'll typically want to build multiple variants. Variants contain different code or are built with different options, and are composed of build types and product flavors.\n\nBuild types vary declared build options. By default, AGP sets up \"release\" and \"debug\" build types, but you can adjust them and add more (perhaps for staging or internal testing).\n\nA debug build doesn't minify or obfuscate your application, speeding up its build and preserving all symbols as is. It also marks the application as \"debuggable\", signing it with a generic debug key and enabling access to the installed application files on the device. This makes it possible to explore saved data in files and databases while running the application.\n\nA release build optimizes the application, signs it with your release key, and protects the installed application files.\n\nUsing product flavors, you can change the included source and dependency variants for the application. For example, you may want to create \"demo\" and \"full\" flavors for your application, or perhaps \"free\" and \"paid\" flavors. You write your common source in a \"main\" source set directory, and override or add source in a source set named after the flavor.\n\nAGP creates variants for each combination of build type and product flavor. If you don't define flavors, the variants are named after the build types. If you define both, the variant is named . For example, with build types and , and flavors and , AGP will create variants:\n\nNow that you've seen the build concepts, take a look at the Android build structure in your project."
    },
    {
        "link": "https://docs.gradle.org/current/userguide/declaring_repositories_basics.html",
        "document": "Gradle can resolve local or external dependencies from one or many repositories based on Maven, Ivy or flat directory formats. Repositories intended for use in a single project are declared in your file: To centralize repository declarations in your file, head over to Centralizing Repository Declarations.\n\nMost enterprise projects set up a binary repository available only within an intranet. In-house repositories enable teams to publish internal binaries, setup user management and security measures, and ensure uptime and availability. Specifying a custom URL is also helpful if you want to declare publicly-available repository that Gradle does not provide a shorthand for. Repositories with custom URLs can be specified as Maven or Ivy repositories by calling the corresponding methods available on the RepositoryHandler API: Gradle supports additional protocols beyond and , such as , , and for custom URLs. For full coverage, see the section on supported repository types. You can also define your own repository layout by using repositories, as they are very flexible in terms of how modules are organised in a repository:\n\nYou can define more than one repository for resolving dependencies. Declaring multiple repositories is helpful if some dependencies are only available in one repository but not the other. You can mix any type of repository described in the reference section. The order of repository declaration determines the order that Gradle will search for dependencies during resolution. If Gradle finds a dependency’s metadata in a particular repository, it will attempt to download all the artifacts for that module from the same repository. You can learn more about the inner workings of dependency downloads."
    },
    {
        "link": "https://stackoverflow.com/questions/62851237/configuring-repositories-for-all-projects-in-gradle",
        "document": "A multi-project build in Gradle may have multiple files, but only one file (usually in the root project directory). Your second files defines a second setup that only contains a single project. You can check this by running . Just delete the second file to solve your problem.\n\nUsually you can simply define the names of your sub-projects by naming the respective directories and then calling . The name of the may be defined inside , because the name of the directory is often not stored in version control systems like Git. Developers may check out the repository to different directories causing Gradle to use different names for the root project. If you want a subproject to have a different name than its containing directory, use with the desired name and then change the project directory via ."
    }
]