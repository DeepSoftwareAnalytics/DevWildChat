[
    {
        "link": "https://refactoring.guru/design-patterns/command/csharp/example",
        "document": "Usage examples: The Command pattern is pretty common in C# code. Most often it’s used as an alternative for callbacks to parameterizing UI elements with actions. It’s also used for queueing tasks, tracking operations history, etc.\n\nIdentification: The Command pattern is recognizable by behavioral methods in an abstract/interface type (sender) which invokes a method in an implementation of a different abstract/interface type (receiver) which has been encapsulated by the command implementation during its creation. Command classes are usually limited to specific actions.\n\nThis example illustrates the structure of the Command design pattern. It focuses on answering these questions:\n• What classes does it consist of?\n• What roles do these classes play?\n• In what way the elements of the pattern are related?"
    },
    {
        "link": "https://medium.com/@lexitrainerph/command-pattern-in-c-from-basics-to-advanced-29d954cafb92",
        "document": "The Command Pattern is a behavioral design pattern that turns a request into a stand-alone object containing information about the request. This decoupling allows users to parameterize objects with operations, delay the execution of an operation, or queue it, and support undoable operations. In this blog post, we’ll delve deep into the Command Pattern in C#, starting from the basics and moving to advanced use cases.\n\nThe Command Pattern encapsulates a request as an object, thereby allowing users to parameterize clients with different requests, queue requests, and support operations like undo/redo.\n• Command: Declares an interface for executing an operation.\n• ConcreteCommand: Defines a binding between a Receiver object and an action.\n• Invoker: Asks the command to carry out the request.\n• Receiver: Knows how to perform the operations associated with carrying out the request.\n\nLet’s start with a basic example: a remote control for a light.\n\nTo support undo and redo, the Command interface can be expanded with and methods.\n\nMacro commands are a sequence of commands that are executed in order. This is useful when you want to execute multiple commands with a single action.\n\nSometimes, you might need to pass parameters to commands. This can be achieved by modifying the method to accept parameters or by setting properties on the command object.\n\nCommands can be queued for later execution. This is useful in scenarios like thread pooling.\n\nThe Command Pattern is a versatile design pattern that provides a clean way to decouple the sender from the receiver. This decoupling is beneficial in scenarios where you need to parameterize objects with operations, delay the execution of operations, or support undoable operations. By understanding and implementing this pattern, you can write more modular, flexible, and maintainable code in C#."
    },
    {
        "link": "https://dofactory.com/net/command-design-pattern",
        "document": "A visualization of the classes and objects participating in this pattern.\n\nThe classes and objects participating in this pattern include:\n• Command ( )\n• declares an interface for executing an operation\n• ConcreteCommand ( )\n• defines a binding between a Receiver object and an action\n• implements Execute by invoking the corresponding operation(s) on Receiver\n• Invoker ( )\n• asks the command to carry out the request\n• Receiver ( )\n• knows how to perform the operations associated with carrying out the request.\n\nThis structural code demonstrates the Command pattern which stores requests as objects allowing clients to execute or playback the requests.\n\nThis real-world code demonstrates the Command pattern used in a simple calculator with unlimited number of undo's and redo's. Note that in C# the word 'operator' is a keyword. Prefixing it with '@' allows using it as an identifier.\n\nCurrent value = 100 (following + 100)\n\n Current value = 50 (following - 50)\n\n Current value = 500 (following * 10)\n\n Current value = 250 (following / 2)\n\n \n\n ---- Undo 4 levels\n\n Current value = 500 (following * 2)\n\n Current value = 50 (following / 10)\n\n Current value = 100 (following + 50)\n\n Current value = 0 (following - 100)\n\n \n\n ---- Redo 3 levels\n\n Current value = 100 (following + 100)\n\n Current value = 50 (following - 50)\n\n Current value = 500 (following * 10)\n\n\n\nThe .NET optimized code demonstrates the same code as above but uses more modern C# and .NET features.\n\n\n\n Here is an elegant C# Command solution.\n\nCurrent value = 100 (following + 100)\n\n Current value = 50 (following - 50)\n\n Current value = 500 (following * 10)\n\n Current value = 250 (following / 2)\n\n \n\n ---- Undo 4 levels\n\n Current value = 500 (following * 2)\n\n Current value = 50 (following / 10)\n\n Current value = 100 (following + 50)\n\n Current value = 0 (following - 100)\n\n \n\n ---- Redo 3 levels\n\n Current value = 100 (following + 100)\n\n Current value = 50 (following - 50)\n\n Current value = 500 (following * 10)"
    },
    {
        "link": "https://syncfusion.com/blogs/post/command-design-pattern-tutorial-with-csharp-examples",
        "document": "The command pattern is a behavioral design pattern. This pattern encapsulates a request as an object that contains all the information about the request, including requests for queues or logs, allowing for much more complex architectures. It even allows operations like undo and redo.\n\nIn this blog post, we’ll learn how to implement the command pattern in C# and we’ll see in which use cases it can be useful.\n\nThe command pattern is divided into five parts:\n• The Command declares an interface for the execution of an operation.\n• The ConcreteCommand defines a binding between a Receiver and an action.\n• The Client creates a ConcreteCommand object and sets a Receiver for the command.\n• The Invoker demands the command carry out its request.\n• The Receiver knows how to execute the operations associated with the action of the request.\n\nThe command pattern is part of the GoF’s formal list of design patterns. So, let’s look at the class diagram for the command pattern and try to understand it.\n\nLet’s see how to do a simple command pattern implementation by writing a small Dine & Chef application. The idea is a table order at a restaurant: the waiter takes an order, which is the customer’s command. For the kitchen staff, this order is then queued. The waiter informs the chef that there is a fresh order, and the chef has enough data to prepare the meal.\n\nLet’s first generate a class that represents an item being ordered to start building our application.\n\nFirst, we’ll create our command interface and then create three concrete commands: Insert, Remove, and Modify order.\n\nDineChefRestaurant is our receiver class, so let’s set it up.\n\nIn this case, our invoker is the DineChef class.\n\nWe are finally setting up a client to use the invoker.\n\nAs the receiver (the DineChefRestaurant class) processes the orders, the contents of the order are changed. Here’s the sample project output.\n\nThe command pattern is a very good way to decrease the coupling between sender and receiver. The command pattern will also be helpful for wizards, progress bars, GUI buttons, menu actions, and other transactional behaviors. To download all the code examples shown in this tutorial, click here.\n\nSyncfusion provides about 1,000 controls to ease the work of developers in various platforms. You can make use of them in your application development in these platforms:\n\nIf you have any questions, please let us know in the comments section below. You can also contact us through our support forum, Direct-Trac, or Feedback Portal. We are always happy to assist you!"
    },
    {
        "link": "https://codeproject.com/Articles/5377622/Command-Pattern-in-Csharp-What-You-Need-to-Impleme",
        "document": "Learn what the Command Pattern in C# is and the design principles it follows. Understand the pros and cons!\n\nCommand Pattern in C# – What You Need to Implement It\n\nThe Command Pattern in C# offers a behavioral design approach that separates request execution from implementation, fostering code flexibility and organization, explored here through practical implementation steps and design principles.\n\nAt its core, the command pattern is a behavioral software design pattern that helps separate the logic of a request’s execution from its actual implementation. This separation helps to promote greater flexibility and code organization in larger codebases. In this article, I’ll go over the command pattern in C# so we can see it in action!\n\nMaintaining well-organized code is crucial for any software engineer, and understanding design patterns — such as the command pattern — is an essential part of this process. Together, we’ll implement the command pattern in C# and you can see if this pattern will help in your current codebase.\n\nWhat’s in this Article: The Command Pattern in C#\n\nThe Command Pattern is a behavioral design pattern that decouples the sender of a request from the object that performs the action requested. This software pattern encloses a request as an object, thereby allowing you to parameterize clients with different requests. The object that encapsulates the command may know how to invoke the action, but it doesn’t necessarily know the receiver of the request.\n\nIn C#, the Command Pattern is used to encapsulate requests as objects, which is particularly helpful in constructing composite commands or transaction processing. The pattern is designed to enable the separation of application-specific functionality from the underlying system, ensuring that changes made to one do not affect the other.\n\nBy separating commands from the classes that use them, the command pattern allows you to create a more cohesive and maintainable codebase over time. This separation enables the code to scale and evolve over time without much impact on the system’s overall architecture.\n\nCommand Pattern Example in C#\n\nLet’s say we have a fictional restaurant application where a customer can order a beverage. We would use the Command Pattern to encapsulate the request for the beverage order and its processing. The customer would create a concrete command object, specifying a drink order. The object, the waiter, sends the Concrete Command object to the receiver, the bartender, which then executes the request.\n\nThis separation of roles enables the code to scale and evolve over time while maintaining code modularity and cohesion — At least, that’s the theory behind following a pattern like this. In practice, we may find that the levels of abstraction and separation over-complicate, so it’s important to remain pragmatic and choose what works situationally.\n\nHere’s an example of implementing the Command Pattern in C#:\n\nWe’ll revisit how to put this all together in a later section, so keep on reading!\n\nThe Command Pattern follows several principles of object-oriented design. Two of the most relevant principles are the Open-Closed principle and the Single Responsibility principle.\n\nThe Open-Closed principle states that software entities should be open for extension but closed for modification. In other words, once a class is defined and implemented, it should not be changed, except for maintenance purposes. Instead, new features should be added by creating new classes that inherit from or interface with the existing class.\n\nWhen applied to the Command Pattern, the Open-Closed principle emphasizes the importance of creating concrete commands that can be extended over time, without modifying the existing code. This principle enables us to add new functionality to a command without changing the commands’ existing code.\n\nThe Single Responsibility principle states that every software entity should have only one responsibility. This means that a class should be designed in such a way that it only has one reason to change. In the context of the Command Pattern, the Command objects should have only one task to accomplish.\n\nThis can be helpful to recognize because if you have a module of your code that’s doing “too much” (i.e., not a single responsibility), you may be able to ask if some can be factored into a pattern like the Command Pattern. Functionally, it should remain the same — But the implementation and design may end up lending itself well to better organization of code.\n\nThe Command Pattern adheres to the SOLID principle, which is an acronym for five object-oriented design principles used in software development. Each letter represents a principle, as follows:\n• S – Single Responsibility Principle: Each software entity should have only one responsibility. The Command Pattern follows this principle by creating commands that have only one task to accomplish.\n• O – Open-Closed Principle: Software entities should be open for extension but closed for modification. The Command Pattern facilitates this principle through the use of abstract commands that define the behavior of the commands, and concrete classes that implement those behaviors.\n• L – Liskov Substitution Principle: Subtypes should be substitutable for their base types. The Command Pattern facilitates this principle by ensuring that all commands implement the ICommand interface, making them substitutable.\n• I – Interface Segregation Principle: Clients should only be exposed to relevant interfaces. The Command Pattern follows this principle by allowing clients to interact with the Invoker, which calls the commands, rather than with the commands themselves.\n• D – Dependency Inversion Principle: Depend on abstractions, not on concretions. The Command Pattern follows this principle by allowing the to call commands using an interface, rather than a concrete command. This way, the does not depend on a specific command implementation.\n\nThe Command Pattern is composed of four primary components:\n\nEach component plays a critical role in encapsulating requests as objects in the Command Pattern. As we explore each of these, we can consider how the example we looked at relates.\n\nThe is responsible for invoking the commands and initiating their execution. It does not know the details of how the command is executed, unaware of the command’s receiver. The only works with the object’s generic interface, which is in C#. When the receives a command, it stores the command in a history of all invoked commands, providing support for undo and redo commands.\n\nAn example of an implementation in our C# example would be a class that executes a command by calling its method. If we look at the implementation, we can see that the calls made inside of the don’t suggest any shared knowledge of the implementation of the commands.\n\nThe is the abstract encapsulation of a request, which includes the receiver object associated with this request. Commands expose an interface for invoking requests without coupling the sender’s implementation to the requester’s implementation. In other words, objects do not need to know anything about the object they report to – they merely execute the command’s logic and call upon the receiver object when necessary.\n\nIn our C# example, the object implements the interface, which serves as the basis for all commands. You could use a base class or an abstract class, but our example just uses the interface.\n\nA Concrete Command extends and implements the method in a way that defines a specific request and its receiver. Every concrete command corresponds to a specific operation on the receiver. This implementation is where the actual work is done. In other words, the concrete command is responsible for calling the appropriate receiver method(s) based on the request (the command).\n\nAn example of a Concrete Command implementation in our C# example is a , which implements the method to prepare the beverage.\n\nThe Receiver is responsible for providing the necessary actions for carrying out the request. These actions occur as a result of the Concrete Command call to the receiver’s method. The receiver itself does not know anything about the command pattern – it only knows how to perform the action associated with the request that it received.\n\nIn our C# example, a Receiver implementation could be the class that defines the actual task to be executed, such as the class executing the beverage command.\n\nImplementing the Command Pattern in C#: A Practical Guide\n\nImplementing the Command Pattern in C# involves a few fundamental steps, but when done correctly, it can lead to better organization and maintainability of your code. Here is a step-by-step guide to implementing the Command Pattern in C# along with code examples to help you understand how it all works.\n\nDefine the interface. This interface defines the operation that needs to be executed when the command is executed.\n\nCreate concrete classes that implement the interface. In this concrete command class, specific parameters and methods are implemented.\n\nThe class stores the object and calls its specific method to run the command. This class receives a command object to run in the form of .\n\nThis class holds the actual logic for performing the task. It receives the command sent from the client to execute an operation.\n\nThe client creates the command objects and passes them to the class to execute the command.\n\nBy following these steps, you can effectively implement the Command Pattern in C#. The Command Pattern leads to cleaner and more modular code, which can help maintain the system’s structure over time.\n\nBenefits and Drawbacks of the Command Pattern\n\nThe Command Pattern offers numerous benefits for software developers. By encapsulating requests as objects, you can effectively coordinate work on complex, multi-step processes. The pattern provides a uniform and consistent way to represent, store, and transmit requests. This helps to improve the overall structure and maintainability of your codebase.\n\nBenefits of the Command Pattern in C#\n\nBelow are some benefits of the Command Pattern:\n• Improved code organization: The Command Pattern promotes improved code organization by separating the request from the objects that perform the action, making it easier to understand and modify code.\n• Maintainability: Separating the requests into a Command object allows for better scalability and maintainability of code. Programs can be easily modified and updated without worrying about adverse side effects.\n• Reusability: With the Command Pattern, implementations of individual commands can be reused across the application.\n\nDrawbacks of the Command Pattern in C#\n\nAlthough the Command Pattern offers plenty of benefits, it also has a few drawbacks:\n• Increased memory usage: Using the Command Pattern requires creating many small objects that require memory allocation. This overhead can increase the program’s memory usage and performance latency, especially in high-performance applications.\n• Increased complexity: Integrating the Command Pattern into an application can add complexity due to the need for additional classes and interfaces. This is a pretty common trade-off when implementing many design patterns or levels of abstraction.\n• Possible overuse: Overusing the Command Pattern can lead to code redundancy and a convoluted application structure that makes it challenging to maintain, update, and debug.\n\nA common misconception about the Command Pattern is that its use is limited to the undo/redo feature. While this is true, the Command Pattern offers much more than just undo and redo functionality. It promotes code maintainability, extensibility, and scalability, making it an essential part of any software developer’s toolkit.\n\nBy understanding the benefits and drawbacks of the Command Pattern, you can determine if it is the best pattern for your application. Like with any software development pattern, the Command Pattern has its advantages and disadvantages, so it’s important to know when and where it makes sense to use it.\n\nWrapping Up the Command Pattern in C#\n\nThe Command Pattern is a powerful and flexible design pattern that can assist software engineers in separating code execution from code triggering, increasing modularity and reusability. Applying the Command Pattern to C# code can help to organize large codebases, reduce complexity, promote high cohesion, and minimize coupling between objects. While there are some drawbacks to the pattern, the benefits far outweigh them in most cases.\n\nRemember, the key components of the Command Pattern are the invoker, command, concrete command, and receiver. By following the SOLID principles, engineers can create clean and easy-to-maintain code. The challenge is to identify an appropriate context where the Command Pattern can be applied effectively.\n\nBy implementing the Command Pattern, software engineers can gain control over the execution of commands, encourage separation of concerns and improved code maintainability.\n\nFrequently Asked Questions: The Command Pattern in C#"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/delegates-patterns",
        "document": "One excellent example for this kind of design is LINQ. The LINQ Query Expression Pattern relies on delegates for all of its features. Consider this simple example:\n\nThis filters the sequence of numbers to only those less than the value 10. The method uses a delegate that determines which elements of a sequence pass the filter. When you create a LINQ query, you supply the implementation of the delegate for this specific purpose.\n\nThe prototype for the Where method is:\n\nThis example is repeated with all the methods that are part of LINQ. They all rely on delegates for the code that manages the specific query. This API design pattern is a powerful one to learn and understand.\n\nThis simple example illustrates how delegates require very little coupling between components. You don't need to create a class that derives from a particular base class. You don't need to implement a specific interface. The only requirement is to provide the implementation of one method that is fundamental to the task at hand.\n\nBuild Your Own Components with Delegates\n\nLet's build on that example by creating a component using a design that relies on delegates.\n\nLet's define a component that could be used for log messages in a large system. The library components could be used in many different environments, on multiple different platforms. There are a lot of common features in the component that manages the logs. It will need to accept messages from any component in the system. Those messages will have different priorities, which the core component can manage. The messages should have timestamps in their final archived form. For more advanced scenarios, you could filter messages by the source component.\n\nThere is one aspect of the feature that will change often: where messages are written. In some environments, they may be written to the error console. In others, a file. Other possibilities include database storage, OS event logs, or other document storage.\n\nThere are also combinations of output that might be used in different scenarios. You may want to write messages to the console and to a file.\n\nA design based on delegates will provide a great deal of flexibility, and make it easy to support storage mechanisms that may be added in the future.\n\nUnder this design, the primary log component can be a non-virtual, even sealed class. You can plug in any set of delegates to write the messages to different storage media. The built-in support for multicast delegates makes it easy to support scenarios where messages must be written to multiple locations (a file, and a console).\n\nLet's start small: the initial implementation will accept new messages, and write them using any attached delegate. You can start with one delegate that writes messages to the console.\n\nThe static class above is the simplest thing that can work. We need to write the single implementation for the method that writes messages to the console:\n\nFinally, you need to hook up the delegate by attaching it to the WriteMessage delegate declared in the logger:\n\nOur sample so far is fairly simple, but it still demonstrates some of the important guidelines for designs involving delegates.\n\nUsing the delegate types defined in the core framework makes it easier for users to work with the delegates. You don't need to define new types, and developers using your library do not need to learn new, specialized delegate types.\n\nThe interfaces used are as minimal and as flexible as possible: To create a new output logger, you must create one method. That method may be a static method, or an instance method. It may have any access.\n\nLet's make this first version a bit more robust, and then start creating other logging mechanisms.\n\nNext, let's add a few arguments to the method so that your log class creates more structured messages:\n\nNext, let's make use of that argument to filter the messages that are sent to the log's output.\n\nYou've added new features to the logging infrastructure. Because the logger component is very loosely coupled to any output mechanism, these new features can be added with no impact on any of the code implementing the logger delegate.\n\nAs you keep building this, you'll see more examples of how this loose coupling enables greater flexibility in updating parts of the site without any changes to other locations. In fact, in a larger application, the logger output classes might be in a different assembly, and not even need to be rebuilt.\n\nThe Log component is coming along well. Let's add one more output engine that logs messages to a file. This will be a slightly more involved output engine. It will be a class that encapsulates the file operations, and ensures that the file is always closed after each write. That ensures that all the data is flushed to disk after each message is generated.\n\nHere is that file-based logger:\n\nOnce you've created this class, you can instantiate it and it attaches its LogMessage method to the Logger component:\n\nThese two are not mutually exclusive. You could attach both log methods and generate messages to the console and a file:\n\nLater, even in the same application, you can remove one of the delegates without any other issues to the system:\n\nNow, you've added a second output handler for the logging subsystem. This one needs a bit more infrastructure to correctly support the file system. The delegate is an instance method. It's also a private method. There's no need for greater accessibility because the delegate infrastructure can connect the delegates.\n\nSecond, the delegate-based design enables multiple output methods without any extra code. You don't need to build any additional infrastructure to support multiple output methods. They simply become another method on the invocation list.\n\nPay special attention to the code in the file logging output method. It is coded to ensure that it does not throw any exceptions. While this isn't always strictly necessary, it's often a good practice. If either of the delegate methods throws an exception, the remaining delegates that are on the invocation won't be invoked.\n\nAs a last note, the file logger must manage its resources by opening and closing the file on each log message. You could choose to keep the file open and implement to close the file when you are completed. Either method has its advantages and disadvantages. Both do create a bit more coupling between the classes.\n\nNone of the code in the class would need to be updated in order to support either scenario.\n\nFinally, let's update the LogMessage method so that it is robust for those cases when no output mechanism is selected. The current implementation will throw a when the delegate does not have an invocation list attached. You may prefer a design that silently continues when no methods have been attached. This is easy using the null conditional operator, combined with the method:\n\nThe null conditional operator ( ) short-circuits when the left operand ( in this case) is null, which means no attempt is made to log a message.\n\nYou won't find the method listed in the documentation for or . The compiler generates a type safe method for any delegate type declared. In this example, that means takes a single argument, and has a void return type.\n\nYou've seen the beginnings of a log component that could be expanded with other writers, and other features. By using delegates in the design, these different components are loosely coupled. This provides several advantages. It's easy to create new output mechanisms and attach them to the system. These other mechanisms only need one method: the method that writes the log message. It's a design that's resilient when new features are added. The contract required for any writer is to implement one method. That method could be a static or instance method. It could be public, private, or any other legal access.\n\nThe Logger class can make any number of enhancements or changes without introducing breaking changes. Like any class, you cannot modify the public API without the risk of breaking changes. But, because the coupling between the logger and any output engines is only through the delegate, no other types (like interfaces or base classes) are involved. The coupling is as small as possible."
    },
    {
        "link": "https://stackoverflow.com/questions/1295358/best-practices-when-should-i-use-a-delegate-in-net",
        "document": "Delegates provide a way for you to pass behavior as a parameter.\n\nCommon examples are Events and asynchronous programming where something other than your object is responsible for calling into your object. You provide that event with a delegate, and now it's able to run the behavior associated with that delegate.\n\nThis can also be a useful technique when implementing a general algorithm. There've been times where I'm writing multiple methods that are very similar. Perhaps they loop over the same set of data, but they perform slightly different tasks. I can pass in a delegate to a single function to perform that task, then call the delegate from inside the loop over the data. This way I don't have to implement the loop over the data multiple times, I only have to write new code that does new things-- the common behavior is all captured in a common way.\n\nIn response to the comment:\n\nThe difference between calling the delegate from within the loop and calling the method from within the loop is that the delegate is a parameter to the function that contains the loop. This means that that function could do anything, not just what's defined within a particular method. That flexibility can and has been leveraged to supply generic algorithms in libraries completely independent of the specifics of what the algorithms are working with. Linq is a fine example of the generality that is allowed via the flexibility of delegates."
    },
    {
        "link": "https://stackoverflow.com/questions/7988454/events-and-delegates-what-design-pattern",
        "document": "Whilst learning events and delegates I can't help but think about the Observer design pattern.\n\nI'm sort of novice level with both C# and design patterns. When using events and delegates to lets say, firing an event from a child form and being picked up by the parent, is that the Observer design pattern?\n\nWhat other design patters are events and delegates used in?\n\nI'd be interested to know about other 'things' (sorry for my lack of terminology) in .NET are based on common design patterns, such as those from the Gang of Four.\n\nI think it's easier to understand code examples and explanations with such topics if you can relate it to a pattern. Personally anyway."
    },
    {
        "link": "https://medium.com/@sevvalkatirci99/mastering-c-events-and-delegates-the-key-to-flexible-event-driven-programming-2aa56e018111",
        "document": "Understanding Delegates and Events in C#\n\nIn C#, delegates and events are important concepts used for defining and handling callbacks, notifications, and other event-driven behaviors in applications. They enable the decoupling of methods from the objects that invoke them, providing a flexible way to manage dynamic behaviors. Let’s break down the differences and relationships between these concepts and explore examples to see how they work.\n\nA delegate is essentially a function pointer that allows you to encapsulate a method and pass it around as a parameter. It can point to both static and instance methods and can be invoked just like a method.\n• Type Safety: Delegates are type-safe, meaning that they must match the signature (return type and parameters) of the method they point to.\n• Method Encapsulation: Delegates encapsulate methods, allowing you to treat methods as objects.\n• Multicast: Delegates can be combined, so they can invoke multiple methods in a single call.\n• Flexibility: Delegates can be passed as parameters to methods, stored in variables, and returned from methods.\n\nWhat is an Event?\n\nAn event is a mechanism used for broadcasting notifications to registered listeners. While events rely on delegates, they add an additional layer of abstraction and encapsulation. Specifically, an event restricts direct access to the underlying delegate, preventing external code from resetting or invoking the delegate directly.\n• Encapsulation: Events expose only the functionality to subscribe ( ) and unsubscribe ( ) listeners, restricting any direct invocation or resetting of the delegate.\n• Notification Mechanism: Events allow one object (the publisher) to notify other objects (subscribers) when something of interest happens.\n• Class/Struct Limitation: Events can only be declared within classes or structs, ensuring that their use is tied to object-oriented programming principles.\n\nExample of an Event:\n• A delegate allows you to encapsulate methods and pass them around, which can be invoked directly.\n• An event is more restrictive, providing a notification mechanism that only allows methods to be added or removed from the invocation list, without allowing direct invocation from outside the class\n• A delegate can be invoked directly by anyone who has access to it.\n• An event can only be raised (invoked) by the class that declares it, ensuring better encapsulation.\n• Delegates are used when you need a function pointer for callbacks.\n• Events are used when you want to notify multiple subscribers about certain actions or states.\n\nMulticast delegates allow multiple methods to be invoked in a single call. This is useful for events, as multiple subscribers can be notified at once.\n\nDelegates and events are powerful tools for building flexible, event-driven architectures in C#. While delegates provide a way to encapsulate methods and treat them as first-class objects, events add a protective layer that ensures safe and controlled usage of delegates in the context of notifications. Understanding the difference between these two is crucial for writing robust and maintainable code in C#."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/event-pattern",
        "document": ".NET events generally follow a few known patterns. Standardizing on these patterns means that developers can apply knowledge of those standard patterns, which can be applied to any .NET event program.\n\nLet's go through these standard patterns so you have all the knowledge you need to create standard event sources, and subscribe and process standard events in your code.\n\nThe standard signature for a .NET event delegate is:\n\nThis standard signature provides insight into when events are used:\n• The return type is void. Events can have zero to many listeners. Raising an event notifies all listeners. In general, listeners don't provide values in response to events.\n• Events indicate the sender: The event signature includes the object that raised the event. That provides any listener with a mechanism to communicate with the sender. The compile-time type of is , even though you likely know a more derived type that would always be correct. By convention, use .\n• Events package more information in a single structure: The parameter is a type derived from System.EventArgs that includes any more necessary information. (You'll see in the next section that this convention is no longer enforced.) If your event type doesn't need any more arguments, you still must provide both arguments. There's a special value, EventArgs.Empty that you should use to denote that your event doesn't contain any additional information.\n\nLet's build a class that lists files in a directory, or any of its subdirectories that follow a pattern. This component raises an event for each file found that matches the pattern.\n\nUsing an event model provides some design advantages. You can create multiple event listeners that perform different actions when a sought file is found. Combining the different listeners can create more robust algorithms.\n\nEven though this type looks like a small, data-only type, you should follow the convention and make it a reference ( ) type. That means the argument object is passed by reference, and any updates to the data are viewed by all subscribers. The first version is an immutable object. You should prefer to make the properties in your event argument type immutable. That way, one subscriber can't change the values before another subscriber sees them. (There are exceptions to this practice, as you see later.)\n\nNext, we need to create the event declaration in the FileSearcher class. Using the System.EventHandler<TEventArgs> type means that you don't need to create yet another type definition. You just use a generic specialization.\n\nLet's fill out the FileSearcher class to search for files that match a pattern, and raise the correct event when a match is discovered.\n\nThe simplest way to add an event to your class is to declare that event as a public field, as in the preceding example:\n\nThis looks like it's declaring a public field, which would appear to be a bad object-oriented practice. You want to protect data access through properties, or methods. While this code might look like a bad practice, the code generated by the compiler does create wrappers so that the event objects can only be accessed in safe ways. The only operations available on a field-like event are add and remove handler:\n\nThere's a local variable for the handler. If you used the body of the lambda, the handler wouldn't work correctly. It would be a different instance of the delegate, and silently do nothing.\n\nCode outside the class can't raise the event, nor can it perform any other operations.\n\nBeginning with C# 14, events can be declared as partial members. A partial event declaration must include a defining declaration and an implementing declaration. The defining declaration must use the field-like event syntax. The implementing declaration must declare the and handlers.\n\nYour simple version is working fine. Let's add another feature: Cancellation.\n\nWhen you raise the Found event, listeners should be able to stop further processing, if this file is the last one sought.\n\nThe event handlers don't return a value, so you need to communicate that in another way. The standard event pattern uses the object to include fields that event subscribers can use to communicate cancel.\n\nTwo different patterns could be used, based on the semantics of the Cancel contract. In both cases, you add a boolean field to the EventArguments for the found file event.\n\nOne pattern would allow any one subscriber to cancel the operation. For this pattern, the new field is initialized to . Any subscriber can change it to . After the raising the event for all subscribers, the FileSearcher component examines the boolean value and takes action.\n\nThe second pattern would only cancel the operation if all subscribers wanted the operation canceled. In this pattern, the new field is initialized to indicate the operation should cancel, and any subscriber could change it to indicate the operation should continue. After all subscribers process the raised the event, the FileSearcher component examines the boolean and takes action. There's one extra step in this pattern: the component needs to know if any subscribers responded to the event. If there are no subscribers, the field would indicate a cancel incorrectly.\n\nLet's implement the first version for this sample. You need to add a boolean field named to the type:\n\nThis new field is automatically initialized to so you don't cancel accidentally. The only other change to the component is to check the flag after raising the event to see if any of the subscribers requested a cancellation:\n\nOne advantage of this pattern is that it isn't a breaking change. None of the subscribers requested cancellation before, and they still aren't. None of the subscriber code requires updates unless they want to support the new cancel protocol.\n\nLet's update the subscriber so that it requests a cancellation once it finds the first executable:\n\nLet's add one more feature, and demonstrate other language idioms for events. Let's add an overload of the method that traverses all subdirectories in search of files.\n\nThis method could get to be a lengthy operation in a directory with many subdirectories. Let's add an event that gets raised when each new directory search begins. This event enables subscribers to track progress, and update the user as to progress. All the samples you created so far are public. Let's make this event an internal event. That means you can also make the argument types internal as well.\n\nYou start by creating the new EventArgs derived class for reporting the new directory and progress.\n\nAgain, you can follow the recommendations to make an immutable reference type for the event arguments.\n\nNext, define the event. This time, you use a different syntax. In addition to using the field syntax, you can explicitly create the event property with add and remove handlers. In this sample, you don't need extra code in those handlers, but this shows how you would create them.\n\nIn many ways, the code you write here mirrors the code the compiler generates for the field event definitions you saw earlier. You create the event using syntax similar to properties. Notice that the handlers have different names: and . These accessors are called to subscribe to the event, or unsubscribe from the event. Notice that you also must declare a private backing field to store the event variable. This variable is initialized to null.\n\nNext, let's add the overload of the method that traverses subdirectories and raises both events. The easiest way is to use a default argument to specify that you want to search all directories:\n\nAt this point, you can run the application calling the overload for searching all subdirectories. There are no subscribers on the new event, but using the idiom ensures it works correctly.\n\nLet's add a handler to write a line that shows the progress in the console window.\n\nYou saw patterns that are followed throughout the .NET ecosystem. By learning these patterns and conventions, you're writing idiomatic C# and .NET quickly.\n\nNext, you see some changes in these patterns in the most recent release of .NET."
    },
    {
        "link": "https://refactoring.guru/design-patterns/command",
        "document": "Also known as:\n\nImagine that you’re working on a new text-editor app. Your current task is to create a toolbar with a bunch of buttons for various operations of the editor. You created a very neat class that can be used for buttons on the toolbar, as well as for generic buttons in various dialogs. All buttons of the app are derived from the same class. While all of these buttons look similar, they’re all supposed to do different things. Where would you put the code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses for each place where the button is used. These subclasses would contain the code that would have to be executed on a button click. Lots of button subclasses. What can go wrong? Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren’t risking breaking the code in these subclasses each time you modify the base class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic. Several classes implement the same functionality. And here’s the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small “Copy” button on the toolbar, or copy something via the context menu, or just hit on the keyboard. Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation’s code in many classes or make menus dependent on buttons, which is an even worse option.\n\nGood software design is often based on the principle of separation of concerns, which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic. In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a request. The GUI objects may access the business logic objects directly. The Command pattern suggests that GUI objects shouldn’t send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate command class with a single method that triggers this request. Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn’t need to know what business logic object will receive the request and how it’ll be processed. The GUI object just triggers the command, which handles all the details. The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender’s behavior at runtime. You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn’t have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own. The GUI objects delegate the work to commands. Let’s get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It’s enough to put a single field into the base class that stores a reference to a command object and make the button execute that command on a click. You’ll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons’ intended behavior. Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They’ll be linked to a command which gets executed when a user interacts with the GUI element. As you’ve probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication. As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that’s only a fraction of the benefits that the Command pattern can offer!\n\nAfter a long walk through the city, you get to a nice restaurant and sit at the table by the window. A friendly waiter approaches you and quickly takes your order, writing it down on a piece of paper. The waiter goes to the kitchen and sticks the order on the wall. After a while, the order gets to the chef, who reads it and cooks the meal accordingly. The cook places the meal on a tray along with the order. The waiter discovers the tray, checks the order to make sure everything is as you wanted it, and brings everything to your table. The paper order serves as a command. It remains in a queue until the chef is ready to serve it. The order contains all the relevant information required to cook the meal. It allows the chef to start cooking right away instead of running around clarifying the order details from you directly.\n\nIn this example, the Command pattern helps to track the history of executed operations and makes it possible to revert an operation if needed. Commands which result in changing the state of the editor (e.g., cutting and pasting) make a backup copy of the editor’s state before executing an operation associated with the command. After a command is executed, it’s placed into the command history (a stack of command objects) along with the backup copy of the editor’s state at that point. Later, if the user needs to revert an operation, the app can take the most recent command from the history, read the associated backup of the editor’s state, and restore it. The client code (GUI elements, command history, etc.) isn’t coupled to concrete command classes because it works with commands via the command interface. This approach lets you introduce new commands into the app without breaking any existing code. // The base command class defines the common interface for all // concrete commands. abstract class Command is protected field app: Application protected field editor: Editor protected field backup: text constructor Command(app: Application, editor: Editor) is this.app = app this.editor = editor // Make a backup of the editor's state. method saveBackup() is backup = editor.text // Restore the editor's state. method undo() is editor.text = backup // The execution method is declared abstract to force all // concrete commands to provide their own implementations. // The method must return true or false depending on whether // the command changes the editor's state. abstract method execute() // The concrete commands go here. class CopyCommand extends Command is // The copy command isn't saved to the history since it // doesn't change the editor's state. method execute() is app.clipboard = editor.getSelection() return false class CutCommand extends Command is // The cut command does change the editor's state, therefore // it must be saved to the history. And it'll be saved as // long as the method returns true. method execute() is saveBackup() app.clipboard = editor.getSelection() editor.deleteSelection() return true class PasteCommand extends Command is method execute() is saveBackup() editor.replaceSelection(app.clipboard) return true // The undo operation is also a command. class UndoCommand extends Command is method execute() is app.undo() return false // The global command history is just a stack. class CommandHistory is private field history: array of Command // Last in... method push(c: Command) is // Push the command to the end of the history array. // ...first out method pop():Command is // Get the most recent command from the history. // The editor class has actual text editing operations. It plays // the role of a receiver: all commands end up delegating // execution to the editor's methods. class Editor is field text: string method getSelection() is // Return selected text. method deleteSelection() is // Delete selected text. method replaceSelection(text) is // Insert the clipboard's contents at the current // position. // The application class sets up object relations. It acts as a // sender: when something needs to be done, it creates a command // object and executes it. class Application is field clipboard: string field editors: array of Editors field activeEditor: Editor field history: CommandHistory // The code which assigns commands to UI objects may look // like this. method createUI() is // ... copy = function() { executeCommand( new CopyCommand(this, activeEditor)) } copyButton.setCommand(copy) shortcuts.onKeyPress(\"Ctrl+C\", copy) cut = function() { executeCommand( new CutCommand(this, activeEditor)) } cutButton.setCommand(cut) shortcuts.onKeyPress(\"Ctrl+X\", cut) paste = function() { executeCommand( new PasteCommand(this, activeEditor)) } pasteButton.setCommand(paste) shortcuts.onKeyPress(\"Ctrl+V\", paste) undo = function() { executeCommand( new UndoCommand(this, activeEditor)) } undoButton.setCommand(undo) shortcuts.onKeyPress(\"Ctrl+Z\", undo) // Execute a command and check whether it has to be added to // the history. method executeCommand(command) is if (command.execute()) history.push(command) // Take the most recent command from the history and run its // undo method. Note that we don't know the class of that // command. But we don't have to, since the command knows // how to undo its own action. method undo() is command = history.pop() if (command != null) command.undo()\n\nUse the Command pattern when you want to parametrize objects with operations. The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc. Here’s an example: you’re developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item. Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely. As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there’s even more! In the same way, you can queue, log or send commands over the network. Use the Command pattern when you want to implement reversible operations. Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all. To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application’s state. This method has two drawbacks. First, it isn’t that easy to save an application’s state because some of it can be private. This problem can be mitigated with the Memento pattern. Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement."
    },
    {
        "link": "https://refactoring.guru/design-patterns/csharp",
        "document": ""
    },
    {
        "link": "https://medium.com/@bsahoo1995/c-design-patterns-command-a67a5a72f53e",
        "document": "Before we implement, it’s essential to know the components that are part of the implementation.\n• Command Interface: Represents the command and declares an Execute() method.\n\nLet’s call the command interface¹ ICommand.cs which will have the Execute() method.\n\nThen, we will create concrete commands² MoveCommand.cs, JumpCommand.cs, and AttackCommand.cs.\n\nFor the commands to execute actions on the player, we have to make the Move(), Jump(), and Attack() methods publicly accessible.\n\nWith the concrete commands² created, let's create the invoker³ InputHandler.cs which will be executing these input commands.\n\nAs we do not need to check for correct command types anymore, we can get rid of the InputType.cs enum.\n\nFinally, the client⁴ GamePlay.cs is going to initiate these commands for the player.\n\nLook… how simple and manageable the inputs are now after implementing the command pattern. 😄 👍 🙌\n\nWith this, each command can be stored and reused in any order, allowing a more dynamic input-handling system.\n\nMoreover, if we need to we can keep a buffer of executed commands and then allow re-playing or even undoing the commands. Similar to a strategy or a chess game.\n\nWith the implementation, we have achieved 👇\n\n✅ Extensibility & Maintainability: Adding new actions simply requires creating new concrete command classes without modifying the GamePlay.cs or InputHandler.cs class.\n\nBut indeed requires the Player.cs class to define public methods for the respective actions, as the player class itself is responsible for managing how the actions are performed by the player.\n\n✅ Undo/Redo: “Command Objects” can be stacked or queued allowing delayed, step-by-step, or repetitive/iterative executions."
    },
    {
        "link": "https://stackoverflow.com/questions/13490497/c-sharp-console-application-command-session-history",
        "document": "I have simple command line application, and I want to store commands typed in between starts of program.\n\nStoring alone is not problem, I know how to do it, but how I can restore it? class don't have any method for setting history, if I press up arrow on start of application it is empty.\n\nMethods from msdn for unmanaged code are not helpful for me, good answer could show me how to use them in c# to get what I need.\n\nMy idea is to override up arrow with only and do it \"hard\" way but if there is easier way I would be glad."
    },
    {
        "link": "https://scholarhat.com/tutorial/designpatterns/command-design-pattern",
        "document": "Understanding the Command Design Pattern is a crucial concept in software design. It allows for the encapsulation of a request as an object, enabling parameterization of clients with queues, logs, and operations. This decouples the sender of the request from the receiver, promoting flexibility, reuse, and scalability, which is especially valuable in undo/redo functionalities and transactional systems.\n\nIn this design pattern tutorial, we will look at the Command What is the Command Design Pattern? When should I use the Command Design Pattern? \" we will also explore examples of the Command Design Pattern in action. So, let us begin by addressing the question: \" What is the Command Design Pattern?\n• The Command Design Pattern is a behavioral design pattern that converts a request into a stand-alone object, allowing clients to be parameterized with different requests, queuing requests, and supporting irreversible activities.\n• None The Command Pattern wraps a request as an object, separating the sender and recipient.\n• Commands can be parameterized, which means that you can create several commands with varying parameters without modifying the invoker.\n• It separates the sender (client or invoker) from the receiver (object that performs the operation), allowing for greater flexibility and extension.\n• By saving the state or reverse commands, the pattern provides undoable operations (an action or a series of actions that can be reversed or undone in a system).\n\nThe UML class diagram for the implementation of the command design pattern is given below:\n\nThe classes, interfaces, and objects in the above UML class diagram are as follows:\n• The Command Interface functions similarly to a rulebook for all command types.\n• It declares a common function, execute(), which ensures that each concrete command understands how to do its own operation.\n• It establishes the standard for all commands, allowing the remote control to manage and execute various tasks without having to know the specifics of each command.\n• Concrete Command Classes are specific commands, such as turning on the television or altering the audio volume.\n• Each class contains the details of a certain action.\n• These classes serve as executable instructions that the remote control can activate without thinking about the specifics of how each command performs its function.\n• The Invoker, commonly a remote control, is in charge of beginning command execution.\n• It references a command but does not go into detail on how each command works.\n• The remote control's purpose is to coordinate and execute commands without becoming engaged in the complexity of individual activities.\n• The Receiver is the device that knows how to carry out the actual function specified by a command.\n• It could be a television, stereo, or another device. Receivers understand the exact duties specified in commands.\n• If a command specifies \"turn on,\" the Receiver (device) understands exactly how to carry out that operation.\n• The Receiver-Command connection divides responsibilities, making it simple to add new devices or commands without interfering with existing features.\n\nThis diagram illustrates the Command Design Pattern within a smart home automation system. Here is a breakdown of the elements:\n• It triggers the execution of commands without needing to know the specifics of each action.\n• It provides a method for setting and executing commands, like turning on lights or adjusting the thermostat.\n• None for all smart devices, such as lights, thermostats, or speakers.\n• It ensures that each device can respond to a command in a standardized way.\n• It specifies the operations a device should perform, such as turning on or off.\n• None These are the specific implementations of the\n• They encapsulate the actual actions, such as switching the light on or adjusting the temperature.\n• They respond to commands initiated by the RemoteControl.\n• None Serves as the blueprint for creating various commands.\n• It specifies the execute() method that all concrete commands must implement.\n• It ensures that each command follows the same structure, making it easier to handle diverse actions.\n• None represent specific commands, such as turning on a light or adjusting the thermostat.\n• Each class encapsulates the logic for executing a particular operation on the smart device.\n• The execute() method is implemented to invoke the appropriate action on the device.\n• None is useful because it decouples the invoker (remote control) from the receiver (smart devices).\n• It makes it easy to add or modify commands without altering the RemoteControl or device classes.\n• It provides flexibility in implementing additional features like undo/redo operations or logging command history.\n• It's ideal for situations where you want to handle multiple operations without tightly coupling the requester to the device logic.\n• This code demonstrates the Command pattern with smart devices.\n• It is where the ICommand interface defines the command structure, and ISmartDevice represents devices like a smart light and thermostat.\n• The TurnOnCommand and TurnOffCommand execute actions for these devices.\n• The RemoteControl class acts as the invoker, allowing the client to execute commands to turn devices on or off.\n\nWhen to use the Command Design Pattern\n• Undo/redo functionality:It is ideal when you need to implement undo/redo actions, allowing you to store and reverse commands easily.\n• Parameterizing actions: It is useful when you want to pass actions (commands) as parameters to other objects, enabling flexible system design.\n• Queueing operations: This is effective when commands need to be queued or logged for later execution, such as in task scheduling systems.\n• Encapsulating requests: It is helpful when you need to encapsulate a request as an object, making it easier to manage, log, or execute actions at a later time.\n• Simple actions: It is unnecessary when actions are straightforward and do not need to be encapsulated into objects or queued for later execution.\n• Limited flexibility: It is overkill if your application does not require extensive undo/redo functionality or complex request handling.\n• Increased complexity: It is better to avoid when the pattern adds excessive complexity without significant benefits, especially for small, simple tasks.\n\nThe Command Design Pattern encapsulates requests as objects, allowing for parameterization of clients with different requests and supporting undoable operations. It promotes loose coupling between the sender and receiver of commands and is ideal for implementing queues, logging, and transactional systems. However, it may not be suitable for simple operations due to the added complexity. For a deeper understanding and practical applications of design patterns, consider enrolling in the Software Architecture and Design Certification Training offered by Scholarhat."
    }
]