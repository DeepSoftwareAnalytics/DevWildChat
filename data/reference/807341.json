[
    {
        "link": "https://baeldung.com/java-private-constructors",
        "document": "Private constructors allow us to restrict the instantiation of a class. Simply put, they prevent the creation of class instances in any place other than the class itself.\n\nPublic and private constructors, used together, allow control over how we wish to instantiate our classes – this is known as constructor delegation.\n\nThere are several patterns and benefits to restricting explicit class instantiation, and we’ll go through the most common ones in this tutorial:\n\nLet’s see how to define a private constructor:\n\nWe define private constructors similarly to public constructors; we’ve simply changed the public keyword to private.\n\n3. Using Private Constructors in the Singleton Pattern\n\nThe singleton pattern is one of the most common places we’ll encounter the use of a private constructor. The private constructor allows us to restrict class instantiation to a single object instance:\n\nWe can create an instance by calling SingletonClass.getInstance() – this either returns an existing instance or creates one if this is the first instantiation. We can only instantiate this class by using the getInstance() static method.\n\nAnother common use case for private constructors is to provide a means of constructor delegation. Constructor delegation allows us to pass parameters through several different constructors while restricting initialization to specific places.\n\nIn this example, ValueTypeClass allows initialization with a value and type – but we only want to allow it for a subset of types. The general constructor must be private to ensure that only permitted types are used:\n\nWe can initialize ValueTypeClass via two different public constructors: one accepts an int, and the other a boolean. Each of these constructors then calls a common private constructor to complete the object initialization.\n\nUninstantiable classes are classes that we cannot instantiate. In this example, we’ll create a class that simply contains a collection of static methods:\n\nThe StringUtils class contains a couple of static utility methods and can’t be instantiated due to the private constructor.\n\nReally, there’s no need to allow object instantiation since static methods don’t require an object instance to be used.\n\n6. Using Private Constructors in the Builder Pattern\n\nThe builder pattern allows us to construct complex objects step by step, rather than having several constructors providing different ways to create the object. A private constructor restricts initialization, allowing the builder to manage object creation instead.\n\nIn this example, we’ve created an Employee class that holds the name, age, and department of an employee:\n\nAs we can see, we’ve made the Employee constructor private – therefore, we cannot instantiate the class explicitly.\n\nWe’ll now add an inner Builder class to the Employee class:\n\nThe builder can now create different employees with a name, age, or department – there’s no constraint on how many fields we must provide:\n\nWe’ve created an Employee with a name of “baeldung” and a department of “Builder Pattern“. Age is not provided, so the default primitive int value of 0 will be used.\n\nAnother possible use for private constructors is to prevent subclassing of a class. If we tried to create such as subclass, it would be unable to call the super constructor. However, it’s important to note that we’d normally make a class final to prevent subclassing rather than using a private constructor.\n\nThe primary use of private constructors is to restrict the instantiation of classes. Private constructors are especially useful when we want to restrict the external creation of a class.\n\nSingletons, factories, and static method objects are examples of how restricting object instantiation can be useful to enforce a certain pattern.\n\nConstants classes and static method classes also dictate that a class should not be instantiable. It’s important to remember that we can also combine private constructors with public constructors to allow code sharing inside different public constructor definitions."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html",
        "document": "Trail: Learning the Java Language \n\nLesson: Classes and Objects \n\nSection: More on Classes\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAccess level modifiers determine whether other classes can use a particular field or invoke a particular method. There are two levels of access control:\n• At the top level , or package-private (no explicit modifier).\n• At the member level , , , or package-private (no explicit modifier).\n\nA class may be declared with the modifier , in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes  you will learn about them in a later lesson.)\n\nAt the member level, you can also use the modifier or no modifier (package-private) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: and . The modifier specifies that the member can only be accessed in its own class. The modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.\n\nThe following table shows the access to members permitted by each modifier.\n\nThe first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members. The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member. The third column indicates whether subclasses of the class declared outside this package have access to the member. The fourth column indicates whether all classes have access to the member.\n\nAccess levels affect you in two ways. First, when you use classes that come from another source, such as the classes in the Java platform, access levels determine which members of those classes your own classes can use. Second, when you write a class, you need to decide what access level every member variable and every method in your class should have.\n\nLet's look at a collection of classes and see how access levels affect visibility. The following figure shows the four classes in this example and how they are related.\n\nThe following table shows where the members of the Alpha class are visible for each of the access modifiers that can be applied to them."
    },
    {
        "link": "https://stackoverflow.com/questions/5304925/restrict-constructor-to-sibling-use-java",
        "document": "There is a way to emulate the C++'s friend feature, and thus achieve the result you want.\n\nWarning: This is a contrived technique that should be used only if you have no other solution!\n\nSince no modifier does what you want in this case, the trick is to move the access restriction to another place, where modifiers apply. To do that, add a key parameter to the constructor. That key is of a class that can only be instantiated by the allowed \"sibling\" classes, i.e. by the subclasses of a given class.\n\nThe restriction is thus moved to the common superclass, where restraining the creation of the key is possible with the usual modifiers.\n\nHere is an example:"
    },
    {
        "link": "https://stackoverflow.com/questions/11625635/private-constructor-in-abstract-class",
        "document": "In Java what is the purpose of using private constructor in an abstract class?\n\nIn a review I got this question, and I am curious, for what situation we need to use the constructor in such way?\n\nI think it can be used in pair with another constructor in abstract class, but this is very trivial. Also it can be used for constructing static inner classes which will excend abstract class.\n\nMaybe there is more elegant usage?"
    },
    {
        "link": "https://docs.vultr.com/java/examples/implement-private-constructors",
        "document": "Java programming allows the use of private constructors to restrict the instantiation of classes from outside code, ensuring more control over how objects are created. Typically, this feature is utilized in patterns like Singleton, where it's crucial to manage the number of object instances or in utility classes that shouldn't be instantiated at all.\n\nIn this article, you will learn how to use private constructors in Java effectively through practical examples. Explore how this can be useful in creating Singleton classes and utility classes to maintain better control and integrity of your application's architecture.\n• Understand the Singleton pattern: It ensures that a class has only one instance and provides a global point of access to it.\n• Recognize the need for a private constructor: It prevents the creation of a class instance from any other class.\n• None Utilize a static method that provides access to the instance. In this code block, the class uses a private constructor to restrict instantiation. The method checks if an instance of already exists; if not, it creates one. This ensures that there is always only one instance of .\n• Ensures that a resource-consuming object isn't created more than once.\n• Provides a controlled access point to a shared resource throughout an application, such as a database connection or a configuration manager.\n• Recognize utility classes: These are classes typically filled with static methods and constants. They are not meant to be instantiated.\n• Know why a private constructor is useful: It prevents the instantiation of utility classes, avoiding improper usage.\n• None Add static methods that do not rely on object state. Here, the class has a private constructor to prevent it from being instantiated. The static method provides functionality without needing an instance of . This design ensures that is used as intended – as a provider of static functionalities.\n• Use for grouping related static operations like mathematical operations, string processing, or file manipulations.\n• Employ in cases where maintaining the state is unnecessary or could be harmful.\n\nUsing private constructors in Java is a potent technique for enhancing control over how classes are used within software architectures. By implementing private constructors, you promote the intentional use of classes either by restricting their instantiation as in Singleton patterns, or by preventing instantiation altogether as with utility classes. These practices lead to a more robust, maintainable, and error-resistant codebase. Embrace these strategies to capitalize on Java's capabilities, ensuring your programs are efficient and logically organized."
    },
    {
        "link": "https://geeksforgeeks.org/factory-method-design-pattern-in-java",
        "document": "It is a creational design pattern that talks about the creation of an object. The factory design pattern says to define an interface ( A java interface or an abstract class) for creating the object and let the subclasses decide which class to instantiate.\n\nWhat is the Factory Method Design Pattern?\n\nBelow is the explanation of the above image:\n• None The factory method in the interface lets a class defer the instantiation to one or more concrete subclasses.\n• None Since these design patterns talk about the instantiation of an object they come under the category of creational design pattern.\n• None If we notice the name Factory method , that means there is a method which is a factory, and in general, factories are involved with creational stuff and here with this, an object is being created.\n• None It is one of the best ways to create an object where object creation logic is hidden from the client. Now Let’s look at the implementation.\n\nWhen to use Factory Method Design Pattern?\n\nFactory method design pattern can be used in java in following cases:\n• None A class cannot predict the type of objects it needs to create.\n• None A class wants its subclasses to specify the objects it creates.\n• None Classes delegate responsibility to one of multiple helper subclasses, and you aim to keep the information about which helper subclass is the delegate within a specific scope or location.\n\nBelow are the main components of Factory Method Design Pattern in Java:\n• Product\n• None It’s an abstract class or interface that defines the common operations for the objects that the factory will create.\n• None Concrete Products are the actual classes that implement the Product interface, each representing a specific type of object to be created.\n• Creator\n• None It’s an abstract class or interface that declares the factory method.\n• None This method is responsible for creating Product objects, but it delegates the actual creation to subclasses.\n• Concrete Creators\n• None These are subclasses of the Creator that implement the factory method.\n• None They decide which specific Concrete Product to create, often based on input parameters or configuration.\n• Factory Method\n• None It’s a method defined in the Creator class that is responsible for creating Product objects.\n• None It’s typically declared as abstract in the Creator and implemented in the Concrete Creators.\n\nLet’s understand factory method design pattern using an example. Below is the problem statement to understand it:\n\nYou are developing a software system for an e-commerce platform that deals with various types of products. Each product category (e.g., electronics, clothing, books) requires specific handling during creation. However, you want to decouple the client code from the concrete product creation logic to enhance flexibility and maintainability. Additionally, you want to allow for easy extension by adding new product types in the future without modifying existing code.\n\nThe above problem can be solved using Factory Method Design Pattern:\n\nThe above problem can be solved using Factory Method Design Pattern:\n\nUse Cases of the Factory Method Design Pattern\n\nBelow are the use cases of factory method:\n• None JDBC uses factories to create connections and statements. Frameworks like Spring and Guice utilize factories for managing beans.\n• None Swing and JavaFX uses factories to produce UI components such as buttons and text fields, offering flexibility in design.\n• None Tools like Log4j and Logback employ factories to create loggers with various configurations, allowing for control over logging levels.\n• None Serialization frameworks use factories to generate objects from serialized data, accommodating different formats and versions.\n\nBelow are the main advantages of factory method:\n• None Separates object creation from client code, enhancing flexibility and maintainability since changes to creation don’t affect clients.\n• None New product types can be easily added without altering client code by simply creating new Concrete Creator subclasses.\n• None Simplifies unit testing by allowing mock product creation, enabling tests of various implementations without actual object dependencies.\n• None The factory method can be reused across different application parts, centralizing and streamlining object creation logic.\n\nBelow are the main advantages of factory method:\n• None Adds more classes and interfaces, which can complicate understanding and maintenance, especially for newcomers.\n• None Polymorphism and dynamic binding may slightly affect performance, though this is usually minimal.\n• None Concrete creators remain closely linked to their products, necessitating changes across both when one is modified.\n• None Client code must be aware of concrete subclasses to make accurate factory calls.\n• None The pattern should be applied carefully to avoid unnecessary complexity; simple object creation may not need a factory.\n• None Testing the factory logic can be more complicated compared to simpler designs.\n\nSo far we learned what is Factory method design pattern and how to implement it. I believe now we have a fair understanding of the advantage of this design mechanism. Factory methods pervade toolkits and frameworks.The preceding document example is a typical use in MacApp and ET++."
    },
    {
        "link": "https://refactoring.guru/design-patterns/factory-method",
        "document": "Also known as:\n\nImagine that you’re creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the class. After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app. Adding a new class to the program isn’t that simple if the rest of the code is already coupled to existing classes. Great news, right? But how about the code? At present, most of your code is coupled to the class. Adding into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again. As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app’s behavior depending on the class of transportation objects.\n\nThe Factory Method pattern suggests that you replace direct object construction calls (using the operator) with calls to a special factory method. Don’t worry: the objects are still created via the operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products. Subclasses can alter the class of objects being returned by the factory method. At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method. There’s a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface. All products must follow the same interface. For example, both and classes should implement the interface, which declares a method called . Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the class returns truck objects, whereas the factory method in the class returns ships. As long as all product classes implement a common interface, you can pass their objects to the client code without breaking it. The code that uses the factory method (often called the client code) doesn’t see a difference between the actual products returned by various subclasses. The client treats all the products as abstract . The client knows that all transport objects are supposed to have the method, but exactly how it works isn’t important to the client.\n\nThis example illustrates how the Factory Method can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes. The base class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux. When the factory method comes into play, you don’t need to rewrite the logic of the class for each operating system. If we declare a factory method that produces buttons inside the base class, we can later create a subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen. For this pattern to work, the base class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the code within remains functional, whichever type of buttons it works with. Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the , you get closer to the Abstract Factory pattern. Fear not, we’ll talk about this pattern later. // The creator class declares the factory method that must // return an object of a product class. The creator's subclasses // usually provide the implementation of this method. class Dialog is // The creator may also provide some default implementation // of the factory method. abstract method createButton():Button // Note that, despite its name, the creator's primary // responsibility isn't creating products. It usually // contains some core business logic that relies on product // objects returned by the factory method. Subclasses can // indirectly change that business logic by overriding the // factory method and returning a different type of product // from it. method render() is // Call the factory method to create a product object. Button okButton = createButton() // Now use the product. okButton.onClick(closeDialog) okButton.render() // Concrete creators override the factory method to change the // resulting product's type. class WindowsDialog extends Dialog is method createButton():Button is return new WindowsButton() class WebDialog extends Dialog is method createButton():Button is return new HTMLButton() // The product interface declares the operations that all // concrete products must implement. interface Button is method render() method onClick(f) // Concrete products provide various implementations of the // product interface. class WindowsButton implements Button is method render(a, b) is // Render a button in Windows style. method onClick(f) is // Bind a native OS click event. class HTMLButton implements Button is method render(a, b) is // Return an HTML representation of a button. method onClick(f) is // Bind a web browser click event. class Application is field dialog: Dialog // The application picks a creator's type depending on the // current configuration or environment settings. method initialize() is config = readApplicationConfigFile() if (config.OS == \"Windows\") then dialog = new WindowsDialog() else if (config.OS == \"Web\") then dialog = new WebDialog() else throw new Exception(\"Error! Unknown operating system.\") // The client code works with an instance of a concrete // creator, albeit through its base interface. As long as // the client keeps working with the creator via the base // interface, you can pass it any creator's subclass. method main() is this.initialize() dialog.render()\n\nUse the Factory Method when you don’t know beforehand the exact types and dependencies of the objects your code should work with. The Factory Method separates product construction code from the code that actually uses the product. Therefore it’s easier to extend the product construction code independently from the rest of the code. For example, to add a new product type to the app, you’ll only need to create a new creator subclass and override the factory method in it. Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components. Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component? The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself. Let’s see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard class with a glorious subclass. But now you need to tell the main class to use the new button subclass instead of a default one. To achieve this, you create a subclass from a base framework class and override its method. While this method returns objects in the base class, you make your subclass return objects. Now use the class instead of . And that’s about it! Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time. You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources. Let’s think about what has to be done to reuse an existing object:\n• First, you need to create some storage to keep track of all of the created objects.\n• When someone requests an object, the program should look for a free object inside that pool.\n• … and then return it to the client code.\n• If there are no free objects, the program should create a new one (and add it to the pool). That’s a lot of code! And it must all be put into a single place so that you don’t pollute the program with duplicate code. Probably the most obvious and convenient place where this code could be placed is the constructor of the class whose objects we’re trying to reuse. However, a constructor must always return new objects by definition. It can’t return existing instances. Therefore, you need to have a regular method capable of creating new objects as well as reusing existing ones. That sounds very much like a factory method."
    },
    {
        "link": "https://stackoverflow.com/questions/18796333/object-instantiation-with-a-factory-method",
        "document": "A factory is useful in specific situations:\n• Where one of several different subclasses of the object might be returned, based on parameters.\n• Where there is some need to \"guard\" the creation of objects, perhaps for security, perhaps for some sort of synchronization.\n• Where created objects need to be \"enrolled\" somehow after creation, and doing so in the constructor is not feasible.\n• Where one does not even want to load the (actual) class (and it's tree of referenced classes) unless an instance must be created.\n\nWhere some reason such as the above is not present, there is no benefit to factory methods, and they simply obscure the logic.\n\nThere is no real restriction on what a factory can do, given that it can (if things are set up properly) access package level constructors and interfaces that are not accessible to the hoi polloi.\n\nLet's say we have the classical Vehicle example, with Car and Truck subclasses. If you simply have CarFactory and TruckFactory then that increases the complexity of the code for no good reason (unless there are other compelling reasons for using factories).\n\nBut you can have a VehicleFactory and have it \"decide\", based on input or external factors, to create a Car or a Truck. This is a fairly common pattern.\n\nHowever, if you were to (for some reason) have a VehicleFactory that only created Vehicle objects (not Cars or Trucks), and if use of the factory were mandatory (you couldn't access Vehicle's constructors), that would make it essentially impossible to subclass Vehicle. When you use a factory you make it very difficult (at the least) for someone else to add new subclasses."
    },
    {
        "link": "https://home.csulb.edu/~pnguyen/cecs277/lecnotes/factory.pdf",
        "document": ""
    },
    {
        "link": "https://medium.com/@eshikashah2001/exploring-the-factory-method-design-pattern-4d270b6ff935",
        "document": "In the realm of software engineering, design patterns play a pivotal role in ensuring the scalability, maintainability, and flexibility of applications. One such design pattern that stands out for its simplicity and usefulness is the Factory Method Design Pattern. In this blog, we’ll delve into the intricacies of the Factory Method pattern, exploring its definition, use cases, components, and implementation, as well as its advantages and disadvantages.\n\nThe Factory Method pattern falls under the category of creational design patterns and is widely used to create objects without specifying their exact class types. Instead of directly instantiating objects using constructors, the Factory Method pattern delegates the responsibility of object creation to subclasses, allowing for greater flexibility and extensibility.\n\nWhat is the Factory Method Design Pattern?\n\nThe Factory Method pattern is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. It encapsulates the object creation logic, decoupling it from the client code that uses the objects.\n\nWhen to Use Factory Method Design Pattern?\n\nThe Factory Method pattern is best suited for scenarios where\n• The exact class of objects to be created is not known at compile time.\n• The client code needs to be decoupled from the concrete classes of objects it creates.\n• There’s a need for flexibility in object creation, allowing subclasses to provide variations of the created objects.\n• The application needs to adhere to the Open/Closed Principle, where classes should be open for extension but closed for modification.\n• Product: Represents the interface of the objects created by the factory method.\n• ConcreteProduct: Implements the Product interface and represents the concrete objects created by the factory method.\n• Creator: Declares the factory method, which returns an instance of the Product interface.\n• ConcreteCreator: Implements the factory method to create instances of ConcreteProduct.\n\nLet’s consider a simple example of a pizza ordering system to illustrate the Factory Method pattern:\n\nBy using the Factory Method pattern:\n\n- We keep client code decoupled from concrete pizza types.\n\n- Adding new pizza types is easy, just create a new concrete pizza class and its corresponding factory.\n\n- Creation logic is encapsulated in factory classes, promoting maintainability.\n• Encourages loose coupling between client code and the created objects.\n• Provides a centralized point of control for object creation, facilitating easier maintenance and testing.\n• Supports the Open/Closed Principle, allowing for the addition of new product types without modifying existing client code.\n• Can lead to an explosion of subclasses if there are many variations of products.\n• Increases complexity in the codebase, especially when dealing with multiple factories and product types.\n• May introduce runtime errors if the factory method is not implemented properly or if there are inconsistencies in product creation logic across subclasses.\n\nThe Factory Method Design Pattern is a powerful tool for creating objects in a flexible, decoupled, and extensible manner. By encapsulating object creation logic in subclasses, the Factory Method pattern promotes code reusability, maintainability, and scalability. While it may introduce some complexity, especially in large codebases, its benefits outweigh the drawbacks, making it a valuable addition to any developer’s toolkit."
    }
]