[
    {
        "link": "https://expressjs.com/en/4x/api.html",
        "document": "Creates an Express application. The function is a top-level function exported by the module.\n\nThe object conventionally denotes the Express application. Create it by calling the top-level function exported by the Express module:\n\nThe object has methods for\n• Routing HTTP requests; see for example, app.METHOD and app.param.\n\nIt also has settings (properties) that affect how the application behaves; for more information, see Application settings.\n\nAdd callback triggers to route parameters, where is the name of the parameter or an array of them, and is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order. If is an array, the trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to inside the callback will call the callback for the next declared parameter. For the last parameter, a call to will call the next middleware in place for the route currently being processed, just like it would if were just a string. For example, when is present in a route path, you may map user loading logic to automatically provide to the route, or perform validations on the parameter input. // try to get the user details from the User model and attach it to the request object Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on will be triggered only by route parameters defined on routes. All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples. On , the following is printed: CALLED ONLY ONCE although this matches and this matches too On , the following is printed: CALLED ONLY ONCE with 42 CALLED ONLY ONCE with 3 although this matches and this matches too The following section describes , which is deprecated as of v4.11.0. The behavior of the method can be altered entirely by passing only a function to . This function is a custom implementation of how should behave - it accepts two parameters and must return a middleware. The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation. The middleware returned by the function decides the behavior of what happens when a URL parameter is captured. In this example, the signature is modified to . Instead of accepting a name and a callback, will now accept a name and a number. In this example, the signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id. The ‘ ’ character can’t be used to capture a character in your capturing regexp. For example you can’t use to capture , use or instead (as in . // captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\n\nThe object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as (and the HTTP response is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n\nThe object represents the HTTP response that an Express app sends when it gets an HTTP request.\n\nIn this documentation and by convention, the object is always referred to as (and the HTTP request is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own response object and supports all built-in fields and methods."
    },
    {
        "link": "https://expressjs.com/en/api.html",
        "document": "Creates an Express application. The function is a top-level function exported by the module.\n\nThe object conventionally denotes the Express application. Create it by calling the top-level function exported by the Express module:\n\nThe object has methods for\n• Routing HTTP requests; see for example, app.METHOD and app.param.\n\nIt also has settings (properties) that affect how the application behaves; for more information, see Application settings.\n\nAdd callback triggers to route parameters, where is the name of the parameter or an array of them, and is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order. If is an array, the trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to inside the callback will call the callback for the next declared parameter. For the last parameter, a call to will call the next middleware in place for the route currently being processed, just like it would if were just a string. For example, when is present in a route path, you may map user loading logic to automatically provide to the route, or perform validations on the parameter input. // try to get the user details from the User model and attach it to the request object Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on will be triggered only by route parameters defined on routes. All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples. On , the following is printed: CALLED ONLY ONCE although this matches and this matches too On , the following is printed: CALLED ONLY ONCE with 42 CALLED ONLY ONCE with 3 although this matches and this matches too The following section describes , which is deprecated as of v4.11.0. The behavior of the method can be altered entirely by passing only a function to . This function is a custom implementation of how should behave - it accepts two parameters and must return a middleware. The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation. The middleware returned by the function decides the behavior of what happens when a URL parameter is captured. In this example, the signature is modified to . Instead of accepting a name and a callback, will now accept a name and a number. In this example, the signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id. The ‘ ’ character can’t be used to capture a character in your capturing regexp. For example you can’t use to capture , use or instead (as in . // captures '1-a_6' and '543-az(ser\"-sder' but not '5-a s'\n\nThe object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as (and the HTTP response is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own request object and supports all built-in fields and methods.\n\nThe object represents the HTTP response that an Express app sends when it gets an HTTP request.\n\nIn this documentation and by convention, the object is always referred to as (and the HTTP request is ) but its actual name is determined by the parameters to the callback function in which you’re working.\n\nBut you could just as well have:\n\nThe object is an enhanced version of Node’s own response object and supports all built-in fields and methods."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/routes",
        "document": "In the last tutorial article we defined Mongoose models to interact with the database, and used a (standalone) script to create some initial library records. We can now write the code to present that information to users. The first thing we need to do is determine what information we want to be able to display in our pages, and then define appropriate URLs for returning those resources. Then we're going to need to create the routes (URL handlers) and views (templates) to display those pages. The diagram below is provided as a reminder of the main flow of data and things that need to be implemented when handling an HTTP request/response. In addition to the views and routes the diagram shows \"controllers\" — functions that separate out the code to route requests from the code that actually processes requests. As we've already created the models, the main things we'll need to create are:\n• \"Routes\" to forward the supported requests (and any information encoded in request URLs) to the appropriate controller functions.\n• Controller functions to get the requested data from the models, create an HTML page displaying the data, and return it to the user to view in the browser.\n• Views (templates) used by the controllers to render the data. Ultimately we might have pages to show lists and detail information for books, genres, authors and bookinstances, along with pages to create, update, and delete records. That's a lot to document in one article. Therefore most of this article will concentrate on setting up our routes and controllers to return \"dummy\" content. We'll extend the controller methods in our subsequent articles to work with model data. The first section below provides a brief \"primer\" on how to use the Express Router middleware. We'll then use that knowledge in the following sections when we set up the LocalLibrary routes.\n\nOur module above defines a couple of typical route functions. The \"about\" route (reproduced below) is defined using the method, which responds only to HTTP GET requests. The first argument to this method is the URL path while the second is a callback function that will be invoked if an HTTP GET request with the path is received. The callback takes three arguments (usually named as shown: , , ), that will contain the HTTP Request object, HTTP response, and the next function in the middleware chain. Note: Router functions are Express middleware, which means that they must either complete (respond to) the request or call the function in the chain. In the case above we complete the request using , so the argument is not used (and we choose not to specify it). The router function above takes a single callback, but you can specify as many callback arguments as you want, or an array of callback functions. Each function is part of the middleware chain, and will be called in the order it is added to the chain (unless a preceding function completes the request). The callback function here calls on the response to return the string \"About this wiki\" when we receive a GET request with the path ( ). There are a number of other response methods for ending the request/response cycle. For example, you could call to send a JSON response or to send a file. The response method that we'll be using most often as we build up the library is , which creates and returns HTML files using templates and data—we'll talk a lot more about that in a later article!\n\nThe previous section shows how Express expects route functions to return errors. The framework is designed for use with asynchronous functions that take a callback function (with an error and result argument), which is called when the operation completes. That's a problem because later on we will be making Mongoose database queries that use Promise-based APIs, and which may throw exceptions in our route functions (rather than returning errors in a callback). In order for the framework to properly handle exceptions, they must be caught, and then forwarded as errors as shown in the previous section. Note: Express 5, which is currently in beta, is expected to handle JavaScript exceptions natively. Re-imagining the simple example from the previous section with as a database query that returns a promise, we might write the route function inside a block like this: exports.get(\"/about\", async function (req, res, next) { try { const successfulResult = await About.find({}).exec(); res.render(\"about_view\", { title: \"About\", list: successfulResult }); } catch (error) { return next(error); } }); That's quite a lot of boilerplate code to add to every function. Instead, for this tutorial we'll use the express-async-handler module. This defines a wrapper function that hides the block and the code to forward the error. The same example is now very simple, because we only need to write code for the case where we assume success: // Import the module const asyncHandler = require(\"express-async-handler\"); exports.get( \"/about\", asyncHandler(async (req, res, next) => { const successfulResult = await About.find({}).exec(); res.render(\"about_view\", { title: \"About\", list: successfulResult }); }), );\n\nThe URLs that we're ultimately going to need for our pages are listed below, where object is replaced by the name of each of our models (book, bookinstance, genre, author), objects is the plural of object, and id is the unique instance field ( ) that is given to each Mongoose model instance by default.\n• — The list of all books, bookinstances, genres, or authors (e.g. / , / , etc.)\n• — The detail page for a specific book, bookinstance, genre, or author with the given field value (e.g. .\n• — The form to create a new book, bookinstance, genre, or author (e.g. .\n• — The form to update a specific book, bookinstance, genre, or author with the given field value (e.g. .\n• — The form to delete a specific book, bookinstance, genre, or author with the given field value (e.g. . The first home page and list pages don't encode any additional information. While the results returned will depend on the model type and the content in the database, the queries run to get the information will always be the same (similarly the code run for object creation will always be similar). By contrast the other URLs are used to act on a specific document/model instance—these encode the identity of the item in the URL (shown as above). We'll use path parameters to extract the encoded information and pass it to the route handler (and in a later article we'll use this to dynamically determine what information to get from the database). By encoding the information in our URL we only need one route for every resource of a particular type (e.g. one route to handle the display of every single book item). Note: Express allows you to construct your URLs any way you like — you can encode information in the body of the URL as shown above or use URL parameters (e.g. ). Whichever approach you use, the URLs should be kept clean, logical and readable (check out the W3C advice here). Next we create our route handler callback functions and route code for all the above URLs.\n\nOpen the /controllers/authorController.js file and type in the following code: const Author = require(\"../models/author\"); const asyncHandler = require(\"express-async-handler\"); // Display list of all Authors. exports.author_list = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author list\"); }); // Display detail page for a specific Author. exports.author_detail = asyncHandler(async (req, res, next) => { res.send(`NOT IMPLEMENTED: Author detail: ${req.params.id}`); }); // Display Author create form on GET. exports.author_create_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author create GET\"); }); // Handle Author create on POST. exports.author_create_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author create POST\"); }); // Display Author delete form on GET. exports.author_delete_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author delete GET\"); }); // Handle Author delete on POST. exports.author_delete_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author delete POST\"); }); // Display Author update form on GET. exports.author_update_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author update GET\"); }); // Handle Author update on POST. exports.author_update_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Author update POST\"); }); The module first requires the model that we'll later be using to access and update our data, and the wrapper we'll use to catch any exceptions thrown in our route handler functions. It then exports functions for each of the URLs we wish to handle. Note that the create, update and delete operations use forms, and hence also have additional methods for handling form post requests — we'll discuss those methods in the \"forms article\" later on. The functions all use the wrapper function described above in Handling exceptions in route functions, with arguments for the request, response, and next. The functions respond with a string indicating that the associated page has not yet been created. If a controller function is expected to receive path parameters, these are output in the message string (see above). Note that once implemented, some route functions might not contain any code that can throw exceptions. We can change those back to \"normal\" route handler functions when we get to them. Open the /controllers/bookinstanceController.js file and copy in the following code (this follows an identical pattern to the controller module): const BookInstance = require(\"../models/bookinstance\"); const asyncHandler = require(\"express-async-handler\"); // Display list of all BookInstances. exports.bookinstance_list = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance list\"); }); // Display detail page for a specific BookInstance. exports.bookinstance_detail = asyncHandler(async (req, res, next) => { res.send(`NOT IMPLEMENTED: BookInstance detail: ${req.params.id}`); }); // Display BookInstance create form on GET. exports.bookinstance_create_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance create GET\"); }); // Handle BookInstance create on POST. exports.bookinstance_create_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance create POST\"); }); // Display BookInstance delete form on GET. exports.bookinstance_delete_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance delete GET\"); }); // Handle BookInstance delete on POST. exports.bookinstance_delete_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance delete POST\"); }); // Display BookInstance update form on GET. exports.bookinstance_update_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance update GET\"); }); // Handle bookinstance update on POST. exports.bookinstance_update_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: BookInstance update POST\"); }); Open the /controllers/genreController.js file and copy in the following text (this follows an identical pattern to the and files): const Genre = require(\"../models/genre\"); const asyncHandler = require(\"express-async-handler\"); // Display list of all Genre. exports.genre_list = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre list\"); }); // Display detail page for a specific Genre. exports.genre_detail = asyncHandler(async (req, res, next) => { res.send(`NOT IMPLEMENTED: Genre detail: ${req.params.id}`); }); // Display Genre create form on GET. exports.genre_create_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre create GET\"); }); // Handle Genre create on POST. exports.genre_create_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre create POST\"); }); // Display Genre delete form on GET. exports.genre_delete_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre delete GET\"); }); // Handle Genre delete on POST. exports.genre_delete_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre delete POST\"); }); // Display Genre update form on GET. exports.genre_update_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre update GET\"); }); // Handle Genre update on POST. exports.genre_update_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Genre update POST\"); }); Open the /controllers/bookController.js file and copy in the following code. This follows the same pattern as the other controller modules, but additionally has an function for displaying the site welcome page: const Book = require(\"../models/book\"); const asyncHandler = require(\"express-async-handler\"); exports.index = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Site Home Page\"); }); // Display list of all books. exports.book_list = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book list\"); }); // Display detail page for a specific book. exports.book_detail = asyncHandler(async (req, res, next) => { res.send(`NOT IMPLEMENTED: Book detail: ${req.params.id}`); }); // Display book create form on GET. exports.book_create_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book create GET\"); }); // Handle book create on POST. exports.book_create_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book create POST\"); }); // Display book delete form on GET. exports.book_delete_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book delete GET\"); }); // Handle book delete on POST. exports.book_delete_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book delete POST\"); }); // Display book update form on GET. exports.book_update_get = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book update GET\"); }); // Handle book update on POST. exports.book_update_post = asyncHandler(async (req, res, next) => { res.send(\"NOT IMPLEMENTED: Book update POST\"); });\n\nNext we create routes for all the URLs needed by the LocalLibrary website, which will call the controller functions we defined in the previous sections. The skeleton already has a ./routes folder containing routes for the index and users. Create another route file — catalog.js — inside this folder, as shown. Open /routes/catalog.js and copy in the code below: const express = require(\"express\"); const router = express.Router(); // Require controller modules. const book_controller = require(\"../controllers/bookController\"); const author_controller = require(\"../controllers/authorController\"); const genre_controller = require(\"../controllers/genreController\"); const book_instance_controller = require(\"../controllers/bookinstanceController\"); /// BOOK ROUTES /// // GET catalog home page. router.get(\"/\", book_controller.index); // GET request for creating a Book. NOTE This must come before routes that display Book (uses id). router.get(\"/book/create\", book_controller.book_create_get); // POST request for creating Book. router.post(\"/book/create\", book_controller.book_create_post); // GET request to delete Book. router.get(\"/book/:id/delete\", book_controller.book_delete_get); // POST request to delete Book. router.post(\"/book/:id/delete\", book_controller.book_delete_post); // GET request to update Book. router.get(\"/book/:id/update\", book_controller.book_update_get); // POST request to update Book. router.post(\"/book/:id/update\", book_controller.book_update_post); // GET request for one Book. router.get(\"/book/:id\", book_controller.book_detail); // GET request for list of all Book items. router.get(\"/books\", book_controller.book_list); /// AUTHOR ROUTES /// // GET request for creating Author. NOTE This must come before route for id (i.e. display author). router.get(\"/author/create\", author_controller.author_create_get); // POST request for creating Author. router.post(\"/author/create\", author_controller.author_create_post); // GET request to delete Author. router.get(\"/author/:id/delete\", author_controller.author_delete_get); // POST request to delete Author. router.post(\"/author/:id/delete\", author_controller.author_delete_post); // GET request to update Author. router.get(\"/author/:id/update\", author_controller.author_update_get); // POST request to update Author. router.post(\"/author/:id/update\", author_controller.author_update_post); // GET request for one Author. router.get(\"/author/:id\", author_controller.author_detail); // GET request for list of all Authors. router.get(\"/authors\", author_controller.author_list); /// GENRE ROUTES /// // GET request for creating a Genre. NOTE This must come before route that displays Genre (uses id). router.get(\"/genre/create\", genre_controller.genre_create_get); //POST request for creating Genre. router.post(\"/genre/create\", genre_controller.genre_create_post); // GET request to delete Genre. router.get(\"/genre/:id/delete\", genre_controller.genre_delete_get); // POST request to delete Genre. router.post(\"/genre/:id/delete\", genre_controller.genre_delete_post); // GET request to update Genre. router.get(\"/genre/:id/update\", genre_controller.genre_update_get); // POST request to update Genre. router.post(\"/genre/:id/update\", genre_controller.genre_update_post); // GET request for one Genre. router.get(\"/genre/:id\", genre_controller.genre_detail); // GET request for list of all Genre. router.get(\"/genres\", genre_controller.genre_list); /// BOOKINSTANCE ROUTES /// // GET request for creating a BookInstance. NOTE This must come before route that displays BookInstance (uses id). router.get( \"/bookinstance/create\", book_instance_controller.bookinstance_create_get, ); // POST request for creating BookInstance. router.post( \"/bookinstance/create\", book_instance_controller.bookinstance_create_post, ); // GET request to delete BookInstance. router.get( \"/bookinstance/:id/delete\", book_instance_controller.bookinstance_delete_get, ); // POST request to delete BookInstance. router.post( \"/bookinstance/:id/delete\", book_instance_controller.bookinstance_delete_post, ); // GET request to update BookInstance. router.get( \"/bookinstance/:id/update\", book_instance_controller.bookinstance_update_get, ); // POST request to update BookInstance. router.post( \"/bookinstance/:id/update\", book_instance_controller.bookinstance_update_post, ); // GET request for one BookInstance. router.get(\"/bookinstance/:id\", book_instance_controller.bookinstance_detail); // GET request for list of all BookInstance. router.get(\"/bookinstances\", book_instance_controller.bookinstance_list); module.exports = router; The module requires Express and then uses it to create a object. The routes are all set up on the router, which is then exported. The routes are defined either using or methods on the router object. All the paths are defined using strings (we don't use string patterns or regular expressions). Routes that act on some specific resource (e.g. book) use path parameters to get the object id from the URL. The handler functions are all imported from the controller modules we created in the previous section."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/Introduction",
        "document": "A module is a JavaScript library/file that you can import into other code using Node's function. Express itself is a module, as are the middleware and database libraries that we use in our Express applications. The code below shows how we import a module by name, using the Express framework as an example. First we invoke the function, specifying the name of the module as a string ( ), and calling the returned object to create an Express application. We can then access the properties and functions of the application object. You can also create your own modules that can be imported in the same way. Note: You will want to create your own modules, because this allows you to organize your code into manageable parts — a monolithic single-file application is hard to understand and maintain. Using modules also helps you manage your namespace, because only the variables you explicitly export are imported when you use a module. To make objects available outside of a module you just need to expose them as additional properties on the object. For example, the square.js module below is a file that exports and methods: We can import this module using , and then call the exported method(s) as shown: const square = require(\"./square\"); // Here we require() the name of the file without the (optional) .js file extension console.log(`The area of a square with a width of 4 is ${square.area(4)}`); Note: You can also specify an absolute path to the module (or a name, as we did initially). If you want to export a complete object in one assignment instead of building it one property at a time, assign it to as shown below (you can also do this to make the root of the exports object a constructor or other function): Note: You can think of as a shortcut to within a given module. In fact, is just a variable that gets initialized to the value of before the module is evaluated. That value is a reference to an object (empty object in this case). This means that holds a reference to the same object referenced by . It also means that by assigning another value to it's no longer bound to . For a lot more information about modules see Modules (Node API docs).\n\nJavaScript code frequently uses asynchronous rather than synchronous APIs for operations that may take some time to complete. A synchronous API is one in which each operation must complete before the next operation can start. For example, the following log functions are synchronous, and will print the text to the console in order (First, Second). By contrast, an asynchronous API is one in which the API will start an operation and immediately return (before the operation is complete). Once the operation finishes, the API will use some mechanism to perform additional operations. For example, the code below will print out \"Second, First\" because even though method is called first, and returns immediately, the operation doesn't complete for several seconds. Using non-blocking asynchronous APIs is even more important on Node than in the browser because Node is a single-threaded event-driven execution environment. \"Single threaded\" means that all requests to the server are run on the same thread (rather than being spawned off into separate processes). This model is extremely efficient in terms of speed and server resources, but it does mean that if any of your functions call synchronous methods that take a long time to complete, they will block not just the current request, but every other request being handled by your web application. There are a number of ways for an asynchronous API to notify your application that it has completed. The most common way is to register a callback function when you invoke the asynchronous API, that will be called back when the operation completes. This is the approach used above. Note: Using callbacks can be quite \"messy\" if you have a sequence of dependent asynchronous operations that must be performed in order because this results in multiple levels of nested callbacks. This problem is commonly known as \"callback hell\". This problem can be reduced by good coding practices (see http://callbackhell.com/), using a module like async, or refactoring the code to native JavaScript features like Promises and async/await. Node offers the function to do the callback → Promise conversion ergonomically. Note: A common convention for Node and Express is to use error-first callbacks. In this convention, the first value in your callback functions is an error value, while subsequent arguments contain success data. There is a good explanation of why this approach is useful in this blog: The Node.js Way - Understanding Error-First Callbacks (fredkschott.com).\n\nIn our Hello World Express example (see above), we defined a (callback) route handler function for HTTP requests to the site root ( ). The callback function takes a request and a response object as arguments. In this case, the method calls on the response to return the string \"Hello World!\" There are a number of other response methods for ending the request/response cycle, for example, you could call to send a JSON response or to send a file. Note: You can use any argument names you like in the callback functions; when the callback is invoked the first argument will always be the request and the second will always be the response. It makes sense to name them such that you can identify the object you're working with in the body of the callback. The Express application object also provides methods to define route handlers for all the other HTTP verbs, which are mostly used in exactly the same way: There is a special routing method, , which will be called in response to any HTTP method. This is used for loading middleware functions at a particular path for all request methods. The following example (from the Express documentation) shows a handler that will be executed for requests to irrespective of the HTTP verb used (provided it is supported by the http module). app.all(\"/secret\", function (req, res, next) { console.log(\"Accessing the secret section…\"); next(); // pass control to the next handler }); Routes allow you to match particular patterns of characters in a URL, and extract some values from the URL and pass them as parameters to the route handler (as attributes of the request object passed as a parameter). Often it is useful to group route handlers for a particular part of a site together and access them using a common route-prefix (e.g. a site with a Wiki might have all wiki-related routes in one file and have them accessed with a route prefix of /wiki/). In Express this is achieved by using the object. For example, we can create our wiki route in a module named wiki.js, and then export the object, as shown below: Note: Adding routes to the object is just like adding routes to the object (as shown previously). To use the router in our main app file we would then the route module (wiki.js), then call on the Express application to add the Router to the middleware handling path. The two routes will then be accessible from and . We'll show you a lot more about working with routes, and in particular about using the , later on in the linked section Routes and controllers.\n\nMiddleware is used extensively in Express apps, for tasks from serving static files to error handling, to compressing HTTP responses. Whereas route functions end the HTTP request-response cycle by returning some response to the HTTP client, middleware functions typically perform some operation on the request or response and then call the next function in the \"stack\", which might be more middleware or a route handler. The order in which middleware is called is up to the app developer. Note: The middleware can perform any operation, execute any code, make changes to the request and response object, and it can also end the request-response cycle. If it does not end the cycle then it must call to pass control to the next middleware function (or the request will be left hanging). Most apps will use third-party middleware in order to simplify common web development tasks like working with cookies, sessions, user authentication, accessing request and JSON data, logging, etc. You can find a list of middleware packages maintained by the Express team (which also includes other popular 3rd party packages). Other Express packages are available on the npm package manager. To use third party middleware you first need to install it into your app using npm. For example, to install the morgan HTTP request logger middleware, you'd do this: You could then call on the Express application object to add the middleware to the stack: Note: Middleware and routing functions are called in the order that they are declared. For some middleware the order is important (for example if session middleware depends on cookie middleware, then the cookie handler must be added first). It is almost always the case that middleware is called before setting routes, or your route handlers will not have access to functionality added by your middleware. You can write your own middleware functions, and you are likely to have to do so (if only to create error handling code). The only difference between a middleware function and a route handler callback is that middleware functions have a third argument , which middleware functions are expected to call if they are not that which completes the request cycle (when the middleware function is called, this contains the next function that must be called). You can add a middleware function to the processing chain for all responses with , or for a specific HTTP verb using the associated method: , , etc. Routes are specified in the same way for both cases, though the route is optional when calling . The example below shows how you can add the middleware function using both approaches, and with/without a route. const express = require(\"express\"); const app = express(); // An example middleware function const a_middleware_function = function (req, res, next) { // Perform some operations next(); // Call next() so Express will call the next middleware function in the chain. }; // Function added with use() for all routes and verbs app.use(a_middleware_function); // Function added with use() for a specific route app.use(\"/some-route\", a_middleware_function); // A middleware function added for a specific HTTP verb and route app.get(\"/\", a_middleware_function); app.listen(3000); Note: Above we declare the middleware function separately and then set it as the callback. In our previous route handler function we declared the callback function when it was used. In JavaScript, either approach is valid. The Express documentation has a lot more excellent documentation about using and writing Express middleware.\n\nTemplate engines (also referred to as \"view engines\" in Express) allow you to specify the structure of an output document in a template, using placeholders for data that will be filled in when a page is generated. Templates are often used to create HTML, but can also create other types of documents. Express has support for a number of template engines, notably Pug (formerly \"Jade\"), Mustache, and EJS. Each has its own strengths for addressing particular use cases (relative comparisons can easily be found via Internet search). The Express application generator uses Jade as its default, but it also supports several others. In your application settings code you set the template engine to use and the location where Express should look for templates using the 'views' and 'view engine' settings, as shown below (you will also have to install the package containing your template library too!) const express = require(\"express\"); const path = require(\"path\"); const app = express(); // Set directory to contain the templates ('views') app.set(\"views\", path.join(__dirname, \"views\")); // Set view engine to use, in this case 'some_template_engine_name' app.set(\"view engine\", \"some_template_engine_name\"); The appearance of the template will depend on what engine you use. Assuming that you have a template file named \"index.<template_extension>\" that contains placeholders for data variables named 'title' and \"message\", you would call in a route handler function to create and send the HTML response: For more information see Using template engines with Express (Express docs)."
    },
    {
        "link": "https://github.com/expressjs/expressjs.com/blob/gh-pages/en/guide/routing.md",
        "document": "Routing refers to how an application's endpoints (URIs) respond to client requests. For an introduction to routing, see [Basic routing](/{{ page.lang }}/starter/basic-routing.html).\n\nYou define routing using methods of the Express object that correspond to HTTP methods; for example, to handle GET requests and to handle POST requests. For a full list, see [app.METHOD](/{{ page.lang }}/5x/api.html#app.METHOD). You can also use [app.all()](/{{ page.lang }}/5x/api.html#app.all) to handle all HTTP methods and [app.use()](/{{ page.lang }}/5x/api.html#app.use) to specify middleware as the callback function (See [Using middleware](/{{ page.lang }}/guide/using-middleware.html) for details).\n\nThese routing methods specify a callback function (sometimes called \"handler functions\") called when the application receives a request to the specified route (endpoint) and HTTP method. In other words, the application \"listens\" for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.\n\nIn fact, the routing methods can have more than one callback function as arguments. With multiple callback functions, it is important to provide as an argument to the callback function and then call within the body of the function to hand off control to the next callback.\n\nThe following code is an example of a very basic route.\n\nA route method is derived from one of the HTTP methods, and is attached to an instance of the class.\n\nThe following code is an example of routes that are defined for the and the methods to the root of the app.\n\nExpress supports methods that correspond to all HTTP request methods: , , and so on. For a full list, see [app.METHOD](/{{ page.lang }}/5x/api.html#app.METHOD).\n\nThere is a special routing method, , used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route whether using , , , , or any other HTTP request method supported in the http module.\n\nRoute paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.\n\n{% capture caution-character %} In express 5, the characters , , , , and are handled differently than in version 4, please review the [migration guide](/{{ page.lang }}/guide/migrating-5.html#path-syntax) for more information.{% endcapture %}\n\n{% capture note-dollar-character %}In express 4, regular expression characters such as need to be escaped with a . {% endcapture %}\n\n{% capture note-path-to-regexp %} Express uses path-to-regexp for matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths. Express Playground Router is a handy tool for testing basic Express routes, although it does not support pattern matching. {% endcapture %}\n\n{% include admonitions/warning.html content=\"Query strings are not part of the route path.\" %}\n\nThis route path will match requests to the root route, .\n\nThis route path will match requests to .\n\nThis route path will match requests to .\n\n{% capture caution-string-patterns %} The string patterns in Express 5 no longer work. Please refer to the [migration guide](/{{ page.lang }}/guide/migrating-5.html#path-syntax) for more information.{% endcapture %}\n\nThis route path will match and .\n\nThis route path will match , , , and so on.\n\nThis route path will match , , , , and so on.\n\nThis route path will match and .\n\nThis route path will match anything with an \"a\" in it.\n\nThis route path will match and , but not , , and so on.\n\nRoute parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the object, with the name of the route parameter specified in the path as their respective keys.\n\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below.\n\nThe name of route parameters must be made up of \"word characters\" ([A-Za-z0-9_]).\n\nSince the hyphen ( ) and the dot ( ) are interpreted literally, they can be used along with route parameters for useful purposes.\n\n{% capture warning-regexp %} In express 5, Regexp characters are not supported in route paths, for more information please refer to the [migration guide](/{{ page.lang }}/guide/migrating-5.html#path-syntax).{% endcapture %}\n\nTo have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses ( ):\n\n{% include admonitions/warning.html content=\"Because the regular expression is usually part of a literal string, be sure to escape any characters with an additional backslash, for example .\" %}\n\n{% capture warning-version %} In Express 4.x, the character in regular expressions is not interpreted in the usual way. As a workaround, use instead of . This will likely be fixed in Express 5. {% endcapture %}\n\nYou can provide multiple callback functions that behave like [middleware](/{{ page.lang }}/guide/using-middleware.html) to handle a request. The only exception is that these callbacks might invoke to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there's no reason to proceed with the current route.\n\nRoute handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.\n\nA single callback function can handle a route. For example:\n\nMore than one callback function can handle a route (make sure you specify the object). For example:\n\nAn array of callback functions can handle a route. For example:\n\nA combination of independent functions and arrays of functions can handle a route. For example:\n\nThe methods on the response object ( ) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.\n\nYou can create chainable route handlers for a route path by using . Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: [Router() documentation](/{{ page.lang }}/5x/api.html#router).\n\nHere is an example of chained route handlers that are defined by using .\n\nUse the class to create modular, mountable route handlers. A instance is a complete middleware and routing system; for this reason, it is often referred to as a \"mini-app\".\n\nThe following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.\n\nCreate a router file named in the app directory, with the following content:\n\nThen, load the router module in the app:\n\nThe app will now be able to handle requests to and , as well as call the middleware function that is specific to the route.\n\nBut if the parent route has path parameters, it will not be accessible by default from the sub-routes. To make it accessible, you will need to pass the option to the Router constructor [reference](/{{ page.lang }}/5x/api.html#app.use)."
    },
    {
        "link": "https://stackoverflow.com/questions/24501756/sort-mongodb-documents-by-timestamp-in-desc-order",
        "document": "I have a bunch of documents in mongodb and all have a timestamp field with timestamp stored as \"1404008160\". I want to sort all docs in this collection by desc order. I do it by:\n\nHowever, I don't get results sorted by timestamp in desc order. I am thinking it's because timestamp is being treated as an int field. Is there a work around this without changing data type of timestamp field. I already have a lot of data in this collection so don't want to go through the hassle of import/export, etc.\n\nAlso - I want to keep the load for sorting to mongodb rather than doing it programmatically in python.\n\nTo be clear: Timestamp does not indicate when the document was created and it is stored as string (e.g. \"1404217646\")."
    },
    {
        "link": "https://mongodb.com/community/forums/t/sorting-with-mongoose-and-mongodb/122573",
        "document": "I have a userModel that has about 5 fields that I would like to be sorted in Ascending or Descending when I find({}) them. Everything I have read from the documentation suggests that this should work but it’s not working. This query only returns a correct order for the first value e.g firstName and returns a non-sorted result for the rest. These are the different sorting techniques that I’ve tried to implement and all return the same result. if I try to flip to Descending order, the exact same behaviour occurs. I Also tried to create an index before sorting but still, only the first field is getting sorted const UserSchema = new mongoose.Schema( { firstName: { type: String, required: [true, \"Please enter a valid first name.\"], }, lastName: { type: String, required: [true, \"Please enter a valid last name.\"], }, email: { type: String, required: [true, \"Please provide a valid email address.\"], unique: true }, createdAt: { type: Date, default: null, }, updatedAt: { type: Date, default: null, }, ) UserSchema.index({firstName: 1, lastName:1 ,email:1, createdAt:1 , updatedAt: 1 }) export default mongoose.models.User || mongoose.model(\"User\", UserSchema)\n\nHello @muhammed_ogunsanya, welcome to the community\n\n takes an object as parameter where the values are or \n\n Use for descending order and for ascending\n\n same idea goes for index creation\n\n eg: if you want to reverse the order use the last sort is covered by the index (in backward), while the first two will do an in memory sort Hope that was informative, take care\n\ni changed the values because of company policy. but what i’m expecting is when i try to sort by any field, i should get them either by asc or desc depending on which i specify. but it on returns the correct other for whichever field i pass in the first position. e.g wlll return in descending order for firstName alone\n\nYour example does not show the case of sorting with multiple fields\n\n means that mongodb will sort in descending order according to the . if two documents have the same mongodb will check there \n\n example:\n\n given the following documents note that is used only when the two documents have the same"
    },
    {
        "link": "https://stackoverflow.com/questions/72174970/how-to-sort-order-by-descending-in-mongo-query",
        "document": "You can use auto-generated-createdat-and-updatedat-fields-in-mongodb, then use the $orderby operator to order it descending. It may be worth it to add an index on those fields if you expect your table to grow."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-sort-a-collection-by-date-in-mongodb",
        "document": "In MongoDB, sorting collections by date is a common requirement for many applications. Sorting by date allows us to display data in reverse order, making it easier for users to understand and analyze. In this article, we will explore different approaches to sorting collections by date in MongoDB, using various techniques and methods along with examples and so on.\n\nHow to Sort by Date in MongoDB\n\nIn many applications, especially those dealing with time-series data or event logs, there is a common need to sort documents based on their date. For example, consider an application that tracks user activities such as logging in, making purchases or interacting with content. Being able to sort these activities can provide valuable output into user behavior over time. Below are the two methods in the MongoDB that allow to sort a collection by date are as follow:\n\nLet's set up an environment to sort a collection by date in MongoDB.\n\nTo understand How to sort a collection by date in MongoDB we need a document on which we will perform various operations and queries. Here we will consider a collection of events that consists of the below records into it. So we have considered a collection named \"events\" containing documents with a \"timestamp\" field representing the date of the event.\n\nWe use the sort() method with a value of 1 for the date field to sort documents in ascending order by date.\n\nIn this example, a collection named \"events\" contains documents with a \"timestamp\" field representing the date of the event. The query retrieves documents from the \"events\" collection and sorts them in ascending order by the \"timestamp\" field.\n\nExplanation: In the above Query, We retrieves documents from the collection and sorts them in ascending order based on the field.\n\nWe use the sort() method with a value of '-1' for the date field to sort documents in descending order by date.\n\nIn this example, The query retrieves documents from the \"events\" collection and sorts them by the \"timestamp\" field in descending order.\n\nExplanation: In the above Query, We retrieves documents from the collection and sorts them in descending order based on the field.\n\nOverall, sorting collections by date in MongoDB is important for applications to handle ime-sensitive data. Whether you need to display events or analyze trends over time, sorting by date provides valuable insights. By using the method with either ascending or descending order, you can easily organize your data to meet your applications requirements. Understanding these sorting techniques in MongoDB can greatly enhance your ability to manage and analyze date-based data effectively."
    },
    {
        "link": "https://mongodb.com/community/forums/t/sorting-with-mongoose-find/158594",
        "document": "I have a Model with {timestamps : true}.\n\n I want that every time i create a new post it will show at the top of the page. I tried with .sort (createdAt: -1) but it didn’t work. Pls help and thankyou guys\n\n\n\nCan you check in the database if properties are added to the documents? Also, you can actually do the sorting with if it’s of the type ObjectId:\n\nI checked the database, the prop createdAt already added but something wrong with my database, it shows only one data even though i don’t use any query. As before, a list will be displayed.\n\n And i tried sort with _id, same result. when i create a new post, it still shows at the end of the array\n\n\n\nThen the issue is not with . You have only one document inside the collection, so only that document will be returned. You should add more new documents and then check if the is working.\n\nBut wait, you added to the query, right? That is why you have only one document returned."
    }
]