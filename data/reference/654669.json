[
    {
        "link": "https://github.com/google/traceur-compiler/issues/1007",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://github.com/google/traceur-compiler/wiki/Options-for-Compiling",
        "document": "Various options control which EcmaScript features are allowed in the source and what kind of output will be generated. The compile options are enumerated in Options.js. You can experiment with the options in the REPL page using the Options control in the upper right corner.\n\nThe command line ( )supports these options by using , as well as a few more options:\n\nThe arguments should just be the 'root' modules, traceur will pull the rest. So for example if requires requires , only list on the command line.\n\nTo set options when compiling in the browser, use , e.g.:\n• modules='amd': each input module creates an output file in AMD format. eg\n• modules='commonjs': each input module creates an output file in ?\n• modules='inline': All dependencies of the root modules and/or scripts are compiled into a long script that creates modules upon execution then runs the dependents.\n• modules='bootstrap': All dependencies of the root modules and/or scripts are compiled in to functions that register the modules then execute any scripts.\n\nThe option allows you to set the value; use on the command line or in code to cause the to be the input file name. This option is not normally required."
    },
    {
        "link": "http://students.aiu.edu/submissions/profiles/resources/onlineBook/R7C4g8_Mastering_JavaScript_Design_Patterns.pdf",
        "document": ""
    },
    {
        "link": "http://digitalbreakdown.net/sandbox/Ebooks/JavaScript-Cookbook-2nd-Edition.pdf",
        "document": ""
    },
    {
        "link": "https://pepa.holla.cz/wp-content/uploads/2016/08/JavaScript-Cookbook-2nd-Edition.pdf",
        "document": ""
    },
    {
        "link": "https://dev.to/jps27cse/understanding-prototype-inheritance-and-es6-classes-in-javascript-3ddl",
        "document": "JavaScript has a different inheritance mechanism than most conventional OOP languages. Prototypes are the main focus, whereas ES6 classes offer a more contemporary method. Let's examine how ES6 classes improve readability and usefulness as well as how prototype inheritance operates.\n\nEvery object in JavaScript has an internal link to another object called its prototype. This prototype object can have its own prototype, forming a chain.\n\nExplanation:\n\n\n\n Here, inherits from . This demonstrates how objects can share properties through inheritance.\n\nBefore ES6 classes, JavaScript used constructor functions to create objects and initialize their properties.\n\nExplanation:\n\n\n\n The constructor initializes . The property is added through the , enabling inheritance.\n\nA master object serves as the prototype for other objects.\n\nExplanation:\n\n\n\n is the common ancestor, and inherits its property while adding .\n\nJavaScript looks up the prototype chain to find properties and methods.\n\nExplanation:\n\n\n\n The object looks for . It finds 's , demonstrating how the prototype chain resolves property lookups.\n\nExplanation:\n\n\n\n inherits from , allowing it to access . It also defines its own method.\n\nES6 introduced a cleaner, more intuitive way to create classes.\n\nExplanation:\n\n\n\n This class-based syntax simplifies the creation and inheritance of objects, making the code more readable.\n\nES6 allows defining methods to access or modify object properties dynamically.\n\nExplanation:\n\n\n\n is a computed property using a getter and setter, allowing dynamic updates.\n\nStatic methods belong to the class itself and not to instances.\n\nExplanation:\n\n\n\n is a static method accessible directly on , useful for utility functions.\n\nPolymorphism allows subclasses to redefine methods from the parent class.\n\nExplanation:\n\n\n\n overrides from , providing its own implementation.\n\nThe foundation of JavaScript object-oriented programming is made up of ES6 classes and prototype inheritance. Writing reusable, maintainable code is improved by knowing how to use constructor functions, prototypes, and ES6 classes. To fully utilize JavaScript's inheritance paradigm, embrace these ideas!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes",
        "document": "JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes. In many other languages, classes, or constructors, are clearly distinguished from objects, or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the operator with a constructor function to create a new object. We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide. This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.\n\nPerhaps the most important job of a class is to act as a \"factory\" for objects. For example, when we use the constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor. As an example, we would create a class called , which represents a specific color. Users create colors through passing in an RGB triplet. class Color { constructor(r, g, b) { // Assign the RGB values as a property of `this`. this.values = [r, g, b]; } } Open your browser's devtools, paste the above code into the console, and then create an instance: You should see some output like this: You have successfully created a instance, and the instance has a property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following: The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters: class Color { constructor(...values) { this.values = values; } } const red = new Color(255, 0, 0); // Creates an instance with the same shape as above. Each time you call , a different instance is created. Within a class constructor, the value of points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next). The value will be automatically returned as the result of . You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the expression, and the value of is dropped. (You can read more about what does in its description.)\n\nIf a class only has a constructor, it is not much different from a factory function which just creates plain objects. However, the power of classes is that they can be used as \"templates\" which automatically assign methods to instances. For example, for instances, you can use a range of methods to get different information from a single date value, such as the year, month, day of the week, etc. You can also set those values through the counterparts like . For our own class, we can add a method called which returns the red value of the color. Without methods, you may be tempted to define the function within the constructor: This also works. However, a problem is that this creates a new function every time a instance is created, even when they all do the same thing! In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or , which is explained in more detail in Inheritance and the prototype chain. Similarly, we can create a new method called , which sets the red value of the color. class Color { constructor(r, g, b) { this.values = [r, g, b]; } getRed() { return this.values[0]; } setRed(value) { this.values[0] = value; } } const red = new Color(255, 0, 0); red.setRed(0); console.log(red.getRed()); // 0; of course, it should be called \"black\" at this stage!\n\nYou might be wondering: why do we want to go to the trouble of using and methods, when we can directly access the array on the instance? There is a philosophy in object-oriented programming called \"encapsulation\". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead: class Color { constructor(r, g, b) { // values is now an HSL array! this.values = rgbToHSL([r, g, b]); } getRed() { return this.values[0]; } setRed(value) { this.values[0] = value; } } const red = new Color(255, 0, 0); console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0 The user assumption that means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some \"harmless refactors\". In classes, this is done through private fields. A private field is an identifier prefixed with (the hash symbol). The hash is an integral part of the field's name, which means a private property can never have name clash with a public property. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private property on the fly). Apart from this, a private field is pretty much equivalent to a normal property. class Color { // Declare: every Color instance has a private field called #values. #values; constructor(r, g, b) { this.#values = [r, g, b]; } getRed() { return this.#values[0]; } setRed(value) { this.#values[0] = value; } } const red = new Color(255, 0, 0); console.log(red.getRed()); // 255 Accessing private fields outside the class is an early syntax error. The language can guard against this because is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code. console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class Note: Code run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction. Private fields in JavaScript are hard private: if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same. After we've made the field private, we can add some more logic in the and methods, instead of making them simple pass-through methods. For example, we can add a check in to see if it's a valid R value: class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } getRed() { return this.#values[0]; } setRed(value) { if (value < 0 || value > 255) { throw new RangeError(\"Invalid R value\"); } this.#values[0] = value; } } const red = new Color(255, 0, 0); red.setRed(1000); // RangeError: Invalid R value If we leave the property exposed, our users can easily circumvent that check by assigning to directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream. A class method can read the private fields of other instances, as long as they belong to the same class. class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } redDifference(anotherColor) { // #values doesn't necessarily need to be accessed from this: // you can access private fields of other instances belonging // to the same class. return this.#values[0] - anotherColor.#values[0]; } } const red = new Color(255, 0, 0); const crimson = new Color(220, 20, 60); red.redDifference(crimson); // 35 However, if is not a Color instance, won't exist. (Even if another class has an identically named private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private property throws an error instead of returning like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using / to handle the error, you can use the operator. class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } redDifference(anotherColor) { if (!(#values in anotherColor)) { throw new TypeError(\"Color instance expected\"); } return this.#values[0] - anotherColor.#values[0]; } } Note: Keep in mind that the is a special identifier syntax, and you can't use the field name as if it's a string. would look for a property name literally called , instead of a private field. There are some limitations in using private properties: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors. Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call. For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it. In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of .\n\nWith the example, we have also encountered the method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the class instead of being exposed as a global function, because it's mostly useful when dealing with date instances. Note: Prefixing utility methods with what they deal with is called \"namespacing\" and is considered a good practice. For example, in addition to the older, unprefixed method, JavaScript also later added the prefixed method to indicate that it's for dealing with numbers. Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include: Everything also has private counterparts. For example, for our class, we can create a static method that checks whether a given triplet is a valid RGB value: Static properties are very similar to their instance counterparts, except that:\n• They are all prefixed with , and\n• They are not accessible from instances. There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded. Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private properties.\n\nA key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance, which means one object can \"borrow\" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic. For example, suppose our class now needs to support transparency. We may be tempted to add a new field that indicates its transparency: class Color { #values; constructor(r, g, b, a = 1) { this.#values = [r, g, b, a]; } get alpha() { return this.#values[3]; } set alpha(value) { if (value < 0 || value > 1) { throw new RangeError(\"Alpha value must be between 0 and 1\"); } this.#values[3] = value; } } However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our class will become very bloated and hard to maintain. Instead, in object-oriented programming, we would create a derived class. The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an clause, which indicates the class it extends from. class ColorWithAlpha extends Color { #alpha; constructor(r, g, b, a) { super(r, g, b); this.#alpha = a; } get alpha() { return this.#alpha; } set alpha(value) { if (value < 0 || value > 1) { throw new RangeError(\"Alpha value must be between 0 and 1\"); } this.#alpha = value; } } There are a few things that have immediately come to attention. First is that in the constructor, we are calling . It is a language requirement to call before accessing . The call calls the parent class's constructor to initialize — here it's roughly equivalent to . You can have code before , but you cannot access before — the language prevents you from accessing the uninitialized . After the parent class is done with modifying , the derived class can do its own logic. Here we added a private field called , and also provided a pair of getter/setters to interact with them. A derived class inherits all methods from its parent. For example, although doesn't declare a accessor itself, you can still access because this behavior is specified by the parent class: Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the class, which defines some basic methods like . However, the base method is notoriously useless, because it prints in most cases: Instead, our class can override it to print the color's RGB values: Within derived classes, you can access the parent class's methods by using . This allows you to build enhancement methods and avoid code duplication. class ColorWithAlpha extends Color { #alpha; // … toString() { // Call the parent class's toString() and build on the return value return `${super.toString()}, ${this.#alpha}`; } } console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5' When you use , the static methods inherit from each other as well, so you can also override or enhance them. class ColorWithAlpha extends Color { // ... static isValid(r, g, b, a) { // Call the parent class's isValid() and build on the return value return super.isValid(r, g, b) && a >= 0 && a <= 1; } } console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being \"hard private\". Private fields are scoped to the class body itself and do not grant access to any outside code. class ColorWithAlpha extends Color { log() { console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class } } A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem. However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins. Instances of derived classes are also instances of the base class.\n\nThe guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends. Classes introduce a paradigm, or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism). However, many people are philosophically against certain OOP practices and don't use classes as a result. For example, one thing that makes objects infamous is that they're mutable. function incrementDay(date) { return date.setDate(date.getDate() + 1); } const date = new Date(); // 2019-06-19 const newDay = incrementDay(date); console.log(newDay); // 2019-06-20 // The old date is modified as well!? console.log(date); // 2019-06-20 Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program. In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns. However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient. On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the class, we may need to create a dozen of utility functions: But with classes, we can congregate them all under the namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API. In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:\n• The and classes store a collection of elements and allow you to access them by key using , , , etc.\n• The class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.\n• The class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like and that extend . In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with . JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion."
    },
    {
        "link": "https://forum.freecodecamp.org/t/modules-and-prototypes-with-es6-classes/252234",
        "document": "I recently finished the Object Oriented Programming section under Algorithms And Data Structures Cert and its mainly about using prototypes, inheritance and setting up an IIFE but it didnt touch on classes. In a recent freeCodeCamp video with Beau about modules from 3 months ago, he outlines the IIFE method as being old and says “theres a new way to do it”. Do classes replace the need to write prototype code such as this? I’m really lost now as to how this sort of code ties in with using classes in ES6, does anyone know of a medium article or something similar that goes over how all these concepts work together? Thanks in advance to anyone who has any suggestions\n\nYes, they do. Use of ES6 classes is, mostly, a cosmetic lift on what we already have. Behind the scenes, the methods defined in the class are being assigned to the constructor’s prototype. So you’re not seeing it happen, but it’s happening all the same. Oddly, there was another question a little while ago about how to view the methods attached to the class (rather than the methods attached to an object). I got something to do just that, but it does demonstrate that the methods defined in your class are being attached to the class prototype. Here’s a link to the repl where I was testing that. The relevant bit of code that shows the prototype bits is: // All our other initialization has happened. But the class has been defined, // so we can get at its prototype. Note that I defined .getAllMethods() in my // class, per ES6, and that it is attached to the prototype automagically. let myClassMethods = this.constructor.prototype.getAllMethods(); console.log(\"And the class methods IN THE CONSTRUCTOR: \", myClassMethods)\n\nThanks for your reply, it clearly a few things up In the link, whats the reason for having the getAllMethods() function in the main class instead of just directly defining them within the constructor? Wouldnt they already be in the prototype of any child classes if they were just defined in the constructor without needing the myClassMethods object?\n\nSO… within that same repl, I’ve created another class, (I know, politically incorrect. Sue me.) – and within the constructor for that, I attached the function. If you wander back to the repl, you’ll see – Fred is an instance of Businessman. But methods attached within the constructor (using ) are attached to the instance, not to the constructor.\n\nSo the only way to insert methods into the parent prototype(Person) to be passed down the prototype chain using ES6 classes is to assign the methods object in the constructor like you did here?\n\n let myClassMethods = this.constructor.prototype.getAllMethods();? I feel like ive seen methods being added to the prototype in classes in a different way before, but it sounds like I’m probably wrong Thanks for your help though, its making a bit more sense now.\n\nNope. You can still attach them by the after the fact if you want. You have both options. Just know that, if you do, future developers encountering your code may be sharpening their pitchforks. There are a few reasons you may want to be able to mix and match, both to attach methods within the class and add them by prototype – for example, suppose you’ve created mixin methods. It would make sense, in that case, do define the class-specific methods within the class definition, but ones that you use generically can be assigned by ES6 classes don’t take away anything from what you’ve learned. That all still works. It is creating a prototype exactly as you are used to. It simply gives you the option.\n\nThat particular repl got really really meaty. Not only do we have the class method conversation going on (with ), but we looked at how to attach instance methods using classes (in the class, using the keyword in the constructor), and I toyed with using within a constructor to bind the class methods to the current instance (in the class). The reason I called that one is because of the mechanism used to bind the class methods to the instance – they are being cloned into the instance itself. We can see that when I call – it shows all the constructor methods as being directly attached to the instance. I really enjoyed both of these conversations, and I really REALLY learned a lot in trying to find answers for both. Thank you for the opportunity, @korora747 and @aykutkardas – the challenge and the experimenting were very rewarding."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/js-objects-prototypes-classes",
        "document": "Considering the fact that almost everything in JavaScript is an object, object oriented JavaScript code is very different from other object-capable languages. The JS object system is more of a prototype-based object system instead.\n\nComing from a C++ background, I was aware of the Object Oriented programming paradigm and had a very rigid idea of how Objects and Classes should work. Exposure to other languages like Java only seemed to further establish this idea. While these languages have their own semantics on how objects and classes work; Javascript, for the new user, is quite a revelation.\n\nFirst off the bat, JavaScript objects are very different in the way they are created. There is no requirement for a class. Object instances can be created using the new operator:\n\nSecond, JavaScript objects are very flexible. While classic object oriented languages allow only property modification or property slots, JavaScript allows objects to modify their properties and methods; i.e. JavaScript objects have both property and method slots.\n\nMy first thought at the discovery was “yeah freedom!” but this came with a cost - a need to understand the prototype property in JavaScript. The knowledge of the prototype is essential to a developer who wishes to implement any semblance of an object oriented system in JavaScript.\n\nAll JavaScript objects are created from the constructor:\n\nAnd the allows us to add new methods to objects constructors, this means that the following method now exists in all instances of .\n\nObject instances of can be now created:\n\nThe of the object is now the basis for inheritance, the method is accessible to both and because the of has this method. The property is shared amongst all its instances and is accessible via the property of a particular instance.\n\nNow, because of the existence of method slots and a common instance property being shared across all instances, some very neat tricks are possible which are very weird to C++ folks:\n\nChange one instance’s property or method, all instances of the object are affected. This means we could be deleting stuff as well. A croc tired of drowning could potentially do this:\n\nNow no one gets to swim.\n\nThis is just a silly example to show how fundamental the is to the Object system in JavaScript and how it can be quite jarring to people from other object oriented languages.\n\nWith the ES6 syntax, JavaScript has been provided the feature to create classes.\n\nHowever, the concept of true classes does not exist in JavaScript but it is emulated through and the class syntax is just syntactic sugar around it. Therefore, understanding this behavior is important to realize the convenience and limitations of ES6 classes.\n\nWith the new syntax, would be defined as:\n\nThis does not mean it brings nothing new to the offer for users, some pitfalls can be avoided by using ES6 classes, like making the keyword mandatory for creating instances.\n\nThis is actually a good thing, since it prevents accessing the wrong context when using the object properties and methods, which is usually the global scope or the window object.\n\nThough JavaScript right now does certainly lack features like truly private members. It has made creating objects via class syntax, instead of prototypes closely resemble classes from other OO languages like C++/Java.\n\nPS. There has been a proposal to TC39 for creating truly private members in JavaScript classes, you can follow it here and contribute your opinion. If it were to be included in the next revision, then we’d have something like:"
    },
    {
        "link": "https://reddit.com/r/javascript/comments/4bmiqj/using_classes_in_javascript_es6_best_practice",
        "document": "Coming from languages like C++, it was very strange to not have class declarations in Javascript.\n\nHowever, according to the documentation of ES6, it looks like they have introduced class declarations to keep things clearer and simpler. Syntax (see: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes):\n\nMy question, then, is whether it is now considered a best practice to make use of classes and class declarations, as opposed to continuing on with the non-class system of old Javascript."
    }
]