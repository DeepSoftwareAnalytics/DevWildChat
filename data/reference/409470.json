[
    {
        "link": "https://doc.qt.io/qt-6/qgraphicsview.html",
        "document": "The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. More...\n\nQGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework. To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example: You can explicitly scroll to any position on the scene by using the scroll bars, or by calling centerOn(). By passing a point to centerOn(), QGraphicsView will scroll its viewport to ensure that the point is centered in the view. An overload is provided for scrolling to a QGraphicsItem, in which case QGraphicsView will see to that the center of the item is centered in the view. If all you want is to ensure that a certain area is visible, (but not necessarily centered,) you can call ensureVisible() instead. QGraphicsView can be used to visualize a whole scene, or only parts of it. The visualized area is by default detected automatically when the view is displayed for the first time (by calling QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle yourself, you can call setSceneRect(). This will adjust the scroll bars' ranges appropriately. Note that although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). QGraphicsView visualizes the scene by calling render(). By default, the items are drawn onto the viewport by using a regular QPainter, and using default render hints. To change the default render hints that QGraphicsView passes to QPainter when painting items, you can call setRenderHints(). By default, QGraphicsView provides a regular QWidget for the viewport widget. You can access this widget by calling viewport(), or you can replace it by calling setViewport(). To render using OpenGL, simply call setViewport(new QOpenGLWidget). QGraphicsView takes ownership of the viewport widget. QGraphicsView supports affine transformations, using QTransform. You can either pass a matrix to setTransform(), or you can call one of the convenience functions rotate(), scale(), translate() or shear(). The most two common transformations are scaling, which is used to implement zooming, and rotation. QGraphicsView keeps the center of the view fixed during a transformation. Because of the scene alignment (setAlignment()), translating the view will have no visual impact. You can interact with the items on the scene by using the mouse and keyboard. QGraphicsView translates the mouse and key events into scene events, (events that inherit QGraphicsSceneEvent,), and forward them to the visualized scene. In the end, it's the individual item that handles the events and reacts to them. For example, if you click on a selectable item, the item will typically let the scene know that it has been selected, and it will also redraw itself to display a selection rectangle. Similarly, if you click and drag the mouse to move a movable item, it's the item that handles the mouse moves and moves itself. Item interaction is enabled by default, and you can toggle it by calling setInteractive(). You can also provide your own custom scene interaction, by creating a subclass of QGraphicsView, and reimplementing the mouse and key event handlers. To simplify how you programmatically interact with items in the view, QGraphicsView provides the mapping functions mapToScene() and mapFromScene(), and the item accessors items() and itemAt(). These functions allow you to map points, rectangles, polygons and paths between view coordinates and scene coordinates, and to find items on the scene using view coordinates. When using a QOpenGLWidget as a viewport, stereoscopic rendering is supported. This is done using the same pattern as QOpenGLWidget::paintGL. To enable it, enable the QSurfaceFormat::StereoBuffers flag. Because of how the flag is handled internally, set QSurfaceFormat::StereoBuffers flag globally before the window is created using QSurfaceFormat::setDefaultFormat(). If the flag is enabled and there is hardware support for stereoscopic rendering, then drawBackground() and drawForeground() will be triggered twice each frame. Call QOpenGLWidget::currentTargetBuffer() to query which buffer is currently being drawn to. Note: Using an OpenGL viewport limits the ability to use QGraphicsProxyWidget. Not all combinations of widgets and styles can be supported with such a setup. You should carefully test your UI and make the necessary adjustments.\n\nSee also QGraphicsScene, QGraphicsItem, and QGraphicsSceneEvent.\n\nThis enum describes the flags that you can set for a QGraphicsView's cache mode. All painting is done directly onto the viewport. The background is cached. This affects both custom backgrounds, and backgrounds based on the backgroundBrush property. When this flag is enabled, QGraphicsView will allocate one pixmap with the full size of the viewport. The CacheMode type is a typedef for QFlags<CacheModeFlag>. It stores an OR combination of CacheModeFlag values. This enum describes the default action for the view when pressing and dragging the mouse over the viewport. Nothing happens; the mouse event is ignored. The cursor changes into a pointing hand, and dragging the mouse around will scroll the scrolbars. This mode works both in interactive and non-interactive mode. A rubber band will appear. Dragging the mouse will set the rubber band geometry, and all items covered by the rubber band are selected. This mode is disabled for non-interactive views. See also dragMode and QGraphicsScene::setSelectionArea(). This enum describes flags that you can enable to improve rendering performance in QGraphicsView. By default, none of these flags are set. Note that setting a flag usually imposes a side effect, and this effect can vary between paint devices and platforms. When rendering, QGraphicsView protects the painter state (see QPainter::save()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call QPainter::setPen() or QPainter::setBrush() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent QGraphicsView from doing the same. Disables QGraphicsView's antialiasing auto-adjustment of exposed areas. Items that render antialiased lines on the boundaries of their QGraphicsItem::boundingRect() can end up rendering parts of the line outside. To prevent rendering artifacts, QGraphicsView expands all exposed regions by 2 pixels in all directions. If you enable this flag, QGraphicsView will no longer perform these adjustments, minimizing the areas that require redrawing, which improves performance. A common side effect is that items that do draw with antialiasing can leave painting traces behind on the scene as they are moved. Since Qt 4.6, restore the old painting algorithm that calls QGraphicsView::drawItems() and QGraphicsScene::drawItems(). To be used only for compatibility with old code. The OptimizationFlags type is a typedef for QFlags<OptimizationFlag>. It stores an OR combination of OptimizationFlag values. This enums describe the possible anchors that QGraphicsView can use when the user resizes the view or when the view is transformed. No anchor, i.e. the view leaves the scene's position unchanged. The scene point at the center of the view is used as the anchor. The point under the mouse is used as the anchor. See also resizeAnchor and transformationAnchor. This enum describes how QGraphicsView updates its viewport when the scene contents change or are exposed. When any visible part of the scene changes or is reexposed, QGraphicsView will update the entire viewport. This approach is fastest when QGraphicsView spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QOpenGLWidget, and for viewports that need to disable scroll optimization. QGraphicsView will determine the minimal viewport region that requires a redraw, minimizing the time spent drawing by avoiding a redraw of areas that have not changed. This is QGraphicsView's default mode. Although this approach provides the best performance in general, if there are many small visible changes on the scene, QGraphicsView might end up spending more time finding the minimal approach than it will spend drawing. QGraphicsView will attempt to find an optimal update mode by analyzing the areas that require a redraw. The bounding rectangle of all changes in the viewport will be redrawn. This mode has the advantage that QGraphicsView searches only one region for changes, minimizing time spent determining what needs redrawing. The disadvantage is that areas that have not changed also need to be redrawn. QGraphicsView will never update its viewport when the scene changes; the user is expected to control all updates. This mode disables all (potentially slow) item visibility testing in QGraphicsView, and is suitable for scenes that either require a fixed frame rate, or where the viewport is otherwise updated externally.\n\nThis property holds the alignment of the scene in the view when the whole scene is visible. If the whole scene is visible in the view, (i.e., there are no visible scroll bars,) the view's alignment will decide where the scene will be rendered in the view. For example, if the alignment is Qt::AlignCenter, which is default, the scene will be centered in the view, and if the alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in the top-left corner of the view. This property holds the background brush of the scene. This property sets the background brush for the scene in this view. It is used to override the scene's own background, and defines the behavior of drawBackground(). To provide custom background drawing for this view, you can reimplement drawBackground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::backgroundBrush and foregroundBrush. This property holds which parts of the view are cached QGraphicsView can cache pre-rendered content in a QPixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render. Texture, gradient and alpha blended backgrounds, for example, can be notibly slow to render; especially with a transformed view. The CacheBackground flag enables caching of the view's background. For example: The cache is invalidated every time the view is transformed. However, when scrolling, only partial invalidation is required. By default, nothing is cached. See also resetCachedContent() and QPixmapCache. This property holds the behavior for dragging the mouse over the scene while the left mouse button is pressed. This property defines what should happen when the user clicks on the scene background and drags the mouse (e.g., scrolling the viewport contents using a pointing hand cursor, or selecting multiple items with a rubber band). The default value, NoDrag, does nothing. This behavior only affects mouse clicks that are not handled by any item. You can define a custom behavior by creating a subclass of QGraphicsView and reimplementing mouseMoveEvent(). This property holds the foreground brush of the scene. This property sets the foreground brush for the scene in this view. It is used to override the scene's own foreground, and defines the behavior of drawForeground(). To provide custom foreground drawing for this view, you can reimplement drawForeground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::foregroundBrush and backgroundBrush. This property holds whether the view allows scene interaction. If enabled, this view is set to allow scene interaction. Otherwise, this view will not allow interaction, and any mouse or key events are ignored (i.e., it will act as a read-only view). By default, this property is . flags that can be used to tune QGraphicsView's performance. QGraphicsView uses clipping, extra bounding rect adjustments, and certain other aids to improve rendering quality and performance for the common case graphics scene. However, depending on the target platform, the scene, and the viewport in use, some of these operations can degrade performance. The effect varies from flag to flag; see the OptimizationFlags documentation for details. By default, no optimization flags are enabled. This property holds the default render hints for the view These hints are used to initialize QPainter before each visible item is drawn. QPainter uses render hints to toggle rendering features such as antialiasing and smooth pixmap transformation. how the view should position the scene when the view is resized. QGraphicsView uses this property to decide how to position the scene in the viewport when the viewport widget's size changes. The default behavior, NoAnchor, leaves the scene's position unchanged during a resize; the top-left corner of the view will appear to be anchored while resizing. Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and transformationAnchor. This property holds the behavior for selecting items with a rubber band selection rectangle. This property defines how items are selected when using the RubberBandDrag drag mode. The default value is Qt::IntersectsItemShape; all items whose shape intersects with or is contained by the rubber band are selected. See also dragMode, items(), and rubberBandRect(). This property holds the area of the scene visualized by this view. The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars. If unset, or if a null QRectF is set, this property has the same value as QGraphicsScene::sceneRect, and it changes with QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected by the scene. Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use translate() to navigate the scene instead. By default, this property contains a rectangle at the origin with zero width and height. how the view should position the scene during transformations. QGraphicsView uses this property to decide how to position the scene in the viewport when the transformation matrix changes, and the coordinate system of the view is transformed. The default behavior, AnchorViewCenter, ensures that the scene point at the center of the view remains unchanged during transformations (e.g., when rotating, the scene will appear to rotate around the center of the view). Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and resizeAnchor. how the viewport should update its contents. QGraphicsView uses this property to decide how to update areas of the scene that have been reexposed or changed. Usually you do not need to modify this property, but there are some cases where doing so can improve rendering performance. See the ViewportUpdateMode documentation for specific details. The default value is MinimalViewportUpdate, where QGraphicsView will update as small an area of the viewport as possible when the contents change. See also ViewportUpdateMode and cacheMode.\n\nConstructs a QGraphicsView and sets the visualized scene to scene. parent is passed to QWidget's constructor. Scrolls the contents of the viewport to ensure that the scene coordinate pos, is centered in the view. Because pos is a floating point coordinate, and the scroll bars operate on integer coordinates, the centering is only an approximation. Note: If the item is close to or outside the border, it will be visible in the view, but not centered. This is an overloaded function. Scrolls the contents of the viewport to ensure that item is centered in the view. This is an overloaded function. This function is provided for convenience. It's equivalent to calling centerOn(QPointF(x, y)). Draws the background of the scene using painter, before any items and the foreground are drawn. Reimplement this function to provide a custom background for this view. If all you want is to define a color, texture or gradient for the background, you can call setBackgroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's backgroundBrush. If no such brush is defined (the default), the scene's drawBackground() function is called instead. See also drawForeground() and QGraphicsScene::drawBackground(). Draws the foreground of the scene using painter, after the background and all items are drawn. Reimplement this function to provide a custom foreground for this view. If all you want is to define a color, texture or gradient for the foreground, you can call setForegroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's foregroundBrush. If no such brush is defined (the default), the scene's drawForeground() function is called instead. See also drawBackground() and QGraphicsScene::drawForeground(). Scrolls the contents of the viewport so that the scene rectangle rect is visible, with margins specified in pixels by xmargin and ymargin. If the specified rect cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. Scrolls the contents of the viewport so that the center of item item is visible, with margins specified in pixels by xmargin and ymargin. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. This function is provided for convenience. It's equivalent to calling ensureVisible(QRectF(x, y, w, h), xmargin, ymargin). Scales the view matrix and scrolls the scroll bars to ensure that the scene rectangle rect fits inside the viewport. rect must be inside the scene rect; otherwise, fitInView() cannot guarantee that the whole rect is visible. This function keeps the view's rotation, translation, or shear. The view is scaled according to aspectRatioMode. rect will be centered in the view if it does not fit tightly. It's common to call fitInView() from inside a reimplementation of resizeEvent(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside resizeEvent() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see horizontalScrollBarPolicy() and verticalScrollBarPolicy()). If rect is empty, or if the viewport is too small, this function will do nothing. See also setTransform(), ensureVisible(), and centerOn(). This is an overloaded function. Ensures that item fits tightly inside the view, scaling the view according to aspectRatioMode. See also ensureVisible() and centerOn(). This is an overloaded function. This convenience function is equivalent to calling fitInView(QRectF(x, y, w, h), aspectRatioMode). See also ensureVisible() and centerOn(). Invalidates and schedules a redraw of layers inside rect. rect is in scene coordinates. Any cached content for layers inside rect is unconditionally invalidated and redrawn. You can call this function to notify QGraphicsView of changes to the background or the foreground of the scene. It is commonly used for scenes with tile-based backgrounds to notify changes when QGraphicsView has enabled background caching. Note that QGraphicsView currently supports background caching only (see QGraphicsView::CacheBackground). This function is equivalent to calling update() if any layer but QGraphicsScene::BackgroundLayer is passed. See also QGraphicsScene::invalidate() and update(). Returns if the view is transformed (i.e., a non-identity transform has been assigned, or the scrollbars are adjusted). See also setTransform(), horizontalScrollBar(), and verticalScrollBar(). Returns the item at position pos, which is in viewport coordinates. If there are several items at this position, this function returns the topmost item. CustomView mousePressEvent( event) { ( item itemAt(event pos())) { qDebug() item; } { qDebug( \"You didn't click on an item.\" ); } } See also items() and Sorting. This is an overloaded function. This function is provided for convenience. It's equivalent to calling itemAt(QPoint(x, y)). Returns a list of all the items in the associated scene, in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also QGraphicsScene::items() and Sorting. Returns a list of all the items at the position pos in the view. The items are listed in descending stacking order (i.e., the first item in the list is the uppermost item, and the last item is the lowermost item). pos is in viewport coordinates. This function is most commonly called from within mouse event handlers in a subclass in QGraphicsView. pos is in untransformed viewport coordinates, just like QMouseEvent::pos(). See also QGraphicsScene::items() and Sorting. This function is provided for convenience. It's equivalent to calling items(QPoint(x, y)). This convenience function is equivalent to calling items(QRectF(x, y, w, h), mode). This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with path. path is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by path are returned. See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with polygon. polygon is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by polygon are returned. The items are sorted by descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with rect. rect is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by rect are returned. The items are sorted in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This function is provided for convenience. It's equivalent to calling mapFromScene(QPointF(x, y)). This function is provided for convenience. It's equivalent to calling mapFromScene(QRectF(x, y, w, h)). Note: It can be useful to map the whole rectangle covered by the pixel at point instead of the point itself. To do this, you can call mapToScene(QRect(point, QSize(2, 2))). This function is provided for convenience. It's equivalent to calling mapToScene(QPoint(x, y)). This function is provided for convenience. It's equivalent to calling mapToScene(QRect(x, y, w, h)). Renders the source rect, which is in view coordinates, from the scene into target, which is in paint device coordinates, using painter. This function is useful for capturing the contents of the view onto a paint device, such as a QImage (e.g., to take a screenshot), or for printing to QPrinter. For example: If source is a null rect, this function will use viewport()->rect() to determine what to draw. If target is a null rect, the full dimensions of painter's paint device (e.g., for a QPrinter, the page size) will be used. The source rect contents will be transformed according to aspectRatioMode to fit into the target rect. By default, the aspect ratio is kept, and source is scaled to fit in target. Resets any cached content. Calling this function will clear QGraphicsView's cache. If the current cache mode is CacheNone, this function does nothing. This function is called automatically for you when the backgroundBrush or QGraphicsScene::backgroundBrush properties change; you only need to call this function if you have reimplemented QGraphicsScene::drawBackground() or QGraphicsView::drawBackground() to draw a custom background, and need to trigger a full redraw. Resets the view transformation to the identity matrix. See also transform() and setTransform(). See also setTransform(), transform(), scale(), shear(), and translate(). This signal is emitted when the rubber band rect is changed. The viewport Rect is specified by rubberBandRect. The drag start position and drag end position are provided in scene points with fromScenePoint and toScenePoint. When rubberband selection ends this signal will be emitted with null vales. This functions returns the current rubber band area (in viewport coordinates) if the user is currently doing an itemselection with rubber band. When the user is not using the rubber band this functions returns (a null) QRectF(). Notice that part of this QRect can be outside the visual viewport. It can e.g contain negative values. See also rubberBandSelectionMode and rubberBandChanged(). See also setTransform(), transform(), rotate(), shear(), and translate(). Returns a pointer to the scene that is currently visualized in the view. If no scene is currently visualized, is returned. Enables flag if enabled is true; otherwise disables flag. If enabled is true, the render hint hint is enabled; otherwise it is disabled. Sets the current scene to scene. If scene is already being viewed, this function does nothing. When a scene is set on a view, the QGraphicsScene::changed() signal is automatically connected to this view's updateScene() slot, and the view's scroll bars are adjusted to fit the size of the scene. The view does not take ownership of scene. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix transforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interaction with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordinate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also transform(), resetTransform(), rotate(), scale(), shear(), and translate(). This slot is called by QAbstractScrollArea after setViewport() has been called. Reimplement this function in a subclass of QGraphicsView to initialize the new viewport widget before it is used. See also setTransform(), transform(), rotate(), scale(), and translate(). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setTransform(), rotate(), scale(), shear(), and translate(). See also setTransform(), transform(), rotate(), and shear(). Schedules an update of the scene rectangles rects. Notifies QGraphicsView that the scene's scene rect has changed. rect is the new scene rect. If the view already has an explicitly set scene rect, this function does nothing. See also sceneRect and QGraphicsScene::sceneRectChanged(). See also mapToScene() and mapFromScene()."
    },
    {
        "link": "https://doc.qt.io/qt-6/graphicsview.html",
        "document": "Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation.\n\nThe framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement.\n\nGraphics View uses a BSP (Binary Space Partitioning) tree to provide very fast item discovery, and as a result of this, it can visualize large scenes in real-time, even with millions of items.\n\nGraphics View was introduced in Qt 4.2, replacing its predecessor, QCanvas.\n\nGraphics View provides an item-based approach to model-view programming, much like InterView's convenience classes QTableView, QTreeView and QListView. Several views can observe a single scene, and the scene contains items of varying geometric shapes.\n\nQGraphicsScene provides the Graphics View scene. The scene has the following responsibilities:\n• Managing item state, such as selection and focus handling\n\nThe scene serves as a container for QGraphicsItem objects. Items are added to the scene by calling QGraphicsScene::addItem(), and then retrieved by calling one of the many item discovery functions. QGraphicsScene::items() and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. QGraphicsScene::itemAt() returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).\n\nQGraphicsScene's event propagation architecture schedules scene events for delivery to items, and also manages propagation between items. If the scene receives a mouse press event at a certain position, the scene passes the event on to whichever item is at that position.\n\nQGraphicsScene also manages certain item states, such as item selection and focus. You can select items on the scene by calling QGraphicsScene::setSelectionArea(), passing an arbitrary shape. This functionality is also used as a basis for rubberband selection in QGraphicsView. To get the list of all currently selected items, call QGraphicsScene::selectedItems(). Another state handled by QGraphicsScene is whether or not an item has keyboard input focus. You can set focus on an item by calling QGraphicsScene::setFocusItem() or QGraphicsItem::setFocus(), or get the current focus item by calling QGraphicsScene::focusItem().\n\nFinally, QGraphicsScene allows you to render parts of the scene into a paint device through the QGraphicsScene::render() function. You can read more about this in the Printing section later in this document.\n\nQGraphicsView provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set. The view widget is a scroll area, and provides scroll bars for navigating through large scenes. To enable OpenGL support, you can set a QOpenGLWidget as the viewport by calling QGraphicsView::setViewport().\n\nThe view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene.\n\nUsing its transformation matrix, QGraphicsView::transform(), the view can transform the scene's coordinate system. This allows advanced navigation features such as zooming and rotation. For convenience, QGraphicsView also provides functions for translating between view and scene coordinates: QGraphicsView::mapToScene() and QGraphicsView::mapFromScene().\n\nQGraphicsItem is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles (QGraphicsRectItem), ellipses (QGraphicsEllipseItem) and text items (QGraphicsTextItem), but the most powerful QGraphicsItem features are available when you write a custom item. Among other things, QGraphicsItem supports the following features:\n• Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.\n• Grouping, both through parent-child relationships, and with QGraphicsItemGroup\n\nItems live in a local coordinate system, and like QGraphicsView, it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like QGraphicsView, it can transform its coordinate system using a matrix: QGraphicsItem::transform(). This is useful for rotating and scaling individual items.\n\nItems can contain other items (children). Parent items' transformations are inherited by all its children. Regardless of an item's accumulated transformation, though, all its functions (e.g., QGraphicsItem::contains(), QGraphicsItem::boundingRect(), QGraphicsItem::collidesWith()) still operate in local coordinates.\n\nQGraphicsItem supports collision detection through the QGraphicsItem::shape() function, and QGraphicsItem::collidesWith(), which are both virtual functions. By returning your item's shape as a local coordinate QPainterPath from QGraphicsItem::shape(), QGraphicsItem will handle all collision detection for you. If you want to provide your own collision detection, however, you can reimplement QGraphicsItem::collidesWith().\n\nGraphics View is based on the Cartesian coordinate system; items' position and geometry on the scene are represented by sets of two numbers: the x-coordinate, and the y-coordinate. When observing a scene using an untransformed view, one unit on the scene is represented by one pixel on the screen.\n\nThere are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems.\n\nWhen rendering, Graphics View's scene coordinates correspond to QPainter's logical coordinates, and view coordinates are the same as device coordinates. In the Coordinate System documentation, you can read about the relationship between logical coordinates and device coordinates.\n\nItems live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles.\n\nWhen creating a custom item, item coordinates are all you need to worry about; QGraphicsScene and QGraphicsView will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The QGraphicsItem::contains() virtual function, which returns if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.\n\nAt item's position is the coordinate of the item's center point in its parent's coordinate system; sometimes referred to as parent coordinates. The scene is in this sense regarded as all parent-less items' \"parent\". Top level items' position are in scene coordinates.\n\nChild coordinates are relative to the parent's coordinates. If the child is untransformed, the difference between a child coordinate and a parent coordinate is the same as the distance between the items in parent coordinates. For example: If an untransformed child item is positioned precisely in its parent's center point, then the two items' coordinate systems will be identical. If the child's position is (10, 0), however, the child's (0, 10) point will correspond to its parent's (10, 10) point.\n\nBecause items' position and transformation are relative to the parent, child items' coordinates are unaffected by the parent's transformation, although the parent's transformation implicitly transforms the child. In the above example, even if the parent is rotated and scaled, the child's (0, 10) point will still correspond to the parent's (10, 10) point. Relative to the scene, however, the child will follow the parent's transformation and position. If the parent is scaled (2x, 2x), the child's position will be at scene coordinate (20, 0), and its (10, 0) point will correspond to the point (40, 0) on the scene.\n\nWith QGraphicsItem::pos() being one of the few exceptions, QGraphicsItem's functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. QGraphicsItem::boundingRect()) is always given in item coordinates.\n\nThe scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (QGraphicsItem::scenePos(), QGraphicsItem::sceneBoundingRect()), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how QGraphicsScene determines what areas of the scene have changed. Changes in the scene are communicated through the QGraphicsScene::changed() signal, and the argument is a list of scene rectangles.\n\nView coordinates are the coordinates of the widget. Each unit in view coordinates corresponds to one pixel. What's special about this coordinate system is that it is relative to the widget, or viewport, and unaffected by the observed scene. The top left corner of QGraphicsView's viewport is always (0, 0), and the bottom right corner is always (viewport width, viewport height). All mouse events and drag and drop events are originally received as view coordinates, and you need to map these coordinates to the scene in order to interact with items.\n\nOften when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in QGraphicsView's viewport, you can ask the scene what item is under the cursor by calling QGraphicsView::mapToScene(), followed by QGraphicsScene::itemAt(). If you want to know where in the viewport an item is located, you can call QGraphicsItem::mapToScene() on the item, then QGraphicsView::mapFromScene() on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a QPainterPath to mapToScene(), and then pass the mapped path to QGraphicsScene::items().\n\nYou can map coordinates and shapes to and from an item's scene by calling QGraphicsItem::mapToScene() and QGraphicsItem::mapFromScene(). You can also map to an item's parent item by calling QGraphicsItem::mapToParent() and QGraphicsItem::mapFromParent(), or between items by calling QGraphicsItem::mapToItem() and QGraphicsItem::mapFromItem(). All mapping functions can map both points, rectangles, polygons and paths.\n\nThe same mapping functions are available in the view, for mapping to and from the scene. QGraphicsView::mapFromScene() and QGraphicsView::mapToScene(). To map from a view to an item, you first map to the scene, and then map from the scene to the item.\n\nQGraphicsView supports the same affine transformations as QPainter does through QGraphicsView::setMatrix(). By applying a transformation to the view, you can easily add support for common navigation features such as zooming and rotating.\n\nHere is an example of how to implement zoom and rotate slots in a subclass of QGraphicsView:\n\nThe slots could be connected to QToolButtons with autoRepeat enabled.\n\nQGraphicsView keeps the center of the view aligned when you transform the view.\n\nSee also the Elastic Nodes example for code that shows how to implement basic zooming features.\n\nGraphics View provides single-line printing through its rendering functions, QGraphicsScene::render() and QGraphicsView::render(). The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a QPainter to either of the rendering functions. This example shows how to print the whole scene into a full page, using QPrinter.\n\nThe difference between the scene and view rendering functions is that one operates in scene coordinates, and the other in view coordinates. QGraphicsScene::render() is often preferred for printing whole segments of a scene untransformed, such as for plotting geometrical data, or for printing a text document. QGraphicsView::render(), on the other hand, is suitable for taking screenshots; its default behavior is to render the exact contents of the viewport using the provided painter.\n\nWhen the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a Qt::AspectRatioMode to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.\n\nBecause QGraphicsView inherits QWidget indirectly, it already provides the same drag and drop functionality that QWidget provides. In addition, as a convenience, the Graphics View framework provides drag and drop support for the scene, and for each and every item. As the view receives a drag, it translates the drag and drop events into a QGraphicsSceneDragDropEvent, which is then forwarded to the scene. The scene takes over scheduling of this event, and sends it to the first item under the mouse cursor that accepts drops.\n\nTo start a drag from an item, create a QDrag object, passing a pointer to the widget that starts the drag. Items can be observed by many views at the same time, but only one view can start the drag. Drags are in most cases started as a result of pressing or moving the mouse, so in mousePressEvent() or mouseMoveEvent(), you can get the originating widget pointer from the event. For example:\n\nTo intercept drag and drop events for the scene, you reimplement QGraphicsScene::dragEnterEvent() and whichever event handlers your particular scene needs, in a QGraphicsItem subclass. You can read more about drag and drop in Graphics View in the documentation for each of QGraphicsScene's event handlers.\n\nItems can enable drag and drop support by calling QGraphicsItem::setAcceptDrops(). To handle the incoming drag, reimplement QGraphicsItem::dragEnterEvent(), QGraphicsItem::dragMoveEvent(), QGraphicsItem::dragLeaveEvent(), and QGraphicsItem::dropEvent().\n\nSee also the Drag and Drop Robot example for a demonstration of Graphics View's support for drag and drop operations.\n\nLike QWidget, QGraphicsItem also supports cursors (QGraphicsItem::setCursor()), and tooltips (QGraphicsItem::setToolTip()). The cursors and tooltips are activated by QGraphicsView as the mouse cursor enters the item's area (detected by calling QGraphicsItem::contains()).\n\nYou can also set a default cursor directly on the view by calling QGraphicsView::setCursor().\n\nSee also the Drag and Drop Robot example for code that implements tooltips and cursor shape handling.\n\nGraphics View supports animation at several levels. You can easily assemble animation by using the Animation Framework. For that you'll need your items to inherit from QGraphicsObject and associate QPropertyAnimation with them. QPropertyAnimation allows to animate any QObject property.\n\nAnother option is to create a custom item that inherits from QObject and QGraphicsItem. The item can the set up its own timers, and control animations with incremental steps in QObject::timerEvent().\n\nA third option, which is mostly available for compatibility with QCanvas in Qt 3, is to advance the scene by calling QGraphicsScene::advance(), which in turn calls QGraphicsItem::advance().\n\nTo enable OpenGL rendering, you simply set a new QOpenGLWidget as the viewport of QGraphicsView by calling QGraphicsView::setViewport(). If you want OpenGL with antialiasing, you need to set a QSurfaceFormat with the needed sample count (see QSurfaceFormat::setSamples()).\n\nBy making an item a child of another, you can achieve the most essential feature of item grouping: the items will move together, and all transformations are propagated from parent to child.\n\nIn addition, QGraphicsItemGroup is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a QGraphicsItemGroup will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create QGraphicsItemGroups through the scene by calling QGraphicsScene::createItemGroup().\n\nQt 4.4 introduced support for geometry and layout-aware items through QGraphicsWidget. This special base item is similar to QWidget, but unlike QWidget, it doesn't inherit from QPaintDevice; rather from QGraphicsItem instead. This allows you to write complete widgets with events, signals & slots, size hints and policies, and you can also manage your widgets geometries in layouts through QGraphicsLinearLayout and QGraphicsGridLayout.\n\nBuilding on top of QGraphicsItem's capabilities and lean footprint, QGraphicsWidget provides the best of both worlds: extra functionality from QWidget, such as the style, font, palette, layout direction, and its geometry, and resolution independence and transformation support from QGraphicsItem. Because Graphics View uses real coordinates instead of integers, QGraphicsWidget's geometry functions also operate on QRectF and QPointF. This also applies to frame rects, margins and spacing. With QGraphicsWidget it's not uncommon to specify contents margins of (0.5, 0.5, 0.5, 0.5), for example. You can create both subwidgets and \"top-level\" windows; in some cases you can now use Graphics View for advanced MDI applications.\n\nSome of QWidget's properties are supported, including window flags and attributes, but not all. You should refer to QGraphicsWidget's class documentation for a complete overview of what is and what is not supported. For example, you can create decorated windows by passing the Qt::Window window flag to QGraphicsWidget's constructor, but Graphics View currently doesn't support the Qt::Sheet and Qt::Drawer flags that are common on macOS.\n\nQGraphicsLayout is part of a second-generation layout framework designed specifically for QGraphicsWidget. Its API is very similar to that of QLayout. You can manage widgets and sublayouts inside either QGraphicsLinearLayout and QGraphicsGridLayout. You can also easily write your own layout by subclassing QGraphicsLayout yourself, or add your own QGraphicsItem items to the layout by writing an adaptor subclass of QGraphicsLayoutItem.\n\nGraphics View provides seamless support for embedding any widget into the scene. You can embed simple widgets, such as QLineEdit or QPushButton, complex widgets such as QTabWidget, and even complete main windows. To embed your widget to the scene, simply call QGraphicsScene::addWidget(), or create an instance of QGraphicsProxyWidget to embed your widget manually.\n\nThrough QGraphicsProxyWidget, Graphics View is able to deeply integrate the client widget features including its cursors, tooltips, mouse, tablet and keyboard events, child widgets, animations, pop-ups (e.g., QComboBox or QCompleter), and the widget's input focus and activation. QGraphicsProxyWidget even integrates the embedded widget's tab order so that you can tab in and out of embedded widgets. You can even embed a new QGraphicsView into your scene to provide complex nested scenes.\n\nWhen transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)\n\nIn order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user's hardware is able to provide reasonable performance for floating point instructions.\n\nMany workstations and desktop computers are equipped with suitable hardware to accelerate this kind of computation, but some embedded devices may only provide libraries to handle mathematical operations or emulate floating point instructions in software.\n\nAs a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using OpenGL to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware."
    },
    {
        "link": "https://felgo.com/doc/qt5/qgraphicsview",
        "document": "The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. More...\n\nThe QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework. To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example: You can explicitly scroll to any position on the scene by using the scroll bars, or by calling centerOn(). By passing a point to centerOn(), QGraphicsView will scroll its viewport to ensure that the point is centered in the view. An overload is provided for scrolling to a QGraphicsItem, in which case QGraphicsView will see to that the center of the item is centered in the view. If all you want is to ensure that a certain area is visible, (but not necessarily centered,) you can call ensureVisible() instead. QGraphicsView can be used to visualize a whole scene, or only parts of it. The visualized area is by default detected automatically when the view is displayed for the first time (by calling QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle yourself, you can call setSceneRect(). This will adjust the scroll bars' ranges appropriately. Note that although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). QGraphicsView visualizes the scene by calling render(). By default, the items are drawn onto the viewport by using a regular QPainter, and using default render hints. To change the default render hints that QGraphicsView passes to QPainter when painting items, you can call setRenderHints(). By default, QGraphicsView provides a regular QWidget for the viewport widget. You can access this widget by calling viewport(), or you can replace it by calling setViewport(). To render using OpenGL, simply call setViewport(new QGLWidget). QGraphicsView takes ownership of the viewport widget. QGraphicsView supports affine transformations, using QTransform. You can either pass a matrix to setTransform(), or you can call one of the convenience functions rotate(), scale(), translate() or shear(). The most two common transformations are scaling, which is used to implement zooming, and rotation. QGraphicsView keeps the center of the view fixed during a transformation. Because of the scene alignment (setAligment()), translating the view will have no visual impact. You can interact with the items on the scene by using the mouse and keyboard. QGraphicsView translates the mouse and key events into scene events, (events that inherit QGraphicsSceneEvent,), and forward them to the visualized scene. In the end, it's the individual item that handles the events and reacts to them. For example, if you click on a selectable item, the item will typically let the scene know that it has been selected, and it will also redraw itself to display a selection rectangle. Similiary, if you click and drag the mouse to move a movable item, it's the item that handles the mouse moves and moves itself. Item interaction is enabled by default, and you can toggle it by calling setInteractive(). You can also provide your own custom scene interaction, by creating a subclass of QGraphicsView, and reimplementing the mouse and key event handlers. To simplify how you programmatically interact with items in the view, QGraphicsView provides the mapping functions mapToScene() and mapFromScene(), and the item accessors items() and itemAt(). These functions allow you to map points, rectangles, polygons and paths between view coordinates and scene coordinates, and to find items on the scene using view coordinates.\n\nSee also QGraphicsScene, QGraphicsItem, and QGraphicsSceneEvent.\n\nThis enum describes the flags that you can set for a QGraphicsView's cache mode. All painting is done directly onto the viewport. The background is cached. This affects both custom backgrounds, and backgrounds based on the backgroundBrush property. When this flag is enabled, QGraphicsView will allocate one pixmap with the full size of the viewport. The CacheMode type is a typedef for QFlags<CacheModeFlag>. It stores an OR combination of CacheModeFlag values. This enum describes the default action for the view when pressing and dragging the mouse over the viewport. Nothing happens; the mouse event is ignored. The cursor changes into a pointing hand, and dragging the mouse around will scroll the scrolbars. This mode works both in interactive and non-interactive mode. A rubber band will appear. Dragging the mouse will set the rubber band geometry, and all items covered by the rubber band are selected. This mode is disabled for non-interactive views. See also dragMode and QGraphicsScene::setSelectionArea(). This enum describes flags that you can enable to improve rendering performance in QGraphicsView. By default, none of these flags are set. Note that setting a flag usually imposes a side effect, and this effect can vary between paint devices and platforms. This value is obsolete and has no effect. When rendering, QGraphicsView protects the painter state (see QPainter::save()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call QPainter::setPen() or QPainter::setBrush() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent QGraphicsView from doing the same. Disables QGraphicsView's antialiasing auto-adjustment of exposed areas. Items that render antialiased lines on the boundaries of their QGraphicsItem::boundingRect() can end up rendering parts of the line outside. To prevent rendering artifacts, QGraphicsView expands all exposed regions by 2 pixels in all directions. If you enable this flag, QGraphicsView will no longer perform these adjustments, minimizing the areas that require redrawing, which improves performance. A common side effect is that items that do draw with antialiasing can leave painting traces behind on the scene as they are moved. Since Qt 4.6, restore the old painting algorithm that calls QGraphicsView::drawItems() and QGraphicsScene::drawItems(). To be used only for compatibility with old code. This enum was introduced or modified in Qt 4.3. The OptimizationFlags type is a typedef for QFlags<OptimizationFlag>. It stores an OR combination of OptimizationFlag values. This enums describe the possible anchors that QGraphicsView can use when the user resizes the view or when the view is transformed. No anchor, i.e. the view leaves the scene's position unchanged. The scene point at the center of the view is used as the anchor. The point under the mouse is used as the anchor. See also resizeAnchor and transformationAnchor. This enum describes how QGraphicsView updates its viewport when the scene contents change or are exposed. When any visible part of the scene changes or is reexposed, QGraphicsView will update the entire viewport. This approach is fastest when QGraphicsView spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization. QGraphicsView will determine the minimal viewport region that requires a redraw, minimizing the time spent drawing by avoiding a redraw of areas that have not changed. This is QGraphicsView's default mode. Although this approach provides the best performance in general, if there are many small visible changes on the scene, QGraphicsView might end up spending more time finding the minimal approach than it will spend drawing. QGraphicsView will attempt to find an optimal update mode by analyzing the areas that require a redraw. The bounding rectangle of all changes in the viewport will be redrawn. This mode has the advantage that QGraphicsView searches only one region for changes, minimizing time spent determining what needs redrawing. The disadvantage is that areas that have not changed also need to be redrawn. QGraphicsView will never update its viewport when the scene changes; the user is expected to control all updates. This mode disables all (potentially slow) item visibility testing in QGraphicsView, and is suitable for scenes that either require a fixed frame rate, or where the viewport is otherwise updated externally. This enum was introduced or modified in Qt 4.3.\n\nThis property holds the alignment of the scene in the view when the whole scene is visible. If the whole scene is visible in the view, (i.e., there are no visible scroll bars,) the view's alignment will decide where the scene will be rendered in the view. For example, if the alignment is Qt::AlignCenter, which is default, the scene will be centered in the view, and if the alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in the top-left corner of the view. This property holds the background brush of the scene. This property sets the background brush for the scene in this view. It is used to override the scene's own background, and defines the behavior of drawBackground(). To provide custom background drawing for this view, you can reimplement drawBackground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::backgroundBrush and foregroundBrush. This property holds which parts of the view are cached QGraphicsView can cache pre-rendered content in a QPixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render. Texture, gradient and alpha blended backgrounds, for example, can be notibly slow to render; especially with a transformed view. The CacheBackground flag enables caching of the view's background. For example: The cache is invalidated every time the view is transformed. However, when scrolling, only partial invalidation is required. By default, nothing is cached. See also resetCachedContent() and QPixmapCache. This property holds the behavior for dragging the mouse over the scene while the left mouse button is pressed. This property defines what should happen when the user clicks on the scene background and drags the mouse (e.g., scrolling the viewport contents using a pointing hand cursor, or selecting multiple items with a rubber band). The default value, NoDrag, does nothing. This behavior only affects mouse clicks that are not handled by any item. You can define a custom behavior by creating a subclass of QGraphicsView and reimplementing mouseMoveEvent(). This property holds the foreground brush of the scene. This property sets the foreground brush for the scene in this view. It is used to override the scene's own foreground, and defines the behavior of drawForeground(). To provide custom foreground drawing for this view, you can reimplement drawForeground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::foregroundBrush and backgroundBrush. This property holds whether the view allows scene interaction. If enabled, this view is set to allow scene interaction. Otherwise, this view will not allow interaction, and any mouse or key events are ignored (i.e., it will act as a read-only view). By default, this property is . flags that can be used to tune QGraphicsView's performance. QGraphicsView uses clipping, extra bounding rect adjustments, and certain other aids to improve rendering quality and performance for the common case graphics scene. However, depending on the target platform, the scene, and the viewport in use, some of these operations can degrade performance. The effect varies from flag to flag; see the OptimizationFlags documentation for details. By default, no optimization flags are enabled. This property was introduced in Qt 4.3. This property holds the default render hints for the view These hints are used to initialize QPainter before each visible item is drawn. QPainter uses render hints to toggle rendering features such as antialiasing and smooth pixmap transformation. how the view should position the scene when the view is resized. QGraphicsView uses this property to decide how to position the scene in the viewport when the viewport widget's size changes. The default behavior, NoAnchor, leaves the scene's position unchanged during a resize; the top-left corner of the view will appear to be anchored while resizing. Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and transformationAnchor. This property holds the behavior for selecting items with a rubber band selection rectangle. This property defines how items are selected when using the RubberBandDrag drag mode. The default value is Qt::IntersectsItemShape; all items whose shape intersects with or is contained by the rubber band are selected. This property was introduced in Qt 4.3. See also dragMode, items(), and rubberBandRect(). This property holds the area of the scene visualized by this view. The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars. If unset, or if a null QRectF is set, this property has the same value as QGraphicsScene::sceneRect, and it changes with QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected by the scene. Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use translate() to navigate the scene instead. By default, this property contains a rectangle at the origin with zero width and height. how the view should position the scene during transformations. QGraphicsView uses this property to decide how to position the scene in the viewport when the transformation matrix changes, and the coordinate system of the view is transformed. The default behavior, AnchorViewCenter, ensures that the scene point at the center of the view remains unchanged during transformations (e.g., when rotating, the scene will appear to rotate around the center of the view). Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and resizeAnchor. how the viewport should update its contents. QGraphicsView uses this property to decide how to update areas of the scene that have been reexposed or changed. Usually you do not need to modify this property, but there are some cases where doing so can improve rendering performance. See the ViewportUpdateMode documentation for specific details. The default value is MinimalViewportUpdate, where QGraphicsView will update as small an area of the viewport as possible when the contents change. This property was introduced in Qt 4.3. See also ViewportUpdateMode and cacheMode.\n\nConstructs a QGraphicsView and sets the visualized scene to scene. parent is passed to QWidget's constructor. Scrolls the contents of the viewport to ensure that the scene coordinate pos, is centered in the view. Because pos is a floating point coordinate, and the scroll bars operate on integer coordinates, the centering is only an approximation. Note: If the item is close to or outside the border, it will be visible in the view, but not centered. This is an overloaded function. This function is provided for convenience. It's equivalent to calling centerOn(QPointF(x, y)). This is an overloaded function. Scrolls the contents of the viewport to ensure that item is centered in the view. Draws the background of the scene using painter, before any items and the foreground are drawn. Reimplement this function to provide a custom background for this view. If all you want is to define a color, texture or gradient for the background, you can call setBackgroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's backgroundBrush. If no such brush is defined (the default), the scene's drawBackground() function is called instead. See also drawForeground() and QGraphicsScene::drawBackground(). Draws the foreground of the scene using painter, after the background and all items are drawn. Reimplement this function to provide a custom foreground for this view. If all you want is to define a color, texture or gradient for the foreground, you can call setForegroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's foregroundBrush. If no such brush is defined (the default), the scene's drawForeground() function is called instead. See also drawBackground() and QGraphicsScene::drawForeground(). Scrolls the contents of the viewport so that the scene rectangle rect is visible, with margins specified in pixels by xmargin and ymargin. If the specified rect cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. This function is provided for convenience. It's equivalent to calling ensureVisible(QRectF(x, y, w, h), xmargin, ymargin). This is an overloaded function. Scrolls the contents of the viewport so that the center of item item is visible, with margins specified in pixels by xmargin and ymargin. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. Scales the view matrix and scrolls the scroll bars to ensure that the scene rectangle rect fits inside the viewport. rect must be inside the scene rect; otherwise, fitInView() cannot guarantee that the whole rect is visible. This function keeps the view's rotation, translation, or shear. The view is scaled according to aspectRatioMode. rect will be centered in the view if it does not fit tightly. It's common to call fitInView() from inside a reimplementation of resizeEvent(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside resizeEvent() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see horizontalScrollBarPolicy() and verticalScrollBarPolicy()). If rect is empty, or if the viewport is too small, this function will do nothing. See also setTransform(), ensureVisible(), and centerOn(). This is an overloaded function. This convenience function is equivalent to calling fitInView(QRectF(x, y, w, h), aspectRatioMode). See also ensureVisible() and centerOn(). This is an overloaded function. Ensures that item fits tightly inside the view, scaling the view according to aspectRatioMode. See also ensureVisible() and centerOn(). Invalidates and schedules a redraw of layers inside rect. rect is in scene coordinates. Any cached content for layers inside rect is unconditionally invalidated and redrawn. You can call this function to notify QGraphicsView of changes to the background or the foreground of the scene. It is commonly used for scenes with tile-based backgrounds to notify changes when QGraphicsView has enabled background caching. Note that QGraphicsView currently supports background caching only (see QGraphicsView::CacheBackground). This function is equivalent to calling update() if any layer but QGraphicsScene::BackgroundLayer is passed. See also QGraphicsScene::invalidate() and update(). Returns if the view is transformed (i.e., a non-identity transform has been assigned, or the scrollbars are adjusted). This function was introduced in Qt 4.6. See also setTransform(), horizontalScrollBar(), and verticalScrollBar(). Returns the item at position pos, which is in viewport coordinates. If there are several items at this position, this function returns the topmost item. CustomView mousePressEvent( event) { ( item itemAt(event pos())) { qDebug() item; } { qDebug( \"You didn't click on an item.\" ); } } See also items() and Sorting. This is an overloaded function. This function is provided for convenience. It's equivalent to calling itemAt(QPoint(x, y)). Returns a list of all the items in the associated scene, in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also QGraphicsScene::items() and Sorting. Returns a list of all the items at the position pos in the view. The items are listed in descending stacking order (i.e., the first item in the list is the uppermost item, and the last item is the lowermost item). pos is in viewport coordinates. This function is most commonly called from within mouse event handlers in a subclass in QGraphicsView. pos is in untransformed viewport coordinates, just like QMouseEvent::pos(). See also QGraphicsScene::items() and Sorting. This function is provided for convenience. It's equivalent to calling items(QPoint(x, y)). This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with rect. rect is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by rect are returned. The items are sorted in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This convenience function is equivalent to calling items(QRectF(x, y, w, h), mode). This function was introduced in Qt 4.3. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with polygon. polygon is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by polygon are returned. The items are sorted by descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with path. path is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by path are returned. See also itemAt(), items(), mapToScene(), and Sorting. This function is provided for convenience. It's equivalent to calling mapFromScene(QPointF(x, y)). This function is provided for convenience. It's equivalent to calling mapFromScene(QRectF(x, y, w, h)). Note: It can be useful to map the whole rectangle covered by the pixel at point instead of the point itself. To do this, you can call mapToScene(QRect(point, QSize(2, 2))). This function is provided for convenience. It's equivalent to calling mapToScene(QPoint(x, y)). This function is provided for convenience. It's equivalent to calling mapToScene(QRect(x, y, w, h)). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setMatrix(), transform(), rotate(), scale(), shear(), and translate(). Renders the source rect, which is in view coordinates, from the scene into target, which is in paint device coordinates, using painter. This function is useful for capturing the contents of the view onto a paint device, such as a QImage (e.g., to take a screenshot), or for printing to QPrinter. For example: If source is a null rect, this function will use viewport()->rect() to determine what to draw. If target is a null rect, the full dimensions of painter's paint device (e.g., for a QPrinter, the page size) will be used. The source rect contents will be transformed according to aspectRatioMode to fit into the target rect. By default, the aspect ratio is kept, and source is scaled to fit in target. Resets any cached content. Calling this function will clear QGraphicsView's cache. If the current cache mode is CacheNone, this function does nothing. This function is called automatically for you when the backgroundBrush or QGraphicsScene::backgroundBrush properties change; you only need to call this function if you have reimplemented QGraphicsScene::drawBackground() or QGraphicsView::drawBackground() to draw a custom background, and need to trigger a full redraw. Resets the view transformation matrix to the identity matrix. Resets the view transformation to the identity matrix. See also transform() and setTransform(). See also setTransform(), transform(), scale(), shear(), and translate(). This signal is emitted when the rubber band rect is changed. The viewport Rect is specified by rubberBandRect. The drag start position and drag end position are provided in scene points with fromScenePoint and toScenePoint. When rubberband selection ends this signal will be emitted with null vales. This function was introduced in Qt 5.1. This functions returns the current rubber band area (in viewport coordinates) if the user is currently doing an itemselection with rubber band. When the user is not using the rubber band this functions returns (a null) QRectF(). Notice that part of this QRect can be outise the visual viewport. It can e.g contain negative values. This function was introduced in Qt 5.1. See also rubberBandSelectionMode and rubberBandChanged(). See also setTransform(), transform(), rotate(), shear(), and translate(). Returns a pointer to the scene that is currently visualized in the view. If no scene is currently visualized, 0 is returned. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix tranforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interation with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordinate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also matrix(), setTransform(), rotate(), scale(), shear(), and translate(). Enables flag if enabled is true; otherwise disables flag. If enabled is true, the render hint hint is enabled; otherwise it is disabled. Sets the current scene to scene. If scene is already being viewed, this function does nothing. When a scene is set on a view, the QGraphicsScene::changed() signal is automatically connected to this view's updateScene() slot, and the view's scroll bars are adjusted to fit the size of the scene. The view does not take ownership of scene. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix tranforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interation with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordiate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also transform(), rotate(), scale(), shear(), and translate(). This slot is called by QAbstractScrollArea after setViewport() has been called. Reimplement this function in a subclass of QGraphicsView to initialize the new viewport widget before it is used. See also setTransform(), transform(), rotate(), scale(), and translate(). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setTransform(), rotate(), scale(), shear(), and translate(). See also setTransform(), transform(), rotate(), and shear(). Schedules an update of the scene rectangles rects. Notifies QGraphicsView that the scene's scene rect has changed. rect is the new scene rect. If the view already has an explicitly set scene rect, this function does nothing. See also sceneRect and QGraphicsScene::sceneRectChanged(). See also mapToScene() and mapFromScene()."
    },
    {
        "link": "http://bim-times.com/qt/Qt-5.11.1/qtwidgets/qgraphicsview.html",
        "document": ""
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_packages/centos6/freesurfer-fsl-matlab-Linux-centos6_x86_64-dev/freesurfer/lib/qt/qt_doc/html/qgraphicsview.html",
        "document": "The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. More...\n\nThis class was introduced in Qt 4.2.\n\nThe QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene. QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework. To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example: You can explicitly scroll to any position on the scene by using the scroll bars, or by calling centerOn(). By passing a point to centerOn(), QGraphicsView will scroll its viewport to ensure that the point is centered in the view. An overload is provided for scrolling to a QGraphicsItem, in which case QGraphicsView will see to that the center of the item is centered in the view. If all you want is to ensure that a certain area is visible, (but not necessarily centered,) you can call ensureVisible() instead. QGraphicsView can be used to visualize a whole scene, or only parts of it. The visualized area is by default detected automatically when the view is displayed for the first time (by calling QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle yourself, you can call setSceneRect(). This will adjust the scroll bars' ranges appropriately. Note that although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use translate() to navigate the scene instead. QGraphicsView visualizes the scene by calling render(). By default, the items are drawn onto the viewport by using a regular QPainter, and using default render hints. To change the default render hints that QGraphicsView passes to QPainter when painting items, you can call setRenderHints(). By default, QGraphicsView provides a regular QWidget for the viewport widget. You can access this widget by calling viewport(), or you can replace it by calling setViewport(). To render using OpenGL, simply call setViewport(new QGLWidget). QGraphicsView takes ownership of the viewport widget. QGraphicsView supports affine transformations, using QTransform. You can either pass a matrix to setTransform(), or you can call one of the convenience functions rotate(), scale(), translate() or shear(). The most two common transformations are scaling, which is used to implement zooming, and rotation. QGraphicsView keeps the center of the view fixed during a transformation. You can interact with the items on the scene by using the mouse and keyboard. QGraphicsView translates the mouse and key events into scene events, (events that inherit QGraphicsSceneEvent,), and forward them to the visualized scene. In the end, it's the individual item that handles the events and reacts to them. For example, if you click on a selectable item, the item will typically let the scene know that it has been selected, and it will also redraw itself to display a selection rectangle. Similiary, if you click and drag the mouse to move a movable item, it's the item that handles the mouse moves and moves itself. Item interaction is enabled by default, and you can toggle it by calling setInteractive(). You can also provide your own custom scene interaction, by creating a subclass of QGraphicsView, and reimplementing the mouse and key event handlers. To simplify how you programmatically interact with items in the view, QGraphicsView provides the mapping functions mapToScene() and mapFromScene(), and the item accessors items() and itemAt(). These functions allow you to map points, rectangles, polygons and paths between view coordinates and scene coordinates, and to find items on the scene using view coordinates.\n\nSee also QGraphicsScene, QGraphicsItem, and QGraphicsSceneEvent.\n\nThis enum describes the flags that you can set for a QGraphicsView's cache mode. All painting is done directly onto the viewport. The background is cached. This affects both custom backgrounds, and backgrounds based on the backgroundBrush property. When this flag is enabled, QGraphicsView will allocate one pixmap with the full size of the viewport. The CacheMode type is a typedef for QFlags<CacheModeFlag>. It stores an OR combination of CacheModeFlag values. This enum describes the default action for the view when pressing and dragging the mouse over the viewport. Nothing happens; the mouse event is ignored. The cursor changes into a pointing hand, and dragging the mouse around will scroll the scrolbars. This mode works both in interactive and non-interactive mode. A rubber band will appear. Dragging the mouse will set the rubber band geometry, and all items covered by the rubber band are selected. This mode is disabled for non-interactive views. See also dragMode and QGraphicsScene::setSelectionArea(). This enum describes flags that you can enable to improve rendering performance in QGraphicsView. By default, none of these flags are set. Note that setting a flag usually imposes a side effect, and this effect can vary between paint devices and platforms. This value is obsolete and has no effect. When rendering, QGraphicsView protects the painter state (see QPainter::save()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call QPainter::setPen() or QPainter::setBrush() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent QGraphicsView from doing the same. Disables QGraphicsView's antialiasing auto-adjustment of exposed areas. Items that render antialiased lines on the boundaries of their QGraphicsItem::boundingRect() can end up rendering parts of the line outside. To prevent rendering artifacts, QGraphicsView expands all exposed regions by 2 pixels in all directions. If you enable this flag, QGraphicsView will no longer perform these adjustments, minimizing the areas that require redrawing, which improves performance. A common side effect is that items that do draw with antialiasing can leave painting traces behind on the scene as they are moved. Since Qt 4.6, restore the old painting algorithm that calls QGraphicsView::drawItems() and QGraphicsScene::drawItems(). To be used only for compatibility with old code. This enum was introduced or modified in Qt 4.3. The OptimizationFlags type is a typedef for QFlags<OptimizationFlag>. It stores an OR combination of OptimizationFlag values. This enums describe the possible anchors that QGraphicsView can use when the user resizes the view or when the view is transformed. No anchor, i.e. the view leaves the scene's position unchanged. The scene point at the center of the view is used as the anchor. The point under the mouse is used as the anchor. See also resizeAnchor and transformationAnchor. This enum describes how QGraphicsView updates its viewport when the scene contents change or are exposed. When any visible part of the scene changes or is reexposed, QGraphicsView will update the entire viewport. This approach is fastest when QGraphicsView spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization. QGraphicsView will determine the minimal viewport region that requires a redraw, minimizing the time spent drawing by avoiding a redraw of areas that have not changed. This is QGraphicsView's default mode. Although this approach provides the best performance in general, if there are many small visible changes on the scene, QGraphicsView might end up spending more time finding the minimal approach than it will spend drawing. QGraphicsView will attempt to find an optimal update mode by analyzing the areas that require a redraw. The bounding rectangle of all changes in the viewport will be redrawn. This mode has the advantage that QGraphicsView searches only one region for changes, minimizing time spent determining what needs redrawing. The disadvantage is that areas that have not changed also need to be redrawn. QGraphicsView will never update its viewport when the scene changes; the user is expected to control all updates. This mode disables all (potentially slow) item visibility testing in QGraphicsView, and is suitable for scenes that either require a fixed frame rate, or where the viewport is otherwise updated externally. This enum was introduced or modified in Qt 4.3.\n\nThis property holds the alignment of the scene in the view when the whole scene is visible. If the whole scene is visible in the view, (i.e., there are no visible scroll bars,) the view's alignment will decide where the scene will be rendered in the view. For example, if the alignment is Qt::AlignCenter, which is default, the scene will be centered in the view, and if the alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in the top-left corner of the view. This property holds the background brush of the scene. This property sets the background brush for the scene in this view. It is used to override the scene's own background, and defines the behavior of drawBackground(). To provide custom background drawing for this view, you can reimplement drawBackground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::backgroundBrush and foregroundBrush. This property holds which parts of the view are cached. QGraphicsView can cache pre-rendered content in a QPixmap, which is then drawn onto the viewport. The purpose of such caching is to speed up the total rendering time for areas that are slow to render. Texture, gradient and alpha blended backgrounds, for example, can be notibly slow to render; especially with a transformed view. The CacheBackground flag enables caching of the view's background. For example: The cache is invalidated every time the view is transformed. However, when scrolling, only partial invalidation is required. By default, nothing is cached. See also resetCachedContent() and QPixmapCache. This property holds the behavior for dragging the mouse over the scene while the left mouse button is pressed. This property defines what should happen when the user clicks on the scene background and drags the mouse (e.g., scrolling the viewport contents using a pointing hand cursor, or selecting multiple items with a rubber band). The default value, NoDrag, does nothing. This behavior only affects mouse clicks that are not handled by any item. You can define a custom behavior by creating a subclass of QGraphicsView and reimplementing mouseMoveEvent(). This property holds the foreground brush of the scene. This property sets the foreground brush for the scene in this view. It is used to override the scene's own foreground, and defines the behavior of drawForeground(). To provide custom foreground drawing for this view, you can reimplement drawForeground() instead. By default, this property contains a brush with the Qt::NoBrush pattern. See also QGraphicsScene::foregroundBrush and backgroundBrush. This property holds whether the view allowed scene interaction. If enabled, this view is set to allow scene interaction. Otherwise, this view will not allow interaction, and any mouse or key events are ignored (i.e., it will act as a read-only view). By default, this property is true. This property holds flags that can be used to tune QGraphicsView's performance. QGraphicsView uses clipping, extra bounding rect adjustments, and certain other aids to improve rendering quality and performance for the common case graphics scene. However, depending on the target platform, the scene, and the viewport in use, some of these operations can degrade performance. The effect varies from flag to flag; see the OptimizationFlags documentation for details. By default, no optimization flags are enabled. This property was introduced in Qt 4.3. This property holds the default render hints for the view. These hints are used to initialize QPainter before each visible item is drawn. QPainter uses render hints to toggle rendering features such as antialiasing and smooth pixmap transformation. This property holds how the view should position the scene when the view is resized. QGraphicsView uses this property to decide how to position the scene in the viewport when the viewport widget's size changes. The default behavior, NoAnchor, leaves the scene's position unchanged during a resize; the top-left corner of the view will appear to be anchored while resizing. Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment, transformationAnchor, and Qt::WNorthWestGravity. This property holds the behavior for selecting items with a rubber band selection rectangle. This property defines how items are selected when using the RubberBandDrag drag mode. The default value is Qt::IntersectsItemShape; all items whose shape intersects with or is contained by the rubber band are selected. This property was introduced in Qt 4.3. See also dragMode and items(). This property holds the area of the scene visualized by this view. The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars. If unset, or if a null QRectF is set, this property has the same value as QGraphicsScene::sceneRect, and it changes with QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected by the scene. Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use translate() to navigate the scene instead. By default, this property contains a rectangle at the origin with zero width and height. This property holds how the view should position the scene during transformations. QGraphicsView uses this property to decide how to position the scene in the viewport when the transformation matrix changes, and the coordinate system of the view is transformed. The default behavior, AnchorViewCenter, ensures that the scene point at the center of the view remains unchanged during transformations (e.g., when rotating, the scene will appear to rotate around the center of the view). Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, QGraphicsScene uses the view alignment to position the scene in the view. See also alignment and resizeAnchor. This property holds how the viewport should update its contents. QGraphicsView uses this property to decide how to update areas of the scene that have been reexposed or changed. Usually you do not need to modify this property, but there are some cases where doing so can improve rendering performance. See the ViewportUpdateMode documentation for specific details. The default value is MinimalViewportUpdate, where QGraphicsView will update as small an area of the viewport as possible when the contents change. This property was introduced in Qt 4.3. See also ViewportUpdateMode and cacheMode.\n\nConstructs a QGraphicsView and sets the visualized scene to scene. parent is passed to QWidget's constructor. Scrolls the contents of the viewport to ensure that the scene coordinate pos, is centered in the view. Because pos is a floating point coordinate, and the scroll bars operate on integer coordinates, the centering is only an approximation. Note: If the item is close to or outside the border, it will be visible in the view, but not centered. This is an overloaded function. This function is provided for convenience. It's equivalent to calling centerOn(QPointF(x, y)). This is an overloaded function. Scrolls the contents of the viewport to ensure that item is centered in the view. Draws the background of the scene using painter, before any items and the foreground are drawn. Reimplement this function to provide a custom background for this view. If all you want is to define a color, texture or gradient for the background, you can call setBackgroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's backgroundBrush. If no such brush is defined (the default), the scene's drawBackground() function is called instead. See also drawForeground() and QGraphicsScene::drawBackground(). Draws the foreground of the scene using painter, after the background and all items are drawn. Reimplement this function to provide a custom foreground for this view. If all you want is to define a color, texture or gradient for the foreground, you can call setForegroundBrush() instead. All painting is done in scene coordinates. rect is the exposed rectangle. The default implementation fills rect using the view's foregroundBrush. If no such brush is defined (the default), the scene's drawForeground() function is called instead. See also drawBackground() and QGraphicsScene::drawForeground(). Scrolls the contents of the viewport so that the scene rectangle rect is visible, with margins specified in pixels by xmargin and ymargin. If the specified rect cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. This is an overloaded function. This function is provided for convenience. It's equivalent to calling ensureVisible(QRectF(x, y, w, h), xmargin, ymargin). This is an overloaded function. Scrolls the contents of the viewport so that the center of item item is visible, with margins specified in pixels by xmargin and ymargin. If the specified point cannot be reached, the contents are scrolled to the nearest valid position. The default value for both margins is 50 pixels. Scales the view matrix and scrolls the scroll bars to ensure that the scene rectangle rect fits inside the viewport. rect must be inside the scene rect; otherwise, fitInView() cannot guarantee that the whole rect is visible. This function keeps the view's rotation, translation, or shear. The view is scaled according to aspectRatioMode. rect will be centered in the view if it does not fit tightly. It's common to call fitInView() from inside a reimplementation of resizeEvent(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside resizeEvent() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see horizontalScrollBarPolicy() and verticalScrollBarPolicy()). If rect is empty, or if the viewport is too small, this function will do nothing. See also setTransform(), ensureVisible(), and centerOn(). This is an overloaded function. This convenience function is equivalent to calling fitInView(QRectF(x, y, w, h), aspectRatioMode). See also ensureVisible() and centerOn(). This is an overloaded function. Ensures that item fits tightly inside the view, scaling the view according to aspectRatioMode. See also ensureVisible() and centerOn(). Invalidates and schedules a redraw of layers inside rect. rect is in scene coordinates. Any cached content for layers inside rect is unconditionally invalidated and redrawn. You can call this function to notify QGraphicsView of changes to the background or the foreground of the scene. It is commonly used for scenes with tile-based backgrounds to notify changes when QGraphicsView has enabled background caching. Note that QGraphicsView currently supports background caching only (see QGraphicsView::CacheBackground). This function is equivalent to calling update() if any layer but QGraphicsScene::BackgroundLayer is passed. See also QGraphicsScene::invalidate() and update(). Returns true if the view is transformed (i.e., a non-identity transform has been assigned, or the scrollbars are adjusted). This function was introduced in Qt 4.6. See also setTransform(), horizontalScrollBar(), and verticalScrollBar(). Returns the item at position pos, which is in viewport coordinates. If there are several items at this position, this function returns the topmost item. void CustomView::mousePressEvent(QMouseEvent *event) { if (QGraphicsItem *item = itemAt(event->pos())) { qDebug() << \"You clicked on item\" << item; } else { qDebug() << \"You didn't click on an item.\"; } } See also items() and Sorting. This is an overloaded function. This function is provided for convenience. It's equivalent to calling itemAt(QPoint(x, y)). Returns a list of all the items in the associated scene, in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also QGraphicsScene::items() and Sorting. Returns a list of all the items at the position pos in the view. The items are listed in descending stacking order (i.e., the first item in the list is the uppermost item, and the last item is the lowermost item). pos is in viewport coordinates. This function is most commonly called from within mouse event handlers in a subclass in QGraphicsView. pos is in untransformed viewport coordinates, just like QMouseEvent::pos(). void CustomView::mousePressEvent(QMouseEvent *event) { qDebug() << \"There are\" << items(event->pos()).size() << \"items at position\" << mapToScene(event->pos()); } See also QGraphicsScene::items() and Sorting. This function is provided for convenience. It's equivalent to calling items(QPoint(x, y)). This convenience function is equivalent to calling items(QRectF(x, y, w, h), mode). This function was introduced in Qt 4.3. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with rect. rect is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by rect are returned. The items are sorted in descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with polygon. polygon is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by polygon are returned. The items are sorted by descending stacking order (i.e., the first item in the returned list is the uppermost item). See also itemAt(), items(), mapToScene(), and Sorting. This is an overloaded function. Returns a list of all the items that, depending on mode, are either contained by or intersect with path. path is in viewport coordinates. The default value for mode is Qt::IntersectsItemShape; all items whose exact shape intersects with or is contained by path are returned. See also itemAt(), items(), mapToScene(), and Sorting. This function is provided for convenience. It's equivalent to calling mapFromScene(QPointF(x, y)). This function is provided for convenience. It's equivalent to calling mapFromScene(QRectF(x, y, w, h)). Note: It can be useful to map the whole rectangle covered by the pixel at point instead of the point itself. To do this, you can call mapToScene(QRect(point, QSize(2, 2))). This function is provided for convenience. It's equivalent to calling mapToScene(QPoint(x, y)). This function is provided for convenience. It's equivalent to calling mapToScene(QRect(x, y, w, h)). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setMatrix(), transform(), rotate(), scale(), shear(), and translate(). Renders the source rect, which is in view coordinates, from the scene into target, which is in paint device coordinates, using painter. This function is useful for capturing the contents of the view onto a paint device, such as a QImage (e.g., to take a screenshot), or for printing to QPrinter. For example: If source is a null rect, this function will use viewport()->rect() to determine what to draw. If target is a null rect, the full dimensions of painter's paint device (e.g., for a QPrinter, the page size) will be used. The source rect contents will be transformed according to aspectRatioMode to fit into the target rect. By default, the aspect ratio is kept, and source is scaled to fit in target. Resets any cached content. Calling this function will clear QGraphicsView's cache. If the current cache mode is CacheNone, this function does nothing. This function is called automatically for you when the backgroundBrush or QGraphicsScene::backgroundBrush properties change; you only need to call this function if you have reimplemented QGraphicsScene::drawBackground() or QGraphicsView::drawBackground() to draw a custom background, and need to trigger a full redraw. Resets the view transformation matrix to the identity matrix. Resets the view transformation to the identity matrix. See also transform() and setTransform(). See also setTransform(), transform(), scale(), shear(), and translate(). See also setTransform(), transform(), rotate(), shear(), and translate(). Returns a pointer to the scene that is currently visualized in the view. If no scene is currently visualized, 0 is returned. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix tranforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interation with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordinate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also matrix(), setTransform(), rotate(), scale(), shear(), and translate(). Enables flag if enabled is true; otherwise disables flag. If enabled is true, the render hint hint is enabled; otherwise it is disabled. Sets the current scene to scene. If scene is already being viewed, this function does nothing. When a scene is set on a view, the QGraphicsScene::changed() signal is automatically connected to this view's updateScene() slot, and the view's scroll bars are adjusted to fit the size of the scene. If combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default. The transformation matrix tranforms the scene into view coordinates. Using the default transformation, provided by the identity matrix, one pixel in the view represents one unit in the scene (e.g., a 10x10 rectangular item is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is then drawn using 20x20 pixels in the view). To simplify interation with items using a transformed view, QGraphicsView provides mapTo... and mapFrom... functions that can translate between scene and view coordinates. For example, you can call mapToScene() to map a view coordiate to a floating point scene coordinate, or mapFromScene() to map from floating point scene coordinates to view coordinates. See also transform(), rotate(), scale(), shear(), and translate(). This slot is called by QAbstractScrollArea after setViewport() has been called. Reimplement this function in a subclass of QGraphicsView to initialize the new viewport widget before it is used. See also setTransform(), transform(), rotate(), scale(), and translate(). Returns the current transformation matrix for the view. If no current transformation is set, the identity matrix is returned. See also setTransform(), rotate(), scale(), shear(), and translate(). See also setTransform(), transform(), rotate(), and shear(). Schedules an update of the scene rectangles rects. Notifies QGraphicsView that the scene's scene rect has changed. rect is the new scene rect. If the view already has an explicitly set scene rect, this function does nothing. See also sceneRect and QGraphicsScene::sceneRectChanged(). See also mapToScene() and mapFromScene()."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtransform.html",
        "document": "The QTransform class specifies 2D transformations of a coordinate system. More...\n\nA transformation specifies how to translate, scale, shear, rotate or project the coordinate system, and is typically used when rendering graphics. A QTransform object can be built using the setMatrix(), scale(), rotate(), translate() and shear() functions. Alternatively, it can be built by applying basic matrix operations. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the reset() function. The QTransform class supports mapping of graphic primitives: A given point, line, polygon, region, or painter path can be mapped to the coordinate system defined by this matrix using the map() function. In case of a rectangle, its coordinates can be transformed using the mapRect() function. A rectangle can also be transformed into a polygon (mapped to the coordinate system defined by this matrix), using the mapToPolygon() function. QTransform provides the isIdentity() function which returns if the matrix is the identity matrix, and the isInvertible() function which returns if the matrix is non-singular (i.e. AB = BA = I). The inverted() function returns an inverted copy of this matrix if it is invertible (otherwise it returns the identity matrix), and adjoint() returns the matrix's classical adjoint. In addition, QTransform provides the determinant() function which returns the matrix's determinant. Finally, the QTransform class supports matrix multiplication, addition and subtraction, and objects of the class can be streamed as well as compared. When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in QPainter. By default, QPainter operates on the associated device's own coordinate system. The standard coordinate system of a QPaintDevice has its origin located at the top-left position. The x values increase to the right; y values increase downward. For a complete description, see the coordinate system documentation. QPainter has functions to translate, scale, shear and rotate the coordinate system without using a QTransform. For example: Although these functions are very convenient, it can be more efficient to build a QTransform and call QPainter::setTransform() if you want to perform more than a single transform operation. For example: A QTransform object contains a 3 x 3 matrix. The ( ) and ( ) elements specify horizontal and vertical translation. The and elements specify horizontal and vertical scaling. The and elements specify horizontal and vertical shearing. And finally, the and elements specify horizontal and vertical projection, with as an additional projection factor. QTransform transforms a point in the plane to another point using the following formulas: The point (x, y) is the original point, and (x', y') is the transformed point. (x', y') can be transformed back to (x, y) by performing the same operation on the inverted() matrix. The various matrix elements can be set when constructing the matrix, or by using the setMatrix() function later on. They can also be manipulated using the translate(), rotate(), scale() and shear() convenience functions. The currently set values can be retrieved using the m11(), m12(), m13(), m21(), m22(), m23(), m31(), m32(), m33(), dx() and dy() functions. Translation is the simplest transformation. Setting and will move the coordinate system units along the X axis and units along the Y axis. Scaling can be done by setting and . For example, setting to 2 and to 1.5 will double the height and increase the width by 50%. The identity matrix has , , and set to 1 (all others are set to 0) mapping a point to itself. Shearing is controlled by and . Setting these elements to values different from zero will twist the coordinate system. Rotation is achieved by setting both the shearing factors and the scaling factors. Perspective transformation is achieved by setting both the projection factors and the scaling factors. Here's the combined transformations example using basic matrix operations: The combined transform first scales each operand, then rotates it, and finally translates it, just as in the order in which the product of its factors is written. This means the point to which the transforms are applied is implicitly multiplied on the left with the transform to its right. The matrix notation in QTransform is the transpose of a commonly-taught convention which represents transforms and points as matrices and vectors. That convention multiplies its matrix on the left and column vector to the right. In other words, when several transforms are applied to a point, the right-most matrix acts directly on the vector first. Then the next matrix to the left acts on the result of the first operation - and so on. As a result, that convention multiplies the matrices that make up a composite transform in the reverse of the order in QTransform, as you can see in Combining Transforms. Transposing the matrices, and combining them to the right of a row vector that represents the point, lets the matrices of transforms appear, in their product, in the order in which we think of the transforms being applied to the point.\n\nSee also QPainter, Coordinate System, Affine Transformations Example, and Transformations Example.\n\nReturns if t1 and t2 are equal, allowing for a small fuzziness factor for floating-point comparisons; false otherwise. Returns the hash value for key, using seed to seed the calculation. This is the same as matrix.map(line). This is the same as matrix.map(line). This is the same as matrix.map(path). This is the same as matrix.map(point). This is the same as matrix.map(polygon). This is the same as matrix.map(polygon). This is the same as matrix.map(region). Writes the given matrix to the given stream and returns a reference to the stream. Reads the given matrix from the given stream and returns a reference to the stream."
    },
    {
        "link": "https://stackoverflow.com/questions/39338784/qt-qtransform-rotation",
        "document": "As you have not provided a minimal complete code that reproduces the problem, I cannot guess what is wrong there. But the most probable reason is incorrect calculation. At least the following draft works:\n\nThe transformation used here is complicated because of need to rotate each item relative to it's central , not . This also may be the case.\n\nFont and angles are increased to see considered effects better."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtwidgets-painting-transformations-example.html",
        "document": "The Transformations example shows how transformations influence the way that QPainter renders graphics primitives.\n\nThe application allows the user to manipulate the rendering of a shape by changing the translation, rotation and scale of QPainter's coordinate system.\n\nThe example consists of two classes and a global enum:\n• The class controls the rendering of a given shape.\n• The class is the application's main window.\n• The enum describes the various transformation operations available in the application.\n\nFirst we will take a quick look at the enum, then we will review the class to see how a shape is rendered. Finally, we will take a look at the Transformations application's features implemented in the class.\n\nNormally, the QPainter operates on the associated device's own coordinate system, but it also has good support for coordinate transformations.\n\nThe default coordinate system of a paint device has its origin at the top-left corner. The x values increase to the right and the y values increase downwards. You can scale the coordinate system by a given offset using the QPainter::scale() function, you can rotate it clockwise using the QPainter::rotate() function and you can translate it (i.e. adding a given offset to the points) using the QPainter::translate() function. You can also twist the coordinate system around the origin (called shearing) using the QPainter::shear() function.\n\nAll the transformation operations operate on QPainter's transformation matrix that you can retrieve using the QPainter::worldTransform() function. A matrix transforms a point in the plane to another point. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe global enum is declared in the file and describes the various transformation operations available in the Transformations application.\n\nThe class inherits QWidget, and controls the rendering of a given shape.\n\nWe declare two public functions, and , to be able to specify the widget's shape and to transform the coordinate system the shape is rendered within.\n\nWe reimplement the QWidget's minimumSizeHint() and sizeHint() functions to give the widget a reasonable size within our application, and we reimplement the QWidget::paintEvent() event handler to draw the render area's shape applying the user's transformation choices.\n\nWe also declare several convenience functions to draw the shape, the coordinate system's outline and the coordinates, and to transform the painter according to the chosen transformations.\n\nIn addition, the widget keeps a list of the currently applied transformation operations, a reference to its shape, and a couple of convenience variables that we will use when rendering the coordinates.\n\nThe widget controls the rendering of a given shape, including the transformations of the coordinate system, by reimplementing the QWidget::paintEvent() event handler. But first we will take a quick look at the constructor and at the functions that provides access to the widget:\n\nIn the constructor we pass the parent parameter on to the base class, and customize the font that we will use to render the coordinates. The QWidget::font() function returns the font currently set for the widget. As long as no special font has been set, or after QWidget::setFont() is called, this is either a special font for the widget class, the parent's font or (if this widget is a top level widget) the default application font.\n\nAfter ensuring that the font's size is 12 points, we extract the rectangles enclosing the coordinate letters, 'x' and 'y', using the QFontMetrics class.\n\nQFontMetrics provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font. The QFontMetrics::boundingRect() function returns the bounding rectangle of the given character relative to the left-most point on the base line.\n\nIn the and functions we update the widget by storing the new value or values followed by a call to the QWidget::update() slot which schedules a paint event for processing when Qt returns to the main event loop.\n\nWe reimplement the QWidget's minimumSizeHint() and sizeHint() functions to give the widget a reasonable size within our application. The default implementations of these functions returns an invalid size if there is no layout for this widget, and returns the layout's minimum size or preferred size, respectively, otherwise.\n\nThe event handler receives the widget's paint events. A paint event is a request to repaint all or part of the widget. It can happen as a result of QWidget::repaint() or QWidget::update(), or because the widget was obscured and has now been uncovered, or for many other reasons.\n\nFirst we create a QPainter for the widget. The QPainter::Antialiasing render hint indicates that the engine should antialias edges of primitives if possible. Then we erase the area that needs to be repainted using the QPainter::fillRect() function.\n\nWe also translate the coordinate system with an constant offset to ensure that the original shape is renderend with a suitable margin.\n\nBefore we start to render the shape, we call the QPainter::save() function.\n\nQPainter::save() saves the current painter state (i.e. pushes the state onto a stack) including the current coordinate system. The rationale for saving the painter state is that the following call to the function will transform the coordinate system depending on the currently chosen transformation operations, and we need a way to get back to the original state to draw the outline.\n\nAfter transforming the coordinate system, we draw the 's shape, and then we restore the painter state using the QPainter::restore() function (i.e. popping the saved state off the stack).\n\nThen we draw the square outline.\n\nSince we want the coordinates to correspond with the coordinate system the shape is rendered within, we must make another call to the function.\n\nThe order of the painting operations is essential with respect to the shared pixels. The reason why we don't render the coordinates when the coordinate system already is transformed to render the shape, but instead defer their rendering to the end, is that we want the coordinates to appear on top of the shape and its outline.\n\nThere is no need to save the QPainter state this time since drawing the coordinates is the last painting operation.\n\nThe , and are convenience functions called from the event handler. For more information about QPainter's basic drawing operations and how to display basic graphics primitives, see the Basic Drawing example.\n\nThe convenience function is also called from the event handler, and transforms the given QPainter's coordinate system according to the user's transformation choices.\n\nThe class is the Transformations application's main window.\n\nThe application displays four widgets. The left-most widget renders the shape in QPainter's default coordinate system, the others render the shape with the chosen transformation in addition to all the transformations applied to the widgets to their left.\n\nWe declare two public slots to make the application able to respond to user interaction, updating the displayed widgets according to the user's transformation choices.\n\nThe slot updates each of the widgets applying the currently chosen transformation operations, and is called whenever the user changes the selected operations. The slot updates the widgets' shapes whenever the user changes the preferred shape.\n\nWe also declare a private convenience function, , that is used when constructing the widget, and we declare pointers to the various components of the widget. We choose to keep the available shapes in a QList of QPainterPaths. In addition we declare a private enum counting the number of displayed widgets except the widget that renders the shape in QPainter's default coordinate system.\n\nIn the constructor we create and initialize the application's components:\n\nFirst we create the widget that will render the shape in the default coordinate system. We also create the associated QComboBox that allows the user to choose among four different shapes: A clock, a house, a text and a truck. The shapes themselves are created at the end of the constructor, using the convenience function.\n\nThen we create the widgets that will render their shapes with coordinate transformations. By default the applied operation is No Transformation, i.e. the shapes are rendered within the default coordinate system. We create and initialize the associated QComboBoxes with items corresponding to the various transformation operations described by the global enum.\n\nWe also connect the QComboBoxes' activated() signal to the slot to update the application whenever the user changes the selected transformation operations.\n\nFinally, we set the layout for the application window using the QWidget::setLayout() function, construct the available shapes using the private convenience function, and make the application show the clock shape on startup using the public slot before we set the window title.\n\nThe function is called from the constructor and create the QPainterPath objects representing the shapes that are used in the application. For construction details, see the example file. The shapes are stored in a QList. The QList::append() function inserts the given shape at the end of the list.\n\nWe also connect the associated QComboBox's activated() signal to the slot to update the application when the user changes the preferred shape.\n\nThe public slot is called whenever the user changes the selected operations.\n\nWe retrieve the chosen transformation operation for each of the transformed widgets by querying the associated QComboBoxes. The transformed widgets are supposed to render the shape with the transformation specified by its associated combobox in addition to all the transformations applied to the widgets to its left. For that reason, for each widget we query, we append the associated operation to a QList of transformations which we apply to the widget before proceeding to the next.\n\nThe slot is called whenever the user changes the preferred shape, updating the widgets using their public function.\n\nThe Transformations example shows how transformations influence the way that QPainter renders graphics primitives. Normally, the QPainter operates on the device's own coordinate system, but it also has good support for coordinate transformations. With the Transformations application you can scale, rotate and translate QPainter's coordinate system. The order in which these transformations are applied is essential for the result.\n\nAll the transformation operations operate on QPainter's transformation matrix. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe Qt reference documentation provides several painting examples. Among these is the Affine Transformations example that shows Qt's ability to perform transformations on painting operations. The example also allows the user to experiment with the various transformation operations."
    },
    {
        "link": "https://codebrowser.dev/qt6/qtbase/src/gui/painting/qtransform.cpp.html",
        "document": ""
    },
    {
        "link": "https://dreamswork.github.io/qt4/classQTransform.html",
        "document": "The QTransform class specifies 2D transformations of a coordinate system. More...\n\nA transformation specifies how to translate, scale, shear, rotate or project the coordinate system, and is typically used when rendering graphics. QTransform differs from QMatrix in that it is a true 3x3 matrix, allowing perspective transformations. QTransform's toAffine() method allows casting QTransform to QMatrix. If a perspective transformation has been specified on the matrix, then the conversion will cause loss of data. QTransform is the recommended transformation class in Qt. A QTransform object can be built using the setMatrix(), scale(), rotate(), translate() and shear() functions. Alternatively, it can be built by applying basic matrix operations. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the reset() function. The QTransform class supports mapping of graphic primitives: A given point, line, polygon, region, or painter path can be mapped to the coordinate system defined by this matrix using the map() function. In case of a rectangle, its coordinates can be transformed using the mapRect() function. A rectangle can also be transformed into a polygon (mapped to the coordinate system defined by this matrix), using the mapToPolygon() function. QTransform provides the isIdentity() function which returns true if the matrix is the identity matrix, and the isInvertible() function which returns true if the matrix is non-singular (i.e. AB = BA = I). The inverted() function returns an inverted copy of this matrix if it is invertible (otherwise it returns the identity matrix), and adjoint() returns the matrix's classical adjoint. In addition, QTransform provides the determinant() function which returns the matrix's determinant. Finally, the QTransform class supports matrix multiplication, addition and subtraction, and objects of the class can be streamed as well as compared. When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in QPainter. By default, QPainter operates on the associated device's own coordinate system. The standard coordinate system of a QPaintDevice has its origin located at the top-left position. The x values increase to the right; y values increase downward. For a complete description, see the Coordinate System documentation. QPainter has functions to translate, scale, shear and rotate the coordinate system without using a QTransform. For example: Although these functions are very convenient, it can be more efficient to build a QTransform and call QPainter::setTransform() if you want to perform more than a single transform operation. For example: A QTransform object contains a 3 x 3 matrix. The ( ) and ( ) elements specify horizontal and vertical translation. The and elements specify horizontal and vertical scaling. The and elements specify horizontal and vertical shearing. And finally, the and elements specify horizontal and vertical projection, with as an additional projection factor. QTransform transforms a point in the plane to another point using the following formulas: The point (x, y) is the original point, and (x', y') is the transformed point. (x', y') can be transformed back to (x, y) by performing the same operation on the inverted() matrix. The various matrix elements can be set when constructing the matrix, or by using the setMatrix() function later on. They can also be manipulated using the translate(), rotate(), scale() and shear() convenience functions. The currently set values can be retrieved using the m11(), m12(), m13(), m21(), m22(), m23(), m31(), m32(), m33(), dx() and dy() functions. Translation is the simplest transformation. Setting and will move the coordinate system units along the X axis and units along the Y axis. Scaling can be done by setting and . For example, setting to 2 and to 1.5 will double the height and increase the width by 50%. The identity matrix has , , and set to 1 (all others are set to 0) mapping a point to itself. Shearing is controlled by and . Setting these elements to values different from zero will twist the coordinate system. Rotation is achieved by setting both the shearing factors and the scaling factors. Perspective transformation is achieved by setting both the projection factors and the scaling factors. Here's the combined transformations example using basic matrix operations:\n\nThe documentation for this class was generated from the following files:"
    }
]