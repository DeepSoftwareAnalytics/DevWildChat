[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading",
        "document": "Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times. Lazy loading can occur on different moments in the application, but it typically happens on some user interactions such as scrolling and navigation.\n\nAs the web has evolved, we have come to see huge increases in the number and size of assets sent to users. Between 2011 and 2019, the median resource weight increased from ~100KB to ~400KB for desktop and ~50KB to ~350KB for mobile. While Image size has increased from ~250KB to ~900KB on desktop and ~100KB to ~850KB on mobile. One of the methods we can use to tackle this problem is to shorten the Critical Rendering Path length by lazy loading resources that are not critical for the first render to happen. A practical example would be when you land on the home page of an e-commerce site with a link to a cart page/section, and none of the cart page's resources (such as JavaScript, CSS, and images) are downloaded until you navigate there.\n\nBy default, CSS is treated as a render blocking resource, so the browser won't render any processed content until the CSSOM is constructed. CSS must be thin, delivered as quickly as possible, and the usage media types and queries are advised to unblock rendering. It is possible to perform some CSS optimizations to achieve that.\n\nBy default, font requests are delayed until the render tree is constructed, which can result in delayed text rendering. It is possible to override the default behavior and preload web font resources using , the CSS descriptor, and the Font Loading API.\n\nVery often, webpages contain many images that contribute to data-usage and how fast a page can load. Most of those images are off-screen (non-critical), requiring a user interaction, like scrolling, in order to view them. The attribute on an element, or the attribute on an , can be used to instruct the browser to defer loading of images/iframes that are off-screen until the user scrolls near them. This allows non-critical resources to load only if needed, potentially speeding up initial page loads and reducing network usage. The event fires when the eagerly-loaded content has all been loaded. At that time, it's entirely possible (or even likely) that there may be lazily-loaded images or iframes within the visual viewport that haven't yet loaded. You can determine if a given image has finished loading by examining the value of its Boolean property. Intersection Observers allow the user to know when an observed element enters or exits the browser's viewport. When browser compatibility is crucial, there are a few options:\n• fallback to scroll, resize or orientation change event handlers to determine if a specific element is in viewport"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Lazy_loading",
        "document": "Lazy loading is a strategy to identify resources as non-blocking (non-critical) and load these only when needed. It's a way to shorten the length of the critical rendering path, which translates into reduced page load times. Lazy loading can occur on different moments in the application, but it typically happens on some user interactions such as scrolling and navigation.\n\nAs the web has evolved, we have come to see huge increases in the number and size of assets sent to users. Between 2011 and 2019, the median resource weight increased from ~100KB to ~400KB for desktop and ~50KB to ~350KB for mobile. While Image size has increased from ~250KB to ~900KB on desktop and ~100KB to ~850KB on mobile. One of the methods we can use to tackle this problem is to shorten the Critical Rendering Path length by lazy loading resources that are not critical for the first render to happen. A practical example would be when you land on the home page of an e-commerce site with a link to a cart page/section, and none of the cart page's resources (such as JavaScript, CSS, and images) are downloaded until you navigate there.\n\nBy default, CSS is treated as a render blocking resource, so the browser won't render any processed content until the CSSOM is constructed. CSS must be thin, delivered as quickly as possible, and the usage media types and queries are advised to unblock rendering. It is possible to perform some CSS optimizations to achieve that.\n\nBy default, font requests are delayed until the render tree is constructed, which can result in delayed text rendering. It is possible to override the default behavior and preload web font resources using , the CSS descriptor, and the Font Loading API.\n\nVery often, webpages contain many images that contribute to data-usage and how fast a page can load. Most of those images are off-screen (non-critical), requiring a user interaction, like scrolling, in order to view them. The attribute on an element, or the attribute on an , can be used to instruct the browser to defer loading of images/iframes that are off-screen until the user scrolls near them. This allows non-critical resources to load only if needed, potentially speeding up initial page loads and reducing network usage. The event fires when the eagerly-loaded content has all been loaded. At that time, it's entirely possible (or even likely) that there may be lazily-loaded images or iframes within the visual viewport that haven't yet loaded. You can determine if a given image has finished loading by examining the value of its Boolean property. Intersection Observers allow the user to know when an observed element enters or exits the browser's viewport. When browser compatibility is crucial, there are a few options:\n• fallback to scroll, resize or orientation change event handlers to determine if a specific element is in viewport"
    },
    {
        "link": "https://web.dev/articles/browser-level-image-lazy-loading",
        "document": "You can use the attribute to lazy-load images without the need to write custom lazy-loading code or use a separate JavaScript library. Here's a demo of the feature:\n\nThis page walks through the details of implementing lazy-loading in the browser.\n\nAccording to the HTTP Archive, images are the most-requested asset type for most websites, and they usually take up more bandwidth than any other resource. At the 90th percentile, sites send over 5 MB of images on desktop and mobile.\n\nPreviously, there were two ways to defer the loading of off-screen images:\n\nEither option can let developers include lazy loading behavior, and many developers have built third-party libraries to provide abstractions that are even easier to use.\n\nWith lazy loading supported directly by the browser, however, there's no need for an external library. Browser-level lazy loading also ensures that loading of images still works even if the client disables JavaScript. Note however that loading is only deferred when JavaScript is enabled.\n\nChrome loads images at different priorities depending on where they're located relative to the device viewport. Images below the viewport are loaded with a lower priority, but they're still fetched as the page loads.\n\nYou can use the attribute to completely defer the loading of offscreen images:\n\nHere are the supported values for the attribute:\n• : Defer loading of the resource until it reaches a calculated distance from the viewport.\n• : Default loading behavior of the browser, which is the same as not including the attribute and means the image is loaded regardless of where it's located on the page. This is the default, but it can be useful to set explicitly if your tooling automatically adds when there's no explicit value, or if your linter complains if it isn't explicitly set.\n\nRelationship between the attribute and fetch priority\n\nThe value is an instruction to load the image as usual, without delaying the load further if the image is off-screen. It doesn't load the image faster than another image that doesn't have a attribute.\n\nIf you want to increase the fetch priority of an important image (for example, the LCP image), use Fetch Priority with .\n\nAn image with and is still delayed while it's off-screen, and then fetched with a high priority when it's almost within the viewport. This combination isn't really necessary because the browser would likely load that image with high priority anyway.\n\nAll images that are immediately viewable without scrolling load normally. Images far below the device viewport are only fetched when the user scrolls near them.\n\nChromium's implementation of lazy loading tries to ensure that offscreen images are loaded early enough that they finish loading by the time the user scrolls to them by fetching them well before they become visible in the viewport.\n\nThe distance threshold varies depending on the following factors:\n• The type of image resource being fetched\n\nYou can find the default values for the different effective connection types in the Chromium source. You can experiment with these different thresholds by throttling the network in DevTools.\n\nIn July 2020, Chrome made significant improvements to align the image lazy loading distance-from-viewport thresholds to better meet developer expectations.\n\nOn fast connections (4G), we reduced Chrome's distance-from-viewport thresholds from to and on slower connections (3G or lower), changed the threshold from to . This change achieves two things:\n• behaves closer to the experience offered by JavaScript lazy loading libraries.\n• The new distance-from-viewport thresholds still means images will probably have loaded by the time a user has scrolled to them.\n\nYou can find a comparison between the old versus new distance-from-viewport thresholds for one of our demos on a fast connection (4G) next:\n\nand the new thresholds versus LazySizes (a popular JavaScript lazy loading library):\n\nWhile the browser loads an image, it doesn't immediately know the image's dimensions, unless they're explicitly specified. To let the browser reserve enough space on a page for images, and avoid disruptive layout shifts, we recommend adding and attributes to all tags.\n\nAlternatively, specify their values directly in an inline style:\n\nThe best practice of setting dimensions applies to tags regardless of whether you're lazy loading them, but lazy loading can make it more important.\n\nLazy loading in Chromium is implemented in a way that makes images more likely to be loaded as soon as they're visible, but there's still a chance that they won't load at the right time. If that happens, not specifying and on your images increases their impact on Cumulative Layout Shift. If you can't specify your images' dimensions, lazy loading them can save network resources at the risk of these increased layout shifts.\n\nIn most scenarios, images still lazy load if you don't specify dimensions, but there are a few edge cases you should be aware of. Without and specified, image dimensions default to 0×0 pixels. If you have a gallery of images, the browser might decide that all of them fit inside the viewport at the start, because each image takes up no space and no image is pushed offscreen. In this case, the browser decides to load everything, making the page load more slowly.\n\nFor an example of how works with large numbers of images, refer to this demo.\n\nYou can also lazy-load images you've defined using the element:\n\nAlthough the browser decides which image to load from any of the elements, you only need to add to the fallback element.\n\nAlways eager-load images visible in the first viewport\n\nFor images that are visible when the user first loads the page, and especially for LCP images, use the browser's default eager loading so they can be available right away. For more information, see The performance effects of too much lazy-loading.\n\nUse only for images outside the initial viewport. The browser can't lazy-load an image until it knows where the image should be on the page, which causes them to load more slowly.\n\nBrowsers that don't support the attribute ignore it. They don't get the benefits of lazy loading, but there's no negative impact from including it.\n\nPreviously, Chromium automatically lazy-loaded any images that were well suited to being deferred if Lite mode was enabled on Chrome for Android and the attribute was either not provided or set to . However, Lite mode and have been deprecated and there are no plans to provide automatically lazy-load of images in Chrome.\n\nCan I change how close an image needs to be to the viewport before it loads?\n\nThese values are hardcoded and can't be changed through the API. However, they might change in the future as browsers experiment with different threshold distances and variables.\n\nCan CSS background images use the attribute?\n\nNo, you can only use it with tags.\n\nCan work with images in the viewport that aren't immediately visible?\n\nUsing can prevent images being loaded when they aren't visible but are within the calculated distance. These images might be behind a carousel or hidden by CSS for certain screen sizes. For example, Chrome, Safari, and Firefox don't load images using styling, either on the image element or on a parent element. However, other image hiding techniques, such as using styling, still cause the browser to load the image. Always test your implementation thoroughly to make sure it's acting as intended.\n\nChrome 121 changed the behavior for horizontal-scrolling images like carousels. These now use the same thresholds as vertical scrolling. This means for the carousel use case, images will be loaded before they visible in the viewport. This means the image loading is less likely to be noticeable to the user, but at the cost of more downloads. Use the Horizontal Lazy Loading demo to compare behaviour in Chrome versus Safari and Firefox.\n\nWhat if I'm already using a third-party library or a script to lazy-load images?\n\nWith full support of lazy loading built into modern browsers, you probably don't need a third-party library or script to lazy-load images.\n\nOne reason to continue to use a third-party library alongside is to provide a polyfill for browsers that don't support the attribute, or to have more control over when lazy loading is triggered.\n\nHow do I handle browsers that don't support lazy loading?\n\nBrowser-level image lazy loading is well supported across all the major browsers and is recommended for most use cases, to remove the need for extra dependencies on JavaScript.\n\nHowever, if you have a need to support more browsers or want to have more control over lazy-loading thresholds then you can use a third-party library to lazy-load images on your site.\n\nYou can use the property to detect whether a browser supports the feature:\n\nFor example, lazysizes is a popular JavaScript lazy loading library. You can detect support for the attribute to load lazysizes as a fallback library only when isn't supported. This works as follows:\n• Replace with to avoid an eager load in unsupported browsers. If the attribute is supported, swap for .\n• If isn't supported, load a fallback from lazysizes and initiate it, using the class to indicate which images to lazy-load:\n\nHere's a demo of this pattern. Try it in an older browser to see the fallback in action.\n\nIs lazy loading for iframes also supported in browsers?\n\nhas also been standardized. This lets you lazy-load iframes using the attribute. For more information, see It's time to lazy-load offscreen iframes!\n\nHow does browser-level lazy loading affect advertisements on a web page?\n\nAll ads displayed to the user as images or iframes lazy-load just like any other image or iframe.\n\nAll images and iframes load immediately when the page is printed. See issue #875403 for details.\n\nLighthouse 6.0 and higher factor in approaches for offscreen image lazy loading that can use different thresholds, letting them pass the Defer offscreen images audit.\n\nBrowser support for lazy loading images can make it significantly easier for you to improve your pages' performance.\n\nAre you noticing any unusual behavior with this feature enabled in Chrome? File a bug!"
    },
    {
        "link": "https://imagekit.io/blog/lazy-loading-images-complete-guide",
        "document": "Images are critical for every website and application today. Whether it be marketing banners, product images or logos, it is impossible to imagine a website without images. Sadly though, images are large in size making them the single largest contributor to the page size.\n\nAs per the latest HTTP Archive data, the median page size on desktops is 1511 KB. Images make up for almost 650 KB of that size, roughly 45% of the total page size. Now, since we cannot do away with images, we need to make our web pages load fast with them.\n\nIn this guide, we will talk about lazy loading images, a technique that helps improve the page load time and reduces page size, while still retaining all the images on the page.\n\nLazy Loading Images is a set of techniques in web and application development that defer the loading of images on a page to a later point in time - when those images are actually needed, instead of loading them up front. These techniques help in improving performance, better utilization of the device’s resources, and reducing associated costs.\n\nHere is a quick video to help you understand better:\n\nThe word “lazy” in the English language is often attributed to the act of avoiding work as long as possible.\n\nSimilarly, lazy loading defers the loading of resources on the page till they are actually needed. Instead of loading these resources as soon as the page loads, which is what normally happens, the loading of these resources is put off till the moment the user actually needs to view them.\n\nThe technique of lazy loading can be applied to almost all the resources on a page. For example, in a single page application, if a JS file is not needed until later, it is best not to load it initially. If an image is not needed up front, load it later when it actually needs to be viewed.\n\nWhy go for lazy loading images at all?\n\nLazy Loading defers the loading of an image that is not needed on the page immediately. An image, not visible to the user when the page loads, is loaded later when the user scrolls and the image actually becomes visible. If the user never scrolls, an image that is not visible to the user never gets loaded.\n\nThis is the most important one for you as a website administrator - better performance and load time.\n\nWith lazy loading, you are reducing the number of images that need to be loaded on the page initially. Lesser resource requests mean lesser bytes to download and lesser competition for the limited network bandwidth available to the user. This ensures that the device is able to download and process the remaining resources much faster. Hence, the page becomes usable much sooner as compared to one without lazy loading.\n\nThe second benefit for you is in terms of delivery costs. Image delivery, or delivery of any other asset, is usually charged on the basis of the number of bytes transferred.\n\nAs mentioned earlier, with lazy loading, if the image is not visible, it never gets loaded. Thus, you reduce the total bytes delivered on the page., especially for users that bounce off the page or interact with only the top portion of the page. This reduction in bytes transferred from your delivery network reduces delivery costs. This will become more apparent as we explore lazy loading further.\n\nWhich Images can be Lazy Loaded?\n\nThe basic idea of lazy loading is simple - defer loading anything that is not needed right now. For images it usually translates to any image that is not visible to the user up front can be lazy loaded.\n\nAs the user scrolls down the page, the image placeholders start coming into viewport (visible part of the webpage). We trigger the load for these images when they become visible.\n\nYou can find out which images are a candidate for lazy loading and how many bytes you can save on the initial page load by using Google Lighthouse audit tool. The audit performed by this tool has a section dedicated for offscreen images. You can also use ImageKit’s website analyzer to identify if your website uses lazy loading or not, in addition other critical image-related optimizations on your page.\n\nLazy loading is critical not only for good performance, but also to deliver a good user experience.\n\nImages on a webpage can be loaded in two ways - using the <img> tag, or using the CSS `background` property. Let's first look at the more common of the two, the <img> tag, and then move on to CSS background images.\n\nThe general concept of lazy loading images in <img> tag\n\nLazy loading images can be broken down into two steps:\n\nStep one is to prevent the image load up front. For images loaded using the tag, the browser uses the attribute of the tag to trigger the image load. Irrespective of whether it is the 1st or the 1000th image in your HTML and well off-screen, if the browser gets the attribute, it would trigger the image load.\n\nThus, to lazyload such images, put the image URL in an attribute other than . Let’s say we specify the image URL in the attribute of the image tag. Now that is empty, the browser doesn’t trigger the image load\n\nNow that we've stopped the upfront load, we need to tell the browser when to load the image.\n\nFor this, we check that as soon as the image (i.e., its placeholder) enters the viewport, we trigger the load.\n\nTo check when an image enters the viewport, there are two ways:\n\nIn this technique, we use event listeners on the , and events in the browser. The scroll event is an obvious one to check when the user scrolls the page. The resize and orientationChange events are equally important for lazy loading. The resize event occurs when the size of the browser window changes. The orientationChange event gets triggered when the device is rotated from landscape to portrait mode, or vice versa. In such cases, the number of images that become visible on the screen will change. Therefore, we'll need to trigger a load for these images.\n\nWhen either of these events occur, we find all the images on the page that are to be lazy loaded and haven't been loaded yet. From these images, we check which ones are now in the viewport. This is done using the image’s top offset, the current document scroll top, and window height. If it has entered the viewport, we pick the URL from attribute and put it in the attribute. This triggers the image load. We also remove the class that identifies the images to be lazily loaded for events that trigger later. Once all the images are loaded, we remove the event listeners.\n\nHere is a working example of this approach.\n\nIf you notice, the first 3 images in the example are loaded up front. The URL is present directly in the attribute instead of the attribute. This is essential for a good user experience. Since these images are at the top of the page, they should be made visible as soon as possible. We must not wait for an event or JS execution to load them.\n\nIntersection Observer API is a relatively new API in browsers. It makes it really simple to detect when an element enters the viewport, and take an action when it does. In the previous method, we had to bind events, keep performance in mind, and implement a way to calculate if the element was in the viewport or not. The Intersection Observer API makes this really simple, helps avoid the math, and delivers great performance.\n\nAn example of using the Intersection Observer API to lazy load images:\n\nWe attach the observer on all the images to be lazy loaded. Once the API detects that the element has entered the viewport, using the property, we pick the URL from the attribute and move it to the attribute for the browser to trigger the image load. Once this is done, we remove the lazy class from the image, and also remove the observer from that image.\n\nIf you compare the time taken to load an image in both the methods, event listeners vs Intersection Observer, you would find that using the Intersection Observer API, the image load is triggered much quicker, and yet the site doesn’t appear sluggish on scrolling. In the method involving event listeners, we had to add a timeout to make it performant, which has a marginal impact on the user experience as the image load is triggered with a slight delay.\n\nHowever, the support for Intersection Observer API is not available across all browsers. Hence, we need to fall back to the event listener method in browsers where the Intersection Observer API is not supported. We have taken this into account in the example above.\n\nIn their most recent update, Google has added support for native lazy loading in the Chrome browser's latest version - Chrome 76. All Chromium-based browsers, i.e., Chrome, Edge, and Safari, and Firefox. You can find more details about browser support for native lazy loading on caniuse.com.\n\nWith browser-side support coming into play, now, developers only need to add a \"loading\" attribute when embedding images, to implement lazy loading on their websites.\n\nIn fact, one does not need to even be a developer to get this done. Some basic knowledge of HTML is enough to implement the \"loading\" attribute, making this feature accessible to many more website admins.\n\nSo the code would now look like -\n\nThe following values are supported by the loading attribute:\n• lazy - Deferring the loading of assets till it reaches a certain distance from the viewport.\n• eager - loading the assets as soon as the page loads, irrespective of where they are placed on the page, whether above or below the page fold.\n• auto - This value triggers default lazy loading. Basically, it's the same as not including the loading attribute.\n\nHowever, for browsers that do not support native lazy loading, the aforementioned techniques for implementing of it need to be applied.\n\nAs covered later in this blog, to prevent the surrounding content from reflowing when a lazy-loaded image is downloaded, make sure to add and attributes to the element or specify their values directly in an inline style:\n\nAfter tags, background images are the most common way to load images on a webpage. For tags, the browser has a very simple approach - if the image URL is available, let’s load the image.\n\nWith CSS background images it is not that straightforward. To load CSS background images, the browser needs to build the DOM (Document Object Model) tree, as well as the CSSOM (CSS Object Model) tree, to decide if the CSS style applies to a DOM node in the current document.\n\nIf the CSS rule specifying the background image does not apply to an element in the document, then the browser does not load the background image. If the CSS rule is applicable to an element in the current document, then the browser loads the image.\n\nThis may seem complex at first, but this same behavior forms the basis of the technique for lazy loading background images. In simple terms, we trick the browser into not applying the background image CSS property to an element till that element comes into the viewport.\n\nHere is a working example that lazy loads a CSS background image.\n\nOne thing to note here is that the Javascript code for lazy loading is still the same. We are using the Intersection Observer API method with a fallback to the event listeners. The trick lies in the CSS.\n\nThe element with ID bg-image has a specified in the CSS. However, when the class is added to this element, in the CSS we override the property and set it to none.\n\nSince the rule, combining with class has a higher preference in CSS than just , the browser applies the property to the element initially. When we scroll down, the Intersection Observer (or event listeners) detects that the image is in the viewport and removes the class . This changes the applicable CSS and applies the actual property to the element triggering the load of the background image.\n\nLazy loading presents a great performance benefit. For an e-commerce company that loads hundreds of product images on a page, lazy loading can provide a significant improvement in initial page load time while decreasing the bandwidth consumption.\n\nHowever, a lot of companies do not opt for lazy loading because they believe it goes against delivering a great user experience quoting reasons like \"the initial placeholder is ugly\", \"the load times are slow\", etc.\n\nHow can we solve such concerns around user experience with lazy loading of images?\n\n1. Using the right image placeholders\n\nA placeholder is what appears in the container until the actual image is loaded. Normally, we see developers using a solid color placeholder for images, or a single image as a placeholder for all images.\n\nWe used the same in our example code as well. A solid light grey color is used for all our image backgrounds. However, we can do better to provide a more pleasing user experience.\n\nA look at some examples of better placeholders for our images:\n\nInstead of using a fixed color for the image placeholder, we find the dominant color from the original image and use that as a placeholder.\n\nThis technique has been used for quite some time in Google image search results and Pinterest.\n\nThis might look complex to achieve, but a very simple way of accomplishing this is to first scale down the image to a 1x1 pixel and then scale it up to the size of the placeholder - a very rough approximation, but a simple, no-fuss way to get a single dominant color.\n\nUsing ImageKit, the dominant color placeholder can be obtained using a chained transform in ImageKit as shown here:\n\nThe placeholder image is just 661 bytes in size, as compared to the original image which is 12700 bytes, making it 19x smaller. And it provides a more pleasant transition experience from placeholder to the actual image.\n\nHere's a video demonstrating how this effect works for the user:\n\nYou can view the working example and code for using dominant color placeholder here.\n\nWe can expand the above idea of using a dominant color placeholder further.\n\nInstead of using a single color, we use a very low-quality, blurred version of the original image as the placeholder. Not only does it look better, it also gives the user some idea about what to expect in the actual image, while giving the perception that the image load is in progress. This is great for improving the perceived loading experience.\n\nThis technique has been utilized by the likes of Facebook and Medium.com for images on their websites and apps.\n\nThe LQIP is 1300 bytes in size, almost 10x smaller than the original image, and a significant improvement in terms of visual experience over any other placeholder technique.\n\nHere's a video demonstrating how this effect works for the user:\n\nYou can view the working example and code for using LQIP technique here.\n\nIt is evident from the video samples of the two techniques above, that using dominant-color placeholders or using low-quality image placeholders provides a smoother transition from the placeholder to the actual image, while giving the user an idea of what's to come and improves loading perception.\n\nWhen we discussed different methods to trigger image load above, we checked for the point of time where the image enters the viewport, i.e. when the top edge of the image placeholder coincides with the bottom edge of the viewport.\n\nThe problem\n\nOften, users scroll swiftly through the page, and the image needs some time to load and appear on the screen. In this scenario, combined with the fact that the load image event might be triggered with a delay because of throttling, you would often face the scenario where the placeholders come into the viewport, the user waits for a few milliseconds while the image loads up. This delay makes for a poor user experience.\n\nWhile using Intersection Observers to load the image or using low-quality image placeholders provides better loading performance and user experience, there is another simple trick that you can use to ensure that the images are always loaded completely when they enter the viewport - introduce a margin to the trigger point for images.\n\nThe solution\n\nInstead of loading the image just when they exactly enter the viewport, load the images when they are, let’s say, 500px away from entering the viewport. This provides additional time, between the load trigger and the actual entry in the viewport, for the images to load.\n\nWith the Intersection Observer API, you can use the `root` parameter along with the `rootMargin` parameter (works as standard CSS margin rule), to increase the effective bounding box that is considered to find the “intersection”.\n\nWith the event listener method, instead of checking for the difference between the image edge and the viewport edge to be 0, we can use a positive number to add some threshold.\n\nThe example here uses a 500px threshold to load images.\n\nAs evident from the video below (monitor the network requests closely appearing at the bottom), while scrolling, when the third image is in view, the 5th image gets loaded. When the 4th image comes into the view, the 6th image gets loaded. This way we are giving sufficient time for the images to load completely and in most cases, the user won’t see the placeholder at all.\n\nIn case you haven't noticed yet, in all our examples, the third image (image3.jpg) is always loaded up front, even though it's outside the viewport. This was also done following the same principal - load slightly in advance instead of loading exactly at the threshold for better user experience.\n\nIf you are using the native image lazy loading method, browsers automatically calculate this distance from the viewport threshold to determine when the browser should trigger the image load. Browsers consider the image type, network speed, and data-saver setting in the browser to decide this threshold, keeping in mind developer expectations and user experience.\n\nThis is another trivial point which, if solved, can help maintain a good user experience.\n\nThe problem\n\nWhen there is no image, the browser doesn’t know the dimensions of the content that is to be displayed in the enclosing container. And if we do not specify it using CSS, the enclosing container would have no dimensions, i.e. 0 x 0 pixels. So, when the image gets loaded, the browser would resize the enclosing container to fit the image.\n\nThis sudden change in the layout causes other elements to move around and it is called content shifting. As demonstrated in this content shifting article & video from Smashing Magazine, it's a rather unpleasant experience for a user as the content moves suddenly when the image loads.\n\nThe solution\n\nThis can be avoided by specifying a height and/or width for your enclosing container so that the browser can paint the image container with a known height and width. Later, when the image loads, since the container size is already specified and the image fits into that perfectly, the rest of the content around the container stays put.\n\n4. Do not lazy load all the images\n\nThis is another mistake the developers often commit - lazy load all the images on the page. This might reduce the initial page load, but would also result in bad user experience as a lot of images, even the ones at the top of the webpage, won’t show up till the Javascript gets executed.\n\nHere are some general principles to follow to identify which images should be lazy loaded.\n\na) Any image that is present in the viewport, or at the beginning of the webpage, should not be lazy loaded. This applies to any header image, marketing banner, logos, etc., as the user should see them as soon as the page loads.\n\nAlso, as mobile and desktop devices have different screen sizes, they will have a different number of images that will be visible on the screen initially. So you need to take into account the device type to decide which resources to load up front and which to lazy load.\n\nb) Any image that is just slightly off the viewport should not be lazy loaded. This is based on the point discussed earlier - load slightly in advance. So, let’s say, any image that is 500px or a single scroll from the bottom of the viewport can be loaded up front as well.\n\nc) If the page isn’t too long, may be just a single scroll or two, or if there are less than 5 images outside the viewport, then lazy loading can be avoided altogether.\n\nIt would not provide any significant benefit to the end user in terms of performance. The additional JS that you load on the page to enable lazy loading will offset any benefit reaped from lazy loading such a small number of images.\n\nThe entire idea of lazy loading is dependent on the availability of Javascript execution capabilities in the user’s browser. Though native lazy loading promises to remove this dependency, with browser support still close to 70%, if you are to provide the same experience across all browsers, you would still need to utilize JS libraries.\n\nWhile most of your users would have Javascript execution enabled in their browser, as it is essential for almost all websites these days, you may want to plan for users that do not allow javascript execution or use a browser that doesn’t support javascript at all.\n\nYou could either show them a message telling them why the images won’t load and that they need to switch to a modern browser or enable Javascript. Or you can use the noscript tag to create a usable experience for these users as well. Using the <noscript> tag approach for such users has some gotchas.\n\nThis thread on Stack Overflow does a great job addressing these concerns, and is a recommended read for anyone looking to address this set of users.\n\nPopular Javascript libraries for lazy loading on your website\n\nSince browser environments and implementation details can vary across browsers and devices, it is best to use a tried and tested library for lazy loading.\n\nHere is a list of popular libraries and platform specific plugins that will allow you to implement lazy loading with minimal effort\n• Uses Intersection Observer and falls back to event-based lazy loading.\n• Supports all major HTML element types but not background-images.\n• Works on IE11+ as well.\n• Supports responsive images srcset and sizes attribute as well.\n• It is paid though.\n\nHow to test if lazy loading is working?\n\nOnce you have implemented lazy loading, you'll want to check if the behaviour of images on your website is as intended. The simplest way is to open developer tools in Chrome browser.\n\nHere, when you refresh the page for the first time, only the images that are to be loaded up front should get loaded. Then, as you start scrolling down the page, other image load requests would get triggered and loaded.\n\nYou can also notice the timings for image load in the waterfall column in this view. It would help you identify image loading issues, if any, or issues in triggering the image load.\n\nAnother way would be to run the Google Chrome Lighthouse audit report on your page after you have implemented the changes, and look for suggestions under the “Offscreen images” section.\n\nWe have covered almost everything related to lazy loading images in this guide. Lazy loading, if implemented correctly, will significantly improve the loading performance of your web pages, reduce page size and delivery costs by cutting down on unnecessary resources loaded up front, while keeping the necessary content intact on the page. With faster loading pages comes a great user experience, something your visitors would love.\n\nSo, what are you waiting for? Get started with lazy loading images now!\n\nAre you optimizing your website images? No? Get started with ImageKit's image CDN & optimization tool for free now!"
    },
    {
        "link": "https://geeksforgeeks.org/html-img-loading-attribute",
        "document": "In this article, we will discuss the HTML img loading attribute. This attribute handles how an image will be loaded on a webpage. It accepts three string values, namely, auto, eager and lazy.\n\nLazy Loading Attribute: This strategy is used to identify resources as non-critical and the resources will be loaded only when needed. In other words, Lazy loading defers to the loading of the webpage content as long as if they were not required. This technique helps to optimize the page & allowing them to load later. Usually, the image size is large on the webpage. For this, lazy loading can be useful to defer the offscreen images. Please refer to What is Lazy Loading? article.\n• auto: It is a default lazy-loading behavior of the browser, in which the browser will determine for the lazy load of contents.\n• eager: The image corresponds to it will load without any delay ie., It will load the resources immediately, regardless of where it’s located on the page.\n• lazy: It delays the loading of the image that corresponds to it until the browser specifies that it is expected to appear shortly. It can help in optimizing the loading time of a webpage, by postponing the loading of images until and unless they are expected to appear, instead of loading them at once.\n\nWe will use these attribute values to see the changes in each case through the examples.\n\nExample 1: This example illustrates the use of the lazy attribute.\n\nExample 2: This example illustrates the use of both the auto & eager loading attribute.\n\nNOTE: In browsers like chrome, the image loading is instant, so you might not be able to distinguish it. But the loading time is optimized."
    },
    {
        "link": "https://w3schools.com/tags/att_img_loading.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/html-img-loading-attribute",
        "document": "In this article, we will discuss the HTML img loading attribute. This attribute handles how an image will be loaded on a webpage. It accepts three string values, namely, auto, eager and lazy.\n\nLazy Loading Attribute: This strategy is used to identify resources as non-critical and the resources will be loaded only when needed. In other words, Lazy loading defers to the loading of the webpage content as long as if they were not required. This technique helps to optimize the page & allowing them to load later. Usually, the image size is large on the webpage. For this, lazy loading can be useful to defer the offscreen images. Please refer to What is Lazy Loading? article.\n• auto: It is a default lazy-loading behavior of the browser, in which the browser will determine for the lazy load of contents.\n• eager: The image corresponds to it will load without any delay ie., It will load the resources immediately, regardless of where it’s located on the page.\n• lazy: It delays the loading of the image that corresponds to it until the browser specifies that it is expected to appear shortly. It can help in optimizing the loading time of a webpage, by postponing the loading of images until and unless they are expected to appear, instead of loading them at once.\n\nWe will use these attribute values to see the changes in each case through the examples.\n\nExample 1: This example illustrates the use of the lazy attribute.\n\nExample 2: This example illustrates the use of both the auto & eager loading attribute.\n\nNOTE: In browsers like chrome, the image loading is instant, so you might not be able to distinguish it. But the loading time is optimized."
    },
    {
        "link": "https://web.dev/articles/browser-level-image-lazy-loading",
        "document": "You can use the attribute to lazy-load images without the need to write custom lazy-loading code or use a separate JavaScript library. Here's a demo of the feature:\n\nThis page walks through the details of implementing lazy-loading in the browser.\n\nAccording to the HTTP Archive, images are the most-requested asset type for most websites, and they usually take up more bandwidth than any other resource. At the 90th percentile, sites send over 5 MB of images on desktop and mobile.\n\nPreviously, there were two ways to defer the loading of off-screen images:\n\nEither option can let developers include lazy loading behavior, and many developers have built third-party libraries to provide abstractions that are even easier to use.\n\nWith lazy loading supported directly by the browser, however, there's no need for an external library. Browser-level lazy loading also ensures that loading of images still works even if the client disables JavaScript. Note however that loading is only deferred when JavaScript is enabled.\n\nChrome loads images at different priorities depending on where they're located relative to the device viewport. Images below the viewport are loaded with a lower priority, but they're still fetched as the page loads.\n\nYou can use the attribute to completely defer the loading of offscreen images:\n\nHere are the supported values for the attribute:\n• : Defer loading of the resource until it reaches a calculated distance from the viewport.\n• : Default loading behavior of the browser, which is the same as not including the attribute and means the image is loaded regardless of where it's located on the page. This is the default, but it can be useful to set explicitly if your tooling automatically adds when there's no explicit value, or if your linter complains if it isn't explicitly set.\n\nRelationship between the attribute and fetch priority\n\nThe value is an instruction to load the image as usual, without delaying the load further if the image is off-screen. It doesn't load the image faster than another image that doesn't have a attribute.\n\nIf you want to increase the fetch priority of an important image (for example, the LCP image), use Fetch Priority with .\n\nAn image with and is still delayed while it's off-screen, and then fetched with a high priority when it's almost within the viewport. This combination isn't really necessary because the browser would likely load that image with high priority anyway.\n\nAll images that are immediately viewable without scrolling load normally. Images far below the device viewport are only fetched when the user scrolls near them.\n\nChromium's implementation of lazy loading tries to ensure that offscreen images are loaded early enough that they finish loading by the time the user scrolls to them by fetching them well before they become visible in the viewport.\n\nThe distance threshold varies depending on the following factors:\n• The type of image resource being fetched\n\nYou can find the default values for the different effective connection types in the Chromium source. You can experiment with these different thresholds by throttling the network in DevTools.\n\nIn July 2020, Chrome made significant improvements to align the image lazy loading distance-from-viewport thresholds to better meet developer expectations.\n\nOn fast connections (4G), we reduced Chrome's distance-from-viewport thresholds from to and on slower connections (3G or lower), changed the threshold from to . This change achieves two things:\n• behaves closer to the experience offered by JavaScript lazy loading libraries.\n• The new distance-from-viewport thresholds still means images will probably have loaded by the time a user has scrolled to them.\n\nYou can find a comparison between the old versus new distance-from-viewport thresholds for one of our demos on a fast connection (4G) next:\n\nand the new thresholds versus LazySizes (a popular JavaScript lazy loading library):\n\nWhile the browser loads an image, it doesn't immediately know the image's dimensions, unless they're explicitly specified. To let the browser reserve enough space on a page for images, and avoid disruptive layout shifts, we recommend adding and attributes to all tags.\n\nAlternatively, specify their values directly in an inline style:\n\nThe best practice of setting dimensions applies to tags regardless of whether you're lazy loading them, but lazy loading can make it more important.\n\nLazy loading in Chromium is implemented in a way that makes images more likely to be loaded as soon as they're visible, but there's still a chance that they won't load at the right time. If that happens, not specifying and on your images increases their impact on Cumulative Layout Shift. If you can't specify your images' dimensions, lazy loading them can save network resources at the risk of these increased layout shifts.\n\nIn most scenarios, images still lazy load if you don't specify dimensions, but there are a few edge cases you should be aware of. Without and specified, image dimensions default to 0×0 pixels. If you have a gallery of images, the browser might decide that all of them fit inside the viewport at the start, because each image takes up no space and no image is pushed offscreen. In this case, the browser decides to load everything, making the page load more slowly.\n\nFor an example of how works with large numbers of images, refer to this demo.\n\nYou can also lazy-load images you've defined using the element:\n\nAlthough the browser decides which image to load from any of the elements, you only need to add to the fallback element.\n\nAlways eager-load images visible in the first viewport\n\nFor images that are visible when the user first loads the page, and especially for LCP images, use the browser's default eager loading so they can be available right away. For more information, see The performance effects of too much lazy-loading.\n\nUse only for images outside the initial viewport. The browser can't lazy-load an image until it knows where the image should be on the page, which causes them to load more slowly.\n\nBrowsers that don't support the attribute ignore it. They don't get the benefits of lazy loading, but there's no negative impact from including it.\n\nPreviously, Chromium automatically lazy-loaded any images that were well suited to being deferred if Lite mode was enabled on Chrome for Android and the attribute was either not provided or set to . However, Lite mode and have been deprecated and there are no plans to provide automatically lazy-load of images in Chrome.\n\nCan I change how close an image needs to be to the viewport before it loads?\n\nThese values are hardcoded and can't be changed through the API. However, they might change in the future as browsers experiment with different threshold distances and variables.\n\nCan CSS background images use the attribute?\n\nNo, you can only use it with tags.\n\nCan work with images in the viewport that aren't immediately visible?\n\nUsing can prevent images being loaded when they aren't visible but are within the calculated distance. These images might be behind a carousel or hidden by CSS for certain screen sizes. For example, Chrome, Safari, and Firefox don't load images using styling, either on the image element or on a parent element. However, other image hiding techniques, such as using styling, still cause the browser to load the image. Always test your implementation thoroughly to make sure it's acting as intended.\n\nChrome 121 changed the behavior for horizontal-scrolling images like carousels. These now use the same thresholds as vertical scrolling. This means for the carousel use case, images will be loaded before they visible in the viewport. This means the image loading is less likely to be noticeable to the user, but at the cost of more downloads. Use the Horizontal Lazy Loading demo to compare behaviour in Chrome versus Safari and Firefox.\n\nWhat if I'm already using a third-party library or a script to lazy-load images?\n\nWith full support of lazy loading built into modern browsers, you probably don't need a third-party library or script to lazy-load images.\n\nOne reason to continue to use a third-party library alongside is to provide a polyfill for browsers that don't support the attribute, or to have more control over when lazy loading is triggered.\n\nHow do I handle browsers that don't support lazy loading?\n\nBrowser-level image lazy loading is well supported across all the major browsers and is recommended for most use cases, to remove the need for extra dependencies on JavaScript.\n\nHowever, if you have a need to support more browsers or want to have more control over lazy-loading thresholds then you can use a third-party library to lazy-load images on your site.\n\nYou can use the property to detect whether a browser supports the feature:\n\nFor example, lazysizes is a popular JavaScript lazy loading library. You can detect support for the attribute to load lazysizes as a fallback library only when isn't supported. This works as follows:\n• Replace with to avoid an eager load in unsupported browsers. If the attribute is supported, swap for .\n• If isn't supported, load a fallback from lazysizes and initiate it, using the class to indicate which images to lazy-load:\n\nHere's a demo of this pattern. Try it in an older browser to see the fallback in action.\n\nIs lazy loading for iframes also supported in browsers?\n\nhas also been standardized. This lets you lazy-load iframes using the attribute. For more information, see It's time to lazy-load offscreen iframes!\n\nHow does browser-level lazy loading affect advertisements on a web page?\n\nAll ads displayed to the user as images or iframes lazy-load just like any other image or iframe.\n\nAll images and iframes load immediately when the page is printed. See issue #875403 for details.\n\nLighthouse 6.0 and higher factor in approaches for offscreen image lazy loading that can use different thresholds, letting them pass the Defer offscreen images audit.\n\nBrowser support for lazy loading images can make it significantly easier for you to improve your pages' performance.\n\nAre you noticing any unusual behavior with this feature enabled in Chrome? File a bug!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/loading",
        "document": "The property is a string whose value provides a hint to the user agent on how to handle the loading of the image which is currently outside the window's visual viewport. This helps to optimize the loading of the document's contents by postponing loading the image until it's expected to be needed, rather than immediately during the initial page load.\n\nA string providing a hint to the user agent as to how to best schedule the loading of the image to optimize page performance. The possible values are: The default behavior, tells the browser to load the image as soon as the element is processed. Tells the user agent to hold off on loading the image until the browser estimates that it will be needed imminently. For instance, if the user is scrolling through the document, a value of will cause the image to only be loaded shortly before it will appear in the window's visual viewport.\n\nLoading is only deferred when JavaScript is enabled. This is an anti-tracking measure, because if a user agent supported lazy loading when scripting is disabled, it would still be possible for a site to track a user's approximate scroll position throughout a session, by strategically placing images in a page's markup such that a server can track how many images are requested and when.\n\nThe event is fired when the document has been fully processed. When images are loaded eagerly (which is the default), every image in the document must be fetched before the event can fire. By specifying the value for , you prevent the image from delaying the attribute by the amount of time it takes to request, fetch, and process the image. Images whose attribute is set to but are located within the visual viewport immediately upon initial page load are loaded as soon as the layout is known, but their loads do not delay the firing of the event. In other words, these images aren't loaded immediately when processing the element, but are still loaded as part of the initial page load. They just don't affect the timing of the event. That means that when fires, it's possible that any lazy-loaded images located in the visual viewport may not yet be visible.\n\nWhen an image whose loading has been delayed by the attribute being set to is finally loaded, the browser will determine the final size of the element based on the style and intrinsic size of the image, then reflow the document as needed to update the positions of elements based on any size change made to the element to fit the image. To prevent this reflow from occurring, you should explicitly specify the size of the image's presentation using the image element's and attributes. By establishing the intrinsic aspect ratio in this manner, you prevent elements from shifting around while the document loads, which can be disconcerting or off-putting at best and can cause users to click the wrong thing at worst, depending on the exact timing of the deferred loads and reflows."
    },
    {
        "link": "https://medium.com/codex/the-img-tag-performance-optimization-using-standard-html-attributes-8403c14d0de9",
        "document": "I’ve come to know lately that the IMG tag has 3 attributes that if set correctly can greatly improve the loading time of a web page. Check them out!\n\nWith this simple attribute on the IMG tag, clients will load the image when specified, eagerly or lazily.\n\nIt’s a good strategy to avoid clogging the clients with several requests, loading the critical elements of the webpage before any others.\n\nSometimes images are just decorations of the webpage, not critical aspects, so the information may be loaded after the main contents. In this case lazy is the best option. In other cases, images could be the most important part of the web app so we need to load them as soon as possible. In this case eager is the way to go."
    }
]