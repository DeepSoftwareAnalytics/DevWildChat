[
    {
        "link": "https://mql5.com/en/articles/15457",
        "document": "This article will follow the course of integrating Telegram with MetaTrader 5. We intend to achieve this by crafting a custom Expert Advisor (EA) in the MetaQuotes Language 5 (MQL5) programming language. Our main task is to program a trading assistant that operates in real-time and keeps us in the loop via a chat on Telegram. The Telegram bot that we will build will act like an update server, sending us juicy morsels of information that help us make important trading decisions.\n\nTo reach this goal, we will go through the process of establishing a Telegram bot and adjusting our EA to communicate with Telegram's Application Programming Interface (API). We will first set up BotFather, a Telegram bot that helps you create new bots and manage your existing ones. Using \"BotFather\", we will create a new bot and will have the chance to name it. We will also get a vital piece of information—the token—that we will use to identify and gain access to our bot from the Application Programming Interface (API). After that, we will get the chat ID and will use these two items to reach the API and make it work.\n\nThus, in this article, we will offer a comprehensive coding tutorial. We'll show you how to write and implement an Expert Advisor that will establish a two-way link between MetaTrader 5 and Telegram. We will explain not only the \"how\" but also the \"why,\" so you will understand the integration's technical and practical aspects. We will also discuss potential errors that may occur during setup and operation, mainly to help you avoid them, but also to ensure you know how to handle them if they happen despite our best efforts at foreseeing and preventing them.\n\nTo easily absorb the content in small chunks, we will break down the process into the following subtopics:\n\nBy the end of the article, you should have a solid understanding of how to achieve integrated, automated communication between MetaTrader 5 and Telegram, with a working EA as the end product.\n• None Overview of the series and objectives:\n\nThis series of articles is intended to close the loop between your trading on the MetaTrader 5 platform and your instant communications on the Telegram application. By the end of the series, you will have a working Expert Advisor (EA) in MQL5 that can send and receive messages and even relay images through your trading platform and to your Telegram account. Each part of the series builds on the last, sharpening the EA's functionality and the overall trading system you could use.\n\nThere are several advantages to integrating Telegram with MQL5. To start, it offers the ability to send instant notifications. If you’ve set up an expert advisor to trade with MQL5, you can program it to send you alerts via Telegram. This works nicely because you can configure your trading algorithm in such a way that the only alerts you get are for either an amazing new trading opportunity or an important update regarding an open position. The other major route through which you can communicate with your trading algorithm via Telegram is through the use of a Telegram bot. Bots offer a few distinct advantages when it comes to programming a service to send you alerts and/or allow for the limited but safe and secure communication of trading-sensitive data. Additionally, you can share all sorts of trade-relevant media—like charts or screenshots—working in tandem with the bot to allow your trade algorithms to serve you better. Technically, the bot relays communication between the user and the server. Here is a detailed visualization of the chronological processes:\n\nToday's trading world demands fast adaptability from its players; it is a profit-and-loss issue. Necessarily, we traders have sought ways to automate our strategies—to be in touch with the markets while not being tied to our desks. One of the more recent approaches to achieving this involves the use of MQL5, a powerful programming language, with Telegram, an instant messaging app that can be made to perform almost as a customized trading dashboard. This proxy trading telegram setup covers the necessary bases for inclusion in any telegram that serves to notify the user of relevant happenings for any accounts they might be managing. Whether or not you have a team, Telegram's peer-to-peer update capabilities make the app a legitimate candidate for inclusion in a trader's toolkit.\n• None Setting the foundation for the series:\n\nUnderstanding the essential concepts and basic tools of the integration is paramount. We will start with the basics: creating a Telegram bot and configuring MQL5 to send messages through it. This step is fundamental. It allows us to establish a groundwork on which we can build more advanced, more sophisticated, and more useful functionalities in future installments. By the end of Part 1, we will possess a basic but functional system capable of sending text messages from our EA to Telegram. This foundation will not only give you practical skills but also prepare you for the more complex tasks ahead, such as sending images and handling bi-directional communication between MQL5 and Telegram. At the end, we will have the integration as follows:\n\nThis will serve as the basic foundation for the other parts.\n\nThe first step in connecting Telegram to MetaTrader 5 is to create a Telegram bot. This bot will serve as the intermediary for messages sent to and received from Telegram and MetaTrader 5. Using the BotFather, we will create a new bot, configure it with the necessary permissions, and then obtain the API token that allows for communication with our bot.\n\nTo create a bot, you first open the Telegram app and search for \"BotFather.\" This is a special bot that you use to create and manage other bots. As there could be many of them with almost similar names, make sure to key in the wordings as illustrated.\n\nYou start a chat with BotFather and use the command \"/newbot\" to create a new bot. BotFather then prompts you for a name and a username for your bot. After that, you get a unique API token. This is a big deal because it allows your application to authenticate with Telegram's servers and interact with them in a way that the servers know is legitimate. To illustrate the process undertaken, we considered a Graphics Interchange Format (GIF) image visualization as below to ensure that you get the correct steps.\n\nSetting up the bot: After acquiring the API token, we must set up the bot to meet our needs. We can program it to recognize and respond to commands using BotFather's \"/setcommands\" command. To open the bot, you can either search it using its name or just click on the first link provided by \"BotFather\" as shown below:\n\nWe can also give the bot a more friendly user interface. Adding a profile, a description, and a picture will make it a little more inviting, but this is an optional step. The next step in configuring the bot is to ensure that it can handle the actual messaging according to our requirements.\n\nGetting the Chat ID: To send direct messages from our bot to a specific chat or group, we need to obtain the chat ID. We can achieve this by messaging our bot and then using the Telegram API \"getUpdates\" method to pull the chat ID. We'll need this ID if we want our bot to send messages anywhere other than to its owner. If we want the bot to send messages to a group or channel, we can add the bot to the group first and then use the same methods to obtain the chat ID. To get the chat ID, we use the following code snippet. Just copy, and replace the bot token with your bot's token and run it on your browser.\n\nThese are the results we get:\n\nYou can see that our result does not contain any message update, even if we return true, indicating that everything provided is correct. If you input something in the link that is not correct, you will receive a bad web request and get a false return like below:\n\nIn our case, we return true, and yet our structure is empty. That is because we need to send a message to the bot so that there is an update. In our case, we send a starting \"/start\" command.\n\nOnce we send the message and refresh the link again, we now get the update. Here, it is good to note that messages are stored on the telegram server for 24 hours only, and are afterwards discarded. So, if you are getting the chat ID using this method, make sure that the messages were sent within 24 hours before the process. Here is what we have:\n\nWe get the updates but the presentation structure is pretty compact and unappealing. To achieve a more readable format, just check the \"Pretty-Print\" box and you should have the below structure.\n\nOur chat ID is the one under the \"chat id\" column. Up to this point, armed with the bot token and chat ID, we can create a program that sends messages from MQL5 to the telegram bot that we have created.\n\nTo ensure that our MetaTrader 5 platform can communicate with Telegram, we need to add the Telegram API URL to the list of allowed URLs in MetaTrader 5. We start by opening MetaTrader 5 and navigating to the \"Tools\" menu. From there, we select \"Options\", which can alternatively be opened by pressing \"CTRL + O\".\n\nOnce the \"Options\" window pops up, navigate to the \"Expert Advisors\" tab. Here, we check the box labeled \"Allow WebRequest for listed URL\" and add the URL \"https://api.telegram.org\" to the list. This step is crucial because it grants our Expert Advisor the necessary permissions to send HTTP requests to the Telegram API, enabling it to send messages and updates to our Telegram bot. By configuring these settings, we ensure smooth and secure communication between our MetaTrader 5 platform and Telegram, allowing our trading activities to be monitored and managed effectively on a real-time basis.\n\nAfter doing all that, you are all set and we can now begin the implementation in MQL5, where we define all the logic that will be used to create the program that relays messages from MQL5 to Telegram. Let us then get started.\n\nThe integration will be based on an Expert Advisor (EA). To create an Expert Advisor, on your MetaTrader 5 terminal, click the Tools tab and check MetaQuotes Language Editor, or press F4 on your keyboard. Alternatively, click the IDE (Integrated Development Environment) icon on the tools bar. This will open the MetaQuotes Language Editor environment, which allows the writing of trading robots, technical indicators, scripts, and libraries of functions.\n\nOnce the MetaEditor is opened, on the tools bar, navigate to the File tab and check New File, or simply press CTRL + N, to create a new document. Alternatively, you can click on the New icon on the tools tab. This will result in a MQL Wizard pop-up.\n\nOn the Wizard that pops, check Expert Advisor (template) and click Next.\n\nOn the general properties of the Expert Advisor, under the name section, provide your expert's file name. Note that to specify or create a folder if it doesn't exist, you use the backslash before the name of the EA. For example, here we have \"Experts\\\" by default. That means that our EA will be created in the Experts folder and we can find it there. The other sections are pretty straightforward, but you can follow the link at the bottom of the Wizard to know how to precisely undertake the process.\n\nAfter providing your desired Expert Advisor file name, click on Next, click Next, and then click Finish. After doing all that, we are ready to code and create our program.\n\nFirst, we start by defining some metadata about the Expert Advisor (EA). This includes the name of the EA, the copyright information, and a link to the MetaQuotes website. We also specify the version of the EA, which is set to \"1.00\".\n\nWhen loading the program, information that depicts the one shown below is realized.\n\nNext, we define several constants that will be used throughout our code.\n\nHere, the \"TG_API_URL\" constant holds the base URL for Telegram's API, which is essential for sending Hyper Text Transfer Protocol (HTTP) requests to Telegram's servers. The \"botTkn\" constant contains the unique token for our Telegram bot, provided by BotFather, which is necessary for authentication. The \"chatID\" constant is the unique identifier for the Telegram chat where we want to send messages. This is where you input your chat ID that we obtained using the Telegram API’s getUpdates method. Notice that we used constant string variables. The const keyword makes sure that our variables remain intact and unchanged once defined. Thus, we will not have to redefine them again and they will maintain their initialization values throughout the code. This way, we save time and space as we do not have to re-input them every time we need the values, we just call the necessary variables and again, the chances of wrongly inputting their values are significantly reduced.\n\nOur code will be majorly based on the expert initialization section since we want to make quick illustrations without having to wait for ticks on the chart so we have signals being generated. Thus, the OnInit event handler will house most of the code structure.\n\nThe OnInit function is an event handler that is called on the expert initialization instance to do necessary initializations if necessary.\n\nTo make communication with the telegram server, we use an MQL5 in-built function called WebRequest. The function is typically an overloading integer data type function, with two forms.\n\nFor simplicity, we will use the second version. Let us break the function down so that we can understand what every parameter means.\n\nLet us briefly explain the parameters of WebRequest function.\n• method: The HTTP method to use for the request. Common methods include \"GET\" and \"POST\". \"GET\" is typically used to retrieve data from a server. \"POST\" is used to send data to a server.\n• url: The URL of the web server to which the request is sent. This includes the protocol (http:// or https://), the domain, and the path/resource being accessed.\n• headers: Optional HTTP headers to include in the request. Headers can provide additional information to the server (e.g., content type, authentication tokens).\n• timeout: The maximum time (in milliseconds) to wait for a response from the server. If the server does not respond within this time, the request is aborted, and an error code is returned. For example, if we set a timeout of 10000 milliseconds, we have 10000/1000 = 10 seconds.\n• data: The data to send with the request. For \"POST\" requests, this would typically be the body of the request (e.g., form data, JSON payload).\n• result: The buffer to store the response data from the server. This array will be filled with the server's response, which we can then process in our code.\n• result_headers: The buffer to store the response headers from the server. This string will be filled with the headers sent by the server in its response.\n\nNow having the idea of what the parameters are used for and why we need them, let us continue to define some of the most necessary variables that we will use.\n\nFirst, we declare the \"data\" and \"res\" arrays of type char. These arrays will be used in the WebRequest function to hold the data sent to and received from the web server, respectively. The \"data\" array is intended for any payload that we might want to send with our HTTP request, although for now, we will keep it empty. The \"res\" array will be populated with the response from the server, allowing us to process and utilize the server's reply in our program.\n\nNext, we define a string variable named \"resHeaders\" to store the headers of the HTTP response we receive from the server. HTTP response headers provide important metadata about the response, such as content type, server information, and status codes. By capturing these headers, we can gain more context about the response and handle it appropriately with our Expert Advisor (EA).\n\nWe then create a string variable named \"msg\" which contains the message we want to send to Telegram. In this case, the message is set to \"EA INITIALIZED ON CHART\" followed by the symbol of the current chart, represented by the built-in _Symbol variable. The _Symbol variable holds the symbol name of the financial instrument for which the EA is running, such as \"AUDUSD\" or \"GBPUSD\". By including this information in our message, we provide clear and specific context about the action or event that has occurred, which can be particularly useful for monitoring and logging purposes. This is just an arbitrary value that we want to show when the program is initialized and thus you can have your own.\n\nWe then construct the Uniform Resource Locator (URL) required to make a request to the Telegram API. We start with the base URL stored in the \"TG_API_URL\" constant, which is \"https://api.telegram.org\". We then append the path to the \"sendMessage\" API method, including our bot's token (botTkn). This token uniquely identifies and authenticates our bot with Telegram's servers, ensuring that the request is valid and authorized. The URL path looks like this: \"/bot<botTkn>/sendmessage\", where <botTkn> is replaced by the actual bot token.\n\nNext, we append the query parameters to the URL. The first parameter is \"chat_id\", which specifies the unique identifier of the Telegram chat where we want to send our message. This is stored in the \"chatID\" constant. The second parameter is text, which contains the actual message we want to send, stored in the \"msg\" variable. These parameters are concatenated to the base URL to form the complete request URL. The final URL looks like this: \"https://api.telegram.org/bot<botTkn>/sendmessage?chat_id=<chatID>&text=<msg>\", where <botTkn>, <chatID>, and <msg> are replaced by their respective values.\n\nFinally, we just call the function to make the communication by passing the necessary arguments.\n\nHere, we employ the WebRequest function to send an HTTP POST request to the designated URL. Communicating with an external web service, like the Telegram API, requires us to use this function. We must specify the HTTP method; in this case, it is \"POST\". We use this method when sending data to a server that performs some action. The action we want this server to perform is sending a message to a Telegram chat. We provide the \"url\" variable, which we constructed earlier in the code. The URL we use contains the base address of the Telegram API, our unique bot token, the sendMessage method of the API, the ID of the chat we want to send the message to, and the text of the message itself.\n\nWe then specify that the headers parameter is an empty string, which indicates that this request doesn't need any extra HTTP headers. The timeout is specified as 10 seconds, which is typically 10*1000 = 10000 milliseconds, which tends to be pretty generous in a world where servers should usually respond within a few seconds. This timeout guards against the request hanging indefinitely and is designed to keep the EA responsive. The next thing we do is pass the data array and the response array to the function. The data array holds any extra information we want to send with the request, and we use the response array to hold the result of the request. Finally, we pass the response header string, which the function also uses in \"storing\" the response header sent by the server.\n\nThe function returns an integer status code, stored in the \"send_res\" variable, which indicates whether the request was successful or if an error occurred. Using the results, we can check whether the message was sent successfully and if not, inform of the error encountered.\n\nAfter making the HTTP request, we can handle the response by checking the status code stored in the \"send_res\" variable. To achieve this, we can use conditional statements to determine the outcome of our request and take appropriate actions based on the status code returned.\n\nHere, if our variable contains the status code 200, then we know that our request was successful. We can take this as a sign that our message made it to the specified Telegram chat. So, in this case, we print to the terminal something along the lines of \"TELEGRAM MESSAGE SENT SUCCESSFULLY.\"\n\nIf the result doesn't equal 200, we next check to see if it equals -1. This status tells us that something went wrong with the HTTP request—error! But we can't just leave our end-user stuck at this error screen. To make things more meaningful for them, we can get a little more detailed and crafty with our error messages. That's exactly what we're going to do next.\n\nFirst, we check the specific error (message) we got when the function call failed. We use the GetLastError function to retrieve the error code that tells us what went wrong. Then, we interpret the likely scenario (what the error code means) and print a message to the user that will guide them in fixing the problem that caused the error. In this case, if it equals 4014, we know that the URL is not either listed or enabled on the terminal. Thus we inform the user to add and enable the correct URL on their trading terminal. We are going to test this and see the significance of the shout-out.\n\nWhen the problem isn't associated with the URL restriction (GetLastError doesn't yield 4014), we don't just shrug our shoulders resignedly. We print a message—to the user, mind you—that states clearly the nature of the malfunction: \"UNABLE TO SEND THE TELEGRAM MESSAGE.\" It's bad enough if we can't communicate with our bot, but to have a bot, and the two of us on this side of the screen, rendered completely mute, is worse than anything. We even catch the random \"anomalous\" response condition.\n\nIf \"send_res\" is not equivalent to 200 (that is, it's not good), and it's not -1 (which indicates an obvious, URL restriction-related problem), then we've got a head-scratcher on our hands. If everything goes well, we return the succeeded integer value.\n\nLet us test this and see if everything works out fine.\n\nOn the Telegram bot chat, this is what we get:\n\nOn the trading terminal, this is what we get:\n\nYou can see that we were able to send a message from the trading terminal to the telegram server which relayed it to the telegram chat, which means it is a success.\n\nThe full source code responsible for sending the message from the trading terminal to the Telegram chat via a bot is as below:\n\nSince this was a success, on the next subtopic, let us alter the code to a few different message formats so we can see our extent of sending messages, make errors that one may make, and see how to mitigate them. Thus, it is also equally significant.\n\nTo ensure that our Expert Advisor (EA) correctly sends messages to Telegram, we need to test the integration thoroughly. One crucial aspect of testing is to verify the behavior of the EA when certain settings are incorrect, such as when the \"Allow WebRequest for listed URL\" checkbox is disabled in the trading terminal. To ensure we get this correct, let us disable the check box.\n\nIf we run the program, we get an error instructing the user that communication can only be done if the link provided is included and allowed on the trading terminal.\n\nMoreso, you can see that we not only inform of the error but also present the user with a viable solution to mitigate the errors encountered.\n\nNow that we can identify and solve the errors, let us proceed to make the message formats more creative, clear, and fancy. First, let us include emojis in our initial message.\n\nHere, we just append two rocket emojis to the initial message. Upon compilation, this is what we get:\n\nYou can see that the simple message with the emoji was successfully sent. To get the emoji characters, just press the Windows + period (.) keys simultaneously. We can now continue to be more creative and modify our message notification to have trading signals like \"BUY\" or \"SELL\", account balance information, the opening of trade instances, modified trade levels like stop loss and take profit, daily performance summary, and account status update information. These are just arbitrary messages that can be modified to fit one's trading style. This is achieved via the following code.\n\nWhen we run this code snippet with the message formats individually, we get the following summation of results:\n\nFrom the above code snippet and image, you can see that the integration was a success. Thus, we achieved our objective of sending messages from trading terminals to telegram bot chat. In case you want to send the messages to a telegram channel or group, you just need to add the bot to the group or channel and make it an administrator. For example, we created a group and named it \"Forex Algo Trader Group\", taking after our name and logo, but you can assign yours a more creative and different name. Afterward, we made the bot an administrator.\n\nHowever, even if you promote the bot to an administrator, you still need to get the chat ID for the group specifically. If the bot chat ID remains, the messages will always be forwarded to it and not to the intended group. Thus, the process to get the group's ID is just similar to the initial one.\n\nWe just need to send a message to the group and run the code on the browser. The message we sent is as below:\n\nOn the browser, we get the following information in a structured format:\n\nHere, our chat ID has a negative sign in front of the number. This is the ID we extract and switch it with the initial one. So now our chat ID will be as below:\n\nIf we run this, we get the following result.\n\nUp to this point, you can see that we were able to create a program in MQL5 that correctly sends messages from the trading terminal to the telegram's bot chat field with all the necessary information. This is a success for a simple message but for complex messages that contain foreign characters like New line feed characters \"\n\n\" or letters from Unicode character sets like emoji codes \"U+1F600\" will not be sent. We will consider that in the following parts. For now, let us keep everything simple and straight to the point. Cheers!\n\nIn this article, we created an Expert Advisor that works with MQL5 and Telegram. This allows for communication between the terminal and a Telegram bot, which means you can send messages from the terminal to the bot and from the bot to the terminal. This is very cool for two reasons: one, because the bot is essentially a proxy between you and the terminal for sending and receiving messages; two, because for some reason, this trading setup seems much cooler than sending a message via email.\n\nWe also probed into the testing process, pinpointing the possible mistakes that can happen when the WebRequest parameters are not set correctly. We figured out the reasons for these errors and then fixed them so that the program now runs with a higher reliability. That is, it operates smoothly and error-free, sending messages with the correct information to the correct place at the proper time. This understanding of the \"why\" and \"how\" of the error allows us to build with confidence in the future, knowing that our \"foundational cell\" can be trusted.\n\nIn the subsequent parts of this series, we will elevate our integration to a higher level by constructing a custom indicator that produces trading signals. These signals are to be used to set off messages sent to our group chat in Telegram, giving us all real-time updates on the kinds of potential trading opportunities we usually look for and pounce on. This isn't just about making our trading strategy work better. It's also about showing off how we can combine MQL5 with Telegram to create a dynamic trading workflow that sends alerts without us having to do anything except watch our phones. Stay tuned as we continue to build and refine this integrated system."
    },
    {
        "link": "https://mql5.com/en/forum/338730",
        "document": "I know how to read from telegram api, its easy wih http request. The question which i have now is the following, what if i want to have my MT4 to get updated infos from telegram, will i need to call for example every second the telegram api to have the update, or can telegram contact my metatrader script to tell me that he have updates?\n\ni know that its possible to let the call for example a php file which you have to send you updates, but i guess he will not be able to call somethink like metatrader script or?\n\nAnd the telegram api can not call me and if i must call the telegram api every second to be updated, will this not become a problem with the telegram api useage, because if i try to call the api from telegram every second, then they maybe block my ip or?"
    },
    {
        "link": "https://mql5.com/en/articles/2355",
        "document": "During the F8 conference held in San Francisco on 12th of April in 2016, Facebook announced the integration of API for bots into the Messenger. The same day a major update for the Telegram Bot Platform was released. Version 2.0 has pleasantly surprised with its functionality. It seems that bots that used to be popular in the ICQ era are now experiencing a comeback. At the new stage of development bots were given a thoughtful functionality, open interface for programing, and multimedia support. Basically, they have all the conditions to become irreplaceable when you want to find, see or purchase something.\n\nThis article is a step-by-step manual for creating bots for Telegram in MQL5. So what is a \"bot\"? A bot (shortened from \"robot\") is a special account in Telegram for exchanging messages. Bots operate on your (client) side, and interact with the Telegram server using a special set of commands that are part of Bot API. Before we proceed with creating a bot, please download Telegram and login to it. The registration is linked to the telephone number, but you can also search by @username. It is time now to get acquainted with a folder of all bots.\n\nA special bot @BotFather is in charge of registering and setting up bots. We will find it through the search engine. After adding it to the list of contacts, we will start communicating with it using the /start command. As a response it will send you a list of all available commands, as shown in Fig. 1.\n\nWith the /newbot command we begin the registration of a new bot. We need to come up with two names. The first one is a name of a bot that can be set in your native language. The second one is a username of a bot in Latin that ends with a “bot” prefix. As a result, we obtain a token – the access key for operating with a bot through API. The example of registration is shown in Fig. 2.\n• /setcommands – setting the list of supported commands. This list will appear to users as a tooltip when entering the symbol \"/\" in the chat window.\n• /setuserpic – setting the profile picture. Without one, a bot just isn't presentable enough.\n• /setdescription – a text displayed as a greeting when a bot is added to the Messenger. Normally, there are few sentences to describe the purpose of a bot.\n\nIf you wish, few parameters can be amended. I suggest keeping the settings for the inline mode. Otherwise, our bots won't be able to work with it. I would recommend setting only the cosmetic qualities:\n\nSo, a new bot is registered. Let's discuss now the modes it can be used in.\n\nTelegram has three schemes of interaction between bots and users. First - private chats. Every user communicates with a bot independently from each other, as shown if Fig 3, by making requests and receiving replies.\n\nUsers send messages to a bot. They are stored on the server for no longer than 24 hours, and are removed afterwards. A bot has time to request these messages and to respond to them. This is the main mode that our bots will be operating in.\n\nThe second mode involves group chats. In this case, the message sent by any member of a group is seen by the entire group (Fig. 4).\n\nWith regard to bots, you can let them join groups by using the /setjoingroups command. If a bot is added to a group, then by using the /setprivacy command you can set the option to either receive all messages, or only those that start with a sign of the symbol team “/”. To be honest, I only managed to think of one bot appointment in this mode – statistics of messages for a subsequent analysis.\n\nThe third mode focuses on operation on a channel. Telegram channels are accounts for transmitting messages for a wide audience that support an unlimited number of subscribers. The important feature of channels is that users can't leave comments and likes on the news feed (one-way connection). Only channel administrators can create messages there (Fig. 5).\n\nBots can be also added to the list of administrators. This makes a channel an ideal tool for providing trading signals. A bit later we will write a simple bot that publishes signals from the standard MACD indicator. A new public channel can be created through the messenger's “New Channel” menu. Don't forget to add your bot to the list of channel's admins. It is achieved through the property window of the channel. All preparations have been concluded to let us proceed with programming.\n\n\n\nWhile writing this article, I had a goal to create a class that would undertake the routine of handling messages and allow to focus on the bot's logic. As a result, the CCustomBot class that implements a minimum functionality for work was written.\n\nCommunication with a server occurs through POST requests using the WebRequst function. Every command has its own URL:\n\n\n\nResponses from the server arrive in the JSON format, therefore a good JSON parser was required. I have applied a native parser JSON Serialization and Deserialization. I would like to thank Alexey (sergeev) for the work he accomplished. Also, the panel for displaying some parameters is also applied. The CComment class taken from the Codebase was suitable for this task. Names of class public methods were borrowed from the documentation for Bot API to achieve universality. The methods that we have managed to implement in the class are listed below:\n\nIn order to understand how to use these functions, we are going to get deeper into programming.\n\nSince during every request a token is sent, then, above all, the GetMe function that checks for its credibility is implemented. It is advisable to perform this check at the start of EA, and notify a user in case of failure.\n\n\n\nIf successful, GetMe returns 0, and you can find out the bot username through the Name() method. This name is not used for operation. However, it will be displayed on the panel for information purposes. The address like telegram.me/<botname> allows to use a Web-version of Messenger and will serve as a link to advertise your bot. The EA that checks the token in OnInit would look as follows:\n\nThe main function GetUpdates reads an array of messages stored on the server. It needs to be called by the timer. A period of updating the timer shouldn't be set below 1 second in order to avoid server overload.\n\nLet's have a look inside this function. When it is called, reading and parsing of all unread messages received from users is performed. The example of one of those messages is provided below:\n\nA user with avaticks username has sent the /start command to the bot. The point is to save such messages and to respond to them in the future. The chat number chat[id] is a unique identifier. The same user communicating with a bot through various devices has different chat identifiers. This parameter is suitable as a unique key for building a chat list. While operating, bots will accumulate the chat array and update the last received message in each of them. If we have responded to it, then this message has been handled and we can set the done flag to it. The chat type is also known. It can be either private, or group.\n\nIn order to write your own bot, it is simply required to inherit from CCustomBot and re-determine the ProcessMessage virtual function in the class, that is provided for implementing the operation logic. A full-fledged bot, as per Telegram documentation, needs to know how to respond to two commands: \"/start\" and \"/help\". Let's write the first bot that will respond to them.\n\n\n\nThe result achieved is shown in figure 6.\n\nFor interactive communication with users for bots, developers have come up with an idea of a “keyboard”. When sending messages for every chat, a \"keyboard\" with a pre-selected set of keys can be displayed. When pressing a key, a user sends a message with a text indicated on it. This way, the interaction between a bot and a user is significantly simplified.\n\nThe class has three functions for working with the keyboard. The first function creates the keyboard's object.\n\nThe second function hides the keyboard.\n\nThe third function allows to send a small panel whose type indicates that a bot expects an answer from you in the form of a text (the keyboard is not displayed).\n\nNow we proceed to analyzing how these functions are used.\n\nThe keyboard can't be displayed or hidden by itself. The action is sent with a message. The SendMessage function for sending messages to the chat looks as follows:\n\nThe keyboard is optional in this case. We can send simple text messages from our MQL-programs. In my opinion, this function is more interesting that the native SendNotification. Firstly, we can send messages more often (approximately once per second). Secondly, the HTML format is supported. In addition to that, the ability to send Emoji is a serious bonus.\n\nТelegram supports a number of Emoji characters from the table that can be viewed here. As you can see, the majority of Emoji codes are in the range of 1F300 – 1F700. Their bitness goes beyond two-byte code of strings acceptable in MQL5. If you remove higher digits so only a two-bite number remains, then the obtained range (F300 – F700) falls in the area (E000— F8FF) that in the Unicode table is reserved for a certain use. This way, nothing stops us from using 2 lower bites for sending Emoji. The string message with a classic Emoji with a code U+1F642 looks as follows:\n\nThis is also fair for keys that are a text, in fact. Nothing stops us from using Emoji on keys. Let's write a sample for displaying three keys with the event handler.\n\nAs a result we will get a message with the keyboard as displayed in Fig. 7.\n\nNow, we will try to implement the analog of RadioButton and CheckBox controls. For example, we have to select one out of three options, and also enable or disable a certain option. Changes will affect our class only, therefore the remaining EA code from the previous example will remain the same.\n\nAs a result we get the following window (figure 8).\n\nWe can see here that Emoji used here provide settings with a better visibility. Apart from these controls, we will be able to easily implement hierarchical menu with navigation in every sub-menu. Everything will depend on functionality that you will come up with and decide to implement.\n\n\n\nIn case we decide to publish messages on the channel, there is a second option - SendMessage.\n\n\n\nThe result of this function is displayed in figure 9 below.\n\nBots can exchange photos, audio and video files and also voice messages, stickers and location coordinates. At the point of writing this article, Bot API 2.0 with a function of exchanging contact data and invitations to meet up was released. From the whole list provided, only the option to exchange photos holds relevance for us.\n\nThe class has implemented the opportunity to send photos with two ways of application.\n\n\n\nExample of the code that sends photo:\n\nI believe you will have cases when it will be required to send a photo to several users or send the same photo several times. In this case it is more rational to upload a photo once, and to apply the photo_id identifier along with the second option of the SendPhoto function when re-sending a photo:\n\nImagine that you handle a user's response and are almost ready to provide him with a result. Since it may take few seconds to create a response, it would be polite to notify a user that you are in the process already. And this is what events are used for. For example, while the chart screenshot is formed to be sent to a user, you can send the \"send photo\" event in the meantime. This is achieved via SendChatAction.\n\nAll previously described functions where implemented in three demonstration bots that we are going to speak about later.\n\nThe first bot Telegram_Bot_EA allows to obtain information about the account balance, quotes and chart screenshots. How it operates is shown in this video.\n\nThe second bot Telegram_Search_EA sends search results to MQL5.com. You may be curious to watch the following video to see how it actually works.\n\n\n\nThe third bot Telegram_Signal_EA publishes signals from the MACD standard indicator on the channel. I think it will be easy to change MACD to your favorite indicator and use this code for your purposes.\n\nAs a result you will receive messages shown in Fig. 9.\n\nThose who wish to connect analytics to the Yandex.AppMetrika base for their bot, may use the Botan source. The idea of the service is to send them messages received from users, and to request indicators like segmentation, tracking, cohort analysis etc. There is no need to exit Messenger, because statistics will be sent by the special bot in the form of charts, and a more detailed report will be available on the website.\n\nI hope that this articles has inspired you to apply Telegram in trading. It wasn't my goal to cover all details, because they have been already provided in documentation for Bot API. The codes attached to this article are adapted to trading on both platforms — MetaTrader 4 and MetaTrader 5."
    },
    {
        "link": "https://core.telegram.org/bots/api",
        "document": "All queries to the Telegram Bot API must be served over HTTPS and need to be presented in this form: . Like this for example:\n\nThe boost was obtained by the creation of a Telegram Premium or a Telegram Star giveaway. This boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription for Telegram Premium giveaways and prize_star_count / 500 times for one year for Telegram Star giveaways.\n• Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.\n\nUse this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link , where is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.\n\nUse this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success."
    },
    {
        "link": "https://mql5.com/en/articles/15750",
        "document": "In this article, part 5 of our series, we continue integrating MetaQuotes Language 5 (MQL5) with Telegram, focusing on refining the interaction between MetaTrader 5 (MT5) and Telegram. Previously, in part 4 of the series, we laid the groundwork for sending complex messages and chart images from MQL5 to Telegram, establishing the communication bridge between these platforms. Now, we aim to expand on that foundation by enabling the Expert Advisor to receive and interpret commands directly from Telegram users. Instead of the Expert Advisor controlling itself by generating signals, opening market positions, and sending predefined messages to our Telegram chat, we will control it from the Telegram chat by relaying commands to the Advisor which will, in turn, decode the commands, interpret them, and send back intellectual and appropriate request replies and responses.\n\nWe will begin by setting up the necessary environment to facilitate this communication, ensuring everything is in place for seamless interaction. The core of this article will involve creating classes that automatically retrieve chat updates from JavaScript Object Notation (JSON) data, which are the Telegram commands and requests in this case, which will allow the Expert Advisor to understand and process user commands from Telegram. This step is crucial in establishing a dynamic two-way communication where the bot not only sends messages but also intelligently responds to user inputs.\n\nAdditionally, we will focus on decoding and interpreting the incoming data, ensuring that the Expert Advisor can effectively manage various types of commands from the Telegram Application Programming Interface (API). To demonstrate this process, we have provided a detailed visual guide that illustrates the flow of communication between Telegram, MetaTrader 5, and the MQL5 code editor, making it easier to understand how these components work together.\n\nThe provided illustration should be clear to showcase the integration components. Thus, the flow will be as follows: Telegram sends commands to the trading terminal where the Expert Advisor is attached, the Advisor sends the commands to MQL5 which decodes, interprets the messages, and prepares the respective responses, which in turn sends them to the trading terminal and Telegram as responses. For easier understanding, we will subdivide the whole process into topics as follows:\n• Creating Classes to Get Chat Updates from JSON\n• Decoding and Parsing Data from the Telegram API\n\nBy the end of the article, we will have a fully integrated Expert Advisor that sends commands and requests from Telegram to MQL5 and gets supervised replies as responses in Telegram chat. Let's get started then.\n\nIt's fundamental to establish an environment that allows our Expert Advisor (EA) to interface with Telegram before beginning the actual work of creating classes and functions. Our EA will need to access several essential libraries that facilitate the management of trades, arrays, and strings in MQL5. By making these essential libraries available, we ensure our EA has access to a well-stocked function and class library that significantly smooths the way ahead for the implementation of our EA. This is as shown below:\n\nHere, the library \"<Trade/Trade.mqh>\" provides a complete set of trading functions. This library allows the EA to execute trades, manage positions, and perform other trading-related tasks. It's a critical component of any EA that aims to interact with the market. The libraries \"<Arrays/List.mqh>\" and \"<Arrays/ArrayString.mqh>\" that follow are included to facilitate the management of data structures. The first of these two libraries is for managing dynamic lists. The second is for working with arrays of strings. Both of these libraries are particularly useful when dealing with the trading signals we receive from Telegram. That was a lot of jargon, we know. The following chapters will unpack this a bit, and we'll try to explain in more detail what all these components do. To access the \"Arrays\" library, open the navigator, expand the includes' folder, and check either of the two as illustrated below.\n\nFinally, we need to define the Telegram base URL, the timeout, and the bot's token as shown below.\n\nAfter including the libraries and compiling your program, you are all set with the necessary environment that is required for handling complex data structures received from Telegram commands and we can now proceed with the implementation.\n\nCreating Classes to Get Chat Updates from JSON\n\nThis is the section where we focus on developing the core functionality that allows our Expert Advisor (EA) to receive updates from Telegram in real-time. Specifically, we'll need to create classes that parse JSON data returned by the Telegram API and extract the necessary information, such as chat updates and user commands. This step is crucial for establishing a responsive communication loop between Telegram and MetaTrader 5. First, let us simulate the process. We will again load the default function to get chat updates as below in our browser so that we get the data structure we need to implement the classes.\n\nUpon loading, we return true, indicating that the process was a success but the data structure is empty. This is because there are no messages sent from the Telegram chat within the last 24 hours. We thus need to send a message to get an update. For this, we send an initialization message from the Telegram chat as shown below.\n\nOnce we send the message, we now have an update and we can reload the browser link to get the structure of the data sent.\n\nFrom the above image, we can see the correct details in the data structure which is constructed from the message we send. This is exactly the data that we need to copy into our classes and loop through it every time we send a new message update. Thus, let us construct a class that will contain all the member variables. Let us first construct the general class blueprint.\n\nLet us concentrate on the class prototype we have declared above so everything we flow smoothly later. To declare a class, we use the keyword \"class\" followed by the class name, in our case it is \"Class_Message\". Since we will be getting lots of similar data structures, we inherit another class named \"CObject\", and make the inherited members of the foreign class public by using the keyword \"public\". We then declare the first members of the class to be \"public\". Before we continue further, let us explain in detail what all these mean. The keyword is one of the 4 qualifiers, commonly called access specifiers, and they define how the compiler can access variables, members of structures, or classes. The four of them are: public, protected, private, and virtual.\n\nLet us break them down and explain each separately.\n• Members declared under the \"public\" access specifier are accessible from any part of the code where the class is visible. This means that functions, variables, or other objects outside the class can directly access and use public members. They are often used for functions or variables that need to be accessed by other classes, functions, or scripts.\n• : Members declared under the \"protected\" access specifier are not accessible from outside the class, but they are accessible within the class itself, by derived classes (i.e., subclasses that inherit from this class), and by friend classes/functions. This is useful for encapsulating data that should be available to subclasses but not to the rest of the program. They are typically used to allow subclasses to access or modify certain variables or functions of the base class while still hiding those members from the rest of the program.\n• Members declared under the \"private\" access specifier are only accessible within the class itself. Neither derived classes nor any other part of the program can directly access or modify private members. This is the most restrictive access level and is typically used for variables and helper functions that should not be accessible or modifiable from outside the class. They are commonly used to implement data hiding, ensuring that the internal state of an object can only be modified through well-defined public interfaces (methods).\n• Applies only to class methods (but not to methods of structures) and tells the compiler that this method should be placed in the table of virtual functions of the class.\n\nFrom the above-provided syntaxes, only the first three are commonly used. Now getting back to our class prototype, let us break down what everything does.\n\nNote that both the constructor and destructor contain the same name as the base class, only that the destructor has a tide (~) as its prefix. With that, we can now continue to define the members of our class. These members are the same as received in our data structure, thus, we will visualize the data structure and the members that we need to extract from it as below.\n\nFrom the above image, we can see that we need a minimum of 14 members in our class. We define them as below:\n\nWe now have the full class members that we need. The final class structure looks like the one below. We have added comments to make everything self-explanatory in the process.\n\nAfter defining the messages class, we need to initialize its members so that they get ready to receive data. We do this by calling the class constructor.\n\nWe first call the base class and define the constructor by using the \"scope operator\" (::). We then initialize the member variables to their default values. The \"done\" boolean is set to \"false\", meaning that the message hasn't been processed yet. Both \"message_id\" and \"update_id\" are initialized to 0, which represents the default IDs for the message and update. For sender-related information, \"from_id\" is set to 0, and the variables \"from_first_name\", \"from_last_name\", and \"from_username\" are initialized to NULL, meaning that the sender's details aren't set. Similarly, variables related to the chat, that is, \"chat_id\", \"chat_first_name\", \"chat_last_name\", \"chat_username\", and \"chat_type\", are also initialized to 0 or NULL to their data types, meaning that chat information isn't available yet. Finally, \"message_date\" is set to 0, and \"message_text\" is initialized to NULL, which means that the content of the message and the message's date aren't specified yet. Technically, we initialize \"integer\" data type variables to 0 and \"strings\" to NULL.\n\nSimilarly, we need to define another class instance that will be used to hold individual Telegram chats. We will use this data to make a comparison between the data parsed and the data received from Telegram. For example, when we send a command \"get Ask price\", we will parse the data, get updates from the JSON, and check if any of the received data that is stored in the JSON matches our command, and if so, take the necessary action. We hope this clarifies some things, but it will get more clear as we proceed. The class code snippet is as below:\n\nWe define a class named \"Class_Chat\" to handle and keep the information of individual Telegram chats. This class contains an empty constructor and destructor, and several members: \"member_id\" stores the unique ID of the chat; \"member_state\" indicates the state of the chat; and \"member_time\" holds whatever information relates to the timing of the chat. The class has two instances of the base class we have already defined, \"Class_Message\", which holds the last and the new messages respectively. We need these to store the messages and process them individually when the user sends multiple commands. To illustrate this, we will send an initialization message as below:\n\nUpon reading our chat updates, we get the following data structure.\n\nFrom the second message data structure received, we can see that the update and message IDs for the first message are 794283239 and 664 respectively, while the second message has 794283240 and 665, making a difference of 1. We hope that clarifies the need for a different class. We now can proceed to create the last default class that we will use to control the interaction flow seamlessly. Its structure is as below.\n\nWe define a class called \"Class_Bot_EA\" to manage interactions between the Telegram bot and the MQL5 environment. It has several private members as \"member_token\", which stores the authentication token for the bot, and \"member_name\", which contains the name of the bot. Another member is the \"member_update_id\", which keeps track of the last update processed. Several other members manage and filter user interactions. The class has a protected member, \"member_chats\", which maintains a list of chat objects. Among its public members, the most notable are the constructor and the destructor, which do the necessary initialization and cleanup of instances. There are also two notable functions among the public members: \"getChatUpdates\", which retrieves updates from Telegram, and \"ProcessMessages\", which handles the processing of incoming messages. This are the most crucial functions that we will use to get the chat updates and process the received commands. We will initialize these members using a similar format as we did with the first class as below.\n\nHere, we invoke the constructor for the \"Class_Bot_EA\" class and initialize the member variables to set the bot's environment. Initially, the \"member_token\" is set to NULL as a placeholder. Then we assign it the trimmed version of \"InpToken\". This value is very important as it governs the authentication of the bot. If the trimmed placeholder is left in the code, the bot simply will not work. The \"member_name\" is also initialized to NULL, and the \"member_update_id\" is set to 0, which indicates that no updates have yet been processed. The \"member_first_remove\" variable is set to true. This means that the bot is configured to remove the first message it processes. Finally, both \"member_chats\" and \"member_users_filter\" are cleared, to ensure they start up empty. You might have noticed that we used a different function to get the bot's token. The function is as below.\n\nHere, we define two functions that work hand in hand to clean and validate the bot's token string. The first function, \"getTrimmedToken\", accesses the \"bot_token\" as input. It then calls another function, \"getTrimmedString,\" to remove any leading or trailing whitespace from the token. After trimming, the function checks if the token is empty. If the token is empty after trimming, an error message is printed, and the function returns \"NULL\" to indicate that the bot cannot go any further with this token. On the other hand, if the token is not empty, it is returned as a valid, trimmed token.\n\nThe second function, \"getTrimmedString,\" does the actual work of trimming the whitespace from both ends of a given string. It uses StringTrimLeft to remove leading whitespace and StringTrimRight to remove trailing whitespace, then returns the trimmed string as a token that passes the validity test.\n\nUp to this point, we already have the necessary data structures to organize the received metadata. We then need to proceed to get the chat updates and process them simultaneously. To ensure clear communication, we will first call the class functions. At first, to access the class members, we will have to create an object based on the class to give us the required access. This is achieved as below:\n\nAfter we declare the class object as \"obj_bot\", we can access the class's members by using the dot operator. We will need the check for updates and process the messages on a designated time interval. Thus, instead of using the OnTick event handler which will be time-consuming to count the number of ticks that might take computer resources, we opt for the OnTimer function which automatically does the counting for us. To use the event handler, we will need to set and initialize it on the OnInit event handler as below.\n\nHere, we initialize the Expert Advisor by setting up a timer event using the EventSetMillisecondTimer function to trigger every 3000 milliseconds (3 seconds). This ensures that the Expert Advisor continuously checks for updates at regular intervals. We then immediately call the OnTimer event handler to get the first update right after initialization, ensuring that the process starts without delay. Finally, we return \"INIT_SUCCEEDED\" to indicate that the initialization was successful. Then since we set the timer, once the program is deinitialized, we need to destroy the set timer to free the computer resources as well.\n\nHere, when the Expert Advisor is removed or halted, the first thing we do in the OnDeinit event handler is to stop the timer event. This is done using the EventKillTimer function, which is the logical counterpart to EventSetMillisecondTimer. We would not want the timer to keep running if the Expert Advisor is no longer functioning. After stopping the timer, we call the ChartRedraw function. Calling this function is not strictly necessary, but it can help in some circumstances where you need to refresh the chart for changes made to apply. Finally, we call the timer event handler to take care of the counting process.\n\nFinally, we call the OnTimer event handler. Inside it, we call our two crucial functions that are necessary to get the chart updates and process the messages respectively by using the object \"obj_bot\" we created and using the \"dot operator\" to get access to class functions. Up to this point, everything is a success and we can now concentrate on the functions. This is done in the next sections.\n\nDecoding and Parsing Data from the Telegram API\n\nThe first thing we need to do is get the chat updates which we will use to make a comparison with the text received from Telegram and if there's a match, make the necessary response. Thus, we will do this on the function responsible for getting the updates.\n\nAfter calling the function, the first thing we do is make sure we have a valid token, and if not so, we print an error message to the log and return -1, indicating that we can't proceed further without the token. This is as shown below.\n\nIf the token is not empty, we can proceed to prepare a request to send to the Telegram API for retrieving updates from a specified chat.\n\nWe begin by declaring a variable named \"out\" to hold the response returned from the API request. To build the URL for the request, we combine the base API URL (\"TELEGRAM_BASE_URL\"), the bot's token (\"member_token\"), and the method we want to call (\"/getUpdates\"). This method retrieves updates sent to the bot by users, allowing us to see what has happened since the last time we checked for updates. We then include a single parameter in our request. The parameter \"offset\" ensures that we only get updates that occurred after the last retrieved update. Finally, we issue a POST request to the API, with the result of the request stored in the \"out\" variable and indicated by the \"res\" field in the response. We did use a custom function \"postRequest\". Here is its code snippet and breakdown. It is similar to what we have been doing in the prior parts but we have added comments to explain the variables used.\n\nHere, we take care of sending a POST request and processing the reply. We start by taking the input parameters and converting them into a form that they can be sent in—using StringToCharArray to create a character array from the parameters string. We then define two arrays that will capture the response data and the response headers. Finally, we use the WebRequest function to send the POST request to the URL to which it must go, with the parameters that it must use and a timeout setting.\n\nWhen our request is successful (which we determine based on receiving a 200 response code), we make sure there's nothing that could interfere with processing at the very beginning of our response data. Specifically, we check for any Byte Order Mark (BOM). If we find one, we treat it like a substring that shouldn't be there, and we take steps to avoid including it in the data that we eventually use. After that, we convert the data from a character array to a string. If we make it through all these steps without hitting a snag, we return a 0 to indicate that everything went smoothly.\n\nWhen our request doesn't succeed, we deal with the error by checking the code that came back with the response. If the problem lies with the WebRequest function, we tell the user which error code was last set—that's the only way we can figure out what the problem is. If we're dealing with an HTTP error, we do our best to interpret the error message that came with the HTTP response, and we tell the user what we found. Finally, for any other response codes we might get, we just hand back the code.\n\nBefore we proceed further, we can verify the data being sent by checking the response and printing the data. We achieve this by using the following logic.\n\nHere, we check if the result of the post is equal to zero and if so, we print the data for debugging and verification. Upon run, we have the below results.\n\nHere, we can see that the response is true, which means that the process to get the updates was a success. Now we need to get the data response, and to retrieve it, we will need to use a JSON parse. We will not get too deep into the code responsible for parsing but we will include it as a file and as well as add it to the global scope of our program. Upon its addition, we proceed to create a JSON object as below.\n\nAfter creating the object, we use it to deserialize the response as below.\n\nWe declare a boolean variable \"done\" to store the results. This is where we store the flags for either the response we correctly parsed or not. We can print it for debugging purposes as below.\n\nUpon the printout, we get the following response.\n\nHere, we can see that we correctly parsed the response. We need the response to be true for us to proceed. In the case where the response is the latter, we need to halt the process and return since we will not access the rest of the message updates. For that reason then, we make sure that if the response is negative, we terminate the process.\n\nHere, we check whether the JSON parsing was successful by evaluating the boolean variable \"done\". If the parsing fails (i.e., \"done\" is false), we print an error message \"ERR: JSON PARSING\" to indicate that there was an issue with interpreting the JSON response. Following this, we return -1 to signal that an error occurred during the JSON parsing process. Next, we make sure the response is processed successfully via the following logic.\n\nFirst, we verify the value of the 'ok' field in the JSON that is retrieved from the response. This lets us know if the request was processed successfully. We extract this field and store it in a boolean named \"ok\". If the value of \"ok\" is false, it indicates that there was an error or some sort of issue with the response, even though the request itself was successful. In this case, we print \"ERR: JSON NOT OK\" to signal that there was some sort of problem and return -1 to indicate that there also was some sort of problem in processing the JSON response. If all was a success, it means we have message updates and we can proceed to retrieve them. Thus, we will need to declare an object based on the messages class as follows:\n\nWe can now loop via all the message updates and store them in the class using the object created. First, we need to get the total number of updates, which is achieved via the following logic.\n\nOn each iteration, we need to retrieve an individual update item from the JSON response for which we work.\n\nWe then can proceed to get the individual chat updates. First, let us have the message updates.\n\nHere, we take the details of the individual message from the update item indicated by \"obj_item\". We begin by pulling the update ID from the JSON object and stashing it in \"obj_msg.update_id\". After that, we pull the message ID and park it in \"obj_msg.message_id\". The message's date, which comes in a not-so-human-readable format, is also included in the item, and we store it as a \"datetime\" object in \"obj_msg.message_date\", which we \"typecast\" into a human-readable format. Then we look at the message's text. For the most part, we can just grab the text and put it in \"obj_msg.message_text\". However, sometimes, its HTML entities are encoded; other times, it has special characters that are also encoded. For those instances, we handle them in a function called \"decodeStringCharacters\". This is a function that we had earlier explained, we'll just call it to do its thing. Then, in a similar format, we extract the sender details.\n\nAfter extracting the sender details, we extract the chat details as well in a similar manner.\n\nUp to this point, you should have noticed that the structure is just the same as the one that we provided on the data structure from the browser. We then can proceed to update the update ID to make sure that the next request for updates from Telegram starts at the right point.\n\nHere, we update the \"member_update_id\" to make sure that the next request for updates from Telegram starts at the right spot. By assigning the value \"obj_msg.update_id + 1\", we set the offset so that the next request doesn't include the current update and, in effect, only gets new updates that happen after this ID. This is important because we don't want to handle the same update more than once, and we also want to keep the bot as responsive as possible. Next, we check for new updates.\n\nHere, we determine whether the current update is the first post-initialization update being processed by checking the flag \"member_first_remove\". If \"member_first_remove\" is true, it indicates that we are processing the first update - the initial update - after everything has been initialized. We then skip processing this update by simply continuing to the next one. Finally, we filter and manage chat messages based on whether a username filter is applied.\n\nFirst, we determine whether a username filter is active by checking the \"member_users_filter.Total()\". If there is no filter (\"Total() == 0\"), we handle all messages as usual. If there is a filter (\"Total() > 0\"), we ascertain whether the sender's username (\"obj_msg.from_username\") is in the filter, using \"member_users_filter.SearchLinear()\". If we find the username, we go ahead and handle the message.\n\nWe then search for the chat in the \"member_chats\" list by iterating through it and comparing the chat ID (\"obj_msg.chat_id\"). If the chat isn't found (index == -1), we add a new \"Class_Chat\" object to the list. We initialize the object with the chat ID, the current time, an initial state of 0, and the text of the new message. We also mark the new message as not done (done = false).\n\nIf the chat is already in the list, we update the existing chat object with the new text of the message and the current time, marking the message as unprocessed. This guarantees that the latest message in each chat is recorded and updated properly. After all is done, we set the first update flag to false.\n\nFinally, we return the result of the post request.\n\nArmed with this function, we can be sure that we retrieve the chat updates and store them at every set time interval, and thus we can process them whenever we need to. The processing of the messages is done in the next section.\n\nAfter getting the chat updates, we can proceed to access the retrieved messages, make comparisons, and send responses back to Telegram. This is achieved via the use of the class's \"ProcessMessages\" function.\n\nThe first thing that we need to do is process the individual chats.\n\nHere, we iterate through the \"member_chats\" collection and retrieve the corresponding chat object for each chat using the index variable, \"i\", from \"member_chats\". For every chat, we check the current chat's associated message to see if it has been processed yet by evaluating the done flag in the \"member_new_one\" structure. If the message has not been processed yet, we set this flag to true, marking the message as handled to prevent duplicate processing. Finally, we extract the text of the message from the \"member_new_one\" structure. We will utilize the text to determine what kind of response or action, if any, should be taken based on the content of the message. First, let us define an instance where the user sends a greeting text \"Hello\" from Telegram.\n\nHere, we verify whether the message text says, \"Hello.\" If it does, we craft a response that lets the user know the system received and processed the \"Hello\" text. This reply serves as a confirmation that the input was correctly handled by the MQL5 code. We then send this acknowledgment back to the user to let them know their input was successfully processed. To send the response, we will need to craft another function to handle the replies.\n\nHere, we define the function \"sendMessageToTelegram\", which sends a message to a specified Telegram chat using the Telegram Bot API. Firstly, we construct the URL for the API request by combining the base URL for Telegram, the bot token (retrieved using \"getTrimmedToken\"), and the specific method for sending messages (\"sendMessage\"). This URL is essential for directing the API request to the correct endpoint. Next, we build the query parameters for the request. These parameters include:\n• The ID of the chat where the message will be sent.\n• The content of the message, which is URL-encoded to ensure it is transmitted correctly.\n\nIf a custom reply keyboard markup (\"reply_markup\") is provided, it is appended to the parameters. This allows for interactive buttons in the message. Additional parameters include:\n• Specifies that the message should be interpreted as HTML, allowing for formatted text.\n• Ensures that any web page previews are disabled in the message.\n\nFinally, the function sends the request using the \"postRequest\" function, which handles the actual communication with the Telegram API. The response code from this request is returned to indicate whether the message was successfully sent or if an error occurred.\n\nWe can then call this function with the respective parameters as below to send the response.\n\nHere, we first utilize the \"sendMessageToTelegram\" function to dispatch the response message to the appropriate Telegram chat. We call the function with the \"chat.member_id\" that targets the right chat for the right content message. The \"reply_markup\" parameter is set to NULL, meaning that the message sent has no keyboard or interactive elements accompanying it. After sending the message, we use the \"continue\" statement. It skips any remaining code in the loop currently processing and moves to the next iteration of that loop. The logic here is straightforward: We handle and forward the response to the current message. After that, we pretty much move on, not processing any further code for the current chat or message in the current iteration. Upon compilation, this is what we get.\n\nWe can see that the message was received and processed within seconds. Let us then move on to adding a custom reply keyboard to our function.\n\nHere, we define the function \"customReplyKeyboardMarkup\", which creates a custom reply keyboard for Telegram. This function takes three parameters: keyboard, resize, and one_time. The keyboard parameter specifies the layout of the custom keyboard in JSON format. The resize parameter determines whether the keyboard will be resized to fit the screen of the user's device. If the resize parameter is set to true, the keyboard will be resized to fit the screen of the user's device. The one_time parameter specifies whether the keyboard will become a \"one-time\" keyboard, disappearing after the user has interacted with it.\n\nWithin the function, a JSON string is constructed that represents the custom reply keyboard markup. To ensure that the keyboard parameter is formatted correctly for the API request, we use \"UrlEncode\" function to encode it. Next, we rely on the \"convertBoolToString\" function to change the boolean values for resize and one_time (which determine whether these values should be considered true or false) into their string representations. Finally, the constructed string is returned from the function and can be put to use in API requests to Telegram. The custom function we use is as follows.\n\nFinally, to hide and force-reply on the custom keyboards, we use the following functions.\n\nHere, the functions \"hideCustomReplyKeyboard\" and \"forceReplyCustomKeyboard\" generate JSON strings that specify particular actions to be taken by Telegram's custom keyboard feature.\n\nFor the function \"hideCustomReplyKeyboard\", the JSON string it generates reads: \"{\\\"hide_keyboard\\\": true}\". This JSON configuration tells Telegram to hide the reply keyboard after the user sends a message. In essence, this function serves to make the keyboard disappear once a message has been sent.\n\nFor the function \"forceReplyCustomKeyboard\", the JSON string it generates reads: \"{\\\"force_reply\\\": true}\". This string tells Telegram to require a response from the user before they can interact with any other UI element in the chat. This string serves to keep the user interacting singularly with the message that was just sent.\n\nArmed with the custom reply keyboard function, let us then call the function to have the reply keyboard constructed in Telegram.\n\nWhen we send the message in Telegram, we get the following result.\n\nWe can see that that was a success. Now, we can send the message by just clicking on the button. It is however pretty large. We can add several buttons now. First, let us add buttons in rows format.\n\nHere, we define a custom reply keyboard layout with the variable \"buttons_rows\". This string \"[[\\\"Hello 1\\\"],[\\\"Hello 2\\\"],[\\\"Hello 3\\\"]]\" represents a keyboard with three buttons, each labeled \"Hello 1\", \"Hello 2\", and \"Hello 3\". The format of this string is JSON, which is used by Telegram to render the keyboard. Upon run, we have the following results.\n\nTo visualize the keyboard layout in column format, we implement the following logic.\n\nUpon running the program, we receive the following output.\n\nWe can see that the layout we received is in columnar format, which means that the process was a success. We can now continue to create more complex commands. At first, let us have a custom list of commands that the user can quickly process.\n\nHere, we verify whether the incoming message is among the predetermined commands of \"/start,\" \"/help,\" \"Start,\" and \"Help.\" If it is one of these commands, we prepare a welcoming missive that introduces the bot to the user and provides a list of commands that can be sent to the bot to interact with it. We elide parts of this list and categorize other parts of it to give the user an overview of what they can do with the bot. Finally, we send this message along with a custom keyboard back to the user that's better suited to interact with the bot than the command line is. We have also defined the custom keyboard as follows.\n\nWe use the macro #define to define two elements that will be used in the Telegram bot's user interface. First, we define \"EMOJI_CANCEL\" as a cross-mark emoji using its Unicode representation \"\\x274C\". We will use this emoji in the keyboard layout to indicate a \"Cancel\" option. The emoji's Unicode representation is as shown below:\n\nNext, we define \"KEYB_MAIN\", which represents the main keyboard layout for the bot. The keyboard is structured as a JSON array with rows of buttons. The layout includes options that are contained in the commands' list which are \"Name,\" \"Account Info,\" \"Quotes,\" and a row with \"More,\" \"Screenshot,\" and the \"Cancel\" button represented by the \"EMOJI_CANCEL\". This keyboard will be displayed to the user, allowing them to interact with the bot by pressing these buttons instead of typing commands manually. When we run the program, we get the following output.\n\nWe now have the JSON-formatted custom keyboard and the list of commands that we can send to the bot. What now remains is the crafting of the respective responses as per the received commands from Telegram. We will begin by replying to the \"/name\" command.\n\nHere, we verify whether the message received from the user is either \"/name\" or \"Name\". On the occasion that this check yields a positive result, we set to work on constructing a reply to the user that contains the name of the Expert Advisor (EA) file that is currently being used. We initialize a string variable called \"message\", which begins with the text \"The file name of the EA that I control is:\n\n\". We follow this initial declaration with a book emoji (represented by the code \"\\xF50B\") and the name of the EA file.\n\nWe use the built-in MQL5 macro \"__FILE__\" to get the name of the file. The macro returns the file's name and path. We then construct a message to be sent to the user. The message consists of the name of the EA file and the path to it. We send the constructed message using the \"sendMessageToTelegram\" function. This function takes three parameters: the first is the chat ID of the user to whom we want to send the message; the second is the message itself; and the third parameter, which is set to \"NULL\", indicates that we are not sending any custom keyboard or button commands along with our message. This is important since we don't want to create an additional keyboard. When we click on either the \"/name\" command or its button, we receive the respective response as below.\n\nThat was a success. Similarly, we craft the respective responses to account information and price quote commands. This is achieved via the following code snippet.\n\nFor the trading operation commands, more particularly opening a buy position, we use the following logic.\n\nHere, we handle a scenario where the user sends the message \"/buy\" or \"Buy\". Our first step is to create a CTrade object named \"obj_trade\", which we will use to carry out the trading operation. We then obtain the current ask and bid prices by calling the SymbolInfoDouble function. To open our buy position, we use the Buy function of the CTrade object. We set the volume of the trade at 0.01 lots. For our SL (stop loss) and TP (take profit), we set the bid price minus 300 points and the bid price plus 300 points, respectively.\n\nOnce the position is opened, we ascertain the new order's ticket number via the \"ResultOrder\" function. With the ticket in hand, we use the function PositionGetInteger to select the position by ticket. We then retrieve vital statistics like the entry price, volume, stop loss, and take profit. Using these numbers, we construct a message that will inform the user they have opened a buy position. To handle the position closure and contact command, we use the following similar logic.\n\nIt is now clear we can respond to commands sent from Telegram. Up to this point, we just send plain text messages. Let us be a bit more fancy and format our text messages using the Hypertext Markup Language (HTML) entity, which could also be Markdown. Your choice!\n\nHere, we respond to the user when they send the message \"/join\" or \"Join\". We start by crafting a message that invites the user to join the MQL5 Community. The message includes a hyperlink that users can click to join the community, as well as several examples of how text can be formatted using HTML tags in Telegram:\n• Strike-through Text: We use the <s> tag to strike through the words \"Civil Engineering\" and emphasize that we focus on \"Forex AlgoTrading.\"\n• Preformatted Text: The <pre> tag is used to show a sample of MQL5 code in a preformatted text block.\n• Italic and Underlined Text: The <u> and <i> tags are combined to underline and italicize a reminder for users to follow community guidelines, adding a Unicode emoji for emphasis.\n• Bold Text: The <b> tag is used to bold the closing statement \"Happy Trading!\"\n\nFinally, we send this formatted message to the user via Telegram using the \"sendMessageToTelegram\" function, ensuring the user receives a well-formatted and engaging invitation to join the MQL5 community. Upon run, we get the following output.\n\nNow that we have depleted the command lists, let us continue to modify the reply keyboard and generate a new one once the \"more\" button is clicked. The following logic is implemented.\n\nWhen we receive the message \"more\" or \"More\" from the user, we take it as a signal to update the current conversation's context. In the world of chatbots, the message indicates that the user is not satisfied with the current number of options or has not found what they are looking for so far. Our response to the user must therefore provide a different variety of selections. In practical terms, this means that we send the user a new message with a new keyboard layout. The \"KEYB_MORE\" is as shown below:\n\nWhen we run the program we get the following output.\n\nThat was a success. We can similarly handle the other commands.\n\nHere, we deal with diverse user messages to control the chat interface. When a user sends the up emoji, we take that as a signal and reset the chat state to 0, prompting the user to once again choose a menu item, accompanied by the main keyboard layout. When a user sends \"next\" or \"Next,\" we update the chat state to 2 and instruct the user to once again choose a menu item, this time from a keyboard layout that presents additional options.\n\nFor the pistol emoji, we adjust the chat state based on its current value: if the state is 2, we switch it to 1 and present the more options keyboard; if the state is different, we switch it to 0 and present the main menu keyboard. For the cancel emoji, we reset the chat state to 0 and send the user a message that tells them to choose either \"/start\" or \"/help\" to begin. We send this message with the hidden custom reply keyboard to clear any active custom keyboards for the user. The extra custom layouts used are as below:\n\nUp to this point, everything is complete. We just have to handle the screenshot commands and that will be all. The following logic is implemented to handle the mode of receipt of the chart images. The keyboard layout will be used for this purpose rather than having to type manually.\n\nHere, we deal with the user's requests for a screenshot of a chart by managing the different states of the chat flow. When the user sends the command \"/screenshot\" or \"Screenshot,\" we set the chat state to 10 and prompt the user for a symbol by displaying a keyboard with the available symbols. It is important to note here that the chat state can be any numeral, even 1000. It just acts as an identifier or quantifier to store the state that we remember during the response processing. If the user provides a symbol, we check its validity. If it's valid, we ask the user for a period (a valid \"time\" for the chart) by displaying a keyboard with the available options for periods. If the user provides an invalid symbol, we notify them and prompt them to give us a valid one.\n\nWhen the user inputs a time frame, we check to see if it’s valid. If the time frame is one of the predefined valid options, we move on to update the chat state and forward the user’s request for a screenshot of the symbol given in the last valid caption, with the just-in-time fulfillment details necessary for the implied \"if-then\" statement we started with—and initiate the screenshot process in our backend. If, on the other hand, the user provides a time frame that doesn’t match one of the valid predefined options, we just let the user know that the input was erroneous, repeating the valid options we showed in line with the initial input request. The custom reply keyboards for the symbols and periods and the timeframe array we use are defined below.\n\nUp to this point, we are now all set with our fully customized keyboard and replies. To ascertain this, we run the program. Here are the output results we get.\n\nHere, we can see that the screenshot-sending process is initiated and accomplished. Any invalid commands or inputs are handled in a manner that ensures that only valid commands are sent by the user. To ascertain that everything works out as intended and pinpoint any resulting limitations, we will need to test the implementation thoroughly. This is done in the next section.\n\nTesting is a crucial phase in validating that our created program functions as intended. Thus, we will need to check if it works correctly. The first thing we do is enable the webpage preview in our link responses. Allowing web page previews in links lets users glimpse the content before they click through. They see a title and image that often convey a good sense of what the linked page is about. This is great from a user experience standpoint, especially when you consider that it’s often hard to judge a link’s quality just from the text of the link itself. Thus, we will turn on the disabled preview to false as follows.\n\nOnce we run this, we get the following output.\n\nWe can now receive the web page previews as shown. That was a success. We can then move to changing the formatting entity or parse mode from Hypertext Markup Language (HTML) to Markdown as follows:\n\nIn markdown parse mode, we will need to change the whole formatting structure of our initial code with markdown entities. The correct form will be as below.\n• Link: In Markdown, links are created with [text](URL) instead of <a href=\"URL\">text</a>.\n• Strike-through: Use ~text~ for strike-through instead of <s>text</s>.\n• Preformatted text: Use triple backticks (```) to format preformatted text instead of <pre>text</pre>.\n• Italic and underline: Markdown does not natively support underline. The closest you can get is italic with *text* or _text_. The underline effect from HTML is not directly supported in Markdown, so it is included with a placeholder if needed.\n• Bold: Use double asterisks **text** for bold instead of <b>text</b>.\n\nWhen we run the program, we receive the following output.\n\nTo demonstrate the testing process, we have prepared a video that showcases the program in action. This video illustrates the different test cases we ran and highlights how the program responded to various inputs and how well it performed its necessary tasks. When you watch this video, you'll get a very clear picture of the testing process and will be able to see, without any doubt, that the implementation meets the expected requirements. The video is presented below.\n\nIn summary, the successful execution and verification of the implementation, as demonstrated in the attached video, affirm that the program is functioning as intended.\n\nTo sum up, the Expert Advisor that we created integrates the MetaQuotes Language 5 (MQL5) language—along with the MetaTrader 5 trading platform—with the Telegram messaging app, allowing users to quite literally talk to their trading robots. And why not? Telegram has emerged as a powerful, user-friendly way of controlling automated trading systems. Using it, one can send commands and receive responses from the system in real-time.\n\nIn our case, we have made sure that instead of waiting for the Expert Advisor to communicate with the Telegram bot which relays the communication to the user, we connect the two bots and communicate with the Expert Advisor whenever we want without having to wait for a signal generation. We set up a series of conversations between the user and the bot. We made sure that the MQL5 commands that the user sent through Telegram were interpreted correctly. After a lot of testing, we can confidently say that our Expert Advisor is both reliable and robust."
    },
    {
        "link": "https://mql5.com/en/articles/15795",
        "document": "In the world of financial programming, especially in the context of MetaTrader 5, the ability to interact with remote servers via HTTP is vital. Whether it’s to obtain real-time market data, send trading orders to an API, or even query third-party services, HTTP requests play a crucial role. In MQL5, the WebRequest function is the native tool provided for such communications, but its limitations make it impractical in many scenarios.\n\nHTTP (Hypertext Transfer Protocol) is the basis of web communication, and mastering its use allows developers to create rich and dynamic integrations between MetaTrader 5 and other services. For example, an Expert Advisor (EA) may need to access a news API to adjust its trading strategies based on global events. Another common application is querying cryptocurrency prices on exchanges that offer HTTP APIs, allowing the EA to trade in sync with these markets.\n\nDespite the importance of HTTP requests, the implementation of the WebRequest function in MQL5 is not exactly what one would expect from a modern and flexible tool. This puts developers in a challenging position: either adapt to the limitations or look for workarounds. The series of articles we are starting here aims to do just that—explore the weaknesses of the WebRequest function and build a library, Connexus, that overcomes these limitations and makes the work of MQL5 developers easier.\n\nThe WebRequest function opens up a wide range of possibilities for integration with external services. From collecting financial data, which can be essential for automated trading decisions, to fully automating processes, this function allows EAs to interact directly with the web. This allows, for example, your trading robot to obtain real-time information from external sources, such as economic news or market data from other platforms. This data can be processed and used to automatically adjust your trading strategies, increasing both the accuracy and efficiency of your operations.\n\nHowever, as will be demonstrated in the examples presented, using the WebRequest function may not be trivial. Sending an HTTP request might seem simple, but you will quickly encounter technical challenges, such as sending the correct headers, formatting JSON data, properly handling server responses, and even dealing with errors and exceptions that may occur during communication. These challenges will illustrate that, although powerful, the function requires a solid understanding of protocols and communication between systems, which can present a significant barrier for developers who are just starting to explore this area.\n\nThis is exactly where the need for a more accessible and efficient tool will come in. The Connexus library, which will be developed and improved in the upcoming articles in this series, aims to overcome these limitations and make the integration process via WebRequest more user-friendly and intuitive. With Connexus , the idea will be that developers can focus on what truly matters: the logic of their applications and EAs, without having to deal directly with the technical details of the lower layers of network programming. Instead of wasting time debugging formatting or header errors, you will be able to focus on integrating your systems efficiently, with a clear and functional interface.\n\nThis series of articles will be dedicated to thoroughly exploring the weaknesses of the WebRequest function, its limitations, and how we will work around them when developing a robust solution. In addition to continuing the discussion of the HTTP protocol, we will cover aspects such as authentication in APIs, handling large volumes of data, and implementing advanced features like response time control and handling multiple simultaneous requests.\n\nSo, if you are interested in improving your MQL5 development skills, learning more about system integration, and optimizing HTTP communication processes, stay tuned for the upcoming publications. We will continue to expand the scope of this project, guiding you in developing the Connexus library so that it becomes an indispensable tool in your development arsenal. The knowledge gained here will be useful not only for those who work with MetaTrader, but also for any developer who needs to integrate APIs and web services into their applications.\n\nGetting to Know WebRequest\n\nThe WebRequest function is the main tool provided by MQL5 for making HTTP requests. In simple terms, it allows an MQL5 program to send a request to a server and receive a response. Although it may seem simple, practical use of WebRequest reveals a number of pitfalls and complexities that can complicate development.\n\nThe basic syntax of the function has two versions:\n\nThe parameters of the WebRequest function are vital to its proper functioning, and a detailed understanding of them is essential for any developer who wants to use it effectively. Let's explore each of these parameters:\n\nEach of these settings must be configured carefully to ensure that the request is made correctly. An error in any of these parameters can result in a malformed request or a complete failure to communicate with the server.\n\nThe function returns an HTTP status code that indicates the success or failure of the operation. While WebRequest covers the basic concepts, its implementation leaves much to be desired. It requires the developer to manually manage the creation of headers, the handling of different data types, and the error checking, making the process tedious and error-prone. One good thing about WebRequest is that it supports both GET and POST requests, which allows it to interact with a wide range of APIs.\n\n\n\n\n\nPractical Example of the WebRequest Function\n\nTo illustrate the use of the WebRequest function, let's build a simple example. For this we will use httpbin.org, which is a free online service that allows you to make and test HTTP requests. It was created by kennethreitz, it is an OpenSource project (link). This service works in a very simple and uncomplicated way. It is basically a \"mirror\". You stand in front of the mirror and strike a pose or ask a question. This is like sending a request to HTTP Bin. The mirror reflects exactly what you are doing. This is like HTTP Bin receiving and reflecting what you sent. It is a useful tool for developers who want to check exactly what is being sent in their HTTP requests or who need to simulate different types of requests and responses. Some common features of httpbin include:\n• Sending Requests: You can send HTTP requests of different types, such as GET, POST, PUT, DELETE, etc., to see how the server responds.\n• HTTP Header Testing: You can send custom headers and view the server’s response, which is useful for debugging header-related issues.\n• Sending Data in the Request Body: It’s possible to test sending data in the request body and see how the server handles it.\n• HTTP Status Simulation: You can request the server to return specific status codes, such as 200, 404, 500, etc., to test how your application handles different status responses.\n• Simulation of Delays and Redirects: httpbin.org allows simulating response delays or redirects, helping to test system behavior in more complex scenarios.\n• Cookie Testing: You can manipulate cookies, seeing how they are set and returned by the server.\n\n\n\nIt is a practical tool for integrating systems that use the HTTP protocol. Let’s make the simplest possible GET request using WebRequest.\n\nAccording to the documentation: To use the WebRequest() function, add the required server addresses to the list of allowed URLs in the \"Tools\" tab of the \"Options\" window. The server’s port is automatically selected based on the specified protocol - 80 for \"http://\" and 443 for \"https://\".\n\nIn the directory <data_folder>/MQL5/Experts , create a folder called Connexus. We will place our test files in this folder. To find the data folder, in the MetaTrader or MetaEditor main menu, select File > Open Data Folder. Inside that folder, create a file named “WebRequest.mq5” and you’ll have something like this:\n\nWe will only use the OnInit() event for testing for now. Let's define some variables to perform the request and pass them to the WebRequest function.\n\nWhen we insert the robot into the chart, the terminal will print the following response:\n\nNote that the status code received was 200, meaning the request was successful, and in the response we received a JSON with some data. In the next article we will explore in more detail how communication works via the HTTP protocol. Now we will change the HTTP verb to POST and send data in the body of the request.\n\nOkay, now we have everything working, considering that httpbin will return everything we send, it should return the body we sent, right? Executing the POST code will return:\n\nNote that we have some additional fields, such as “json” and “data”. Let’s understand each of them. The “data” field should show the body that we sent in string format, while the “json” field should show the body that we sent in json format. But why are both empty if we sent the body in the request? Because we have to inform the server that the content type will be json. To do this, we configure the request header, like this:\n\nNotice that now the data we sent is in the “data” field, which indicates that we are on the right track, but notice that the \\u0000 character appears because the StringToCharArray method includes the null terminator when converting the string to a byte array. To avoid this, we can adjust the size of the array. Let’s print the body that we are sending to see where this “\\u0000” character is coming from.\n\nNote that the body string is valid JSON, that is, it opens and closes square brackets, values ​​are separated by commas, and respects the key:value rule. Let's see the byte array that is generated by the StringToCharArray function. Note that it prints the size of the string and the array, but they are different. The byte array is one position larger than the string. Also note that in the list of values, the last value is \"0\" where it should be 125, which is the character \"}\". So to solve this, we will remove the last position of the array using ArrayRemove().\n\nNow, the size of the string and array are aligned, and the server correctly found the content as valid JSON. This can be provided in the response return, where the server returns the JSON sent in the \"json\" and \"data\" fields. After some configuration, we were able to perform a simple HTTP POST request, sending data correctly. However, using the WebRequest function is not trivial; it requires a good understanding of how the protocol works and the structures we are manipulating. Often, even small drawbacks can become complicated, as we saw when adjusting the code to obtain a valid response. The goal of the Connexus library is precisely to simplify this process, allowing the end user to not have to deal with these lower and more abstract layers of programming, avoiding complex problems like the one we are facing now, making the use of WebRequest more accessible and efficient.\n\nThroughout this article, we have explored in detail the use of the WebRequest function in MetaTrader 5, an essential tool for developers looking to expand the capabilities of their Expert Advisors (EAs) by communicating with external servers and APIs. We have used the httpbin.org service as a practical example to perform GET and POST requests, send and receive data in JSON format, and understand the server responses. This introduction is just the beginning of a journey of system integration via HTTP, providing the basis for much more complex projects in the future.\n\nThe journey is just beginning. Together, let's transform the WebRequest function into a simplified, powerful and accessible tool, simplifying the development of Expert Advisors and opening doors to new possibilities for automation and integration in MetaTrader 5."
    },
    {
        "link": "https://mql5.com/en/forum/432897",
        "document": "Hello I have a .mq5 indicator and I have a custom flask python server running on local host (0.0.0.0:80)\n\nI'm trying to setup a system where the indicator (inside of OnInit()) would send a HTTP POST request to the server with some information and then the server would return a message back based on the information that was sent.\n\nI've been going down some rabbit holes. I found webrequest but this is not supported within indicator code, only EA/scripts from my understanding.\n\nI found XML-rpc and using winlet.dll but both of these code articles are 10-11 years old. I made attempts at using both of them (connecting to a localhost python server on port 80) but was unable to be successful after spending several hours with both libraries. I had hard time debugging them since I wasn't sure if the code was just out of date or if I was missing something in the code. For the XML-RPC I couldn't even get a simple connection to my python server using the following code\n\nWhat I'm now considering is writing my own .dll to send the POST request. I'm just sending a few string arguments in the POST request, it's nothing super complex like downloading files. I was considering using something like curl or https://github.com/elnormous/HTTPRequest, compiling the DLL, and then importing into .mq5.\n\nI'm more so making this post to hopefully gain some helpful insight or ideas from the community. Is there something really easy that I'm missing and there is an easier way to do what I trying to accomplish? Is what I'm trying to do even possible? I really appreciate anyone taking the time to read through this and give me insight/ideas. Thanks!"
    },
    {
        "link": "https://mql5.com/en/forum/442474",
        "document": "I assume that its a quite easy question for you but I need your help.\n\nI got a website where I want my future EA clients to but their AccountIDs for a license Check.\n\nWhen I call the API via Postman I get the data, however I am unable to adapt the accordingly to get it to work, please help :)\n\nThe API will return a JSON, that I want to parse lateron to check for the AccountIDs and if the Account is still valid\n\nFrom my understanding / the documentation I dont need any includes\n\nThank you very much!"
    },
    {
        "link": "https://stackoverflow.com/questions/42098884/how-to-post-from-metatrader-terminal-5-mql-5-a-request-to-my-nodejs-server-whic",
        "document": "I'm trying to get FX rates in my nodejs server and socke.io emit them to the client, while running MetaTrader Terminal 5 or 4.\n\nSo I guess I have to use MQL4/5. I know how the handle the request in my nodejs server. What I dont know is where to write the MQL4 code, what to config in my MetaTrader Terminal.\n\nLets say I want to send EUR/USD bid rate to my nodejs server everytime it gets changed. How do I achieve that, using MT4/5 and MQL4/5?\n\nWhen I compile and run, I see that it was executed in MT Experts tab, but on my nodejs server, console logs nothing."
    },
    {
        "link": "https://stackoverflow.com/questions/39954177/how-to-send-a-post-with-a-json-in-a-webrequest-call-using-mql4",
        "document": "So, back to the square No.1:\n\nIn the last-year's post, there was a step by step methodology to proceed with a MCVE-based approach to the problem isolation.\n\nRepeating the same steps here, inside -code,\n\n adding a -based mock-up WebSERVER, to diagnose the actual working client/server http-protocol exchange & handshaking, ( not the WebSERVER-side interpretation of the delivered POST-request, which is the same, as if one have launched the URL from a WebBROWSER, for all related details ref: )\n\nthe output is\n\nproviding an evidence that the last pair of rows were produced by an -side that was setup correctly and works fine there and back\n\n[ MetaTrader Terminal 4 ]-Log reads:\n\nA raw -snippet BUT use at one's own risk!\n\n\n\n\n\nAll have been warned, so:\n\nLast years setup picture is still valid:\n\nThe mock-up WebSERVER had inside the dotted form-field input of:\n\nOne shall also bear in mind, that trying to set a specific port designation in the URL will violate the MetaQuotes Inc. design rule, that a port is being derived from the protocol pragma at the beginning of the URL declaration, so:\n\nwill not work, as CANNOT use other port but either of , given by protocol pragma stated in URL:\n\nThus for any port-numbering gymnastics, one has to setup and tune a proper set of port-forwarding services, that would leave MetaTrader Terminal 4 live inside this design-cage, using just either of .\n\nThe simplest -script demonstrator looks this way:\n\nIf documentation says something, it is worth keeping that advice ( with some tests, sure ).\n\nIf a sponsored Community advice says something, it is worth giving it at least a try, before asking for more."
    }
]