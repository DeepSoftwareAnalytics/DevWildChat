[
    {
        "link": "https://github.com/tauri-apps/tauri",
        "document": "Tauri is a framework for building tiny, blazingly fast binaries for all major desktop platforms. Developers can integrate any front-end framework that compiles to HTML, JS and CSS for building their user interface. The backend of the application is a rust-sourced binary with an API that the front-end can interact with.\n\nThe user interface in Tauri apps currently leverages as a window handling library on macOS, Windows, Linux, Android and iOS. To render your application, Tauri uses WRY, a library which provides a unified interface to the system webview, leveraging WKWebView on macOS & iOS, WebView2 on Windows, WebKitGTK on Linux and Android System WebView on Android.\n\nTo learn more about the details of how all of these pieces fit together, please consult this ARCHITECTURE.md document.\n\nIf you are interested in making a tauri app, please visit the documentation website.\n\nThe quickest way to get started is to install the prerequisites for your system and create a new project with . For example with :\n\nThe list of Tauri's features includes, but is not limited to:\n• Built-in app bundler to create app bundles in formats like , , , , and Windows installers like (via NSIS) and (via WiX).\n\nTauri currently supports development and distribution on the following platforms:\n\nBefore you start working on something, it's best to check if there is an existing issue first. It's also a good idea to stop by the Discord server and confirm with the team if it makes sense or if someone else is already working on it.\n\nPlease make sure to read the Contributing Guide before making a pull request.\n\nThank you to everyone contributing to Tauri!\n\nDocumentation in a polyglot system is a tricky proposition. To this end, we prefer to use inline documentation in the Rust & JS source code as much as possible. Check out the hosting repository for the documentation site for further information: https://github.com/tauri-apps/tauri-docs\n\nFor the complete list of sponsors please visit our website and Open Collective.\n\nTauri aims to be a sustainable collective based on principles that guide sustainable free and open software communities. To this end it has become a Programme within the Commons Conservancy, and you can contribute financially via Open Collective.\n\nCode: (c) 2015 - Present - The Tauri Programme within The Commons Conservancy."
    },
    {
        "link": "https://v2.tauri.app",
        "document": "Bring your existing web stack to Tauri or start that new dream project. Tauri supports any frontend framework so you don’t need to change your stack."
    },
    {
        "link": "https://docs.rs/tauri/latest/tauri",
        "document": "Tauri is a framework for building tiny, blazing fast binaries for all major desktop platforms. Developers can integrate any front-end framework that compiles to HTML, JS and CSS for building their user interface. The backend of the application is a rust-sourced binary with an API that the front-end can interact with.\n\nThe following are a list of Cargo features that can be enabled or disabled:\n• wry (enabled by default): Enables the wry runtime. Only disable it if you want a custom runtime.\n• common-controls-v6 (enabled by default): Enables Common Controls v6 support on Windows, mainly for the predefined menu item.\n• unstable: Enables unstable features. Be careful, it might introduce breaking changes in future minor releases.\n• objc-exception: This feature flag is no-op since 2.3.0.\n• linux-libxdo: Enables linking to libxdo which enables Cut, Copy, Paste and SelectAll menu items to work on Linux.\n• isolation: Enables the isolation pattern. Enabled by default if the config option is set to on the file.\n• custom-protocol: Feature managed by the Tauri CLI. When enabled, Tauri assumes a production environment instead of a development one.\n• devtools: Enables the developer tools (Web inspector) and . Enabled by default on debug builds. On macOS it uses private APIs, so you can’t enable it if your app will be published to the App Store.\n• native-tls: Provides TLS support to connect over HTTPS.\n• native-tls-vendored: Compile and statically link to a vendored copy of OpenSSL.\n• rustls-tls: Provides TLS support to connect over HTTPS using rustls.\n• process-relaunch-dangerous-allow-symlink-macos: Allows the function to allow symlinks on macOS (this is dangerous, see the Security section in the documentation website).\n• tray-icon: Enables application tray icon APIs. Enabled by default if the config is defined on the file.\n• macos-private-api: Enables features only available in macOS’s private APIs, currently the window functionality and the preference setting to . Enabled by default if the config flag is set to on the file.\n• webview-data-url: Enables usage of data URLs on the webview.\n• compression *(enabled by default): Enables asset compression. You should only disable this if you want faster compile times in release builds - it produces larger binaries.\n• config-toml: Adds support to TOML format for the configuration .\n• specta: Add support for with Tauri arguments such as , and\n\nThe following are a list of Cargo features that enables commands for Tauri’s API package. These features are automatically enabled by the Tauri CLI based on the configuration under ."
    },
    {
        "link": "https://dev.to/stevepryde/create-a-desktop-app-in-rust-using-tauri-and-yew-2bhe",
        "document": "I recently created a complete desktop app in Rust using Tauri and Yew. A few people expressed interest in how I did this, so here is a tutorial to show how to get started.\n\nIf you're into Rust and want to build desktop apps, Tauri is a great choice. It's still very early days for web front-ends in Rust but Yew is already quite usable as you will see.\n\nFirst let's create a directory for our new project. We'll create a monorepo containing separate directories for the front-end and the back-end.\n\nIf you like, you can create a new github repository for it and add the git origin following the instructions here.\n\nAll of the code in this tutorial is available on my github if you want to just download it and follow along:\n\n https://github.com/stevepryde/tauri-yew-demo\n\nNext we'll create the front-end directory. We do this first because later the setup will ask where this directory is.\n\nSince this will be the part of the project, let's follow the setup instructions here: https://yew.rs/docs/getting-started/introduction\n\nNext create in the base of the directory:\n\nWe'll also create in the directory we created earlier:\n\nYou can now build your frontend app and view it in the browser! Let's test it out:\n\nNow open your browser and go to . You should see a blank page with a grey background.\n\nWe haven't yet added to the project, so let's do that now.\n\nTo install rust packages to your project, I highly recommend the tool, which you can install via .\n\nWith installed you can do:\n\nIf you prefer to add dependencies manually, just add the following lines to the section of :\n\nNow open and replace its contents with the following:\n\nNow you should be able to re-run and see the updated page in your browser. This is a real Rust front-end, compiled to WASM, running in your browser. Yes, it is that easy!\n\nFor this step you'll need to be back in the base directory. Hit if you're still running .\n\nIf you're still in the directory, go up one directory:\n\nTauri has its own CLI that we'll use to manage the app.\n\nThere are various installation options but since we're using Rust, we'll install it via .\n\nThe Tauri CLI installation instructions can be found here: https://tauri.studio/docs/getting-started/beginning-tutorial#alternatively-install-tauri-cli-as-a-cargo-subcommand\n\nThen run which will ask you some questions about the app:\n\nThis will create a directory, containing all of the back-end code for your app.\n\nYou can run to check all of the installation details.\n\nBefore we can run the app, we need to tell how to actually start the front-end server.\n\nEdit the file that is in the directory. This file contains all of the tauri config that tells tauri how to build your app. You will want to bookmark https://tauri.studio/en/docs/api/config/ because it contains a lot of very useful info about all of the options in this file. For now we will just update the build settings.\n\nReplace the section with the following:\n\nThis means we won't need to manually run in another tab while developing. We can develop in the front-end and back-end and both will hot-reload automatically when changes are made.\n\nOk, we're now ready to start the tauri dev server that you'll use while developing your app:\n\nAnd there's your desktop app, running with !\n\nTauri itself is written in Rust and your back-end application will be a Rust application that provides \"commands\" through in much the same way that a Rust web-server provides routes. You can even have managed state, for things like databases!\n\nOpen in the project and add the following below the function:\n\nYou will also need to modify the function slightly to tell about your new command:\n\nThat's all for the back-end.\n\nAccessing tauri commands from Rust in the front-end\n\nIn order to access tauri commands on the front-end in Rust/WASM we need to add some glue code in Javascript.\n\nThere is a npm package but since we want to keep any Javascript usage to a minimum and prefer to use and to manage our front-end, we will use a different approach.\n\nTauri also exports its functions via the object in Javascript.\n\nIn our project, create a new file called inside the directory.\n\nThat is all the Javascript we will add. I told you it would be minimal!\n\nNotice that the Javascript function is async. That is because the tauri command returns a Javascript promise. And through WASM, Javascript promises can be converted into Rust futures. Just let that awesomeness sink in for a while :)\n\nHow do we call that Javascript function from Rust? We add more glue code, this time in Rust. Add the following in your frontend's :\n\nHere we tell wasm_bindgen about our javascript code in . We give it the javascript function name, and the parameter tells wasm_bindgen that we want to add a handler to the javascript promise and turn it into a in Rust.\n\nThis new code won't work yet, because we haven't added to our front-end dependencies. Let's do that now. We'll also add which we'll use to call this later, which provides access to the browser object, and which gives us the types we referenced above.\n\nThis will add the following dependencies to in the front-end:\n\nWe also need to add some imports to the top of main.rs.\n\nSo now we've added the glue code in Javascript and the Rust code that calls that method. What we need to do is wire that up to the front-end code and actually use it.\n\nIn version 0.19 Yew added function components, which operate much like React hooks if you're familiar with the React framework in Javascript. If you're not familiar with that, I will attempt to give a brief explanation of the concepts used in this tutorial, but a fuller explanation of hooks is out of scope. The yew docs themselves go into some more detail.\n\nReplace the function component in your front-end with the following:\n\nAnd this should compile and run.\n\nNavigate up one directory (to the directory), and run:\n\nYou should see the application window showing .\n\nOk, that was a lot of code. Let's unpack it.\n\nFirst we add some state to the component through the hook.\n\nComponent state has an initial value, and a method for updating that value. Normally, updating a state value will cause the component to be re-rendered with the new value.\n\nThe hook gives us a state handle that will only cause the component to be re-rendered if the value has changed. It uses Rust's trait for this.\n\nYou can dereference a to get the underlying state value.\n\nWe need to clone the handle so that we can move it into the closure.\n\nThe hook is a variant of the hook where this one only runs the hook when some dependency changes.\n\nIt takes two arguments. The first is the closure we want to run when the dependency value changes, and the second is the dependency value itself.\n\nIn this example the dependency is specified as , which means we are dereferencing the handle to get the underlying and then cloning the because we cannot move it.\n\nThat value is then passed as the argument to the closure.\n\nThe hook is generally used to do some longer operation or some async operation where the component will update with the result of that operation. This is why we pass in the handle, because this allows the closure to set the value of that handle, which will cause the component to re-render, but only if the value has changed. Calls to tauri commands will generally go inside a or hook.\n\nThe return value of the closure is always another closure that will run when the component is unloaded from the virtual DOM. You can use this closure to perform any cleanup relating to this effect hook. In this case there is nothing to clean up so we return an empty closure.\n\nLet's look at the function.\n\nThe function is from and it allows us to run async functions in the current thread. In this case we need it in order to call our function, because it is async.\n\nNext we call the function, which returns . We know the will be a string since the original tauri command we implemented returned , so we can just unwrap() here.\n\nFinally if the result was then we set the new value of the state variable. Otherwise we display an alert.\n\nHopefully this tutorial has given you a taste for how to create a desktop app almost entirely in Rust, using for the back-end and for the front-end.\n\nYou can find all of the code for this tutorial on my github:\n\n https://github.com/stevepryde/tauri-yew-demo\n\nFeel free to use it and modify it as a base for your own projects.\n\nI highly recommend reading through the documentation for both Tauri and Yew.\n\nIf there's anything I missed or anything that is still unclear from this tutorial, please let me know in the comments and I'll aim to update it."
    },
    {
        "link": "https://tauri.app/v1/guides/getting-started/prerequisites",
        "document": "The first step is to install Rust and system dependencies. Keep in mind that this setup is only needed for developing Tauri apps. Your end-users are not required to do any of this.\n\nYou will need to install Microsoft Visual Studio C++ build tools. The easiest way is to install Build Tools for Visual Studio 2022. When asked which workloads to install, ensure \"C++ build tools\" and the Windows 10 SDK are selected.\n\nTauri heavily depends on WebView2 to render web content on Windows, therefore you must have WebView2 installed. The easiest way is to download and run the Evergreen Bootstrapper from Microsoft's website.\n\nThe bootstrapper script will try to determine the correct architecture and version for your system. Still, if you run into issues (especially with Windows on ARM) you can select the correct standalone installer.\n\nLastly, go to https://www.rust-lang.org/tools/install to install (the Rust installer). Note that you have to restart your terminal, and in some cases, Windows itself, for the changes to take effect.\n\nAlternatively, you could use to install rustup using the following command in PowerShell:\n\nYou will need to install CLang and macOS development dependencies. To do this, run the following command in your terminal:\n\nTo install Rust on macOS, open a terminal and enter the following command:\n\nThe command downloads a script and starts the installation of the tool, which installs the latest stable version of Rust. You might be prompted for your password. If the installation was successful, the following line will appear:\n\nMake sure to restart your terminal for the changes to take effect.\n\nYou will need to install a couple of system dependencies, such as a C compiler and . Below are commands for a few popular distributions:\n\nNote that for Fedora 36 and below, and all Enterprise Linux Distributions, you need to install instead of . For Enterprise Linux, you also need instead of . For example: Note: A desktop profile is recommended to set the appropriate USE flags for webkit-gtk Working on NixOS requires a slightly different setup, as Tauri needs to find the required system libraries both at compile time and dynamically at runtime. To make them available to Tauri the environment variable needs to be populated with the correct paths. When using Nix Flakes, copy the following code into on your repository, then run to activate the development environment. You can also use direnv's Flakes integration to automatically start the dev shell when entering the project folder. If you don't use Nix Flakes, the Nix Shell can be configured using the following script. Run to activate the development environment, or use direnv's Shell integration to automatically start the dev shell when entering the project folder. To create Tauri development environments using Guix shell, copy the following code into on your repository, then run to activate. You can also use direnv's Guix shell support to automatically start the Guix shell when entering the project folder.\n\nTo install Rust on Linux, open a terminal and enter the following command:\n\nThe command downloads a script and starts the installation of the tool, which installs the latest stable version of Rust. You might be prompted for your password. If the installation was successful, the following line will appear:\n\nMake sure to restart your Terminal for the changes to take effect.\n\nYou should keep your Rust version up to date whenever possible to always benefit from the latest improvements. To update Rust, open a terminal and run the following command:\n\ncan also be used to uninstall Rust from your machine fully:\n\nTo check whether you have Rust installed correctly, open a shell and enter this command:\n\nYou should see the version number, commit hash, and commit date for the latest stable version that has been released in the following format:\n\nIf you don't see this information, your Rust installation might be broken. Please consult Rust's Troubleshooting Section on how to fix this. If your problems persist, you can get help from the official Tauri Discord and GitHub Discussions.\n• None Go to Node.js website, download the Long Term Support (LTS) version and install it.\n• None Check if Node was succesfully installed by running:\n\nIt's important to restart your Terminal to ensure it recognizes the new installation. In some cases, you might need to restart your computer.\n\nWhile npm is the default package manager for Node.js, you can also use others like pnpm or yarn. To enable these, run in your Terminal. This step is optional and only needed if you prefer using a package manager other than npm."
    },
    {
        "link": "https://github.com/ash-rs/ash",
        "document": "\n• No validation, everything is unsafe\n• Lifetime-safety on structs created with the builder pattern\n\nThe Vulkan Video bindings are experimental and still seeing breaking changes in their upstream specification, and are only provided by Ash for early adopters. All related functions and types are semver-exempt 1 (we allow breaking API changes while releasing Ash with non-breaking semver bumps).\n\nNote: Functions don't return if this would limit the functionality. See .\n\nEach Vulkan handle type is exposed as a newtyped struct for improved type safety. Null handles can be constructed with , and handles may be freely converted to and from with and for interop with non-Ash Vulkan code.\n\nUse to insert at the front of the pointer chain attached to . If already contains a valid pointer chain of its own, ly call instead.\n\nThe generic argument of only allows valid structs to extend a given struct (known as in the Vulkan registry, mapped to traits). Only structs that are listed one or more times in any will implement a .\n\nAsh also takes care of loading the function pointers. Function pointers are split into 3 categories.\n• Entry: Loads the Vulkan library. Needs to outlive and .\n• Instance: Loads instance level functions. Needs to outlive the s it has created.\n\nThe loader is just one possible implementation:\n• Device level functions are retrieved on a per device basis.\n• Everything is loaded by default, functions that failed to load are initialized to a function that always panics.\n• Do not call Vulkan 1.1 functions if you have created a 1.0 instance. Doing so will result in a panic.\n\nAdditionally, every Vulkan extension has to be loaded explicitly. You can find all extensions directly under in a module with their prefix (e.g. or ).\n\nRaw function pointers are available, if something hasn't been exposed yet in the higher level API. Please open an issue if anything is missing.\n\nHandles from Instance or Device are passed implicitly.\n\nThe default cargo feature will dynamically load the default Vulkan library for the current platform with , meaning that the build environment does not have to have Vulkan development packages installed.\n\nIf, on the other hand, your application cannot handle Vulkan being missing at runtime, you can instead enable the feature, which will link your binary with the Vulkan loader directly and expose the infallible .\n\nAsh can be used in environments (with ) by disabling the feature.\n\nYou can find the examples here. All examples currently require: the LunarG Validation layers and a Vulkan library that is visible in your . An easy way to get started is to use the LunarG Vulkan SDK\n\nMake sure that you have a Vulkan ready driver and install the LunarG Vulkan SDK.\n\nInstall a Vulkan driver for your graphics hardware of choice, and (optionally) the Validation Layers via your package manager:\n• Ubuntu/Debian: Besides installing a compatible graphics driver, install (Debian) for the Validation Layers.\n• Other distros: consult your distro documentation and/or package repository for the preferred method to install and use Vulkan.\n\nInstall the LunarG Vulkan SDK. The installer puts the SDK in by default. You will need to set the following environment variables when running cargo:\n• vk-mem-rs - This crate provides an FFI layer and idiomatic rust wrappers for the excellent AMD Vulkan Memory Allocator (VMA) C/C++ library.\n• gpu-allocator - GPU Memory allocator written in pure Rust for Vulkan and DirectX 12."
    },
    {
        "link": "https://reddit.com/r/rust/comments/1h1jj8d/learning_vulkan_and_rust",
        "document": "There probably have been similar questions asked before, but is it good idea to learn Vulkan with Rust and if so how to do it. What crates to use, what tutorial and videos to watch, is it better to just use C++?\n\nI am a decent C++ programmer and have worked with sdl2 and similar before, I have a position in the industry as a C++ dev but I want to learn Rust 'cuz I like everything it brings to the table and while I am learning the language I would like to conquer some of my goals I've never had to (computer graphics).\n\nSo once again is there a reason to learn vulkan + rust or should I learn Rust with something else and learn vulkan with C++.\n\nThank you for your time :D."
    },
    {
        "link": "https://crates.io/crates/ash",
        "document": ""
    },
    {
        "link": "https://kylemayes.github.io/vulkanalia",
        "document": "This tutorial is an adaptation of https://vulkan-tutorial.com to use Rust instead of C++. The majority of the credit for this tutorial should go the author of the original tutorial (Alexander Overvoorde) and the other contributors.\n\nThis tutorial also includes several additional chapters that are original creations of the author of this adapted tutorial (starting with the chapter). These chapters introduce important Vulkan concepts and features that will be useful in almost any Vulkan application. However, as noted in the disclaimer for those chapters, they should be considered experimental.\n\nThis tutorial will teach you the basics of using the Vulkan graphics and compute API. Vulkan is a new API by the Khronos group (known for OpenGL) that provides a much better abstraction of modern graphics cards. This new interface allows you to better describe what your application intends to do, which can lead to better performance and less surprising driver behavior compared to existing APIs like OpenGL and Direct3D. The ideas behind Vulkan are similar to those of Direct3D 12 and Metal, but Vulkan has the advantage of being cross-platform and allows you to develop for Windows, Linux and Android at the same time (and iOS and macOS via MoltenVK).\n\nHowever, the price you pay for these benefits is that you have to work with a significantly more verbose API. Every detail related to the graphics API needs to be set up from scratch by your application, including initial frame buffer creation and memory management for objects like buffers and texture images. The graphics driver will do a lot less hand holding, which means that you will have to do more work in your application to ensure correct behavior.\n\nThe takeaway message here is that Vulkan is not for everyone. It is targeted at programmers who are enthusiastic about high performance computer graphics, and are willing to put some work in. If you are more interested in game development, rather than computer graphics, then you may wish to stick to OpenGL or Direct3D, which will not be deprecated in favor of Vulkan anytime soon. Another alternative is to use an engine like Unreal Engine or Unity, which will be able to use Vulkan while exposing a much higher level API to you.\n\nWith that out of the way, let's cover some prerequisites for following this tutorial:\n\nThis tutorial will not assume knowledge of OpenGL or Direct3D concepts, but it does require you to know the basics of 3D computer graphics. It will not explain the math behind perspective projection, for example. See this online book for a great introduction of computer graphics concepts. Some other great computer graphics resources are:\n• Vulkan being used in a real engine in the open-source Quake and DOOM 3\n\nIf you want a C++ tutorial instead, see the original tutorial:\n\n https://vulkan-tutorial.com\n\nThis tutorial uses the crate to provide access to the Vulkan API from Rust. provides raw bindings to the Vulkan API as well as a thin wrapper over said bindings to make them easier and more idiomatic to use from Rust (more on this in the next chapter). This means that while you should never have any difficulty in determining exactly how your Rust programs are interacting with the Vulkan API, you will be shielded from little of the danger and verbosity of the Vulkan API.\n\nIf you want a Rust Vulkan tutorial that uses a crate which provides a safe and relatively concise wrapper around the Vulkan API ( ), see this tutorial:\n\n https://github.com/bwasty/vulkan-tutorial-rs\n\nWe'll start with an overview of how Vulkan works and the work we'll have to do to get the first triangle on the screen. The purpose of all the smaller steps will make more sense after you've understood their basic role in the whole picture. Next, we'll set up the development environment with the Vulkan SDK.\n\nAfter that we'll implement all of the basic components of a Vulkan program that are necessary to render your first triangle. Each chapter will follow roughly the following structure:\n• Introduce a new concept and its purpose\n• Use all of the relevant API calls to integrate it into your program\n• Abstract parts of it into helper functions\n\nAlthough each chapter is written as a follow-up on the previous one, it is also possible to read the chapters as standalone articles introducing a certain Vulkan feature. That means that the site is also useful as a reference. All of the Vulkan functions and types are linked to the either the Vulkan specification or to the documentation, so you can click them to learn more. Vulkan is still a fairly young API, so there may be some shortcomings in the specification itself. You are encouraged to submit feedback to this Khronos repository.\n\nAs mentioned before, the Vulkan API has a rather verbose API with many parameters to give you maximum control over the graphics hardware. This causes basic operations like creating a texture to take a lot of steps that have to be repeated every time. Therefore we'll be creating our own collection of helper functions throughout the tutorial.\n\nEvery chapter will also start with a link to the final code for that chapter. You can refer to it if you have any doubts about the structure of the code, or if you're dealing with a bug and want to compare.\n\nThis tutorial is intended to be a community effort. Vulkan is still a fairly new API and best practices haven't been fully established. If you have any type of feedback on the tutorial and site itself, then please don't hesitate to submit an issue or pull request to the GitHub repository.\n\nAfter you've gone through the ritual of drawing your very first Vulkan powered triangle onscreen, we'll start expanding the program to include linear transformations, textures and 3D models.\n\nIf you've played with graphics APIs before, then you'll know that there can be a lot of steps until the first geometry shows up on the screen. There are many of these initial steps in Vulkan, but you'll see that each of the individual steps is easy to understand and does not feel redundant. It's also important to keep in mind that once you have that boring looking triangle, drawing fully textured 3D models does not take that much extra work, and each step beyond that point is much more rewarding.\n\nIf you encounter any problems while following the tutorial, check the FAQ to see if your problem and its solution is already listed there. Next, you might find someone who had the same problem (if it is not Rust-specific) in the comment section for the corresponding chapter in the original tutorial."
    },
    {
        "link": "https://github.com/vulkano-rs/vulkano",
        "document": "Vulkano is a Rust wrapper around the Vulkan graphics API. It follows the Rust philosophy, which is that as long as you don't use unsafe code you shouldn't be able to trigger any undefined behavior. In the case of Vulkan, this means that non-unsafe code should always conform to valid API usage.\n\nWhat does vulkano do?\n• Provides a low-levelish API around Vulkan. It doesn't hide what it does but provides some comfort types.\n• Plans to prevent all invalid API usages, even the most obscure ones. The purpose of Vulkano is not to simply let you draw a teapot, but to cover all possible usages of Vulkan and detect all the possible problems in order to write robust programs. Invalid API usage is prevented thanks to both compile-time checks and runtime checks.\n• Can handle synchronization on the GPU side for you (unless you choose to do that yourself), as this aspect of Vulkan is both annoying to handle and error-prone. Dependencies between submissions are automatically detected, and semaphores are managed automatically. The behavior of the library can be customized thanks to unsafe trait implementations.\n• Tries to be convenient to use. Nobody is going to use a library that requires you to browse the documentation for hours for every single operation.\n\nComparison to other well-known Graphics APIs in Rust ecosystem.\n\nPlease note that by the current date none of the known projects in the ecosystem(including Vulkano) reached stable release versions and the final design goals, their APIs are changing from time to time in a breakable way too, and there could be bugs and unfinished features too.\n\nHowever, most of the projects mentioned above are already established definitive structures, all feature breaking changes will likely be straightforward to fix in user code, and most of them are maintained. As such we can recommend using any of them in the 3rd party code. The choice depends on the end project's goals and requirements, and we recommend examining their actual set of features and API capabilities beforehand.\n\nTo get started you are encouraged to use the following resources:\n• The examples folder in this repository.\n• The guide on vulkano.rs - Starts with trivial compute examples (~50 lines of code) and then works up to rendering triangles and mandelbrots. The guide is currently outdated a little. We are planning to update it in the future, but it's a good place to start understanding the base building blocks of Vulkano API.\n• GitHub Issues - Raise a topic, ask a question or report a bug. The new topics there are watched regularly by maintainers and other community users.\n• Gitter Chat - Another place to raise a question. However, the chat is not maintained regularly at this moment. Better use GitHub Issues for this purpose.\n\nContributions are very welcome! Feel free to submit pull requests, to open questions and topics in the Issues section.\n\nThe project was initially developed by Pierre Krieger(Tomaka), who established Vulkano's base design goals, and the code structure. In the meantime, development is driven by Vulkano community members.\n\nIf your change adds, removes or modifies a trait or a function, please specify changelog entries in the Pull Request description(not in the changelog file directly). They will be transferred to the changelog right after the PR merge.\n\nEvery PR must pass tests in order to be merged to .\n\nMinor releases are usually happening between 1 to 3 months averagely depending on grow of unreleased and breaking changes in\n\nThis repository contains four libraries:\n• is the main one.\n• provides the macro for compiling glsl shaders.\n• allows building a dependency graph of tasks, which are automatically synchronized and are then executed on the Vulkan device.\n• provides a variety of utility functions to streamline certain common operations such as device and swapchain creation. a window to render to.\n\nIn order to run tests, run at the root of the repository. Make sure your Vulkan driver is up to date before doing so.\n\nWe would love to mention some members, who put significant contributions to this project:\n• Rua. An active developer, who put a lot of effort to improve Vulkano and constantly keeping it up to date.\n• You! Thanks to your help, contributions, improvements, bug reports and user experience to make this project one of the major Rust graphics API library in Rust!\n\nVulkano uses shaderc-rs for shader compilation. Refer to shaderc-rs documentation to provide a pre-built libshaderc for faster build times.\n\nNote that in general vulkano does not require you to install the official Vulkan SDK. This is not something specific to vulkano (you don't need the SDK to write programs that use Vulkan, even without vulkano), but many people are unaware of that and install the SDK thinking that it is required. However, macOS, iOS and tvOS platforms do require a little more Vulkan setup since it is not natively supported. See below for more details.\n\nUnless you provide libshaderc, in order to build libshaderc with the shaderc-sys crate, the following tools must be installed and available on :\n• Ninja Is optional except when building with MSVC. It may speed up build time for libshaderc.\n• Python (works with both Python 2.x and 3.x, on windows the executable must be named )\n\nThese requirements can be either installed with your favourite package manager or with installers from the projects' websites. Below are some examples of ways to set up.\n• Install Build Tools for Visual Studio 2017. If you have already been using this toolchain then its probably already installed.\n• Install msys2, following ALL of the instructions.\n• Then in the msys2 terminal run:\n• Add the msys2 mingw64 binary path to the PATH environment variable.\n\nwindows-gnu toolchain is not supported but you can instead cross-compile to windows-gnu from windows-msvc\n\nSteps 1 and 2 are to workaround rust-lang/rust#49078 by using the same mingw that rust uses.\n• Add the absolute path to mingw64\\bin to your PATH environment variable. (This path needs to be before the msys2 path)\n• Install Build Tools for Visual Studio 2017. If you have already been using this toolchain then it's probably already installed.\n• Install msys2, following ALL of the instructions.\n• Then in the msys2 terminal run:\n• Add the msys2 mingw64 binary path to the PATH environment variable.\n• Any cargo command that builds the project needs to include e.g. to run:\n\nUse your package manager to install the required dev-tools and Vulkan drivers\n\nFor example on ubuntu:\n\nVulkan is not natively supported by macOS, iOS and tvOS. However, there exists MoltenVK an open-source Vulkan implementation on top of Apple's Metal API. This allows vulkano to build and run on macOS, iOS and tvOS platforms.\n\nThe easiest way to get vulkano up and running with MoltenVK is to install the Vulkan SDK for macOS. There are installation instructions on the LunarG website.\n\nOn iOS and tvOS, vulkano links directly to the MoltenVK framework. There is nothing else to do besides installing it. Note that the Vulkan SDK for macOS also comes with the framework for iOS and tvOS.\n\nLicensed under either of\n\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be dual licensed as above, without any additional terms or conditions."
    },
    {
        "link": "https://docs.rs/steamworks",
        "document": ""
    },
    {
        "link": "https://github.com/Noxime/steamworks-rs",
        "document": "This crate provides Rust bindings to the Steamworks SDK.\n\nAdd the following to your :\n\nYou can find more examples in examples.\n\n: This feature enables serialization and deserialization of some types with .\n\nThis crate is dual-licensed under Apache and MIT.\n\nIf you are seeing errors like , etc. You are likely missing the Steamworks SDK Redistributable files. Steamworks-rs loads the SDK dynamically, so the libraries need to exist somewhere the operating system can find them. This is likely next to your game binary (.exe on windows). You can find the required files in the SDK release ZIP, under . See #63 for further details"
    },
    {
        "link": "https://partner.steamgames.com/doc/sdk/api",
        "document": "\n• If you haven't already, download the Steamworks SDK and unzip it.\n• Copy the Steamworks API headers folder into an appropriate place in your applications source tree.\n• Copy the relevant redistributable files from into an appropriate place in your project folder.\n• Windows\n\n You must have linking in your visual studio project. This can be linked to either the primary executable or a module that uses Steam. This allows you to access the functionality contained in which is exposed via the Steamworks API headers. Additional Reading: Linking an Executable to a DLL (MSDN)\n\n\n\n You must also ship the in your run-time directory (next to your programs executable, or in your dll search path).\n• macOS\n\n provides both the x86 and x64 version of the Steam API. You must link to this in your Xcode project and you must ship this along side your executable.\n\n Additional Reading: Using Dynamic Libraries\n• Linux\n\n You must both link to and ship this along side your executable.\n• The Steam client isn't running. A running Steam client is required to provide implementations of the various Steamworks interfaces.\n• The Steam client couldn't determine the App ID of game. If you're running your application from the executable or debugger directly then you must have a in your game directory next to the executable, with your app ID in it and nothing else. Steam will look for this file in the current working directory. If you are running your executable from a different directory you may need to relocate the file.\n• Your application is not running under the same OS user context as the Steam client, such as a different user or administration access level.\n• Ensure that you own a license for the App ID on the currently active Steam account. Your game must show up in your Steam library.\n• Your App ID is not completely set up, i.e. in , or it's missing default packages.\n\n// Get the current users Steam name. const char *name = SteamFriends()->GetPersonaName();\n• must be the name of the struct or class where you are defining this. (eg. )\n• will be the name of the function that receives this callback. (eg. )\n• is the name of the callback. (eg. )\n\nclass CGameManager { private: STEAM_CALLBACK( CGameManager, OnGameOverlayActivated, GameOverlayActivated_t ); }; void CGameManager::OnGameOverlayActivated( GameOverlayActivated_t* pCallback ) { if ( pCallback->m_bActive ) printf( \"Steam overlay now active\n\n\" ); else printf( \"Steam overlay now inactive\n\n\" ); }\n• must be the name of the struct or class where you are defining this. (eg. )\n• is the name of the callback. (eg. )\n\n// In your class definition class CGameManager { public: void GetNumberOfCurrentPlayers(); private: void OnGetNumberOfCurrentPlayers( NumberOfCurrentPlayers_t *pCallback, bool bIOFailure ); CCallResult< CGameManager, NumberOfCurrentPlayers_t > m_NumberOfCurrentPlayersCallResult; }; // Make the asynchronous request to receive the number of current players. void CGameManager::GetNumberOfCurrentPlayers() { printf( \"Getting Number of Current Players\n\n\" ); SteamAPICall_t hSteamAPICall = SteamUserStats()->GetNumberOfCurrentPlayers(); m_NumberOfCurrentPlayersCallResult.Set( hSteamAPICall, this, &CGameManager::OnGetNumberOfCurrentPlayers ); } // Called when SteamUserStats()->GetNumberOfCurrentPlayers() returns asynchronously, after a call to SteamAPI_RunCallbacks(). void CGameManager::OnGetNumberOfCurrentPlayers( NumberOfCurrentPlayers_t *pCallback, bool bIOFailure ) { if ( bIOFailure || !pCallback->m_bSuccess ) { printf( \"NumberOfCurrentPlayers_t failed!\n\n\" ); return; } printf( \"Number of players currently playing: %d\n\n\", pCallback->m_cPlayers ); }\n• ISteamClient which you can access via the global interface:\n• ISteamUtils which you can access via the global interface:\n• ISteamNetworking which you can access via the global interface:\n• ISteamHTTP which you can access via the global interface:\n• ISteamUGC which you can access via the global interface:\n• ISteamApps which you can access via the global interface:\n\nFlat interface for binding to other languages\n• declares a set of \"flat\" functions that mirror the interface functions in the SDK. This is not pure C code, but it does use plain C linkage and calling conventions, so it is easy to interop with other languages. These functions are exported by .\n• describes (almost all of) the interfaces, types, and functions in the SDK. It is intended that this file be used by an automated process to generate binding layer. We hope that this can be used to automate 95% of the work, but there are still a few special cases that need to be handled manually. In particular, CSteamID and CGameID will probably require special handling by your binding layer to make it efficient.\n\nThe Steamworks API allows your game to take full advantage of Steam by accessing all of the underlying systems provided through the API. This includes things such as pausing your game when the user opens the Steam Overlay , inviting friends to play, allowing players to unlock Steam Achievements , letting players compete on the Steam Leaderboards and much more.The Steamworks API Reference catalogs and documents every interface, function, callback, and type supported in the API.Integration with the Steamworks API is never required to ship your product on Steam, but it is highly recommended as it allows you to accomplish many interactions that Steam users expect.The Steamworks API officially supports C++, using Microsoft Visual Studio 2008+ on Microsoft Windows, GCC 4.6+ and Clang 3.0+ on macOS and SteamOS / Linux. If you're using a third party engine or a programming language other than C++ then you should first look at Commercial engine and non-C++ language support to see if there are more specific instructions to get started with your engine or language of choice. In some cases you may be able to skip many of these steps.After you have the Steamworks API set up within your project you can start using it by calling SteamAPI_Init function to initialize the API. This will set up the global state and populate the interface pointers which are accessible via the global functions which match the name of the interface. Thisbe called and return successfully prior to accessing any of the Steamworks Interfaces The Steamworks API will not initialize if it does not know the App ID of your game. When you launch your app from Steam itself then it will automatically have the App ID available. While developing you will need to hint this to Steam with a text file. Create the a text file callednext to your executable containing just the App ID and nothing else. This overrides the value that Steam provides. You should not ship this with your builds. Example:A return ofindicates one of the following conditions:If you're running into initialization issues then see the Debugging the Steamworks API documentation to learn about the various methods of debugging the Steamworks API. SteamAPI_RestartAppIfNecessary checks if your executable was launched through Steam and relaunches it through Steam if it wasn't.This is optional but highly recommended as the Steam context associated with your application (including your App ID) will not be set up if the user launches the executable directly. If this occurs thenwill fail and you will be unable to use the Steamworks API.If you choose to use this then it should be the first Steamworks function call you make, right before SteamAPI_Init If this returnsthen it starts the Steam client if required and launches your game again through it, and you should quit your process as soon as possible. This effectively runsso it may not relaunch the exact executable that called this function (for example, if you were running from your debugger). It will always relaunch from the version installed in your Steam library folder.Otherwise, if it returns, then your game was launched by the Steam client and no action needs to be taken. One exception is if afile is present then this will returnregardless. This allows you to develop and test without launching your game through the Steam client. Make sure to remove thefile when uploading the game to your Steam depot!If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary as the DRM wrapper will perform this internally.When you are done using the Steamworks API you should call SteamAPI_Shutdown to release the resources used by your application internally within Steam. You should call this during process shutdown if possible.This will not unhook the Steam Overlay from your game as there's no guarantee that your rendering API is done using it.The Steamworks API is composed of multiple interfaces which all expose a limited, specific amount of functionality.After Steamworks has successfully initialized you can then access the interfaces via their global functions. The functions always match the name of their interface. As such you can access ISteamApps through theaccessor and ISteamFriends throughYou can use these interfaces to make calls like so:You can view the complete list of interfaces on the Steamworks API Reference or by diving into the Steamworks API header files.Callbacks are one of the most important aspect of Steamworks, they allow you to retrieve data asynchronously from Steam without locking up your game. The goal of the callbacks are to provide a simple, light-weight, type-safe, thread-safe method of raising asynchronous events to any object registered as a listener.Callbacks are usually triggered via an event that happens from Steam such as when ever a friend logs on or off, or the asynchronous result of some API functions. Each callback consists of a struct containing a unique identifier and a small set of data. The callbacks are declared in theheader files, grouped with the interface that it most closely belongs to.To listen for a callback, a struct or class must use the macroin it's declaration.This defines a local member function for that class which is automatically prototyped as. Creating a new instance of the object will cause this member function to register itself as a listener with the Steamworks API; destruction of the object will cause it to de-register.You should ensure that Steam has been initialized before creating objects that listen for callbacks.For callbacks to dispatch to registered listeners you must call the SteamAPI_RunCallbacks . It's best to call this frequently, as the more time between calls, the more latency between receiving events or results from the Steamworks API. Most games call this once per render-frame, it's highly recommended that you call this at least once a second. All registered listener functions will be invoked during this call, in the thread context wherewas called from.One callback that you will likely wish to use is ISteamFriends::GameOverlayActivated_t . As the name implies it sends you a callback every time the user activates or deactivates the Steam Overlay One popular and recommended use case for the ISteamFriends::GameOverlayActivated_t callback is to pause the game when the overlay opens.Many Steamworks methods use call results instead of a callback to asynchronously return results from a function call. The difference between a callback and call results is that callbacks are broadcast to all listeners, where-as call results only target a specific listener. Like callbacks, your game will need to call SteamAPI_RunCallbacks to dispatch call results to their listener.You can identify a function that provides a call result by inspecting it's return value; if it returns a SteamAPICall_t and has aattribute then you must register to receive the call result. Note that a callback registered to a CCallResult will only be triggered for the most recent SteamAPICall_t set on it, so be aware if you are re-using one.Callbacks and call results are not interchangeable. An event will only come through one or the other, not both. You must make sure that you are registering for the right type of event!Call results must be created as a member in a struct/class using the CCallResult type and you will also need to create the member function that will receive the callback.Feel free to name the function, function parameters, and CCallResult type anything you want.Here's an example of how to use the ISteamUserStats::GetNumberOfCurrentPlayers API which produces a ISteamUserStats::NumberOfCurrentPlayers_t call result.If you can't use the CCallResult system, then you may be able to use ISteamUtils::IsAPICallCompleted ISteamUtils::GetAPICallResult and ISteamUtils::GetAPICallFailureReason to track the status of a call result.The classes and macros used to register callbacks are convenient in C++ code. But there is also a lower-level mechanism for dealing with callbacks. This mechanism operates more like a Windows event loop. Instead of a single function that dispatches all of the callbacks and call results to active listeners, you fetch the next available callback in a loop, and dispatch it using whatever mechanisms you want. The manual dispatch mode is especially useful for binding layers that expose the Steamworks SDK to languages other than C++. Seeinfor more information.The Steamworks API includes support for running game servers as well as regular clients. A game server, in Steamworks API terms, is an entity in the system that normal users connect to to play multi-player games. This can be connecting over the Internet to a remote game server, or connecting locally to a game server that's in the same process as the client. Game servers have their own set of API functions to use, and their own unique Steam ID for other users to refer to them by.To use the Steam Game Server API you must first includeinstead ofInitializing and using the game server API is very similar to the normal API:After initializing a game server you have access to the two game server exclusive interfaces ISteamGameServer and ISteamGameServerStats You can also access the following regular interfaces from the game server:If you're running a dedicated game server (one which has no client component), you only have to initialize the game server API's, you don't have to initialize the normal user API.See Steamworks API Example Application (SpaceWar) for a fully loaded example of using the game server API.Unlike a game, a dedicated server will usually be run in an environment where there is no Steam Client installed to provide the latest steamworks binaries. In order for the dedicated server to have the latest steam binaries, you will need to include the Dedicated Server Redistributables with your app. Log into partner.steamgames.com and navigate to the technical settings for your app. Then look under \"Installation / Redistributables\" and check \"Dedicated Server Redistributables\"If you're using a commercial game engine or a language other than C or C++ you will want to see what level of support for the Steamworks API is provided for it.In some engines they provide native built-in support, for others you may need a third-party solution.If your engine does not have native support you can use the Steam Web API to access many features that Steam supports.Regardless of how the Steamworks SDK is implemented in your engine you will need to have the latest Steamworks SDK to upload your application to Steam If some of the software you are shipping on steam is available under a restrictive open source license then please see Distributing Open Source Applications on Steam Here are some common engines that people routinely use to ship games on Steam and the relevant documentation on how to get started using the Steamworks SDK with them.Valve does not in any way endorse any of these engines or the third-party solutions. This list is sorted exclusively by name, and is in no way comprehensive, it exists solely as a starting guide. Engines will only be listed if they include native support or have a third-party solution that fits the guidelines. Third-party solutions will only be listed if they are kept reasonably up to date with the Steamworks SDK, are freely available under a permissive license (See: Distributing Open Source Applications on Steam ), and have a thread on the Steamworks Discussion Board . We recommend that you consult the community to see which option would work best for your specific setup.The SDK has a few features to facilitate the creation of binding layers for other languages.Steam uses a variety of techniques to expose functionality to your application. It's by no means critical to understand exactly how the Steamworks API works but it's fairly simple and can be useful in planning out how to code your game with Steam integration in mind.When you link toit provides access to a small number of C functions which are prefixed with themacro, these functions are all exposed inand. Themodule itself is very small, it only exposes the base functionality to initialize and shutdown the Steamworks API.When the Steamworks API initializes it finds the actively running steam client process and loadsfrom that path.is essentially the core engine of the Steam client. It contains and maintains the information necessary to run Steam. The Steam client UI uses a similar set of functions as exposed here to access the data provided by. Since this data is in the Steam process, all Steam API calls are transparently marshaled and sent via an RPC/IPC mechanism. (A cross-process pipe, ISteamClient::HSteamPipe ).The Steam process, viamaintains a constant connection to the Steam back-end servers. Through this connection all authentication, matchmaking, friends list and VAC communication occurs. This connection may drop if the user has a network issue, or if the Steam server they are connected to receives an update. Callbacks will be posted to any running app if the connection drops or re-establishes. The Steam client will automatically try to reconnect, and clients running an app receive priority, so the typical reconnect time is under 10 seconds, although in some rare cases may be up to 5 minutes.The Steamworks API is versioned through a COM-like mechanism, where a string name and version of an interface are passed intowhich then returns the correct version of the interface to the caller.contains a set of adapters for all released versions of an interface which redirect or re-interpret the old calls in the context of the latest interface. The adapters live inside the steam client so that they are easy to update if any issues arise."
    },
    {
        "link": "https://docs.rs/bevy-steamworks",
        "document": "This crate provides a Bevy plugin for integrating with the Steamworks SDK.\n\nThe underlying steamworks crate comes bundled with the redistributable dynamic libraries a compatible version of the SDK. Currently it’s v153a.\n\nTo add the plugin to your app, simply add the to your . This will require the provided to you by Valve for initialization.\n\nThe plugin adds as a Bevy ECS resource, which can be accessed like any other resource in Bevy. The client implements and and can be used to make requests via the SDK from any of Bevy’s threads.\n\nThe plugin will automatically call on the Bevy every tick in the schedule, so there is no need to run it manually.\n\nAll callbacks are forwarded as and can be listened to in the a Bevy idiomatic way:"
    },
    {
        "link": "https://partner.steamgames.com/doc/sdk/api?l=swedish&language=english",
        "document": "\n• Copy the relevant redistributable files from into an appropriate place in your project folder.\n• Windows\n\n You must have linking in your visual studio project. This can be linked to either the primary executable or a module that uses Steam. This allows you to access the functionality contained in which is exposed via the Steamworks API headers. Additional Reading: Linking an Executable to a DLL (MSDN)\n\n\n\n You must also ship the in your run-time directory (next to your programs executable, or in your dll search path).\n• The Steam client couldn't determine the App ID of game. If you're running your application from the executable or debugger directly then you must have a in your game directory next to the executable, with your app ID in it and nothing else. Steam will look for this file in the current working directory. If you are running your executable from a different directory you may need to relocate the file.\n• declares a set of \"flat\" functions that mirror the interface functions in the SDK. This is not pure C code, but it does use plain C linkage and calling conventions, so it is easy to interop with other languages. These functions are exported by .\n• describes (almost all of) the interfaces, types, and functions in the SDK. It is intended that this file be used by an automated process to generate binding layer. We hope that this can be used to automate 95% of the work, but there are still a few special cases that need to be handled manually. In particular, CSteamID and CGameID will probably require special handling by your binding layer to make it efficient.\n\nThe Steamworks API allows your game to take full advantage of Steam by accessing all of the underlying systems provided through the API. This includes things such as pausing your game when the user opens the Steam Overlay , inviting friends to play, allowing players to unlock Steam Achievements , letting players compete on the Steam Leaderboards and much more.The Steamworks API Reference catalogs and documents every interface, function, callback, and type supported in the API.Integration with the Steamworks API is never required to ship your product on Steam, but it is highly recommended as it allows you to accomplish many interactions that Steam users expect.The Steamworks API officially supports C++, using Microsoft Visual Studio 2008+ on Microsoft Windows, GCC 4.6+ and Clang 3.0+ on macOS and SteamOS / Linux. If you're using a third party engine or a programming language other than C++ then you should first look at Commercial engine and non-C++ language support to see if there are more specific instructions to get started with your engine or language of choice. In some cases you may be able to skip many of these steps.After you have the Steamworks API set up within your project you can start using it by calling SteamAPI_Init function to initialize the API. This will set up the global state and populate the interface pointers which are accessible via the global functions which match the name of the interface. Thisbe called and return successfully prior to accessing any of the Steamworks Interfaces The Steamworks API will not initialize if it does not know the App ID of your game. When you launch your app from Steam itself then it will automatically have the App ID available. While developing you will need to hint this to Steam with a text file. Create the a text file callednext to your executable containing just the App ID and nothing else. This overrides the value that Steam provides. You should not ship this with your builds. Example:A return ofindicates one of the following conditions:If you're running into initialization issues then see the Debugging the Steamworks API documentation to learn about the various methods of debugging the Steamworks API. SteamAPI_RestartAppIfNecessary checks if your executable was launched through Steam and relaunches it through Steam if it wasn't.This is optional but highly recommended as the Steam context associated with your application (including your App ID) will not be set up if the user launches the executable directly. If this occurs thenwill fail and you will be unable to use the Steamworks API.If you choose to use this then it should be the first Steamworks function call you make, right before SteamAPI_Init If this returnsthen it starts the Steam client if required and launches your game again through it, and you should quit your process as soon as possible. This effectively runsso it may not relaunch the exact executable that called this function (for example, if you were running from your debugger). It will always relaunch from the version installed in your Steam library folder.Otherwise, if it returns, then your game was launched by the Steam client and no action needs to be taken. One exception is if afile is present then this will returnregardless. This allows you to develop and test without launching your game through the Steam client. Make sure to remove thefile when uploading the game to your Steam depot!If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary as the DRM wrapper will perform this internally.When you are done using the Steamworks API you should call SteamAPI_Shutdown to release the resources used by your application internally within Steam. You should call this during process shutdown if possible.This will not unhook the Steam Overlay from your game as there's no guarantee that your rendering API is done using it.The Steamworks API is composed of multiple interfaces which all expose a limited, specific amount of functionality.After Steamworks has successfully initialized you can then access the interfaces via their global functions. The functions always match the name of their interface. As such you can access ISteamApps through theaccessor and ISteamFriends throughYou can use these interfaces to make calls like so:You can view the complete list of interfaces on the Steamworks API Reference or by diving into the Steamworks API header files.Callbacks are one of the most important aspect of Steamworks, they allow you to retrieve data asynchronously from Steam without locking up your game. The goal of the callbacks are to provide a simple, light-weight, type-safe, thread-safe method of raising asynchronous events to any object registered as a listener.Callbacks are usually triggered via an event that happens from Steam such as when ever a friend logs on or off, or the asynchronous result of some API functions. Each callback consists of a struct containing a unique identifier and a small set of data. The callbacks are declared in theheader files, grouped with the interface that it most closely belongs to.To listen for a callback, a struct or class must use the macroin it's declaration.This defines a local member function for that class which is automatically prototyped as. Creating a new instance of the object will cause this member function to register itself as a listener with the Steamworks API; destruction of the object will cause it to de-register.You should ensure that Steam has been initialized before creating objects that listen for callbacks.For callbacks to dispatch to registered listeners you must call the SteamAPI_RunCallbacks . It's best to call this frequently, as the more time between calls, the more latency between receiving events or results from the Steamworks API. Most games call this once per render-frame, it's highly recommended that you call this at least once a second. All registered listener functions will be invoked during this call, in the thread context wherewas called from.One callback that you will likely wish to use is ISteamFriends::GameOverlayActivated_t . As the name implies it sends you a callback every time the user activates or deactivates the Steam Overlay One popular and recommended use case for the ISteamFriends::GameOverlayActivated_t callback is to pause the game when the overlay opens.Many Steamworks methods use call results instead of a callback to asynchronously return results from a function call. The difference between a callback and call results is that callbacks are broadcast to all listeners, where-as call results only target a specific listener. Like callbacks, your game will need to call SteamAPI_RunCallbacks to dispatch call results to their listener.You can identify a function that provides a call result by inspecting it's return value; if it returns a SteamAPICall_t and has aattribute then you must register to receive the call result. Note that a callback registered to a CCallResult will only be triggered for the most recent SteamAPICall_t set on it, so be aware if you are re-using one.Callbacks and call results are not interchangeable. An event will only come through one or the other, not both. You must make sure that you are registering for the right type of event!Call results must be created as a member in a struct/class using the CCallResult type and you will also need to create the member function that will receive the callback.Feel free to name the function, function parameters, and CCallResult type anything you want.Here's an example of how to use the ISteamUserStats::GetNumberOfCurrentPlayers API which produces a ISteamUserStats::NumberOfCurrentPlayers_t call result.If you can't use the CCallResult system, then you may be able to use ISteamUtils::IsAPICallCompleted ISteamUtils::GetAPICallResult and ISteamUtils::GetAPICallFailureReason to track the status of a call result.The classes and macros used to register callbacks are convenient in C++ code. But there is also a lower-level mechanism for dealing with callbacks. This mechanism operates more like a Windows event loop. Instead of a single function that dispatches all of the callbacks and call results to active listeners, you fetch the next available callback in a loop, and dispatch it using whatever mechanisms you want. The manual dispatch mode is especially useful for binding layers that expose the Steamworks SDK to languages other than C++. Seeinfor more information.The Steamworks API includes support for running game servers as well as regular clients. A game server, in Steamworks API terms, is an entity in the system that normal users connect to to play multi-player games. This can be connecting over the Internet to a remote game server, or connecting locally to a game server that's in the same process as the client. Game servers have their own set of API functions to use, and their own unique Steam ID for other users to refer to them by.To use the Steam Game Server API you must first includeinstead ofInitializing and using the game server API is very similar to the normal API:After initializing a game server you have access to the two game server exclusive interfaces ISteamGameServer and ISteamGameServerStats You can also access the following regular interfaces from the game server:If you're running a dedicated game server (one which has no client component), you only have to initialize the game server API's, you don't have to initialize the normal user API.See Steamworks API Example Application (SpaceWar) for a fully loaded example of using the game server API.Unlike a game, a dedicated server will usually be run in an environment where there is no Steam Client installed to provide the latest steamworks binaries. In order for the dedicated server to have the latest steam binaries, you will need to include the Dedicated Server Redistributables with your app. Log into partner.steamgames.com and navigate to the technical settings for your app. Then look under \"Installation / Redistributables\" and check \"Dedicated Server Redistributables\"If you're using a commercial game engine or a language other than C or C++ you will want to see what level of support for the Steamworks API is provided for it.In some engines they provide native built-in support, for others you may need a third-party solution.If your engine does not have native support you can use the Steam Web API to access many features that Steam supports.Regardless of how the Steamworks SDK is implemented in your engine you will need to have the latest Steamworks SDK to upload your application to Steam If some of the software you are shipping on steam is available under a restrictive open source license then please see Distributing Open Source Applications on Steam Here are some common engines that people routinely use to ship games on Steam and the relevant documentation on how to get started using the Steamworks SDK with them.Valve does not in any way endorse any of these engines or the third-party solutions. This list is sorted exclusively by name, and is in no way comprehensive, it exists solely as a starting guide. Engines will only be listed if they include native support or have a third-party solution that fits the guidelines. Third-party solutions will only be listed if they are kept reasonably up to date with the Steamworks SDK, are freely available under a permissive license (See: Distributing Open Source Applications on Steam ), and have a thread on the Steamworks Discussion Board . We recommend that you consult the community to see which option would work best for your specific setup.The SDK has a few features to facilitate the creation of binding layers for other languages.Steam uses a variety of techniques to expose functionality to your application. It's by no means critical to understand exactly how the Steamworks API works but it's fairly simple and can be useful in planning out how to code your game with Steam integration in mind.When you link toit provides access to a small number of C functions which are prefixed with themacro, these functions are all exposed inand. Themodule itself is very small, it only exposes the base functionality to initialize and shutdown the Steamworks API.When the Steamworks API initializes it finds the actively running steam client process and loadsfrom that path.is essentially the core engine of the Steam client. It contains and maintains the information necessary to run Steam. The Steam client UI uses a similar set of functions as exposed here to access the data provided by. Since this data is in the Steam process, all Steam API calls are transparently marshaled and sent via an RPC/IPC mechanism. (A cross-process pipe, ISteamClient::HSteamPipe ).The Steam process, viamaintains a constant connection to the Steam back-end servers. Through this connection all authentication, matchmaking, friends list and VAC communication occurs. This connection may drop if the user has a network issue, or if the Steam server they are connected to receives an update. Callbacks will be posted to any running app if the connection drops or re-establishes. The Steam client will automatically try to reconnect, and clients running an app receive priority, so the typical reconnect time is under 10 seconds, although in some rare cases may be up to 5 minutes.The Steamworks API is versioned through a COM-like mechanism, where a string name and version of an interface are passed intowhich then returns the correct version of the interface to the caller.contains a set of adapters for all released versions of an interface which redirect or re-interpret the old calls in the context of the latest interface. The adapters live inside the steam client so that they are easy to update if any issues arise."
    }
]