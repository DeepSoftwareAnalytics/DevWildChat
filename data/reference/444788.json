[
    {
        "link": "https://bluetooth.com/learn-about-bluetooth/key-attributes/range",
        "document": "The longer answer to the question about the range of Bluetooth® technology is it depends.\n\nUnlike other wireless technologies, Bluetooth technology is designed to support a wide range of achievable ranges between two devices, providing developers tremendous flexibility to create wireless solutions that best meet the needs of their target use case.\n\nSeveral key factors influence the effective range of a reliable Bluetooth connection, including the following:\n\nRadio spectrum stretches from 30 Hz to 300 GHz. The lower the frequency the longer the range. However, the lower the frequency the lower the data rate it can support. As a result, selecting a radio spectrum comes with tradeoffs between range and data rate. Bluetooth® technology uses the 2.4 GHz ISM spectrum band (2400 to 2483.5 MHz), which enables a good balance between range and throughput. In addition, the 2.4 GHz band is available worldwide, making it a true standard for low-power wireless connectivity. The physical layer (PHY) of a wireless technology defines the modulation scheme and other techniques it uses to send data over a specific radio frequency (RF) band. This includes the number of channels available, how effectively those channels are utilized, the use of error correction, the guards in place to counter interference, and much more. If you compare RF communication to verbal communication, you can think of the PHY as defining the speed and clarity of your speech. Both impact the range at which you can be heard. Bluetooth® technology provides multiple PHY options, each with different characteristics that determine effective range and data rates. Receiver sensitivity is the measure of the minimum signal strength a receiver can interpret. In other words, it’s the lowest power level at which the receiver can detect a radio signal, maintain a connection, and still demodulate data. Think of receiver sensitivity as a measure of how well you can hear or the quietest sound you can hear and understand. Bluetooth® technology specifies that devices must be able to achieve a minimum receiver sensitivity of -70 dBm to -82 dBm, depending on the PHY used. However, Bluetooth implementations typically achieve much higher receiver sensitivity levels. For example, average implementations of the Bluetooth LE 125K (Coded) PHY are achieving a receiver sensitivity of -103 dBm. Choosing a transmit power level is a design tradeoff between range and power consumption. The higher the transmit power, the more likely the signal can be heard at longer distances and the longer the effective range. However, increasing the transmit power increases the power consumption of your device. Think of transmit power like the volume of your voice. The louder you speak, the farther away someone can hear you but the more energy it takes. The antenna converts electrical energy from the transmitter into electromagnetic energy (or radio waves) and vice-versa for the receiver. Antenna location, package size, and design can greatly impact how effective the signal is transmitted and received. And types and sizes of antenna and their efficiency in converting electrical to electromagnetic energy and focusing the direction of the energy can vary greatly. The effective antenna gain is relevant for both the transmitting and receiving antenna. The directional influence of an antenna is similar to speaking or listening through a cone to focus the energy of the sound. Bluetooth® technology designers can choose to implement a variety of antenna options. Antenna design is as much an art as it is a science. Bluetooth devices typically achieve an antenna gain in the range of –10 dBi to +10 dBi. Path loss is the reduction in signal strength that occurs as a radio wave propagates through the air. Path loss, or path attenuation, occurs naturally over distance and is impacted by the environment in which the signal is being transmitted. Obstacles between the transmitter and the receiver can deteriorate the signal. Attenuators can be anything from humidity and precipitation, to walls, windows, and other obstacles made of glass, wood, metal, or concrete, including metal towers or panels that reflect and scatter radio waves. While radio waves can pass through objects, the amount of attenuation and effective path loss varies with the type and density of the obstruction. Think about when you are trying to hear someone in the next room and the difference between the volume and clarity of what you can hear if the wall that separates you is made of wood compared to concrete."
    },
    {
        "link": "https://einfochips.com/blog/bluetooth-device-testing-performance-measurement-of-bluetooth-devices",
        "document": "Manufacturers of Bluetooth devices need to up their production as the increased demand results in the reduction of the device cost. The time to hit the market can become a primary factor in ensuring the success of the wireless product with Bluetooth wireless technology in it. However, the factors such as higher quantities, low cost, and reduced time-to-market can establish a demand for a cost-effective solution to test the quality and certify the compliance in the production line.\n\nBluetooth is a technology that seems simple from the usability perspective, but it is challenging to test and ensure that it works accurately for all different types of devices serving different transactions. There are two different devices involved that may have distinct development cycles and synchronization issues for Bluetooth connectivity checks.\n\n\n\nDevice testing for measuring Bluetooth connectivity is important to ensure flawless communication without any noise or interruption between devices. Device testing needs to be done in a controlled and isolated environment that is free from ambient or unwanted interference. For any IoT application, to determine if the Bluetooth technology meets the communication requirement, below are the parameters to be measured:\n\nIt is measured in bits per second (bps) and it defines the rate of data sent over a transmission channel successfully. The formula through which maximum throughput can be measured is R = D/T (R: Throughput rate; D: Data inventory; T: Time).\n\nHere, the value of D can be found by multiplying the total number of packets captured. It determines the total amount of data captured at the receiver node. T is the total time taken to capture the packets.\n\nRound-Trip Time (RTT): When the entire cycle of communication is completed, RTT shows the total time taken by the packet to be transferred from the instant transmitter to the immediate receiver after receiving the acknowledgment.\n\nIt shows the amount of time a packet takes to travel to the receiver node. It can also be identified by finding the difference in the time taken by the packet departing from the transmitter node to arrival at the receiver node. Before testing a one-way delay, it is important to synchronize the system clocks from transmitter and receiver nodes to reflect the accurate delay.\n\nIt shows the amount of time taken for the connection to be established before the BLE link is ready to transfer the data.\n\nWhile testing a Bluetooth device, it is important to consider that some uncontrollable parameters may affect the testing procedure and the outcome. These factors are:\n\nEnvironment Noise: It is a signal noise that comes from the environment, and it may cause severe packet losses. It can also possibly degrade the link capacity or increase the packet delay.\n\nSystem Load: The testing results can be biased if the system load is high while performing the procedure as factors such as speed, scalability, stability, and reliability depend on the load.\n\nThe performance evaluation of BLE technology helps in understanding the niche of applications and how to best leverage it. Some of the other essential factors to consider are link capacity, data transfer delay, connection reestablishment latency, connection interval, pairing, packet size, and power consumption. By using the analytical models of these test metrics, the quality of the Bluetooth connection and uninterrupted data transfer can be determined.\n\nOne of our clients who is a leader in the audio and consumer electronics segment and has a strong leadership position in the global home audio systems and speakers, noise-canceling headphones, professional audio products, and automobile sound systems, was facing issues with its Bluetooth audio products. The client was looking for a solution partner to uncover Bluetooth connection stability issues and wanted to ensure interoperability between audio devices across five product categories – 20+ product variants and various versions of mobile models (Android/iOS), Tablets, Windows, and Mac station.\n\nLeveraging strong experience in wireless testing services, eInfochips delivered a complete turnkey testing solution including audio performance testing based on a range (2-30 meters), Bluetooth connectivity, and profiles testing – A2DP, AVRCP, and HFP. eInfochips’ Bluetooth testing solution helped the client launch new Bluetooth speakers and headsets range in the market ensuring high quality. It also enabled the client to achieve product superiority over competitive audio systems and equipment.\n\nBluetooth has been established as the well-known wireless communication technology for IoT applications and as a short-range radio standard for audio solutions. To ensure the flawless functionality of a Bluetooth device, it is important to evaluate performance and identify the key quality metrics.\n\neInfochips offers a comprehensive range of test solutions for Bluetooth testing, applicable from design and certification to production. We enable companies to get their connected devices and products to market quickly with testing services for ensuring quality comprising functionality, security, performance, and interoperability.\n\nTo know more about our security testing services, talk to our experts today."
    },
    {
        "link": "https://rohde-schwarz.com/us/solutions/wireless-communications-testing/wireless-standards/bluetooth/bluetooth-testing_124320.html",
        "document": "Bluetooth® is a short-range wireless technology that enables data communication in personal area networks (PAN). Bluetooth® communication is organized in so-called piconets, which involve one central device and up to seven peripheral devices.\n\nBluetooth® applies frequency or phase shift keying (FSK/PSK) modulation on 1 or 2 MHz spaced channels in an adaptive frequency hopping (AFH) scheme that operates in the globally available ISM band at 2.4 GHz.\n\nInitial requirements aimed at a data connection that supports certain protocol stack profiles, such as audio streaming or file exchange, based on the so-called basic rate (BR) of up to 1 Mbit/s in an ad-hoc network. Later, in Bluetooth® 2.0, an enhanced data rate (EDR) of up to 3 Mbit/s was specified.\n\nFollowing the demands for lower power data communication, the Bluetooth® Special Interest Group (SIG) started adopting Bluetooth® Low Energy (LE) technology in Bluetooth® 4.0. This is typically used in central devices to connect with a wide range of wearables, peripherals and IoT devices."
    },
    {
        "link": "https://gta-psg.georgia.gov/psg/bluetooth-so-06-004",
        "document": ""
    },
    {
        "link": "https://embien.com/blog/bluetooth-device-testing-methodologies",
        "document": "Earlier, we covered product testing for all major domains such as Modbus validation in industrial, displays in consumer domain, UDS in automotive domain, Wi-Fi in consumer domain etc. Bluetooth is also one of the key technologies used in consumer, automotive, medical, and industrial domains. There are several factors in Bluetooth design that may influence overall performance such as antenna design, power supplies, other wireless communications chips or the final housing. Therefore, it is necessary to test the Bluetooth device to verify its performance and ensure conformance with the Bluetooth Special Interest Group (SIG) standards and regulatory requirements. This is especially important because Bluetooth operates in the unlicensed spectrum and has to work seamlessly with other radio technologies that use the same spectrum.\n\nBluetooth device testing is governed by regulatory compliance for radio operation in 2.4Ghz band and compliance with Bluetooth specification. There are primarily 2 types of Bluetooth interfaces in use – Bluetooth classic and Bluetooth low energy. So, testers need to know the specific tests to perform for each type as discussed below.\n\nIn Bluetooth classic device, physical layer supports 2 transport schemes (SCO & ACL) to support data transfer. Bluetooth Classic radio, also referred to as BR/EDR, can be tested by vendor-specific control interface and can be used for fully automated tests. The Bluetooth SIG has specified a test mode and interface that should be used to control the Device under test (DUT) during compliance testing. This uses the link management protocol (LMP) to control the DUT over the Bluetooth radio link.\n\nDuring testing, the tester and the Device under test (DUT) form a Bluetooth piconet, where the tester acts as the central device and has full control over the test sequence via a control interface using the link management protocol (LMP). The DUT acts as peripheral and is set at the beginning via a DUT specific local interface in test mode (TM) for testing.\n\nFew test cases that can be run are:\n\nBluetooth physical layer test items comprise transmitter tests that cover transmit power, power density spectrum, spurious emission, or modulation accuracy, as well as receiver tests for sensitivity or blocking performance.\n\nStandalone battery-operated low power devices are the main use cases of BLE. Some of the devices that use BLE are home automation system, fitness tracking, fleet tracking etc. Critical testing of this device involves RF testing and power consumption.\n\nBluetooth SIG Standardized direct test mode (DTM) to test transmitter, receiver with control facilitated test commands. This mode enables testing of the Bluetooth LE transmitter and receiver, with control facilitated through a dedicated wired test interface. For the wired interface, two specified options include a USB or RS232 connection to the host control interface (HCI) of the DUT.\n\nApart from the above physical level tests, the Bluetooth devices are to be validated for application functionality. Classic devices are to be verified if the profiles being implemented are in conformance with the specifications. For the BLE, services and characteristics implementation have to be validated. Some of the tests could be:\n\nFor this application specific/use case-based tests, additional tools and applications are required. Since the edge device is mostly going to communicate with consumer devices such as smartphones, automotive clusters, infotainment systems, etc. it will be complex to test them against a wide range of smartphones and devices. So, a proper set of tools need to be identified and used for testing. These tools could be a Client Emulator for functional validation or Sniffer for non-invasive validation.\n\nEssentially PC based/Mobile Apps, these tools help to interact with and test the target Bluetooth devices. They are also very helpful for testing out new changes/updates during development. These types of apps allow testers to scan for nearby advertising Bluetooth Low Energy devices, connect to one of these devices, discover their services and characteristics, and read from/write to the characteristic values as well.\n\nNordic Semiconductor's nRF Connect is a robust tool for developing and testing Bluetooth Low Energy BLE devices. It allows reading available characteristics, writing to them, register for notifications etc. But being a non-customizable tool performing specific communication operations such as multi-sequence operations, file transfer etc. will be a challenge.\n\nTestBot from Embien, is a PC Based tool that allowed testers to create a mock peripheral device and simulate its behavior. This method is much more flexible than the nRF Connect app, as testers can program the peripheral device to behave in certain ways. Configuring and developing a Test Bot based automation may take more time compared to the nRF connect. However, once it is set up, it can be used for both unit testing and integration testing.\n\nA Bluetooth sniffer (or protocol analyzer) is one of the most useful tools. The difference between a Bluetooth sniffer and the Client emulator apps mentioned previously is that sniffers can spy on the communication between the central and peripheral devices. While a client emulator is usually used to act as a central device to read, write, and subscribe to notifications/indications of characteristic values of the peripheral device, the sniffer acts in the background (usually without requiring to modify any of system’s behavior).\n\nIn general, a BLE sniffer captures packets in two main scenarios:\n• Advertising mode: It captures advertising packets (mainly on the primary advertising channels 37, 38, and 39)\n• Connection mode: It captures raw packet data exchanged between two Bluetooth LE devices during a connection (the remaining 37 channels: 0 through 36)\n\nThere are 2 types of sniffers.\n\nThough the low-cost sniffers usually suffer from a few limitations, such as the lack of advanced features on the companion desktop software side as well as not being able to scan the three primary advertising channels simultaneously, they are good enough for most tests.\n\nBluetooth technology continues to be a cornerstone of wireless communication, enabling a wide array of devices to connect seamlessly. By adhering to best practices and leveraging advanced testing tools such as sniffers, emulators etc., testers can test the Bluetooth devices effectively."
    },
    {
        "link": "https://bluetooth.com/blog/a-developers-guide-to-bluetooth",
        "document": "Bluetooth® technology is the wireless communications technology for developers which allows devices to communicate with each other without the need for a central device like a router or access point.\n\nBluetooth technology has a special low energy feature which means it can be used without requiring much power from the devices using it.\n\nIn the world of Bluetooth® Low Energy, a device has something called a profile which defines the way other devices are able to communicate over Bluetooth with it. In a way, the Bluetooth® profile defines the way a device appears to other devices in terms of its features and the things it can do.\n\nTo put it another way, a Bluetooth profile is really an interface specification. It defines the data which a device has, what another device can do with that data over a Bluetooth connection and how the device with the profile should respond when a connected device acts upon its data in some way. Let’s look at that description in a little more technical detail.\n\nA Bluetooth® device contains a table of data called an Attribute Table which can be accessed by other connected devices in various possible ways. That table of data and the ways in which it can be exploited falls into a technical area of Bluetooth called the Generic Attribute profile or GATT for short and you may see the term GATT in some of the documentation for APIs such as those provided by the Android platform.\n\nThe Attribute Table contains something like a series of records of various types. The main types are called Services, Characteristics, and Descriptors. Let’s look at each of these terms in turn.\n\nServices, Characteristics, and Descriptors are all types of Attribute. Hence Generic Attribute Profile, Attribute Table and something called the Attribute Protocol. All attributes have a type which is identified by a UUID (Universally Unique Identifer). Some Attributes are defined by the Bluetooth SIG, the technical standards body for Bluetooth and these have UUIDs which are 16 bits in length. Some Attributes are custom designed for a particular device by the product team and these have 128 bit UUIDs.\n\nServices, Characteristics and Descriptors are organised in a hierarchy with Services at the top and Descriptors at the bottom. Services contain one or more Characteristics. A Characteristic owns zero or more Descriptors because Descriptors are completely optional whereas a Service must contain at least one Characteristic.\n\nA Service is a container for logically related Bluetooth® data items. Those data items are in fact called Characteristics. A Service can be thought of as the owner of the Characteristics inside it. Often a Service represents a particular feature (e.g. a hardware feature) of a device like the buttons or a particular sensor. An example of a Bluetooth SIG defined Service is the Device Information Service which, as the name suggests, is a container for various items of information about the device such as its manufacturer and serial number.\n\nCharacteristics are items of data which relate to a particular internal state of the device or perhaps some state of the environment which the device can measure using a sensor. The current battery level is an example of internal state data whereas the ambient temperature could perhaps be measured by a sensor. Sometimes Characteristics represent configuration data such as the frequency at which you want something to be measured. In any of these cases, the way a device can expose such data to other devices to use via Bluetooth® technology is by making them available as a Characteristic. An example of a Bluetooth SIG defined Characteristic is the Serial Number String which you’ll find inside the Device Information service.\n\nCharacteristics contain various parts. They have a type, a value, some properties and some permissions.\n\nType is something already explained above, a UUID value which indicates which particular type of Characteristic an Attribute is. Value is the value of the associated state data item.\n\nProperties define what another device can do with the characteristic over a Bluetooth signal in terms of various defined operations such as READ, WRITE or NOTIFY. Reading a characteristic means transferring its current value from the attribute table to the connected device over a Bluetooth signal. Writing allows the connected device to change that value in the state table. Notifications are a special message type which a device can send to a connected device whenever the value of the associated characteristic changes or perhaps periodically, controlled by a timer. Not all Characteristics support all operations. The Characteristic’s properties tell you which operations are supported.\n\nSometimes the device will have been programmed to respond in a special way when it processes an operation like reading or writing a value from the attribute table so operations can result in more happening than simply transferring data across the connection. Perhaps changing the value of a Characteristic will result in the device changing the frequency with which it samples readings from the device accelerometer for example.\n\nPermissions are to do with security and further describe the security conditions that must be met before read or write access to the characteristic is to be granted.\n\nDescriptors contain metadata which either augments the details relating to the Characteristic which the Descriptor belongs to or allows the configuration of a behaviour involving that Characteristic. For example, notification messages are switched on or off using a special descriptor called the Client Characteristic Configuration Descriptor .\n\nA Bluetooth® profile is a specification which pulls together all the required information about how a device behaves, how it can be accessed in terms of its services, characteristics and descriptors, security rules, concurrency limitations and so on.\n\nWhen a smartphone application interacts with a device over a Bluetooth® connection we have a client/server architecture. The phone application is usually the GATT client and the device is usually the GATT server. They communicate using a protocol called the Attribute Protocol or just ATT for short. As a smartphone developer, you work with APIs and do not have to worry about formulating ATT protocol data units and so on.\n\nEverything described above relates to devices which are connected and communicating as GATT client and server. But there’s a stage which precedes this where the two devices are not yet connected. How do they find each other and connect? The answer to this question is termed ‘Device Discovery’ and is the responsibility of another part of the Bluetooth architecture called the Generic Access Profile (GAP).\n\nIn GAP, one device advertises, emitting small packets of data periodically. These packets contain information about the device doing the advertising. Other devices looking for devices to connect to perform something called scanning, receiving and processing advertising packets and filtering out those that come from devices of a type that are not of interest. Usually, the user is given information about devices which are discovered and they then select one to be connected to. The device which advertises is called a Bluetooth Peripheral whereas the one doing the scanning is a Bluetooth® Central device.\n\nWant to Know More?\n\nThe Bluetooth SIG website at is a good place for further information about Bluetooth technology in general. You’ll find all the Bluetooth SIG defined profiles, services, characteristics and descriptors there as well as the Bluetooth® Core Specification for all Bluetooth technology."
    },
    {
        "link": "https://bluetooth.com/blog/bluetooth-pairing-part-1-pairing-feature-exchange",
        "document": "In the Bluetooth® Core Specification, there are three major architectural layers: Controller, Host and Application. In the Host Layer, there is a module called Security Manager (SM) which defines the methods and protocols for pairing and key distribution, the corresponding security toolbox, and the Security Manager Protocol (SMP) which defines the pairing command frame format, frame structure and timeout restriction. The Security Manager (SM) uses a key distribution approach to perform identity and encryption functionalities in radio communication.\n\nPairing is performed to establish keys which can then be used to encrypt a link. A transport specific key distribution is then performed to share the keys. The keys can be used to encrypt a link in future reconnections, verify signed data, or perform random address resolution. In general, there are 3-phase for paring.\n\nLE legacy pairing and LE Secure Connections may be new terms to most. LE is short for “low energy” and is in the Bluetooth® specification as a main feature of Bluetooth® Core 4.0 and above. In Bluetooth® Core 4.2, the Secure Connections feature to the LE physical transport was added, which upgraded pairing to utilize FIPS-approved algorithms (AES-CMAC and P-256 elliptic curve) on the Bluetooth LE physical transport. In order to distinguish Secure Connections from LE pairing as defined in Bluetooth® Core 4.0 and Bluetooth® Core 4.1, it is referred to as LE legacy pairing. Figure 1 is a pairing flowchart which applies to both legacy pairing and secure connections.\n\nToday, we will look at Phase 1: Pairing Feature Exchange. Pairing is the exchange of security features that include things like Input/Output (IO) capabilities, requirements for Man-In-The-Middle protection, etc. The exchange of pairing information between two devices is done through the Pairing Request and Pairing Response packet. The contents of these two messages is shown below in Table 1 Pairing Request/Response.\n\nSince IO refers to Input/Output, the IO Capabilities are combined to generate the value for this field. For Input Capabilities, it could be “No Input”, “Yes/No” or “Keyboard,” detailed below.\n\nFor Output Capabilities, it could be “No Output” or “Numeric Output,” detailed below.\n\nAfter combined those capabilities of Input and Output, here is a matrix defining what IO capabilities the Bluetooth device should have.\n\nNone of the pairing algorithms can use Yes/No input and no output, therefore, “NoInputNoOutput” is used as the resulting IO capability.\n\nFrom the above matrix, you map the corresponding IO capabilities and select below enum to place into Pairing Request/Response packet.\n\nOOB, or Out-of-Band, uses an external means of communication to exchange some information used in the pairing process. The OOB media could be any other wireless communication standard which can carry the corresponding information for pairing, like NFC or QRCode.\n\nBonding is the exchange of long-term keys after pairing occurs, and storing those keys for later use — it is the creation of permanent security between devices. Pairing is the mechanism that allows bonding to occur.\n\nMITM is short for “Man-In-The-Middle.” This field is a 1-bit flag that is set to one if the device is requesting MITM protection. This blog focuses on the procedure for the pairing feature exchange—if you are interested in MITM, please refer to the Bluetooth Core Specification v4.2, Vol1, Part A, 5.2.3.\n\nThe SC field is a 1-bit flag that is set to one to request LE Secure Connection pairing. The possible resulting pairing mechanisms are if both devices support LE Secure Connections, use LE Secure Connections and otherwise use LE legacy pairing. So this flag is an indicator to determine Phase 2 pairing method.\n\nThe keypress field is a 1-bit flag that is used only in the Passkey Entry protocol and is ignored in other protocols. Passkey Entry protocol is a typical pairing method of Legacy Pairing and Secure Connection. We will go into this in the next blog article.\n\nThe maximum key size shall be in the range 7 to 16 octets.\n\nThese two fields have the same definition as below. I will explain when we talk about key distribution in the future series blog.\n\nWhen the exchange of pairing feature starts, the initiator and responder will exchange their pairing feature information with each other through pairing request and response. With the information, the initiator and responder can determine the I/O capabilities with each other, which pairing mechanism—legacy pairing or secure connection—should be used, and select the pairing method—Just Work, Passkey Entry, Numeric Comparison or Out of Band—to use in Phase2. We will explore the details in Part 2: Pairing Method and Key Generation."
    },
    {
        "link": "https://developer.android.com/develop/connectivity/bluetooth",
        "document": "The Android platform includes support for the Bluetooth network stack, which allows a device to wirelessly exchange data with other Bluetooth devices. The app framework provides access to the Bluetooth functionality through Bluetooth APIs. These APIs let apps connect to other Bluetooth devices, enabling point-to-point and multipoint wireless features.\n\nUsing the Bluetooth APIs, an app can perform the following:\n• Connect to other devices through service discovery.\n• Transfer data to and from other devices.\n\nThis topic focuses on Classic Bluetooth. Classic Bluetooth is the right choice for more battery-intensive operations, which include streaming and communicating between devices. For Bluetooth devices with low power requirements, consider using Bluetooth Low Energy connections.\n\nThis documentation describes different Bluetooth profiles and explains how to use the Bluetooth APIs to accomplish the four major tasks necessary to communicate using Bluetooth:\n• Finding devices that are either paired or available in the local area.\n\nFor a demonstration of using the Bluetooth APIs, see the Bluetooth Chat sample app.\n\nFor Bluetooth-enabled devices to transmit data between each other, they must first form a channel of communication using a pairing process. One device, a discoverable device, makes itself available for incoming connection requests. Another device finds the discoverable device using a service discovery process. After the discoverable device accepts the pairing request, the two devices complete a bonding process in which they exchange security keys. The devices cache these keys for later use. After the pairing and bonding processes are complete, the two devices exchange information. When the session is complete, the device that initiated the pairing request releases the channel that had linked it to the discoverable device. The two devices remain bonded, however, so they can reconnect automatically during a future session as long as they're in range of each other and neither device has removed the bond.\n\nUse of the Bluetooth APIs requires declaring several permissions in your manifest file. Once your app has permission to use Bluetooth, your app needs to access the and determine if Bluetooth is available on the device. If Bluetooth is available, there are three steps to make a connection:\n• Find nearby Bluetooth devices, either devices that are already paired or new ones.\n\nCertain devices use a specific Bluetooth profile that declares the data it provides.\n\nAll of the Bluetooth APIs are available in the package. The following are the classes and interfaces you need in order to create Bluetooth connections:"
    },
    {
        "link": "https://stackoverflow.com/questions/27360338/how-does-bluetooth-pairing-work",
        "document": "How exactly does Bluetooth paring work? What is communicated between each device during the pairing process?\n\nI was told if you had wanting to pair with :\n• sends a 'unique key' to device on some wavelength/frequency\n• None returns an 'echo' back to , and hence the devices pair.\n\nThis seems to be inaccurate, so would anyone be able to either expand further or actually explain how/what is communicated to result in a successful pairing of the devices?\n\nI was thinking of incorporating some of this research into a final year project (University), but would at least need to know the something of the Bluetooth programming pairing first.\n\nAny help would be much appreciated in describing how these initial communications work.\n\nI've heard of terms such as 'parked mode', and 'passive mode' within my research, but am yet to find any 'useful' information in the programming behind the design, (and hence I have asked this question). The likes of googling this type of topic is also quite difficult as it seems to bring up stuff like 'how to turn your bluetooth on' pages, and not the design of the programming behind it."
    },
    {
        "link": "https://developer.android.com/develop/connectivity/bluetooth/find-bluetooth-devices",
        "document": "Using the , you can find remote Bluetooth devices either through device discovery or by querying the list of paired devices.\n\nMake sure you have the appropriate Bluetooth permissions and set up your app for Bluetooth before attempting to find Bluetooth devices.\n\nDevice discovery is a scanning procedure that searches the local area for Bluetooth-enabled devices and requests some information about each one. This process is sometimes referred to as discovering, inquiring, or scanning. A nearby Bluetooth device responds to a discovery request only if it is currently accepting information requests by being discoverable. If a device is discoverable, it responds to the discovery request by sharing some information, such as the device's name, its class, and its unique MAC address. Using this information, the device that is performing the discovery process can then choose to initiate a connection to the discovered device.\n\nBecause discoverable devices might reveal information about the user's location, the device discovery process requires location access. If your app is being used on a device that runs Android 8.0 (API level 26) or higher, consider using the Companion Device Manager API instead. This API performs device discovery on your app's behalf, so your app doesn't need to request location permissions.\n\nOnce a connection is made with a remote device for the first time, a pairing request is automatically presented to the user. When a device is paired, the basic information about that device—such as the device's name, class, and MAC address—is saved and can be read using the Bluetooth APIs. Using the known MAC address for a remote device, a connection can be initiated with it at any time without performing discovery, assuming the device is still within range.\n\nNote that there is a difference between being paired and being connected:\n• To be paired means that two devices are aware of each other's existence, have a shared link-key that can be used for authentication, and are capable of establishing an encrypted connection with each other.\n• To be connected means that the devices currently share an RFCOMM channel and are able to transmit data with each other. The current Bluetooth APIs require devices to be paired before an RFCOMM connection can be established. Pairing is automatically performed when you initiate an encrypted connection with the Bluetooth APIs.\n\nThe following sections describe how to find devices that have been paired and how to discover new devices using device discovery.\n\nBefore performing device discovery, it's worth querying the set of paired devices to see if the desired device is already known. To do so, call . This returns a set of objects representing paired devices. For example, you can query all paired devices and get the name and MAC address of each device, as the following code snippet demonstrates:\n\nTo initiate a connection with a Bluetooth device, all that's needed from the associated object is the MAC address, which you retrieve by calling . You can learn more about creating a connection in Connect Bluetooth devices.\n\nTo start discovering devices, call . The process is asynchronous and returns a boolean value indicating whether discovery has successfully started. The discovery process usually involves an inquiry scan of about 12 seconds, followed by a page scan of each device found to retrieve its Bluetooth name.\n\nTo receive information about each device discovered, your app must register a for the intent. The system broadcasts this intent for each device. The intent contains the extra fields and , which in turn contain a and a , respectively. The following code snippet shows how you can register to handle the broadcast when devices are discovered:\n\nTo initiate a connection with a Bluetooth device, you call on the to retrieve the associated MAC address.\n\nTo make the local device discoverable to other devices, call with the intent. This issues a request to enable the system's discoverable mode without having to navigate to the Settings app, which would stop your own app. By default, the device becomes discoverable for two minutes. You can define a different duration, up to five minutes, by adding the extra.\n\nThe following code snippet sets the device to be discoverable for five minutes:\n\nA dialog is displayed, requesting the user's permission to make the device discoverable, as shown in figure 2. If the user responds \"Allow,\" then the device becomes discoverable for the specified amount of time. Your activity then receives a call to the callback, with the result code equal to the duration that the device is discoverable. If the user responded \"Deny\", or if an error occurred, the result code is .\n\nThe device silently remains in discoverable mode for the allotted time. To be notified when the discoverable mode has changed, register a for the intent. This intent contains the extra fields and , which provide the new and old scan mode, respectively. Possible values for each extra are as follows:\n\nIf you are initiating the connection to a remote device, you don't need to enable device discoverability. Enabling discoverability is only necessary when you want your app to host a server socket that accepts incoming connections, as remote devices must be able to discover other devices before initiating connections to those other devices."
    }
]