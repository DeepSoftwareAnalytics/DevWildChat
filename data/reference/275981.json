[
    {
        "link": "https://help.ubuntu.com/community/DOSBox",
        "document": "DOSBox is a free, open-source cross-platform MS-DOS emulator that uses the SDL library. It emulates CPU:286/386 realmode/protected mode, Directory FileSystem/XMS/EMS, Tandy/Hercules/CGA/EGA/VGA/VESA graphics, and SoundBlaster/Gravis Ultra Sound cards. Thus, it is possible to run many programs originally written for MS-DOS in Linux with DOSBox.\n\nThe emulator has been largely developed for use with old games, but it may be possible to use DOSBox to run other MS-DOS applications. The DOSBox project maintains a list of compatible games.\n\nTo run more recent applications developed for Windows, use Wine.\n\nYou will need to enable the Universe repositories (see AddingRepositoriesHowto), update, and install the package.\n\nDOSBox can be run from a terminal by simply typing .\n\nThis will open up what looks like another terminal window, with a prompt. This is DOSBox.\n\nSeeing a where one might have expected to see or even will seem strange to those familiar with MS-DOS and command.com.\n\nDOSBox does not have a drive enabled by default. To give it one, we must mount one onto the virtual machine.\n\nIn practice, this means we must create a directory which can serve as a virtual drive for DOSBox.\n\nIn a regular terminal, (NOT DOSBox), you can execute\n\nwhich will create the directory in your home directory. To have DOSBox use this as its drive, execute the following command in DOSBox:\n\nThis makes the contents of the contents of the virtual drive in DOSBox. You can now run any DOS programs in that directory in DOSBox. If those DOS programs are self-contained executables, it's enough simply to copy them onto a suitable sub-directory in and run them within DOSBox. For other programs, you may need to run their installers. Consult the compatibility list for details for each one.\n\nIt is also possible to mount removeable disks in this way; simply specify the path to the removeable disk instead.\n\nFor a more technical discussion of the mount command in DOSBox, consult the manual page for that command.\n\nNote that many of the examples on the official DOSBox will seem to be specific to MS-DOS or Windows. Where you see a Windows-type path like , simply read a Linux-style path. The result of the commands should be the same.\n\nIt is also possible(and in many cases desireable) to mount disk images in DOSBox, using the command.\n\nMost commonly, this is used to mount CD-ROM images. To mount a CD-ROM image in DOSBox, execute the following command in DOSBox:\n\nThis will mount an .iso to the DOSBox virtual machine as a CD-ROM.\n\nA more technical discussion of the imgmount command can be found at its manual page\n\nNote that many of the examples on the official DOSBox will seem to be specific to MS-DOS or Windows. Where you see a Windows-type path like , simply read a Linux-style path. The result of the commands should be the same."
    },
    {
        "link": "https://delorie.com/djgpp/doc/ug/intro/installing-djgpp.html",
        "document": ""
    },
    {
        "link": "https://blogsystem5.substack.com/p/running-gnu-on-dos-with-djgpp",
        "document": "The recent deep dive into the IDEs of the DOS times 30 years ago made me reminisce of DJGPP, a distribution of the GNU development tools for DOS.\n\nI remember using DJGPP back in the 1990s before I had been exposed to Linux and feeling that it was a strange beast. Compared to the Microsoft C Compiler and Turbo C++, the tooling was bloated and alien to DOS, and the resulting binaries were huge. But DJGPP provided a complete development environment for free, which I got from a monthly magazine, and I could even look at its source code if I wished. You can’t imagine what a big deal that was at the time.\n\nBut even if I could look under the cover, I never did. I never really understood why was DJGPP so strange, slow, and huge, or why it even existed. Until now. As I’m in the mood of looking back, I’ve spent the last couple of months figuring out what the foundations of this software were and how it actually worked. Part of this research has resulted in the previous two posts on DOS memory management. And part of this research is this article. Let’s take a look!\n\nSpecial thanks go to DJ Delorie himself for reviewing a draft of this article. Make sure to visit his website for DJGPP and a lot more cool stuff!\n\nSimply put, DJGPP is a port of the GNU development tools to DOS. You would think that this was an easy feat to achieve given that other compilers did exist for DOS. However… you should know that Richard Stallman (RMS)—the creator of GNU and GCC—thought that GCC, a 32-bit compiler, was too big to run on a 16-bit operating system restricted to 1 MB of memory. DJ Delorie took this as a challenge in 1989 and, with all the contortions that we shall see below, made GCC and other tools like GDB and Emacs work on DOS.\n\nTo a DOS and Windows user, DJGPP was, and still is, an alien development environment: the tools’ behavior is strange compared to other DOS compilers, and that’s primarily due to their Unix heritage. For example, as soon as you start using DJGPP, you realize that flags are prefixed by a dash instead of a slash, paths use forward slashes instead of backward slashes, and the files don’t ship in a flat directory structure like most other programs did. But hey, all the tools worked and, best of all, they were free!\n\nIn fact, from reading about the historical goals of the project, I gather that a secondary goal was for DJ to evangelize free software to as many people as possible, meeting them where they already were: PC users with a not-very-powerful machine that ran DOS. Mind you, this plan worked on some of us as we ended up moving to Linux and the free software movement later on.\n\nIn any case, being a free alien development environment doesn’t explain why it had to be huge and slow compared to other others. To explain this, we need to look at the “32-bit compiler” part.\n\nAs we saw in a previous article, Intel PCs based on the 80386 have two main modes of operation: real mode and protected mode. In real mode, the processor behaves like a fast 16-bit 8086, limiting programs to a 1 MB address space and with free reign to access memory and hardware peripherals. In protected mode, programs are 32-bit, have access to a 4 GB address space, and there are protection rules in place to access memory and hardware.\n\nDOS was a 16-bit operating system that ran in real mode. Applications that ran on DOS leveraged DOS’ services for things like disk access, were limited to addressing 1 MB of memory, and had complete control of the computer. Contrary to that, GCC was a 32-bit program that had been designed to run on Unix (oops sorry, GNU is Not Unix) and produce binaries for Unix, and Unix required virtual memory from the ground up to support multiprocessing. (I know that’s not totally accurate but it’s easier to think about it that way.)\n\nIntel-native compilers for DOS, such as the Microsoft C compiler and Turbo C++, targeted the 8086’s weird segmented architecture and generated code accordingly. Those compilers had to deal with short, near, and far jumps—which is to say I have extra research to do and write another article on ancient DOS memory models. GCC, on the other hand, assumes the full address space is available to programs and generates code making such assumptions.\n\nGCC was not only a 32-bit program, though: it was also big. In order to compile itself and other programs, GCC needed more physical memory than PCs had back then. This means that, in order to port GCC to DOS, GCC needed virtual memory. In turn, this means that GCC had to run in protected mode. Yet… DOS is a real mode operating system, and calling into DOS services to access files and the like requires the processor to be in real mode.\n\nTo address this conundrum, DJ had to find a way to make GCC and the programs it compiles integrate with DOS. After all, if you have a C program that opens a file and you compile said program with GCC, you want the program to open the file via the DOS file system for interoperability reasons.\n\nHere, witness this. The following silly program, , goes out of its way to allocate a buffer above the 2 MB mark and then uses said buffer to read itself into it, printing the very first line of its source code:\n\nYes, yes, I know the above code is really unsafe and lacks error handling throughout. But that’s not important here. Watch out what happens when we compile and run this program with DJGPP on DOS:\n\nNote two things. The first is that the program has to have run in protected mode because it successfully allocated a buffer above the 1 MB mark and used it without extraneous API calls. The second is that the program is invoking file operations, and those operations interact with files managed by DOS.\n\nAnd here is where the really cool stuff begins. On the one hand, we have DOS as a real mode operating system. On the other hand, we have programs that want to interoperate with DOS but they also want to take advantage of protected mode to leverage the larger address space and virtual memory. Unfortunately, protected mode cannot call DOS services because those require real mode.\n\nThe accepted solution to this issue is the use of a DOS Extender as we already saw in the previous article but such technology was in its infancy. DJ actually went through three different iterations to fully resolve this problem in DJGPP:\n• None The first prototype used Phar Lap’s DOS Extender but it didn’t get very far because it didn’t support virtual memory.\n• None Then, the first real version of DJGPP used DJ’s own DOS Extender called go32, a big hack that I’m not going to talk about here.\n• None And then, the second major version of DJGPP—almost a full rewrite of the first one—switched to using the DOS Protected Mode Interface (DPMI).\n\nAt this point, DJGPP was able to run inside existing DPMI hosts such as Windows or the many memory managers that already existed for DOS and it didn’t have to carry the hacks that previously existed in go32 (although the go32 code went on to live inside ). The remainder of this article only talks about the latter of these versions.\n\nOne thing you may have noticed in the code of the example above is that I’m using a buffer for the file read that’s 1 MB-long. That’s not unintentional: for such a large buffer to even exist (no matter our attempts to push it above 2 MBs), the buffer must be allocated in extended memory. But if it is allocated in extended memory, how can the file read operations that we send to DOS actually address such memory? After all, even if we used unreal mode, the DOS APIs wouldn’t understand it.\n\nThe answer is the transfer buffer. The transfer buffer is a small and static piece of memory that DJGPP-built programs allocate at startup time below the 1 MB mark. With that in mind, and taking a file read as an example, DJGPP’s C library does something akin to the following:\n• None The stub issues a DPMI read call (which is to say, it executes the DOS read file API but uses the DPMI trampoline) onto the transfer buffer.\n• None The DPMI host switches to real mode and calls the DOS read file API.\n• None The real-mode DOS read places the data in the transfer buffer.\n• None The real-mode DPMI host switches back to protected mode and returns control to the protected-mode stub.\n• None The protected-mode stub copies the data from the transfer buffer into the user-supplied buffer.\n\nThis is all good and dandy but… take a close look at DOS’s file read API:\n\nThat’s right: file read and write operations are restricted to 64 KB at a time because the number of bytes to process is specified in the 16-bit register. Which means that, in order to perform large file operations, we need to go through the dance above multiple times in a loop. And that’s why DJGPP is slow: if the DPMI host has to switch to real mode and back for every system call, the overhead of each system call is significant.\n\nNow is a good time to take a short break and peek into DJGPP’s implementation. It’s succinct and clearly illustrates what I described just above. And with that done, let’s switch gears.\n\nLeveraging protected mode and a large memory address space are just two important but small parts of the DJGPP puzzle. The other interesting pieces of DJGPP are those that make Unix programs run semi-seamlessly on DOS, and there are many such pieces. I won’t cover them all here because Eli Zarateskii’s presentation did an excellent job at that. So want I to do instead is look at a subset of them apart and show them in action.\n\nTo begin, let’s try to answer this question: how do you interact with a program originally designed for Unix on a DOS system? The Unix shell is a big part of such interaction and is no Unix shell. To summarize the linked article: the API to invoke an executable on Unix takes a list of arguments while on DOS and Windows it takes a flat string. Partially because of this, the Unix shell is responsible for expanding globs and dealing with quotation characters, while on DOS and Windows each program is responsible for tokenizing the command line.\n\nLeaving aside the fact that the DOS API is… ehem… bad, this fundamental difference means that any Unix program ported to DOS has a usability problem: you cannot use globs anymore when invoking it! Something as simple and common as would just not work. So then… how can we explain the following output from the program, a little piece of code that prints ?\n\nIn the picture above, you can see how I ran the showargs.c program with *.c as its own argument and somehow it worked as you would expect. But if we build it with a standard DOS compiler we get different results:\n\nGCC is actually doing something to make glob expansion work—and it has to, because remember that DJGPP was not just about porting GCC: it was about porting many more GNU developer tools to DOS. Having had to patch them one by one to work with DOS’ semantics would have been a sad state of affairs.\n\nTo understand what’s happening here, know that all C programs compiled by any compiler include a prelude: is not the program’s true entry point. All compilers wrap with some code of their own to set up the process and the C library, and DJGPP is no different. Such code is often known as the (or C Runtime) and it comes in two phases: , written in assembly for early bootstrapping, and , written in C.\n\nAs you can imagine, this is where the magic lives. DJGPP’s is in charge of processing the flat command line that it receives from DOS and transforming it into the that POSIX C programs expect, following common Unix semantics. In a way, this code performs the job of a Unix shell.\n\nOnce again, take a break to inspect the sources and, in particular, the contents of the file. Pay attention to file reads and the “proxy” thing, both of which bring us to the next section.\n\nUnix command lines aren’t different just because of glob expansion. They are also different because they are usually long, and they are long in part because of glob expansion and in part because Unix has supported long file names for much longer than DOS.\n\nUnfortunately… DOS restricted command lines to a maximum of 126 characters—fewer characters than you can fit in a Tweet or an SMS—and this posed a problem because the build process of most GNU developer tools, if not all, required using long command lines. To resolve these issues, DJGPP provides two features.\n\nThe first is support for response files. Response files are text files that contain the full command line. These files are then passed to a process with the syntax, which then causes DJGPP’s code to load the response files and construct the long command line in extended memory.\n\nLet’s take a look. If we reuse our previous program that prints the command line arguments, we can observe how the behavior differs between building this program with a standard DOS compiler and with DJGPP:\n\nResponse files are easy to implement and they are sufficient to support long command lines: even if they require special handling on the caller side to write the arguments to disk and then place the response file as an argument, this could all be hidden inside the family of system calls. Unfortunately, using response files is slow because, in order to invoke a program, you need to write the command line to a file—only to load it immediately afterwards. And disk I/O used to be really slow.\n\nFor this reason, DJGPP provides a different mechanism to pass long command lines around, and this is via the transfer buffer described earlier. This mechanism involves putting the command line in the transfer buffer and telling the executed command where its command line lives. This mechanism obviously only works when executing a DJGPP program from another DJGPP program, because no matter what, process executions are still routed through DOS and thus are bound by DOS’ 126 character limit.\n\nLet’s try this too. For this experiment, we’ll play with two programs: one that prints the length of the received command line and another one that produces a long command line and executes the former.\n\nThe first program is and is depicted below. All this program does is allocate a command line longer than DOS’ maximum length of 126 characters and, once it has built the command line, invokes with said long command line:\n\nThe second program is and is depicted below. This program prints the number of arguments it received and also computes the length of the command line (assuming all arguments were separated by just one space character):\n\nNow let’s see what happens when we compile these two programs with Turbo C++ and with DJGPP. First, let’s build both with Turbo C++ and run the entry point:\n\nRunning fails because the command line is too long and cannot process it. (I’m not exactly sure why returns because the Turbo C++ documentation claims that this function should return on this condition, but alas.)\n\nNow, let’s build just with DJGPP and run it:\n\nWe get a bit further now! runs successfully and executes … but claims that the command line is shorter than we expect. This is because DJGPP’s implementation knew that it was running a standard DOS application not built by DJGPP, so it had to place a truncated command line in the system call issued to DOS. (As a detail also note that this shows 141 and not 126: the reason for this is that DOS does not place on the command line, but the C runtime has to synthesize this value.)\n\nBut now look at what happens when we also compile with DJGPP:\n\nTa-da! When runs, it now sees the full command line. This is because now knows that understands the transfer buffer arrangement and can send the command line to it this way.\n\nYou can read more about this in the spawn documentation from DJGPP’s libc and peek at the dosexec.c sources.\n\nLet’s move on to one more Unix-y thing that DJGPP has to deal with, which is paths and file names. You see, paths are paths in both DOS and Unix: a sequence of directory names (like ) followed by an optional file name (like ). Unfortunately, DOS and Unix paths differ in two aspects.\n\nThe first is that DOS paths separate directory components with a backslash, not a forward slash. This is a historical artifact of the early CP/M and DOS days, where command-line flags used the forward slash ( ) instead of Unix’s dash ( ). When DOS gained support for directories in its 2.0 release, it had to pick a different character to separate directories, and it picked the backslash. Dealing with this duality in DJGPP-built programs seems easy: just make DJGPP’s libc functions allow both and call it a day. And for the most part, this works—and in fact even PowerShell does this on Windows today.\n\nThe second is that DOS paths may include an optional drive name such as and… the drive name has the colon character in it. While Unix uses the colon character to separate multiple components of the search , DOS could not do that: it had to pick a different character, and it picked the semicolon. Take a look:\n\nThe problem here is that many Unix applications, particularly shell scripts like —especially —read the value of the variable and split it at colon separators or append to it by adding a colon. But if we do these textual manipulations on a DOS-style like the one shown above… we’ll get the wrong behavior because of the drive names—and Unix programs don’t know they have to split on the semicolon instead and we cannot be expected to fix them all.\n\nThe way DJGPP deals with this is by faking the device tree. While DJGPP provides implementations of things like , it also exposes DOS drives via their corresponding virtual directory. So, if you wanted to run applications that parse or modify the , you could rewrite the above as this:\n\nThis would allow any application reading the to continue to work. But note that this value doesn’t seem to leave the realm of the current process, which is interesting:\n\nThe picture above shows how bash sees a DOS-style after it starts. Manually setting it to a Unix path keeps the Unix path in the current process (as shown by the built-in calls), but when we spawn a different one ( is a separate executable), the value is reset. This makes sense because, if we are running a regular DOS program from within a DJGPP one, we want to export a DOS-compatible environment. Which means the Unix variants probably only stick within shell scripts. You can also see how this works by peeking at again.\n\nBut wait a minute… did I just show you bash?! On DOS? Oh yes, yes I did…\n\nTrying it out yourself\n\nIt’s time to get our hands dirty, try this out, and reminisce the old days! Or, actually, not so old. You should know that DJGPP is still available in this day and age and that it is quite up to date with GCC 12.3—released less than a year ago.\n\nFirst off, start by installing DOSBox. You can use the standard DOSBox version, but it’s probably better to go the DOSBox-X route so that you can get Long File Name (LFN) support by setting the configuration option. Otherwise, beware that running Bash later on will create under but the file will be named due to some odd truncation, and this will later confuse Bash on a second start and assume that is actually .\n\nNow, pick a mirror for your downloads. You’ll see various uses of FTP in the list but don’t be surprised if clicking on those doesn’t work: major browsers have unfortunately dropped their FTP client so you’ll have to “fall back” to an HTTP mirror.\n\nFrom there, you can use the Zip Picker to help you choose what you need or you can download the same files I did:\n• None : The RHIDE console IDE akin to Turbo C++.\n• None : GDB because why not.\n• None : grep because I find it very handy.\n• None : Various shell utilities (like and ) that you’ll almost-certainly need to run shell scripts.\n\nOnce you have those files, create the “root” directory for what will be the drive in DOSBox. I keep this under and it is much easier to prepare this directory from outside of DOSBox. Within that location, create a subdirectory and unpack all the zip files you downloaded into it. If there are any file conflicts, just tell unzip to overwrite them.\n\nOnce the unpacking finishes, go to your DOSBox configuration. If you are on Windows, you should have a start menu entry called “DOSBox 0.74-3 Options” or similar which opens the configuration file in Notepad. If you are on Linux or any other reasonable OS, you can find the configuration file under . In the configuration, you’ll want to set up the drive at the very bottom of the file where the section is. Here is what I do:\n\nLaunch DOSBox and you are set. Enter full-screen by pressing for the full retro experience and then… launch :"
    },
    {
        "link": "https://delorie.com/djgpp",
        "document": "DJGPP is a complete 32-bit C/C++ development system for Intel 80386 (and higher) PCs running DOS. It includes ports of many GNU development utilities. The development tools require a 80386 or newer computer to run, as do the programs they produce. In most cases, the programs it produces can be sold commercially without license or royalties."
    },
    {
        "link": "https://nullprogram.com/blog/2014/12/09",
        "document": "How to build DOS COM files with GCC\n\nUpdate 2018: RenéRebe builds upon this article in an interesting follow-up video (part 2).\n\nUpdate 2020: DOS Defender was featured on GET OFF MY LAWN.\n\nThis past weekend I participated in Ludum Dare #31. Before the theme was even announced, due to recent fascination I wanted to make an old school DOS game. DOSBox would be the target platform since it’s the most practical way to run DOS applications anymore, despite modern x86 CPUs still being fully backwards compatible all the way back to the 16-bit 8086.\n\nI successfully created and submitted a DOS game called DOS Defender. It’s a 32-bit 80386 real mode DOS COM program. All assets are embedded in the executable and there are no external dependencies, so the entire game is packed into that 10kB binary.\n\nYou’ll need a joystick/gamepad in order to play. I included mouse support in the Ludum Dare release in order to make it easier to review, but this was removed because it doesn’t work well.\n\nThe most technically interesting part is that I didn’t need any DOS development tools to create this! I only used my every day Linux C compiler ( ). It’s not actually possible to build DOS Defender in DOS. Instead, I’m treating DOS as an embedded platform, which is the only form in which DOS still exists today. Along with DOSBox and DOSEMU, this is a pretty comfortable toolchain.\n\nIf all you care about is how to do this yourself, skip to the “Tricking GCC” section, where we’ll write a “Hello, World” DOS COM program with Linux’s GCC.\n\nI didn’t have GCC in mind when I started this project. What really triggered all of this was that I had noticed Debian’s bcc package, Bruce’s C Compiler, that builds 16-bit 8086 binaries. It’s kept around for compiling x86 bootloaders and such, but it can also be used to compile DOS COM files, which was the part that interested me.\n\nFor some background: the Intel 8086 was a 16-bit microprocessor released in 1978. It had none of the fancy features of today’s CPU: no memory protection, no floating point instructions, and only up to 1MB of RAM addressable. All modern x86 desktops and laptops can still pretend to be a 40-year-old 16-bit 8086 microprocessor, with the same limited addressing and all. That’s some serious backwards compatibility. This feature is called real mode. It’s the mode in which all x86 computers boot. Modern operating systems switch to protected mode as soon as possible, which provides virtual addressing and safe multi-tasking. DOS is not one of these operating systems.\n\nUnfortunately, bcc is not an ANSI C compiler. It supports a subset of K&R C, along with inline x86 assembly. Unlike other 8086 C compilers, it has no notion of “far” or “long” pointers, so inline assembly is required to access other memory segments (VGA, clock, etc.). Side note: the remnants of these 8086 “long pointers” still exists today in the Win32 API: , , , etc. The inline assembly isn’t anywhere near as nice as GCC’s inline assembly. The assembly code has to manually load variables from the stack so, since bcc supports two different calling conventions, the assembly ends up being hard-coded to one calling convention or the other.\n\nGiven all its limitations, I went looking for alternatives.\n\nDJGPP is the DOS port of GCC. It’s a very impressive project, bringing almost all of POSIX to DOS. The DOS ports of many programs are built with DJGPP. In order to achieve this, it only produces 32-bit protected mode programs. If a protected mode program needs to manipulate hardware (i.e. VGA), it must make requests to a DOS Protected Mode Interface (DPMI) service. If I used DJGPP, I couldn’t make a single, standalone binary as I had wanted, since I’d need to include a DPMI server. There’s also a performance penalty for making DPMI requests.\n\nGetting a DJGPP toolchain working can be difficult, to put it kindly. Fortunately I found a useful project, build-djgpp, that makes it easy, at least on Linux.\n\nEither there’s a serious bug or the official DJGPP binaries have become infected again, because in my testing I kept getting the “Not COFF: check for viruses” error message when running my programs in DOSBox. To double check that it’s not an infection on my own machine, I set up a DJGPP toolchain on my Raspberry Pi, to act as a clean room. It’s impossible for this ARM-based device to get infected with an x86 virus. It still had the same problem, and all the binary hashes matched up between the machines, so it’s not my fault.\n\nSo given the DPMI issue and the above, I moved on.\n\nWhat I finally settled on is a neat hack that involves “tricking” GCC into producing real mode DOS COM files, so long as it can target 80386 (as is usually the case). The 80386 was released in 1985 and was the first 32-bit x86 microprocessor. GCC still targets this instruction set today, even in the x86-64 toolchain. Unfortunately, GCC cannot actually produce 16-bit code, so my main goal of targeting 8086 would not be achievable. This doesn’t matter, though, since DOSBox, my intended platform, is an 80386 emulator.\n\nIn theory this should even work unchanged with MinGW, but there’s a long-standing MinGW bug that prevents it from working right (“cannot perform PE operations on non PE output file”). It’s still do-able, and I did it myself, but you’ll need to drop the directive and add an extra step ( ).\n\nTo demonstrate how to do all this, let’s make a DOS “Hello, World” COM program using GCC on Linux.\n\nThere’s a significant burden with this technique: there will be no standard library. It’s basically like writing an operating system from scratch, except for the few services DOS provides. This means no or anything of the sort. Instead we’ll ask DOS to print a string to the terminal. Making a request to DOS means firing an interrupt, which means inline assembly!\n\nDOS has nine interrupts: 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x2F. The big one, and the one we’re interested in, is 0x21, function 0x09 (print string). Between DOS and BIOS, there are thousands of functions called this way. I’m not going to try to explain x86 assembly, but in short the function number is stuffed into register and interrupt 0x21 is fired. Function 0x09 also takes an argument, the pointer to the string to be printed, which is passed in registers and .\n\nHere’s the GCC inline assembly function. Strings passed to this function must be terminated with a . Why? Because DOS.\n\nThe assembly is declared because it has a side effect (printing the string). To GCC, the assembly is an opaque hunk, and the optimizer relies in the output/input/clobber constraints (the last three lines). For DOS programs like this, all inline assembly will have side effects. This is because it’s not being written for optimization but to access hardware and DOS, things not accessible to plain C.\n\nCare must also be taken by the caller, because GCC doesn’t know that the memory pointed to by is ever read. It’s likely the array that backs the string needs to be declared too. This is all foreshadowing into what’s to come: doing anything in this environment is an endless struggle against the optimizer. Not all of these battles can be won.\n\nNow for the main function. The name of this function shouldn’t matter, but I’m avoiding calling it since MinGW has a funny ideas about mangling this particular symbol, even when it’s asked not to.\n\nCOM files are limited to 65,279 bytes in size. This is because an x86 memory segment is 64kB and COM files are simply loaded by DOS to 0x0100 in the segment and executed. There are no headers, it’s just a raw binary. Since a COM program can never be of any significant size, and no real linking needs to occur (freestanding), the entire thing will be compiled as one translation unit. It will be one call to GCC with a bunch of options.\n\nHere are the essential compiler options.\n\nSince no standard libraries are in use, the only difference between gnu99 and c99 is that trigraphs are disabled (as they should be) and inline assembly can be written as instead of . It’s a no brainer. This project will be so closely tied to GCC that I don’t care about using GCC extensions anyway.\n\nI’m using to keep the compiled output as small as possible. It will also make the program run faster. This is important when targeting DOSBox because, by default, it will deliberately run as slow as a machine from the 1980’s. I want to be able to fit in that constraint. If the optimizer is causing problems, you may need to temporarily make this to determine if the problem is your fault or the optimizer’s fault.\n\nYou see, the optimizer doesn’t understand that the program will be running in real mode, and under its addressing constraints. It will perform all sorts of invalid optimizations that break your perfectly valid programs. It’s not a GCC bug since we’re doing crazy stuff here. I had to rework my code a number of times to stop the optimizer from breaking my program. For example, I had to avoid returning complex structs from functions because they’d sometimes be filled with garbage. The real danger here is that a future version of GCC will be more clever and will break more stuff. In this battle, is your friend.\n\nTh next option is , since there are no valid libraries for us to link against, even statically.\n\nThe options set the compiler to produce 80386 code. If I was writing a bootloader for a modern computer, targeting 80686 would be fine, too, but DOSBox is 80386.\n\nThe argument requires that GCC not emit code that calls built-in standard library helper functions. Sometimes instead of emitting code to do something, it emits code that calls a built-in function to do it, especially with math operators. This was one of the main problems I had with bcc, where this behavior couldn’t be disabled. This is most commonly used in writing bootloaders and kernels. And now DOS COM files.\n\nThe option is used to pass arguments to the linker ( ). We need it since we’re doing all this in one call to GCC.\n\nThe turns off page alignment of sections. One, we don’t need this. Two, that would waste precious space. In my tests it doesn’t appear to be necessary, but I’m including it just in case.\n\nThe option tells the linker that we want to use a custom linker script. This allows us to precisely lay out the sections ( , , , ) of our program. Here’s the script.\n\nThe says not to put this into an ELF (or PE, etc.) file. The linker should just dump the raw code. A COM file is just raw code, so this means the linker will produce a COM file!\n\nI had said that COM files are loaded to . The fourth line offsets the binary to this location. The first byte of the COM file will still be the first byte of code, but it will be designed to run from that offset in memory.\n\nWhat follows is all the sections, (program), (static data), (zero-initialized data), (strings). Finally I mark the end of the binary with the symbol . This will come in handy later for writing , after we’re done with “Hello, World.” I’ve asked for the position to be 4-byte aligned.\n\nThe linker is usually aware of our entry point ( ) and sets that up for us. But since we asked for “binary” output, we’re on our own. If the function is emitted first, our program’s execution will begin with executing that function, which is invalid. Our program needs a little header stanza to get things started.\n\nThe linker script has a option for handling this, but to keep it simple we’ll put that right in the program. This is usually called or , in case those names every come up in your own reading. This inline assembly must be the very first thing in our code, before any includes and such. DOS will do most of the setup for us, we really just have to jump to the entry point.\n\nThe tells the assembler that we’re going to be running in real mode, so that it makes the proper adjustment. Despite the name, this will not make it produce 16-bit code! First it calls , the function we wrote above. Then it informs DOS, using function (terminate with return code), that we’re done, passing the exit code along in the 1-byte register (already set by ). This inline assembly is automatically because it has no inputs or outputs.\n\nEverything at Once\n\nAnd testing it in DOSBox:\n\nFrom here if you want fancy graphics, it’s just a matter of making an interrupt and writing to VGA memory. If you want sound you can perform an interrupt for the PC speaker. I haven’t sorted out how to call Sound Blaster yet. It was from this point that I grew DOS Defender.\n\nTo cover one more thing, remember that symbol? We can use it to implement for dynamic memory allocation within the main program segment. This is real mode, and there’s no virtual memory, so we’re free to write to any memory we can address at any time. Some of this is reserved (i.e. low and high memory) for hardware. So using specifically isn’t really necessary, but it’s interesting to implement ourselves.\n\nAs is normal on x86, your text and segments are at a low address (0x0100 in this case) and the stack is at a high address (around 0xffff in this case). On Unix-like systems, the memory returned by comes from two places: and . What does is allocates memory just above the text/data segments, growing “up” towards the stack. Each call to will grow this space (or leave it exactly the same). That memory would then managed by and friends.\n\nHere’s how we can get in a COM program. Notice I have to define my own , since we don’t have a standard library.\n\nIt just sets a pointer to and grows it as needed. A slightly smarter would be careful about alignment as well.\n\nIn the making of DOS Defender an interesting thing happened. I was (incorrectly) counting on the memory return by my being zeroed. This was the case the first time the game ran. However, DOS doesn’t zero this memory between programs. When I would run my game again, it would pick right up where it left off, because the same data structures with the same contents were loaded back into place. A pretty cool accident! It’s part of what makes this a fun embedded platform."
    },
    {
        "link": "https://nullprogram.com/blog/2014/12/09",
        "document": "How to build DOS COM files with GCC\n\nUpdate 2018: RenéRebe builds upon this article in an interesting follow-up video (part 2).\n\nUpdate 2020: DOS Defender was featured on GET OFF MY LAWN.\n\nThis past weekend I participated in Ludum Dare #31. Before the theme was even announced, due to recent fascination I wanted to make an old school DOS game. DOSBox would be the target platform since it’s the most practical way to run DOS applications anymore, despite modern x86 CPUs still being fully backwards compatible all the way back to the 16-bit 8086.\n\nI successfully created and submitted a DOS game called DOS Defender. It’s a 32-bit 80386 real mode DOS COM program. All assets are embedded in the executable and there are no external dependencies, so the entire game is packed into that 10kB binary.\n\nYou’ll need a joystick/gamepad in order to play. I included mouse support in the Ludum Dare release in order to make it easier to review, but this was removed because it doesn’t work well.\n\nThe most technically interesting part is that I didn’t need any DOS development tools to create this! I only used my every day Linux C compiler ( ). It’s not actually possible to build DOS Defender in DOS. Instead, I’m treating DOS as an embedded platform, which is the only form in which DOS still exists today. Along with DOSBox and DOSEMU, this is a pretty comfortable toolchain.\n\nIf all you care about is how to do this yourself, skip to the “Tricking GCC” section, where we’ll write a “Hello, World” DOS COM program with Linux’s GCC.\n\nI didn’t have GCC in mind when I started this project. What really triggered all of this was that I had noticed Debian’s bcc package, Bruce’s C Compiler, that builds 16-bit 8086 binaries. It’s kept around for compiling x86 bootloaders and such, but it can also be used to compile DOS COM files, which was the part that interested me.\n\nFor some background: the Intel 8086 was a 16-bit microprocessor released in 1978. It had none of the fancy features of today’s CPU: no memory protection, no floating point instructions, and only up to 1MB of RAM addressable. All modern x86 desktops and laptops can still pretend to be a 40-year-old 16-bit 8086 microprocessor, with the same limited addressing and all. That’s some serious backwards compatibility. This feature is called real mode. It’s the mode in which all x86 computers boot. Modern operating systems switch to protected mode as soon as possible, which provides virtual addressing and safe multi-tasking. DOS is not one of these operating systems.\n\nUnfortunately, bcc is not an ANSI C compiler. It supports a subset of K&R C, along with inline x86 assembly. Unlike other 8086 C compilers, it has no notion of “far” or “long” pointers, so inline assembly is required to access other memory segments (VGA, clock, etc.). Side note: the remnants of these 8086 “long pointers” still exists today in the Win32 API: , , , etc. The inline assembly isn’t anywhere near as nice as GCC’s inline assembly. The assembly code has to manually load variables from the stack so, since bcc supports two different calling conventions, the assembly ends up being hard-coded to one calling convention or the other.\n\nGiven all its limitations, I went looking for alternatives.\n\nDJGPP is the DOS port of GCC. It’s a very impressive project, bringing almost all of POSIX to DOS. The DOS ports of many programs are built with DJGPP. In order to achieve this, it only produces 32-bit protected mode programs. If a protected mode program needs to manipulate hardware (i.e. VGA), it must make requests to a DOS Protected Mode Interface (DPMI) service. If I used DJGPP, I couldn’t make a single, standalone binary as I had wanted, since I’d need to include a DPMI server. There’s also a performance penalty for making DPMI requests.\n\nGetting a DJGPP toolchain working can be difficult, to put it kindly. Fortunately I found a useful project, build-djgpp, that makes it easy, at least on Linux.\n\nEither there’s a serious bug or the official DJGPP binaries have become infected again, because in my testing I kept getting the “Not COFF: check for viruses” error message when running my programs in DOSBox. To double check that it’s not an infection on my own machine, I set up a DJGPP toolchain on my Raspberry Pi, to act as a clean room. It’s impossible for this ARM-based device to get infected with an x86 virus. It still had the same problem, and all the binary hashes matched up between the machines, so it’s not my fault.\n\nSo given the DPMI issue and the above, I moved on.\n\nWhat I finally settled on is a neat hack that involves “tricking” GCC into producing real mode DOS COM files, so long as it can target 80386 (as is usually the case). The 80386 was released in 1985 and was the first 32-bit x86 microprocessor. GCC still targets this instruction set today, even in the x86-64 toolchain. Unfortunately, GCC cannot actually produce 16-bit code, so my main goal of targeting 8086 would not be achievable. This doesn’t matter, though, since DOSBox, my intended platform, is an 80386 emulator.\n\nIn theory this should even work unchanged with MinGW, but there’s a long-standing MinGW bug that prevents it from working right (“cannot perform PE operations on non PE output file”). It’s still do-able, and I did it myself, but you’ll need to drop the directive and add an extra step ( ).\n\nTo demonstrate how to do all this, let’s make a DOS “Hello, World” COM program using GCC on Linux.\n\nThere’s a significant burden with this technique: there will be no standard library. It’s basically like writing an operating system from scratch, except for the few services DOS provides. This means no or anything of the sort. Instead we’ll ask DOS to print a string to the terminal. Making a request to DOS means firing an interrupt, which means inline assembly!\n\nDOS has nine interrupts: 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x2F. The big one, and the one we’re interested in, is 0x21, function 0x09 (print string). Between DOS and BIOS, there are thousands of functions called this way. I’m not going to try to explain x86 assembly, but in short the function number is stuffed into register and interrupt 0x21 is fired. Function 0x09 also takes an argument, the pointer to the string to be printed, which is passed in registers and .\n\nHere’s the GCC inline assembly function. Strings passed to this function must be terminated with a . Why? Because DOS.\n\nThe assembly is declared because it has a side effect (printing the string). To GCC, the assembly is an opaque hunk, and the optimizer relies in the output/input/clobber constraints (the last three lines). For DOS programs like this, all inline assembly will have side effects. This is because it’s not being written for optimization but to access hardware and DOS, things not accessible to plain C.\n\nCare must also be taken by the caller, because GCC doesn’t know that the memory pointed to by is ever read. It’s likely the array that backs the string needs to be declared too. This is all foreshadowing into what’s to come: doing anything in this environment is an endless struggle against the optimizer. Not all of these battles can be won.\n\nNow for the main function. The name of this function shouldn’t matter, but I’m avoiding calling it since MinGW has a funny ideas about mangling this particular symbol, even when it’s asked not to.\n\nCOM files are limited to 65,279 bytes in size. This is because an x86 memory segment is 64kB and COM files are simply loaded by DOS to 0x0100 in the segment and executed. There are no headers, it’s just a raw binary. Since a COM program can never be of any significant size, and no real linking needs to occur (freestanding), the entire thing will be compiled as one translation unit. It will be one call to GCC with a bunch of options.\n\nHere are the essential compiler options.\n\nSince no standard libraries are in use, the only difference between gnu99 and c99 is that trigraphs are disabled (as they should be) and inline assembly can be written as instead of . It’s a no brainer. This project will be so closely tied to GCC that I don’t care about using GCC extensions anyway.\n\nI’m using to keep the compiled output as small as possible. It will also make the program run faster. This is important when targeting DOSBox because, by default, it will deliberately run as slow as a machine from the 1980’s. I want to be able to fit in that constraint. If the optimizer is causing problems, you may need to temporarily make this to determine if the problem is your fault or the optimizer’s fault.\n\nYou see, the optimizer doesn’t understand that the program will be running in real mode, and under its addressing constraints. It will perform all sorts of invalid optimizations that break your perfectly valid programs. It’s not a GCC bug since we’re doing crazy stuff here. I had to rework my code a number of times to stop the optimizer from breaking my program. For example, I had to avoid returning complex structs from functions because they’d sometimes be filled with garbage. The real danger here is that a future version of GCC will be more clever and will break more stuff. In this battle, is your friend.\n\nTh next option is , since there are no valid libraries for us to link against, even statically.\n\nThe options set the compiler to produce 80386 code. If I was writing a bootloader for a modern computer, targeting 80686 would be fine, too, but DOSBox is 80386.\n\nThe argument requires that GCC not emit code that calls built-in standard library helper functions. Sometimes instead of emitting code to do something, it emits code that calls a built-in function to do it, especially with math operators. This was one of the main problems I had with bcc, where this behavior couldn’t be disabled. This is most commonly used in writing bootloaders and kernels. And now DOS COM files.\n\nThe option is used to pass arguments to the linker ( ). We need it since we’re doing all this in one call to GCC.\n\nThe turns off page alignment of sections. One, we don’t need this. Two, that would waste precious space. In my tests it doesn’t appear to be necessary, but I’m including it just in case.\n\nThe option tells the linker that we want to use a custom linker script. This allows us to precisely lay out the sections ( , , , ) of our program. Here’s the script.\n\nThe says not to put this into an ELF (or PE, etc.) file. The linker should just dump the raw code. A COM file is just raw code, so this means the linker will produce a COM file!\n\nI had said that COM files are loaded to . The fourth line offsets the binary to this location. The first byte of the COM file will still be the first byte of code, but it will be designed to run from that offset in memory.\n\nWhat follows is all the sections, (program), (static data), (zero-initialized data), (strings). Finally I mark the end of the binary with the symbol . This will come in handy later for writing , after we’re done with “Hello, World.” I’ve asked for the position to be 4-byte aligned.\n\nThe linker is usually aware of our entry point ( ) and sets that up for us. But since we asked for “binary” output, we’re on our own. If the function is emitted first, our program’s execution will begin with executing that function, which is invalid. Our program needs a little header stanza to get things started.\n\nThe linker script has a option for handling this, but to keep it simple we’ll put that right in the program. This is usually called or , in case those names every come up in your own reading. This inline assembly must be the very first thing in our code, before any includes and such. DOS will do most of the setup for us, we really just have to jump to the entry point.\n\nThe tells the assembler that we’re going to be running in real mode, so that it makes the proper adjustment. Despite the name, this will not make it produce 16-bit code! First it calls , the function we wrote above. Then it informs DOS, using function (terminate with return code), that we’re done, passing the exit code along in the 1-byte register (already set by ). This inline assembly is automatically because it has no inputs or outputs.\n\nEverything at Once\n\nAnd testing it in DOSBox:\n\nFrom here if you want fancy graphics, it’s just a matter of making an interrupt and writing to VGA memory. If you want sound you can perform an interrupt for the PC speaker. I haven’t sorted out how to call Sound Blaster yet. It was from this point that I grew DOS Defender.\n\nTo cover one more thing, remember that symbol? We can use it to implement for dynamic memory allocation within the main program segment. This is real mode, and there’s no virtual memory, so we’re free to write to any memory we can address at any time. Some of this is reserved (i.e. low and high memory) for hardware. So using specifically isn’t really necessary, but it’s interesting to implement ourselves.\n\nAs is normal on x86, your text and segments are at a low address (0x0100 in this case) and the stack is at a high address (around 0xffff in this case). On Unix-like systems, the memory returned by comes from two places: and . What does is allocates memory just above the text/data segments, growing “up” towards the stack. Each call to will grow this space (or leave it exactly the same). That memory would then managed by and friends.\n\nHere’s how we can get in a COM program. Notice I have to define my own , since we don’t have a standard library.\n\nIt just sets a pointer to and grows it as needed. A slightly smarter would be careful about alignment as well.\n\nIn the making of DOS Defender an interesting thing happened. I was (incorrectly) counting on the memory return by my being zeroed. This was the case the first time the game ran. However, DOS doesn’t zero this memory between programs. When I would run my game again, it would pick right up where it left off, because the same data structures with the same contents were loaded back into place. A pretty cool accident! It’s part of what makes this a fun embedded platform."
    },
    {
        "link": "https://stackoverflow.com/questions/27443069/why-cant-programs-compiled-using-gcc-be-run-using-dosbox-while-those-compiled-u",
        "document": "Years ago,I had created a program using TurboC IDE and This program can also be run using DOSbox. Now,when I tried to run any program which was compiled using GCC in DOSbox,this message came:\n\nSo my question is,Why isn't it possible to run programs compiled using GCC in DOSbox,while those compiled from TurboC are?\n\nPS:The reason that I want to run them in DOSbox is that I want to run those programs in my phone(which has DOSbox installed)."
    },
    {
        "link": "https://stackoverflow.com/questions/4370813/using-gcc-on-mac-os-to-compile-c-program-for-ms-dos-dosbox",
        "document": "DOSBox runs 16 bit x86 real-mode code under emulation. The regular GCC compiler on OSX 10.6 targets the OSX operating system and 32 bit x86 protected mode, so you cannot use that to build code to run in DOSBox.\n\nWhat you may be able to do is run a DOS compiler in DOSBox itself. DJGPP is an MS-DOS port of GCC, however it generates 32bit protected mode code targetted at the DPMI subsystem. It is not clear to me that DOSBox supports DPMI, but I imagine that it does, and DJGPP itself is in the DOSBox compatability list, so one would imagine that the code it generates might run also if it does not do anything too out of the ordinary to the emulated hardware.\n\nBorland Turbo C is also on the compatability list, and TC 2.01 is legitimately available for free. Other versions are offered for download elsewhare, but I doubt the legality of such distribution.\n\nA more robust solution however is probably to install a genuine MS-DOS or DOS compatible OS in a Virtual Machine hosted on OSX using VirtualBox. If you do not have a copy of MS-DOS, you might try FreeDOS."
    },
    {
        "link": "https://wikihow.com/Compile-a-C-Program-Using-the-GNU-Compiler-(GCC)",
        "document": "The complete guide to compiling C code with GCC on Linux and Windows Are you ready to turn your C code into an executable program? The GNU C compiler, also known as GCC, is a simple Linux-based C compiler that's easy to use from the command line. If you're using Linux, including Ubuntu, Fedora, and Linux Mint, you can install GCC from your distribution's package manager. On Windows 10 and 11, you can use GCC in a Windows Subsystem for Linux (WSL) shell, or by installing an open source tool called MinGW. This wikiHow guide will teach you the easiest ways to compile a C program from source code using GCC.\n• Building your code with a -g flag will produce debugging information which the corresponding debugger program, GDB, can use to make debugging work better.\n• Makefiles can be created to make it easier to compile large programs.\n• If you use optimizations heavily, be aware that optimization for speed may come with a trade off in size and sometimes accuracy, and vice versa. Show More Tips All tip submissions are carefully reviewed before being published Please provide your name and last initial Thanks for submitting a tip for review!"
    },
    {
        "link": "https://quora.com/How-do-I-successfully-compile-and-run-C-program-from-the-DOS-command-prompt",
        "document": "Something went wrong. Wait a moment and try again."
    }
]