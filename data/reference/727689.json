[
    {
        "link": "https://geeksforgeeks.org/bubble-sort-algorithm",
        "document": "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity are quite high.\n• None We sort the array using multiple passes. After the first pass, the maximum element goes to end (its correct position). Same way, after second pass, the second largest element goes to second last position and so on.\n• None In every pass, we process only those elements that have already not moved to correct position. After k passes, the largest k elements must have been moved to the last k positions.\n• None In a pass, we consider remaining elements and compare all adjacent and swap if larger element is before a smaller element. If we keep doing this, we get the largest (among the remaining elements) at its correct position.\n\nBelow is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn’t cause any swap.\n\n// If no two elements were swapped, then break // If no two elements were swapped by inner loop, // If no two elements were // swapped by inner loop, then break # Last i elements are already in place # Traverse the array from 0 to n-i-1 # Swap if the element found is greater // If no two elements were // swapped by inner loop, then break // IF no two elements were // swapped by inner loop, then break // Last i elements are already // Traverse the array from 0 to // found is greater than the // If no two elements were swapped // by inner loop, then break // This code is contributed by ChitraNayal.\n• None Bubble sort is easy to understand and implement.\n• None It does not require any additional memory space.\n• None It is a stable sorting algorithm, meaning that elements with the same key value maintain their relative order in the sorted output.\n• None Bubble sort has a time complexity of O(n ) which makes it very slow for large data sets.\n• None Bubble sort has almost no or limited real world applications. It is mostly used in academics to teach different ways of sorting.\n\nWhat is the Boundary Case for Bubble sort?\n\nDoes sorting happen in place in Bubble sort?"
    },
    {
        "link": "https://youcademy.org/bubble-sort-java",
        "document": "Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. This process is repeated until no swaps are needed, which indicates that the list is sorted. In this article, we’ll start with a basic version of the bubble sort algorithm in Java to sort a list of numbers in ascending order. We’ll then explore several variations, including sorting in descending order, optimizing the algorithm for better performance, and sorting custom objects.\n\nLet’s start with a standard version of bubble sort in Java. This version will sort a list of numbers from smallest to largest.\n• The method takes an integer array as input.\n• stores the length of the array.\n• The outer loop iterates from to . Each pass makes sure the largest unsorted element “bubbles up” to its correct spot at the end of the array.\n• The inner loop goes from to , comparing items that are next to each other.\n• If is bigger than , they are swapped using a temporary variable .\n• The method is a helper function to show the array’s contents.\n\nTo sort from largest to smallest, you only need to change the comparison in the inner loop.\n\nThe main difference here is the condition. Instead of swapping if the current element is greater than the next, we swap if it’s less than the next, effectively sorting in reverse order.\n\nWe can make bubble sort faster by stopping it early if no swaps happen during a pass. If no swaps occur, it means the array is already sorted.\n• A boolean variable is used. It starts as at the beginning of each pass (outer loop).\n• If a swap happens in the inner loop, becomes .\n• After each pass, if is still , no swaps were made. This means the array is sorted as all adjacent elements are relatively in order, and we can stop the outer loop using .\n\nTo sort objects you’ve created, you need to tell Java how to compare them. You can do this using the interface or a . Let’s explore how to sort using . Using a is useful because it lets you define different ways to sort objects without changing the object’s class itself.\n• The class no longer implements the interface.\n• A is created using . This creates a comparator that compares objects based on their age. The method is used for comparing integer values, and is a lambda expression that extracts the age from a object.\n• The method now takes an array of objects and a as arguments.\n• The comparison inside the inner loop uses to compare objects using the provided comparator.\n• We pass the to the method to sort the array by age.\n\nNow that you’ve learned how to implement bubble sort in Java, you might want to explore:\n• Understand the Advantages and Disadvantages of Bubble Sort Algorithm.\n• Learn about common mistakes and how to avoid them\n• Study the time and space complexity analysis to understand performance characteristics.\n• Compare it with other sorting algorithms to know when to use bubble sort."
    },
    {
        "link": "https://ioflood.com/blog/bubble-sort-java",
        "document": "Are you finding it challenging to implement bubble sort in Java? You’re not alone. Many developers find themselves puzzled when it comes to handling sorting algorithms in Java, but we’re here to help.\n\nThink of bubble sort as a meticulous librarian – it helps to bring order to your data, making it easier for you to find what you’re looking for. Bubble sort is a simple and intuitive sorting algorithm, but it’s essential to understand its ins and outs for efficient usage.\n\nThis guide will walk you through the process of implementing bubble sort in Java, from the basics to more advanced techniques. We’ll cover everything from understanding the algorithm, writing the code, to optimizing it for better performance.\n\nSo, let’s dive in and start mastering bubble sort in Java!\n\nTL;DR: How Do I Implement Bubble Sort in Java?\n\nIn this function, is used to compare two Strings. If the current string comes after the next string lexicographically, they are swapped. This process continues until the array is sorted in lexicographic order.\n\nBubble sort is a simple sorting algorithm that works by repeatedly stepping through the list, comparing each pair of adjacent items, and swapping them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\n\nLet’s break down how bubble sort works with a simple Java implementation.\n\nIn this code, we start with a function called that takes an array of integers as an argument. The outer loop runs from the first element to the last, and the inner loop compares each pair of elements. If the current element ( ) is greater than the next element ( ), they are swapped. This process continues until the array is sorted.\n\nThe time complexity of Bubble Sort is O(n^2) in both average and worst-case scenarios, where n is the number of items being sorted. This makes it inefficient on large lists, and generally it is used only for educational purposes or small lists where its inefficiency is not a high penalty.\n\nIn the next section, we’ll look at how to optimize this algorithm to improve its efficiency.\n\nWhile bubble sort is simple to understand and implement, it’s not the most efficient sorting algorithm. However, with a few tweaks, we can optimize it to improve its performance.\n\nOne common optimization is to use a boolean variable to check if any swapping occurred in a pass. If no swapping occurred, it means the array is already sorted, and we can skip the remaining passes.\n\nHere’s an example of an optimized bubble sort in Java:\n\nIn this code, we’ve added a variable that is set to whenever we make a swap. If we finish a pass without making any swaps ( is still ), we break out of the loop early, saving unnecessary iterations.\n\nWhile this optimization doesn’t change the worst-case time complexity (still O(n^2)), it can significantly improve the best-case time complexity to O(n) when the input array is already sorted or nearly sorted. This makes bubble sort more efficient in certain scenarios, but there are still more efficient sorting algorithms for general use, which we’ll discuss in the next section.\n\nWhile bubble sort is a great starting point for understanding sorting algorithms, there are several other algorithms that offer better performance in many scenarios. Two such algorithms are Quick Sort and Merge Sort.\n\nQuick sort is a divide-and-conquer algorithm that works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. Here’s a simple implementation of quick sort in Java:\n\nMerge sort is another divide-and-conquer algorithm that works by dividing the unsorted list into n sublists, each containing one element (a list of one element is considered sorted), and then repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining. Here’s a simple implementation of merge sort in Java:\n\nAs you can see, both quick sort and merge sort offer better average and worst-case performance than bubble sort. However, they are also more complex and can be more difficult to understand and implement. Therefore, while bubble sort may not be the most efficient sorting algorithm, it’s a valuable tool for learning the basics of how sorting algorithms work.\n\nEven with a straightforward algorithm like bubble sort, it’s common to encounter issues during implementation. One of the most common problems is the off-by-one error. This error typically occurs when you access an array out of its bounds, leading to unexpected results or a runtime error.\n\nConsider this incorrect implementation of bubble sort:\n\nIn this code, the inner loop attempts to access , which will be out of bounds on the last iteration. This will throw an .\n\nThe solution is to ensure the inner loop only runs up to , as in the correct implementation of bubble sort. This prevents the loop from going beyond the bounds of the array.\n\nBy understanding the common issues and their solutions, you can avoid these pitfalls and implement bubble sort correctly in your Java programs.\n\nSorting algorithms are fundamental to the field of computer science and have a wide range of applications in the real world. From organizing files on your computer to ranking search engine results, sorting algorithms are the invisible force that brings order to our digital world.\n\nA sorting algorithm is a method that takes a list or array of items and arranges them in a specific order. The order could be numerical (ascending or descending) or lexicographical (A-Z or Z-A).\n\nIn the code block above, we start with an unsorted array of integers. After applying a sorting algorithm, we get a new array where the integers are in ascending order.\n\nSorting algorithms play a crucial role in optimizing the efficiency of other algorithms. They make it easier to search for items, check for duplicates, and find the minimum or maximum values. Without efficient sorting, these tasks could take significantly longer, especially with large datasets.\n\nIn addition to their practical applications, sorting algorithms are also an excellent way to understand fundamental concepts in computer science, like algorithmic complexity, divide-and-conquer strategies, and data structures.\n\nIn the next section, we’ll explore how these concepts apply to bubble sort, a simple yet powerful sorting algorithm.\n\nThe Relevance of Sorting Algorithms: Beyond Code\n\nSorting algorithms, including bubble sort, hold a significant place in the realm of computer science education and coding interviews. They form the backbone of data structures and algorithm courses, and are often used as a yardstick to gauge a candidate’s problem-solving and coding skills.\n\nUnderstanding sorting algorithms is crucial for mastering data structures and algorithms – a core area of computer science. The study of sorting algorithms provides insight into algorithm design, complexity analysis, and problem-solving strategies. Implementing bubble sort in Java, for instance, allows you to understand the concept of nested loops and how to manipulate array indices.\n\nIn coding interviews, sorting algorithms are a common topic. They are used not only to test your coding skills but also to see how you approach problem-solving, how you handle edge cases, and how you optimize the solution. Having a firm grasp of sorting algorithms, including bubble sort, can give you an edge in these interviews.\n\nOnce you’re comfortable with sorting algorithms, you can explore related concepts like search algorithms and data structures. Search algorithms, such as binary search and depth-first search, are used to find specific items in data structures. Understanding these algorithms can help you write more efficient code.\n\nData structures, such as arrays, linked lists, and binary trees, are used to store and organize data in a way that makes it efficient to perform operations like sorting and searching. Learning about these data structures and how they interact with sorting algorithms can deepen your understanding of computer science.\n\nTo further your understanding of sorting algorithms, here are some resources that provide in-depth explanations and examples:\n• Beginner’s Guide to Java Stream – Master the use of Java streams for filtering, mapping, and reducing data elements.\n• None Selection Sort in Java: Basics – Discover how to implement the selection sort algorithm in Java for sorting arrays or lists\n• None Exploring Merge Sort in Java – Master Java merge sort implementation for improved performance in data processing.\n• None GeeksforGeeks’ Sorting Algorithms resource provides detailed tutorials on various sorting algorithms.\n• None Algorithms in Computer Science – A course on algorithms, including videos, practice exercises, and quizzes.\n• None Data Structures and Algorithms Specialization from Coursera covers data structures and algorithms.\n\nIn this comprehensive guide, we’ve delved into the process of implementing bubble sort in Java, starting from the basics and moving towards more advanced techniques. We’ve explored how this simple yet powerful sorting algorithm can be a great tool for understanding the workings of sorting algorithms.\n\nWe started with the basics, learning how to implement bubble sort in Java. We then delved into more advanced usage, such as optimizing the algorithm to improve its efficiency. We also discussed common issues that you might encounter when implementing bubble sort, such as off-by-one errors, and provided solutions to these problems.\n\nAdditionally, we explored other sorting algorithms that can be used in Java, such as quick sort and merge sort. We discussed the advantages and disadvantages of these algorithms compared to bubble sort, giving you a broader perspective of sorting algorithms in Java.\n\nWhether you’re just starting out with bubble sort or you’re looking to deepen your understanding of sorting algorithms, we hope this guide has been helpful. Bubble sort, with its simplicity, serves as a great starting point in the world of sorting algorithms. With the knowledge you’ve gained, you’re now better equipped to tackle more complex sorting algorithms. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/16195092/optimized-bubble-sort",
        "document": "First of all, you have an out-of-bounds access:\n\nfor , so the loop condition should rather be .\n\nBut, in Bubble sort, you know that after passes, the largest elements are sorted at the last entries of the array, so the conventional Bubble sort uses\n\nNow, that would still do a lot of unnecessary iterations when the array has a long sorted tail of largest elements, say you have as the first elements and to in order after that. The standard Bubble sort will pass times through (almost) the entire array.\n\nBut if you remember where you made your last swap, you know that after that index, there are the largest elements in order, so\n\nwould sort the above example with only one pass through the entire array, and the remaining passes only through a (short) prefix.\n\nOf course, in general, that won't buy you much, but then optimising a Bubble sort is a rather futile exercise anyway."
    },
    {
        "link": "https://simplilearn.com/tutorials/data-structure-tutorial/bubble-sort-algorithm",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html",
        "document": ""
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html",
        "document": "\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator. - if or (optional) if the comparator is found to violate the contract\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the class of the objects in the array - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the class of the objects in the array - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holdsand the operation performs addition, then upon return the array holds. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array within the specified range.\n• Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.\n• Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.\n• if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of longs areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of ints areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of shorts areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of chars areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of bytes areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of booleans areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of doubles areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of floats areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects and are considered equal if . In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of Objects areto one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objectsandare consideredif. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Assigns the specified long value to each element of the specified array of longs. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified array of ints. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified array of shorts. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified array of chars. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified array of bytes. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified array of booleans. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified array of doubles. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified array of floats. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified Object reference to each element of the specified array of Objects. - the array to be filled - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array to be copied - the length of the copy to be returned - the class of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length - if an element copied from is not of a runtime type that can be stored in an array of class\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with null characters to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with false elements to obtain the specified length\n• ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . Copies the specified range of the specified array into a new array. The initial index of the range () must lie between zero and, inclusive. The value atis placed into the initial element of the copy (unlessor). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (), which must be greater than or equal to, may be greater than, in which caseis placed in all elements of the copy whose index is greater than or equal to. The length of the returned array will be The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) - the class of the copy to be returned a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length - if an element copied from is not of a runtime type that can be stored in an array of class .\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length\n• Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with . The returned list is serializable and implements This method also provides a convenient way to create a fixed-size list initialized to contain several elements: - the class of the objects in the array - the array by which the list will be backed a list view of the specified array\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any two non-nullarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays and such that , it is also the case that . The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose content-based hash code to compute\n• Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays and such that , it is also the case that . The computation of the value returned by this method is similar to that of the value returned by on a list containing the same elements as in the same order, with one difference: If an element of is itself an array, its hash code is computed not by calling , but as by calling the appropriate overloading of if is an array of a primitive type, or as by calling recursively if is an array of a reference type. If is , this method returns 0. - the array whose deep-content-based hash code to compute\n• if the two specified arrays are deeply equal to one another. Unlike the Returnsif the two specified arrays areto one another. Unlike the method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are , or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly elements and are deeply equal if any of the following conditions hold:\n• and are both arrays of object reference types, and\n• and are arrays of the same primitive type, and the appropriate overloading of would return true. Note that this definition permits elements at any depth. Note that this definition permitselements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined. - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• , which describes their identities rather than their contents. Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method inherited from, which describes theirrather than their contents. The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose string representation to return\n• Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by , unless they are themselves arrays. If an element is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of . If an element is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string . For example, an array containing only a reference to itself would be rendered as . This method returns if the specified array is . - the array whose string representation to return\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use the spliterator for the array elements\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - The type of the array elements - The array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the type of the array elements - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use an for the array\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover an for the array range - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size"
    },
    {
        "link": "https://cs.usfca.edu/~cs272/javadoc/api/java.base/java/util/Arrays.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/3707190/why-does-javas-arrays-sort-method-use-two-different-sorting-algorithms-for-diff",
        "document": "The most likely reason: quicksort is not stable, i.e. equal entries can change their relative position during the sort; among other things, this means that if you sort an already sorted array, it may not stay unchanged.\n\nSince primitive types have no identity (there is no way to distinguish two ints with the same value), this does not matter for them. But for reference types, it could cause problems for some applications. Therefore, a stable merge sort is used for those.\n\nOTOH, a reason not to use the (guaranteed n*log(n)) stable merge sort for primitive types might be that it requires making a clone of the array. For reference types, where the referred objects usually take up far more memory than the array of references, this generally does not matter. But for primitive types, cloning the array outright doubles the memory usage."
    },
    {
        "link": "https://stackoverflow.com/questions/21219777/the-running-time-for-arrays-sort-method-in-java",
        "document": "It depends on what you are sorting and on your Java version. Sort methods for arrays of different types have different time and space complexities. There are also improvements in the latter Java versions.\n\nAs well as Arrays.sort(long[]), Arrays.sort(float[]) and Arrays.sort(double[])\n\nTime complexity of depends on the version of Java.\n\nA pretty ordinary quicksort was used with time complexity ranging from O(n) (when the array is already sorted and we are only checking that it is) to O(n2) for certain inputs that cause extremely uneven distribution of elements into parts with an average complexity of O(n log(n)). You can find a detailed analysis here.\n\nIn Java 14 the implementation was improved to guarantee the worst-case time complexity of O(n log(n)). The function was changed to resort to heapsort if recursion becomes too deep:\n\nwhich prevents the method from degrading to quadratic time complexity.\n\nThere is an initiative to switch to radix sort for almost random big enough arrays thus reducing the time complexity to O(n) in the worst-case.\n\nIn all versions, the algorithm has space complexity ranging from O(1) (when the array is already sorted and we only to check that it is) to O(n) (when the array is highly structured (there is a small number of sorted subarrays inside the original array and we merge those subarrays)).\n\nHere's where allocation happens in the worst case:\n\nWhile the question asks specifically about Arrays.sort(int[]) method I still decided to include answers for other data types since this is the first result when you look for Arrays.sort() time and space complexity in Google and it is not easy to find correct answers to this simple question in other places.\n\nAs well as Arrays.sort(char[]) and Arrays.sort(byte[])\n\nAlthough the documentation says:\n\nThis is not true at least starting from Java 7. Actually, an in-place counting sort used for big enough arrays, which has linear time complexity and constant space complexity:\n\nUnlike other methods, this one is well-documented and the documentation here corresponds to reality.\n\nThe algorithm used by java.util.Arrays.sort and (indirectly) by java.util.Collections.sort to sort object references is a \"modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist).\" It is a reasonably fast stable sort that guarantees O(n log n) performance and requires O(n) extra space."
    }
]