[
    {
        "link": "https://quicknode.com/guides/ethereum-development/smart-contracts/how-to-create-and-deploy-an-erc20-token",
        "document": "Ethereum network’s launch in 2015 created a lot of buzz in the developer community and sprouted a lot of tokens on the network. Initially, there weren’t any templates or guidelines for token development. This resulted in a variety of tokens quite different from each other. To bring this diversity to order, the community came up with an ERC-20 standard to make all tokens more or less uniform.\n• Learn about ERC-20 tokens and their use cases\n• Create and deploy an ERC-20 token using Remix.IDE\n• Test ETH (You can get some at the Multi-Chain QuickNode Faucet)\n\nERC stands for Ethereum Request for Comment, and 20 is the proposal identifier number. ERC-20 was designed to improve the Ethereum network.\n\nERC-20 is one of the most significant ERCs. It has emerged as the technical standard for writing smart contracts on the Ethereum blockchain network, used for token implementation. ERC-20 contains a set of rules that all Ethereum based tokens must follow.\n\nERC-20 defines tokens as blockchain-based assets that can be sent/received and have value. ERC-20 tokens are similar to Bitcoin and Litecoin in many aspects. However, the most significant difference is that instead of running on their own blockchain network, ERC-20 coins run on Ethereum’s blockchain network and use gas as the transaction fee.\n\nBefore the emergence of ERC-20, everyone who created tokens had to reinvent the wheel, which means all tokens were different from each other. For example, if a developer wanted to work with another token, they had to understand the entire smart contract code of that token due to the lack of any specific structure or guidelines for building new tokens. This was particularly painful for wallets and exchange platforms - adding different types of tokens required developers to go through the code of each and every token and understand it in order to handle those tokens on their platforms. Needless to say, it was rather difficult to add new tokens to any app. Today, wallets and exchanges use the ERC-20 standard to integrate various standardized tokens onto their platforms and also facilitate easy exchange between ERC-20 tokens and other tokens. The ERC-20 token standard has made interaction between tokens almost seamless and painless.\n\nStandardized Functions: ERC-20 tokens follow a specific set of standards, which means they have a common list of rules and functions. This includes how the tokens can be transferred, how transactions are approved, how users can access data about a token, and the total supply of tokens.\n\nSmart Contracts and DeFi: The use of smart contracts in ERC-20 tokens enables the automation and enforcement of complex financial operations. This is crucial for DeFi platforms, where these tokens can represent various financial instruments, like loans or stakes in a liquidity pool.\n\nInteroperability: Since ERC-20 tokens follow the same standard, they are easily interchangeable and can work seamlessly with other ERC-20-compliant tokens and applications on the Ethereum network. This standardization simplifies the process of creating new tokens and makes them instantly compatible with existing wallets, exchanges, and other services.\n\nUse Cases: ERC-20 tokens can represent a wide range of assets or utilities. For example, ERC-20 tokens can serve various roles, such as collateral for loans, interest-bearing assets in yield farming, and governance tokens granting voting rights in decentralized autonomous organizations (DAOs).\n\nTransferability and Exchange: These tokens can be transferred from one account to another as payment, similar to cryptocurrencies like Bitcoin, and can be traded on various cryptocurrency exchanges.\n\nERC-20 is a standard or guideline for creating new tokens. The standard defines six mandatory functions that a smart contract should implement and three optional ones.\n\nThe mandatory functions are listed below with explanations.\n• totalSupply: A method that defines the total supply of your tokens; when this limit is reached, the smart contract will refuse to create new tokens.\n• balanceOf: A method that returns the number of tokens a wallet address has.\n• transfer: A method that takes a certain amount of tokens from the total supply and gives it to a user.\n• transferFrom: Another type of transfer method that is used to transfer tokens between users.\n• approve: This method verifies whether a smart contract is allowed to allocate a certain amount of tokens to a user, considering the total supply.\n• allowance: This method is exactly the same as the approved method except that it checks if one user has enough balance to send a certain amount of tokens to another.\n\nBesides the mandatory functions listed below, functions are optional, but they improve the token's usability.\n• name: A method that returns the name of the token.\n• symbol: A method that returns the symbol of the token.\n• decimals: A method that returns the number of decimals the token uses. It is used to define the smallest unit of the token. For example, if an ERC-20 token has a value of 6, this means that the token can be divided up to six decimal places.\n\nIf you know something about object-oriented programming, you can compare ERC-20 to an Interface. If you want your token to be an ERC-20 token, you have to implement the ERC-20 interface, and that forces you to implement these 6 methods.\n\nNow that we know what ERC-20 tokens are and how they work, let’s see how we can build and deploy our own token.\n\nTo begin deploying your contract on the Ethereum Sepolia testnet, you'll need to install the MetaMask browser extension or use another web3 compatible wallet like Phantom or WalletConnect. Once your wallet is set up, you'll need to acquire some test ETH. This can be obtained from the QuickNode Multi-Chain Faucet specifically for the Ethereum Sepolia network. Simply navigate to their website, connect your wallet or enter your wallet address, and proceed. You'll have an option to share a tweet for an additional bonus. If you choose not to, you can just select the option \"No thanks, just send me 0.05 ETH\" to receive your test ETH.\n\nThere are a multitude of ERC20-compliant tokens already operational on the Ethereum blockchain, developed by different groups. These implementations vary, with some focusing on reducing gas costs and others prioritizing enhanced security. For a robust and secure implementation, many developers opt to use OpenZeppelin's ERC20 token standard. OpenZeppelin provides a well-tested, community-audited library of reusable smart contracts, which includes a reliable and secure framework for ERC20 tokens, making it a preferred choice for ensuring compliance and security in token development.\n\nFor ease and security, we’ll use the OpenZeppelin ERC-20 contract to create our token. With OpenZeppelin, we don’t need to write the whole ERC-20 interface. Instead, we can import the library contract and use its functions.\n\nHead over to the Ethereum Remix IDE and make a new Solidity file, for example - MyToken.sol.\n\nPaste the following code into your new Solidity script:\n\nExplanation of the code above:\n• The SPDX-License-Identifier comment specifies the license under which the contract is released.\n• The directive states the compiler version to use.\n• The contract from OpenZeppelin is imported and used as a base.\n• is the name of your contract, and it extends the ERC20 contract.\n• The function initializes your token with a name (\"MyToken\") and a symbol (\"MTK\").\n• The function in the constructor mints an initial supply of tokens. In this example, 1 million tokens are minted and assigned to the address that deploys the contract. The number of tokens is adjusted by the value, which defaults to 18 in the OpenZeppelin implementation.\n\nNow, take a minute to customize the smart contract with your own details if you'd like. You can update the token name and symbol by updating the following part - .\n\nOnce you've completed customizing the smart contract, proceed to compile it.\n\nStep 1: Click on the Solidity compiler button. Check the compiler version and the selected contract. The compiler version should be at least 0.8.20 because of the line in the smart contract. Then, click the Compile MyToken.sol button. If everything goes well, you will see a green check mark on the Compile button.\n\nStep 2: Go to the Deploy & Run Transactions tab. For deployment, use the Injected Provider option under the Environment. Before the deployment, ensure that your MetaMask is set to the Sepolia testnet, and MyToken contract is the selected contract to be deployed. Finally, click on the Deploy button to deploy your contract.\n\nThat’s it! Your token contract is now deployed on Ethereum’s Sepolia testnet!\n\nNow, let's interact with it. Click the arrow (>) near the contract's name under the “Deployed Contracts” section to see the functions of the contract. Then, click the name button, and you should see the name that you customize in your contract. Feel free to try other functions as well.\n\nTo see your contract on a blockchain explorer, a beginner-friendly useful tool used to analyze various blockchain data, go to the Etherscan Sepolia Explorer and search your contract's address.\n\nYou will see your token name and token symbol under the Token Tracker section.\n\nNow, click on the your token name. The page that opens displays the name, symbol, max total supply, and decimals information of your token.\n\nIf you want to see your token in your MetaMask, copy the deployed contract’s address using the copy button near the contract’s name. Then, open MetaMask, click on the Import tokens button and paste the contract’s address in the Token contract address field. MetaMask will fetch the Token Symbol and decimals automatically. Click the Next and Import, and your token will be added to the wallet; it will be available under the assets section in Metamask.\n\nCongratulations on successfully creating your very own token on the Ethereum Sepolia testnet!\n\nIf you'd like to learn more about smart contract deployment contents, you may want to check out these QuickNode guides:\n• How to Create and Deploy an ERC-721 (NFT)\n• How to Create and Deploy an ERC-1155 NFT\n• How to Create a \"Hello World\" Smart Contract with Solidity\n• How to Create and Deploy a Smart Contract with Hardhat\n\nYou can also explore these different QuickNode guide sections:\n\nSubscribe to our newsletter for more articles and guides on Web3 and blockchain. If you have any questions or need further assistance, feel free to join our Discord server or provide feedback using the form below. Stay up to date with the latest by following us on Twitter (@QuickNode) and our Telegram announcement channel.\n\nLet us know if you have any feedback or requests for new topics. We'd love to hear from you."
    },
    {
        "link": "https://docs.soliditylang.org",
        "document": "Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.\n\nSolidity is a curly-bracket language designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the language influences section.\n\nSolidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.\n\nWith Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.\n\nWhen deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number to indicate this fast pace of change.\n\nIdeas for improving Solidity or this documentation are always welcome, read our contributors guide for more details.\n\nIf you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following: Once you are accustomed to the basics, we recommend you read the “Solidity by Example” and “Language Description” sections to understand the core concepts of the language. There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the installation page. You can try out code examples directly in your browser with the Remix IDE. Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally. As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the Security Considerations section. If you want to learn more about building decentralized applications on Ethereum, the Ethereum Developer Resources can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks. If you have any questions, you can try searching for answers or asking on the Ethereum StackExchange, or our Gitter channel."
    },
    {
        "link": "https://docs.alchemy.com/docs/how-to-create-an-erc-20-token-4-steps",
        "document": "An Ethereum Token is an incredibly powerful feature of the Ethereum virtual machine, as it can represent virtually anything from financial assets to skills of a game character, to a fiat currency, and so much more.\n• Why build your Own ERC-20 token?\n• How to create your own ERC-20 tokens\n\nWhy build your own ERC-20 token? Why build your own ERC-20 token?\n\nThe ERC-20 token standard is the most popular way to create fungible cryptocurrencies on Ethereum and EVM-compatible blockchains, and therefore allows builders and creators to develop digital assets for their protocol, marketplace, metaverse, or community.\n\n \n\n This tutorial will teach you how to create your own ERC-20 token on Ethereum’s Goerli testnet using Alchemy, MetaMask, HardHat, and Solidity code snippets. At the end of this tutorial, you will be able to deploy your own ERC-20 token smart contract. The estimated time to complete this guide is 15 minutes.\n\nWhat is the ERC-20 token standard? What is the ERC-20 token standard?\n\nThe ERC-20 token standard ensures that all tokens have the same properties, including that all tokens are fungible (any one token is exactly equal to any other token), and no tokens have special properties or rights associated with them.\n\nThis means that for a token to follow the ERC-20 token standard, it must implement the following API methods and events:\n• - a method that defines the total supply of your tokens, and stops creating new tokens when the limit is reached.\n• - a method that returns the number of tokens a wallet address contains.\n• - a method that transfers in a certain amount of tokens from the total supply and sends it to a user.\n• - verifies whether a smart contract is allowed to allocate a certain amount of tokens to a user, considering the total supply.\n• - checks if a user has enough balance to send a token to another user.\n\nERC-20 tokens are fungible (can be interchanged) because they have the same value and properties. There are also non-fungible token standards and semi-fungible token standards such as ERC-721 and ERC-1155 tokens.\n\nHow to Create an ERC-20 Token How to Create an ERC-20 Token\n\nIn four steps you’ll create and deploy an ERC-20 token on the Goerli test network, using Metamask, Solidity, Hardhat, and Alchemy. This Goerli ERC-20 token will have all the characteristics required above, making it a valid ERC-20 token.\n\nFirst, create an Alchemy account, and set up Metamask, HardHat, and Solidity for this project. For a walkthrough, read through the ChainShot HardHat guide.\n\nNext, enter and to create a folder for your project and change directories to your my-token folder, then run\n\nIf you don't already have NPM installed, use this guide.\n\nNext, go to the project root directory and type and into your command line to create two new folders that will organize your ERC-20 smart contracts and your deployment scripts:\n\nHere’s how to write the token contract for your ERC-20 token using Solidity, which is like Java and JavaScript, or C and C++:\n• Open up the project in your code editor.\n• Open a new file and name the file the same name as your token.\n\n Note: To create and work with your smart contract file, you must have a name that matches the name of your token. For example, to create a token named Web3Token, your contract file name should be .\n\nCopy and paste this code snippet based on the OpenZeppelin ERC 20 implementation:\n\nThe token symbol you choose, in our case \"GG\" can be any arbitrary character length but do keep in mind that some UIs may display ones that are too long differently.\n\n Feel free to edit the initial supply by changing the 100 to how many tokens you would like your initial supply to be - we put 100 because there are very few true Goofy Goobers in the world! You can put any number you'd like for this - make sure to leave the (10**18) as that multiplies the number we want as our supply to have 18 decimals.\n\nNow that your token contract is written, write your smart contract deployment script by:\n\nTo deploy your ERC-20 token, navigate to your root directory and run the following command:\n\nYour contract will be compiled and deployed to the Goerli network! You should see a message appear with information about the smart contracts you are deploying including your account address, account balance, and token address.\n\nGo to https://goerli.etherscan.io/ and input your outputted Token address to see your deployed ERC-20 contract on Goerli!\n\nNow it's time to have real fun! Send some of your new tokens to your friends and family, stimulate an economy - create the Bitcoin/Ethereum of the future! In this guide, you deployed your own ERC-20 token on Goerli using the OpenZeppelin ERC20 standard - great job!\n\nWe are going to challenge you to send some tokens in one of two ways:\n• More Challenging Way: Write your own Hardhat Script to do an airdrop!\n• Simpler Way: Add your ERC-20 token to MetaMask and send it to an address via the UI!\n• How to Get ERC-20 Token Balance at a Given Block\n• How to Interact with ERC-20 tokens in Solidity\n• How to Send ERC20 Tokens in an EIP-1559 Transaction"
    },
    {
        "link": "https://metana.io/blog/creating-a-token-with-solidity",
        "document": "\n• Tokens on the Ethereum blockchain are digital assets created using the Solidity programming language.\n• The ERC-20 standard defines a set of functions and events that a token contract must implement to ensure compatibility with existing platforms.\n• Key functions include totalSupply, balanceOf, transfer, approve, and transferFrom, each serving specific roles in token management.\n• Developers must set up a development environment with tools like Solidity compilers and Integrated Development Environments (IDEs) to write and deploy smart contracts.\n• Proper testing and security audits are essential to ensure the reliability and safety of the token contract\n\nThe world of blockchain technology has seen a increase in the development and use of tokens. These digital assets represent ownership, utility, or access within a blockchain ecosystem. Solidity, a high-level programming language specifically designed for writing smart contracts on the Ethereum Virtual Machine (EVM), plays a crucial role in creating these tokens. This article delves into the process of crafting your own token using Solidity, guiding you through the essential steps and considerations.\n\nBefore diving into Solidity code, it’s vital to grasp the concept of tokens and the standard used for creating them on Ethereum.\n• Tokens: Tokens are units of value residing on a blockchain. They can represent various things, including fungible (interchangeable) currencies, unique digital collectibles, or access rights to specific services within a decentralized application (dApp).\n• ERC-20 Standard: The ERC-20 standard is a set of guidelines established for creating tokens on the Ethereum blockchain. It defines six core functions that a token contract must implement to ensure compatibility with Ethereum wallets, exchanges, and other dApps. These functions include:\n• totalSupply: Retrieves the total number of tokens ever created.\n• transfer(address recipient, uint256 amount): Transfers tokens from the sender’s account to the recipient’s address.\n• allowance(address owner, address spender): Checks the amount of tokens an owner has approved for a spender to transfer on their behalf.\n• transferFrom(address sender, address recipient, uint256 amount): Allows a spender to transfer tokens from another account’s balance (as long as the allowance is sufficient).\n• approve(address spender, uint256 amount): Grants permission for a spender to transfer a specified amount of tokens on the owner’s behalf.\n\nBy adhering to the ERC-20 standard, it can easily work with many different tools and services on the Ethereum network, like a piece of fitting perfectly into a puzzle making it more useful and convenient.\n\nTo get started on your token creation journey, you’ll need a development environment equipped with the necessary tools:\n• Solidity Compiler: This tool translates your human-readable Solidity code into bytecode, a format understandable by the EVM. You can install the command-line compiler using npm or include an online compiler like Remix.\n• Solidity IDE (Optional): While you can write Solidity code in any text editor, an Integrated Development Environment (IDE) specifically designed for Solidity offers features like syntax highlighting, code completion, and debugging capabilities. Popular options include Remix (online), Visual Studio Code with Solidity extensions, or dedicated blockchain IDEs like Truffle or OpenZeppelin Defender.\n• Blockchain Node (Optional): For local testing and deployment, you might consider setting up a local Ethereum node using tools like Geth or running a node on a test network like Rinkeby or Kovan.\n\nHere comes the exciting part: writing the Solidity code for your token contract. Here’s a breakdown of the key components:\n• Solidity Pragma: The first line typically specifies the Solidity version your code is compatible with. This ensures proper compilation and functionality. For instance:\n• Imports: You can import existing libraries or contracts to leverage functionality. Importing the OpenZeppelin ERC20 library simplifies the process by providing pre-built implementations of the ERC-20 standard functions.\n• Contract Definition: Define your token contract using the contract keyword, followed by the chosen name for your token (e.g., MyToken). Inherit from the ERC20 contract to automatically implement the standard functions.\n• Token Properties:\n• Name: Set the human-readable name of your token using the name variable.\n• Symbol: Define a short abbreviation for your token using the symbol variable. This will be used for display purposes on exchanges and wallets.\n• Decimals: Specify the number of decimal places your token represents. Most tokens use 18 decimals for divisibility.\n\nLet us explore additional functionalities you can incorporate into your token contract:\n• Total Supply: Define the total number of tokens that will ever exist using a state variable of type uint256. You can either mint the entire supply during deployment or distribute it gradually.\n\n\n\nuint256 public constant TOTAL_SUPPLY = 1000000 * 10**uint256(decimals());\n• Minting: Implement a function with access control (e.g., only the contract owner) to create new tokens and add them to the total supply. Utilize the _mint function inherited from the ERC20 library.\n• Burning: If desired, you can introduce a function to permanently remove tokens from circulation, reducing the total supply. Employ the _burn function from the ERC20 library.\n• Ownership Transfer: Include functionality to transfer ownership of the contract to another address. This might be useful for future upgrades or maintenance.\n• Events: Utilize events to log information about token transfers and approvals on the blockchain. This allows external applications and users to track token activity.\n\nAn ERC-20 contract with all the above mentioned functionalities would look like this,\n• Security: Smart contract security is paramount. Always thoroughly test and audit your code before deployment to prevent vulnerabilities that could lead to loss of funds. Consider using established libraries like OpenZeppelin for secure implementations.\n• Gas Fees: Executing transactions on the Ethereum blockchain incurs gas fees. Optimize your code for efficiency to minimize gas costs for users.\n• Regulations: Depending on your token’s purpose and functionality, regulations might apply. Research relevant regulations in your jurisdiction to ensure compliance.\n\nOnce you’ve written your token contract, it’s crucial to test it rigorously before deploying it on the Ethereum mainnet. Here’s how:\n• Local Testing: Use a local Ethereum node or a test network like Rinkeby or Kovan to deploy your contract and simulate transactions. Tools like Truffle or Ganache can facilitate local testing.\n• Unit Testing: Write unit tests to verify individual functions of your contract in isolation. This helps isolate potential bugs in specific areas of the code. Frameworks like Solidity Test Framework (STF) can aid in unit testing.\n• Auditing: For critical projects, consider a professional security audit by a reputable blockchain security firm. This adds an extra layer of assurance and minimizes the risk of vulnerabilities.\n\nAfter successful testing, you can deploy your contract to the Ethereum mainnet. The process involves interacting with your chosen blockchain node and paying the required transaction fees. Tools like Remix, Truffle, or dedicated blockchain IDEs offer deployment functionalities.\n• Wallet Integration: Ensure your token is compatible with popular Ethereum wallets and exchanges for wider adoption.\n• Liquidity Provision: If you plan to enable trading of your token on decentralized exchanges (DEXs), you might need to provide initial liquidity for trading pairs.\n\nCreating a token with Solidity empowers you to contribute to the ever-evolving world of blockchain technology. By following this guide and adhering to best practices, you can develop your own ERC-20 token and leverage its functionalities within the Ethereum ecosystem. Remember, continuous learning, security awareness, and thorough testing are key to a successful token creation journey.\n• Solidity is a programming language designed for developing smart contracts that run on the Ethereum blockchain.\n\nHow do you create a token in Solidity?\n• Creating a token in Solidity involves writing a smart contract that defines the token’s properties and behaviors, then deploying it to the Ethereum network.\n\nWhat are the key components of a Solidity token contract?\n• Key components include the contract declaration, state variables for tracking balances, and functions for transferring tokens and managing supply.\n\nCan I create different types of tokens using Solidity?\n• Yes, you can create various types of tokens, including fungible tokens (ERC-20), non-fungible tokens (ERC-721), and others.\n\nWhat are the best practices for deploying a Solidity token?\n• Best practices include thorough testing, code audits, optimizing gas usage, and ensuring contract security to prevent vulnerabilities.\n• Ethereum is a decentralized platform that enables developers to build and deploy smart contracts and decentralized applications (dApps).\n• Smart contracts are self-executing contracts with the terms of the agreement directly written into code, running on the blockchain.\n• Blockchain technology is a decentralized digital ledger that records all transactions across a network of computers securely and transparently.\n\nWhat is the purpose of cryptocurrency tokens?\n• Cryptocurrency tokens can represent various assets or utilities on a blockchain and are often used as part of dApps or as digital currency.\n• Learning Solidity can be approached through online tutorials, coding bootcamps, and comprehensive reading of the official Solidity documentation."
    },
    {
        "link": "https://docs.openzeppelin.com/contracts/4.x/erc20",
        "document": "Often, you’ll want to be able to divide your tokens into arbitrary amounts: say, if you own , you may want to send to a friend, and keep to yourself. Unfortunately, Solidity and the EVM do not support this behavior: only integer (whole) numbers can be used, which poses an issue. You may send or tokens, but not .\n\nTo work around this, provides a field, which is used to specify how many decimal places a token has. To be able to transfer , must be at least , since that number has a single decimal place.\n\nHow can this be achieved? It’s actually very simple: a token contract can use larger integer values, so that a balance of will represent , a transfer of will correspond to being sent, and so on.\n\nIt is important to understand that is only used for display purposes. All arithmetic inside the contract is still performed on integers, and it is the different user interfaces (wallets, exchanges, etc.) that must adjust the displayed values according to . The total token supply and balance of each account are not specified in : you need to divide by to get the actual amount.\n\nYou’ll probably want to use a value of , just like Ether and most ERC20 token contracts in use, unless you have a very special reason not to. When minting tokens or transferring them around, you will be actually sending the number .\n\nSo if you want to send tokens using a token contract with 18 decimals, the method to call will actually be:"
    },
    {
        "link": "https://docs.soliditylang.org/en/latest/solidity-by-example.html",
        "document": "The following contract is quite complex, but showcases a lot of Solidity’s features. It implements a voting contract. Of course, the main problems of electronic voting is how to assign voting rights to the correct persons and how to prevent manipulation. We will not solve all problems here, but at least we will show how delegated voting can be done so that vote counting is automatic and completely transparent at the same time. The idea is to create one contract per ballot, providing a short name for each option. Then the creator of the contract who serves as chairperson will give the right to vote to each address individually. The persons behind the addresses can then choose to either vote themselves or to delegate their vote to a person they trust. At the end of the voting time, will return the proposal with the largest number of votes. // This declares a new complex type which will // be used for variables later. // if true, that person already voted // This is a type for a single proposal. // short name (up to 32 bytes) // stores a `Voter` struct for each possible address. Voter voters Proposal proposals /// Create a new ballot to choose one of `proposalNames`. proposalNames chairperson voters chairperson weight // For each of the provided proposal names, // create a new proposal object and add it // to the end of the array. i proposalNames length i // appends it to the end of `proposals`. proposals push Proposal name proposalNames i voteCount // Give `voter` the right to vote on this ballot. // May only be called by `chairperson`. // If the first argument of `require` evaluates // to `false`, execution terminates and all // changes to the state and to Ether balances // This used to consume all gas in old EVM versions, but // It is often a good idea to use `require` to check if // As a second argument, you can also provide an // explanation about what went wrong. chairperson \"Only chairperson can give right to vote.\" voters voter voted voters voter weight voters voter weight /// Delegate your vote to the voter `to`. Voter storage sender voters sender weight \"You have no right to vote\" sender voted to // Forward the delegation as long as // In general, such loops are very dangerous, // because if they run too long, they might // need more gas than is available in a block. // In this case, the delegation will not be executed, // but in other situations, such loops might // cause a contract to get \"stuck\" completely. voters to delegate to voters to delegate // We found a loop in the delegation, not allowed. to Voter storage delegate_ voters to // Voters cannot delegate to accounts that cannot vote. delegate_ weight // Since `sender` is a reference, this sender voted sender delegate to delegate_ voted // If the delegate already voted, // directly add to the number of votes proposals delegate_ vote voteCount sender weight // If the delegate did not vote yet, delegate_ weight sender weight /// Give your vote (including votes delegated to you) Voter storage sender voters sender weight sender voted sender voted sender vote proposal // If `proposal` is out of the range of the array, // this will throw automatically and revert all proposals proposal voteCount sender weight view p proposals length p proposals p voteCount winningVoteCount winningVoteCount proposals p voteCount winningProposal_ p // Calls winningProposal() function to get the index // of the winner contained in the proposals array and then // returns the name of the winner view winnerName_ proposals winningProposal name Currently, many transactions are needed to assign the rights to vote to all participants. Moreover, if two or more proposals have the same number of votes, is not able to register a tie. Can you think of a way to fix these issues?\n\nIn this section, we will show how easy it is to create a completely blind auction contract on Ethereum. We will start with an open auction where everyone can see the bids that are made and then extend this contract into a blind auction where it is not possible to see the actual bid until the bidding period ends. The general idea of the following simple auction contract is that everyone can send their bids during a bidding period. The bids already include sending some compensation, e.g. Ether, in order to bind the bidders to their bid. If the highest bid is raised, the previous highest bidder gets their Ether back. After the end of the bidding period, the contract has to be called manually for the beneficiary to receive their Ether - contracts cannot activate themselves. // Parameters of the auction. Times are either beneficiary pendingReturns // Set to true at the end, disallows any change. // Events that will be emitted on changes. // comments. They will be shown when the user // is asked to confirm a transaction or // when an error is displayed. /// The auction has already ended. error AuctionAlreadyEnded /// There is already a higher or equal bid. error BidNotHighEnough /// The auction has not ended yet. error AuctionNotYetEnded /// The function auctionEnd has already been called. error AuctionEndAlreadyCalled /// seconds bidding time on behalf of the beneficiaryAddress beneficiary beneficiaryAddress auctionEndTime biddingTime /// Bid on the auction with the value sent /// together with this transaction. /// The value will only be refunded if the // No arguments are necessary, all // information is already part of // is required for the function to // be able to receive Ether. // Revert the call if the bidding auctionEndTime revert AuctionAlreadyEnded // If the bid is not higher, send the // will revert all changes in this // it having received the Ether). highestBid revert BidNotHighEnough highestBid highestBid // Sending back the Ether by simply using // because it could execute an untrusted contract. // It is always safer to let the recipients pendingReturns highestBidder highestBid highestBidder highestBid emit HighestBidIncreased pendingReturns amount // It is important to set this to zero because the recipient // can call this function again as part of the receiving call pendingReturns // msg.sender is not of type `address payable` and must be send amount // No need to call throw here, just reset the amount owing pendingReturns amount /// End the auction and send the highest bid // It is a good guideline to structure functions that interact // with other contracts (i.e. they call functions or send Ether) // If these phases are mixed up, the other contract could call // back into the current contract and modify the state or cause // contracts, they also have to be considered interaction with auctionEndTime revert AuctionNotYetEnded ended revert AuctionEndAlreadyCalled ended emit AuctionEnded highestBidder highestBid beneficiary transfer highestBid The previous open auction is extended to a blind auction in the following. The advantage of a blind auction is that there is no time pressure towards the end of the bidding period. Creating a blind auction on a transparent computing platform might sound like a contradiction, but cryptography comes to the rescue. During the bidding period, a bidder does not actually send their bid, but only a hashed version of it. Since it is currently considered practically impossible to find two (sufficiently long) values whose hash values are equal, the bidder commits to the bid by that. After the end of the bidding period, the bidders have to reveal their bids: They send their values unencrypted, and the contract checks that the hash value is the same as the one provided during the bidding period. Another challenge is how to make the auction binding and blind at the same time: The only way to prevent the bidder from just not sending the Ether after they won the auction is to make them send it together with the bid. Since value transfers cannot be blinded in Ethereum, anyone can see the value. The following contract solves this problem by accepting any value that is larger than the highest bid. Since this can of course only be checked during the reveal phase, some bids might be invalid, and this is on purpose (it even provides an explicit flag to place invalid bids with high-value transfers): Bidders can confuse competition by placing several high or low invalid bids. beneficiary Bid bids pendingReturns /// The function has been called too early. error TooEarly /// The function has been called too late. /// It cannot be called after `time`. error TooLate /// The function auctionEnd has already been called. error AuctionEndAlreadyCalled // Modifiers are a convenient way to validate inputs to // functions. `onlyBefore` is applied to `bid` below: // The new function body is the modifier's body where // `_` is replaced by the old function body. onlyBefore time revert TooLate time _ onlyAfter time revert TooEarly time _ beneficiaryAddress beneficiary beneficiaryAddress biddingEnd biddingTime revealEnd biddingEnd revealTime /// The sent ether is only refunded if the bid is correctly /// revealed in the revealing phase. The bid is valid if the /// ether sent together with the bid is at least \"value\" and /// \"fake\" is not true. Setting \"fake\" to true and sending /// not the exact amount are ways to hide the real bid but /// still make the required deposit. The same address can onlyBefore biddingEnd bids push Bid blindedBid blindedBid deposit /// Reveal your blinded bids. You will get a refund for all /// correctly blinded invalid bids and for all bids except for calldata values calldata fakes calldata secrets onlyAfter biddingEnd onlyBefore revealEnd bids length values length length fakes length length secrets length length i length i Bid storage bidToCheck bids i values i fakes i secrets i bidToCheck blindedBid abi encodePacked value fake secret // Bid was not actually revealed. refund bidToCheck deposit fake bidToCheck deposit value placeBid value refund value // Make it impossible for the sender to re-claim bidToCheck blindedBid transfer refund pendingReturns amount // It is important to set this to zero because the recipient // can call this function again as part of the receiving call // before `transfer` returns (see the remark above about pendingReturns transfer amount /// End the auction and send the highest bid onlyAfter revealEnd ended revert AuctionEndAlreadyCalled emit AuctionEnded highestBidder highestBid ended beneficiary transfer highestBid // This is an \"internal\" function which means that it // can only be called from the contract itself (or from value highestBid highestBidder pendingReturns highestBidder highestBid highestBid value highestBidder bidder\n\nPurchasing goods remotely currently requires multiple parties that need to trust each other. The simplest configuration involves a seller and a buyer. The buyer would like to receive an item from the seller and the seller would like to get some compensation, e.g. Ether, in return. The problematic part is the shipment here: There is no way to determine for sure that the item arrived at the buyer. There are multiple ways to solve this problem, but all fall short in one or the other way. In the following example, both parties have to put twice the value of the item into the contract as escrow. As soon as this happened, the Ether will stay locked inside the contract until the buyer confirms that they received the item. After that, the buyer is returned the value (half of their deposit) and the seller gets three times the value (their deposit plus the value). The idea behind this is that both parties have an incentive to resolve the situation or otherwise their Ether is locked forever. This contract of course does not solve the problem, but gives an overview of how you can use state machine-like constructs inside a contract. seller buyer Created Locked Release Inactive // The state variable has a default value of the first member, `State.created` State state condition condition_ _ /// Only the buyer can call this function. error OnlyBuyer /// Only the seller can call this function. error OnlySeller /// The function cannot be called at the current state. error InvalidState /// The provided value has to be even. error ValueNotEven onlyBuyer buyer revert OnlyBuyer _ onlySeller seller revert OnlySeller _ inState State state_ state state_ revert InvalidState _ // Ensure that `msg.value` is an even number. // Division will truncate if it is an odd number. // Check via multiplication that it wasn't an odd number. seller value value revert ValueNotEven /// Abort the purchase and reclaim the ether. /// Can only be called by the seller before onlySeller inState State Created emit Aborted state State Inactive // We use transfer here directly. It is // reentrancy-safe, because it is the // last call in this function and we seller transfer balance /// Transaction has to include `2 * value` ether. /// The ether will be locked until confirmReceived inState State Created condition value emit PurchaseConfirmed buyer state State Locked /// Confirm that you (the buyer) received the item. /// This will release the locked ether. onlyBuyer inState State Locked emit ItemReceived // It is important to change the state first because // otherwise, the contracts called using `send` below // can call in again here. state State Release buyer transfer value /// pays back the locked funds of the seller. onlySeller inState State Release emit SellerRefunded // It is important to change the state first because // otherwise, the contracts called using `send` below // can call in again here. state State Inactive seller transfer value\n\nIn this section, we will learn how to build an example implementation of a payment channel. It uses cryptographic signatures to make repeated transfers of Ether between the same parties secure, instantaneous, and without transaction fees. For the example, we need to understand how to sign and verify signatures, and setup the payment channel. Imagine Alice wants to send some Ether to Bob, i.e. Alice is the sender and Bob is the recipient. Alice only needs to send cryptographically signed messages off-chain (e.g. via email) to Bob and it is similar to writing checks. Alice and Bob use signatures to authorize transactions, which is possible with smart contracts on Ethereum. Alice will build a simple smart contract that lets her transmit Ether, but instead of calling a function herself to initiate a payment, she will let Bob do that, and therefore pay the transaction fee. The contract will work as follows:\n• None Alice deploys the contract, attaching enough Ether to cover the payments that will be made.\n• None Alice authorizes a payment by signing a message with her private key.\n• None Alice sends the cryptographically signed message to Bob. The message does not need to be kept secret (explained later), and the mechanism for sending it does not matter.\n• None Bob claims his payment by presenting the signed message to the smart contract, it verifies the authenticity of the message and then releases the funds. Alice does not need to interact with the Ethereum network to sign the transaction, the process is completely offline. In this tutorial, we will sign messages in the browser using web3.js and MetaMask, using the method described in EIP-712, as it provides a number of other security benefits. The prepends the length of the message to the signed data. Since we hash first, the message will always be exactly 32 bytes long, and thus this length prefix is always the same. For a contract that fulfills payments, the signed message must include:\n• None The amount to be transferred. A replay attack is when a signed message is reused to claim authorization for a second action. To avoid replay attacks we use the same technique as in Ethereum transactions themselves, a so-called nonce, which is the number of transactions sent by an account. The smart contract checks if a nonce is used multiple times. Another type of replay attack can occur when the owner deploys a smart contract, makes some payments, and then destroys the contract. Later, they decide to deploy the smart contract again, but the new contract does not know the nonces used in the previous deployment, so the attacker can use the old messages again. Alice can protect against this attack by including the contract’s address in the message, and only messages containing the contract’s address itself will be accepted. You can find an example of this in the first two lines of the function of the full contract at the end of this section. Furthermore, instead of destroying the contract by calling , which is currently deprecated, we will disable the contract’s functionalities by freezing it, resulting in the reversion of any call after it being frozen. Now that we have identified what information to include in the signed message, we are ready to put the message together, hash it, and sign it. For simplicity, we concatenate the data. The ethereumjs-abi library provides a function called that mimics the behavior of Solidity’s function applied to arguments encoded using . Here is a JavaScript function that creates the proper signature for the example: // recipient is the address that should be paid. // amount, in wei, specifies how much ether should be sent. // nonce can be any unique number to prevent replay attacks // contractAddress is used to prevent cross-contract replay attacks In general, ECDSA signatures consist of two parameters, and . Signatures in Ethereum include a third parameter called , that you can use to verify which account’s private key was used to sign the message, and the transaction’s sender. Solidity provides a built-in function ecrecover that accepts a message along with the , and parameters and returns the address that was used to sign the message. Signatures produced by web3.js are the concatenation of , and , so the first step is to split these parameters apart. You can do this on the client-side, but doing it inside the smart contract means you only need to send one signature parameter rather than three. Splitting apart a byte array into its constituent parts is a mess, so we use inline assembly to do the job in the function (the third function in the full contract at the end of this section). The smart contract needs to know exactly what parameters were signed, and so it must recreate the message from the parameters and use that for signature verification. The functions and do this in the function. owner owner Owned notFrozen _frozen _ owner _frozen Freezable usedNonces signature notFrozen usedNonces nonce usedNonces nonce // this recreates the message that was signed on the client prefixed abi encodePacked amount nonce recoverSigner message signature owner transfer amount /// freeze the contract and reclaim the leftover funds. notFrozen owner freeze transfer balance sig pure sig length assembly // first 32 bytes, after the length prefix. r mload add sig s mload add sig // final byte (first byte of the next 32 bytes). v byte mload add sig v r s sig pure splitSignature sig ecrecover message v r s /// builds a prefixed hash to mimic the behavior of eth_sign. pure abi encodePacked Alice now builds a simple but complete implementation of a payment channel. Payment channels use cryptographic signatures to make repeated transfers of Ether securely, instantaneously, and without transaction fees. Payment channels allow participants to make repeated transfers of Ether without using transactions. This means that you can avoid the delays and fees associated with transactions. We are going to explore a simple unidirectional payment channel between two parties (Alice and Bob). It involves three steps:\n• None Alice funds a smart contract with Ether. This “opens” the payment channel.\n• None Alice signs messages that specify how much of that Ether is owed to the recipient. This step is repeated for each payment.\n• None Bob “closes” the payment channel, withdrawing his portion of the Ether and sending the remainder back to the sender. Only steps 1 and 3 require Ethereum transactions, step 2 means that the sender transmits a cryptographically signed message to the recipient via off chain methods (e.g. email). This means only two transactions are required to support any number of transfers. Bob is guaranteed to receive his funds because the smart contract escrows the Ether and honours a valid signed message. The smart contract also enforces a timeout, so Alice is guaranteed to eventually recover her funds even if the recipient refuses to close the channel. It is up to the participants in a payment channel to decide how long to keep it open. For a short-lived transaction, such as paying an internet café for each minute of network access, the payment channel may be kept open for a limited duration. On the other hand, for a recurring payment, such as paying an employee an hourly wage, the payment channel may be kept open for several months or years. To open the payment channel, Alice deploys the smart contract, attaching the Ether to be escrowed and specifying the intended recipient and a maximum duration for the channel to exist. This is the function in the contract, at the end of this section. Alice makes payments by sending signed messages to Bob. This step is performed entirely outside of the Ethereum network. Messages are cryptographically signed by the sender and then transmitted directly to the recipient. Each message includes the following information:\n• None The smart contract’s address, used to prevent cross-contract replay attacks.\n• None The total amount of Ether that is owed to the recipient so far. A payment channel is closed just once, at the end of a series of transfers. Because of this, only one of the messages sent is redeemed. This is why each message specifies a cumulative total amount of Ether owed, rather than the amount of the individual micropayment. The recipient will naturally choose to redeem the most recent message because that is the one with the highest total. The nonce per-message is not needed anymore, because the smart contract only honours a single message. The address of the smart contract is still used to prevent a message intended for one payment channel from being used for a different channel. Here is the modified JavaScript code to cryptographically sign a message from the previous section: // contractAddress is used to prevent cross-contract replay attacks. // amount, in wei, specifies how much Ether should be sent. When Bob is ready to receive his funds, it is time to close the payment channel by calling a function on the smart contract. Closing the channel pays the recipient the Ether they are owed and deactivates the contract by freezing it, sending any remaining Ether back to Alice. To close the channel, Bob needs to provide a message signed by Alice. The smart contract must verify that the message contains a valid signature from the sender. The process for doing this verification is the same as the process the recipient uses. The Solidity functions and work just like their JavaScript counterparts in the previous section, with the latter function borrowed from the contract. Only the payment channel recipient can call the function, who naturally passes the most recent payment message because that message carries the highest total owed. If the sender were allowed to call this function, they could provide a message with a lower amount and cheat the recipient out of what they are owed. The function verifies the signed message matches the given parameters. If everything checks out, the recipient is sent their portion of the Ether, and the sender is sent the remaining funds via a . You can see the function in the full contract. Bob can close the payment channel at any time, but if they fail to do so, Alice needs a way to recover her escrowed funds. An expiration time was set at the time of contract deployment. Once that time is reached, Alice can call to recover her funds. You can see the function in the full contract. After this function is called, Bob can no longer receive any Ether, so it is important that Bob closes the channel before the expiration is reached. notFrozen _frozen _ _frozen Frozeable sender recipient // Timeout in case the recipient never closes. recipientAddress sender recipient recipientAddress expiration duration /// the recipient can close the channel at any time by presenting a /// signed amount from the sender. the recipient will be sent that amount, /// and the remainder will go back to the sender signature notFrozen recipient isValidSignature amount signature recipient transfer amount freeze sender transfer balance /// the sender can extend the expiration at any time notFrozen sender newExpiration expiration expiration newExpiration /// if the timeout is reached without the recipient closing the channel, /// then the Ether is released back to the sender. notFrozen expiration freeze sender transfer balance signature view prefixed abi encodePacked amount // check that the signature is from the payment sender recoverSigner message signature sender /// All functions below this are just taken from the chapter sig pure sig length assembly // first 32 bytes, after the length prefix r mload add sig s mload add sig // final byte (first byte of the next 32 bytes) v byte mload add sig v r s sig pure splitSignature sig ecrecover message v r s /// builds a prefixed hash to mimic the behavior of eth_sign. pure abi encodePacked The function does not use all security checks. A real implementation should use a more rigorously tested library, such as openzeppelin’s version of this code. Unlike in the previous section, messages in a payment channel aren’t redeemed right away. The recipient keeps track of the latest message and redeems it when it’s time to close the payment channel. This means it’s critical that the recipient perform their own verification of each message. Otherwise there is no guarantee that the recipient will be able to get paid in the end. The recipient should verify each message using the following process:\n• None Verify that the contract address in the message matches the payment channel.\n• None Verify that the new total is the expected amount.\n• None Verify that the new total does not exceed the amount of Ether escrowed.\n• None Verify that the signature is valid and comes from the payment channel sender. We’ll use the ethereumjs-util library to write this verification. The final step can be done a number of ways, and we use JavaScript. The following code borrows the function from the signing JavaScript code above: // this mimics the prefixing behavior of the eth_sign JSON-RPC method.\n\nA modular approach to building your contracts helps you reduce the complexity and improve the readability which will help to identify bugs and vulnerabilities during development and code review. If you specify and control the behavior of each module in isolation, the interactions you have to consider are only those between the module specifications and not every other moving part of the contract. In the example below, the contract uses the method of the library to check that balances sent between addresses match what you expect. In this way, the library provides an isolated component that properly tracks balances of accounts. It is easy to verify that the library never produces negative balances or overflows and the sum of all balances is an invariant across the lifetime of the contract. Balances storage balances balances from amount balances to amount balances to balances from amount balances to amount balances using Balances allowed balances move to amount emit Transfer to amount allowed from amount allowed from amount balances move from to amount emit Transfer from to amount allowed spender allowed spender tokens emit Approval spender tokens view balances tokenOwner"
    },
    {
        "link": "https://medium.com/coinmonks/building-a-simple-voting-application-with-solidity-a99ff43cfa14",
        "document": "In this tutorial, we build, test, and deploy a simple voting application using Solidity, a programming language designed specifically for smart contracts.\n\nVoting is a fundamental process in any democratic society, and it is essential to ensure that the voting process is transparent, secure, and accurate. Blockchain technology has the potential to transform the way we conduct voting by providing a secure, decentralized, and tamper-proof system for recording and counting votes. Smart contracts, in particular, can be used to create self-executing voting systems that are transparent and incorruptible.\n\nIn this tutorial, we will explore how to build a simple voting application using Solidity, a programming language designed specifically for smart contracts. We will guide you through the process of creating a smart contract for a voting application, compiling, testing, and deploying the contract.\n\nWhether you are a developer interested in learning about Solidity and smart contracts or someone who wants to understand how blockchain technology can be used for voting systems, this tutorial will provide you with hands-on experience in building a simple voting application on the blockchain. So let’s get started!\n\nTo set up your development environment follow the Hardhat getting started guide. We will be using Typescript for this project.\n\nWe are building a simple voting application using the Solidity programming language. This application will allow any to create a ballot with a set of options or candidates, specify a start and end time for voting, and allow users to cast their votes. Once the voting period is over, the application will tally the votes and declare the winner(s) based on the election rules.\n\nThe goal of this application is to showcase the use of Solidity in building decentralized applications with transparent and secure voting mechanisms. With this application, we can demonstrate how Solidity can be used to create smart contracts that can ensure the integrity of voting processes while promoting transparency and trust.\n• Creating a ballot: The application should allow any user to create a new ballot with a specific set of options, and a start and duration for voting.\n• Voting: Any user should be able to vote on the options listed on the ballot. The application should prevent users from voting multiple times and ensure that votes are cast only during the specified voting window.\n• Tallying votes: Once the voting period is over, the application should tally the votes and declare the winner(s) based on the election rules.\n\nWe will write four test cases for this part.\n• Should revert if the ballot has less than 2 options\n• Should revert if the start time is less than the current time\n• Should revert if the duration is less than 1\n\nLet’s create a file: where we will describe all our test cases. The barebone structure will consist of a method, which will be used in every test.\n\nLet’s write placeholders for our first 4 test cases:\n\nYou will get the following:\n\nThis is because we haven’t actually written our test cases. Let’s write our first one.\n\nNow if we run the test command, we get the following error:\n\nThat is because we didn’t create a contract yet. Let’s do it.\n\nOur basic contract will look like this:\n\nNow we need to define our methods and data structures.\n\nNow, if we run the tests, we get the following, first test passing!\n\nFor the next couple of tests, we testing validations.\n\nRun the tests, and you should get the following:\n\nNext, let’s validate the start time. Here is our test case, we changed the start time declaration.\n\nThe last test in the create ballot section is checking the duration.\n\nLet’s update the function in the contract:\n\nWe have four test cases for voting:\n• Should be able to vote\n• Should revert if the user tries to vote before the start time\n• Should revert if the user tries to vote after the end time\n• Should revert if the user tries to vote multiple times\n\nRun our tests and we get the following:\n• Should return the results for every option\n• Should return the winner for a ballot\n\nNo need to change the contract code. That's it for this tutorial, there are some improvement suggestions below. The code can be found on GitHub."
    },
    {
        "link": "https://kb.osu.edu/bitstreams/75ab8806-17b0-489e-8ccd-e42213b966f2/download",
        "document": ""
    },
    {
        "link": "https://docs.soliditylang.org",
        "document": "Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.\n\nSolidity is a curly-bracket language designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the language influences section.\n\nSolidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.\n\nWith Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.\n\nWhen deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number to indicate this fast pace of change.\n\nIdeas for improving Solidity or this documentation are always welcome, read our contributors guide for more details.\n\nIf you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following: Once you are accustomed to the basics, we recommend you read the “Solidity by Example” and “Language Description” sections to understand the core concepts of the language. There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the installation page. You can try out code examples directly in your browser with the Remix IDE. Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally. As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the Security Considerations section. If you want to learn more about building decentralized applications on Ethereum, the Ethereum Developer Resources can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks. If you have any questions, you can try searching for answers or asking on the Ethereum StackExchange, or our Gitter channel."
    },
    {
        "link": "https://mdpi.com/2571-5577/6/4/70",
        "document": "Elections are crucial, but a sizable portion of the population has little faith in the system, a grave issue for a nation. Even the most significant countries, such as India, are affected by a flawed electoral system. The fundamental problems with the current vote-casting device are vote falsification, election control, and poll space shooting. In the modern era, blockchain technology has been a revolutionary force dramatically impacting numerous industries, from banking to healthcare [ 1 ]. One of the most intriguing applications of blockchain technology has been its use in the voting system, allowing for voter authentication, improved security, and increased transparency [ 2 3 ]. Blockchain is a distributed ledger system that records and stores data securely and reliably. It is a decentralized system, meaning the data is stored on many computers rather than a single, central computer, making it virtually impossible to tamper with or manipulate. A blockchain voting system relies on this technology to provide secure, reliable voting [ 4 ]. Blockchain technology in the poll has been gaining attraction due to its promise of improved security, greater transparency, and more efficient management. Blockchain voting systems are more secure than traditional voting systems because they provide a tamper-proof record of each vote stored securely on the blockchain and can be verified by anyone. This eliminates the possibility of faked or manipulated votes, as each ballot is transparently recorded on the blockchain for anyone to view. 6,7,8,9,10, Another advantage of blockchain voting systems is that they are much more efficient than traditional ones. They are faster, as votes can be recorded and stored securely on the blockchain in minutes or seconds, compared to conventional voting systems, which sometimes take days or weeks to be tallied. This makes it easier for officials to manage and monitor elections, as the votes are tabulated in real-time. In addition, blockchain voting systems can also be used to provide voter authentication. This ensures that only authorized voters can vote and are securely stored and validated. This eliminates the possibility of voter fraud, as votes can be tracked and verified to ensure that they are authentic [ 5 11 ]. 13, Finally, blockchain voting systems provide greater transparency than traditional voting systems due to the distributed nature of the blockchain. All votes are securely stored on the blockchain, allowing anyone to view and verify them. This eliminates the possibility of rigged or manipulated polls, as anyone can view them and verify that they are accurate and authentic. In conclusion, blockchain voting systems offer numerous advantages over traditional voting systems, such as improved security, transparency, and efficiency. As technology evolves and improves, blockchain voting systems become increasingly popular and could soon become the norm in elections worldwide [ 12 14 ]. represents a brief introduction, and represents a brief introduction, and Section 1 represents a brief introduction, and Section 2 describes Blockchain in detail and its subsequent necessity. Section 3 iterates through the short report of the literature review. Section 4 outlines the proposed methodology and design. It also gives details of multiple phases and the level of work done in the technical aspect of the proposed system. Section 5 is an analysis and discussion of the theoretical and practical implementation of the proposed method; It also has a validation subsection. Finally, Section 6 is the conclusion, briefly summarizing the proposed model.\n\nBlockchain can assist in implementing an immutable, transparent, and efficient system that cannot be hacked. Because blocks cannot be changed or deleted, blockchain can solve the problems in the traditional voting system. Blockchain is a distributed network composed of many interconnected nodes. A centralized approach does not control the network. If most nodes agree, the transaction allows users to be anonymous. Whenever there is a need for transparency and decentralized authentication and identification of users, we use blockchain. The transactions in a blockchain network are encrypted. In simpler words, blockchain is a shared database [ 15 16 ].\n• None Node: Each user in a blockchain network is a node. A copy of the distributed ledger is shared with all the blockchain network nodes.\n• None Transaction: is the foundation of blockchain. In a blockchain, transaction details (asset, price, and ownership) are recorded and verified across all nodes.\n• None Block: numerous blocks in the blockchain network store information such as the hash of that block. Figure 1 represents blocks committed in a ledger with their hash Id.\n• None Chain: blocks in a specific order. Blockchain ensures these blocks’ order by storing the previous node’s hash in the current node.\n• None Miners: nodes that perform complex blockchain operations are responsible for verifying whether a transaction is valid.\n• None Consensus: Blockchain follows some algorithms to reach an agreement among nodes participating in a transaction. It’s proof of work. Some common terminologies in a blockchain are:\n• None Smart Contract: Smart contracts are a simple logical bit of programs stored on each block of blockchain that run when some conditions are proper. They follow “if/when … then …” statements written on the blockchain and help automate the verification of parties’ agreement. Automated execution of an agreement is done with the help of smart contracts; it ensures that each participant can be sure of the transaction’s outcome. The irreversibility and traceability of these transactions increase the trust of the nodes in the network. Some advantages of smart contracts are making faster and better decisions, saving time, and lowering cost and risk.\n• None Wallet: Wallet is a collection of user identities. It allows users to store and manage their Bitcoin, Ether, and other cryptocurrencies.\n• None Truffle: It’s a blockchain development environment. It also provides a testing framework and asset pipeline for Ethereum. We have used Ganache, which provides 10 Ethereum test accounts with 100 ETH. Blockchain technology makes implementing e-voting more affordable, simple, and secure. This system ensures data integrity, availability, and fault tolerance by having a decentralized system. Computers(nodes) connected in a decentralized network are blockchain systems. Each node has a complete record of all the transactions on the network and validates all the transactions. They form blockchains, which are ledgers in which digital data is linked. Blockchain records are essentially unchangeable [ 17 ]. Benefits of the E-voting system over the current system:\n• None User Participation: In blockchain-based voting systems, voting can be done anywhere and on any internet device to increase user participation. It is beneficial for disabled users.\n• None User Motivation: By having a fair election, user motivation and trust in the voting system increase.\n• None Security: It is decentralized and uses hashing functions to secure transactions. We need more than 50 affected nodes for a blockchain to be insecure.\n• None Efficiency: In traditional e-voting systems, there is still some paperwork involved, so by using a blockchain-based e-voting system, the cost is significantly reduced, increasing the efficiency of election management.\n• None Precision: There are no errors (or) miscalculations of votes in blockchain-based voting systems. So the results are accurate and timely. It also provides proof of vote to every voter.\n\nSeveral papers have been published presenting the functions and issues with blockchain-based Voting protocols. In this section, we have given some relevant blockchain voting protocols. The Open vote network proposed by Uzma Jafar [ 1 ] was the first release of a self-counting internet protocol that granted security and privacy through Ethereum. Open Vote Network supported a small voting size of 50–60, a choice by design but still failed to stop miners from illegal activities on the system. Voters could also break the Voting system by sending an invalid vote. This system did not guarantee resistance to violence and corruption, and since solidity did not support ‘elliptic curve cryptography,’ the additional library developed into a better blockchain voting protocol. After the library was added, the contracts and transaction data became too big to be stored on the blockchain. The cost to maintain transaction data on Ethereum was astronomically high; storing all voters’ data on it wasn’t feasible. Table 1 illustrates the comparison of several blockchain voting platforms, frameworks they used, their security protocols, and limitations. Hsueh C.W [ 2 ] presented a decentralized and ingenuous electronic voting protocol. The voting system (Date) required a minimum degree of confidence between candidates. The date provided the ability to do large-scale electronic elections, which OVN lacked. Regrettably, this proposed system was also functional enough to provide security from DoS attacks because the authority needed for auditing the vote after the election wasn’t available. While using Ring Signature, which keeps users’ privacy, it was hard to coordinate several signers. This protocol could only be used for small-scale voting despite providing the ability to do large scales. Shahzad et al. [ 3 ] presented a reliable blockchain-based voting protocol. On a minor scale, it promised to solve anonymity, security, and privacy problems in blockchain systems. However, this protocol wasn’t problem-free; this paper used a mathematically complex and resource-demanding algorithm. It needs a vast supply of energy to process. Another issue arises from the involvement of third parties because there is a risk of fraudulent activity and data leaks. Shiyao Gao [ 4 ] proposed an auditable blockchain-based voting technology. They also modified the algorithm method to make it resistant to DoS attacks. It not only accepts the anonymity of the voter, but it also helps the audit process. However, the proposition analysis demonstrates that if voting is small scaled, privacy and efficiency gains for election are considerable. Depending on the size, some efficiency is sacrificed to give higher privacy. Haibo Yi [ 5 ] proposed a Blockchain-based Voting Scheme that employed blockchain technology to increase voting security in a peer network. A technology placed on distributed ledger technology can be used to prevent vote manipulation. Protocol was developed and tested on a peer network using Linux computers. This technology makes the involvement of external parties necessary and is unsuitable for centralized use in a system with various agents. With this system using a distributed technology, securing multi-functional computers can prevent the issue. If the calculation is complex and there are too many voters, compute expenses become significant, if not prohibitive. Khan, K.M. [ 6 ] proposed a blockchain-based electronic voting protocol. Their experiments also provide fascinating insights into how specific characteristics, such as interactions between various parameters and security and performance indicators within an organization, affect the system’s overall scale value and reliability. It became clear. According to the author’s proposal, the election operation needs the implementation of unique and hash-able addresses for voters and candidates. Voters use these addresses to vote for candidates. However, severe drawbacks of this model were revealed. This paper was open to bilateral investment because no regulators prevent unauthorized voters from voting. Their methodology needed to be revised and indifferent to the integrity of the voting process. This attack could be more targeted because it needs to address the main problems of blockchain voting systems, especially the scalability and latency of electronic voting. They used a multi-chain architecture, a private blockchain based on Bitcoin unsuitable for a referendum. According to the authors, this method is only suitable for small and medium voting contexts. The main areas for improvement of past proposed blockchain-based voting systems are primarily related to security and scalability issues. Many previous models have used public blockchains, which are vulnerable to attacks from malicious actors. Moreover, the transparency of public blockchains can compromise voter anonymity, which is essential to ensuring free and fair elections. Scalability is another significant issue in previous blockchain-based voting models. Public blockchains, which are commonly used in many of these models, have limited transaction processing capabilities, which can result in long voting times and increased costs. Additionally, the high cost of transactions on public blockchains may make it difficult to implement blockchain-based voting systems on a large scale. Another challenge previous models faced was a standardized consensus mechanism for blockchain-based voting. Different models have used various consensus mechanisms, including proof of work, proof of stake, and delegated proof of stake. However, these mechanisms may not be suitable for large-scale voting systems due to their high resource requirements. The drawback of an online voting system where anyone can cast a vote instead of the intended user is the issue of voter authentication and identification. In a traditional paper-based voting system, voters must physically present themselves at the polling station and verify their identity through government-issued identification, such as a passport or driver’s license. However, in an online voting system, demonstrating the voter’s identity is challenging, and there is a higher risk of fraud or impersonation. Another problem with online voting is that an attacker could gain unauthorized access to the voting system and cast votes on behalf of other users. Recent work in blockchain voting takes advantage of Zero Knowledge Proofs (ZKPs) to determine the rightful owner of the vote. ZKPs allow for verifying a statement without revealing information beyond what is necessary to prove the statement’s truth. This means it is possible to establish a valid vote without revealing the voter’s identity or any information about their voting preferences. One example of using ZKPs in blockchain voting is the implementation of a ZKP-based authentication mechanism, where voters provide their identity information to a trusted third party, which then generates cryptographic proof that the voter is eligible to cast a vote. The evidence is then submitted to the blockchain and verified using ZKPs, allowing the voter to cast a ballot without revealing their identity. Another example is using ZKP-based anonymous voting schemes, where voters can cast their votes without revealing their preferences or identity. This is achieved using ZKPs to prove a valid vote without revealing any information. The use of ZKPs in blockchain voting provides a promising avenue for addressing the challenge of verifying the rightful owner’s identity while preserving the voter’s privacy and anonymity. To address the shortcomings of previous blockchain voting systems, our proposed blockchain voting system offers three key contributions:\n• None A novel blockchain architecture with a hybrid consensus mechanism and a modular design was proposed, effectively improving the system’s security, scalability, and transparency capabilities for conducting secure and efficient voting.\n• None The proposed blockchain voting system integrates face recognition to deal with the issue of unauthorized access and impersonation. AIML-based face recognition can significantly enhance the security of online voting systems by reducing the risk of unauthorized voting.\n• None The proposed blockchain voting system has better performance and security capabilities than other classical models and can ensure the voting results’ anonymity, integrity, and accuracy while maintaining the voters’ privacy.\n\nThe proposed work plan considers two main modules to be completed in three phases. The two modules are the front end for the application and the back end using Solidity to implement Blockchain. Each of these modules will be considered as one phase, and the remaining phase will cover the connection and testing of these modules. In this phase, the frontend module will be covered, which involves building the interactive user interface for the admin and the user. Research on implementing Blockchain in a decentralized application will be done in parallel. The frontend module has two main components: the admin and user modules. Admin Module: The admin module is divided into five components: dashboard, add candidate, create election, election details, and candidate details. Figure 2 shows the functions of the admin module.\n• None Dashboard: The dashboard component will contain various charts to display information such as the number of parties, voters, etc. This component will give the admin an overview of the election process and help them make informed decisions.\n• None Add Candidate: In this admin feature, they can add candidates standing in the election. After the candidate is added, it will be displayed on the user side. This component will enable the admin to manage the list of candidates and ensure that only authorized candidates are on the ballot.\n• None Create Election: This admin feature will allow them to create an election. A user can cast their vote only after the admin makes the election. A user can cast a vote between the start date and the end date. This component will enable the admin to set the parameters for the election, such as the start and end date, the number of voters, and the type of election.\n• None Election Details: In this section, the admin can update election details such as the start date, end date, etc. This component will enable the admin to manage the election process and make changes if necessary.\n• None Candidate Details: All the candidates added by the admin will be displayed in the candidate details component. The admin can update the candidate details if a wrong entry is made. This component will enable the admin to manage the list of candidates and ensure that the correct information is displayed [ 22 23 ]. User Module: The user module has four components: dashboard, voter register, voting area, and results. Figure 3 shows the functions of the user module.\n• None Dashboard: The user dashboard contains information about parties and their candidates. A user can see all the information about a candidate. This component will give the user an overview of the election process and help them make informed decisions.\n• None Voter Register: In this section, the first user will have to register themselves; only then will they be able to cast their vote. This component will enable the user to register and ensure that only authorized voters can cast their votes.\n• None Voting Area: After a user is registered, they will only be directed to this page and can vote. This component will enable the user to vote and ensure that only authorized voters can participate in the election.\n• None Result: The Results page will provide users with access to view the outcome of the voting process, including the final results and other relevant details. This section ensures transparency and informs users about the election’s outcome. Phase 2 of this blockchain voting methodology involves the implementation of the blockchain using the Ethereum framework and converting the system into a decentralized application. In this phase, the back-end module will be developed using the Solidity programming language, which is used for designing smart contracts on the Ethereum blockchain. The first step in implementing the back-end module is to define the smart contracts for the voting system. Smart contracts enable the automation of contract execution and management, enabling a more efficient and secure way to execute transactions. The smart contracts in this system will handle the voting process, including adding candidates, creating elections, registering voters, and counting votes. The smart contracts will be deployed on the Ethereum blockchain, a decentralized platform that enables the creation of decentralized applications. The blockchain will store all the information related to the voting process, including candidate details, election details, and voter details. Figure 4 represents blockchain data model. The Ethereum blockchain is based on an algorithm called Proof of Work (PoW), which ensures that the transactions on the blockchain are secure and transparent. This consensus algorithm ensures that the transactions on the blockchain are irreversible and tamper-proof. Figure 5 has code of block structure. The next step in implementing the back-end module is creating the necessary Solidity functions to handle the voting process. These functions will add candidates, create elections, register voters, and count votes. The parts will be programmed in Solidity and deployed on the Ethereum blockchain. One of the key advantages of using a blockchain-based system for voting is that it provides transparency and security. The blockchain ensures that all transactions are secure and tamper-proof, allowing for a transparent and auditable voting process. Since the data on the blockchain is decentralized and distributed across multiple nodes, it is difficult for anyone to manipulate the data or hack the system. The next step is to test the back-end module once the smart contracts and functions are defined and programmed. This involves running various test cases to ensure the system functions as expected. The testing will cover different scenarios, including adding candidates, creating elections, registering voters, and casting votes. The testing will also cover strategies related to security and performance, ensuring that the system is secure and efficient. Once the back-end module is tested and verified, it will be integrated with the front-end module in the project’s final phase. Combining the two modules will involve connecting the user interface with the blockchain, ensuring that the front end can interact with the back end and display the results of the voting process. In conclusion, Phase 2 of this blockchain voting methodology involves the implementation of the back-end module using the Solidity programming language and the Ethereum blockchain. The back-end module will handle voting, including adding candidates, creating elections, registering voters, and counting votes. The blockchain provides transparency and security to the voting process, ensuring the transactions are secure and tamper-proof. Testing the back-end module will ensure that the system is functioning as expected, and integrating the back-end with the front-end will complete the development of the blockchain voting system. Phase 3 of the proposed blockchain voting methodology focuses on connecting the frontend and backend modules and testing the platform to ensure its functionality and security. This phase is crucial to ensure the entire project’s success, as it involves the integration of the two modules and verifying their functionality. The first step in Phase 3 is to connect the frontend and backend modules. This links the frontend module’s user interface with the backend module’s smart contracts. The connection should be secure and efficient to ensure the integrity and reliability of the voting process. This is achieved through RESTful APIs, which provide a standardized way of accessing the backend services from the frontend application. Another critical aspect of Phase 3 is ensuring the system is user-friendly and accessible to all users. This involves testing the system with a diverse group of users to identify any potential barriers to accessibility, such as language or usability issues. The system is designed with accessibility in mind to ensure that all users, regardless of their technical abilities or background, can quickly and efficiently cast their votes. It involves the connection of the frontend and backend modules, rigorous system testing, and ensuring its usability and accessibility. By following a well-planned and executed process, the proposed blockchain voting system easily overcomes the limitations of existing voting systems. It provides a secure, transparent, and efficient way to conduct elections. Integration of Firebase cloud and face recognition is also implemented in this face. The data flow in a blockchain voting system is described as follows:\n• None User Registration: The first step in the data flow of a blockchain voting system is the user registration process. Users must register by providing basic information such as their name, address, and date of birth. This information is stored in the user database to verify the user’s identity during voting.\n• None Election Creation: Once the users have registered, the administrator can create an election by setting the start and end dates, the list of candidates contesting the election, and other relevant details. This information is stored in the election database.\n• None Voting: The user logs into the voting application and selects the candidate during the voting process. The vote is then encrypted using the user’s private key and stored in the blockchain. This ensures that the vote is secure and cannot be tampered with.\n• None Vote Counting: The votes are counted once the voting period ends. The smart contract deployed on the blockchain tallies the votes and declares the winner. The results are stored in the blockchain and can be viewed by anyone.\n• None Verification: The blockchain voting system allows voters to verify that their vote was recorded correctly. The user can use their private key to decrypt their vote and verify that it was registered correctly. This ensures the integrity of the voting process. The data flow in a blockchain voting system is designed to be transparent, secure, and tamper-proof. Blockchain technology ensures that the voting process is fast and cannot be manipulated by any individual or group. The system’s transparency allows for easy verification of the results, which helps build trust in voting [ 8 ]. Overall, the data flow of a blockchain voting system is a critical component of the system design. It ensures that the system is secure, transparent, and tamper-proof, which are essential for maintaining the integrity of the voting process. One of the critical aspects of the proposed blockchain-based voting system is the secure storage and management of voter registration data. This data contains sensitive information, including voters’ details and unique identification numbers. Any unauthorized access or tampering of this data could compromise the entire election process. In the proposed blockchain voting system, when voters register to participate in an election, their registration data is collected and stored securely on Firebase Cloud. This data includes the voter’s name, address, age, and other relevant details required to verify their voting eligibility. When voters attempt to vote, the blockchain verifies their identity by accessing their registration data on Firebase Cloud. The blockchain checks the voter’s ID and cross-references it with their personal information to determine that the voter is eligible to cast their vote. If the information matches, the voter is allowed to proceed with casting their vote. Furthermore, integrating Firebase Cloud with the blockchain voting system also offers other benefits. For instance, Firebase Cloud’s scalability ensures the system can handle a large volume of voter registration data. This feature is essential in countries with a large voter population where traditional voting systems need help to cope with the sheer number of voters. Moreover, Firebase Cloud’s accessibility is another advantage that it brings to the table. It enables voters to register for voting from anywhere worldwide, as long as they have an internet connection. This feature increases the convenience of the voting process, making it more accessible to a broader range of people. It provides a secure and scalable platform for storing voter registration data and allows the blockchain to verify the identity of voters before they can cast their votes. The real-time updates feature ensures the data is up-to-date and accurate, enhancing the system’s security. Finally, the accessibility of Firebase Cloud makes the voting process more convenient for voters, increasing the overall participation rate [ 24 25 ]. Integrating AIML face recognition technology with a blockchain-based voting system involves several steps. Firstly, a face recognition model needs to be trained using a large dataset of faces to recognize and verify individuals accurately. This model can be based on machine learning algorithms such as neural networks or support vector machines. Once the model is trained, it must be integrated with the blockchain-based voting system through smart contracts. These smart contracts can be designed to capture and store the facial biometric data of registered voters in a secure and encrypted manner. When a voter logs in to the voting system, the smart contract can use the face recognition model to verify their identity. To ensure the privacy and security of voters, the facial biometric data can be stored on a separate cloud-based service, such as Firebase, integrated with the blockchain-based voting system. This allows for secure and efficient access to necessary data during voting. is the flowchart of the proposed blockchain voting system. It explains the process flow of every step involved via graphical representation. The voter’s identity is verified through a unique identifier provided during registration. During the voting process, the voter submits their vote through an interface linked to the blockchain network. The vote is then verified through smart contracts and stored on the blockchain in a secure and immutable manner. The voter can also track their vote through the blockchain to ensure accuracy and transparency. Vote casting involves the voter accessing the voting application and selecting their preferred candidate. Once the vote is cast, it is recorded on the blockchain and cannot be altered. Subsequent vote counting involves tallying the votes recorded on the blockchain to determine the election results. The ballots can be counted manually or using an automated system, depending on the size of the election and the resources available. Depending on the development of the previous step, the winner is declared, or the system initiates a runoff election. is the flowchart of the proposed blockchain voting system. It explains the process flow of every step involved via graphical representation. The voter’s identity is verified through a unique identifier provided during registration. During the voting process, the voter submits their vote through an interface linked to the blockchain network. The vote is then verified through smart contracts and stored on the blockchain in a secure and immutable manner. The voter can also track their vote through the blockchain to ensure accuracy and transparency. Vote casting involves the voter accessing the voting application and selecting their preferred candidate. Once the vote is cast, it is recorded on the blockchain and cannot be altered. Subsequent vote counting involves tallying the votes recorded on the blockchain to determine the election results. The ballots can be counted manually or using an automated system, depending on the size of the election and the resources available. Depending on the development of the previous step, the winner is declared, or the system initiates a runoff election. Figure 6 is the flowchart of the proposed blockchain voting system. It explains the process flow of every step involved via graphical representation. The voter’s identity is verified through a unique identifier provided during registration. During the voting process, the voter submits their vote through an interface linked to the blockchain network. The vote is then verified through smart contracts and stored on the blockchain in a secure and immutable manner. The voter can also track their vote through the blockchain to ensure accuracy and transparency. Vote casting involves the voter accessing the voting application and selecting their preferred candidate. Once the vote is cast, it is recorded on the blockchain and cannot be altered. Subsequent vote counting involves tallying the votes recorded on the blockchain to determine the election results. The ballots can be counted manually or using an automated system, depending on the size of the election and the resources available. Depending on the development of the previous step, the winner is declared, or the system initiates a runoff election. is the sequence figure of the proposed blockchain voting system. A sequence diagram is a tool to visualize the interactions between different objects in a system over time. It begins with the voter registering for the election, and their information is stored securely on the Firebase Cloud. When voters attempt to vote, their identity is verified through the blockchain using the stored registration data. Once the voter selects a candidate, the vote is added as a transaction on the blockchain. The transaction includes information about the voter, the candidate they voted for, and the voting time. A sequence diagram helps demonstrate a blockchain voting system’s interactions and processes. It can help to identify potential bottlenecks or areas for improvement while also showcasing the transparency and security features of the system. is the sequence figure of the proposed blockchain voting system. A sequence diagram is a tool to visualize the interactions between different objects in a system over time. It begins with the voter registering for the election, and their information is stored securely on the Firebase Cloud. When voters attempt to vote, their identity is verified through the blockchain using the stored registration data. Once the voter selects a candidate, the vote is added as a transaction on the blockchain. The transaction includes information about the voter, the candidate they voted for, and the voting time. A sequence diagram helps demonstrate a blockchain voting system’s interactions and processes. It can help to identify potential bottlenecks or areas for improvement while also showcasing the transparency and security features of the system. Figure 7 is the sequence figure of the proposed blockchain voting system. A sequence diagram is a tool to visualize the interactions between different objects in a system over time. It begins with the voter registering for the election, and their information is stored securely on the Firebase Cloud. When voters attempt to vote, their identity is verified through the blockchain using the stored registration data. Once the voter selects a candidate, the vote is added as a transaction on the blockchain. The transaction includes information about the voter, the candidate they voted for, and the voting time. A sequence diagram helps demonstrate a blockchain voting system’s interactions and processes. It can help to identify potential bottlenecks or areas for improvement while also showcasing the transparency and security features of the system. represents the data flow of the proposed system. The data flow in a blockchain voting system starts with the voter registration process, where the voters. The vote is encrypted for security and privacy. The blockchain then verifies the vote’s validity and adds it to the ledger. The results are then tallied and published on a public website for transparency. Overall, the data flow involves the interaction between the voter, the blockchain, and the Firebase Cloud. This ensures the voting process’s security and accuracy while allowing easy access to information and results. By utilizing these technologies, the voting process becomes more efficient and transparent, which helps to increase trust in the system. represents the data flow of the proposed system. The data flow in a blockchain voting system starts with the voter registration process, where the voters. The vote is encrypted for security and privacy. The blockchain then verifies the vote’s validity and adds it to the ledger. The results are then tallied and published on a public website for transparency. Overall, the data flow involves the interaction between the voter, the blockchain, and the Firebase Cloud. This ensures the voting process’s security and accuracy while allowing easy access to information and results. By utilizing these technologies, the voting process becomes more efficient and transparent, which helps to increase trust in the system. Figure 8 represents the data flow of the proposed system. The data flow in a blockchain voting system starts with the voter registration process, where the voters. The vote is encrypted for security and privacy. The blockchain then verifies the vote’s validity and adds it to the ledger. The results are then tallied and published on a public website for transparency. Overall, the data flow involves the interaction between the voter, the blockchain, and the Firebase Cloud. This ensures the voting process’s security and accuracy while allowing easy access to information and results. By utilizing these technologies, the voting process becomes more efficient and transparent, which helps to increase trust in the system. Section 4.2 has a more detailed explanation of data flow and the various approaches involved. compares different blockchain technologies used in voting. The first column lists the names of the blockchain technologies, and the second column briefly describes each technology. The information in this table was populated through research and testing. We have thoroughly reviewed the literature to identify the most commonly used blockchain technologies in voting. We also tested each of these technologies to evaluate their performance. compares different blockchain technologies used in voting. The first column lists the names of the blockchain technologies, and the second column briefly describes each technology. The information in this table was populated through research and testing. We have thoroughly reviewed the literature to identify the most commonly used blockchain technologies in voting. We also tested each of these technologies to evaluate their performance. Table 2 compares different blockchain technologies used in voting. The first column lists the names of the blockchain technologies, and the second column briefly describes each technology. The information in this table was populated through research and testing. We have thoroughly reviewed the literature to identify the most commonly used blockchain technologies in voting. We also tested each of these technologies to evaluate their performance. Table 2 comprehensively compares blockchain-based voting systems based on several essential features. Each system has its unique characteristics, strengths, and weaknesses. Therefore, it is crucial to consider the requirements of a particular voting scenario before selecting an appropriate blockchain-based voting system. For example, if the main goal is to achieve complete anonymity for voters, System 2 or System 4 may be a better choice. System 2 or 4 may be more suitable if scalability is the primary concern. Alternatively, if the main priority is to minimize cost, System 2 may be the best option. presents six different blockchain technologies used in the voting process. The first column, Technology, includes the names of the technologies: Ethereum, Hyperledger Fabric, Corda, EOSIO, Stellar, and IOTA. The second column, Description, briefly explains each technology’s characteristics. presents six different blockchain technologies used in the voting process. The first column, Technology, includes the names of the technologies: Ethereum, Hyperledger Fabric, Corda, EOSIO, Stellar, and IOTA. The second column, Description, briefly explains each technology’s characteristics. Table 3 presents six different blockchain technologies used in the voting process. The first column, Technology, includes the names of the technologies: Ethereum, Hyperledger Fabric, Corda, EOSIO, Stellar, and IOTA. The second column, Description, briefly explains each technology’s characteristics. compares the proposed blockchain voting system with several others based on various parameters. The first parameter is the reference framework used in each design. The proposed method and two different systems use Ethereum as their reference framework, while the other use Bitcoin and Multichain. The following parameter is anonymity, which indicates whether the system offers voters anonymity. Three systems, including the proposed method, use anonymity measures to protect voters’ privacy. However, the Multichain and Bitcoin-based systems do not provide any anonymity measures. The third parameter is affordability, which refers to the cost of the system. Only the Bitcoin-based system is affordable, while the others are relatively expensive. The fourth parameter is accuracy, which indicates how accurately the system records votes. Four plans, including the proposed method, provide accurate vote recording. The fifth parameter is accessibility, which refers to how easily the system can be used. Four out of five systems offer accessibility to voters, while one system (Bitcoin-based) does not. The last parameter is scalability, which refers to how well the system can handle increasing number of users. Four out of five systems are scalable, while one system (Multichain-based) is not. The proposed model has several advantages over the existing systems in the table. We have focused on providing complete anonymity to voters, an essential feature of any voting system. The proposed model is also affordable, accurate, accessible, and scalable, which is crucial for any voting system. The authors have used Ethereum as their blockchain framework for the proposed method. compares the proposed blockchain voting system with several others based on various parameters. The first parameter is the reference framework used in each design. The proposed method and two different systems use Ethereum as their reference framework, while the other use Bitcoin and Multichain. The following parameter is anonymity, which indicates whether the system offers voters anonymity. Three systems, including the proposed method, use anonymity measures to protect voters’ privacy. However, the Multichain and Bitcoin-based systems do not provide any anonymity measures. The third parameter is affordability, which refers to the cost of the system. Only the Bitcoin-based system is affordable, while the others are relatively expensive. The fourth parameter is accuracy, which indicates how accurately the system records votes. Four plans, including the proposed method, provide accurate vote recording. The fifth parameter is accessibility, which refers to how easily the system can be used. Four out of five systems offer accessibility to voters, while one system (Bitcoin-based) does not. The last parameter is scalability, which refers to how well the system can handle increasing number of users. Four out of five systems are scalable, while one system (Multichain-based) is not. The proposed model has several advantages over the existing systems in the table. We have focused on providing complete anonymity to voters, an essential feature of any voting system. The proposed model is also affordable, accurate, accessible, and scalable, which is crucial for any voting system. The authors have used Ethereum as their blockchain framework for the proposed method. Table 4 compares the proposed blockchain voting system with several others based on various parameters. The first parameter is the reference framework used in each design. The proposed method and two different systems use Ethereum as their reference framework, while the other use Bitcoin and Multichain. The following parameter is anonymity, which indicates whether the system offers voters anonymity. Three systems, including the proposed method, use anonymity measures to protect voters’ privacy. However, the Multichain and Bitcoin-based systems do not provide any anonymity measures. The third parameter is affordability, which refers to the cost of the system. Only the Bitcoin-based system is affordable, while the others are relatively expensive. The fourth parameter is accuracy, which indicates how accurately the system records votes. Four plans, including the proposed method, provide accurate vote recording. The fifth parameter is accessibility, which refers to how easily the system can be used. Four out of five systems offer accessibility to voters, while one system (Bitcoin-based) does not. The last parameter is scalability, which refers to how well the system can handle increasing number of users. Four out of five systems are scalable, while one system (Multichain-based) is not. The proposed model has several advantages over the existing systems in the table. We have focused on providing complete anonymity to voters, an essential feature of any voting system. The proposed model is also affordable, accurate, accessible, and scalable, which is crucial for any voting system. The authors have used Ethereum as their blockchain framework for the proposed method.\n\n, a minimal probability. This makes it very difficult for anyone to alter the data in the blockchain without being detected. The SHA-256 hash function takes an input message and produces a fixed-size output hash value of 256 bits. The AES-256 encryption algorithm takes a plaintext message and a secret key and produces a ciphertext message of the same length [ One of the most promising applications of blockchain technology is in the field of voting. The decentralization and transparency provided by blockchain can potentially eliminate the issues of fraud and manipulation that plague traditional voting systems. Firstly, the cryptographic functions used in blockchain technology make it practically impossible to tamper with the data stored in the blocks. For example, the SHA-256 algorithm used in Bitcoin has a 256-bit output, meaning that the chances of finding two inputs that hash to the same output are approximately 1 in, a minimal probability. This makes it very difficult for anyone to alter the data in the blockchain without being detected. The SHA-256 hash function takes an input message and produces a fixed-size output hash value of 256 bits. The AES-256 encryption algorithm takes a plaintext message and a secret key and produces a ciphertext message of the same length [ 26 ]. We can represent the process of hashing the message M as follows: Let’s assume the input message M is “Voter A votes for candidate A”. We can compute the SHA-256 hash of M as follows: The resulting hash value is a 256-bit hexadecimal number. Next, we can represent the process of encrypting the message M using the AES-256 encryption algorithm as follows: C is the ciphertext, M is the plaintext message, and K is the secret key. Let’s assume that the private key is “secret123”. We can encrypt the plaintext message “Voter A votes for candidate A” using AES-256 as follows: The resulting ciphertext is a base64-encoded string of the same length as the plaintext message. By using both hashing and encryption techniques in a smart contract, we can ensure that the voting data is secure and tamper-proof on the blockchain. The efficiency of a blockchain-based voting system is determined by its ability to ensure fast and secure voting with minimal errors or delays. Additionally, the system’s decentralization ensures that votes are recorded and verified by a network of nodes rather than a central authority. This results in a more transparent and trustworthy voting process with higher accuracy and efficiency [ 27 ]. The main reason the blockchain-based voting system is preferable to the traditional approach is its efficiency. We have analyzed the efficiency of blockchain and conventional systems through tests and sample data. To test the proposed blockchain-based voting system, 1000 votes(V) were chosen to be cast, of which 800 were successful in an hour. The system’s efficiency is calculated as the ratio of the votes cast to the total time taken T, multiplied by the number of candidates C: This means that, on average, each candidate received about 13.2 votes per minute. To calculate the efficiency of a traditional voting system, we considered several factors, such as the time taken for vote counting, the number of errors made during the process, the accuracy of the results, and the level of transparency and trust in the system. A traditional voting system takes an average of 2 hours to count the votes, has a 1% error rate, and results in a 90% accuracy rate; the efficiency can be calculated using the following formula: 30,31,32,33,34,35,36,37,38,39,40, Therefore, the efficiency of the traditional voting system would be 0.0018. Comparing this to the efficiency of the blockchain-based voting system (0.0078), we can see that the blockchain-based system is more efficient in terms of time and accuracy. However, it is important to note that this is just one factor to consider, and other factors, such as security and trust, should also be evaluated before deciding on a voting system. However, there are also some potential drawbacks to consider. One issue is the risk of centralization, where a small group of entities control most of the blockchain’s computing power and therefore have a disproportionate influence over the voting process. Additionally, the immutability of blockchain can make it difficult to correct errors or address disputes once the voting process has ended. Another potential issue is the need for voter privacy. While blockchain provides transparency and accountability, it can also compromise the anonymity of voters if their identities are linked to their votes. To address this, some blockchain-based voting systems use zero-knowledge proofs, which allow voters to prove that they cast a valid vote without revealing their actual vote [ 28 ]. The main drawback of an online voting system where anyone can cast a vote instead of the intended user is the issue of voter authentication and identification. In a traditional paper-based voting system, voters must physically present themselves at the polling station and verify their identity through government-issued identification, such as a passport or driver’s license. However, in an online voting system, it is challenging to ascertain the identity of the voter, and there is a higher risk of fraud or impersonation [ 29 41 ]. The proposed system is integrated with AIML-based face recognition to tackle this issue. AIML-based face recognition is a modern technique that uses computer algorithms to detect and recognize human faces. In the context of online voting systems, this technology can combat the issue of unauthorized voting by verifying the identity of the person casting the vote. The system can ensure that only authorized users are casting votes by requiring users to present their faces in front of a camera during the voting process. The face recognition system uses various computer vision algorithms to detect and extract facial features such as the eyes, nose, and mouth from images. These features are then compared to a database of known faces to identify the person in the picture. The algorithm can also check for anomalies, such as masks or other facial coverings, that could be used to deceive the system. AIML-based face recognition can significantly enhance the security of online voting systems by reducing the risk of unauthorized voting. This technology provides a reliable and efficient way to verify the voter’s identity in real-time, significantly reducing the risk of fraud and manipulation. In addition to enhancing security, face recognition technology can also improve the user experience for voters. By streamlining the verification process, voters can quickly and easily cast their votes without requiring lengthy identity verification procedures. The purpose of this validation is to evaluate the performance of the proposed Blockchain Voting System. The validation process aims to test the system’s capabilities and identify any weaknesses or flaws that need improvement. To validate the Blockchain Voting System, we conducted a series of tests on different aspects of the system. These tests evaluated the system’s functionality, security, and usability. We tested the functionality of the Blockchain Voting System by simulating a mock election. During this simulation, we registered voters, recorded their votes, and counted the results. The system performed well during this test, accurately recording and counting all votes. Security is an essential aspect of any voting system, and the Blockchain Voting System has several security measures in place. We tested the system’s security by attempting to hack into the system and alter the recorded votes. However, the proposed model could not bypass the system’s security protocols, and all recorded votes remained unchanged. Usability is another crucial factor in a voting system, as it should be easy for voters to use and understand. We conducted a user study to evaluate the system’s usability. The results of this study showed that the system was intuitive and easy to use, with a user-friendly interface.\n• None System Performance: The system handled the sample data efficiently and promptly. The total time taken for the system to process all the votes was one hour, which is within acceptable limits. The plan also handled the total number of votes cast (800) and the number of eligible voters (1000) without any issues.\n• None Accuracy: The accuracy of the results was assessed by comparing the number of votes cast to the number of eligible voters and the number of candidates. The results were accurate, with 80% eligible voters casting their votes and five candidates being present in the election.\n• None Security: The system’s security was also tested and found to be secure due to smart contracts and encryption. The hashing and encryption algorithms used in the system were effective in protecting the integrity of the votes cast and ensuring that they could not be tampered with.\n• None User Experience: The system’s user experience was satisfactory, with an intuitive user interface and clear instructions for voters and administrators.\n• None Overall Efficiency: The efficiency of the system was evaluated using the formula: Efficiency = (Total number of votes cast / Total number of eligible voters) × 100% Plugging in the provided data: Efficiency = (800 / 1000) × 100% = 80% This indicates that the system achieved an efficiency of 80% in processing the votes cast, which is a good result. Based on the results of this validation test, it can be concluded that the proposed system is an effective and secure solution for conducting elections. The plan handled the sample data efficiently and accurately while providing a satisfactory user experience. The system’s efficiency in processing votes was also high, indicating that it is a viable alternative to traditional voting systems. includes columns for the validation criteria, test case, result, expected outcome, actual outcome, and pass/fail status. Each row represents a different validation test, such as voter registration or vote counting. The table can be used to track the results of each test, including any errors or unexpected outcomes that occurred during the testing process. The pass/fail status column indicates whether each test passed or failed based on the expected result. This type of validation table can be used to ensure the reliability and accuracy of the blockchain voting system. includes columns for the validation criteria, test case, result, expected outcome, actual outcome, and pass/fail status. Each row represents a different validation test, such as voter registration or vote counting. The table can be used to track the results of each test, including any errors or unexpected outcomes that occurred during the testing process. The pass/fail status column indicates whether each test passed or failed based on the expected result. This type of validation table can be used to ensure the reliability and accuracy of the blockchain voting system. Table 5 includes columns for the validation criteria, test case, result, expected outcome, actual outcome, and pass/fail status. Each row represents a different validation test, such as voter registration or vote counting. The table can be used to track the results of each test, including any errors or unexpected outcomes that occurred during the testing process. The pass/fail status column indicates whether each test passed or failed based on the expected result. This type of validation table can be used to ensure the reliability and accuracy of the blockchain voting system. shows the validation process results for the blockchain voting system. Each validation criterion is listed, along with whether it passed or failed. The requirements include accuracy of vote counting, integrity of the blockchain, security of voter information, ease of use for voters, and ease of use for administrators. The validation process found that all criteria passed, indicating that the system was effective and reliable. Validation is generated through vigorous testing on blockchain models like Ethereum and Multichain. Testing is applied on the local blockchain and deployed blockchain. shows the validation process results for the blockchain voting system. Each validation criterion is listed, along with whether it passed or failed. The requirements include accuracy of vote counting, integrity of the blockchain, security of voter information, ease of use for voters, and ease of use for administrators. The validation process found that all criteria passed, indicating that the system was effective and reliable. Validation is generated through vigorous testing on blockchain models like Ethereum and Multichain. Testing is applied on the local blockchain and deployed blockchain. Table 6 shows the validation process results for the blockchain voting system. Each validation criterion is listed, along with whether it passed or failed. The requirements include accuracy of vote counting, integrity of the blockchain, security of voter information, ease of use for voters, and ease of use for administrators. The validation process found that all criteria passed, indicating that the system was effective and reliable. Validation is generated through vigorous testing on blockchain models like Ethereum and Multichain. Testing is applied on the local blockchain and deployed blockchain.\n\nThe issue of maintaining a secure voting system is a prevalent problem in many countries. Current voting systems, such as the EVM in India, face significant problems, such as decreased security and privacy concerns. The proposed model presents solutions to these problems through a blockchain-based voting system that utilizes smart contracts to ensure voter privacy, increase voting motivation, and enhance overall election security. The proposed method used Ganache, a private Ethereum platform, to develop a decentralized application with numerous advantages, such as accurate traceability and high-security protocols. By utilizing a decentralized database, the proposed system offers a more secure voting process than existing centralized databases. One significant benefit of the proposed method is that voters can vote from anywhere and on any internet-enabled device. This feature enhances convenience and accessibility for voters and potentially increases voter turnout. Moreover, the proposed system increases voter motivation by instilling trust in voting, a crucial aspect of a fair election. While the proposed method offers numerous advantages over current voting systems, there are opportunities for future research to increase its security and accuracy. Implementing AIML can be utilized to identify the individuals casting their votes. This addition could provide an additional layer of protection to ensure that only eligible voters are casting their votes. The protocol could verify whether the person voting is the same person who registered during the registration process. By incorporating these concepts, the voting system could be made even more secure and trustworthy, ultimately ensuring a fair election. Our proposed model is validated and evaluated through simulations and experiments to ensure the accuracy and effectiveness of our proposed blockchain voting system. In conclusion, the proposed blockchain-based voting system with smart contracts offers numerous advantages over traditional voting systems. The system provides a more secure and private voting process while increasing convenience and accessibility for voters. Implementing AI and ML concepts could enhance the system’s security and accuracy, ensuring a fair and transparent election process. By utilizing this system, countries could provide a fair and transparent election process, instilling trust in the democratic process."
    }
]