[
    {
        "link": "https://docs.unity3d.com/Manual/class-ConfigurableJoint.html",
        "document": "Adds a visual gizmo \n\n A graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info to the Scene \n\n A Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info view that helps you edit joint angular limits. To use this gizmo, set the Angular X, Y, Z Motion to Limited and then handles appear for you to drag and adjust the joint’s rotational space.\n\nEnable Collision \n\n A collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info Enable this property to let the object with the joint collide with the object it is connected to. If this is disabled, the joint and object pass through each other."
    },
    {
        "link": "https://docs.unity3d.com/Manual/RagdollStability.html",
        "document": "This page provides tips for improving JointA physics component allowing a dynamic connection between Rigidbody components, usually allowing some degree of movement such as a hinge. More info\n\nSee in Glossary and Ragdoll stability.\n• Avoid small Joint angles of Angular Y Limit and Angular Z Limit. Depending on your setup, the minimum angles should be around 5 to 15 degrees in order to be stable. Instead of using a small angle, try setting the angle to zero. This locks the axis and provide a stable simulation.\n• Uncheck the Joint’s Enable Preprocessing property. Disabling preprocessing can help prevent Joints from separating or moving erratically if they are forced into situations where there is no possible way to satisfy the Joint constraints. This can occur if Rigidbody \n\n A component that allows a GameObject to be affected by simulated gravity and other forces. More info components connected by Joints are pulled apart by static collision \n\n A collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info geometry (for example, spawning a Ragdoll partially inside a wall).\n• Under extreme circumstances (such as spawning partially inside a wall or pushed with a large force), the joint solver is unable to keep the Rigidbody components of a Ragdoll together. This can result in stretching. To handle this, enable projection on the Joints using either ConfigurableJoint.projectionMode or CharacterJoint.enableProjection.\n• If Rigidbody components connected with Joints are jittering, open the Physics window (Edit > Project Settings \n\n A broad collection of settings which allow you to configure how Physics, Audio, Networking, Graphics, Input and many other areas of your project behave. More info , then select the Physics category) and try increasing the Default Solver Iterations value to between 10 and 20.\n• If Rigidbody components connected with Joints are not accurately responding to bounces, open the Physics window (Edit > Project Settings, then select the Physics__category) and try increasing the Default Solver Velocity Iterations__ value to between 10 and 20.\n• Never use direct Transform access with Kinematic Rigidbody components connected by Joints to other Rigidbody components. Doing so skips the step where PhysX computes internal velocities of corresponding Rigidbody components, making the solver provide unwanted results. A common example of bad practice is using direct Transform access in 2D projects to flip characters, by altering Transform.TransformDirection on the root bone of the rig. This behaves much better if you use Rigidbody2D.MovePosition and Rigidbody2D.MoveRotation instead.\n• Avoid large differences in the masses between Rigidbody components connected by Joints. It’s okay to have one Rigidbody with twice as much mass as another, but when one mass is ten times larger than the other, the simulation can become jittery.\n• Try to avoid scaling different from 1 in the Transform containing Rigidbody or the Joint. The scaling might not be robust in all cases.\n• If Rigidbody components are overlapping when inserted into the world, and you cannot avoid the overlap, try lowering the Rigidbody.maxDepenetrationVelocity to make the Rigidbody components exit each other more smoothly."
    },
    {
        "link": "https://discussions.unity.com/t/does-unity-physics-have-configurable-joint-alternative-script-for-making-active-ragdoll/912395",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-can-configurable-joint-be-set-up/918483",
        "document": ""
    },
    {
        "link": "https://docs.unity.cn/2022.1/Documentation/Manual/class-ConfigurableJoint.html",
        "document": "Configurable Joints incorporate all the functionality of the other joint types and provide greater control of character movement. They are particularly useful when you want to customize the movement of a ragdoll and enforce certain poses on your characters. You can also use them to adapt jointsA physics component allowing a dynamic connection between Rigidbody components, usually allowing some degree of movement such as a hinge. More info\n\nSee in Glossary into highly specialized joints of your own design.\n\nAdds a visual gizmo \n\n A graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info to the Scene \n\n A Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info view that helps you edit joint angular limits. To use this gizmo, set the Angular X, Y, Z Motion to Limited and then handles appear for you to drag and adjust the joint’s rotational space. The Rigidbody \n\n A component that allows a GameObject to be affected by simulated gravity and other forces. More info object which the joint connects to. You can set this to None to indicate that the joint attaches to a fixed position in space rather than another Rigidbody. Anchor \n\n A UI layout tool that fixes a UI element to a parent element. Anchors are shown as four small triangular handles in the Scene View and anchor information is also shown in the Inspector. More info The point which defines the center of the joint. All physics-based simulations use this point as the center in calculations. The local axis that defines the object’s natural rotation based on physics simulation. Enable this setting to automatically calculate the Connected Anchor position to match the global position of the anchor property. This is the default setting. Disable it to configure the position of the connected anchor manually. The Axis and Secondary Axis define the local coordinate system of the joint. The third axis is orthogonal to the other two. Set the movement along the X, Y or Z axes to be Free, completely Locked, or Limited according to the limit properties described below. Set the rotation around the X, Y or Z axes to be Free, completely Locked, or Limited according to the limit properties described below. Apply a spring force to pull the object back when it goes past the limit position. The spring force. Set this value to zero to make the limit impassable. A value other than zero makes the limit elastic. The reduction of the spring force in proportion to the speed of the joint’s movement. Set a value above zero to allow the joint to “dampen” oscillations which would otherwise carry on indefinitely. Set a limit on the joint’s linear movement (i.e., movement over distance rather than rotation), specified as a distance from the joint’s origin. The distance in world units from the origin to the limit. Set a bounce force to apply to the object to push it back when it reaches the limit distance. Contact Distance \n\n A joint limit property that sets the minimum distance tolerance between the joint position and the limit at which the limit will be enforced. More info The minimum distance tolerance between the joint position and the limit to enforce the limit. A high tolerance means the limit is less likely to be violated when the object is moving fast. However, this requires the limit to be taken into account by the physics simulation more often and reduces performance slightly. Apply a spring torque to rotate the object back when it goes past the limit angle of the joint. The spring torque. Set this value to zero to make the limit impassable. Set a value other than zero to make the limit elastic. The reduction of the spring torque in proportion to the speed of the joint’s rotation. Set a value above zero to allow the joint to “dampen” oscillations which would otherwise carry on indefinitely. Lower limit on the joint’s rotation around the x-axis, specified as an angle from the joint’s original rotation. Set a bounce torque to apply to the object when its rotation reaches the limit angle. The minimum angular tolerance (between the joint angle and the limit) at which the limit will be enforced. A high tolerance violates the limit less often when the object is moving fast. However, this requires the physics simulation to take into account the limit more often and reduces performance slightly. This is similar to the Low Angular X Limit property described above but it determines the upper angular limit of the joint’s rotation rather than the lower limit. This is similar to the Angular X Limit Spring described above but applies to rotation around both the Y and Z axes. This is similar to the Angular X Limit property described above but applies the limit to the y-axis and regards both the upper and lower angular limits as the same. This is similar to the Angular X Limit property described above but applies the limit to the z-axis and regards both the upper and lower angular limits as the same. The target position that the joint’s drive force moves to. The desired velocity that the joint moves to the Target Position under the drive force. Set the force that Unity uses to rotate the joint around its local x-axis by the Position Spring and Position Damper drive torques. The Maximum Force parameter limits the force. This property is only available if the Rotation Drive Mode property is set to X & YZ. For more information, see Drive force section below. The spring torque that Unity uses to rotate the joint from its current position towards its target position. Reduces the amount of spring torque in proportion to the difference between the joint’s current velocity and its target velocity. This reduces the speed of the joint’s movement. Set a value above zero to allow the joint to dampen oscillations which would otherwise carry on indefinitely. Limits the amount of force that the drive can apply. To make the drive apply the force that it’s calculated, set this to a high value that the drive is unlikely to calculate. This is similar to the X Drive described above but applies to the joint’s y-axis. This is similar to the X Drive described above but applies to the joint’s z-axis. The orientation that the joint’s rotational drive rotates towards, specified as a quaternion \n\n Unity’s standard way of representing rotations as data. When writing code that deals with rotations, you should usually use the Quaternion class and its methods. More info . The target rotation is relative to the body that the Joint is attached to, unless the Swap Bodies parameter is set, in which case it’s relative to the connected body’s anchor. The angular velocity that the joint’s rotational drive aims to achieve. The property is specified as a vector. The vector’s length specifies the rotational speed and whose direction defines the axis of rotation. Set how Unity applies drive force to the object to rotate it to the target orientation. Set the mode to X and YZ, to apply the torque around the axes as specified by the Angular X/YZ Drive properties described below. If you use Slerp mode then the Slerp Drive properties determine the drive torque. This specifies how the drive torque rotates the joint around its local x-axis. This property is only available if the Rotation Drive Mode property described above is set to X & YZ. For more information, see Drive force section below. The spring torque that Unity uses to rotate the joint from its current position towards its target position. Reduces the amount of spring torque in proportion to the difference between the joint’s current velocity and its target velocity. This reduces the speed of the joint’s movement. Set a value above zero to allow the joint to dampen oscillations which would otherwise carry on indefinitely. Limits the amount of force that the drive can apply. To make the drive apply the force that it’s calculated, set this to a high value that the drive is unlikely to calculate. This is similar to the Angular X Drive described above but applies to both the joint’s Y and Z axes. This specifies how the drive torque rotates the joint around all local axes. The property is only available if the Rotation Drive Mode property described above is set to Slerp. For more information, see Slerp Drive section below. The spring torque that Unity uses to rotate the joint from its current position towards its target position. Reduces the amount of spring torque in proportion to the difference between the joint’s current velocity and its target velocity. This reduces the speed of the joint’s movement. Set a value above zero to allow the joint to dampen oscillations which would otherwise carry on indefinitely. Limits the amount of force that the drive can apply. To make the drive apply the force that it’s calculated, set this to a high value that the drive is unlikely to calculate. This defines how the joint snaps back to its constraints when it unexpectedly moves beyond them, because the physics engine \n\n A system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info is unable to reconcile the current combination of forces within the simulation. The options are None and Position and Rotation. The distance the joint must move beyond its constraints before the physics engine attempts to snap it back to an acceptable position. The angle the joint must rotate beyond its constraints before the physics engine attempts to snap it back to an acceptable position. Enable this property to calculate the values set by the various target and drive properties in world space instead of the object’s local space. Enable this property to swap the order in which the physics engine processes the Rigidbodies involved in the joint. This results in different joint motion but has no impact on Rigidbodies and anchors. If a force larger than this value pushes the joint beyond its constraints then the joint is permanently “broken” and deleted. Break Torque only breaks a joint when its axes are Limited or Locked (see Constraining movement section below). If a torque larger than this value rotates the joint beyond its constraints then the joint is permanently “broken” and deleted. Break Force can break a joint regardless of whether its axes are Free, Limited or Locked (see Constraining movement section below). Enable this property to let the object with the joint collide with the object it is connected to. If this is disabled, the joint and object will pass through each other. If preprocessing is disabled then certain “impossible” configurations of the joint are kept more stable rather than drifting wildly out of control. The scale to apply to the inverted mass and inertia tensor of the Rigidbody, ranging from 0.00001 to infinity. This is useful when the joint connects two Rigidbodies of largely varying mass. The physics solver produces better results when the connected Rigidbodies have a similar mass. When your connected Rigidbodies vary in mass, use this property with the Connect Mass Scale property to apply fake masses to make them roughly equal to each other. This produces a high-quality and stable simulation, but reduces the physical behaviour of the Rigidbodies. The scale to apply to the inverted mass and inertia tensor of the connected Rigidbody, ranging from 0.00001 to infinity.\n\nLike the other joints, you can use the Configurable Joint to restrict the movement of an object but you can also use it to drive it to a target velocity or position with forces. Because there are a lot of configuration options,you may need to experiment with them to get the joint to behave exactly the way you want.\n\nYou can constrain both the translational movement and rotation on each joint axis independently using the X, Y, Z Motion and X, Y, Z Rotation properties. Enable Configured In World Space to constrain movements to the world axes rather than the object’s local axes. Each of these properties can be set to Locked, Limited or Free:\n• A Locked axis restricts all movement, so the joint cannot move at all. For example, an object locked in the world y-axis cannot move up or down.\n• A Limited axis allows free movement between predefined limits, as explained below. For example, a gun turret might be given a restricted arc of fire by limiting its Y rotation to a specific angular range.\n\nYou can limit translational movement using the Linear Limit property, which defines the maximum distance the joint can move from its point of origin (measured along each axis separately). For example, you can constrain the puck for an air hockey table by locking the joint in the y-axis (in world space), leaving it free in the z-axis and setting the limit for the x-axis to fit the width of the table; the puck is then constrained to stay within the playing area.\n\nYou can also limit rotation using the Angular Limit properties. Unlike the linear limit, you can specify different limit values for each axis with this property. You can also define separate upper and lower limits on the angle of rotation for the x-axis; the other two axes use the same angle either side of the original rotation. For example, you can construct a “teeter table” by using a flat plane with a joint constrained to allow slight tilting in the X and Z directions while leaving the Y rotation locked.\n\nBy default, a joint stops moving when it runs into its limit. However, an inelastic collisionA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary like this is rare in the real world and so it is useful to add some feeling of bounce to a constrained joint. To make the constrained object bounce back after it hits its limit, use the Bounciness property of the linear and angular limits. Most collisions look more natural with a small amount of bounciness but you can also set this property higher to simulate unusually bouncy boundaries like the cushions of a pool table.\n\nTo soften the joint limits even more, use the spring properties: Linear Limit Spring for translation and Angular X/YZ Limit Spring for rotation. If you set the Spring property to a value above zero, the joint does not abruptly stop moving when it hits a limit, but is drawn back to the limit position by a spring force. The strength of the force is determined by the Spring value. By default, the spring is perfectly elastic and will catapult the joint back in the opposite direction to the collision.\n\nYou can use the Damper property to reduce the elasticity and return the joint to the limit more gently. For example, you can use a spring jointA joint type that connects two Rigidbody components together but allows the distance between them to change as though they were connected by a spring. More info\n\nSee in Glossary to create a lever that you can pull to the left or right, but then it springs back to an upright position. If the springs are perfectly elastic then the lever will oscillate back and forth around the centre point after it is released. However, if you add enough damping then the spring will rapidly settle down to the neutral position.\n\nNot only can a joint react to the movements of object it is attached to, but it can also actively apply drive forces to set the object in motion. Some joints need to keep the object moving at a constant speed, such as a rotary motor turning a fan blade. Use the Target Velocity and Target Angular Velocity properties to set your desired velocity for such joints.\n\nYou might need to use joints that move their object towards a particular position in space,or a particular orientation. Use the Target Position and Target Rotation properties to set this functionality. For example, to implement a forklift, mount the forks on a configurable joint and then set the target height to raise them from a script.\n\nWith the target set, the X, Y, Z Drive and Angular X/YZ Drive (or alternatively Slerp Drive) properties specify the force to use to push the joint toward it. The Drives’ Mode property selects whether the joint should seek a target position, velocity or both. The Position Spring and Position Damper work in the same way as for the joint limits when they seek a target position. In velocity mode, the spring force depends on the “distance” between the current velocity and the target velocity; the damper helps the velocity to settle at the chosen value rather than oscillating endlessly around it. For example, the formula for the XDrive force is:\n\nSo, the force grows proportional to the difference between the current value and the target value, and reduces by the damper proportional to the difference between the current velocity and the target one. Unity applies the force to both positional and rotational drives.\n\nThe Maximum Force property is a final refinement that prevents the force applied by the spring from exceeding a limit value regardless of how far the joint is from its target. This prevents a joint that you stretch far from its target from rapidly snapping the object back in an uncontrolled way.\n\nWhen you use any drive force (except for Slerp Drive, described below), the joint applies the force to the object separately in each axis. For example, you can implement a spacecraft that has a high forward flying speed but a relatively low speed in sideways steering motion.\n\nUnlike the other drive modes that apply forces in separate axes, the Slerp Drive uses the quaternion’s spherical interpolation or “slerp” functionality to reorient the joint. Rather than isolating individual axes, the slerp process finds the minimum total rotation that takes the object from the current orientation to the target, and applies it on all axes as necessary. Slerp drive is slightly easier to configure but you cannot specify different drive forces for the X and Y/Z axes.\n\nTo enable Slerp drive, change the Rotation Drive Mode property from X and YZ to Slerp. A joint can use either the Angular X/YZ Drive values or the Slerp Drive values, but not both."
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/5a4zad/examples_of_things_to_put_in_fixedupdate",
        "document": "I've been googling for almost an hour now and still don't have any idea what goes into FixedUpdate. The common answer I've read a hundred times is:\n• Everything else into Update()\n\nAnd then every time someone asks about his physics related stuff in FixedUpdate() not producing the right result it's 'oh yeah, not that. That has to be in Update\". Things like input and object movement all seem to go into Update, although they basically are everything the physics system consists of. So this leads me to believe that the only physics stuff that's supposed to be in FixedUpdate() is continuous movement like... tumbleweed rolling around in the desert?\n\nMy question is this: can you give me any practical example of something that goes into FixedUpdate()?\n\nWhen I need some physics or collisions I either\n• Need input from the player -> Update()\n• Use an effector -> No need for code\n• Play an animation of something\n\nI can't think of a single 'continuous physics action' that would lead me to use FixedUpdate. I don't get it."
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/9pfssf/should_i_use_update_or_fixedupdate_for_movement",
        "document": "A subreddit for News, Help, Resources, and Conversation regarding Unity, the game engine. Do NOT use your phone to take screenshots. Video and photos of computer screens taken by phones are NOT allowed. All screenshots must be grabbed from the computer itself."
    },
    {
        "link": "https://discussions.unity.com/t/using-update-for-input-sensing-and-fixedupdate-for-physics-movement/924391",
        "document": ""
    },
    {
        "link": "https://gamedevbeginner.com/how-to-use-fixed-update-in-unity",
        "document": "Even if you’re new to scripting in Unity, you’re probably already familiar with the Update function.\n\nUpdate is an event function in Unity that’s called every frame. It’s one of the first functions you’re likely to use and, typically, it’s where most of your game’s logic will go.\n\nAs you start to work with other parts of Unity you may also notice another type of update function, called Fixed Update.\n\nCompared to Update, which is called every frame, Fixed Update is called independently of framerate, at measured intervals, in sync with the game’s physics system.\n\nAs a result, Fixed Update is usually used for physics-based functions, such as applying force to a Rigidbody.\n\nWhile choosing when to use Update or Fixed Update can be simple, it can sometimes be difficult to understand exactly what’s going on behind the scenes.\n\nWhich can make it tricky to know for sure if you’re using Fixed Update in the right way.\n\nIn this article, you’ll learn exactly how Fixed Update works, the right time to use it instead of Update, and when to avoid it entirely.\n\nHere’s what you’ll find on this page:\n• The difference between Update and Fixed Update in Unity\n• When to use Fixed Update in Unity\n\nUpdate is a special function in Unity that’s called on every script, during every frame.\n\nMeaning that Update is called at a variable rate, depending on how fast the game is running.\n\nFixed Update on the other hand, is called at measured intervals, meaning that fixed update is always called at a consistent rate, which, by default, is 50 frames per second.\n\nTypically, most of the logic in your game will happen in Update, either directly inside the Update loop or triggered by an event that is, itself, powered by Update.\n\nWhile Fixed Update, which is called in sync with Unity’s physics system, is usually reserved for physics-based functions only.\n\nSo, as a general rule, it’s best to place logical code in Update and physics-based functions in Fixed Update.\n\nHowever… unfortunately, it’s not always that simple.\n\nFor example, to move an object in Fixed Update, you’ll probably need to make input checks that, in order to work correctly, will need to be in Update.\n\nLikewise, there will often be times when you’ll want to access the physics system, which includes Raycasts and Colliders, from an Update based function.\n\nWhich is why just putting physics in Fixed Update and everything else in Update, isn’t always as simple as it sounds.\n\nFor that reason, it can help to understand what’s actually happening behind the scenes when Fixed Update is called.\n\nSo, how does Fixed Update work?\n\nFixed Update runs on a fixed timestep that will almost always be different to Update’s variable rate.\n\nWhich means that Fixed Update might be called once during a frame, twice, or not at all, depending on the speed of the game.\n\nFor example, by default, Fixed Update is called once every 0.02 seconds, which is a rate of 50 frames per second.\n\nWhich means that, when the game is running at 60 frames per second, Fixed Update is called once per frame for most frames but not all.\n\nWhen the framerate of the game is higher than the physics rate, there will be some frames where Update is called, but Fixed Update isn’t.\n\nHowever, if the framerate of the game is lower than the physics rate, Fixed Update could be called more than once in a single frame.\n\nWhile this chart is representative of how Unity is calculating the rate of Fixed Update calls compared to Update, it can be misleading.\n\nBased on this chart, you might think that Fixed Update could be called early in a frame, or late, depending on the relative frequencies of the two event functions.\n\nHowever, that’s not how Fixed Update works.\n\nSo when, exactly, is Fixed Update called during a frame?\n\nFor example, Awake is called before On Enable, On Enable is called before Start and, in the Update Loop, Fixed Update is always called before Update.\n\nThis is because, while the frequency of Update and Fixed Update are different, they’re not asynchronous, Fixed Update is always called first, before Update.\n\nSo how does Unity know when to call Fixed Update and when to not?\n• At the beginning of the frame, Unity calculates Delta Time, which is the amount of time between the current frame and the one before it, and adds that amount to the total Time value, bringing it up to date.\n• Next, Unity will check to see if the total Fixed Time is behind Time by at least the length of a physics step (0.02 seconds by default).\n• If it is behind, a physics step is processed, Fixed Update is called and the Fixed Delta Time, the length of a physics step, is added to the Fixed Time total.\n• At that point, if Fixed Time is still behind Time, another physics step will be processed, and so on, looping around until Time and Fixed Time are within a physics step of each other.\n• After which, the Fixed Update phase ends and Unity moves on to Update, Late Update and, finally, rendering to finish the frame.\n\nWhat this means is that, if multiple Fixed Updates are required to take place during a frame, they will all be processed, one by one before Update.\n\nExactly how many times Fixed Update is called in a frame depends on the amount of time since the last frame and the Fixed Update Rate.\n\nHow does the Fixed Update Rate in Unity work?\n\nThe rate at which Fixed Update is called is based on the duration of the Fixed Timestep, which is the amount of time between each Fixed Update call.\n\nBy default, the Fixed Timestep value is 0.02 seconds, which is equivalent to a rate of 50 frames per second.\n\nHowever, it’s possible to change the Fixed Timestep value in the Time panel of the Project Settings menu.\n\nOr in code, by setting the Fixed Delta Time value of the Time class.\n\nThe Fixed Timestep value determines how frequently the physics engine and, with it, Fixed Update calls, are processed.\n\nThis means that objects under physics simulation will often move at a different rate to the framerate of the game.\n\nFor example, an object that’s being moved under physics will appear to move at the same rate as Fixed Update.\n\nWhich, at the default 50fps, may look choppy or jittery compared to the same movement in Update, particularly if the game is actually running much faster.\n\nThis happens because the movement calculations that place a physics object in each new position will only take place in each physics step so, even if the actual framerate of the game is significantly faster, the position of the physics object won’t change until the next Fixed Update call.\n\nNo matter how fast the game runs.\n\nWhich can be especially frustrating for physics-powered first-person character controllers, or when physics controlled players are followed by Update controlled cameras, where the effect of a lower framerate will be obviously noticeable.\n\nHow can you move physics objects smoothly?\n\nHow to fix choppy movement in Fixed Update\n\nJittery, choppy movement is caused by the Fixed Timestep value of the physics engine, and occurs when the framerate of the game is higher than the physics rate.\n\nGenerally, there are two options for creating smooth physics-based movement in Unity.\n\nThe first option is to enable Interpolation on the object’s Rigidbody.\n\nInterpolation is a feature of the Rigidbody component that will blend the visual display of physics steps together.\n\nWhile the accuracy of the physics system will be the same, it will appear to move much more smoothly, at the same framerate as the rest of the game.\n\nIt’s generally recommended to enable Interpolation on objects where the, usually, slower rate of the physics engine is felt the most, such as the player object or a camera controller.\n\nHowever, interpolation doesn’t change how often the physics system is updated.\n\nIt only smooths the appearance of selected objects and their movement between frames.\n\nMeaning that, if you want every physics object in the game to move more smoothly, without interpolating their Rigidbody components, you’ll need to increase the Fixed Timestep value instead.\n\nWhich will cause the physics engine to update more often, providing a smoother, more accurate, physics simulation.\n\nBut, how does changing the speed of the physics engine affect the performance of the game?\n\nWhat happens when you change the Fixed Update Rate?\n\nWhen you change the Fixed Timestep value, you change how often physics in Unity are calculated.\n\nIncreasing the timestep value reduces the frequency of Fixed Update calls, improving performance by, effectively, lowering the physics framerate.\n\nWhile reducing the amount of time between Fixed Update calls will improve the accuracy and the framerate of the physics simulation, at the expense of an increased CPU load.\n\nIn many cases, unless you have a reason for changing the physics rate, it’s probably best to stick with the default value.\n\nHowever, if you do change the Fixed Timestep value, what will that actually mean for your project?\n\nHere’s what’s likely to happen in each scenario…\n\nIncreasing the Fixed Timestep will cause Fixed Update to be called less often, meaning that, more often than not, Fixed Update won’t be called in a frame.\n\nGenerally, this should improve the performance of the physics engine, but at the expense of accuracy.\n\nMeaning that physics objects will move at lower frame rates and with less precision.\n\nThis is because Fixed Update is being called less often and the physics engine has fewer points of data to calculate where an object should be.\n\nSo much so that, at extreme values, such as 0.2 seconds, for example (equivalent to just 5 frames per second) physics objects are likely to miss collisions entirely, causing objects to pass through one another.\n\nAlternatively, it’s possible to increase the precision and frequency of physics in Unity by simply reducing the Fixed Timestep value, making it more likely that Fixed Update will be called in every frame, multiple times.\n\nAs a result, the physics system will be more precise and will update more often, reducing the chance that the game’s framerate will be noticeably higher than physics movements.\n\nIncreasing the frequency of the physics system to make the game appear to run smoother can have the opposite effect if it places the physics engine under heavy load.\n\nSo, what actually happens when you put too much in Fixed Update?\n\nWhat happens if you put too much in Fixed Update?\n\nIf the physics system is under heavy load, and the game can’t process each physics step in the Fixed Timestep window, the frame will take longer to process, impacting performance.\n\nWhile the physics simulation will still be accurate, the game’s framerate will be lower as a result.\n\nIn extreme circumstances, consistently overloading the physics engine can cause performance degradation, where each frame takes longer to display than the last.\n\nThis is because the number of physics steps that are required in a frame are based on the duration of the last frame.\n\nSo, if the last frame took longer, because of a heavy physics load, Unity’s response will be to schedule even more physics steps in the next frame in order to meet the specified frequency of steps over the, now, increased Delta Time.\n\nMeaning that, if the physics engine is still under the same load, each frame will take longer and longer than the last, until the game freezes entirely:\n\nWhile it’s technically possible to drain performance in this way, in the vast majority of cases, this won’t happen.\n\nFirstly, for this test, in order to create a sustained heavy load that Unity couldn’t keep up with, I had to increase the Fixed Timestep frequency to an abnormally high level, in this case, equivalent to 5000 frames per second.\n\nSecondly, to allow Unity to even attempt to process all of the physics steps that were scheduled for each frame, I had to effectively disable the built-in failsafe, the Maximum Allowed Timestep value.\n\nWhile, generally speaking, you should only use Fixed Update for physics-based functions, it’s usually not that simple.\n\nThere will, no doubt, be times when you will want to do something physics related in Update, and there will probably be times when you’d like to do something in Fixed Update that would normally belong in Update, such as input checks, for example.\n\nSo what is ok and what isn’t?\n\nIs it ok to call physics functions from Update?\n\nIn Unity, even if you’re not using any Rigidbody objects, you will probably still find yourself working with the physics engine surprisingly often, such as checking a Raycast or a Collider for example.\n\nBut, because they’re physics functions, do those checks need to be carried out in Fixed Update? Or is it ok to run them in Update?\n\nGenerally speaking, it’s perfectly safe to carry out most physics-based checks in Update.\n\nThis is because all you’re really doing is checking if a Collider is in a certain position or if a Raycast returned a hit at the time the check was made.\n\nWhich, in Update, will always be after the most recent Fixed Update.\n\nWhat’s more, if the check you want to make is linked to a system that also operates in Update, such as input, or other game logic, it’s a good idea to keep the check, and any resulting action, in sync with each other.\n\nAlternatively, if the result of the physics-based check is to perform a physics action, such as using a Raycast to move a Rigidbody when it gets close to another object, then it’s better to use Fixed Update for both tasks.\n\nShould you use Update or Fixed Update for movement?\n\nIf you’re moving an object using its Transform component then you should generally use Update to do that.\n\nHowever, technically, the correct way to move a physics object is by using a Rigidbody component and moving it in Fixed Update.\n\nThis keeps the application of force on the Rigidbody in sync with the physics system that’s moving it, keeping the movement consistent and correct relative to other objects.\n\nHowever, there are exceptions to this rule.\n\nFor one-shot physics instructions, or immediate velocity changes, such as the Impulse mode of the Add Force function, you won’t need to use Fixed Update.\n\nBecause the function, in that mode, isn’t dependent on the Fixed Timestep duration, it’s safe to call it from Update, since it will only be triggered once anyway and doesn’t rely on Fixed Delta Time to be accurate.\n\nShould you use Update or Fixed Update for input?\n\nWhen checking for input in Unity, you will usually always need to use Update to do it.\n\nThis is because Unity’s input checks, such as Get Key Down and Get Mouse Button Down return true on a per-frame basis.\n\nWhich means that, unless Fixed Update is called reliably, and only once for every frame of the game, which it rarely is, some input checks are likely to be missed or duplicated, depending on how many Fixed Update calls are being processed.\n\nAs a result, it’s rarely a good idea to try to place input checks in Fixed Update, as it almost always leads to unreliable behaviour and missed input.\n\nIf you’re moving an object using physics, chances are that you’re using input to do it.\n\nSo how can you use input in Update to control a movement function that needs to take place in Fixed Update?\n\nHow to use Update and Fixed Update together\n\nIf you’re moving an object using its Rigidbody, then it’s best to do so in Fixed Update.\n\nHowever, if you want to control that object’s movement, you’ll need to check for input, which can only be reliably detected in Update.\n\nSo what can you do?\n\nOne simple solution is to keep both functions separate and connect them with a variable.\n\nFor example, it’s possible to set up a movement vector using input checks that take place in Update.\n\nThen, in Fixed Update, the movement vector can be passed into a function in Fixed Update to create physics-based movement.\n\nThis allows you to keep critical input checks where they belong, in Update, while applying physics forces correctly in Fixed Update."
    },
    {
        "link": "https://discussions.unity.com/t/input-and-applying-physics-update-or-fixedupdate/93315",
        "document": ""
    }
]