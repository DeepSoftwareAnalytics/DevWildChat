[
    {
        "link": "https://w3schools.com/js/js_es6.asp",
        "document": "ES6 is fully supported in all modern browsers since June 2017:\n\nES6 is not supported in Internet Explorer.\n\nThe keyword allows you to declare a variable with block scope.\n\nRead more about in the chapter: JavaScript Let.\n\nThe keyword allows you to declare a constant (a JavaScript variable with a constant value).\n\nConstants are similar to let variables, except that the value cannot be changed.\n\nRead more about in the chapter: JavaScript Const.\n\nYou don't need the keyword, the keyword, and the curly brackets.\n\nArrow functions do not have their own . They are not well suited for defining object methods.\n\nArrow functions are not hoisted. They must be defined before they are used.\n\nUsing is safer than using , because a function expression is always a constant value.\n\nYou can only omit the keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:\n\nLearn more about Arrow Functions in the chapter: JavaScript Arrow Function.\n\nDestructuring assignment makes it easy to assign array values and object properties to variables.\n\nDestructuring assignment makes it easy to assign array values and object properties to variables.\n\nThe ... operator expands an iterable (like an array) into more elements:\n\nThe ... operator can be used to expand an iterable into more arguments for function calls:\n\nThe JavaScript statement loops through the values of an iterable objects.\n\nlets you loop over data structures that are iterable such as Arrays, Strings, Maps, NodeLists, and more.\n\nThe loop has the following syntax:\n\nvariable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with , , or .\n\niterable - An object that has iterable properties.\n\nLearn more in the chapter: JavaScript Loop For/In/Of.\n\nLearn more about Map objects, and the difference between a Map and an Array, in the the chapter: JavaScript Maps.\n\nLearn more about Set objects in the the chapter: JavaScript Sets.\n\nUse the keyword to create a class.\n\nThe example above creates a class named \"Car\".\n\nThe class has two initial properties: \"name\" and \"year\".\n\nWhen you have a class, you can use the class to create objects:\n\nLearn more about classes in the the chapter: JavaScript Classes.\n\nA Promise is a JavaScript object that links \"Producing Code\" and \"Consuming Code\".\n\n\"Producing Code\" can take some time and \"Consuming Code\" must wait for the result.\n\nLearn more about Promises in the the chapter: JavaScript Promises.\n\nA JavaScript Symbol is a primitive data type just like Number, String, or Boolean.\n\nIt represents a unique \"hidden\" identifier that no other code can accidentally access.\n\nFor instance, if different coders want to add a person.id property to a person object belonging to a third-party code, they could mix each others values.\n\nUsing Symbol() to create a unique identifiers, solves this problem:\n\nES6 allows function parameters to have default values.\n\nThe rest parameter (...) allows a function to treat an indefinite number of arguments as an array:\n\nThe method returns if a string contains a specified value, otherwise :\n\nThe method returns if a string begins with a specified value, otherwise :\n\nThe method returns if a string ends with a specified value, otherwise :\n\nThe method returns an Array Iterator object with key/value pairs:\n\nThe method does not change the original array.\n\nThe method returns an Array object from any object with a length property or any iterable object.\n\nThe method returns an Array Iterator object with the keys of an array.\n\nThe method returns the value of the first array element that passes a test function.\n\nThis example finds (returns the value of ) the first element that is larger than 18:\n\nThe method returns the index of the first array element that passes a test function.\n\nThis example finds the index of the first element that is larger than 18:\n\nES6 added the following methods to the Math object:\n\nreturns if x is negative, null or positive:\n\nES6 added the following properties to the Number object:\n\nThe method returns if the argument is an integer.\n\nA safe integer is an integer that can be exactly represented as a double precision number.\n\nThe method returns if the argument is a safe integer.\n\nThe global method returns if the argument is or .\n\nThe global method returns if the argument is . Otherwise it returns :\n\nModules are imported in two different ways:\n\nLearn more about Modules in: JavaScript Modules."
    },
    {
        "link": "https://stackoverflow.com/questions/47329211/documentation-examples-for-non-trivial-es6-code",
        "document": "I am struggling to find decent documentation samples/references to document ES6 code, like some sort of cheatsheet for ES6 documentation.\n\nI'd like to align on JSDoc documentation, however amongst the most common answers to this question, I can only manage to find trivial code documentation, and not documentation that fits new ES6+/React syntaxes or more complex params like Arrays, maps, param deserializations, etc..\n\nFor instance does-javascript-have-a-standard-for-commenting-functions gives only documentation examples regarding regular JS function with standard params.\n\nI'd like to find rules / nice way to document something like this, how to indicate params that are required or not, etc.\n\nAn exemple of method I'd like to document\n\nI can think of something like this\n\nBut I'm not really sure how to handle deserialized params that don't really have a name , are nested or are renamed and how to handle composed types like an array of xxx\n\nI am already using for several method declarations but they only work when using React components, but are less useful when writing utility functions, etc. outside of react."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript",
        "document": "JavaScript (JS) is a lightweight interpreted (or just-in-time compiled) programming language with first-class functions. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js, Apache CouchDB and Adobe Acrobat. JavaScript is a prototype-based, multi-paradigm, single-threaded, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles.\n\nJavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via ), object introspection (via and utilities), and source-code recovery (JavaScript functions store their source text and can be retrieved through ).\n\nThis section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM.\n\nThe standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.\n\nDo not confuse JavaScript with the Java programming language — JavaScript is not \"Interpreted Java\". Both \"Java\" and \"JavaScript\" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.\n\nJavaScript documentation of core language features (pure ECMAScript, for the most part) includes the following:\n\nFor more information about JavaScript specifications and related technologies, see JavaScript technologies overview."
    },
    {
        "link": "https://stackoverflow.com/questions/40300940/declaring-a-function-in-es6",
        "document": "I wanted to \"update\" my javascript code to the new ES6 Standard, so I looked at how functions are now written and tried it out on a global function of mine, which reads like this in the \"old\" es5\n\nnow if I'm not wrong the correct \"transformation\" to ES6 would be like this:\n\nBut my ESLint tells me that my logMessage is not defined and I get an error in my console, do I miss something? Do I have to declare , or before the logMessage?\n\nI don't know if its important, but I also want to export this function from file One to file Two and use the function logMessage in another function in file Two, is there something I have to keep in mind when doing so?\n\nThanks for any help!\n\nEdit: Thanks everyone the answers helped me a lot, got my problem fixed!"
    },
    {
        "link": "https://tc39.es/ecma262",
        "document": ""
    },
    {
        "link": "https://raygun.com/blog/javascript-best-practices",
        "document": "The world’s biggest language comes with a huge collection of conventions and guidelines from the community’s collective wisdom. Following JavaScript best practices can help achieve faster page loads and better performance, improve code readability, and make maintenance and debugging easier. Carefully crafted code can also prevent errors and security issues, especially if it’s complemented with real-time diagnostic tools such as JavaScript error monitoring.\n\nIn this article, we’ll look into a selection of JavaScript best practices that you can use in frontend development.\n\n1. Choose a JavaScript coding style guide and stick to it\n\nEven though you can set up your own coding guidelines that fit with your goals, you don’t necessarily have to. There are multiple ready-to-use JavaScript coding style guides that are well tested and widely used across the industry. Some examples include the community-based Idiomatic JavaScript, the Google JavaScript Style Guide, and AirBnB’s JavaScript Style Guide.\n\nUsing a coding style guide is especially important in teamwork, where multiple developers are working on the same project. As Idiomatic JavaScript puts it, “all code in any code base should look like a single person typed it, no matter how many people contributed.” Whether you create your own style guide or use a third-party one, consistent code will be easier to read, write, debug, and maintain.\n\nMake the names of your variables, functions, and other code structures easy to understand for anyone who works with your code. Don’t use names that are either too short or too long, and take care that they succinctly describe their own purpose.\n\nSome good examples are (from the DOM API):\n\nAlso keep in mind that JavaScript is a case-sensitive language. As camel case capitalization is the most common naming system in JavaScript programming, you should use lower camelcase for variables and functions and upper camelcase for classes and interfaces for better code readability.\n\n3. Use shorthands, but be careful with them\n\nJavaScript includes many shorthands that allow you to write code faster and make your scripts load faster.\n\nThere are older shorthands that have been part of the JavaScript syntax for ages, such as the shorthand:\n\nAnd of course, there are newer ones, too, such as arrow functions introduced in ECMAScript 6:\n\nSometimes, however, shorthands might return surprising results. So, always be sure of what you’re doing, check the documentation, find relevant JavaScript code examples, and test the outcome.\n\nCommenting is a hot topic in programming. Some say it’s not necessary at all, but code without any comments gets hard to read after a while — especially when working on team or legacy projects. On the other hand, overly long and verbose comments are unnecessary because they’ll take extra time to read through and understand.\n\nAs a rule of thumb, comment your code, especially functions, classes, objects, and interfaces, but only include key information. To keep your comments concise and easy to read, use tags such as , , , , and others.\n\nHere’s an example of a short but descriptive comment from JSDoc’s guidelines:\n\nIf you comment your JavaScript code properly, you can also use a tool such as JSDoc to automatically generate documentation for your project.\n\nTaking separation of concerns (SoC) seriously is one of the most important JavaScript coding practices. Technically, JavaScript allows you to directly change the CSS code using the property. However, to make debugging easier and improve code maintainability, it’s best to avoid it.\n\nAs an alternative, you can add and remove classes using the API as follows (then add the style rules with CSS):\n\nAs global variables are available to all the scripts running on your page, they can easily be overridden by other variables using the same name. There are various ways to reduce the number of global variables, but ECMAScript 6 has introduced two new JavaScript statements you can use to declare variables in the local scope: and .\n\nBoth and create block-scoped local variables, but can be re-declared (in a different scope) while can’t. As opposed to , neither nor becomes a property of the object, so they can’t be accessed, and therefore overridden, by other scripts — even when they are declared globally (in the highest scope).\n\nYou can define with or without a value (however, it can only be read and written after full initialization), but you can’t declare without a value:\n\n7. Use instead of loops\n\nLoops can get costly performance-wise because you repeat the same operation over and over again. However, if you optimize them, you can make them run faster.\n\nThere are many JavaScript best practices to write more performant loops, such as avoiding nesting, keeping DOM manipulation outside of loops, and declaring a separate variable for the length of the loop (e.g. ).\n\nUsing the statement instead of is such a JavaScript coding practice, too. This syntax has been introduced by ECMAScript 6, and it includes a built-in iterator so that you don’t have to define the variable and the length value:\n\nYou can use the loop to iterate over any iterable object, such as arrays, strings, nodelists, maps, and more.\n\nThe topic of modularization comes up frequently in discussions of JavaScript best practices. Modularization means the splitting of larger files into smaller parts — a.k.a. reusable modules. ECMAScript modules and module bundlers such as Webpack help with setting up such architecture, but creating modular and reusable functions is just as important.\n\nAs the first SOLID design principle (single responsibility principle) states, every function, interface, class, and other code structure should perform only one task. Creating helper functions for common tasks is one way to follow this principle. Helper functions should be context-independent so that they can be called from any module.\n\nTo see some JavaScript functionality examples, check out The Vanilla JS Toolkit that includes smart helper functions such as , , , , and others. For example, here’s the function — as you can see, it performs one single action:\n\nUsing classes is another hot topic in JavaScript programming. Even though JavaScript has a prototypical inheritance model, ECMAScript 6 has introduced the class syntax to improve code readability. It’s frequently referred to as “syntactic sugar” as it doesn’t add any new functionality, and, as stated by the MDN Docs, classes are “being converted into Prototypal Inheritance models” under the hood.\n\nSo whether you use classes or not mainly depends on your preferences and project requirements — but if you do decide to use the class syntax, there are, of course, some JavaScript best practices to follow.\n\nFirst and foremost, you need to avoid creating irrelevant classes to build a well-structured application. Classes can be irrelevant for a couple of reasons, including:\n• Catch-all classes that do more than one thing (or everything)\n• Classes that only have data (properties) but no actions (methods) – try to move the data into another class\n• Classes that only include behavior (methods) but no data (properties) – in this case, it’s better to create a function\n\nOverall, classes should respect the single responsibility principle (similar to functions) and include both data and behavior, for example:\n\n10. Pay attention to (the lack of) hoisting when using classes\n\nIn JavaScript, classes are a special type of function, but they don’t always behave like ordinary functions, which can lead to some confusion.\n\nFor instance, unlike functions, classes are not hoisted. Hoisting means that the JavaScript interpreter moves function declarations to the top of their scope so that they can be called before being declared. When working with classes, you can’t take advantage of this feature, however.\n\nYou always need to declare a class before you call it, otherwise you’ll get an uncaught reference error. Following the previous example with the class:\n\nThe JavaScript coding practices discussed above can help you write cleaner and better-structured code that’s easier to maintain and debug. However, creating development code is just the first step of the software life cycle.\n\nEven if you’re diligently following these JavaScript best practices, errors can (and will) still occur when your end-users interact with your application. To ensure your users experience your code as intended, you need to detect and address errors in production. With JavaScript error tracking, you can take care of errors on the production side, monitoring your application in real-time, catching errors as they happen, and taking immediate action."
    },
    {
        "link": "https://w3schools.com/js/js_best_practices.asp",
        "document": "Minimize the use of global variables.\n\nThis includes all data types, objects, and functions.\n\nGlobal variables and functions can be overwritten by other scripts.\n\nUse local variables instead, and learn how to use closures.\n\nAll variables used in a function should be declared as local variables.\n\nLocal variables must be declared with the , the , or the keyword, otherwise they will become global variables.\n\nIt is a good coding practice to put all declarations at the top of each script or function.\n• Provide a single place to look for local variables\n\nThis also goes for loop variables:\n\nIt is a good coding practice to initialize variables when you declare them.\n\nDeclaring objects with const will prevent any accidental change of type:\n\nDeclaring arrays with const will prevent any accidential change of type:\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n\nA variable can contain all data types.\n\nBeware that numbers can accidentally be converted to strings or (Not a Number).\n\nWhen doing mathematical operations, JavaScript can convert numbers to strings:\n\nSubtracting a string from a string, does not generate an error but returns (Not a Number):\n\nThe comparison operator always converts (to matching types) before comparison.\n\nThe operator forces comparison of values and type:\n\nIf a function is called with a missing argument, the value of the missing argument is set to .\n\nUndefined values can break your code. It is a good habit to assign default values to arguments.\n\nRead more about function parameters and arguments at Function Parameters\n\nAlways end your statements with a . Even if you think there is no need for it.\n\nAlways treat numbers, strings, or booleans as primitive values. Not as objects.\n\nDeclaring these types as objects, slows down execution speed, and produces nasty side effects:\n\nThe function is used to run text as code. In almost all cases, it should not be necessary to use it.\n\nBecause it allows arbitrary code to be run, it also represents a security problem."
    },
    {
        "link": "https://stackoverflow.com/questions/48995513/javascript-functions-best-practices",
        "document": "There are several ways to declare functions and there are use cases and pros and cons to each. As a result, there is no \"preferred\" way. Use the appropriate syntax for your situation.\n\nBelow is a summary of the different ways to set up functions with a brief explanation of each. Click on the heading link to be directed to more in-depth resources on that type:\n\nWith a function declaration, the entire function is hoisted (regardless of it's actual location in the code) to the top of the enclosing scope. This makes it possible to invoke the function prior to its declaration point.\n\nFunction expressions are just variable declarations that assign a function (as data) to the variable. As with function declarations, there is hoisting here too, but only the variable ( in this example) declaration gets hoisted, not the assignment, so in this case you could not invoke the function prior to its declaration.\n\nThis is simply a short hand syntax instead of using a function expression. However, there is a difference with an arrow function. With Arrow Functions, the object that binds to is not affected within the function, while it is affected in a non-arrow function.\n\nAn Immediately Invoked Function Expression (IIFE) is an anonymous function (a function with no name) that is turned into an expression by wrapping it with parenthesis and then immediately invoked with another set of parenthesis. This syntax is very common in JavaScript and is used to create a scope that doesn't conflict with other scopes.\n\nFunctions are the work horses of JavaScript, depending on how you set them up and invoke them, they do many different things:\n• They can be units of directly invocable code.\n• They can be the value of a variable or property.\n• They can be constructor functions that are used to instantiate Object instances.\n• They can be raw data that is passed around via arguments."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/JavaScript",
        "document": "Opinions on correct indentation, whitespace, and line lengths have always been controversial. Discussions on these topics are a distraction from creating and maintaining content. On MDN Web Docs, we use Prettier as a code formatter to keep the code style consistent (and to avoid off-topic discussions). You can consult our configuration file to learn about the current rules, and read the Prettier documentation. Prettier formats all the code and keeps the style consistent. Nevertheless, there are a few additional rules that you need to follow.\n\nWhen loops are required, choose the appropriate one from , , , etc.\n• When iterating through all collection elements, avoid using the classical loop; prefer or . Note that if you are using a collection that is not an , you have to check that is actually supported (it requires the variable to be iterable), or that the method is actually present. Do not use — not only do you have to add an extra index, , but you also have to track the length of the array. This can be error-prone for beginners.\n• Make sure that you define the initializer properly by using the keyword for or for the other loops. Don't omit it. These are correct examples: const cats = [\"Athena\", \"Luna\"]; for (const cat of cats) { console.log(cat); } for (let i = 0; i < 4; i++) { result += arr[i]; } The example below does not follow the recommended guidelines for the initialization (it implicitly creates a global variable and will fail in strict mode):\n• When you need to access both the value and the index, you can use instead of . Write: Warning: Never use with arrays and strings. Note: Consider not using a loop at all. If you are using an (or a for some operations), consider using more semantic iteration methods instead, like , , , , , and many more.\n• Use short identifiers, and avoid non-common abbreviations. Good variable names are usually between 3 to 10-character long, but as a hint only. For example, is more descriptive than abbreviating to for the sake of character length.\n• Try to use real-world relevant examples where each variable has clear semantics. Only fall back to placeholder names like and when the example is simple and contrived.\n• Do not use the Hungarian notation naming convention. Do not prefix the variable name with its type. For example, write rather than or instead of .\n• For collections, avoid adding the type such as list, array, queue in the name. Use the content name in the plural form. For example, for an array of cars, use and not or . There may be exceptions, like when you want to show the abstract form of a feature without the context of a particular application.\n• For primitive values, use camelCase, starting with a lowercase character. Do not use . Use concise, human-readable, and semantic names where appropriate. For example, use rather than .\n• Avoid using articles and possessives. For example, use instead of or . There may be exceptions, like when describing a feature in general without a practical context.\n• Use variable names as shown here: Don't name variables like this: Note: The only place where it's allowed not to use human-readable, semantic names is where a very commonly recognized convention exists, such as using and for loop iterators."
    },
    {
        "link": "https://medium.com/@franciscomoretti/popular-ways-to-write-javascript-functions-787ac3cefd55",
        "document": "Learn about the popular ways to define functions in JavaScript, including Function Declaration, Function Expression, and Arrow Function.\n\nJavaScript offers various ways to define functions, each with its own strengths and use cases. Here are the most commonly used methods:\n\nUsage: Perfect for defining functions that need to be hoisted, meaning they can be called before they are declared.\n\nUsage: Useful for anonymous functions or when you want to assign a function to a variable.\n\nUsage: Provides a concise syntax, especially handy for short, one-liner functions. It also maintains the lexical , making it particularly useful for callbacks and event handlers.\n\nArrow Function with Implicit Return offers a shorthand for arrow functions. This example returns the expression.\n\nUsage: Offers a shorthand for arrow functions when the function body consists of a single expression."
    }
]