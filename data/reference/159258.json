[
    {
        "link": "https://github.com/ocornut/imgui/issues/7291",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://github.com/ocornut/imgui/issues/1174",
        "document": "In my renderer I use ImDrawList's outside of ImGui to render \"everything else\". At first this seemed to work well but now I have requirement to be able to set the Z index of any item and have it rendered in that order (everything is blended so can't use z buffer).\n\nTherefore this seems to mean I would need a sorted list of draw commands across ImDrawLists which doesn't really seem possible. The only workaround I can think of is make everything its own ImDrawList which is probably bad for performance?\n\nI don't know if there is some built in clean way to handle this that I haven't thought of? :)"
    },
    {
        "link": "https://github.com/ocornut/imgui/issues/1986",
        "document": "I'm trying to visually cluster groups of widgets (see #1496) (basically enclose them into some sort of box with a bacgrkound color) and to do so I found myself having to draw \"out of order\". I need to be able to draw behind a selected group of widgets; and I looked into the ChannelsSplit(). It's a very neat solution, but I found that columns are already \"under the effect\" of split channels, so you are not allowed to split channels when inside a column.\n\nIn the example below, ImGui throws an assert when doing bc we already are under a split."
    },
    {
        "link": "https://github.com/ocornut/imgui/issues/2613",
        "document": "Back-ends: imgui_impl_dx11.cpp + imgui_impl_win32.cpp (or specify if using a custom engine/back-end)\n\n Compiler: XXX (if the question is related to building or platform specific features)\n\n Operating System: Windows 10 Enterprise 1903 b18343.1\n\nToday I wanted to experiment a bit with ImGui's channel splitting, from what I've read, the main idea is to be able to render out-of-the-order. I am having difficulties with getting it to work. My text disappears after I merge channels when drawing something in between / calls.\n\nWhen not drawing anything in between these two calls, everything is fine.\n\nOften when drawing on multiple channels, only channel where the first drawing was made is being \"rendered\".\n\nStandalone, minimal, complete and verifiable example: (see #2261)\n\n/ Store a pointer to draw list to save a bit of typing ImDrawList* draw = ImGui::GetForegroundDrawList(); / That should create 2 channels for out-of-order drawing draw-> ( ); / That should be drawn ABOVE the red (below) rectangle draw-> ( ); draw-> ( ImVec2( . , . ), ImVec2( . , . ), IM_COL32( , , , ) ); / This should be drawn BEHIND the yellow (above) rectangle draw-> ( ); draw-> ( ImVec2( . , . ), ImVec2( . , . ), IM_COL32( , , , ) ); / Merge all channels, which should put these two rectangles above each other draw-> ();"
    },
    {
        "link": "https://skia.googlesource.com/external/github.com/ocornut/imgui/+/110f506ec0dd10999ed685c87c609553cb162028/imgui.h",
        "document": ""
    },
    {
        "link": "https://ahbejarano.gitbook.io/lwjglgamedev/chapter-10",
        "document": "Dear ImGui is a user interface library which can use several backends such as OpenGL and Vulkan. We will use it to display gui controls or to develop HUDs. It provides multiple widgets and the look and fell is easily customizable.\n\nYou can find the complete source code for this chapter here.\n\nThe first thing is adding Java Imgui wrapper maven dependencies to the project pom.xml. We need to add compile time and runtime dependencies.\n\nWith Imgui we can render windows, panels, etc. like we render any other 3D model, but using only 2D shapes. We set the controls that we want to use and Imgui translates that to a set of vertex buffers that we can render using shaders. This is why it can be used with any backend.\n\nFor each vertex, Imgui defines its coordinates (2D coordinates), texture coordinates and the associated color. Therefore, we need to create a new class to model Gui meshes and to create the associated VAO and VBO. The class, named is defined like this.\n\nAs you can see, we use a single VBO but we define several attributes for the positions, texture coordinates and color. In this case, we do not populate the buffers with data, we will see later on how we will use it.\n\nWe need also to let the application create GUI controls and react to the user input. In order to support this, we will define a new interface named which is defined like this:\n\nThe method will be used to construct the GUI, this where we will define the window and widgets that will be used to construct the GUI meshes. We will use the method to process input events in the GUI. It returns a boolean value to state that the input has been processed by the GUI or not. For example, if we display an overlapping window we may not be interested in keep processing keystrokes in the game logic. You can use the return value to control that. We will store the specific implementation of interface in the class.\n\nThe next step will be to create a new class to render our GUI, which will be named and starts like this:\n\nAs you can see, most of the stuff here will be very familiar to you, we just set up the shaders and the uniforms. Since we will need to set up a custom key callback to handle ImGui input text controls, we need to keep track of a previous key callback in to properly use it and free it. In addition to that, there is a new method called which is defined like this:\n\nIn the method above is where we setup Imgui, we first create a context (required to perform any operation), and set up the display size to the window size. Imgui stores the status in an ini file, since we do not want the status to persist between runs we need to set it to null. The next step is to initialize the font atlas and set up a texture which will be used in the shaders so we can render properly texts, etc. The final step is to create the instance.\n\nThe just creates a single two float for the scale (we will see later on how it will be used).\n\nThe method is required to properly process key events in Imgui and is defined like this:\n\nFirst we need to setup a GLFW key callback which first calls key call back to handle key events and translate GFLW key code sto Imgui ones. When setting a callback we obtain a reference to a previously established one so we can chain them. In this case we will invoke it if the key event is not handled by ImGui. We are not using char callbacks in other parts of the code, but if you do, remember to apply that chain schema also. After that, we set up the state of Imgui according to key pressed or released events. Finally, we need to setup a char call back so text input widgets can process those events.\n\nThe first thing that we do is to check if we have set up an implementation of the interface. If there is no instance, we just return, there is no need to render anything. After that we call the method. That is, in each render call we invoke that method so the Imgui can update its status to be able to generate the proper vertex data. After binding the shader we first enable blending which will allow us to use transparencies. Just by enabling blending, transparencies still will not show up. We need also to instruct OpenGL about how the blending will be applied. This is done through the function. You can check an excellent explanation about the details of the different functions that can be applied here.\n\nAfter that, we need to disable depth testing and face culling for Imgui to work properly. Then, we bind the gui mesh which defines the structure of the data and bind the data and indices buffers. Imgui uses screen coordinates to generate the vertices data, that is values cover the range and values cover the . We will use the uniform to map from that coordinate system to the range of OpenGL's clip space.\n\nAfter that, we retrieve the data generated by Imgui to render the GUI. Imgui first organizes the data in what they call command lists. Each command list has a buffer where it stores the vertex and indices data, so we first dump data to the GPU by calling the . Each command list defines also a set of commands which we will use to generate the draw calls. Each command stores the number of elements to be drawn and the offset to be applied to the buffer in the command list. When we have drawn all the elements we can re-enable the depth test.\n\nFinally, we need to add a method which will be called any time the window is resized to adjust Imgui display size.\n\nWe need to update the class to add support for 2D vectors:\n\nThe vertex shader used for rendering the GUI is quite simple ( ), we just transform the coordinates so they are in the range and output the texture coordinates and color so they can be used in the fragment shader:\n\nIn the fragment shader ( ) we just output the combination of the vertex color and the texture color associated to its texture coordinates:\n\nPutting it up all together\n\nNow we need to glue all the previous pices to render the GUI. We will first start by using the new class into the one.\n\nWe also need to modify the class to include in the update loop and to use its return value to indicate if input has been consumed or not.\n\nWe need also to update the interface to use the input consumed return value.\n\nAnd finally, we will implement the in the class:\n\nIn the method we just setup a new frame, the window position and just invoke the to generate Imgui's demo window. After ending the frame it is very important to call the this is what will generate the set of commands upon the GUI structure defined previously. The first gets mouse position and updates Imgui's IO class with that information and mouse button status. We also return a boolean that indicates that input has been capture by Imgui. Finally, we just need to update the method to receive that flag. In this specific case, if input has already been consumed by the Gui, we just return.\n\nWith all those changes you will be able to see Imgui demo window overlapping the rotating cube. You can interact with the different methods and panels to get a glimpse of the capabilities of Imgui."
    },
    {
        "link": "https://skia.googlesource.com/external/github.com/ocornut/imgui/+/refs/heads/features/doc_font/imgui.h",
        "document": ""
    }
]