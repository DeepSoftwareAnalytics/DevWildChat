[
    {
        "link": "https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7.5",
        "document": "The cmdlet starts one or more processes on the local computer. By default, creates a new process that inherits all the environment variables that are defined in the current process. To specify the program that runs in the process, enter an executable file or script file, or a file that can be opened using a program on the computer. If you specify a non-executable file, starts the program that's associated with the file, similar to the cmdlet. You can use the parameters of to specify options, such as loading a user profile, starting the process in a new window, or using alternate credentials.\n\nExample 1: Start a process that uses default values\n\nExample 3: Start a process to sort items to a new file\n\nExample 5: Start PowerShell as an administrator\n\nExample 6: Using different verbs to start a process\n\nThis example shows how to find the verbs that can be used when starting a process. The available verbs are determined by the filename extension of the file that runs in the process. The example uses to create a System.Diagnostics.ProcessStartInfo object for , the file that runs in the PowerShell process. The Verbs property of the ProcessStartInfo object shows that you can use the Open and verbs with , or with any process that runs a file.\n\nExample 7: Specifying arguments to the process\n\nOn Windows, creates an independent process that remains running independently of the launching shell. On non-Windows platforms, the newly started process is attached to the shell that launched. If the launching shell is closed, the child process is terminated. To avoid terminating the child process on Unix-like platforms, you can combine with . The following example launches a background instance of PowerShell on Linux that stays alive even after you close the launching session. The command collects output in file in the current directory. # Runs for 2 minutes and appends output to ./nohup.out Start-Process nohup 'pwsh -noprofile -c \"1..120 | % { Write-Host . -NoNewline; sleep 1 }\"' In this example, is running the Linux command, which launches as a detached process. For more information, see the nohup article on Wikipedia.\n\nExample 9: Overriding an environment variable for a process\n\nBy default, when you use , the new process is created with the same environment variables as the current session. You can use the Environment parameter to override the values of those variables. In this example, the environment variable is added to the session with as the value. The example runs three times, returning the value of each time. The first command doesn't override the environment variable. In the second command, is set to . In the third command, is set to , which removes it. $env:FOO = 'foo' Start-Process pwsh -NoNewWindow -ArgumentList '-c', '$env:FOO' Start-Process pwsh -NoNewWindow -ArgumentList '-c', '$env:FOO' -Environment @{ FOO = 'bar' } Start-Process pwsh -NoNewWindow -ArgumentList '-c', '$env:FOO' -Environment @{ FOO = $null } foo bar\n\nSpecifies parameters or parameter values to use when this cmdlet starts the process. Arguments can be accepted as a single string with the arguments separated by spaces, or as an array of strings separated by commas. The cmdlet joins the array into a single string with each element of the array separated by a single space. The outer quotes of the PowerShell strings aren't included when the ArgumentList values are passed to the new process. If parameters or parameter values contain a space or quotes, they need to be surrounded with escaped double quotes. For more information, see about_Quoting_Rules. For the best results, use a single ArgumentList value containing all the arguments and any needed quote characters.\n\nSpecifies one or more environment variables to override for the process as a hash table. Specify the name of an environment variable as a key in the hash table and the desired value. To unset an environment variable, specify its value as . The specified variables are replaced in the process. When you specify the environment variable it's replaced with the value of followed by the specified value from this parameter. On Windows, the command appends the values for in the Machine and User scopes after the new value. This parameter was added in PowerShell 7.4.\n\nSpecifies a verb to use when this cmdlet starts the process. The verbs that are available are determined by the filename extension of the file that runs in the process. The following table shows the verbs for some common process file types. To find the verbs that can be used with the file that runs in a process, use the cmdlet to create a System.Diagnostics.ProcessStartInfo object for the file. The available verbs are in the Verbs property of the ProcessStartInfo object. For details, see the examples.\n\nPowerShell includes the following aliases for : Native commands are executable files installed in the operating system. These executables can be run from any command-line shell, like PowerShell. Usually you run the command exactly as you would in or . The cmdlet can be used to run any native commands, but should only be used when you need to control how the command is executed. is useful for running GUI programs on non-Windows platforms. For example, run to launch the graphical text editor common the GNOME Desktop environments. By default, launches a process asynchronously. Control is instantly returned to PowerShell even if the new process is still running.\n• On the local system, the launched process lives on independent from the calling process.\n• On a remote system, the new process is terminated when the remote session ends, immediately following the command. Therefore, you can't use in a remote session expecting the launched process to outlive the session. If you do need to use in a remote session, invoke it with the Wait parameter. Or you could use other methods to create a new process on the remote system. When using the Wait parameter, waits for the process tree (the process and all its descendants) to exit before returning control. This is different than the behavior of the cmdlet, which only waits for the specified processes to exit. On Windows, the most common use case for is to use the Wait parameter to block progress until the new process exits. On non-Windows system, this is rarely needed since the default behavior for command-line applications is equivalent to . This cmdlet is implemented using the Start method of the System.Diagnostics.Process class. For more information about this method, see Process.Start Method."
    },
    {
        "link": "https://stackoverflow.com/questions/7690994/running-a-command-as-administrator-using-powershell",
        "document": "Everything I read so far requires you to supply the administrator password.\n\nI'm wondering how to do this with a PowerShell script. I do not want to have to enter my password; I just want to mimic the right-click Run As Administrator method.\n\nYou know how if you're the administrative user of a system and you can just right click say, a batch script and run it as Administrator without entering the administrator password?\n\nBenjamin Armstrong posted an excellent article about self-elevating PowerShell scripts. There a few minor issue with his code; a modified version based on fixes suggested in the comment is below. Basically it gets the identity associated with the current process, checks whether it is an administrator, and if it isn't, creates a new PowerShell process with administrator privileges and terminates the old process. # Get the ID and security principal of the current user account $myWindowsID = [System.Security.Principal.WindowsIdentity]::GetCurrent(); $myWindowsPrincipal = New-Object System.Security.Principal.WindowsPrincipal($myWindowsID); # Get the security principal for the administrator role $adminRole = [System.Security.Principal.WindowsBuiltInRole]::Administrator; # Check to see if we are currently running as an administrator if ($myWindowsPrincipal.IsInRole($adminRole)) { # We are running as an administrator, so change the title and background colour to indicate this $Host.UI.RawUI.WindowTitle = $myInvocation.MyCommand.Definition + \"(Elevated)\"; $Host.UI.RawUI.BackgroundColor = \"DarkBlue\"; Clear-Host; } else { # We are not running as an administrator, so relaunch as administrator # Create a new process object that starts PowerShell $newProcess = New-Object System.Diagnostics.ProcessStartInfo \"PowerShell\"; # Specify the current script path and name as a parameter with added scope and support for scripts with spaces in it's path $newProcess.Arguments = \"& '\" + $script:MyInvocation.MyCommand.Path + \"'\" # Indicate that the process should be elevated $newProcess.Verb = \"runas\"; # Start the new process [System.Diagnostics.Process]::Start($newProcess); # Exit from the current, unelevated, process Exit; } # Run your code that needs to be elevated here... Write-Host -NoNewLine \"Press any key to continue...\"; $null = $Host.UI.RawUI.ReadKey(\"NoEcho,IncludeKeyDown\");\n\nYou can create a batch file (*.bat) that runs your powershell script with administrative privileges when double-clicked. In this way, you do not need to change anything in your powershell script.To do this, create a batch file with the same name and location of your powershell script and then put the following content in it: Assuming your powershell script is in the path C:\\Temp\\ScriptTest.ps1, your batch file must have the path C:\\Temp\\ScriptTest.bat. When someone execute this batch file, the following steps will occur:\n• None The cmd will execute the command\n• None A new powershell session will open and the following command will be executed:\n• None Another new powershell session with administrative privileges will open in the system32 folder and the following arguments will be passed to it:\n• None The following command will be executed with administrative privileges: Once the script path and name arguments are double quoted, they can contain space or single quotation mark characters (').\n• None The current folder will change from system32 to C:\\Temp and the script will be executed. Once the parameter was passed, the window wont be closed, even if your powershell script throws some exception.\n\nYou need to rerun the script with administrative privileges and check if the script was launched in that mode. Below I have written a script that has two functions: DoElevatedOperations and DoStandardOperations. You should place your code that requires admin rights into the first one and standard operations into the second. The IsRunAsAdmin variable is used to identify the admin mode. My code is an simplified extract from the Microsoft script that is automatically generated when you create an app package for Windows Store apps. param( [switch]$IsRunAsAdmin = $false ) # Get our script path $ScriptPath = (Get-Variable MyInvocation).Value.MyCommand.Path # # Launches an elevated process running the current script to perform tasks # that require administrative privileges. This function waits until the # elevated process terminates. # function LaunchElevated { # Set up command line arguments to the elevated process $RelaunchArgs = '-ExecutionPolicy Unrestricted -file \"' + $ScriptPath + '\" -IsRunAsAdmin' # Launch the process and wait for it to finish try { $AdminProcess = Start-Process \"$PsHome\\PowerShell.exe\" -Verb RunAs -ArgumentList $RelaunchArgs -PassThru } catch { $Error[0] # Dump details about the last error exit 1 } # Wait until the elevated process terminates while (!($AdminProcess.HasExited)) { Start-Sleep -Seconds 2 } } function DoElevatedOperations { Write-Host \"Do elevated operations\" } function DoStandardOperations { Write-Host \"Do standard operations\" LaunchElevated } # # Main script entry point # if ($IsRunAsAdmin) { DoElevatedOperations } else { DoStandardOperations }\n\nis where the shortcut of PowerShell resides. It too still goes to a different location to invoke the actual 'exe' ( ). Since PowerShell is user-profile driven when permissions are concerned; if your username/profile has the permissions to do something then under that profile, in PowerShell you would generally be able to do it as well. That being said, it would make sense that you would alter the shortcut located under your user profile, for example, . Right-click and click properties. Click \"Advanced\" button under the \"Shortcut\" tab located right below the \"Comments\" text field adjacent to the right of two other buttons, \"Open File Location\" and \"Change Icon\", respectively. Check the checkbox that reads, \"Run as Administrator\". Click , then and . Once again right click the icon labeled 'Windows PowerShell' located in and select \"Pin to Start Menu/Taskbar\". Now whenever you click that icon, it will invoke the UAC for escalation. After selecting 'YES', you will notice the PowerShell console open and it will be labeled \"Administrator\" on the top of the screen. To go a step further... you could right click that same icon shortcut in your profile location of Windows PowerShell and assign a keyboard shortcut that will do the exact same thing as if you clicked the recently added icon. So where it says \"Shortcut Key\" put in a keyboard key/button combination like: + + P (for PowerShell). Click and . Now all you have to do is press that button combination you assigned and you will see UAC get invoked, and after you select 'YES' you will see a PowerShell console appear and \"Administrator\" displayed on the title bar.\n\nThe problem with the @pgk and @Andrew Odri's answers is when you have script parameters, specially when they are mandatory. You can solve this problem using the following approach:\n• The user right-clicks the .ps1 file and selects 'Run with PowerShell': ask him for the parameters through input boxes (this is a much better option than use the HelpMessage parameter attribute);\n• The user executes the script through the console: allow him to pass the desired parameters and let the console force him to inform the mandatory ones. Here is how would be the code if the script had the ComputerName and Port mandatory parameters: [CmdletBinding(DefaultParametersetName='RunWithPowerShellContextMenu')] param ( [parameter(ParameterSetName='CallFromCommandLine')] [switch] $CallFromCommandLine, [parameter(Mandatory=$false, ParameterSetName='RunWithPowerShellContextMenu')] [parameter(Mandatory=$true, ParameterSetName='CallFromCommandLine')] [string] $ComputerName, [parameter(Mandatory=$false, ParameterSetName='RunWithPowerShellContextMenu')] [parameter(Mandatory=$true, ParameterSetName='CallFromCommandLine')] [UInt16] $Port ) function Assert-AdministrativePrivileges([bool] $CalledFromRunWithPowerShellMenu) { $isAdministrator = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) if ($isAdministrator) { if (!$CalledFromRunWithPowerShellMenu -and !$CallFromCommandLine) { # Must call itself asking for obligatory parameters & \"$PSCommandPath\" @script:PSBoundParameters -CallFromCommandLine Exit } } else { if (!$CalledFromRunWithPowerShellMenu -and !$CallFromCommandLine) { $serializedParams = [Management.Automation.PSSerializer]::Serialize($script:PSBoundParameters) $scriptStr = @\" `$serializedParams = '$($serializedParams -replace \"'\", \"''\")' `$params = [Management.Automation.PSSerializer]::Deserialize(`$serializedParams) & \"$PSCommandPath\" @params -CallFromCommandLine \"@ $scriptBytes = [System.Text.Encoding]::Unicode.GetBytes($scriptStr) $encodedCommand = [Convert]::ToBase64String($scriptBytes) # If this script is called from another one, the execution flow must wait for this script to finish. Start-Process -FilePath 'powershell' -ArgumentList \"-ExecutionPolicy Bypass -NoProfile -EncodedCommand $encodedCommand\" -Verb 'RunAs' -Wait } else { # When you use the \"Run with PowerShell\" feature, the Windows PowerShell console window appears only briefly. # The NoExit option makes the window stay visible, so the user can see the script result. Start-Process -FilePath 'powershell' -ArgumentList \"-ExecutionPolicy Bypass -NoProfile -NoExit -File \"\"$PSCommandPath\"\"\" -Verb 'RunAs' } Exit } } function Get-UserParameters() { [string] $script:ComputerName = [Microsoft.VisualBasic.Interaction]::InputBox('Enter a computer name:', 'Testing Network Connection') if ($script:ComputerName -eq '') { throw 'The computer name is required.' } [string] $inputPort = [Microsoft.VisualBasic.Interaction]::InputBox('Enter a TCP port:', 'Testing Network Connection') if ($inputPort -ne '') { if (-not [UInt16]::TryParse($inputPort, [ref]$script:Port)) { throw \"The value '$inputPort' is invalid for a port number.\" } } else { throw 'The TCP port is required.' } } # $MyInvocation.Line is empty in the second script execution, when a new powershell session # is started for this script via Start-Process with the -File option. $calledFromRunWithPowerShellMenu = $MyInvocation.Line -eq '' -or $MyInvocation.Line.StartsWith('if((Get-ExecutionPolicy') Assert-AdministrativePrivileges $calledFromRunWithPowerShellMenu # Necessary for InputBox [System.Reflection.Assembly]::Load('Microsoft.VisualBasic, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a') | Out-Null if ($calledFromRunWithPowerShellMenu) { Get-UserParameters } # ... script code Test-NetConnection -ComputerName $ComputerName -Port $Port"
    },
    {
        "link": "https://stackoverflow.com/questions/52833728/how-to-start-process-from-within-powershell-in-admin-mode",
        "document": "Have you tried this? This will launch a program with Administrator privileges.\n\nI tested it out like the following and it launched VS with Administrative privileges."
    },
    {
        "link": "https://reddit.com/r/PowerShell/comments/10c1duo/script_for_powershell_to_open_it_as_admin",
        "document": "I just found this very useful, especially for beginners, let's assume you have or installed:\n\n2. in the end of the line add:\n\n3. Open new tab or PS again and just type:\n\nUAC will be prompted if you have it enabled, just say \"YES\" and you're done! You have admin PowerShell at your command!\n\nRename as you please and remove the first to activate it. Only select one!\n\nfor users, navigate with arrow keys or , , , . Type for INSERT mode, type as usual, press and type to save and exit. Or type to exit."
    },
    {
        "link": "https://superuser.com/questions/108207/how-to-run-a-powershell-script-as-administrator",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://learn.microsoft.com/en-us/powershell/scripting/learn/shell/running-commands?view=powershell-7.5",
        "document": "PowerShell is a command-line shell and a scripting language used for automation. Similar to other shells, like on Linux or the Windows Command Shell ( ), PowerShell lets you to run any command available on your system, not just PowerShell commands.\n\nFor any shell in any operating system there are three types of commands:\n• None Shell language keywords are part of the shell's scripting language. Shell language keywords can only be used within the runtime environment of the shell. There is no executable file, external to the shell, that provides the keyword's functionality.\n• None OS-native commands are executable files installed in the operating system. The executables can be run from any command-line shell, like PowerShell. This includes script files that may require other shells to work properly. For example, if you run a Windows batch script ( file) in PowerShell, PowerShell runs and passes in the batch file for execution.\n• None Shell environment-specific commands are commands defined in external files that can only be used within the runtime environment of the shell. These include scripts and functions, or they can be specially compiled modules that add commands to the shell runtime. In PowerShell, these commands are known as cmdlets (pronounced \"command-lets\").\n\nAny native command can be run from the PowerShell command line. Usually you run the command exactly as you would in or . The following example shows running the command in on Ubuntu Linux.\n\nAfter starting PowerShell on Ubuntu, you can run the same command from the PowerShell command line:\n\nMost shells include features for using variables, evaluating expressions, and handling strings. But each shell does these things differently. In PowerShell, all parameters start with a hyphen ( ) character. In , most parameters use a slash ( ) character. Other command-line tools may not have a special character for parameters.\n\nEach shell has its own way of handling and evaluating strings on the command line. When running native commands in PowerShell that expect strings to be quoted in a specific way, you may need adjust how you pass those strings.\n\nFor more information, see the following articles:\n\nPowerShell 7.2 introduced a new experimental feature that improved native command handling. For more information, see .\n\nPowerShell also has several more output streams than other shells. The and shells have stdout and stderr. PowerShell has six output streams. For more information, see about_Redirection and about_Output_Streams.\n\nIn general, the output sent to stdout by a native command is sent to the Success stream in PowerShell. Output sent to stderr by a native command is sent to the Error stream in PowerShell.\n\nWhen a native command has a non-zero exit code, is set to . If the exit code is zero, is set to .\n\nHowever, this changed in PowerShell 7.2. Error records redirected from native commands, like when using redirection operators ( ), aren't written to PowerShell's variable and the preference variable doesn't affect the redirected output.\n\nMany native commands write to stderr as an alternative stream for additional information. This behavior can cause confusion in PowerShell when looking through errors and the additional output information can be lost if is set to a state that mutes the output.\n\nPowerShell 7.3 added a new experimental feature that allows you to control whether output to is treated as an error. For more information, see .\n\nAs previously noted, PowerShell commands are known as cmdlets. Cmdlets are collected into PowerShell modules that can be loaded on demand. Cmdlets can be written in any compiled .NET language or using the PowerShell scripting language itself.\n\nThe PowerShell call operator ( ) lets you run commands that are stored in variables and represented by strings or script blocks. You can use this to run any native command or PowerShell command. This is useful in a script when you need to dynamically construct the command-line parameters for a native command. For more information, see the call operator.\n\nThe cmdlet can be used to run native commands, but should only be used when you need to control how the command is executed. The cmdlet has parameters to support the following scenarios:\n• Hide the console window created by the new process\n• Use a different working directory for the command\n\nThe following example runs the native command with redirected input and output streams.\n\nFor more information, see Start-Process.\n\nOn Windows, the cmdlet performs the default action for the specified item. For example, it runs an executable file or opens a document file using the application associated with the document file type. The default action depends on the type of item and is resolved by the PowerShell provider that provides access to the item.\n\nThe following example opens the PowerShell source code repository in your default web browser.\n\nFor more information, see Invoke-Item."
    },
    {
        "link": "https://stackoverflow.com/questions/43828823/start-process-to-run-a-powershell-script-with-switch-parameters",
        "document": "What would be code to run a PowerShell script that includes a few switch parameters to be passed along with it and report success or failure?\n\nNormally I run it like\n\nI have the below code, but how do I include switch parameters in it?"
    },
    {
        "link": "https://stackoverflow.com/questions/49575711/powershell-start-process-with-variable-filepath",
        "document": "Hi I need to run a variable process as elevated using powershell. The following code don't work because for some reason Powershell don't expand the variable:\n\nBut I get this error\n\nStart-Process : This command cannot be run due to the error: The system cannot find the file specified"
    },
    {
        "link": "https://learn.microsoft.com/en-us/powershell/scripting/developer/cmdlet/types-of-cmdlet-parameters?view=powershell-7.5",
        "document": "This topic describes the different types of parameters that you can declare in cmdlets. Cmdlet parameters can be positional, named, required, optional, or switch parameters.\n\nAll cmdlet parameters are either named or positional parameters. A named parameter requires that you type the parameter name and argument when calling the cmdlet. A positional parameter requires only that you type the arguments in relative order. The system then maps the first unnamed argument to the first positional parameter. The system maps the second unnamed argument to the second unnamed parameter, and so on. By default, all cmdlet parameters are named parameters.\n\nTo define a named parameter, omit the keyword in the Parameter attribute declaration, as shown in the following parameter declaration.\n\nTo define a positional parameter, add the keyword in the Parameter attribute declaration, and then specify a position. In the following sample, the parameter is declared as a positional parameter with position 0. This means that the first argument of the call is automatically bound to this parameter.\n\nPositional and named parameters accept single arguments or multiple arguments separated by commas. Multiple arguments are allowed only if the parameter accepts a collection such as an array of strings. You may mix positional and named parameters in the same cmdlet. In this case, the system retrieves the named arguments first, and then attempts to map the remaining unnamed arguments to the positional parameters.\n\nThe following commands show the different ways in which you can specify single and multiple arguments for the parameters of the cmdlet. Notice that in the last two samples, -name doesn't need to be specified because the parameter is defined as a positional parameter.\n\nYou can also define cmdlet parameters as mandatory or optional parameters. (A mandatory parameter must be specified before the PowerShell runtime invokes the cmdlet.) By default, parameters are defined as optional.\n\nTo define a mandatory parameter, add the keyword in the Parameter attribute declaration, and set it to , as shown in the following parameter declaration.\n\nTo define an optional parameter, omit the keyword in the Parameter attribute declaration, as shown in the following parameter declaration.\n\nPowerShell provides a System.Management.Automation.SwitchParameter type that allows you to define a parameter whose default value unless the parameter is specified when the cmdlet is called. Whenever possible, use switch parameters instead of Boolean parameters.\n\nConsider the following example. Many PowerShell cmdlets return output. However, these cmdlets have a switch parameter that overrides the default behavior. When you use the parameter, the cmdlet returns output objects to the pipeline.\n\nTo define a switch parameter, declare the property as the type, as shown in the following sample.\n\nTo make the cmdlet act on the parameter when it's specified, use the following structure within one of the input processing methods.\n\nBy default, switch parameters are excluded from positional parameters. You can override that in the Parameter attribute, but it can confuse users.\n\nDesign switch parameters so that using parameter changes the default behavior of the command to a less common or more complicated mode. The simplest behavior of a command should be the default behavior that doesn't require the use of switch parameters. Base the behavior controlled by the switch on the value of the switch, not the presence of the parameter.\n\nThere are several ways to test for the presence of a switch parameters:\n• contains the switch parameter name as a key\n\nFor example, it's possible to provide an explicit value for the switch using or splatting. If you only test for the presence of the parameter, the command behaves as if the switch value is instead of ."
    },
    {
        "link": "https://community.spiceworks.com/t/run-executable-in-powershell/823867",
        "document": "The Start-Process cmdlet starts one or more processes on the local computer. By default, Start-Process creates a new process that inherits all the environment variables that are defined in the current process. To specify the program that runs in the..."
    }
]