[
    {
        "link": "https://ci.dv8tion.net/job/JDA/javadoc/net/dv8tion/jda/api/entities/Message.html",
        "document": "\n• Returns the for this Message. This will be null if this Message has no reference. You can access all the information about a reference through this object. Additionally, you can retrieve the referenced Message if discord did not load it in time. This can be done with .\n• This will have different meaning depending on the of message. Usually, this is a reference. This can be null even if the type is , when the message it references doesn't exist or discord wasn't able to resolve it in time. This differs from a , which contains the raw IDs attached to the reference, and allows you to retrieve the referenced message\n• If no user was mentioned, this list is empty. Elements are sorted in order of appearance. This only counts direct mentions of the user and not mentions through roles or the everyone tag. An immutable list of all mentioned If no user was mentioned, this list is empty. Elements are sorted in order of appearance. This only counts direct mentions of the user and not mentions through roles or the everyone tag. - If this is a system message\n• of mentioned users. \n\nThis can be used to retrieve the amount of times a user was mentioned in this message. This only counts direct mentions of the user and not mentions through roles or the everyone tag. public void sendCount(Message msg) { List<User> mentions = msg.getMentionedUsers(); // distinct list, in order of appearance Bag<User> count = msg.getMentionedUsersBag(); StringBuilder content = new StringBuilder(); for (User user : mentions) { content.append(user.getAsTag()) .append(\": \") .append(count.getCount(user)) .append(\"\n\n\"); } msg.getChannel().sendMessage(content.toString()).queue(); } of mentioned users.This can be used to retrieve the amount of times a user was mentioned in this message. This only counts direct mentions of the user and not mentions through roles or the everyone tag. - If this is a system message\n• If none were mentioned, this list is empty. Elements are sorted in order of appearance. A immutable list of all mentioned If none were mentioned, this list is empty. Elements are sorted in order of appearance. This may include TextChannels from other - If this is a system message\n• of mentioned channels. \n\nThis can be used to retrieve the amount of times a channel was mentioned in this message. public void sendCount(Message msg) { List<TextChannel> mentions = msg.getMentionedTextChannels(); // distinct list, in order of appearance Bag<TextChannel> count = msg.getMentionedTextChannelsBag(); StringBuilder content = new StringBuilder(); for (TextChannel channel : mentions) { content.append(\"#\") .append(channel.getName()) .append(\": \") .append(count.getCount(channel)) .append(\"\n\n\"); } msg.getChannel().sendMessage(content.toString()).queue(); } of mentioned channels.This can be used to retrieve the amount of times a channel was mentioned in this message. - If this is a system message\n• If none were mentioned, this list is empty. Elements are sorted in order of appearance. This only counts direct mentions of the role and not mentions through the everyone tag. A immutable list of all mentioned If none were mentioned, this list is empty. Elements are sorted in order of appearance. This only counts direct mentions of the role and not mentions through the everyone tag. This may include Roles from other - If this is a system message\n• of mentioned roles. \n\nThis can be used to retrieve the amount of times a role was mentioned in this message. This only counts direct mentions of the role and not mentions through the everyone tag. If a role is not public void sendCount(Message msg) { List<Role> mentions = msg.getMentionedRoles(); // distinct list, in order of appearance Bag<Role> count = msg.getMentionedRolesBag(); StringBuilder content = new StringBuilder(); for (Role role : mentions) { content.append(role.getName()) .append(\": \") .append(count.getCount(role)) .append(\"\n\n\"); } msg.getChannel().sendMessage(content.toString()).queue(); } of mentioned roles.This can be used to retrieve the amount of times a role was mentioned in this message. This only counts direct mentions of the role and not mentions through the everyone tag. If a role is not it will not be included. - If this is a system message\n• This is only a convenience method and will skip all users that are not in the specified Guild. Creates an immutable list of representing the users of in the specified This is only a convenience method and will skip all users that are not in the specified Guild. - Non-null that will be used to retrieve Members. - If this is a system message - If the specified Guild is\n• This is only a convenience method and will skip all users that are not in the specified Guild. \n\nIt will provide the Creates an immutable list of representing the users of in the this Message was sent in.This is only a convenience method and will skip all users that are not in the specified Guild.It will provide the output Guild to - If this is a system message - If this message was not sent in a\n• This does not include Combines all instances of filtered by the specified values.This does not include to avoid duplicates. If no MentionType values are given this will fallback to all types. - Amount of to include in the list of mentions - If this is a system message\n• If no filtering Checks if given was mentioned in this message in any way (@User, @everyone, @here, @Role).If no filtering are specified this will fallback to all mention types. and will only be checked, if the given is of type or . \n\nOnline status of Users/Members is NOT considered when checking . - The mentionable entity to check on. - The types to include when checking whether this type was mentioned. This will be used with True, if the given mentionable was mentioned in this message - If this is a system message\n• Indicates if this Message mentions everyone using @everyone or @here. True, if message is mentioning everyone - If this is a system message\n• Returns whether or not this Message has been edited before. True if this message has been edited. - If this is a system message\n• defining when this Message was last edited. If this Message has not been edited ( ), then this method will return . Provides thedefining when this Message was last edited. If this Message has not been edited ( is), then this method will return Time of the most recent edit, or if the Message has never been edited. - If this is a system message\n• The author of this Message - If this is a system message\n• This is only valid if the Message was actually sent in a TextChannel. This will return if the message was not sent in a TextChannel, or if the message was sent by a Webhook. \n\nYou can check the type of channel this message was sent from using Returns the author of this Message as a This will returnif the message was not sent in a TextChannel, or if the message was sent by a Webhook.You can check the type of channel this message was sent from using or Discord does not provide a member object for messages returned by of any kind. This will return null if the message was retrieved through or similar means, unless the member is already cached. Message author, or if the message was not sent in a TextChannel, or if the message was sent by a Webhook. - If this is a system message\n• Returns the jump-to URL for the received message. Clicking this URL in the Discord client will cause the client to jump to the specified message. A String representing the jump-to URL for the message - If this is a system message\n• The textual content of this message in the format that would be shown to the Discord client. All entities will be resolved to the format shown by the Discord client instead of the This includes resolving: \n\n / to their @Username/@Nickname format, \n\n to their #ChannelName format, \n\n to their @RoleName format \n\n (not emojis!) to their format. If you want the actual Content (mentions as <@id>), use instead The textual content of the message with mentions resolved to be visually like the Discord client. - If this is a system message\n• The raw textual content of this message. Does not resolve entities like does. This means that this is the completely raw textual content of the message received from Discord and can contain mentions specified by Discord's Message Formatting The raw textual content of the message, containing unresolved Discord message formatting.\n• Gets the textual content of this message using and then strips it of markdown characters like *, **, __, ~~, || that provide text formatting. Any characters that match these but are not being used for formatting are escaped to prevent possible formatting. The textual content from with all text formatting characters removed or escaped. - If this is a system message\n• This will use the provided under that will parse the Creates an immutable List of codes that are included in this Message.This will use theprovided under to construct athat will parse the output and include all codes it finds in a list. You can use the codes to retrieve/validate invites via - If this is a system message\n• This can be used to validate that a Message was properly sent to the Discord Service. \n\nTo set a nonce before sending you may use Validation nonce for this MessageThis can be used to validate that a Message was properly sent to the Discord Service.To set a nonce before sending you may use\n• This will always be false for Used to determine if this Message was received from a of the specified.This will always be false for as Messages can't be sent to Useful for restricting functionality to a certain type of channels. - The to check against. True if the which this message was received from is the same as the one specified by . - If this is a system message\n• If this is then . Whether this message was sent in a If this isthen will throw an\n• This will never be Gets the that this message was received from.This will never be as Messages can't be sent to The ChannelType which this message was received from. - If this is a system message\n• Useful if you want to ignore non-users. Indicates if this Message was sent by a instead of a Useful if you want to ignore non-users. True if this message was sent by a . - If this is a system message\n• Returns the that this message was sent in. The MessageChannel of this Message - If this is a system message\n• This is only valid if the Message was actually sent in a PrivateChannel. \n\nYou can check the type of channel this message was sent from using Returns the that this message was sent in.You can check the type of channel this message was sent from using or Use for an ambiguous if you do not need functionality specific to . The PrivateChannel this message was sent in - If this is a system message - If this was not sent in a .\n• This is only valid if the Message was actually sent in a TextChannel. \n\nYou can check the type of channel this message was sent from using Returns the that this message was sent in.You can check the type of channel this message was sent from using or Use for an ambiguous if you do not need functionality specific to . The TextChannel this message was sent in - If this is a system message - If this was not sent in a .\n• for DMs. \n\nEquivalent to if this was sent in a The this message was sent in. This will always befor DMs.Equivalent toif this was sent in a - If this is a system message\n• This is just a shortcut to . \n\nThis is only valid if the Message was actually sent in a TextChannel. \n\nYou can check the type of channel this message was sent from using Returns the that this message was sent in.This is just a shortcut to You can check the type of channel this message was sent from using or The Guild this message was sent in - If this is a system message - If this was not sent in a .\n• Most likely this will only ever be 1 An immutable list of that are attached to this message.Most likely this will only ever be 1 at most. - If this is a system message\n• An immutable list of that are part of this Message. Immutable list of all given MessageEmbeds. - If this is a system message\n• You can use Rows of interactive components such as You can use to update these.\n• All attached to this message.\n• Gets the with the specified ID. - The id of the button The or null of no button with that ID is present on this message - If the id is null\n• All with the specified label attached to this message. - Whether to use instead of Immutable of with the specified label - If the provided label is null\n• This only includes Custom Emotes, not unicode Emojis. JDA classifies Emotes as the Custom Emojis uploaded to a Guild and retrievable with All used in this Message.JDA classifies Emotes as the Custom Emojis uploaded to a Guild and retrievable with . These are not the same as the unicode emojis that Discord also supports. Elements are sorted in order of appearance. Unicode emojis are not included as ! An immutable list of the Emotes used in this message (example match <:jda:230988580904763393>) - If this is a system message\n• of emotes used in this message. \n\nThis can be used to retrieve the amount of times an emote was used in this message. public void sendCount(Message msg) { List<Emote> emotes = msg.getEmotes(); // distinct list, in order of appearance Bag<Emote> count = msg.getEmotesBag(); StringBuilder content = new StringBuilder(); for (Emote emote : emotes) { content.append(emote.getName()) .append(\": \") .append(count.getCount(role)) .append(\"\n\n\"); } msg.getChannel().sendMessage(content.toString()).queue(); } of emotes used in this message.This can be used to retrieve the amount of times an emote was used in this message. - If this is a system message\n• All that are on this Message. Immutable list of all MessageReactions on this message. - If this is a system message\n• The returned MessageStickers may only contain necessary information such as the sticker id, format type, name, and icon url. All that are in this Message.The returned MessageStickers may only contain necessary information such as the sticker id, format type, name, and icon url. Immutable list of all MessageStickers in this message. - If this is a system message\n• Defines whether or not this Message triggers TTS (Text-To-Speech). If this message is TTS.\n• that contains its type and party id. that contains its type and party id. The activity, or if no activity was added to the message.\n• Messages can only be edited by the account that sent them!. Edits this Message's content to the provided String. This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - the new content of the Message - If this is a system message - If the message attempting to be edited was not created by the currently logged in account, or if 's length is 0 or greater than 2000.\n• Messages can only be edited by the account that sent them!. Edits this Message's content to the provided This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - the new content of the Message - If this is a system message - If the message attempting to be edited was not created by the currently logged in account, or if the passed-in embed is or not\n• Messages can only be edited by the account that sent them!. Edits this Message's content to the provided This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - the new embeds of the Message (up to 10) - If this is not a Received Message from - If the message attempting to be edited was not created by the currently logged in account - if any of the passed-in embeds is or not .\n• Messages can only be edited by the account that sent them!. Edits this Message's content to the provided This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - the new embeds of the Message (up to 10) - If this is not a Received Message from - If the message attempting to be edited was not created by the currently logged in account - if any of the passed-in embeds is or not .\n• Messages can only be edited by the account that sent them!. \n\nThis will replace all the current Edits this Message's content to the provided This will replace all the current , such as or on this message. The provided parameters are such as which contain a list of components to arrange in the respective layout. This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• Attempted to edit a message that was not sent by the currently logged in account. Discord does not allow editing of other users' Messages!\n• The request was attempted after the account lost access to the typically due to being kicked or removed, or after was revoked in the\n• If the message has already been deleted. This might also be triggered for ephemeral messages.\n• The request was attempted after the channel was deleted. List<ActionRow> rows = Arrays.asList( ActionRow.of(Button.success(\"prompt:accept\", \"Accept\"), Button.danger(\"prompt:reject\", \"Reject\")), // 1st row below message ActionRow.of(Button.link(url, \"Help\")) // 2nd row below message ); message.editMessageComponents(rows).queue(); - Up to 5 new for the edited message, such as - If this is not a Received Message from or any of the component layouts is a custom implementation that is not supported by this interface - If null is provided, or more than 5 layouts are added - If the message attempting to be edited was not created by the currently logged in account\n• Messages can only be edited by the account that sent them!. \n\nThis will replace all the current Edits this Message's content to the provided This will replace all the current , such as or on this message. The provided parameters are such as which contain a list of components to arrange in the respective layout. This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• Attempted to edit a message that was not sent by the currently logged in account. Discord does not allow editing of other users' Messages!\n• The request was attempted after the account lost access to the typically due to being kicked or removed, or after was revoked in the\n• If the message has already been deleted. This might also be triggered for ephemeral messages.\n• The request was attempted after the channel was deleted. message.editMessageComponents( ActionRow.of(Button.success(\"prompt:accept\", \"Accept\"), Button.danger(\"prompt:reject\", \"Reject\")), // 1st row below message ActionRow.of(Button.link(url, \"Help\")) // 2nd row below message ).queue(); - Up to 5 new for the edited message, such as - If this is not a Received Message from or any of the component layouts is a custom implementation that is not supported by this interface - If null is provided, or more than 5 layouts are added - If the message attempting to be edited was not created by the currently logged in account\n• Shortcut for \n\nMessages can only be edited by the account that sent them!. Edits this Message's content to the provided format.Shortcut for This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - Format String used to generate the Message's content via specification - The arguments to use in order to be converted in the format string - If this is a system message - If the provided format String is or blank, or if the created message exceeds the 2000 character limit - If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification. - If the message attempting to be edited was not created by the currently logged in account\n• Messages can only be edited by the account that sent them!. Edits this Message's content to the provided This message instance will not be updated by this operation, please use the response message instead. The following are possible:\n• The edit was attempted after the account lost access to the typically due to being kicked or removed.\n• The edit was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - the new content of the Message - If this is a system message -\n• If the message attempting to be edited was not created by the currently logged in account\n• If the message contains a MessageEmbed that is not\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The content of the reply message Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The content of the reply message Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The embed to reply with Providing the created from this upload. - If null is provided, any of the embeds are not , more than 10 embeds are provided, or the sum of is greater than\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The embeds to reply with Providing the created from this upload. - If null is provided, any of the embeds are not , more than 10 embeds are provided, or the sum of is greater than\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The content of the reply message Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The string that should be formatted, if this is null or empty the content of the Message would be empty and cause a builder exception. - The arguments for your format Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The file to upload to the channel in the reply - Possible options to apply to this attachment, such as marking it as spoiler image Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The data to upload to the channel in the reply - The name that should be sent to discord - Possible options to apply to this attachment, such as marking it as spoiler image Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The data to upload to the channel in the reply - The name that should be sent to discord - Possible options to apply to this attachment, such as marking it as spoiler image Providing the created from this upload.\n• This is identical to . You can use \n\nBy default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with Replies and references this message.This is identical to. You can use to not mention the author of the message.By default there won't be any error thrown if the referenced message does not exist. This behavior can be changed with For further info, see and . - The data to upload to the channel in the reply - The name that should be sent to discord - Possible options to apply to this attachment, such as marking it as spoiler image Providing the created from this upload.\n• If this Message was not sent by the currently logged in account, then this will fail unless the Message is from a Deletes this Message from Discord.If this Message was not sent by the currently logged in account, then this will fail unless the Message is from a and the current account has in the channel. To delete many messages at once in a you should use instead. The following are possible:\n• The delete was attempted after the account lost access to the due to being revoked, or the account lost access to the typically due to being kicked or removed.\n• The delete was attempted after the account lost in the when deleting another Member's message or lost .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - If this is a Data Message (output of ) - If this Message was not sent by the currently logged in account, the Message was sent in a , and the currently logged in account does not have in the channel. -\n• If this Message was not sent by the currently logged in account and it was not sent in a .\n• If this Message is ephemeral\n• Returns the instance related to this Message. - If this is a system message\n• Whether or not this Message has been pinned in its parent channel. True - if this message has been pinned. - If this is a system message\n• This is a shortcut method to Used to add the Message to the pinned message list.This is a shortcut method to The success or failure of this action will not affect the return of . The following are possible:\n• The pin request was attempted after the account lost access to the due to being revoked, or the account lost access to the typically due to being kicked or removed.\n• The pin request was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - If this is a system message - If this Message is from a and:\n• Missing . \n\nThe account needs access the the channel to pin a message in it.\n• Missing . \n\nRequired to actually pin the Message. - If this Message is ephemeral\n• This is a shortcut method to Used to remove the Message from the pinned message list.This is a shortcut method to The success or failure of this action will not affect the return of . The following are possible:\n• The unpin request was attempted after the account lost access to the due to being revoked, or the account lost access to the typically due to being kicked or removed.\n• The unpin request was attempted after the account lost in the .\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - If this is a system message - If this Message is from a and:\n• Missing . \n\nThe account needs access the the channel to pin a message in it.\n• Missing . \n\nRequired to actually pin the Message. - If this Message is ephemeral\n• Adds a reaction to this Message using an This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/emote. Neither success nor failure of this request will affect this Message's return as Message is immutable. Unicode emojis are not included as ! The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The user has blocked the currently logged in account and the reaction failed\n• The message already has too many reactions to proceed\n• The reaction request was attempted after the account lost or in the when adding the reaction.\n• The provided emote was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The to add as a reaction to this Message. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have -\n• If the provided is null.\n• If the provided cannot be used in the current channel. See or for more information. - If this message is ephemeral\n• A reference of unicode emojis can be found here: Adds a reaction to this Message using a unicode emoji.A reference of unicode emojis can be found here: Emoji Table This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/emote. Neither success nor failure of this request will affect this Message's return as Message is immutable. The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The user has blocked the currently logged in account and the reaction failed\n• The message already has too many reactions to proceed\n• The reaction request was attempted after the account lost in the when adding the reaction.\n• The provided unicode character does not refer to a known emoji unicode character. \n\nProper unicode characters for emojis can be found here: Emoji Table\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The unicode emoji to add as a reaction to this Message. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have - If the provided unicode emoji is null or empty. - If this Message is ephemeral\n• This is useful for moderator commands that wish to remove all reactions at once from a specific message. Removes all reactions from this Message.This is useful for moderator commands that wish to remove all reactions at once from a specific message. Please note that you can't clear reactions if this message was sent in a ! Neither success nor failure of this request will affect this Message's return as Message is immutable. The following are possible:\n• The clear-reactions request was attempted after the account lost access to the due to being revoked, or the account lost access to the typically due to being kicked or removed.\n• The clear-reactions request was attempted after the account lost in the when adding the reaction.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - If this is a system message - If the MessageChannel this message was sent in was a and the currently logged in account does not have in the channel. -\n• If this message was not sent in a .\n• If this message is ephemeral\n• Removes all reactions for the specified emoji. Please note that you can't clear reactions if this message was sent in a ! The following are possible:\n• The currently logged in account lost access to the channel by either being removed from the guild or losing the permission\n• The provided unicode character does not refer to a known emoji unicode character. \n\nProper unicode characters for emojis can be found here: Emoji Table\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The unicode emoji to remove reactions for - If this is a system message - If the currently logged in account does not have in the channel -\n• If this message was not sent in a .\n• If this message is ephemeral\n• Removes all reactions for the specified emote. Please note that you can't clear reactions if this message was sent in a ! The following are possible:\n• The currently logged in account lost access to the channel by either being removed from the guild or losing the permission\n• The provided emote was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The to remove reactions for - If this is a system message - If the currently logged in account does not have in the channel -\n• If this message was not sent in a .\n• If this message is ephemeral\n• Removes a reaction from this Message using an This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/emote. Neither success nor failure of this request will affect this Message's return as Message is immutable. Unicode emojis are not included as ! The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The provided emote was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The to remove as a reaction from this Message. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have -\n• If the provided is null.\n• If the provided cannot be used in the current channel. See or for more information. - If this is an ephemeral message\n• Removes a reaction from this Message using an Please note that you can't remove reactions of other users if this message was sent in a ! This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/emote. Neither success nor failure of this request will affect this Message's return as Message is immutable. Unicode emojis are not included as ! The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The reaction request was attempted after the account lost in the when removing the reaction.\n• The provided emote was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The to remove as a reaction from this Message. - The to remove the reaction for. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have . -\n• If the provided is null.\n• If the provided cannot be used in the current channel. See or for more information.\n• If the provided user is null -\n• If this message was not sent in a and the given user is not the .\n• If this message is ephemeral\n• A reference of unicode emojis can be found here: Removes a reaction from this Message using a unicode emoji.A reference of unicode emojis can be found here: Emoji Table This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/unicode. Neither success nor failure of this request will affect this Message's return as Message is immutable. The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The provided unicode character does not refer to a known emoji unicode character. \n\nProper unicode characters for emojis can be found here: Emoji Table\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The unicode emoji to add as a reaction to this Message. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have - If the provided unicode emoji is null or empty. - If this is an ephemeral message\n• A reference of unicode emojis can be found here: Removes a reaction from this Message using a unicode emoji.A reference of unicode emojis can be found here: Emoji Table Please note that you can't remove reactions of other users if this message was sent in a ! This message instance will not be updated by this operation. Reactions are the small emoji/emotes below a message that have a counter beside them showing how many users have reacted with the same emoji/unicode. Neither success nor failure of this request will affect this Message's return as Message is immutable. The following are possible:\n• The reaction request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The provided unicode character does not refer to a known emoji unicode character. \n\nProper unicode characters for emojis can be found here: Emoji Table\n• The reaction request was attempted after the account lost in the when removing the reaction.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The unicode emoji to add as a reaction to this Message. - The to remove the reaction for. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have - If the provided unicode emoji is null or empty or if the provided user is null. - If this message:\n• Was not sent in a and the given user is not the .\n• This obtains the who reacted using the given Messages maintain a list of reactions, alongside a list of users who added them. Using this data, we can obtain a of the users who've reacted to this message. The following are possible:\n• The retrieve request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The provided emote was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The to retrieve users for. The of the emote's users. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have in the channel. - If the provided is null. - If this Message is ephemeral\n• This obtains the who reacted using the given unicode emoji. Messages maintain a list of reactions, alongside a list of users who added them. Using this data, we can obtain a of the users who've reacted to this message. The following are possible:\n• The retrieve request was attempted after the account lost access to the due to being revoked \n\nAlso can happen if the account lost the\n• The provided unicode character does not refer to a known emoji unicode character. \n\nProper unicode characters for emojis can be found here: Emoji Table\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - The unicode emote to retrieve users for. The of the emoji's users. - If this is a system message - If the MessageChannel this message was sent in was a and the logged in account does not have in the channel. - If the provided unicode emoji is null or empty. - If this Message is ephemeral\n• This obtains the for the given unicode reaction on this message. An instance of the related can be obtained through this method by using the emoji's unicode value. - The unicode value of the reaction emoji. The of this message or null if not present. - If this is a system message - If the provided unicode value is null or empty.\n• This obtains the for the given reaction id on this message. An instance of the related can be obtained through this method by using the emote's id. - The string id of the reaction emote. The of this message or null if not present. - If this is a system message - If the provided id is not a valid snowflake.\n• This obtains the for the given reaction id on this message. An instance of the related can be obtained through this method by using the emote's id. - The long id of the reaction emote. The of this message or null if not present. - If this is a system message\n• Suppressing Embeds is equivalent to pressing the in the top-right corner of an Embed inside the Discord client. Enables/Disables suppression of Embeds on this Message.Suppressing Embeds is equivalent to pressing thein the top-right corner of an Embed inside the Discord client. The following are possible:\n• The clear-reactions request was attempted after the account lost access to the due to being revoked, or the account lost access to the typically due to being kicked or removed.\n• The suppress-embeds request was attempted after the account lost in the when adding the reaction.\n• If the message has already been deleted. This might also be triggered for ephemeral messages. - Whether or not the embed should be suppressed - If this is a system message - If the MessageChannel this message was sent in was a and the currently logged in account does not have in the channel. - If the MessageChannel this message was sent in was a and the message was not sent by the currently logged in account. - If this Message is ephemeral\n• The following are possible:\n• The target message has already been crossposted.\n• The request was attempted after the account lost access to the typically due to being kicked or removed, or after was revoked in the\n• The request was attempted after the account lost in the TextChannel.\n• If the message has already been deleted. This might also be triggered for ephemeral messages.\n• The request was attempted after the channel was deleted. - If this is a system message -\n• If the channel is not a text or news channel. See .\n• If the message is ephemeral. - If the currently logged in account does not have in this channel or if this message is from another user and we don't have .\n• This is a shortcut method for checking if Whether embeds are suppressed for this message. When Embeds are suppressed, they are not displayed on clients nor provided via API until un-suppressed.This is a shortcut method for checking if contains Whether or not Embeds are suppressed for this Message. - If this is a system message\n• Returns an EnumSet of all present for this Message. - If this is a system message\n• Returns the raw message flags of this message - If this is a system message\n• The message being ephemeral means it is only visible to the bot and the interacting user \n\nThis is a shortcut method for checking if Whether this message is ephemeral.The message being ephemeral means it is only visible to the bot and the interacting userThis is a shortcut method for checking if contains Whether the message is ephemeral - If this is a system message\n• This specifies the of this Message. Messages can represent more than just simple text sent by Users, they can also be special messages that inform about events that occur. Messages can either be or special messages like . The of this message. - If this is a system message\n• This is sent on the message object when the message is a response to an without an existing message. This means responses to Message Components do not include this property, instead including a message reference object as components always exist on preexisting messages. The of this message. - If this is a system message"
    },
    {
        "link": "https://github.com/discord-jda/JDA",
        "document": "This open source library is intended for implementing bots on Discord using the real-time gateway and REST API. It provides event based functionality to implement bots of any kind, allowing for effective and scalable applications.\n\nThe core concepts of JDA have been developed to make building scalable apps easy:\n• Event System\n\n Providing simplified events from the gateway API, to respond to any platform events in real-time without much hassle.\n• Rest Actions\n\n Easy to use and scalable implementation of REST API functionality, letting you choose between callbacks with combinators, futures, and blocking. The library also handles rate-limits imposed by Discord automatically, while still offering ways to replace the default implementation.\n• Customizable Cache\n\n Trading memory usage for better performance where necessary, with sane default presets to choose from and customize.\n\nYou can learn more by visiting our wiki or referencing our Javadocs.\n\nThis library is available on maven central. The latest version is always shown in the GitHub Release.\n\nThe minimum java version supported by JDA is Java SE 8. JDA also uses JSR 305 to support solid interoperability with Kotlin out of the box.\n\nTo use this library, you have to create an Application in the Discord Application Dashboard and grab your bot token. You can find a step-by-step guide for this in our wiki page Creating a Discord Bot.\n\nWe provide a number of examples to introduce you to JDA. You can also take a look at our official Wiki, Documentation, and FAQ.\n\nEvery bot implemented by JDA starts out using the JDABuilder or DefaultShardManagerBuilder. Both builders provide a set of default presets for cache usage and events it wants to receive:\n• - Enables cache for users who are active in voice channels and all cache flags\n• - Enables member chunking, caches all users, and enables all cache flags\n\nWe recommend reading the guide on caching and intents to get a feel for configuring your bot properly. Here are some possible use-cases:\n\nSimply logging messages to the console. Making use of JDABuilder, the intended entry point for smaller bots that don't intend to grow to thousands of guilds.\n\nStarting your bot and attaching an event listener, using the right intents:\n\nYour event listener could look like this:\n\nYou can find a more thorough example with the MessageLoggerExample class.\n\nThis is a bot that makes use of interactions to respond to user commands. Unlike the message logging bot, this bot can work without any enabled intents, since interactions are always available.\n\n( [] ) { = . ( , . ()) . ( ()) . (); // Register your commands to make them visible globally on Discord: = . (); // Add all your commands on this action instance . ( . ( , \"Makes the bot say what you tell it to\" ) . ( , , \"What the bot should say\" , ), . ( , ) . ( ) . ( . ) // only admins should be able to use this command. ); // Then finally send your commands to discord using the API . (); }\n\nAn event listener that responds to commands could look like this:\n\nYou can find a more thorough example with the SlashBotExample class.\n\nIn this library, the RestAction interface is used as a request builder for all API endpoints. This interface represents a lazy request builder, as shown in this simple example:\n\nThe RestAction interface also supports a number of operators to avoid callback hell:\n• Convert the result of the to a different value\n• Chain another on the result\n• Delay the element of the previous step\n\nAs well as combinators like:\n• Require another RestAction to complete successfully, running in parallel\n• Accumulate a list of many actions into one (see also )\n• Similar to , but combines the results into a list\n• and \n\n Configure how long the action is allowed to be in queue, cancelling if it takes too long\n• Running some checks right before the request is sent, this can be helpful when it is in queue for a while\n• The audit log reason for an action\n\nThis could then be used in code:\n\nCreated and maintained by MinnDevelopment.\n\n Provides Kotlin extensions for RestAction and events that provide a more idiomatic Kotlin experience.\n\nThere are a number of examples available in the README.\n\nCreated by sedmelluq and now maintained by the lavalink community\n\n Lavaplayer is the most popular library used by Music Bots created in Java. It is highly compatible with JDA and Discord4J and allows playing audio from YouTube, Soundcloud, Twitch, Bandcamp and more providers.\n\n The library can easily be expanded to more services by implementing your own AudioSourceManager and registering it. We recommend to also use udpqueue in addition to lavaplayer, to avoid stuttering issues caused by GC pauses.\n\nIt is recommended to read the Usage section of Lavaplayer to understand a proper implementation.\n\n Sedmelluq provided a demo in his repository which presents an example implementation for JDA: https://github.com/lavalink-devs/lavaplayer/tree/master/demo-jda\n\nCreated and maintained by sedmelluq and extended by MinnDevelopment\n\n Provides a native implementation for the JDA Audio Send-System to avoid GC pauses potentially causing problems with continuous audio playback.\n\nNote that this send-system creates an extra UDP-Client which causes audio receive to no longer function properly, since Discord identifies the sending UDP-Client as the receiver.\n\nCreated by Freya Arbjerg and now maintained by the lavalink community.\n\nLavalink is a popular standalone audio sending node based on Lavaplayer. Lavalink was built with scalability in mind, and allows streaming music via many servers. It supports most of Lavaplayer's features.\n\nLavalink is used by many large bots, as well as bot developers who can not use a Java library like Lavaplayer. If you plan on serving music on a smaller scale with JDA, it is often preferable to just use Lavaplayer directly as it is easier.\n\nLavalink-Client is the official Lavalink client for JDA.\n\nIf you want to contribute to JDA, make sure to base your branch off of our master branch (or a feature-branch) and create your PR into that same branch.\n\nDo not expect your pull request to get immediate attention, sometimes it will take a long time to get a response. You can join our discord server and ask in #lib-dev before starting to work on a new PR, to get more immediate feedback from our community members.\n\nDue to the nature of the Discord API, the library will regularly introduce breaking changes to allow for a quick adoption of newer features. We try to keep these breaking changes minimal, but cannot avoid them entirely.\n\nMost breaking changes will result in a minor version bump ( → )."
    },
    {
        "link": "https://stackoverflow.com/questions/44225208/how-to-send-file-with-message-to-discord-with-jda/44235462",
        "document": "I am using JDA lib to create my discord bot and I encountered a problem: in order to send message with a file, I should use existing message:\n\nThere is no implementation for sending file with simple string message. So when I'm trying to send file and pass a message to it I've got duplicated message.\n\nSo the question is: How to create with attached file without duplicating the message?"
    },
    {
        "link": "https://ci.dv8tion.net/job/JDA/javadoc/net/dv8tion/jda/api/events/message/MessageEmbedEvent.html",
        "document": "Indicates that a Message contains an in a Discord may need to do additional calculations and resizing tasks on messages that embed websites, thus they send the message only with content and link and use this update to add the missing embed later when the server finishes those calculations.\n\nCan be used to retrieve MessageEmbeds from any message. No matter if private or guild.\n\nThis event requires at least one of the following intents (Will not fire at all if neither is enabled):"
    },
    {
        "link": "https://stackoverflow.com/questions/68309053/how-do-i-make-my-discord-bot-edit-its-message",
        "document": "I have 2 s (specifically 2 s), I want the bot to send the first , then edit it to the second on button click.\n\nThe bot will , And then it'll add a button to the embed (In my case), If the user clicks that button, The embed would be edited to .\n\nI have read the documentation but I did not get much information, So I assume Stack Overflow will help."
    },
    {
        "link": "https://baeldung.com/java-completablefuture-non-blocking",
        "document": "Having high performance and availability are essential parts of modern software development.\n\nOne way to achieve this is through non-blocking and asynchronous programming. In Java, the CompletableFuture class provides a way to write non-blocking code. But is it truly non-blocking?\n\nIn this tutorial, we’ll examine the situations when CompletableFuture is blocking and when it is non-blocking.\n\nFirstly, let’s take a brief look at CompletableFuture class. It’s a powerful class introduced in Java 8 as part of the Concurrent API.\n\nMoreover, it implements the Future interface and represents the primary implementation of the CompletionStage interface. Thus, it offers nearly 50 different methods for creating and executing asynchronous computations.\n\nWhy did we need CompletableFurure in the first place? Using the Future interface, we could only retrieve the result by calling the get() method. However, this method represents a blocking operation. In other words, it’ll block the current thread until the result of the task becomes available.\n\nIf we need to perform additional actions on the result, we’ll end up with blocking operations.\n\nOn the other hand, thanks to CompletionStage, CompletableFuture provides the ability to chain multiple computations together that can run concurrently. This functionality allows us to create a chain of tasks where the next task is triggered when the current task is completed.\n\nFurthermore, we can specify what should happen once we get the result from the future without blocking the current thread.\n\nThe CompletableFuture class represents both the stage in dependent processes, where one stage’s completion triggers another, and its result.\n\nNext, let’s understand the difference between blocking and non-blocking processing.\n\nIn the blocking operation, the calling thread waits until the operation in another thread completes before continuing with its execution:\n\nHere, the tasks execute sequentially. Thread 1 is blocked by Thread 2. In other words, Thread 1 can’t continue with its execution until Thread 2 finishes processing its tasks.\n\nWe can look at the blocking processing as synchronous operations.\n\nHowever, blocking operations in our system can cause performance issues, especially in applications that require high availability and scalability.\n\nIn contrast, a non-blocking operation allows threads to perform multiple computations simultaneously without having to wait for each task to complete.\n\nThe current thread can continue with its execution while the other threads perform tasks in parallel:\n\nIn the example above, Thread 2 isn’t blocking the execution of Thread 1. Furthermore, both threads are running their tasks concurrently.\n\nBesides improving the performance, we can decide what to do with the result once the non-blocking operation finishes with execution.\n\nThe main advantage of using CompletableFuture is its ability to chain multiple tasks together that will be executed without blocking the current thread. Therefore, we can say the CompletableFuture is non-blocking.\n\nAdditionally, it provides several methods that allow us to perform tasks in a non-blocking way, including:\n• thenApply(): applies a function to the result of a previous task and returns a CompletableFuture representing the transformed result\n• thenCompose(): executes a task that returns a CompletableFuture and returns a CompletableFuture representing the result of the nested task\n• allOf(): executes several tasks in parallel and returns a CompletableFuture representing the completion of all tasks\n\nNext, let’s see a simple example. For instance, suppose we have two tasks we’d like to execute as non-blocking:\n\nAfter the task completes, it’ll print the number 8 on the standard output.\n\nThe computation runs in the background and returns a future. If we have multiple dependent actions, each action is represented by the stage. After one stage completes, it triggers the computation of other dependent stages.\n\nAlthough CompletableFuture is used to perform non-blocking operations, it can still end up blocking the current thread in certain scenarios.\n\nIn asynchronous communication, we usually have a callback mechanism to retrieve the result of the computation. However, CompletableFuture doesn’t notify us upon its completion.\n\nIf needed, we can retrieve the result in the calling thread using the get() method.\n\nNevertheless, we need to be aware the get() method returns the result using blocking processing. If required, it waits for the computation to complete and then returns the result.\n\nTherefore, we’ll end up blocking the current thread until the future completes:\n\nSimilarly, calling the join() method will block the current thread as well:\n\nThe main difference between these two methods is that the join() method doesn’t throw checked exceptions if the future completes exceptionally.\n\nAdditionally, we can call the isDone() method to check whether the future is completed before obtaining the result.\n\nHowever, when it’s necessary to obtain the computation result in the calling thread, we can create CompletableFuture, do other work in the current thread, and then call the get() or join() method. By giving it more time, it’s more likely the Future will finish with computations before we get the result. But there’s still no guarantee that the retrieval won’t end up blocking the thread.\n\nIn this article, we examined the scenarios when CompletableFuture is non-blocking and when it’s not.\n\nTo sum up, CompletableFuture is non-blocking most of the time. However, if we call the get() or the join() methods to retrieve the result, they will block the current thread."
    },
    {
        "link": "https://bluepeople.com/completablefuture-mastering-asynchronous-programming-in-java",
        "document": "CompletableFuture is a powerful tool in the Java programming language, specifically designed for handling asynchronous operations. It extends the capabilities of the traditional Future interface by allowing developers to write non-blocking code that can easily manage tasks that complete in the future.\n\nOne of the primary advantages of CompletableFuture is its ability to facilitate complex workflows where multiple tasks can be executed in parallel or sequentially. It provides a rich set of methods to combine, transform, and chain tasks, resulting in more readable and maintainable code.\n\nIn contrast to its predecessor, CompletableFuture allows for a more fluent and functional programming style. This enhances code clarity and reduces boilerplate, making it easier for developers to focus on business logic rather than complex threading concerns.\n\nCompletableFuture also includes built-in mechanisms for handling exceptions. This enables more robust application development as it simplifies error handling in asynchronous operations. When an error occurs, developers can respond to it in a more controlled manner, thus improving the overall reliability of their applications.\n\nOverall, CompletableFuture represents a significant advancement in Java's approach to concurrency. It empowers developers to write efficient, responsive, and non-blocking applications while effectively managing complex asynchronous tasks.\n\nCompletableFuture offers a robust framework for handling asynchronous operations. Its extensive features enable developers to create non-blocking applications that are easier to compose and manage. Below are the key features that define the capabilities of CompletableFuture.\n\nA standout feature of CompletableFuture is its ability to execute tasks asynchronously. This ensures that the main thread remains responsive while background tasks run independently. This non-blocking approach enhances application performance, especially in environments requiring high concurrency.\n\nTask composition allows developers to chain multiple asynchronous operations in a readable and efficient manner. This feature streamlines complex workflows and fosters clearer code structure. CompletableFuture provides several methods for task composition:\n• None thenApply()This method is used to transform the result of a CompletableFuture once it completes successfully. It takes a function as an argument, processes the result of the preceding stage, and returns a new CompletableFuture.\n• None thenCompose()thenCompose() allows for chaining multiple asynchronous tasks where the next task depends on the result of the previous one. It requires a function that returns another CompletableFuture, creating a seamless flow between tasks.\n• None thenCombine()With thenCombine(), two independent CompletableFutures can be executed concurrently. Once both tasks are complete, their results are combined using a specified function. This is particularly useful for merging results from different sources.\n• None allOf()allOf() allows multiple CompletableFutures to run in parallel. It returns a new CompletableFuture that completes when all the provided futures complete. This is useful for executing multiple tasks concurrently and waiting for their completion.\n\nCompletableFuture simplifies error handling in asynchronous programming. It provides methods that allow developers to manage exceptions in a more declarative manner, improving code clarity and flow control. Key exception handling methods include:\n• None exceptionally()exceptionally() provides a way to recover from errors that occur during the execution of a CompletableFuture. It allows the developer to specify a fallback value or action in the event of an exception, ensuring graceful handling of errors.\n• None handle()handle() enables processing of both the result and any exceptions in a single callback. This method provides a way to transform the result or take an alternative action based on whether the CompletableFuture completed exceptionally or normally.\n\nCompletableFuture gives developers control over the completion and cancellation of tasks. It includes methods to manage task states effectively, enhancing flexibility in handling long-running operations.\n• None cancel()The cancel() method allows for the termination of a running task. It provides the option to either interrupt the thread executing the task or simply mark it as cancelled.\n• None complete()complete() allows developers to manually complete a CompletableFuture with a specific value, regardless of its current state. This can be useful in scenarios where external conditions dictate the completion of a task.\n• None completeExceptionally()completeExceptionally() is used to finish a CompletableFuture with an exception. This method allows developers to signal that a failure has occurred in an operation, providing a mechanism to inform other parts of the application of the failure.\n\nCreating a CompletableFuture involves utilizing various methods that facilitate asynchronous task execution. This section covers the fundamental ways to instantiate a CompletableFuture.\n\nThe supplyAsync() method is essential for starting a new CompletableFuture in a non-blocking manner. It allows developers to supply a computation that runs asynchronously, returning a result or completing exceptionally.\n\nThis method takes a Supplier functional interface, which can be implemented using a lambda expression or a method reference. Here’s a simple example:\n\nThis code initiates a background task that returns a string result. While the task is running, the main thread is free to perform other operations.\n\nBy default, when using supplyAsync(), the task is executed in the ForkJoinPool.commonPool(). This pool is a shared resource among all tasks that invoke supplyAsync(). Using this common pool allows for simple and efficient resource management without the need to create custom executors for every task.\n\nThe common pool is well-suited for smaller tasks that are lightweight, leveraging the available threads efficiently and providing optimal resource utilization.\n\nIn situations where control over the thread management is necessary, such as highly intensive tasks or managing thread lifecycles, it's possible to specify a custom executor.\n\nBy passing an instance of Executor to the supplyAsync() method, the developer can dictate where the task runs. This flexibility allows for more complex thread management strategies. Here is an example:\n\nIn this example, a fixed thread pool of size four is created, allowing multiple tasks to run concurrently without overloading the system’s resources.\n\nSpecifying a custom executor is especially beneficial for applications that require fine-tuned performance or need to comply with specific threading policies.\n\nThis section provides an in-depth look at the various methods available in the CompletableFuture class, which are essential for handling asynchronous tasks effectively. Each method serves a specific purpose, enabling developers to manage the flow and control of data when working with future results.\n\nThe thenAccept() method is a key feature that allows you to specify an action that will be executed once the CompletableFuture completes successfully. This method accepts a consumer as an argument, which takes the result of the CompletableFuture as an input but does not return any value. It is particularly useful for side effects, such as logging or updating user interfaces.\n\nExample usage of thenAccept() can look like this:\n\nIn this example, the string \"Hello, World!\" is generated asynchronously, and once the computation is finished, the result is printed to the console.\n\nThe thenRun() method allows you to execute a Runnable action after the CompletableFuture completes, similar to thenAccept(). However, unlike thenAccept(), it does not take any result from the CompletableFuture. This method is useful for performing actions that do not depend on the result of the previous computation.\n\nA simple example would be:\n\nHere, the message \"Task Complete\" is generated, and after that, \"Next task starts now.\" is printed once the first task completes.\n\nThe thenCombine() method is particularly powerful as it enables the combination of the results of two CompletableFutures. It takes two CompletableFutures and a BiFunction that merges their results once both futures are completed. This is helpful when there is a need to aggregate results from two independent asynchronous computations.\n\nHere's how it can be applied:\n\nThis example combines results from two separate tasks and prints the combined value, demonstrating the ability to synchronize between the two futures.\n\nThe thenCompose() method is essential for chaining asynchronous computations that depend on the result of a previous CompletableFuture. This method takes a Function that returns a new CompletableFuture, allowing for a more fluid way to manage dependent asynchronous tasks.\n\nAn example of using thenCompose() is:\n\nIn this case, an initial value is doubled asynchronously, showcasing how thenCompose() can facilitate chaining while keeping the code clean and straightforward.\n\nThis section presents a straightforward example of using CompletableFuture to perform an asynchronous operation. The following subsections detail the use of Thread.sleep() to mimic a long-running task and illustrate how to return a string value upon completion.\n\nIn Java, simulating a delay in execution can be achieved by utilizing the Thread.sleep() method. This method pauses the current thread for a specified period, allowing developers to mimic operations that take time, such as network calls or long computations. When used in conjunction with CompletableFuture, this feature allows tasks to run asynchronously without blocking the execution of other operations.\n\nHere is an example of how to use Thread.sleep() within a CompletableFuture:\n\nCompletableFuture future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(5000); // Simulating a long task } catch (InterruptedException e) { throw new IllegalStateException(e); } return \"Hello, world!\"; });\n\nIn this snippet, the CompletableFuture is created to execute a task that sleeps for five seconds. This example serves to demonstrate the asynchronous nature of CompletableFuture, allowing other operations to progress while waiting for the result of this long-running task.\n\nAfter the asynchronous task completes, it is crucial to handle the results appropriately. CompletableFuture provides various methods that enable consumers to work with the outcome of the asynchronous operation. In the example above, the return value is a string, and further processing can be utilized to handle this result.\n\nOnce the asynchronous task is finished, developers can use thenAccept() to define actions that should occur with the result. Here’s how that can be implemented:\n\nfuture.thenAccept(result -> { System.out.println(result); // Prints the result after the task is complete });\n\nThis example demonstrates the power of CompletableFuture in managing the flow of data once the operation has concluded. When the CompletableFuture is complete, it will print \"Hello, world!\" to the console, showcasing effective handling of the result obtained from an asynchronous operation.\n\nChaining asynchronous tasks allows developers to create a series of dependent operations that execute in sequence. This approach enhances the flow of data between tasks and ensures that results can be efficiently passed from one task to the next.\n\nThe thenApplyAsync() method is used to transform the result of a completed CompletableFuture into another value. This method is executed asynchronously, meaning the transformation occurs in a separate thread from the one that completed the previous task. This non-blocking behavior is crucial for maintaining application responsiveness.\n• None When using thenApplyAsync(), a function is provided that takes the original result and produces a new result. It ensures that the transformation is handled in the background, optimizing performance.\n• None This method can be especially useful in scenarios where a significant amount of processing is required after an initial task is completed.\n\nConsider a scenario where an initial CompletableFuture retrieves a numeric value, and there’s a requirement to multiply this value by a constant. Using thenApplyAsync(), the multiplication can be performed asynchronously:\n\nIn this example, the original value of `10` is multiplied by `2`, resulting in `20`. This transformation occurs without blocking the main thread, showcasing the benefits of asynchronous processing.\n\nBuilding on the previous example, suppose there’s an additional requirement to add a specific number after the multiplication. The chaining structure allows this operation to be seamlessly integrated:\n\nHere, after multiplying by `2`, a `5` is added to the result, yielding a final value of `25`. Each step of the process is handled asynchronously, which supports a fluid workflow while maintaining system responsiveness.\n\nError handling is an essential part of working with CompletableFuture. It allows developers to manage exceptions effectively without causing the entire application to fail. Here's a closer look at how to handle errors in this asynchronous programming model.\n\nArithmetic exceptions are common in programming, particularly when performing mathematical operations. In the context of CompletableFuture, such exceptions can arise when calculations are attempted that are mathematically invalid, like division by zero. Handling these exceptions is crucial to ensure that the application remains stable.\n\nUsing the exceptionally() method provides a straightforward way to manage such exceptions. This method takes a function that will be executed if the CompletableFuture completes exceptionally. The implementation demonstrates this by capturing ArithmeticException and allowing the program to continue running without failures.\n• None Example of exception handling:Here’s a code snippet illustrating how to handle an ArithmeticException: CompletableFuture future = CompletableFuture.supplyAsync(() -> { if (true) throw new ArithmeticException(\"Error: Division by zero\"); return 1; }).exceptionally(ex -> { System.out.println(\"Exception occurred: \" + ex.getMessage()); return 0; // Default value }); The above code checks for an error condition, raises an exception, and allows the exceptionally method to deal with it. A default value is returned, ensuring that subsequent operations can proceed without interruptions.\n\nWhen an exception is encountered, it is beneficial to return a default value that allows the program to maintain continuity in execution. Setting default values serves as a fallback mechanism whenever an operation fails. This technique avoids the cascading effect of errors that could crash the entire application.\n\nUsing exceptionally(), it’s possible to not only log the exception but also to dictate what value should be returned on error. In this way, developers can maintain control over the program flow and ensure a smoother user experience.\n• None Considerations for setting default values:Utilizing placeholders for computation: CompletableFuture futureWithDefaultValue = CompletableFuture.supplyAsync(() -> { throw new RuntimeException(\"An error occurred.\"); }).exceptionally(ex -> { return -1; // Use -1 as a default value }); This approach demonstrates how a default value (like -1) can be established in case of an error, enabling other areas of the application to function without interruption.\n\nExecuting tasks in parallel is essential for improving application performance and responsiveness. By leveraging the capabilities of CompletableFuture, developers can efficiently manage multiple tasks that run simultaneously, making optimal use of system resources.\n\nThe method allOf() is a powerful feature that allows developers to wait for multiple CompletableFutures to complete before proceeding. This is especially useful when there are multiple independent tasks that can run concurrently without dependency on each other. The result is a single CompletableFuture that completes when all the provided CompletableFutures are done.\n\nHere’s how allOf() can be utilized:\n• None It takes an array of CompletableFuture instances as input.\n• None Returns a CompletableFuture that completes when all supplied futures complete.\n• None Provides a convenient way to synchronize multiple tasks without manual management of their completion states.\n\nWhen multiple tasks are executed in parallel, accessing the results becomes crucial. After using allOf(), the results of each task can be retrieved seamlessly. Here’s how to do it:\n• None Each individual CompletableFuture must be separately defined for collecting results.\n• None After calling allOf(), the results can be fetched using the get() method.\n• None Proper exception handling must be implemented when accessing results to manage any task failures.\n\nFor instance, assume three separate tasks are running in parallel to fetch data from different sources. Once all tasks are completed, their results can be processed:\n• None Each task is executed independently, and allOf() ensures that the main flow waits until all tasks are finished.\n• None After completion, results can be logged, combined, or processed based on application requirements.\n\nThis approach not only optimizes performance but also enhances the responsiveness of applications dealing with multiple concurrent operations.\n\nCompleting a CompletableFuture involves controlling how and when the asynchronous task's result is available. This feature provides flexibility in handling the lifecycle of the task.\n\nThe complete() method is used to manually complete a CompletableFuture with a given value. This is particularly useful when the outcome of an asynchronous operation is determined by an external event or condition, rather than solely by the execution of the task itself.\n\nBy invoking complete(), developers can set the result of the CompletableFuture without waiting for the asynchronous computation to finish. This operation marks the CompletableFuture as completed, allowing any dependent actions to execute immediately. Here's a brief overview of the process:\n• None Invoke complete(value): Passing a value to this method will complete the future with that value, notifying any consumers waiting for the completion.\n• None Execute dependent actions: Any tasks that are chained to this CompletableFuture through methods like thenApply() or thenAccept() will execute with the provided value.\n\nThis method also handles scenarios where the CompletableFuture needs to be completed based on external triggers, enhancing its applicability in real-world scenarios.\n\nThe completeExceptionally() method provides a means to complete the CompletableFuture with an exception. This is advantageous for indicating failure in asynchronous tasks. When this method is invoked, all attached handlers that depend on the result will be triggered with the specified exception, allowing for a structured error handling approach.\n• None Invoke completeExceptionally(exception): By passing an exception to this method, the CompletableFuture will transition to a completed state with the exception set as the cause. This prompts any waiting consumers to handle the failure appropriately.\n• None Handle the failure: Consumers can manage the situation using methods like exceptionally() or handle(), which allow specifying what to do in case of an error during the future's execution.\n\nThis function is crucial for building resilient applications, as it allows programmers to reflect failure conditions consistently across various parts of the code.\n\nThe differences between Future and CompletableFuture are significant in Java, particularly concerning their behavior and usability in asynchronous programming. Below, key distinctions are highlighted to understand their unique functionalities.\n\nOne of the most notable differences lies in how these two classes handle task execution.\n• None Future: This interface is characterized by a blocking behavior. When a thread retrieves the result of a task using the get() method, it halts execution until that result becomes available. This can lead to inefficiencies, particularly in applications requiring responsiveness, such as user interfaces.\n• None CompletableFuture: In contrast, this class promotes non-blocking behavior, allowing threads to execute other operations while waiting for a task's result. Through methods like thenApply() and thenAccept(), developers can continue to process data without unnecessary delays.\n\nTask composition refers to how tasks can be combined and sequenced for execution.\n• None Future: Composing multiple tasks using Future can be cumbersome. Developers must explicitly manage task completion and callbacks, leading to complex and less readable code.\n• None CompletableFuture: This class simplifies task chaining with its variety of methods. Functions like thenCompose(), thenCombine(), and allOf() allow for intuitive task composition. This creates more manageable workflows and encapsulates intricate dependencies seamlessly.\n\nManaging exceptions is crucial in any programming model, especially in asynchronous environments.\n• None Future: The exception handling mechanism with Future is basic and limited. If a task fails, the developer must wrap the get() call in a try-catch block to handle exceptions, making it cumbersome and less elegant.\n• None CompletableFuture: Provides a richer exception handling framework. With methods such as exceptionally() and handle(), developers can define recovery strategies directly within the task chain. This enhances code readability and maintains a clear flow of logic in error scenarios.\n\nThe level of control over task completion is fundamental in managing asynchronous tasks.\n• None Future: Lacks methods for explicitly completing a task. Once a task is submitted, it can only be waited upon or canceled. The inability to control task completion adds complexity to managing task states.\n• None CompletableFuture: Offers methods such as complete() and completeExceptionally(). This allows developers to programmatically set the outcome of a CompletableFuture, providing greater flexibility in task management and control over various execution paths.\n\nThe CompletableFuture API provides a comprehensive set of tools for managing asynchronous programming within Java. This section outlines the key elements of the API, including its interface and methods, as well as common scenarios where these features can be utilized effectively.\n\nThe CompletableFuture interface extends the Future interface, introducing a range of methods that facilitate non-blocking asynchronous operations. The API is designed to be intuitive, allowing developers to chain tasks and handle results in a straightforward manner. Key methods of the CompletableFuture interface include:\n• None supplyAsync(): This method is used to execute a task asynchronously by supplying a value.\n• None thenApply(): Transforms the result of the previous stage upon completion.\n• None thenAccept(): Consumes the result of the previous stage without returning a new value.\n• None thenRun(): Executes a runnable action after the completion of the previous stage.\n• None exceptionally(): Provides a way to handle exceptions that occur in the CompletableFuture chain.\n• None allOf(): Combines multiple CompletableFutures and waits for all to complete.\n\nThe functionality offered by the CompletableFuture API can be applied across various scenarios to improve application performance and responsiveness. Here are some common use cases:\n• None UI Responsiveness: By executing tasks asynchronously, applications can maintain a responsive user interface while performing long-running operations.\n• None Data Processing: CompletableFuture allows for processing data in parallel, effectively utilizing multi-core processors to speed up computation.\n• None API Calls: When calling external APIs, CompletableFuture can handle the latency often associated with network requests without blocking the main thread.\n• None Batch Processing: It is well-suited for scenarios requiring the aggregation of results from multiple asynchronous tasks, improving efficiency.\n• None Background Tasks: Any task that can run in the background without needing immediate feedback can benefit from the features offered by the CompletableFuture API.\n\nUsing CompletableFuture in various scenarios enhances performance and responsiveness in applications.\n\nCompletableFuture significantly improves user interface responsiveness by offloading time-consuming tasks to background threads. When executing operations like data fetching or processing, the main UI thread remains free to respond to user inputs, thus enhancing the overall user experience.\n• None Loading data asynchronously to keep the UI interactive.\n• None Updating UI components once the data is fetched without blocking user interaction.\n• None Utilizing methods like thenAccept() to directly handle UI updates after a CompletableFuture completes.\n\nThis approach minimizes slowdowns during intensive operations, making applications feel faster and more responsive to user interactions. For instance, while a user waits for a file to upload, other actions can still be performed, thereby improving the perceived performance.\n\nCompletableFuture can also be leveraged on server-side applications to halve response times for asynchronous services. Tasks that can run concurrently—such as database queries, external API calls, and data processing—can be handled simultaneously without waiting for each other to complete.\n• None Executing multiple database calls asynchronously, allowing results from different sources to be combined quickly.\n• None Using allOf() to wait for several futures to complete before sending a single response to the client.\n\nThis non-blocking architecture enables the server to handle more requests simultaneously, leading to enhanced scalability and performance. By utilizing CompletableFuture, systems can efficiently serve clients, maintaining responsiveness even under heavy load.\n\nPerformance considerations play a crucial role when working with asynchronous programming. Understanding the execution behavior of CompletableFuture and how to leverage executors can greatly influence the efficiency and responsiveness of applications.\n\nThe default behavior for executing CompletableFuture tasks is to utilize the ForkJoinPool.commonPool(). This shared pool is designed to manage a pool of threads effectively, making it suitable for a wide range of tasks.\n\nHowever, using the common pool can lead to various performance implications. For instance, if many tasks are submitted simultaneously, it may lead to thread contention and increased latency. Consider the following points regarding the default executor:\n• None Thread Management: The common pool dynamically adjusts the number of threads based on the workload. However, in high-throughput applications, this may not always yield optimal results.\n• None Blocking Tasks: If a task blocks, it utilizes a thread that could otherwise be serving additional tasks. This can reduce overall throughput and delay task completion.\n• None Latency and Throughput: The size of the common pool can affect latency and throughput, particularly when the demand for asynchronous tasks fluctuates. Monitoring and tuning may be necessary to ensure efficient use.\n\nTo gain better control over performance characteristics, utilizing custom executors is often recommended. By defining a custom executor, developers can tailor the threading behavior to meet specific application requirements.\n\nThere are several advantages to using custom executors:\n• None Dedicated Resources: Custom executors can allocate and manage a dedicated set of threads for particular tasks. This control can help in avoiding resource contention and optimizing performance for resource-intensive applications.\n• None Task Prioritization: Developers can implement different strategies for handling tasks, from prioritizing certain tasks over others to managing how and when tasks are executed based on various conditions.\n• None Reducing Overhead: In situations where the default common pool may be overtaxed, custom executors can reduce the overhead associated with creating and managing threads, leading to better response times.\n\nCreating a custom executor involves implementing the Executor interface. Once set up, you can pass this executor to the CompletableFuture methods:\n• None Specific Configuration: Adjust thread pool size, task queue capacity, and other parameters to align with expected workloads.\n• None Scoped Usage: Utilize different executors for different types of tasks, enhancing performance and maintainability of the code.\n\nAdvanced CompletableFuture Techniques provide powerful strategies for managing complex asynchronous workflows. These techniques enhance the capability to coordinate multiple tasks and efficiently handle dependencies.\n\nCombining multiple CompletableFutures allows developers to execute several asynchronous operations concurrently and obtain their results collectively. This is particularly useful when one task's output is needed for another or when tasks are independent but must be completed together.\n\nOne of the most effective ways to combine CompletableFutures is through the use of the allOf() method. This method takes an array of CompletableFutures and returns a new CompletableFuture that completes when all of the futures in the array complete. It simplifies the process of running parallel tasks and efficiently gathering their results.\n• None In the following example, three asynchronous tasks are created and combined:CompletableFuture future1 = CompletableFuture.supplyAsync(() -> \"Task 1 Result\"); CompletableFuture future2 = CompletableFuture.supplyAsync(() -> \"Task 2 Result\"); CompletableFuture future3 = CompletableFuture.supplyAsync(() -> \"Task 3 Result\"); CompletableFuture combinedFuture = CompletableFuture.allOf(future1, future2, future3); combinedFuture.thenRun(() -> { try { System.out.println(future1.get()); System.out.println(future2.get()); System.out.println(future3.get()); } catch (Exception e) { e.printStackTrace(); } });\n\nManaging multiple dependencies in asynchronous programming involves coordinating tasks that may be interdependent. Effective handling of such dependencies ensures that tasks execute in the desired order and only proceed when preconditions are satisfied.\n\nTo manage dependencies, developers can use the thenCompose() method. This method enables chaining of CompletableFutures where the next task starts only after the previous task has completed. It is ideal for scenarios where the output of one task is required as input for another.\n• None The following example illustrates how to chain tasks using thenCompose():CompletableFuture future = CompletableFuture.supplyAsync(() -> { return 10; }).thenCompose(result -> CompletableFuture.supplyAsync(() -> result * 2)) .thenCompose(result -> CompletableFuture.supplyAsync(() -> result + 5)); future.thenAccept(finalResult -> { System.out.println(\"Final Result: \" + finalResult); });"
    },
    {
        "link": "https://medium.com/javarevisited/java-completablefuture-c47ca8c885af",
        "document": "provides a set of asynchronous methods to execute multiple tasks concurrently and process the results as soon as they become available. These methods allow you to create a chain of dependent tasks and execute them in parallel, improving the performance of your application.\n\nHere are some examples of the async methods available in :\n• : This method is used to process the result of a task asynchronously and return a new with the transformed result. The processing is done by a separate thread in the . Here's an example:\n\nIn this example, we’re creating a that returns the string \"Hello\". We're then using the method to transform the result to its length using a separate thread. The method is then used to print the length of the string.\n\nThe output of this code will vary depending on the number of available threads in the , but it will look something like this:\n\n: This method is used to consume the result of a task asynchronously, without returning a value. The processing is done by a separate thread in the . Here's an example:\n\nn this example, we’re creating a that returns the string \"Hello\". We're then using the method to print the string in uppercase using a separate thread.\n\nThe output of this code will vary depending on the number of available threads in the , but it will look something like this:\n\n: This method is used to execute a task asynchronously, without returning a value. The processing is done by a separate thread in the . Here's an example:\n\nIn this example, we’re using the method to execute a task asynchronously that prints a message to the console using a separate thread.\n\nThe output of this code will vary depending on the number of available threads in the , but it will look something like this:\n\n4. is a method in that allows you to chain multiple asynchronous tasks together in a non-blocking way. This method is used when you have one object that returns another object as its result, and you want to execute the second task after the first one has completed.\n\nThe method takes a object as its argument, which takes the result of the first object as its input and returns another object as its result. The second task is executed when the first one completes, and its result is passed to the next stage of the pipeline.\n\nHere is an example of using :\n\nIn this example, we create a that returns the string \"Hello\". We then use the method to chain another to the first one. The second takes the result of the first one and adds the string \" World\" to it. Finally, we use the method to print the result of the second .\n\nThe output of this code will be:\n\nIn this example, creates a dependent that takes the result of the first one and applies a transformation to it. The method is then used to consume the result of the dependent . Note that both tasks are executed asynchronously, so the main thread doesn't block while they are running."
    },
    {
        "link": "https://stackoverflow.com/questions/54527613/is-there-a-way-to-delay-the-execution-of-the-completable-future",
        "document": "I'll be using CompletableFuture for my async calls. I would like to know if there's a way to delay its execution. I have around 5 async calls for one flow, and I am chaining then using thenApply/thenCompose as required. My problem is when I create the first CF for a call, it'll start executing whenever a thread is free. I want that first all my tasks should be chained, then when I call , say complete(), it starts executing. What I am looking for is something similar to the intermediate operations in Java streams. I had some help regarding this in one of my earlier questions on SO, but it's not solving my purpose.\n\nMy tech stack only allows Java 8, so can't use any features launched in the next versions."
    },
    {
        "link": "https://stackoverflow.com/questions/61628302/how-to-execute-a-completablefuture-asynchronously",
        "document": "I have created a method that implements an async retry pattern. Actually, I want that when I call this method request should process in a separate thread and it should retry with some delay\n\nBut it seems that call is not async at all. What I am doing wrong here, Can someone please have a look into this?"
    }
]