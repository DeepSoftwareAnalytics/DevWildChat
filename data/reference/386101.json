[
    {
        "link": "https://stackoverflow.com/questions/54117103/webflux-webclient-asynchronous-request-and-processing-mono",
        "document": "I am new to webflux and am not able to find the right material to continue with the implementation.\n\nI want to issue a request and process the response asynchronously. In this case service call takes about 8-10 ms to respond, so we issue the request and continue doing other work, and look for the response when it is needed for further processing.\n\nHow do we make this call execute asynchronously on a different thread.(I tried subscriberOn with Schedulers.single/ Scheuldes.parallel), but didn't see the call getting executed until Mono.block() is called.\n\nHow do we achieve ?\n• We want this call execute in parallel on a separate thread, so the current thread can continue with other work\n• When the current thread looks for the response, if the service has not completed, block until the call completes"
    },
    {
        "link": "https://medium.com/@bolot.89/leveraging-mono-in-spring-boot-a-uick-guide-to-reactive-programming-0d1ef7be9a87",
        "document": "Add the following dependency to your :\n\nWhen you access , the response will be a non-blocking asynchronous computation returning .\n\nYou can use to perform transformations:\n\nIf you use R2DBC (Reactive Relational Database Connectivity), you can retrieve data reactively:\n\nYou can handle errors gracefully using or :\n\nOften, you need to combine data from multiple asynchronous sources. is perfect for this.\n\nThis combines data streams into a single by using a BiFunction.\n\nYou can cache the result of a to optimize resource usage for repeated calls:\n\nThe first call computes the value, but subsequent calls return the cached result, improving performance.\n\nIf an error occurs, it retries the operation three times before falling back.\n\ncan be used to stream files asynchronously:\n\nThis enables efficient handling of large file downloads without blocking threads.\n\nUse to handle HTTP calls asynchronously with WebClient:\n\nThe WebClient retrieves data from an external API, returning a for further processing.\n\nYou can validate incoming data reactively before proceeding:\n\nThis endpoint checks if the input is valid and processes it accordingly."
    },
    {
        "link": "https://stackoverflow.com/questions/70072530/how-to-turn-a-mono-into-a-truly-asynchronous-not-reactive-method-call",
        "document": "There are side effects, but you may be ok living with them:\n• It truly is fire and forget - which means while you'll never be notified about a success (which most people realise), you'll also never be notified about a failure (which far fewer people realise.)\n• If the process hangs for some reason, that publisher will never complete, and you'll have no way of knowing. Since you're subscribing on the bounded elastic threadpool, it'll also tie up one of those limited threads indefinitely too.\n\nThe first point you might be fine with, or you might want to put some error logging further down that reactive chain as a side-effect somehow so you at least have an internal notification if something goes wrong.\n\nFor the second point - I'd recommend putting a (generous) timeout on your method call so it at least gets cancelled if it hasn't completed in a set time, and is no longer hanging around consuming resources. If you're running an asynchronous task, then this isn't a massive issue as it'll just consume a bit of memory. If you're wrapping a blocking call on the elastic scheduler then this is worse however, as you're tying up a thread in that threadpool indefinitely.\n\nI'd also question why you need to use the bounded elastic scheduler at all here - it's used for wrapping blocking calls, which doesn't seem to be the foundation of this use case. (To be clear, if your service is blocking then you should absolutely wrap it on the elastic scheduler - but if not then there's no reason to do so.)\n\n...is a brilliant example of what not to do, as you're creating a kind of \"imposter reactive method\" - someone may very reasonably subscribe to that returned publisher thinking it will complete when the underlying publisher completes, which obviously isn't what's happening here. Using a return type and thus not returning anything is the correct thing to do in this scenario."
    },
    {
        "link": "https://naveen-metta.medium.com/mastering-reactive-programming-with-project-reactors-mono-and-flux-in-java-6a1a81a01f71",
        "document": "Reactive programming has revolutionized the way Java developers approach building scalable and responsive applications. At the heart of this transformation is Project Reactor, a powerful reactive programming library that introduces two key types: Mono and Flux. In this comprehensive guide, we will explore the intricacies of Mono and Flux, understand their applications, delve into numerous examples, and cover advanced concepts to solidify your mastery of reactive programming in Java.\n\nReactive Programming Primer:\n\nReactive programming is a programming paradigm that focuses on the asynchronous flow of data and events, promoting responsiveness, resilience, and scalability. Project Reactor brings these principles to Java, offering a robust framework for building applications that can handle concurrent and asynchronous tasks seamlessly.\n\nProject Reactor Essentials:\n\nMono — The Single Outcome Warrior:\n\nDefinition:\n\nMono represents a stream of zero or one element, encapsulating the outcome of an asynchronous operation. It is ideal for scenarios where you expect a single result.\n\nSingle-Value Results:\n\nMono is perfect for scenarios where you anticipate a single value as the result of an asynchronous operation."
    },
    {
        "link": "https://geeksforgeeks.org/non-blocking-io-operation-with-spring-webflux",
        "document": "Spring WebFlux is most powerful framework for building reactive, non-blocking web applications. Unlike the traditional Spring MVC which can be based on the synchronous, blocking the I/O model, Spring WebFlux the reactor library enables asynchronous and nonblocking operations. It can allow for better scalability and performance, especially under high load conditions, by efficiently utilizing system resources.\n\nThe main concept behind the non-blocking I/O in the Spring WebFlux is to handle the requests and responses asynchronously. This means that the processing of one request does not block the processing of the other requests. It can achieved through the use of reactive streams and publishers like mono and Flux which can represent the single and multiple asynchronous values, respectively.\n\nReactive streams are the specification for asynchronous stream processing with non-blocking back pressure. It can implement this specification using the Reactor library.\n• Mono : It represents the single asynchronous value or an empty value.\n• Flux : It represents the sequence of the asynchronous values.\n\nThese types enable the composing asynchronous, event-driven programs by the providing operators to transform, filter and combine the multiple asynchronous values.\n\nIn the non-blocking I/O model, threads are not tied up waiting for the I/O operations to complete. Instead, they can handle the other tasks while waiting for the I/O operations to finish. It can be particularly useful in the web applications, where the I/O operations such as the network calls and database access can be slow and frequent.\n• Reactive programming : The programming paradigm oriented data streams and the propagation of the change. It allows for the asynchronous data processing. Making it easier to build the non-blocking systems.\n• Non-Blocking I/O : An I/O operation that does not block the execution thread while waiting for the operation to complete. It allows the other tasks to be performed concurrently.\n• Reactive Streams : The standard for asynchronous stream processing with the non-blocking back pressure. It provides the common way to manage the streams of the data asynchronously.\n• Back Pressure : A mechanism for handling the flow of the data between producers and consumers in the reactive programming to prevent the overwhelming the consumer with too much data at once.\n• Publisher : The interface in the reactive streams that can be produces data and sends it to subscribers.\n• Subscriber : The interface in the reactive streams that can be consumes data provided by the publishers.\n• Asynchronous : The form of computation where operations are executed independently of the main program flow, allowing the programs to continue the running while waiting for the operations to complete.\n\nBelow are the implementation steps of Non-Blocking I/O Operation with Spring WebFlux.\n\nWe will create the Spring project using Spring Initializr and on creating the project add the below dependencies into the project.\n\nOnce create the project then the file structure will look like the below image.\n\nOpen the application.properties fill and add the configuration of the application name and mongodb database of the spring application.\n\nGo to src > main > java > org.example.springwebfluxiodemo > model > Person and put the below code.\n\nGo to src > main > java > org.example.springwebfluxiodemo > repository > PersonRepository and put the below code.\n\nGo to src > main > java > org.example.springwebfluxiodemo > service > PersonService and put the below code.\n\nGo to src > main > java > org.example.springwebfluxiodemo > controller > PersonController and put the below code.\n\nNo changes are required in the main class of the project.\n\nOnce complete the application then run the application, it will start at port 8080.\n\nGet the Person by Id:"
    },
    {
        "link": "https://jakarta.ee/specifications/platform/9/apidocs/jakarta/xml/soap/package-summary",
        "document": "Provides the API for creating and building SOAP messages. This package is defined in thespecification.\n\nThe API in the package allows you to do the following:\n• add content to the header of a SOAP message\n• add content to the body of a SOAP message\n• create attachment parts and add content to them\n\nReferences in this document to SAAJ refer to the Jakarta SOAP with Attachments API unless otherwise noted.\n\n References in this document to JAXB refer to the Jakarta XML Binding unless otherwise noted.\n\nIn addition the APIs in the package extend their counterparts in the package. This means that the of a is also a DOM Level 2 , and can be manipulated as such by applications, tools and libraries that use DOM (see http://www.w3.org/DOM/ for more information). It is important to note that, while it is possible to use DOM APIs to add ordinary DOM nodes to a SAAJ tree, the SAAJ APIs are still required to return SAAJ types when examining or manipulating the tree. In order to accomplish this the SAAJ APIs (specifically ) are allowed to silently replace objects that are incorrectly typed relative to SAAJ requirements with equivalent objects of the required type. These replacements must never cause the logical structure of the tree to change, so from the perspective of the DOM APIs the tree will remain unchanged. However, the physical composition of the tree will have changed so that references to the nodes that were replaced will refer to nodes that are no longer a part of the tree. The SAAJ APIs are not allowed to make these replacements if they are not required so the replacement objects will never subsequently be silently replaced by future calls to the SAAJ API.\n\nWhat this means in practical terms is that an application that starts to use SAAJ APIs on a tree after manipulating it using DOM APIs must assume that the tree has been translated into an all SAAJ tree and that any references to objects within the tree that were obtained using DOM APIs are no longer valid. Switching from SAAJ APIs to DOM APIs is not allowed to cause invalid references and neither is using SAAJ APIs exclusively. It is only switching from using DOM APIs on a particular SAAJ tree to using SAAJ APIs that causes the risk of invalid references.\n\nThere are several factories defined in the SAAJ API to discover and load specific implementation:\n• Checks if a system property with the same name as the factory class is set (e.g. ). If such property exists then its value is assumed to be the fully qualified name of the implementation class. This phase of the look up enables per-JVM override of the SAAJ implementation.\n• Use the configuration file \"jaxm.properties\". The file is in standard format and typically located in the directory of the Java installation. It contains the fully qualified name of the implementation class with the key being the system property defined above.\n• Use the service-provider loading facilities, defined by the class, to attempt to locate and load an implementation of the service using the default loading mechanism.\n• Finally, if all the steps above fail, instance is used to locate specific implementation (for and ) or platform default implementation is used ( ). Whenever is used, its lookup procedure to get actual instance is performed.\n\nFirst three definemethod which uses a common lookup procedure to determine the implementation class:"
    },
    {
        "link": "https://javadoc.io/doc/jakarta.xml.soap/jakarta.xml.soap-api/2.0.0-RC1",
        "document": ""
    },
    {
        "link": "https://jakarta.ee/specifications/soap-attachments/2.0/apidocs/jakarta.xml.soap/jakarta/xml/soap/soapmessage",
        "document": "The root class for all SOAP messages. As transmitted on the \"wire\", a SOAP message is an XML document or a MIME message whose first body part is an XML/SOAP document.\n\nA object consists of a SOAP part and optionally one or more attachment parts. The SOAP part for a object is a object, which contains information used for message routing and identification, and which can contain application-specific content. All data in the SOAP Part of a message must be in XML format.\n\nA new object contains the following by default:\n\nThe SOAP part of a message can be retrieved by calling the method. Theobject is retrieved from theobject, and theobject is used to retrieve theandobjects.\n\nIn addition to the mandatory object, a object may contain zero or more objects, each of which contains application-specific data. The interface provides methods for creating objects and also for adding them to a object. A party that has received a object can examine its contents by retrieving individual attachment parts.\n\nUnlike the rest of a SOAP message, an attachment is not required to be in XML format and can therefore be anything from simple text to an image file. Consequently, any message content that is not in XML format must be in an object.\n\nA object may create objects with behavior that is specialized to a particular implementation or application of SAAJ. For instance, a object may produce objects that conform to a particular Profile such as ebXML. In this case a object might produce objects that are initialized with ebXML headers.\n\nIn order to ensure backward source compatibility, methods that are added to this class after version 1.1 of the SAAJ specification are all concrete instead of abstract and they all have default implementations. Unless otherwise noted in the JavaDocs for those methods the default implementations simply throw an and the SAAJ implementation code must override them with methods that provide the specified behavior. Legacy client code does not have this restriction, however, so long as there is no claim made that it conforms to some later version of the specification than it was originally written for. A legacy class that extends the SOAPMessage class can be compiled and/or run against succeeding versions of the SAAJ API without modification. If such a class was correctly implemented then it will continue to behave correctly relative to the version of the specification against which it was written."
    },
    {
        "link": "https://javadoc.io/doc/jakarta.xml.soap/jakarta.xml.soap-api/1.4.2",
        "document": ""
    },
    {
        "link": "https://spring.io/guides/gs/producing-web-service",
        "document": ""
    },
    {
        "link": "https://spring.io/guides/gs/messaging-jms",
        "document": ""
    },
    {
        "link": "https://medium.com/@ankithahjpgowda/activemq-using-jmstemplate-in-spring-boot-710b168d8fd3",
        "document": "We need to have the ActiveMQ up and running in a machine. You can download and setup ActiveMQ here.\n\nWe need below dependency in our pom.xml file:\n\nBy default, ActiveMQ will run in port 61616 and we need to specify these connection details in or file:\n\nIn Configuration class, we need to create a bean of JMSTemplate as below referring environment variables from properties file.\n\nIn above code snippet, we need some beans to be created for customising the ActiveMQ behaviour:\n• ActiveMQConnectionFactory bean: It is required to establish connection to ActiveMQ. Refer additional options at Apache ActiveMQ documentation\n• MessageConverter bean: It is used to specify the converter between Java objects and JMS messages. Here, we are converting the message to TextMessage.\n• DynamicDestinationResolver bean : It is needed when a same application is having both queues and topics. In JMSTemplate we have single method send() for both queues and topics. It will be decided based on value of flag at runtime. It could be done by overriding default implementation of in class.\n• JMSTemplate bean: Needed to perform all ActiveMQ related operations. The could be (messages will survive a broker restart) or (will lose all in-transit messages on failure). By default the deliveryMode is PERSISTENT.\n\nAll these thing are required for configuring the ActiveMQ in a Spring application. To place messages into messaging queue:\n\nThe above code snippet is having two methods one for sending messages into queue and another to a topic. Both are having same implementation and calling the same send() method of JMSTemplate as discussed before. We can optimise the above code a bit with common method for both queue and topic.\n\nIn Spring we have annotation that could be applied on method level which acts as receiver of message from the destination specified in this annotation.\n\nWe can forward the message to next destination using annotation on listener method.\n\nIn above code snippet, in function we are receiving a message from queue myQueue and forwarding it to another queue myQueue2.\n\nIn other two functions we are receiving the data from topic myTopic. Thus, we are creating 2 consumers for single topic myTopic. Here also, we can optionally forward the message received.\n\nYou can always explore more about ActiveMQ in official documentation.\n\nThank you for reading. Happy exploring!!!\n\nThe complete code can be found on GitHub here"
    },
    {
        "link": "https://stackoverflow.com/questions/22902952/sending-a-blobmessage-using-jmstemplate-with-cachingconnectionfactory",
        "document": "I am using ActiveMQ as my message broker and I have a JMS requirement of sending a big document as an input stream to be processed by consumers. The issue I have is that if I use Spring's org.springframework.jms.connection.CachingConnectionFactory to wrap an ActiveMQConnectionFactory, I'll have to cast the session object (javax.jms.Session) into an org.apache.activemq.ActiveMQSession which is what was suggested in here (Sending Files using Active MQ with BlobMessage).\n\nI then get an exception if I cast the generic Session object into an ActiveMQSession because Spring only provides a Proxy for the javax.jms.Session and not the target object that it proxies to (ie org.apache.activemq.ActiveMQSession). So the solution I resorted to was to just use a plain ActiveMQConnectionFactory instead of using a CachingConnectionFactory. Is there a way for me to keep a CachingConnectionFactory without getting the ClassCastException from my sample code below?\n\nAnd here's what I currently have now in my application context which will prevent the ClassCastException from being thrown. See the commented blocks as well which shows the old configuration I have which throws the exception:"
    },
    {
        "link": "https://devglan.com/spring-mvc/spring-jms-activemq-integration-example",
        "document": "In many enterprise application these days asynchronous request processing mechanism is highly used.Today let us integrate and with with an example.This will be a simple JMS and app with an asynchronous messaging model.All the configurations are made using java config.\n\nIf you are looking for spring boot and activemq integration then visit - Spring Boot JMS ActiveMQ Example\n\nJava Message Service (JMS) is an application program interface (API) that supports the formal communication known as messaging between computers in a network. The messages involved exchange crucial data between computers - rather than between users - and contain information such as event notification and service requests asynchronously.\n\nActiveMQ is a message oriented middleware. It is an open source message broker written in Java together with a full Java Message Service (JMS) client. It provides \"Enterprise Features\" which in this case means fostering the communication from more than one client or server.\n\nQueue follows point-to-point, or p2p messaging model which allows users to send messages both asynchronously and synchronously using different channels. In this model once a message is received by the consumer, the message is destroyed as per p2p messaging model.\n\nTopic follows Publish-and-subscribe, or pub/sub messaging model which allows the producer to send messages to many users at the same time. Consumers can subscribe to a particular topic, or channel, and receive all messages within the chosen topic. This model is asynchronous.\n\nHere we will be developing a sample web app using spring JMS having a producer and consumer which will produce and consume message from two different queue.\n\nTo integrate JMS with Spring, we require 2 extra maven dependencies defined in our pom.xml. They are spring-jms and activemq-all\n\n@EnableJms : It enables detection of JmsListener annotations on any Spring-managed bean in the container.\n\nActiveMQConnectionFactory: It is used for creating connections.\n\nJmsTemplate : It is a helper class that simplifies receiving and sending of messages through JMS and gets rid of the boilerplate code.\n\nDefaultJmsListenerContainerFactory : It is responsible to create the listener container responsible for a particular endpoint.\n\nBy default, acivemq broker url is tcp://localhost:61616. The admin console url is http://localhost:8161/admin/ with userId and password as admin and admin.\n\nThis configuration is responsible to initialize spring based web application.\n\n@JmsListener:It marks a method to be the target of a JMS messagelistener on the specified destination. In our case the destination is inbound.queue This class is responsible to listen messsage from the inbound queue and process the same.\n\nThis class will parse the Json message and extract the value against key name and send greeting message to the outbound queue.\n\nWhile dealing with topic in Spring JMS, we require to manually tell spring to enable it.For this, we only require to set the boolean flag i.e. pubSubDomain to true.To do this, we require our and set pubSubDomain to true for the bean definition of JmsTemplate and DefaultJmsListenerContainerFactory.Following are the changes we require to do.\n\nOnce this is done, rest of the configuration remain same and in place of listening from a queue our aplication can start listening from the topic and publish message to a topic.Following are the lines I have added to consume message from a topic in Listener.java.\n\nOnce this configuration is done and appliation is deployed you can see the following topics under topics menu.\n\nActiveMq by default exposes a broker url tcp://localhost:61616 and an admin console on tcp://localhost:61616 with userId and password as admin and admin. Following are the steps to download and install activemq. 1. Download apache activemq from here as per your operating system. 2. Extract under some folder. In my case it's under java\\apache-activemq-5.11.1-bin. 3. Now traverse to java\\apache-activemq-5.11.1-bin\\bin\\win64 and execute the acivemq.bat file. 4. Open the browser and hit - http://localhost:8161/admin/ 4. Enter userId/password as admin/admin. Then following screen will appear:\n\n5. Now click on the queues option present in menu bar and you can notice there are no queues available as below image.\n\n1. Deploy the application on tomcat. And you can see one queue automatically created with name inbound.queue which we had configured in our Listener.class. Refresh the page after application restart.\n\n2. Our application is now listening to this queue and whenever we push messsage to this queue our Listener should automatically pick this message. Now click on the send To option. Enter a JSON string as {\"name\":\"John\"} and click on send.\n\n3. After the messsage is sent, the message is received by Listener.java and the same message will be processed and send back to outbound.queue by Producer.java. Now you can see one more queue created once you click on the queues option from the menu as shown below:\n\nThis demonstrates a simple JMS integration. It is very useful in a mechanism to allow asynchronous request processing. You may wish to implement JMS because the request take a long time to complete or because several parties may be interested in the actual request. Another reason for using it is to allow multiple clients (potentially written in different languages) to access information via JMS.\n\nI hope this article served you that you were looking for. If you have anything that you want to add or share then please share it below in the comment section."
    },
    {
        "link": "https://stackoverflow.com/questions/62455448/send-message-to-a-jms-queue-using-spring-boot",
        "document": "I am new to Spring JMS. My application is developed using Spring Boot and is deployed in JBoss EAP 7.2.0. I have a remote queue which is an ActiveMQ Artemis queue which is also embedded within JBoss EAP 7.2.0. Can anyone please suggest me how to send a message to the remote JMS queue using of Spring Boot? Basically I am not getting how should I define the remote to connect to the remote queue."
    }
]