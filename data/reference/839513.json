[
    {
        "link": "https://matplotlib.org/3.4.0",
        "document": "Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python.\n\nTrying to learn how to do a particular kind of plot? Check out the examples gallery or the list of plotting commands .\n\nMatplotlib is a welcoming, inclusive project, and everyone within the community is expected to abide by our code of conduct.\n\nJoin our community at discourse.matplotlib.org to get help, discuss contributing & development, and share your work. If you have questions, be sure to check the FAQ, the API docs. The full text search is a good way to discover the docs including the many examples. Check out the Matplotlib tag on stackoverflow. Short questions may be posted on the gitter channel.\n\nTo keep up to date with what's going on in Matplotlib, see the what's new page or browse the source code. Anything that could require changes to your existing code is logged in the API changes file.\n\nMatplotlib is the brainchild of John Hunter (1968-2012), who, along with its many contributors, have put an immeasurable amount of time and effort into producing a piece of software utilized by thousands of scientists worldwide. If Matplotlib contributes to a project that leads to a scientific publication, please acknowledge this work by citing the project. A ready-made citation entry is available.\n\nMatplotlib is a Sponsored Project of NumFOCUS, a 501(c)(3) nonprofit charity in the United States. NumFOCUS provides Matplotlib with fiscal, legal, and administrative support to help ensure the health and sustainability of the project. Visit numfocus.org for more information. Donations to Matplotlib are managed by NumFOCUS. For donors in the United States, your gift is tax-deductible to the extent provided by law. As with any donation, you should consult with your tax adviser about your particular tax situation. Please consider donating to the Matplotlib project through the NumFOCUS organization or to the John Hunter Technology Fellowship. The Matplotlib license is based on the Python Software Foundation (PSF) license. There is an active developer community and a long list of people who have made significant contributions."
    },
    {
        "link": "https://matplotlib.org/stable/tutorials/pyplot.html",
        "document": "Go to the end to download the full example code.\n\nAn introduction to the pyplot interface. Please also see Quick start guide for an overview of how Matplotlib works and Matplotlib Application Interfaces (APIs) for an explanation of the trade-offs between the supported user APIs.\n\nLines have many attributes that you can set: linewidth, dash style, antialiased, etc; see . There are several ways to set line properties\n• None Use the setter methods of a instance. returns a list of objects; e.g., . In the code below we will suppose that we have only one line so that the list returned is of length 1. We use tuple unpacking with to get the first element of that list:\n• None Use . The example below uses a MATLAB-style function to set multiple properties on a list of lines. works transparently with a list of objects or a single object. You can either use python keyword arguments or MATLAB-style string/value pairs: Here are the available properties. To get a list of settable line properties, call the function with a line or lines as argument"
    },
    {
        "link": "https://matplotlib.org",
        "document": "You can help by answering questions on discourse , reporting a bug or requesting a feature on GitHub , or improving the documentation and code !\n\nMatplotlib is a community project maintained for and by its users\n\nMatplotlib is the result of development efforts by John Hunter (1968–2012) and the project's many contributors.\n\nIf Matplotlib contributes to a project that leads to a scientific publication, please acknowledge this work by citing the project!"
    },
    {
        "link": "https://devdocs.io/matplotlib~3.4",
        "document": ""
    },
    {
        "link": "https://matplotlib.org/3.4.0/Matplotlib.pdf",
        "document": ""
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/generated/numpy.linspace.html",
        "document": "The end value of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of evenly spaced samples, so that stop is excluded. Note that the step size changes when endpoint is False.\n\nNumber of samples to generate. Default is 50. Must be non-negative.\n\nIf True, stop is the last sample. Otherwise, it is not included. Default is True.\n\nIf True, return (samples, step), where step is the spacing between samples.\n\nThe type of the output array. If is not given, the data type is inferred from start and stop. The inferred dtype will never be an integer; float is chosen even if the arguments would produce an array of integers.\n\nThe axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.\n\nThe device on which to place the created array. Default: None. For Array-API interoperability only, so must be if passed."
    },
    {
        "link": "https://realpython.com/np-linspace-numpy",
        "document": "When you’re working with numerical applications using NumPy, you often need to create an array of numbers. In many cases you want the numbers to be evenly spaced, but there are also times when you may need non-evenly spaced numbers. One of the key tools you can use in both situations is .\n\nIn its basic form, can seem relatively straightforward to use. However, it’s an essential part of the numerical programming toolkit. It’s both very versatile and powerful. In this tutorial, you’ll find out how to use this function effectively.\n\nIn this tutorial, you’ll learn how to:\n• Create an evenly or non-evenly spaced range of numbers\n• Decide when to use instead of alternative tools\n• Use the required and optional input parameters\n• Create arrays with two or more dimensions\n\nThis tutorial assumes you’re already familiar with the basics of NumPy and the data type. You’ll start by learning about various ways of creating a range of numbers in Python. Then you’ll take a closer look at all the ways of using and how you can use it effectively in your programs.\n\nCreating Ranges of Numbers With Even Spacing There are several ways in which you can create a range of evenly spaced numbers in Python. allows you to do this and to customize the range to fit your specific needs, but it’s not the only way to create a range of numbers. In the next section, you’ll learn how to use before comparing it with other ways of creating ranges of evenly spaced numbers. has two required parameters, and , which you can use to set the beginning and end of the range: This code returns an with equally spaced intervals between the and values. This is a vector space, also called a linear space, which is where the name comes from. Note that the value is included in the output array. The function returns a closed range, one that includes the endpoint, by default. This is contrary to what you might expect from Python, in which the end of a range usually isn’t included. This break with convention isn’t an oversight. You’ll see later on that this is usually what you want when using this function. The array in the example above is of length , which is the default number. In most cases, you’ll want to set your own number of values in the array. You can do so with the optional parameter : The output array in this instance contains equally spaced values between and , which is just the numbers from to . Here’s another example: In the example above, you create a linear space with values between and . You use the parameter as a positional argument, without explicitly mentioning its name in the function call. This is the form you’re likely to use most often. Let’s take a step back and look at what other tools you could use to create an evenly spaced range of numbers. The most straightforward option that Python offers is the built-in . The function call returns an object that produces the sequence from to , which is an evenly spaced range of numbers. For many numerical applications, the fact that is limited to integers is too restrictive. Of the examples shown above, only can be accomplished with : The values returned by , when converted explicitly into a list, are the same as those returned by the NumPy version, except that they’re integers instead of floats. You can still use with list comprehensions to create non-integer ranges: The values in the list are the same as the values in the array outputted by . However, even using a list comprehension is rather clumsy and inelegant compared to using . You first need to work out the interval required and then use that interval within a loop. In most applications, you’ll still need to convert the list into a NumPy array since element-wise computations are less complicated to perform using NumPy arrays. Another point you may need to take into account when deciding whether to use NumPy tools or core Python is execution speed. You can expand the section below to see how using a list performs in comparison to using a NumPy array. You can compare the method using NumPy with the one using list comprehensions by creating functions that perform the same arithmetic operation on all elements in both sequences. In the example below, you divide the range from to into samples, which is the same as intervals: The functions and perform the same operations on the sequences. You can confirm this by checking that the outputs from both functions are the same, as shown on line 12 in the code snippet above. Using the module to time the execution of both versions shows that using lists can be significantly slower than using NumPy arrays. Using NumPy tools rather than core Python can yield efficiency gains in some instances. In applications that require many computations on large amounts of data, this increase in efficiency can be significant. NumPy has its own version of the built-in . It’s called , and unlike , it’s not restricted to just integers. You can use in a similar way to , using , , and as the input parameters: The output values are the same, although returns a range object, which can be converted to a list to display all the values, while returns an array. The array returned by uses a half-open interval, which excludes the endpoint of the range. This behavior is similar to but different from . These differences can be a bit confusing initially, but you’ll get used to them as you start using these functions more often. You can even use non-integer numbers with : The output is an array starting from the value, with the gap between each number being exactly equal to the size used in the input arguments. The last number is the largest number in this series that is smaller than the number used for the of the range. The argument can also be a floating-point number, although you’ll need to use caution in this case as the output may not always be quite what you intend: In the first example, everything seems fine. However, you may have noticed that in the second example, when the is 0.345, the last value in the output is equal to the value even though uses a half-open interval. The documentation for has a warning about this: When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use for these cases. (Source) Here’s a good rule of thumb for deciding which of the two functions to use:\n• Use when the exact values for the and points of your range are the important attributes in your application.\n• Use when the size between values is more important. You’ll use again in this tutorial. To learn more about it, check out NumPy arange(): How to Use np.arange().\n\nUsing with the , , and parameters is the most common way of using the function, and for many applications you won’t need to look beyond this approach. However, you can customize your output further. In this section, you’ll learn how to customize the range that’s created, determine the data types of the items in the array, and control the behavior of the endpoint. Although and are the only required parameters, you’ll usually also want to use a third parameter, . The parameters and are the beginning and end of the range you wish to create, and is an integer that determines how many elements the output array will have. Depending on the application you’re developing, you may think of as the sampling, or resolution, of the array you’re creating. Have a look at a few more examples: Both arrays represent the range between -5 and 5 but with different sampling, or resolution. If you prefer, you can use named parameters: The use of named parameters makes the code more readable. In many applications that use extensively, however, you’ll most often see it used without the first three parameters being named. You can use non-integer numbers to define the range: The array now consists of equally spaced numbers starting and stopping at the exact values used as arguments for the and parameters. You now know how to use the three main input parameters: Often, you’ll use this function with only these three input parameters. However, as you’ll see in the next sections, you can modify the output further. The elements of a NumPy array all belong to the same data type. typically returns arrays of floats. You can see this both by inspecting the output or, better still, by looking at the attribute for the array: The numbers in the array are floats. This is true even in cases such as the following: Even though all elements are whole numbers, they’re still displayed with a trailing period to show that they’re floats. You confirm that by looking at the value of . You can use the optional input parameter to change the data type of the elements in the output array: Although the argument states , NumPy interprets this as an , which is a data type within NumPy. You can confirm this by checking the type of one of the elements of : This shows that NumPy uses its own version of the basic data types. You can use the NumPy data types directly as an argument for the parameter: This produces the same output result but avoids ambiguity by explicitly stating the NumPy data type. When choosing a specific data type, you need to use caution to make sure that your linear space is still valid: NumPy forces the values to be of type by rounding in the usual manner, but the result is no longer a linear space. It’s unlikely that this is the outcome you want. You can read more on data types in NumPy in the official documentation. By default, uses a closed interval, , in which the endpoint is included. This will often be your desired way of using this function. However, if you need to create a linear space with a half-open interval, , then you can set the optional Boolean parameter to : This option allows you to use the function with the Python convention of not including the endpoint with a range. The function can also output the size of the interval between samples that it calculates. If you need the value of the step size between elements, then you can set the Boolean parameter to : The return value in this case is a tuple with the array as the first element and a float with the size as the second. You can also use nonscalar values for and . This returns a higher-dimensional array: Both and are lists of the same length. The first items from each list, and , are the and points for the first vector, which has samples as determined by the parameter. The same applies for the second elements from each list and the third ones. The output is a two-dimensional NumPy array with ten rows and three columns. You can explore this array further by inspecting a row and an element from the two-dimensional array: The first result represents the first row of the array. The second result shows the element in the third column of the first row. You can return the transposed version of this array by setting the optional parameter to : The output array now has the number of rows and columns swapped relative to the earlier example, in which the parameter was not explicitly set and the default value of was used. The function declaration serves as a good summary of the options at your disposal: You can find the full details in the documentation. The key points to remember about the input parameters are listed below: These required parameters define the beginning and end of the range. Often these will be scalar values, either or , but can be any array-like object. This parameter defines the number of points in the array, often referred to as sampling or resolution. If this parameter is set to , then the function treats the interval as a half-open interval and excludes the endpoint from the output array. If this parameter is set to , then the function returns the array and a with the step size between each element of the linear space. Otherwise, only the array is returned. This parameter can be used to set the data type of the elements in the output array. This parameter is used only with nonscalar and values. It determines the axis along which the results are stored. The outputs returned from calling the function are listed below:\n• An array of type containing the vector space\n• The step size as a , if is set to You can use this section as a reference when you start experimenting with and the different ways you can customize its output. Imagine that a company that produces packaged food items has a conveyor belt system in its food production factory. The position along the conveyor belt is referenced by a number that represents the length of the conveyor path from the starting point. There are 27 temperature sensors that have been installed at equal intervals along a critical stretch of the belt. The first sensor is located at position 17.5 along the belt, and the last one at 46.2. The temperature sensor array outputs data that can be read as a list in Python. Here’s an example of a readout of temperatures in degrees Celsius: The factory manager needs to see these temperatures plotted against their position on the conveyor belt to ensure temperatures remain within tolerance at each point on this critical stretch of the belt. You’ll need to import to plot the temperatures: You plot the values in the list and set the title and axis labels. This gives the following plot: This plot shows the temperatures plotted against the list index of the sensors. This isn’t useful for the factory manager, who wants to know the temperatures with respect to the standard reference positions of the belt. To create an index for the temperatures that matches the known reference positions, you’ll use three bits of information:\n• The first one is at position 17.5.\n• The last one is at position 46.2. This is an ideal scenario for using : The linear space shows the exact locations of all the temperature sensors along the conveyor belt. You can now plot the temperatures against the array: The difference from the previous example in the code above is that you use the array as the first argument in . This gives the following plot: The graph now shows the correct x-axis, which represents the positions at which each temperature was measured. This example shows a typical case for which is the ideal solution.\n\nMany areas of science, engineering, finance, and other fields rely on mathematical functions. These are often functions of continuous variables. If you want to study these processes computationally, then you’ll need to approximate these mathematical functions with a discrete representation. One of the key tools you’ll need in this process is the ability to create a linear space. In this section, you’ll learn how to represent a mathematical function in Python and plot it. Consider the following function: This mathematical function is a mapping from the continuous real number line. Even if limits are set, say for -5 ≤ x ≤ 5, there is still an infinite number of values of x. To represent the function above, you’ll first need to create a discrete version of the real number line: In this tutorial, the symbol x is used to represent the continuous mathematical variable defined over the real number line, and is used to represent the computational, discrete approximation of it. The version with an underscore is also used for the Python variable representing the array. Since is a NumPy array, you can compute algebraic manipulations similarly to how you would mathematically, and no loops are required: The new array, , is a discrete version of the continuous variable . The final step is to visualize it: This creates a plot of against , which is shown below: Note that this plot doesn’t seem very smooth. The linear space created has only points. That’s not enough to represent the mathematical function properly. The function is undersampled. Doubling the resolution may work better: This gives the following plot: That’s better, and you can be more confident that it’s a fair representation of the function. However, the plot still isn’t as smooth as you might expect to see in a math textbook. With an even higher sampling, the plot becomes smoother: This gives the following plot: You can choose an even higher sampling, but that will come at a cost. Larger arrays require more memory, and computations will require more time. In this section, you’ll create two different waves with distinct properties, then you’ll superimpose them and create an animation to show how they travel. A wave can be represented mathematically by the following function: This tutorial isn’t about the physics of waves, so I’ll keep the physics very brief! A wave follows a sinusoidal function that is defined by the following five terms:\n• The amplitude of the wave (A)\n• The velocity of the wave (v) You’ll learn how to deal with two-dimensional functions in the next section, but for this example you’ll take a different approach. You can start by creating a linear space to represent x: Once the constants are defined, you can create the wave. You can start by defining the constants: # You can set time to 0 for now The function includes time (t), but initially you’ll focus on the variable x. Setting for now means that you can still write the full equations in your code even though you’re not using time yet. You can now create the array to represent the wave: The array created is the discrete version of the equation that describes the wave. Now you can plot the : The plot of the is shown below: That doesn’t look like a sine wave, but you saw this issue earlier. The resolution of the linear space used for isn’t sufficient. You can fix this by increasing the sampling: This plot of the now shows a smooth wave: Now you’re ready to superimpose two waves. All you need to do is create two different waves and add them up. This is also a good time to refactor the code to tidy it up a bit: # Parameters are tuples with a value for each wave (2 in this case) # You can set time to 0 for now # Create 2 (or more) waves using a list comprehension and superimpose # Plot both waves separately to see what they look like This code creates two different waves and adds them together, showing the superimposition of waves: You can see both waves plotted separately in the top figure. The bottom figure shows the superimposition of the waves, when they’re added together. Your final task now is to set these waves in motion by plotting the superimposed waves for different values of time t: # Create 2 (or more) waves using a list comprehension and superimpose # Fix the limits on the y-axis This gives the following output: You can try out the code above with waves of different parameters, and you can even add a third or fourth wave. You can now pick your own favorite functions to experiment with and try to represent them in Python. In the previous example, you resolved the problem of having a function with two variables by representing one as a spatial coordinate and one as a time coordinate. This made sense as the two coordinates were indeed one spatial and one temporal. This method won’t always work, though. Here’s a function with two variables: This is the simplified Gaussian function in two dimensions, with all parameters having unit value. To represent this, you’ll need to create two linear spaces, one for x and one for y. In this case, they can be identical, but that doesn’t always need to be the case: These vectors are each one-dimensional, but the required array must be two-dimensional since it needs to represent a function of two variables. NumPy has a useful function called that you can use in conjunction with to transform one-dimensional vectors into two-dimensional matrices. These matrices represent the coordinates in two dimensions: You’ve transformed the vectors into two-dimensional arrays. You can now use these arrays to create the two-dimensional function: You can show this matrix in two or three dimensions using : The two-dimensional and three-dimensional representations are shown below: You can use this method for any function of two variables. If you wanted to create a binary disk-shaped mask, then you could represent this function using comparison operators: On line 10, you generate the array using element-wise comparison. This gives the following plot: The array has the value (or ) for all values of and that fall within the equation of the circle. Otherwise, it has the value (or ). You’re now equipped with the tools to represent mathematical functions in one dimension and two dimensions computationally, using to create the linear spaces required to represent the function variables. You can extend the same concept to higher dimensions as well.\n\nYou’ve seen how to create and use an evenly spaced range of numbers. However, there are times when you may need an array that isn’t spaced linearly. The steps between each value may need to be logarithmic or follow some other pattern. In this final section, you’ll find out what your options are for creating this type of array. The function creates a logarithmic space in which the numbers created are evenly spaced on a log scale. Once you’ve mastered , you’ll be well equipped to use since the input parameters and returned output of the two functions are very similar. One parameter that’s missing from is since there isn’t a single value to represent the step change between successive numbers. has an additional input parameter, , with a default value of . Another key difference is that and represent the logarithmic start and end points. The first value in the array is , and the final value is : This creates a logarithmic space with elements ranging from to , or from to . The output array shows the numbers , , , , and in scientific notation. Although base 10 is the default value, you can create logarithmic spaces with any base: This example shows a logarithmic space in base e. In the next section, you’ll see how to create other nonlinear ranges that aren’t logarithmic. You can now create linear and logarithmic spaces. You may also need a range of numbers that follow other nonlinear intervals. You can achieve this by transforming a linear space. You can now transform this to be a range of numbers that are linear over x2: This may seem familiar. It’s the same method you used to represent mathematical functions earlier in this tutorial. Indeed, it’s exactly the same. The reason you may sometimes want to think of this as creating a non-evenly spaced array will become clearer in the next section, when you look at a concrete example. Example: Simulation of an Orbiting Planet In this section, you’ll create a simulation of a planet orbiting around its sun. To simplify the simulation slightly, you can assume the planet’s orbit is circular rather than elliptical. The equation that describes a circle is a function of x and y and depends on the radius R: So if the x-positions of the planet are set, the corresponding y-positions will be given by rearranging the equation above: The planet can therefore be placed at a set of coordinates (x, y), and as long as y is given by the equation above, the planet will remain in orbit. Its location will be on the circumference of a circle. You’re now well versed with , so the first attempt can use the methods you already know: The variable x spans the diameter of the circle along the horizontal, from left to right, which means from -R to +R. Now you can work out y: The array is the discrete version of the continuous variable y, which describes a circle. You can plot these points using a scatter plot: To make sure the two-dimensional plot shows the correct pattern, you set the axes to , which ensures that each pixel has a square aspect ratio: All points fit nicely on the circumference of a circle, which should be the case for a planet in a circular orbit. But planets don’t only go around a semicircular orbit. The problem is that the values of x for the other half of the circle are the same. The top semicircle and the bottom one share the same x values but not the same y values. You can resolve this issue by looking back at the above equation that gives y in terms of x. This equation has both a positive solution and a negative one. As x swings back from +R on the right to -R on the left, you can take the negative solution for y: # x_return and y_return are the x_ and y_ values as the # planet moves from right to left The array is the reverse of but without the endpoints. Otherwise, the endpoints will be repeated when you concatenate and . The array is the negative solution for . Therefore, you can overwrite to become the concatenation of and : The values within go from through to and then back through to . You can also print to confirm that it corresponds to the positive values of y for the first half and the negative values of y for the second half. A scatter plot of and will confirm that the planet is now in an orbit that’s a full circle: This gives the following plot: You may already be able to spot the problem in this scatter plot, but you’ll come back to it a bit later. For now, you can use the and vectors above to create a simulation of the moving planet. You’ll need to import for this: # an equal aspect (square), and turn the axes off # Images are generated and stored in a list to animate later # Scatter plot each point using a dot of size 250 and color red # Let's also put a large yellow sun in the middle # The animation can now be created using ArtistAnimation This gives the following output: Unfortunately, planets don’t orbit in this manner. You can see how the planet speeds up as it crosses the x-axis at the left and right of the orbit and slows down as it crosses the y-axis at the top and bottom. Take another look at the scatter plots showing all the planet positions around the orbit to see why this happens. The points are closer together at the top and bottom of the orbit but spaced out on the left and right. You need points that are evenly spaced over the circumference of the orbit, but what you have are points based on an evenly spaced vector. To fix this, you need to create an array of values that isn’t linear but that produces points that are linear along the circumference of the orbit. As a point moves smoothly around a circular orbit, its projection on the x-axis moves (co-)sinusoidally, so you can fix this by changing so that it’s linear over : The first line transforms a linear space into a nonlinear one. The intervals between each value of aren’t equal but vary according to the cosine function. This gives the following plot: The points are now evenly spaced across the circumference of the circular orbit. Your final step is to re-create the animation using the same code as earlier. This is also a good time to increase the resolution by increasing the value of the variable you defined at the start: This gives the following output: To see the full version of the code that generates this animation, you can expand the section below. The full, final version of the simulation, including saving the simulation to a , is available here: # Create vector x_ that is linear on cos(x_) # First create x_ from left to right (-R to +R) # And then x_ returns from right to left (+R to R) # Calculate y_ using the positive solution when x_ is increasing # And the negative solution when x_ is decreasing You’ve just created an animation of a planet orbiting a star. You had to make the movement of the planet linear over the circumference of a circle by making the positions of the planet evenly spaced over the circumference of the circle. You can now create any non-evenly spaced range of numbers as long as you can express it mathematically."
    },
    {
        "link": "https://geeksforgeeks.org/numpy-linspace",
        "document": "linspace() function in NumPy returns an array of evenly spaced numbers over a specified range. Unlike the range() function in Python that generates numbers with a specific step size. linspace() allows you to specify the total number of points you want in the array, and NumPy will calculate the spacing between the numbers automatically.\n\nLet’s understand with the help of an example:\n• None In this example, np.linspace(0, 1, num=10) generates an array of 10 numbers between 0 and 1, including both endpoints.\n• num : [int, optional] No. of samples to generate\n• retstep : If True, Stop is the last sample By default restep = False\n• endpoint : If True, stop is included as the last value. If False, stop is excluded. By default endpoint=True.\n• axis : If start and stop are arrays, axis specifies on what axis will the values be added. If axis = 0, value is added to front, if axis = -1 value is added at the end.\n\nIncluding or Excluding the Stop Value\n\nBy default, includes the value. However, you can exclude it by setting the parameter to .\n\nparameter allows you to return the step size between each number along with the array.\n\nWe can also generate multi-dimensional arrays using linspace(). We can create a 2D array of numbers between 0 and 1:"
    },
    {
        "link": "https://w3resource.com/numpy/array-creation/linspace.php",
        "document": "The numpy.linspace() function is used to create an array of evenly spaced numbers within a specified range. The range is defined by the start and end points of the sequence, and the number of evenly spaced points to be generated between them.\n\nndarray - There are num equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop) (depending on whether endpoint is True or False).\n\nstep : float, optional - Only returned if retstep is True\n\n Size of spacing between samples.\n\nThe above code demonstrates the usage of numpy's linspace() function for generating evenly spaced values within a specified interval. The function takes three main arguments: start point, end point, and the number of values to be generated.\n\n In the first example, linspace() generates 7 values between 3.0 and 4.0, including the endpoint of 4.0. \n\n In the second example, the endpoint is excluded by setting the optional parameter 'endpoint' to False, and linspace() generates 7 values with equal spacing between 3.0 and 4.0. \n\n In the third example, the optional parameter 'retstep' is set to True, which returns a tuple containing the generated array and the step size between adjacent values.\n\nThe above code uses the numpy and matplotlib.pyplot libraries to create a simple plot of points. \n\n 1. A is set to 5 and x is created as a numpy array of 5 zeros. \n\n 2. Two arrays a1 and a2 are created using numpy.linspace method, which returns evenly spaced numbers over a specified interval. \n\n 3. plt.plot is used to create two sets of points on the plot."
    },
    {
        "link": "https://numpy.org/devdocs/user/how-to-partition.html",
        "document": "How to create arrays with regularly-spaced values#\n\nThere are a few NumPy functions that are similar in application, but which provide slightly different results, which may cause confusion if one is not sure when and how to use them. The following guide aims to list these functions and describe their recommended usage.\n\nThe functions mentioned here are\n\nBoth and provide ways to partition an interval (a 1D domain) into equal-length subintervals. These partitions will vary depending on the chosen starting and ending points, and the step (the length of the subintervals).\n• None Use if you want integer steps. relies on step size to determine how many elements are in the returned array, which excludes the endpoint. This is determined through the argument to . The arguments and should be integer or real, but not complex numbers. is similar to the Python built-in . Floating-point inaccuracies can make results with floating-point numbers confusing. In this case, you should use instead.\n• None Use if you want the endpoint to be included in the result, or if you are using a non-integer step size. can include the endpoint and determines step size from the num argument, which specifies the number of elements in the returned array. The inclusion of the endpoint is determined by an optional boolean argument , which defaults to . Note that selecting will change the step size computation, and the subsequent output for the function. can also be used with complex arguments:\n• None Unexpected results may happen if floating point values are used as in . To avoid this, make sure all floating point conversion happens after the computation of results. For example, replace [0.1, 0.2, 0.3, 0.4] # endpoint should not be included!\n• These differ because of numeric noise. When using floating point values, it is possible that , and so is in the interval. In fact, this is exactly the case: But so that 1.08 is excluded: Alternatively, you could use which would always give you precise control of the end point since it is integral: is similar to , but with numbers spaced evenly on a log scale (a geometric progression). The endpoint is included in the result. is similar to , but with the start and end points specified as logarithms (with base 10 as default): In linear space, the sequence starts at ( to the power of ) and ends with :\n\nN-D domains can be partitioned into grids. This can be done using one of the following functions. The purpose of is to create a rectangular grid out of a set of one-dimensional coordinate arrays. will create two coordinate arrays, which can be used to generate the coordinate pairs determining this grid.: can be used as a shortcut for creating meshgrids. It is not a function, but when indexed, returns a multidimensional meshgrid. Similar to , returns an open multidimensional meshgrid. This means that when it is indexed, only one dimension of each returned array is greater than 1. This avoids repeating the data and thus saves memory, which is often desirable. These sparse coordinate grids are intended to be used with Broadcasting. When all coordinates are used in an expression, broadcasting still leads to a fully-dimensional result array. All three methods described here can be used to evaluate function values on a grid."
    }
]