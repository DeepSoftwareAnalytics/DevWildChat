[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/framework/debug-trace-profile/enhancing-debugging-with-the-debugger-display-attributes",
        "document": "Debugger display attributes allow the developer of the type, who specifies and best understands the runtime behavior of that type, to also specify what that type will look like when it is displayed in a debugger. In addition, debugger display attributes that provide a property can be applied at the assembly level by users without knowledge of the source code. The DebuggerDisplayAttribute attribute controls how a type or member is displayed in the debugger variable windows. The DebuggerBrowsableAttribute attribute determines if and how a field or property is displayed in the debugger variable windows. The DebuggerTypeProxyAttribute attribute specifies a substitute type, or a proxy, for a type and changes the way the type is displayed in debugger windows. When you view a variable that has a proxy, or substitute type, the proxy stands in for the original type in the debugger display window. The debugger variable window displays only the public members of the proxy type. Private members are not displayed.\n\nThe DebuggerDisplayAttribute constructor has a single argument: a string to be displayed in the value column for instances of the type. This string can contain braces ({ and }). The text within a pair of braces is evaluated as an expression. For example, the following C# code causes \"Count = 4\" to be displayed when the plus sign (+) is selected to expand the debugger display for an instance of .\n\nAttributes applied to properties referenced in the expression are not processed. For the C# compiler, a general expression is allowed that has only implicit access to this reference for the current instance of the target type. The expression is limited; there is no access to aliases, locals, or pointers. In C# code, you can use a general expression between the braces that has implicit access to the pointer for the current instance of the target type only.\n\nFor example, if a C# object has an overridden , the debugger will call the override and show its result instead of the standard Thus, if you have overridden , you do not need to use DebuggerDisplayAttribute. If you use both, the DebuggerDisplayAttribute attribute takes precedence over the override.\n\nApply the DebuggerBrowsableAttribute to a field or property to specify how the field or property is to be displayed in the debugger window. The constructor for this attribute takes one of the DebuggerBrowsableState enumeration values, which specifies one of the following states:\n• None Never indicates that the member is not displayed in the data window. For example, using this value for the DebuggerBrowsableAttribute on a field removes the field from the hierarchy; the field is not displayed when you expand the enclosing type by clicking the plus sign (+) for the type instance.\n• None Collapsed indicates that the member is displayed but not expanded by default. This is the default behavior.\n• None RootHidden indicates that the member itself is not shown, but its constituent objects are displayed if it is an array or collection.\n\nThe following code example shows the use of the DebuggerBrowsableAttribute to prevent the property following it from appearing in the debug window for the class.\n\nUse the DebuggerTypeProxyAttribute attribute when you need to significantly and fundamentally change the debugging view of a type, but not change the type itself. The DebuggerTypeProxyAttribute attribute is used to specify a display proxy for a type, allowing a developer to tailor the view for the type. This attribute, like the DebuggerDisplayAttribute, can be used at the assembly level, in which case the Target property specifies the type for which the proxy will be used. The recommended usage is that this attribute specifies a private nested type that occurs within the type to which the attribute is applied. An expression evaluator that supports type viewers checks for this attribute when a type is displayed. If the attribute is found, the expression evaluator substitutes the display proxy type for the type the attribute is applied to.\n\nWhen the DebuggerTypeProxyAttribute is present, the debugger variable window displays only the public members of the proxy type. Private members are not displayed. The behavior of the data window is not changed by attribute-enhanced views.\n\nTo avoid unnecessary performance penalties, attributes of the display proxy are not processed until the object is expanded, either through the user clicking the plus sign (+) next to the type in a data window, or through the application of the DebuggerBrowsableAttribute attribute. Therefore, it is recommended that no attributes be applied to the display type. Attributes can and should be applied within the body of the display type.\n\nThe following code example shows the use of the DebuggerTypeProxyAttribute to specify a type to be used as a debugger display proxy.\n\nThe following code example can be viewed in Visual Studio to see the results of applying the DebuggerDisplayAttribute, DebuggerBrowsableAttribute, and DebuggerTypeProxyAttribute attributes."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes",
        "document": "Attributes provide a powerful way to associate metadata, or declarative information, with code (assemblies, types, methods, properties, and so on). After you associate an attribute with a program entity, you can query the attribute at run time by using a technique called reflection.\n\nAttributes have the following properties:\n• Attributes add metadata to your program. Metadata is information about the types defined in a program. All .NET assemblies contain a specified set of metadata that describes the types and type members defined in the assembly. You can add custom attributes to specify any other required information.\n• Attributes can be applied to entire assemblies, modules, or smaller program elements, such as classes and properties.\n• Attributes can accept arguments in the same way as methods and properties.\n• Attributes enable a program to examine its own metadata or metadata in other programs by using reflection.\n\nReflection APIs provided by Type describe assemblies, modules, and types. You can use reflection to dynamically create an instance of a type, bind the type to an existing object, or get the type from an existing object and invoke its methods or access its fields and properties. When you use attributes in your code, reflection enables you to access them. For more information, see Attributes.\n\nHere's a simple example of reflection with the GetType() method. All types from the base class inherit this method, which is used to obtain the type of a variable:\n\nThe following example uses reflection to obtain the full name of the loaded assembly.\n\nThe output is similar to the following example:\n\nThe C# keywords and have no meaning in Intermediate Language (IL) and aren't used in the reflection APIs. The corresponding terms in IL are Family and Assembly. Here some ways you can use these terms:\n• To identify an method by using reflection, use the IsAssembly property.\n• To identify a method, use the IsFamilyOrAssembly.\n\nAttributes can be placed on almost any declaration, though a specific attribute might restrict the types of declarations on which it's valid. In C#, you specify an attribute by placing the name of the attribute enclosed in square brackets ( ) above the declaration of the entity to which it applies.\n\nIn this example, you use the SerializableAttribute attribute to apply a specific characteristic to a class:\n\nYou can declare a method with the DllImportAttribute attribute:\n\nYou can place multiple attributes on a declaration:\n\nSome attributes can be specified more than once for a given entity. The following example shows multiuse of the ConditionalAttribute attribute:\n\nMany attributes have parameters, which can be positional, unnamed, or named. The following table describes how to work with named and positional attributes:\n\nFor example, the following code shows three equivalent attributes:\n\nThe first parameter, the DLL name, is positional and always comes first. The other instances are named parameters. In this scenario, both named parameters default to false, so they can be omitted. Refer to the individual attribute's documentation for information on default parameter values. For more information on allowed parameter types, see the Attributes section of the C# language specification.\n\nThe target of an attribute is the entity that the attribute applies to. For example, an attribute can apply to a class, a method, or an assembly. By default, an attribute applies to the element that follows it. But you can also explicitly identify the element to associate, such as a method, a parameter, or the return value.\n\nTo explicitly identify an attribute target, use the following syntax:\n\nThe following table shows the list of possible values.\n\nYou can specify the target value to apply an attribute to the backing field created for an automatically implemented property.\n\nThe following example shows how to apply attributes to assemblies and modules. For more information, see Common attributes (C#).\n\nThe following example shows how to apply attributes to methods, method parameters, and method return values in C#.\n\nHere are some common ways to use attributes in code:\n• Mark controller methods that respond to POST messages by using the attribute. For more information, see the HttpPostAttribute class.\n• Describe how to marshal method parameters when interoperating with native code. For more information, see the MarshalAsAttribute class.\n• Describe Component Object Model (COM) properties for classes, methods, and interfaces.\n• Call unmanaged code by using the DllImportAttribute class.\n• Describe your assembly in terms of title, version, description, or trademark.\n• Describe which members of a class to serialize for persistence.\n• Describe how to map between class members and XML nodes for XML serialization.\n• Specify characteristics used to enforce security.\n• Control optimizations with the just-in-time (JIT) compiler so the code remains easy to debug.\n• Obtain information about the caller to a method.\n\nReflection is useful in the following scenarios:\n• Access attributes in your program's metadata. For more information, see Retrieving information stored in attributes.\n• Examine and instantiate types in an assembly.\n• Build new types at run time by using classes in the System.Reflection.Emit namespace.\n• Perform late binding and access methods on types created at run time. For more information, see Dynamically loading and using types."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/attributes",
        "document": "Much of the C# language enables the programmer to specify declarative information about the entities defined in the program. For example, the accessibility of a method in a class is specified by decorating it with the method_modifiers , , , and .\n\nC# enables programmers to invent new kinds of declarative information, called attributes. Programmers can then attach attributes to various program entities, and retrieve attribute information in a run-time environment.\n\nAttributes are defined through the declaration of attribute classes (§22.2), which can have positional and named parameters (§22.2.3). Attributes are attached to entities in a C# program using attribute specifications (§22.3), and can be retrieved at run-time as attribute instances (§22.4).\n\nA class that derives from the abstract class , whether directly or indirectly, is an attribute class. The declaration of an attribute class defines a new kind of attribute that can be placed on program entities. By convention, attribute classes are named with a suffix of . Uses of an attribute may either include or omit this suffix.\n\nA generic class declaration shall not use as a direct or indirect base class.\n\nThe attribute (§22.5.2) is used to describe how an attribute class can be used.\n\nhas a positional parameter (§22.2.3) that enables an attribute class to specify the kinds of program entities on which it can be used.\n\nhas a named parameter (§22.2.3), called , which indicates whether the attribute can be specified more than once for a given entity. If for an attribute class is true, then that attribute class is a multi-use attribute class, and can be specified more than once on an entity. If for an attribute class is false or it is unspecified, then that attribute class is a single-use attribute class, and can be specified at most once on an entity.\n\nhas another named parameter (§22.2.3), called , which indicates whether the attribute, when specified on a base class, is also inherited by classes that derive from that base class. If for an attribute class is true, then that attribute is inherited. If for an attribute class is false then that attribute is not inherited. If it is unspecified, its default value is true.\n\nAn attribute class not having an attribute attached to it, as in\n\nis equivalent to the following:\n\nAttribute classes can have positional parameters and named parameters. Each public instance constructor for an attribute class defines a valid sequence of positional parameters for that attribute class. Each non-static public read-write field and property for an attribute class defines a named parameter for the attribute class. For a property to define a named parameter, that property shall have both a public get accessor and a public set accessor.\n\nThe types of positional and named parameters for an attribute class are limited to the attribute parameter types, which are:\n• One of the following types: , , , , , , , , , , , , .\n• Single-dimensional arrays of the above types.\n• A constructor argument or public field that does not have one of these types, shall not be used as a positional or named parameter in an attribute specification.\n\nAttribute specification is the application of a previously defined attribute to a program entity. An attribute is a piece of additional declarative information that is specified for a program entity. Attributes can be specified at global scope (to specify attributes on the containing assembly or module) and for type_declarations (§14.7), class_member_declarations (§15.3), interface_member_declarations (§18.4), struct_member_declarations (§16.3), enum_member_declarations (§19.2), accessor_declarations (§15.7.3), event_accessor_declarations (§15.8), elements of parameter_lists (§15.6.2), and elements of type_parameter_lists (§15.2.3).\n\nAttributes are specified in attribute sections. An attribute section consists of a pair of square brackets, which surround a comma-separated list of one or more attributes. The order in which attributes are specified in such a list, and the order in which sections attached to the same program entity are arranged, is not significant. For instance, the attribute specifications , , , and are equivalent.\n\nFor the production global_attribute_target, and in the text below, identifier shall have a spelling equal to or , where equality is that defined in §6.4.3. For the production attribute_target, and in the text below, identifier shall have a spelling that is not equal to or , using the same definition of equality as above.\n\nAn attribute consists of an attribute_name and an optional list of positional and named arguments. The positional arguments (if any) precede the named arguments. A positional argument consists of an attribute_argument_expression; a named argument consists of a name, followed by an equal sign, followed by an attribute_argument_expression, which, together, are constrained by the same rules as simple assignment. The order of named arguments is not significant.\n\nWhen an attribute is placed at the global level, a global_attribute_target_specifier is required. When the global_attribute_target is equal to:\n• — the target is the containing assembly\n• — the target is the containing module\n\nNo other values for global_attribute_target are allowed.\n\nThe standardized attribute_target names are , , , , , , , and . These target names shall only be used in the following contexts:\n• — a field. A field-like event (i.e., one without accessors) (§15.8.2) and an automatically implemented property (§15.7.4) can also have an attribute with this target.\n• — a constructor, finalizer, method, operator, property get and set accessors, indexer get and set accessors, and event add and remove accessors. A field-like event (i.e., one without accessors) can also have an attribute with this target.\n• — a property set accessor, an indexer set accessor, event add and remove accessors, and a parameter in a constructor, method, and operator.\n• — a delegate, method, operator, property get accessor, and indexer get accessor.\n\nCertain contexts permit the specification of an attribute on more than one target. A program can explicitly specify the target by including an attribute_target_specifier. Without an attribute_target_specifier a default is applied, but an attribute_target_specifier can be used to affirm or override the default. The contexts are resolved as follows:\n• For an attribute on a delegate declaration the default target is the delegate. Otherwise when the attribute_target is equal to:\n• — the target is the delegate\n• — the target is the return value\n• For an attribute on a method declaration the default target is the method. Otherwise when the attribute_target is equal to:\n• — the target is the method\n• — the target is the return value\n• For an attribute on an operator declaration the default target is the operator. Otherwise when the attribute_target is equal to:\n• — the target is the operator\n• — the target is the return value\n• For an attribute on a get accessor declaration for a property or indexer declaration the default target is the associated method. Otherwise when the attribute_target is equal to:\n• — the target is the associated method\n• — the target is the return value\n• For an attribute specified on a set accessor for a property or indexer declaration the default target is the associated method. Otherwise when the attribute_target is equal to:\n• — the target is the associated method\n• — the target is the lone implicit parameter\n• For an attribute on an automatically implemented property declaration the default target is the property. Otherwise when the attribute_target is equal to:\n• — the target is the compiler-generated backing field for the property\n• For an attribute specified on an event declaration that omits event_accessor_declarations the default target is the event declaration. Otherwise when the attribute_target is equal to:\n• — the target is the event declaration\n• — the target is the field\n• — the targets are the methods\n• In the case of an event declaration that does not omit event_accessor_declarations the default target is the method.\n• — the target is the associated method\n• — the target is the lone parameter\n\nIn all other contexts, inclusion of an attribute_target_specifier is permitted but unnecessary.\n\nAn implementation can accept other attribute_targets, the purposes of which are implementation defined. An implementation that does not recognize such an attribute_target shall issue a warning and ignore the containing attribute_section.\n\nBy convention, attribute classes are named with a suffix of . An attribute_name can either include or omit this suffix. Specifically, an attribute_name is resolved as follows:\n• If the right-most identifier of the attribute_name is a verbatim identifier (§6.4.3), then the attribute_name is resolved as a type_name (§7.8). If the result is not a type derived from , a compile-time error occurs.\n• Otherwise,\n• The attribute_name is resolved as a type_name (§7.8) except any errors are suppressed. If this resolution is successful and results in a type derived from then the type is the result of this step.\n• The characters are appended to the right-most identifier in the attribute_name and the resulting string of tokens is resolved as a type_name (§7.8) except any errors are suppressed. If this resolution is successful and results in a type derived from then the type is the result of this step.\n\nIf exactly one of the two steps above results in a type derived from , then that type is the result of the attribute_name. Otherwise a compile-time error occurs.\n\nIt is a compile-time error to use a single-use attribute class more than once on the same entity.\n\nAn expression is an attribute_argument_expression if all of the following statements are true:\n• The type of is an attribute parameter type (§22.2.4).\n• At compile-time, the value of can be resolved to one of the following:\n• A object obtained using a typeof_expression (§12.8.18) specifying a non-generic type, a closed constructed type (§8.4.3), or an unbound generic type (§8.4.4), but not an open type (§8.4.3).\n\nThe attributes of a type declared in multiple parts are determined by combining, in an unspecified order, the attributes of each of its parts. If the same attribute is placed on multiple parts, it is equivalent to specifying that attribute multiple times on the type.\n\nAttributes on type parameters combine in the same way.\n\nAn attribute instance is an instance that represents an attribute at run-time. An attribute is defined with an attribute class, positional arguments, and named arguments. An attribute instance is an instance of the attribute class that is initialized with the positional and named arguments.\n\nRetrieval of an attribute instance involves both compile-time and run-time processing, as described in the following subclauses.\n\nThe compilation of an attribute with attribute class , positional_argument_list , named_argument_list , and specified on a program entity is compiled into an assembly via the following steps:\n• Follow the compile-time processing steps for compiling an object_creation_expression of the form new . These steps either result in a compile-time error, or determine an instance constructor on that can be invoked at run-time.\n• If does not have public accessibility, then a compile-time error occurs.\n• For each named_argument in :\n• Let be the identifier of the named_argument .\n• shall identify a non-static read-write public field or property on . If has no such field or property, then a compile-time error occurs.\n• If any of the values within positional_argument_list or one of the values within named_argument_list is of type and the value is not well-formed as defined by the Unicode Standard, it is implementation-defined whether the value compiled is equal to the run-time value retrieved (§22.4.3). Note: As an example, a string which contains a high surrogate UTF-16 code unit which isn’t immediately followed by a low surrogate code unit is not well-formed. end note\n• Store the following information (for run-time instantiation of the attribute) in the assembly output by the compiler as a result of compiling the program containing the attribute: the attribute class , the instance constructor on , the positional_argument_list , the named_argument_list , and the associated program entity , with the values resolved completely at compile-time.\n\nUsing the terms defined in §22.4.2, the attribute instance represented by , , , and , and associated with can be retrieved at run-time from the assembly using the following steps:\n• Follow the run-time processing steps for executing an object_creation_expression of the form , using the instance constructor and values as determined at compile-time. These steps either result in an exception, or produce an instance of .\n• For each named_argument in , in order:\n• Let be the identifier of the named_argument . If does not identify a non-static public read-write field or property on , then an exception is thrown.\n• Let be the result of evaluating the attribute_argument_expression of .\n• If identifies a field on , then set this field to .\n• Otherwise, Name identifies a property on . Set this property to Value.\n• The result is , an instance of the attribute class that has been initialized with the positional_argument_list and the named_argument_list .\n\nA number of attributes affect the language in some way. These attributes include:\n• (§22.5.2), which is used to describe the ways in which an attribute class can be used.\n• (§22.5.3), is a multi-use attribute class which is used to define conditional methods and conditional attribute classes. This attribute indicates a condition by testing a conditional compilation symbol.\n• (§22.5.4), which is used to mark a member as obsolete.\n• (§22.5.5), which is used to establish a task builder for an async method.\n• (§22.5.6.2), (§22.5.6.3), and (§22.5.6.4), which are used to supply information about the calling context to optional parameters.\n\nThe Nullable static analysis attributes (§22.5.7) can improve the correctness of warnings generated for nullabilities and null states (§8.9.5).\n\nAn execution environment may provide additional implementation-defined attributes that affect the execution of a C# program.\n\nThe attribute is used to describe the manner in which the attribute class can be used.\n\nA class that is decorated with the attribute shall derive from , either directly or indirectly. Otherwise, a compile-time error occurs.\n\nThe attribute enables the definition of conditional methods and conditional attribute classes.\n\nA method decorated with the attribute is a conditional method. Each conditional method is thus associated with the conditional compilation symbols declared in its attributes.\n\nA call to a conditional method is included if one or more of its associated conditional compilation symbols is defined at the point of call, otherwise the call is omitted.\n\nA conditional method is subject to the following restrictions:\n• The conditional method shall be a method in a class_declaration or struct_declaration. A compile-time error occurs if the attribute is specified on a method in an interface declaration.\n• The conditional method shall have a return type of .\n• The conditional method shall not be marked with the modifier. A conditional method can be marked with the modifier, however. Overrides of such a method are implicitly conditional, and shall not be explicitly marked with a attribute.\n• The conditional method shall not be an implementation of an interface method. Otherwise, a compile-time error occurs.\n• The parameters of the conditional method shall not be output parameters.\n\nIn addition, a compile-time error occurs if a delegate is created from a conditional method.\n\nIt is important to understand that the inclusion or exclusion of a call to a conditional method is controlled by the conditional compilation symbols at the point of the call.\n\nThe use of conditional methods in an inheritance chain can be confusing. Calls made to a conditional method through , of the form , are subject to the normal conditional method call rules.\n\nAn attribute class (§22.2) decorated with one or more attributes is a conditional attribute class. A conditional attribute class is thus associated with the conditional compilation symbols declared in its attributes.\n\nAttribute specifications (§22.3) of a conditional attribute are included if one or more of its associated conditional compilation symbols is defined at the point of specification, otherwise the attribute specification is omitted.\n\nIt is important to note that the inclusion or exclusion of an attribute specification of a conditional attribute class is controlled by the conditional compilation symbols at the point of the specification.\n\nThe attribute is used to mark types and members of types that should no longer be used.\n\nIf a program uses a type or member that is decorated with the attribute, a compiler shall issue a warning or an error. Specifically, a compiler shall issue a warning if no error parameter is provided, or if the error parameter is provided and has the value . A compiler shall issue an error if the error parameter is specified and has the value .\n\nThis attribute is described in §15.15.1.\n\nFor purposes such as logging and reporting, it is sometimes useful for a function member to obtain certain compile-time information about the calling code. The caller-info attributes provide a way to pass such information transparently.\n\nWhen an optional parameter is annotated with one of the caller-info attributes, omitting the corresponding argument in a call does not necessarily cause the default parameter value to be substituted. Instead, if the specified information about the calling context is available, that information will be passed as the argument value.\n\nCaller-info attributes can occur on optional parameters anywhere, including in delegate declarations. However, the specific caller-info attributes have restrictions on the types of the parameters they can attribute, so that there will always be an implicit conversion from a substituted value to the parameter type.\n\nIt is an error to have the same caller-info attribute on a parameter of both the defining and implementing part of a partial method declaration. Only caller-info attributes in the defining part are applied, whereas caller-info attributes occurring only in the implementing part are ignored.\n\nCaller information does not affect overload resolution. As the attributed optional parameters are still omitted from the source code of the caller, overload resolution ignores those parameters in the same way it ignores other omitted optional parameters (§12.6.4).\n\nCaller information is only substituted when a function is explicitly invoked in source code. Implicit invocations such as implicit parent constructor calls do not have a source location and will not substitute caller information. Also, calls that are dynamically bound will not substitute caller information. When a caller-info attributed parameter is omitted in such cases, the specified default value of the parameter is used instead.\n\nOne exception is query expressions. These are considered syntactic expansions, and if the calls they expand to omit optional parameters with caller-info attributes, caller information will be substituted. The location used is the location of the query clause which the call was generated from.\n\nIf more than one caller-info attribute is specified on a given parameter, they are recognized in the following order: , , . Consider the following parameter declaration:\n\ntakes precedence, and the other two attributes are ignored. If were omitted, would take precedence, and would be ignored. The lexical ordering of these attributes is irrelevant.\n\nThe attribute is allowed on optional parameters when there is a standard implicit conversion (§10.4.2) from the constant value to the parameter’s type. This ensures that any non-negative line number up to that value can be passed without error.\n\nIf a function invocation from a location in source code omits an optional parameter with the , then a numeric literal representing that location’s line number is used as an argument to the invocation instead of the default parameter value.\n\nIf the invocation spans multiple lines, the line chosen is implementation-dependent.\n\nThe line number may be affected by directives (§6.5.8).\n\nThe attribute is allowed on optional parameters when there is a standard implicit conversion (§10.4.2) from to the parameter’s type.\n\nIf a function invocation from a location in source code omits an optional parameter with the , then a string literal representing that location’s file path is used as an argument to the invocation instead of the default parameter value.\n\nThe format of the file path is implementation-dependent.\n\nThe file path may be affected by directives (§6.5.8).\n\nThe attribute is allowed on optional parameters when there is a standard implicit conversion (§10.4.2) from to the parameter’s type.\n\nIf a function invocation from a location within the body of a function member or within an attribute applied to the function member itself or its return type, parameters or type parameters in source code omits an optional parameter with the , then a string literal representing the name of that member is used as an argument to the invocation instead of the default parameter value.\n\nFor invocations that occur within generic methods, only the method name itself is used, without the type parameter list.\n\nFor invocations that occur within explicit interface member implementations, only the method name itself is used, without the preceding interface qualification.\n\nFor invocations that occur within property or event accessors, the member name used is that of the property or event itself.\n\nFor invocations that occur within indexer accessors, the member name used is that supplied by an (§22.6) on the indexer member, if present, or the default name otherwise.\n\nFor invocations that occur within field or event initializers, the member name used is the name of the field or event being initialized.\n\nFor invocations that occur within declarations of instance constructors, static constructors, finalizers and operators the member name used is implementation-dependent.\n\nThe attributes in this section are used to provide additional information to support a compiler that provides nullability and null-state diagnostics (§8.9.5). A compiler isn’t required to perform any null-state diagnostics. The presence or absence of these attributes do not affect the language nor the behavior of a program. A compiler that doesn’t provide null-state diagnostics shall read and ignore the presence of these attributes. A compiler that provides null-state diagnostics shall use the meaning defined in this section for any of these attributes which it uses to inform its diagnostics.\n\nThe code-analysis attributes are declared in namespace .\n\nThe following sections in §22.5.7.1 are conditionally normative.\n\nSpecifies that a null value is allowed as an input even if the corresponding type disallows it.\n\nSpecifies that a null value is disallowed as an input even if the corresponding type allows it.\n\nSpecifies that a given method never returns.\n\nSpecifies that a given method never returns if the associated parameter has the specified value.\n\nSpecifies that a non-nullable return value may be null.\n\nSpecifies that a non-nullable argument may be when the method returns the specified value. This is similar to the attribute (§22.5.7.6), but includes a parameter for the specified return value.\n\nSpecifies that a nullable value will never be if the method returns (rather than throwing).\n\nSpecifies that a return value isn’t if the argument for the specified parameter isn’t .\n\nSpecifies that a nullable argument won’t be when the method returns the specified value.\n\nFor interoperation with other languages, an indexer may be implemented using indexed properties. If no attribute is present for an indexer, then the name is used by default. The attribute enables a developer to override this default and specify a different name."
    },
    {
        "link": "https://stackoverflow.com/questions/54774515/how-to-debug-into-net-framework-source-code",
        "document": "First of all, I tested it using Microsoft Visual Studio Enterprise 2017, Version 15.9.7 and via .NET Framework 4.7.2. Though, I think it should work on Community edition the same way.\n• None Go to Tools / Options / Debugging / General, and perform these settings:\n• check Enable .NET Framework source stepping (this will automatically disable \"Enable Just My Code\"; if not, do it manually)\n• uncheck Require source files to exactly match the original version\n• None Go to Tools / Options / Debugging / Symbols, and:\n• click Empty Symbol Cache button (to make sure you will get the correct symbols)\n• select Load all modules, unless excluded radio button at the bottom\n• None Download the source of the .NET framework version your project is targeting, from the https://referencesource.microsoft.com/download.html site.\n• None Unpack the downloaded archive (zip) file to a convenient path on your PC.\n• None Debug your application; set a breakpoint to the line of .NET code you wish to debug, and step to the desired code line with the debugger.\n\nNote: your application may start slower since it will download PDBs from the internet.\n• None Press Step Into (F11 by default). If your settings are correct, this will cause some delay (if your VS crashes (like mine did), Empty Symbol Cache again). Eventually it will ask for the sources of the given file, e.g. . Two things can happen here:\n• A) It asks for the source file (.cs) in a file dialog. Go to step 7.\n• B) It says not found, and there is a link that says \"Browse and find whatever.cs...\". Click that link.\n• None Select the corresponding .cs file on your disk (you can search for the file on the OS).\n\nNote: I had to restart VS several times until it \"did not crash\" while looking for sources, this is most likely a bug in VS.\n• If you did everything correctly, you will find yourself debugging the .NET source code.\n\nNote: Since VS saves the path you entered for the source files, you can stop debugging or restart VS; it will work next time, too. Besides, you do not have to manually select any more source files within the framework, because the VS will use the source folder you entered and will search in source files there."
    },
    {
        "link": "https://github.com/MicrosoftDocs/visualstudio-docs/blob/main/docs/debugger/project-settings-for-csharp-debug-configurations-dotnetcore.md",
        "document": "You can change C# project debug settings in the Debug tab and Build tab of the project property pages.\n\nTo open the property pages, select the project in Solution Explorer and then select the Properties icon, or right-click the project and select Properties.\n\nFor more information, see Debug and release configurations.\n\nStarting in Visual Studio 2022, choose Open debug launch profiles UI in the Debug tab to open the launch profiles UI and change debug settings.\n\nIn addition to the properties for .NET 5+, ASP.NET Core launch profiles include several additional properties for the different ASP.NET Core profiles. These settings provide a simple UI for the project's file. For more information on this file, see the Development and section in Use multiple environments in ASP.NET Core.\n\nThe settings provided in the launch profiles UI include the following.\n\nVisual Studio provides an IIS Express profile by default, and you can create additional profiles such as an IIS profile. These settings also correspond to settings in launchSettings.json. These two profile types provide several settings, such as the Hosting model.\n\nThe following table shows build settings that are useful for debugging. For a complete explanation of build settings, see Build Page, Project Designer.\n\nYou can choose the following options for debug symbols.\n• Specifies that no debugging information will be generated.\n• Produces a .PDB file, a platform-specific symbol file that provides other tools, especially debuggers, information about what is in the main executable file and how it was produced.\n• Produces a .PDB file, a non-platform-specific, portable symbol file that provides other tools, especially debuggers, information about what is in the main executable file and how it was produced. See Portable PDB for more information.\n• Embeds portable symbol information into the assembly. No external .PDB file is produced.\n\nFor more information, see /debug (C# Compiler Options)."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.debugger.break?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example demonstrates how to stop the debugger at the call to WriteLine.\n\nIf no debugger is attached, users are asked if they want to attach a debugger. If users say yes, the debugger is started. If a debugger is attached, the debugger is signaled with a user breakpoint event, and the debugger suspends execution of the process just as if a debugger breakpoint had been hit.\n\nStarting with .NET Framework 4, the runtime no longer exercises tight control of launching the debugger for the Break method, but instead reports an error to the Windows Error Reporting (WER) subsystem. WER provides many settings to customize the problem reporting experience, so a lot of factors will influence the way WER responds to an error such as operating system version, process, session, user, machine and domain. If you're having unexpected results when calling the Break method, check the WER settings on your machine. For more information on how to customize WER, see WER Settings. If you want to ensure the debugger is launched regardless of the WER settings, be sure to call the Launch method instead."
    },
    {
        "link": "https://stackoverflow.com/questions/53738788/what-are-sensible-use-cases-for-debugger-isattached-property",
        "document": "the .Net property Debugger.IsAttached can be used at runtime to detect if a debugger is attached or not. That means this property can be used for having a different behavior when the debugger is attached. I can easily come up with examples that show why not to use this property (because the program will be hard to debug) but I have a hard time to find an example in which it seems legitimate to use it.\n\nDo you have use-cases where Debugger.IsAttached is the sensible choice to use?"
    },
    {
        "link": "https://stackoverflow.com/questions/7459661/c-sharp-force-debug-mode-programmatically",
        "document": "I think you're misunderstanding what does. It functions like a hard-coded breakpoint.\n\nWhen your program hits , the Just-In-Time-Debugging window will show (assuming you have Visual Studio installed on the machine. At that point, your program is stopped - it doesn't keep running.\n\nIf you choose an instance of VS, it will be launched, and will be stopped on the line with , as if you hit a breakpoint there.\n\nSo there is really no reason for the while() loop. You could just call whenever you want to stop the program to look at something.\n\nBut the utility of is questionable. You can much more easily use breakpoints, and with breakpoints there is no danger of accidentally leaving it in the finished product."
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/debugger/navigating-through-code-with-the-debugger?view=vs-2022",
        "document": "Navigate through code by using the Visual Studio debugger\n\nThe Visual Studio debugger can help you navigate through code to inspect the state of an app and show its execution flow, which is also known as code stepping. You can use keyboard shortcuts, debug commands, breakpoints, and other features to quickly get to the code you want to examine. By getting more familiar with debugger navigation commands and shortcuts, you can find and resolve app problems faster and more easily. For a list of the most common keyboard shortcuts related to code navigation and debugging, see the Debug section in Keyboard shortcuts.\n\nSome navigation commands start your app and automatically attach the debugger. Your app pauses on a specific line of code based on the command you used to start navigation, and you enter break mode (that is, your app is paused in the debugger).\n\nIn break mode, app execution is suspended while functions, variables, and objects remain in memory. When the debugger is in break mode, you can navigate through your code. There are two very common ways to quickly enter break mode:\n• For example, in the code editor in Visual Studio, you can use the Run To Cursor command to start the app, with the debugger attached, and enter break mode. Then you can use step commands to navigate the code.\n\nCode stepping commands can be used to start your app, but are more commonly used after you enter break mode.\n\nSome navigation commands are mostly used while in break mode (that is, while you're paused in the debugger).\n• None Code stepping commands are most commonly used in break mode.\n• None Some commands like Run to click can only be used while in break mode.\n\nWhen you're in break mode, you can use various commands to navigate through your code. You can examine the values of variables to look for violations or bugs. For some project types, you can also make adjustments to the app when you're in break mode.\n\nMost debugger windows, like the Modules and Watch windows, are available only when the debugger is attached to your app. Some debugger features, like viewing variable values in the Locals window or evaluating expressions in the Watch window, are available only when the debugger is paused (that is, in break mode).\n\nCode stepping refers to executing your application code one statement at a time, with the debugger attached. The debugger step commands help you observe the effects of each statement and find out more about its execution flow.\n\nTo stop on each statement when you're debugging, use Debug > Step Into, or select F11.\n\nThe debugger steps through code statements, not physical lines. For example, an clause can be written on one line:\n\nBut when you step into this line, the debugger treats the condition as one step and the consequence as another. In the preceding example, the condition is true.\n\nOn a nested function call, Step Into steps into the most deeply nested function. For example, if you use Step Into on a call like , the debugger steps into the function .\n\nStep through code and skip some functions\n\nYou might not care about a function when you're debugging. Or you might know some code works, like well-tested library code. You can use the following commands to skip code when you're code stepping. The functions still run, but the debugger skips over them.\n\nYou might prefer to run directly to a specific location or function when you know exactly what code you want to inspect or if you know where you want to start debugging.\n• Setting a breakpoint is best if you think you might want to re-use the breakpoint.\n• Other methods are for convenience, and are similar to setting a temporary breakpoint.\n\nTo set a simple breakpoint in your code, select the far-left margin next to the line of code where you want to suspend execution. You can also select the line and then select F9, select Debug > Toggle Breakpoint, or right-click and select Breakpoint > Insert Breakpoint. The breakpoint appears as a red dot in the left margin next to the line of code. The debugger suspends execution just before the line runs.\n\nBreakpoints in Visual Studio provide a rich set of functionality, like conditional breakpoints and tracepoints. For details, see Using breakpoints.\n\nYou can set the debugger to run until it reaches a specified function. You can specify the function by name, or you can choose it from the call stack.\n\nTo specify a function breakpoint by name:\n• None In the New Function Breakpoint dialog, enter the name of the function and select its language:\n\nIf the function is overloaded or in more than one namespace, you can choose the one you want in the Breakpoints window:\n\nTo select a function breakpoint from the call stack:\n• None While debugging, open the Call Stack window by selecting Debug > Windows > Call Stack.\n• None In the Call Stack window, right-click a function and select Run To Cursor, or select Ctrl+F10.\n\nFor information about visually tracing the call stack, see Map methods on the call stack while debugging.\n\nTo run to the cursor location, in source code or the Call Stack window, select the line you want to break at, and then right-click and select Run To Cursor, or select Ctrl+F10. Selecting Run To Cursor is similar to setting a temporary breakpoint.\n\nWhile the debugger is paused, you can hover over a statement in source code or the Disassembly window and select the Run execution to here green arrow. Using Run to Click is similar to setting a temporary breakpoint.\n\nTo break into the next available line of code in a running app, select Debug > Break All, or select Ctrl+Alt+Break.\n\nBy default, the debugger tries to debug only your app code by enabling a setting called Just My Code. For details about how this feature works for various project types and languages, and how you can customize it, see Just My Code.\n\nTo look at framework code, third-party library code, or system calls while debugging, you can disable Just My Code. In Tools (or Debug) > Options > Debugging, clear the Enable Just My Code checkbox. When Just My Code is disabled, non-user code appears in the debugger windows, and the debugger can step into the non-user code.\n\nIf you've loaded debugging symbols for Microsoft system code and disabled Just My Code, you can step into a system call just as you can any other call.\n\nTo learn about loading Microsoft symbols, see Configure location of symbol files and loading options.\n• None While you're debugging, open the Modules window by selecting Debug > Windows > Modules or by pressing Ctrl+Alt+U.\n• None In the Modules window, you can tell which modules have symbols loaded in the Symbol Status column. Right-click the module that you want to load symbols for and then select Load Symbols.\n\nStep into properties and operators in managed code\n\nThe debugger steps over properties and operators in managed code by default. In most cases, this behavior provides a better debugging experience. To enable stepping into properties or operators, select Debug > Options. On the Debugging > General page, clear the Step over properties and operators (Managed only) checkbox.\n\nMove the pointer to change the execution flow\n\nYou can change the next statement that will run by moving the yellow execution pointer. You can use this feature while in break mode.\n\nThis is an advanced debugger feature. For more information, see Move the execution pointer.\n• First look at debugging"
    },
    {
        "link": "https://reddit.com/r/ProgrammerTIL/comments/9rbfli/c_til_you_can_significantly_speed_up_debugging_by",
        "document": "If you have some code you want to debug, but you have to run a lot of other code to get to that point, debugging can take a lot of time. Having the debugger attached causes code to run much more slowly. You can start without the debugger, but attaching manually at the right time is not always possible.\n\nInstead of running with the debugger attached at the start of your code execution you can use methods from the Debugger class in the System.Diagnostics namespace to launch it right when you need it. After adding the code below, start your code without the debugger attached. When the code is reached you will be prompted to attach the debugger right when you need it:\n\nThis is also really helpful if you only want to launch the debugger in certain environments/situations by using environment variables or compilations symbol without having to constantly change your code. For example, if you only want to to attach the debugger only when debug configuration is being used you can do the following:"
    }
]