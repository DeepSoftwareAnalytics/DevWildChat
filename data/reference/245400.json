[
    {
        "link": "https://medium.com/@lucky_rydar/guide-over-smart-pointers-in-c-46ed8b04448c",
        "document": "Welcome to this small guide about C++ smart pointers. Today, we’re diving into the world of these tools that make managing memory in your C++ programs a whole lot easier and much safer.\n\nIn this article, we’ll explore three types of smart pointers and share some practical tips on how to use them like a pro. So, whether you’re a C++ newbie or a seasoned coder, I think this article will be really useful for you.\n\nAs far you know C++ is well known for providing tools that helps you to make segmentation fault or memory leak in different ways. The root problem of such a runtime errors is using raw pointers and other stuff like forgetting to free memory or getting access to wrong piece of memory.\n\nGenerally, mostly all the problems with memory can be fixed by using smart pointers. The idea of them to control an ownership of pointer and automatic memory deallocation.\n\nStarting from 11 standard of C++ we have three types of pointers: , and . With the help of them you can(and should I think) solve 99% of your every day tasks.\n\nUnique pointer is a kind of smart pointers that implements simple mechanism of handling one raw pointer by one owner. The pointer inside cant be copied accidentally to another one. After stack being deallocated the pointer inside will be deleted also.\n\nIn C++ implementation of smart pointers they works absolutely the same way as raw pointers. Here is general example of how you can use smart pointers.\n\nAs you can see from the example above, unique pointer cant be copied, it is guaranteed by the compiler. Also, if you are not sure, it would be fine to check out if your has a valid address(not a nullptr) so you can access the data.\n\nThe ownership can be also taken using function release with the help of which you can get the pointer and std::uniques_ptr will not hold it. However, I would not suggest to use this function because it could be unsafe.\n\nSpoiler: After deeper look you will understand that this type of pointer works almost the same way as abstract garbage collector but allocated memory being freed right after the moment it is not needed.\n\nThe idea of shared pointer is to make it possible for all the owners(more than one) to point to the same data.\n\nImportant: the memory is deallocated only in case of last shared_ptr object will be deleted so anyone wants this data to continue existing.\n\nHere is a small example of how it works:\n\nIt also can be easily copied:\n\nAnd here is an example that shows how deallocating of memory happens. We can check it out using function use_count with the help of which we can know how many owners there are.\n\nLong story short, is same as but it does not own memory so it can be freed even if there is weak pointer that points to it. Here is how it can be used.\n\nSo, weak pointer does not own memory and it can be safely freed. That is pretty simple concept, but I am sure you have no idea why C++ needs it. I will explain it in the next paragraph.\n\nImagine you have two objects where each has shared pointer to another as a field. We used them for some time and they are needed to be deallocated. Object1 calls destructor and tries to deallocate first its field of shared pointer of Object2, then destructor of Object2 is called and it deallocates first its field of shared pointer of Object1. Oh no, that’s a trap!\n\nHere is an example of such a situation:\n\nDestructors will never be called so the memory will not be deallocated.\n\nTo avoid such a situation you must use class the main function of which is not to pretend on data if it is gonna be allocated.\n\nHere is an example where I use weak pointer to fix the issue:\n\nNow destructors are called and all the memore is freed:\n\nIn summary, C++ smart pointers are handy tools that help manage memory in a safer and more efficient way. By using , , and , programmers can make memory handling easier. Remember, can help prevent memory issues when objects depend on each other, ensuring that your C++ programs run smoothly and reliably.\n\nHope you liked this article and it was useful for you. If so, then please clap so I will know about that."
    },
    {
        "link": "https://stackoverflow.com/questions/40772913/use-unique-ptr-and-appropriate-container-to-do-memory-management",
        "document": "First of all, if you are allocating an array you need to use the specialization or you won't get a on memory release but a simple .\n\nis a good choice unless you have any explicit reason to use something different. For example, if you are going to move many elements inside the container then a could perform better (less operations to shift things around).\n\nRegarding how to manage memory, it depends mainly on the pattern of utilization. If is mainly responsible for everything (which in your specification it is, since expresses ownership), it means that it will be the only one who can release memory. Which could be done simply by calling .\n\nMind that storing raw pointers of managed objects inside other collections leads to dangling pointers if memory is released, for example:\n\nThis could be a problem or not, if is released by last then there are no problems, otherwise you could store const references to so that at least you'd be able to check if memory is still valid, e.g.:"
    },
    {
        "link": "https://linkedin.com/pulse/memory-management-using-smart-pointers-c-part-1-pratik-parvati",
        "document": "One of the major strengths and weaknesses of both C and C++ are pointers. C++ has many benefits of pointers but also several pitfalls if memory management is not performed correctly. Pointers require explicit management of the resources to which they refer. For example, a pointer that holds the address of dynamically allocated memory retrieved using new requires the programmer to release that memory using delete; failing to do so results in dangling pointers or memory leaks which are difficult to find.\n\nA smart pointer provides a mechanism that automates the explicit management of a resource. A smart pointer, as opposed to a raw pointer, can manage the memory of the resource to which it points. It is a proxy for a raw pointer to the resource, and it looks and feels like a raw pointer. It supports the dereferencing (*) and member by pointer ( >) operators. A smart pointer resides on the stack; when it goes out of scope, its destructor deallocates the dynamic memory to which it points to.\n\nSmart pointers implement the object-oriented language idiom Resource Acquisition Is Initialization (RAII). This idiom states that the resource is acquired at initialization time, i.e when the memory for the pointer is created.\n\nThis article is published on my website https://pratikparvati.com/html/blogview.html?id=-Mce2yaFyo-5IU1F8Rq_&lan=cpp, in the DEV community https://dev.to/pratikparvati/memory-management-using-smart-pointers-in-c-part-1-4j2k and on GitHub page https://github.com/pratikparvati/Smart_pointers_in_cpp\n\nWhy should we use Smart Pointers?\n\nLet’s look at this very simple piece of code that causes a memory leak.\n\nWhen I use Valgrind to check the binary for memory leaks; I got the following results.\n\nYou can clearly see that we leaked 80 bytes (4 bytes x 20) of memory because we did not run delete on ptr and it is quit difficult to manually keep track of all allocations and delete them at the right time; especially when we have sufficiently large C++ project where objects are copied, moved and passed everywhere in the code.\n\nLet's look at another scenario of memory leak using raw pointers\n\nAssuming the function someFunction() is getting called infinite times and the obj validation fails every time. This leads to the situations when programmers keep allocating new memory and do not lose any pointers to it, but keep pointers to objects that the program is not going to use anymore (dangling pointer). This is not formally a memory leak but leads to the same situation: a program running out of memory\n\nEven if we use new and delete pairs correctly we may encounter a scenario of memory leak. Lets look at the below example.\n\nIf an exception is thrown, the obj object is never deleted. No matter how much we try, it is very difficult to free all dynamically allocated memory. Even if we can do that, it is often not safe from exceptions.\n\nCreating temporary arrays of dynamic size is often necessary. After they are not required anymore, it is important to free the allocated memory. The C++ requires special delete operator with [] brackets, which is forgotten very easily. The delete[] operator call destructors of all objects from an array along with deleting the memory allocated for an array. It is also incorrect to use the delete operator without [] brackets for an array, which results in undefined behaviour.\n\nWe should avoid using heap memory as much as possible\n\nAnd for these reasons, modern C++ avoids using heap memory as much as possible by declaring objects on the stack; when a resource-owning stack object goes out of scope, its destructor is automatically invoked.\n\nThe following example shows a simple object e. It is declared on the stack at function scope, and is destroyed at the end of the function block. The object e owns no resources (such as heap-allocated memory) and hence no special code is needed in the Entity destructor.\n\nSince C++11, there is a better way to write the previous example: by using a smart pointer from the standard library. The smart pointer manages the allocation and deletion of memory that it owns. The use of a smart pointer eliminates the need for an explicit destructor in the Entity class.\n\nThere are 3 types of smart pointers:\n• Destroys the object when goes out of scope\n• Destroys the object when last reference is released\n\nWith a unique_ptr, you can point to an allocated object, and when the unique_ptr goes out of scope, the pointed-to object gets deleted,and this happens regardless of how we leave the function, either by a return or an exception being thrown somewhere. For example:\n\nSince the dereferencing (*) and member by pointer (->) operators are overloaded in unique_ptr class, we can use unique_ptr as\n\nWe can also check the null-ness of the pointer similar to raw pointers as\n\nFreeing the memory sets the unique_ptr to nullptr\n\nTo be the only owner of a resource means that only the respective unique_ptr pointers are responsible for deleting the object when it is no longer needed (i.e, responsible about the lifetime of the object). This implies that nobody else can use the object after its lifetime ended and for the same reason the std::unique_ptr has practically no overhead and has very predictable behavior.\n\nSince unique_ptr maintains sole ownership of the resource, one can not make a copy of it and for the type safety reasons the copy constructor and copy assignment operators are deleted. Instead we can transfer/move ownership of the pointer from the one pointer object to another using move semantics.\n\nA unique_ptr has to be moved while passing it to a function that takes a unique_ptr by value.\n\nWe can fill a Standard Container with unique_ptrs that own objects, and the ownership then effectively resides in the container.\n• You must fill the container by supplying rvalue unique_ptrs, so the ownership transfers into the unique_ptr in the container\n• If you erase an item in the container, you are destroying the unique_ptr.\n• If you transfer ownership out of container items, the empty unique_ptrs stay in the container.\n\nThe complete type of std::unique_ptr has a second template parameter, its deleter that has a default type std::default_delete<T>\n\nA unique_ptr can be declared and initialized with a user-provided custom deleter that is called to destroy the object resource.\n\nCustomDeleter is passed as an argument to constructor and stored as a member of a unique_ptr object. A deleter can be a function object, a function pointer, or a Lambda. The above example uses function object as second parameter.\n\nVery simple example for customer deleter using function pointer.\n\nThe most common use of unique_ptr is as a pretty fool-proof way of making sure an object allocated in function gets deleted. However, there are situations in which ownership of objects needs to be transferred around but always remains in one place at a time; unique_ptr gives you way to represent this concept directly.\n\nIn the next article, I will write about std::shared_ptr and std::weak_ptr in detail; also, I will talk about these smart pointers in terms of performance."
    },
    {
        "link": "https://fintechpython.pages.oit.duke.edu/jupyternotebooks/3-CPlusCPlus/20-SmartPointers/20-SmartPointers.html",
        "document": "Managing dynamic memory in C++ can be error-prone, leading to issues like memory leaks, dangling pointers, and undefined behavior. Smart pointers, introduced in C++11 and enhanced in later standards, provide automatic and safer memory management by encapsulating raw pointers with ownership semantics.\n\nSmart pointers are template classes that provide automatic memory management for dynamically allocated objects. They ensure that resources are properly released when they are no longer needed, thereby reducing memory leaks and other related issues.\n• None Automatic Resource Management: Automatically deallocate memory when the smart pointer goes out of scope.\n• None Exception Safety: Ensure resources are released even when exceptions are thrown.\n• None Ownership Semantics: Clearly define ownership and sharing of resources.\n\nC++ provides several smart pointer types, each with distinct ownership and lifetime semantics: represents exclusive ownership of a dynamically allocated object. Only one can own a particular resource at a time.\n• None Lightweight with no overhead beyond the raw pointer.\n• None Suitable for implementing RAII (Resource Acquisition Is Initialization) for single ownership. As you step through the code, notice that a Resource object is created with a pointer assigned to . The code then uses that resource by calling . Ownership is then moved to another unique pointer and the original unique pointer no longer has a valid reference to the object. The object is deallocated when the owner unique pointer ( ) goes out of scope.\n\nallows multiple pointers to share ownership of a single resource. It maintains a reference count to manage the resource’s lifetime, destroying it when the last is destroyed or reset.\n• None Suitable for scenarios where multiple parts of a program need to share access to a resource. // ptr2 goes out of scope is a non-owning weak reference to a . It does not affect the reference count, thereby preventing circular dependencies. To access the managed object, must be converted to using the method.\n• None Does not own the resource.\n• None Prevents reference cycles that can lead to memory leaks.\n• None Can check if the resource still exists before accessing. was the first smart pointer introduced in C++. The type was deprecated in C++11 and removed in C++17 due to its flawed copy semantics, which can lead to unexpected behavior.\n• \n• None Issue: Two instances referencing each other create a cycle, preventing the reference count from reaching zero.\n• None Solution: Use to break the cycle. // Neither A nor B will be destroyed\n• None Dangling : Accessing the managed object after it has been destroyed can lead to undefined behavior. Solution: Always check if the can be locked before using it. // sharedPtr goes out of scope\n• \n• None Issue: Managing the same resource with both smart and raw pointers can lead to double deletion or memory leaks.\n• None Solution: Ensure that ownership is clearly defined and avoid sharing ownership between smart and raw pointers.\n\nSmart pointers are essential tools in modern C++ for managing dynamic memory safely and efficiently. By understanding the different types of smart pointers ( , , and ), their appropriate use cases, and best practices, you can write more robust and maintainable C++ code. Always prefer smart pointers over raw pointers for dynamic memory management to leverage their automatic resource management capabilities and reduce the risk of memory-related bugs."
    },
    {
        "link": "https://genbattle.bitbucket.io/blog/2016/02/06/Modern-C-Memory-Management-With-unique-ptr",
        "document": "This post is going to be a general background article on and how/why you should use it (if you are not already). In my current line of work I still deal with a large C++03 codebase, but with efforts ongoing to pull C++11 into the application I have spent a great deal of time thinking about how we can make the most out of C++11. One of the biggest wins is smart pointers and manual memory management, which are usable in C++03 with boost, but are so much more powerful in C++11 thanks to move semantics. I will focus on in this post as a start, but that doesn’t mean you shouldn’t also use the other smart pointer types included in C++11, and , when appropriate.\n\nThe introduced with C++11 (based on boost::scoped_ptr) is conceptually very simple. It wraps a raw pointer to a heap-allocated object with RAII semantics, destroying the associated object with the (i.e. at the end of whatever scope it is declared in). Because object destruction is triggered by RAII, there is no runtime or memory overhead for compared to a raw pointer. There are 3 ways to bind an object instance to a :\n• With (the return value of which can be move-assigned).\n• By using the member function.\n\nThere is only one way to destroy the object associated with the early, before the itself is destroyed. [1] Destroying the contained object early (before the itself is destroyed) can be triggered by calling the member function, which can also optionally take another raw pointer that the should subsequently take ownership of. However, before taking ownership of the new pointer it will always ensure the previous object is deleted first. If no new pointer is passed to , the will hold after the current object is deleted. The same logic applies to assignments; a can be move-assigned an object from another , or assigned . In both cases any object already held by the will be deleted before accepting the new value.\n\nUsing smart pointers is semantically the same as with raw pointers. The and operators have both been overloaded to provide familiar mechanics for accessing the underlying object:\n\nIn fact modern smart pointers in C++ go one further by defining an implicit conversion; so the , , , or whatever null-pointer constant your organization has chosen, can be excluded.\n\nThe time/space within the program between the creation and deletion of an object is the object’s lifetime: the part of the program for which the object is valid. With smart pointers, this is dictated by the owning smart pointer(s) controlling the object’s lifetime.\n\nConsider the following C++03-ish example:\n\nWith C++11 and this becomes:\n\nOr better yet, using from C++14:\n\nThis concept can be extended with class scopes to yield a wider range of object lifetimes we can express using . For example, the traditional PIMPL pattern (simplified for this example):\n\nWith modern C++ this can be refactored to:\n\nNote we don’t even need to define a destructor anymore, because our object is automatically destroyed when the Outer object is destroyed.\n\nWhy Smart Pointers Instead Of Manual Memory Management?\n\nI have had people ask this question when I have suggested using smart pointers instead of traditional manual memory management (using ), because their existing code works perfectly fine and causes no leaks. The most obvious benefit of using smart pointers is avoiding memory leaks ( reference cycles being an exception). But how does using smart pointers avoid leaks?\n\nWhen manual memory management is done correctly it does indeed work, but it becomes more brittle over time as code is refactored and extended. As a simplified example, say we had some code like this hiding somewhere in our application:\n\nThen, while adding a new feature, someone modifies the code so there are multiple places where a pointer is initialized with an instance of different types (using runtime polymorphism). In reality a mistake like this is much less obvious than in this example. This example intentionally shows very poor design to make the flaw more obvious.\n\nWhoops, we may have just caused a memory leak: if both conditions are the first object assigned to is never deleted. We could fix this up by calling to dispose of the first object before we create the second if the pointer is not zero.\n\nThis sort of breakage can be very common when modifying code that uses traditional manual memory management techniques comprised of calls scattered throughout code. This error could have just as well been a double free due to over-application of . It could have also been a use after free error where the pointer is not reset to after deletion, and our program continues to use it unaware until suddenly Cthulhu starts wreaking havoc on our application. The more resilient modern technique to eliminate all of these simple errors is to apply smart pointers in these scenarios instead wherever possible. For example, if we rewrite the above original example using :\n\nWith the same naive refactoring applied this would become:\n\nAnd it Just Works™. No pitfalls to be seen here; the API of smart pointers does not allow an already held pointer to be overwritten without first triggering a release of the object associated with that pointer. It’s extremely difficult to screw up the usage of in these types of scenarios.\n\nSo with the advent of smart pointers in modern C++ are we supposed to completely throw away raw pointers and references? Of course not!\n\nRaw pointers and references still serve a purpose for referencing/accessing objects without affecting their lifetime. The usual rules apply: for raw pointers and references to be valid, the lifetime of the raw pointers/references must be a subset of the lifetime of the object being referred to. It is easier to align the lifetimes of both smart and raw pointers if RAII and scope are used to manage both.\n\nConsider the following example:\n\nThe lifetimes in this example could be represented by the following Venn diagram:\n\nWhereas if we got the lifetimes wrong and did something like this:\n\nThe associated Venn diagram of the lifetimes would look more like this:\n\n\n\nThis would result in a use-after-free error when we try to access after the end of Scope 1, and possibly an application crash.\n\nThere are a multitude of safety and maintainability advantages when using smart pointers instead of traditional manual memory management with direct calls to . Using smart pointers won’t provide any immediate gratification over working code, but in the long term they make code much more resilient in the face of maintenance, refactoring and extension.\n\nWith the addition of , and move semantics from C++11 there should be few real scenarios which still require manual calls. Hopefully as C++ continues to develop and advance this will be ever more true. is still useful to have in your C++ development toolbox, but it should be a tool of last resort.\n\nStay tuned for a follow-up post on and .\n\nUpdate:\n\n[1] Thanks to /u/immutablestate on reddit for pointing out that assignment operations can also trigger an early release of an object held by a .\n\nThanks to /u/corysama and /u/malaprop0s for other corrections."
    },
    {
        "link": "https://stackoverflow.com/questions/1591361/understanding-typedefs-for-function-pointers-in-c",
        "document": "Consider the function from the C standard:\n\nPerfectly obscurely obvious - it's a function that takes two arguments, an integer and a pointer to a function that takes an integer as an argument and returns nothing, and it ( ) returns a pointer to a function that takes an integer as an argument and returns nothing.\n\nthen you can instead declare as:\n\nThis means the same thing, but is usually regarded as somewhat easier to read. It is clearer that the function takes an and a and returns a .\n\nIt takes a bit of getting used to, though. The one thing you can't do, though is write a signal handler function using the in the function definition.\n\nI'm still of the old-school that prefers to invoke a function pointer as:\n\nI can see why that works - I just prefer to know that I need to look for where the variable is initialized rather than for a function called .\n\nLet's try again. The first of these is lifted straight from the C standard - I retyped it, and checked that I had the parentheses right (not until I corrected it - it is a tough cookie to remember).\n\nFirst of all, remember that introduces an alias for a type. So, the alias is , and its type is:\n\nThe 'returns nothing' part is spelled ; the argument that is an integer is (I trust) self-explanatory. The following notation is simply (or not) how C spells pointer to function taking arguments as specified and returning the given type:\n\nAfter creating the signal handler type, I can use it to declare variables and so on. For example:\n\nPlease note How to avoid using in a signal handler?\n\nSo, what have we done here - apart from omit 4 standard headers that would be needed to make the code compile cleanly?\n\nThe first two functions are functions that take a single integer and return nothing. One of them actually doesn't return at all thanks to the but the other does return after printing a message. Be aware that the C standard does not permit you to do very much inside a signal handler; POSIX is a bit more generous in what is allowed, but officially does not sanction calling . I also print out the signal number that was received. In the function, the value will always be as that is the only signal that it is a handler for, but might get or as the signal number because the same function is used for both.\n\nThen I create an array of structures, where each element identifies a signal number and the handler to be installed for that signal. I've chosen to worry about 3 signals; I'd often worry about , and too and about whether they are defined ( conditional compilation), but that just complicates things. I'd also probably use POSIX instead of , but that is another issue; let's stick with what we started with.\n\nThe function iterates over the list of handlers to be installed. For each handler, it first calls to find out whether the process is currently ignoring the signal, and while doing so, installs as the handler, which ensures that the signal stays ignored. If the signal was not previously being ignored, it then calls again, this time to install the preferred signal handler. (The other value is presumably , the default signal handler for the signal.) Because the first call to 'signal()' set the handler to and returns the previous error handler, the value of after the statement must be - hence the assertion. (Well, it could be if something went dramatically wrong - but then I'd learn about that from the assert firing.)\n\nThe program then does its stuff and exits normally.\n\nNote that the name of a function can be regarded as a pointer to a function of the appropriate type. When you do not apply the function-call parentheses - as in the initializers, for example - the function name becomes a function pointer. This is also why it is reasonable to invoke functions via the notation; when you see , you can consider that is a pointer to the function and therefore is an invocation of a function via a function pointer.\n\nSo, thus far, I've shown that a variable is relatively straight-forward to use, as long as you have some of the right type of value to assign to it - which is what the two signal handler functions provide.\n\nNow we get back to the question - how do the two declarations for relate to each other.\n\nIf we changed the function name and the type like this:\n\nyou would have no problem interpreting this as a function that takes an and a as arguments and returns a value (would you? maybe you'd better not 'fess up if that is problematic - but maybe you should be cautious about asking questions as hard as this one if it is a problem).\n\nNow, instead of being a , the function takes a as its second argument, and it returns one as its result.\n\nThe mechanics by which that can also be treated as:\n\nare tricky to explain - so I'll probably screw it up. This time I've given the parameters names - though the names aren't critical.\n\nIn general, in C, the declaration mechanism is such that if you write:\n\nthen when you write it represents a value of the given . For example:\n\nIn the standard, is treated as a storage class in the grammar, rather like and are storage classes.\n\nmeans that when you see a variable of type (say alarm_handler) invoked as:\n\nthe result has - there is no result. And is an invocation of with argument .\n\nSo, if we declared:\n\nrepresents a void value. And therefore:\n\nis equivalent. Now, is more complex because it not only returns a , it also accepts both an int and a as arguments:\n\nIf that still confuses you, I'm not sure how to help - it is still at some levels mysterious to me, but I've grown used to how it works and can therefore tell you that if you stick with it for another 25 years or so, it will become second nature to you (and maybe even a bit quicker if you are clever)."
    },
    {
        "link": "https://geeksforgeeks.org/typedef-in-cpp",
        "document": "typedef keyword in C++ is used for aliasing existing data types, user-defined data types, and pointers to a more meaningful name. Typedefs allow you to give descriptive names to standard data types, which can also help you self-document your code. Mostly typedefs are used for aliasing, only if the predefined name is too long or complex to write again and again. The unnecessary use of typedef is generally not a good practice.\n\nBelow is the C++ Program to implement typedef\n\nApplications of typedef in C++\n• typedef in C++ can be used for aliasing predefined data types with long names.\n• It can be used with STL data structures like Vectors, Strings, Maps, etc.\n• typedef can be used with arrays as well.\n• We can use typedef with normal pointers as well as function pointers.\n\nTypedef can be used for aliasing predefined data types like int, char, float, and their derivatives like long, short, signed, and unsigned. The new alias can then be used for making new variables of respective types.\n\ntypedef can also be used with STL Data Structures, like Vectors, Strings, Maps, etc. If we are one of those, who do not want to import the entire std namespace in our code, then we need to write std::vector, std::string, etc, again and again. Thus using typedef, in this case, can be a quick way to prevent this and keep our code clean and readable.\n\ntypedef can be used with arrays for making newer arrays (just like using them with STL data structures). We can easily make new arrays or make arrays of arrays using typedef with arrays, while keeping our code readable, seamlessly.\n\nAfter this <alias_name> can now be used for creating arrays of type- <data_type> and size <size>.\n\nTypedef can be used with pointers as well. For faster creation of pointers, and keeping the code readable as well. We can use them with both data pointers as well as function pointers.\n\nBelow is the syntax, example, and source code for using typedef with data pointers\n\nBelow is the program to use typedef with data pointers.\n\nBelow is the syntax, example, and code to display the usage of typedef with function pointers.\n\nHere, fun ptr can now be used to create more function pointers. This will be more clear in the code below.\n\nHere, “func_ptr1” is a normal function pointer, while “func_ptr2” is a typedef function pointer and it can be used to create more function pointers taking 2 integers as arguments and with return type “int”."
    },
    {
        "link": "https://isocpp.org/wiki/faq/pointers-to-members",
        "document": "Is the type of “pointer-to-member-function” different from “pointer-to-function”?\n\nConsider the following function:\n\nThe type of this function is different depending on whether it is an ordinary function or a non- member function of some class:\n• Its type is “ ” if an ordinary function\n• Its type is “ ” if a non- member function of\n\nNote: if it’s a member function of , its type is the same as if it were an ordinary function: “ ”.\n\nHow do I pass a pointer-to-member-function to a signal handler, X event callback, system call that starts a thread/task, etc?\n\nBecause a member function is meaningless without an object to invoke it on, you can’t do this directly (if The X Window System was rewritten in C++, it would probably pass references to objects around, not just pointers to functions; naturally the objects would embody the required function and probably a whole lot more).\n\nAs a patch for existing software, use a top-level (non-member) function as a wrapper which takes an object obtained through some other technique. Depending on the routine you’re calling, this “other technique” might be trivial or might require a little work on your part. The system call that starts a thread, for example, might require you to pass a function pointer along with a , so you can pass the object pointer in the . Many real-time operating systems do something similar for the function that starts a new task. Worst case you could store the object pointer in a global variable; this might be required for Unix signal handlers (but globals are, in general, undesired). In any case, the top-level function would call the desired member function on the object.\n\nHere’s an example of the worst case (using a global). Suppose you want to call on interrupt:\n\nNote: member functions do not require an actual object to be invoked, so pointers-to- -member-functions are usually type-compatible with regular pointers-to-functions. However, although it probably works on most compilers, it actually would have to be an non-member function to be correct, since “C linkage” doesn’t only cover things like name mangling, but also calling conventions, which might be different between C and C++.\n\nWhy do I keep getting compile errors (type mismatch) when I try to use a member function as an interrupt service routine?\n\nThis is a special case of the previous two questions, therefore read the previous two answers first.\n\nNon- member functions have a hidden parameter that corresponds to the pointer. The pointer points to the instance data for the object. The interrupt hardware/firmware in the system is not capable of providing the pointer argument. You must use “normal” functions (non class members) or member functions as interrupt service routines.\n\nOne possible solution is to use a member as the interrupt service routine and have that function look somewhere to find the instance/member pair that should be called on interrupt. Thus the effect is that a member function is invoked on an interrupt, but for technical reasons you need to call an intermediate function first.\n\nWhy am I having trouble taking the address of a C++ function?\n\nShort answer: if you’re trying to store it into (or pass it as) a pointer-to-function, then that’s the problem — this is a corollary to the previous FAQ.\n\nLong answer: In C++, member functions have an implicit parameter which points to the object (the pointer inside the member function). Normal C functions can be thought of as having a different calling convention from member functions, so the types of their pointers (pointer-to-member-function vs pointer-to-function) are different and incompatible. C++ introduces a new type of pointer, called a pointer-to-member, which can be invoked only by providing an object.\n\nNOTE: do not attempt to “cast” a pointer-to-member-function into a pointer-to-function; the result is undefined and probably disastrous. E.g., a pointer-to-member-function is not required to contain the machine address of the appropriate function. As was said in the last example, if you have a pointer to a regular C function, use either a top-level (non-member) function, or a (class) member function.\n\nHow can I avoid syntax errors when creating pointers to members?\n\nYea, right, I know: you are different. You are smart. You can do this stuff without a . Sigh. I have received many emails from people who, like you, refused to take the simple advice of this FAQ. They wasted hours and hours of their time, when 10 seconds worth of s would have simplified their lives. Plus, face it, you are not writing code that only you can read; you are hopefully writing your code that others will also be able to read — when they’re tired — when they have their own deadlines and their own challenges. So why intentionally make life harder on yourself and on others? Be smart: use a .\n\nThat’s it! is the type name, and a pointer of that type points to any member of that takes , such as ’s , , and .\n\nAnd it’s also trivial to declare functions that receive member-function pointers:\n\nAnd it’s also trivial to declare functions that return member-function pointers:\n\nSo please, use a . Either that or do not send me email about the problems you have with your member-function pointers!\n\nHow can I avoid syntax errors when calling a member function using a pointer-to-member-function?\n\nIf you have access to a compiler and standard library that implements the appropriate parts of the upcoming C++17 standard, use . Otherwise, use a macro.\n\nI get way too many emails from confused people who refused to take this advice. It’s so simple. I know, you don’t need or a macro, and the expert you talked to can do it without either of them, but please don’t let your ego get in the way of what’s important: money. Other programmers will need to read / maintain your code. Yes, I know: you are smarter than everyone else; fine. And you are awesome; fine. But don’t add unnecessary complexity to your code.\n\nUsing is trivial. Note: is a for a pointer-to-member type:\n\nIf you can’t use , reduce maintenance cost by, paradoxically, using a macro in this particular case.\n\nUsing the macro is also trivial. Note: is a for a pointer-to-member type:\n\nThe reason or this macro is a good idea is because member function invocations are often a lot more complex than the simple example just given. The difference in readability and writability is significant. has had to endure hundreds and hundreds of postings from confused programmers who couldn’t quite get the syntax right. Almost all these errors would have vanished had they used or the above macro.\n\nNote: macros are evil in 4 different ways: evil#1, evil#2, evil#3, and evil#4. But they’re still useful sometimes. But you should still feel a vague sense of shame after using them.\n\nHow do I create and use an array of pointer-to-member-function?\n\nUse both the and or the macro described earlier, and you’re 90% done.\n\nStep 2: create a macro if you don’t have :\n\nNow your array of pointers-to-member-functions is straightforward:\n\nAnd your usage of one of the member function pointers is also straightforward:\n\nor if you don’t have ,\n\nNote: macros are evil in 4 different ways: evil#1, evil#2, evil#3, and evil#4. But they’re still useful sometimes. Feel ashamed, feel guilty, but when an evil construct like a macro improves your software, use it.\n\nHow do I declare a pointer-to-member-function that points to a member function?\n\nShort answer: add a to the right of the when you use a to declare the member-function-pointer type.\n\nFor example, suppose you want a pointer-to-member-function that points at , or :\n\nThen when you use a to declare the member-function-pointer type, it should look like this:\n\nThen you can declare/pass/return member-function pointers just like normal:\n\nWhat is the difference between the and operators?\n\nYou won’t need to understand this if you use or a macro for member-function-pointer calls. Oh yea, please use or a macro in this case. And did I mention that you should use or a macro in this case??!?\n\nBut if you really want to avoid or the macro, sigh, groan, okay, here it is: use when the left-hand argument is a reference to an object, and when it is a pointer to an object.\n\nBUT please consider using a or macro instead:\n\nAs discussed earlier, real-world invocations are often much more complicated than the simple ones here, so using a or macro will typically improve your code’s writability and readability.\n\nTechnical details: pointers to member functions and pointers to data are not necessarily represented in the same way. A pointer to a member function might be a data structure rather than a single pointer. Think about it: if it’s pointing at a virtual function, it might not actually be pointing at a statically resolvable pile of code, so it might not even be a normal address — it might be a different data structure of some sort.\n\nPlease do not email me if the above seems to work on your particular version of your particular compiler on your particular operating system. I don’t care. It’s illegal, period.\n\nTechnical details: pointers are pointers to data, and function pointers point to functions. The language does not require functions and data to be in the same address space, so, by way of example and not limitation, on architectures that have them in different address spaces, the two different pointer types will not be comparable.\n\nPlease do not email me if the above seems to work on your particular version of your particular compiler on your particular operating system. I don’t care. It’s illegal, period.\n\nI need something like function-pointers, but with more flexibility and/or thread-safety; is there another way?\n\nWhat the heck is a functionoid, and why would I use one?\n\nFunctionoids are functions on steroids. Functionoids are strictly more powerful than functions, and that extra power solves some (not all) of the challenges typically faced when you use function-pointers.\n\nLet’s work an example showing a traditional use of function-pointers, then we’ll translate that example into functionoids. The traditional function-pointer idea is to have a bunch of compatible functions:\n\nThen you access those by function-pointers:\n\nSometimes people create an array of these function-pointers:\n\nIn which case they call the function by accessing the array:\n\nWith functionoids, you first create a base class with a pure-virtual method:\n\nThen instead of three functions, you create three derived classes:\n\nThen instead of passing a function-pointer, you pass a . I’ll create a called merely to make the rest of the code similar to the old-fashioned approach:\n\nYou can create an array of them in almost the same way:\n\nThis gives us the first hint about where functionoids are strictly more powerful than function-pointers: the fact that the functionoid approach has arguments you can pass to the ctors (shown above as …ctor-args…) whereas the function-pointers version does not. Think of a functionoid object as a freeze-dried function-call (emphasis on the word call). Unlike a pointer to a function, a functionoid is (conceptually) a pointer to a partially called function. Imagine for the moment a technology that lets you pass some-but-not-all arguments to a function, then lets you freeze-dry that (partially completed) call. Pretend that technology gives you back some sort of magic pointer to that freeze-dried partially-completed function-call. Then later you pass the remaining args using that pointer, and the system magically takes your original args (that were freeze-dried), combines them with any local variables that the function calculated prior to being freeze-dried, combines all that with the newly passed args, and continues the function’s execution where it left off when it was freeze-dried. That might sound like science fiction, but it’s conceptually what functionoids let you do. Plus they let you repeatedly “complete” that freeze-dried function-call with various different “remaining parameters,” as often as you like. Plus they allow (not require) you to change the freeze-dried state when it gets called, meaning functionoids can remember information from one call to the next.\n\nLet’s get our feet back on the ground and we’ll work a couple of examples to explain what all that mumbo jumbo really means.\n\nSuppose the original functions (in the old-fashioned function-pointer style) took slightly different parameters.\n\nWhen the parameters are different, the old-fashioned function-pointers approach is difficult to use, since the caller doesn’t know which parameters to pass (the caller merely has a pointer to the function, not the function’s name or, when the parameters are different, the number and types of its parameters) (do not write me an email about this; yes you can do it, but you have to stand on your head and do messy things; but do not write me about it — use functionoids instead).\n\nWith functionoids, the situation is, at least sometimes, much better. Since a functionoid can be thought of as a freeze-dried function call, just take the un-common args, such as the ones I’ve called and/or , and make them args to the corresponding ctors. You may also pass the common args (in this case the called ) to the ctor, but you don’t have to — you have the option of passing it/them to the pure virtual method instead. I’ll assume you want to pass into and and/or into the ctors:\n\nThen instead of three functions, you create three derived classes:\n\nNow you see that the ctor’s parameters get freeze-dried into the functionoid when you create the array of functionoids:\n\nSo when the user invokes the on one of these functionoids, he supplies the “remaining” args, and the call conceptually combines the original args passed to the ctor with those passed into the method:\n\nAs I’ve already hinted, one of the benefits of functionoids is that you can have several instances of, say, in your array, and those instances can have different parameters freeze-dried into them. For example, and are both of type , but the behavior of will be different from the behavior of since the behavior will depend on both the 12 that was passed to and the args passed to the ctors.\n\nAnother benefit of functionoids is apparent if we change the example from an array of functionoids to a local functionoid. To set the stage, let’s go back to the old-fashioned function-pointer approach, and imagine that you’re trying to pass a comparison-function to a or routine. The or routine is called and the comparison function-pointer type is called :\n\nThen different callers would pass different function-pointers depending on what they thought was best:\n\nWe can easily translate this example into one using functionoids:\n\nGiven this example as a backdrop, we can see two benefits of functionoids over function-pointers. The “ctor args” benefit described above, plus the fact that functionoids can maintain state between calls in a thread-safe manner. With plain function-pointers, people normally maintain state between calls via static data. However static data is not intrinsically thread-safe — static data is shared between all threads. The functionoid approach provides you with something that is intrinsically thread-safe since the code ends up with thread-local data. The implementation is trivial: change the old-fashioned static datum to an instance data member inside the functionoid’s object, and poof, the data is not only thread-local, but it is even safe with recursive calls: each call to will have its own distinct object with its own distinct instance data.\n\nNote that we’ve gained something without losing anything. If you want thread-global data, functionoids can give you that too: just change it from an instance data member inside the functionoid’s object to a static data member within the functionoid’s class, or even to a local-scope static data. You’d be no better off than with function-pointers, but you wouldn’t be worse off either.\n\nThe functionoid approach gives you a third option which is not available with the old-fashioned approach: the functionoid lets callers decide whether they want thread-local or thread-global data. They’d be responsible to use locks in cases where they wanted thread-global data, but at least they’d have the choice. It’s easy:\n\nFunctionoids don’t solve every problem encountered when making flexible software, but they are strictly more powerful than function-pointers and they are worth at least evaluating. In fact you can easily prove that functionoids don’t lose any power over function-pointers, since you can imagine that the old-fashioned approach of function-pointers is equivalent to having a global(!) functionoid object. Since you can always make a global functionoid object, you haven’t lost any ground. QED.\n\nCan you make functionoids faster than normal function calls?\n\nIf you have a small functionoid, and in the real world that’s rather common, the cost of the function-call can be high compared to the cost of the work done by the functionoid. In the previous FAQ, functionoids were implemented using virtual functions and will typically cost you a function-call. An alternate approach uses templates.\n\nThe following example is similar in spirit to the one in the previous FAQ. I have renamed to to improve the caller code’s readability and to allow someone to pass a regular function-pointer:\n\nThe difference between this approach and the one in the previous FAQ is that the fuctionoid gets “bound” to the caller at compile-time rather than at run-time. Think of it as passing in a parameter: if you know at compile-time the kind of functionoid you ultimately want to pass in, then you can use the above technique, and you can, at least in typical cases, get a speed benefit from having the compiler inline-expand the functionoid code within the caller. Here is an example:\n\nWhen the compiler compiles the above, it might inline-expand the call which might improve performance.\n\nHere is one way to call the above:\n\nAside: as was hinted at in the first paragraph above, you may also pass in the names of normal functions (though you might incur the cost of the function call when the caller uses these):\n\nWhat’s the difference between a functionoid and a functor?\n\nA functionoid is an object that has one major method. It’s basically the OO extension of a C-like function such as printf(). One would use a functionoid whenever the function has more than one entry point (i.e., more than one “method”) and/or needs to maintain state between calls in a thread-safe manner (the C-style approach to maintaining state between calls is to add a local “static” variable to the function, but that is horribly unsafe in a multi-threaded environment).\n\nA functor is a special case of a functionoid: it is a functionoid whose method is the “function-call operator,” operator()(). Since it overloads the function-call operator, code can call its major method using the same syntax they would for a function call. E.g., if “foo” is a functor, to call the “operator()()” method on the “foo” object one would say “foo()”. The benefit of this is in templates, since then the template can have a template parameter that will be used as a function, and this parameter can be either the name of a function or a functor-object. There is a performance advantage of it being a functor object since the “operator()()” method can be inlined (whereas if you pass the address of a function it must, necessarily, be non-inlined).\n\nThis is very useful for things like the “comparison” function on sorted containers. In C, the comparison function is always passed by pointer (e.g., see the signature to “qsort()”), but in C++ the parameter can come in either as a pointer to function OR as the name of a functor-object, and the result is that sorted containers in C++ can be, in some cases, a lot faster (and never slower) than the equivalent in C.\n\nSince Java has nothing similar to templates, it must use dynamic binding for all this stuff, and dynamic binding of necessity means a function call. Normally not a big deal, but in C++ we want to enable extremely high performance code. That is, C++ has a “pay for it only if you use it” philosophy, which means the language must never arbitrarily impose any overhead over what the physical machine is capable of performing (of course a programmer may, optionally, use techniques such as dynamic binding that will, in general, impose some overhead in exchange for flexibility or some other “ility”, but it’s up to the designer and programmer to decide whether they want the benefits (and costs) of such constructs)."
    },
    {
        "link": "https://stackoverflow.com/questions/69047157/how-to-understand-using-typedef-to-define-a-function-pointer",
        "document": "Let's start by talking about declaration syntax in general (I'll be using C terminology, although C++ is largely similar). In both C and C++, a declaration contains a sequence of one or more declaration specifiers followed by a comma-separated list of zero or more declarators.\n\nDeclaration specifiers include type specifiers ( , , , , etc.), type qualifiers ( , , etc.), storage class specifiers ( , , , etc.), and specifiers, and a few other things we won't get into here.\n\nDeclarators include the name of the thing being declared, along with information about that thing's pointer-ness, array-ness, or function-ness (in C++ you also have reference-ness).\n\nWhen you declare a function, such as\n\nis the declaration specifier (type specifier), and is the declarator. The type of is fully specified by the combination of the declaration specifier and declarator:\n\nIn plain English, the type of is \"function taking an and parameter and returning .\"\n\nYou can declare pointers to functions as well:\n\nAgain, the sole declaration specifier is , and the declarator is .\n\nFor syntactic purposes, is grouped with the storage class specifiers ( , , ), but it doesn't behave like other storage class specifiers - instead of affecting the storage or visibility of the thing being declared, it makes the identifier in the declarator an alias for the type. If we stick on the front of the above declaration:\n\nthen it reads as\n\nIOW, is an alias ( name) for the type \"pointer to function taking an and parameter and returning \", and you can use it to declare pointer objects of that type:\n\nYou can do the same thing with other pointer types1:\n\nDeclarators can get pretty complex. You can have pointers to functions:\n\narrays of pointers to functions returning pointers to arrays:\n\nand on and on and on, and sticking in front of any of them will work:\n\nmeans is an alias for the type \"N-element array of pointers to functions returning pointers to M-element arrays of \"."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/typedef",
        "document": "The typedef specifier, when used in a declaration, specifies that the declaration is a typedef declaration rather than a variable or function declaration.\n\nTypically, the typedef specifier appears at the start of the declaration, though it is permitted to appear after the type specifiers, or between two type specifiers. The typedef specifier cannot be combined with any other specifier except for type specifiers.\n\nA typedef declaration may declare one or many identifiers on the same line (e.g. int and a pointer to int), it may declare array and function types, pointers and references, class types, etc. Every identifier introduced in this declaration becomes a typedef name, which is a synonym for the type of the object or function that it would become if the keyword typedef were removed.\n\nThe typedef names are aliases for existing types, and are not declarations of new types. typedef cannot be used to change the meaning of an existing type name (including a typedef name). Once declared, a typedef name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.\n\nThe typedef specifier may not appear in the declaration of a function parameter nor in the decl-specifier-seq of a function definition:\n\nThe typedef specifier may not appear in a declaration that does not contain a declarator:\n\nIf a typedef declaration defines an unnamed class or enumeration, the first typedef name of the class type or enumeration type declared by the declaration is the typedef name for linkage purposes of that type.\n\nFor example, in typedef struct { /* ... */ } S;, is a typedef name for linkage purposes. The class or enumeration type defined in this way has external linkage (unless it is in an unnamed namespace).\n\nulong // the following two objects have the same type l1 ulong l2 int_t, intp_t, fp , ulong , arr_t // the following two objects have the same type a1 arr_t a2 // beware: the following two objects do not have the same type intp_t p1 p2 // common C idiom to avoid having to write \"struct S\" a b S, pS // the following two objects have the same type pS ps1 S ps2 // error: storage-class-specifier cannot appear in a typedef declaration // typedef can be used anywhere in the decl-specifier-seq ullong // std::add_const, like many other metafunctions, use member typedefs T add_const T type Node listNode next listNode // error: conflicts with the previously declared struct name // C++20 error: \"struct with typedef name for linkage\" has member functions f C_Incompatible\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    }
]