[
    {
        "link": "https://reaper.fm/sdk/reascript/reascripthelp.html",
        "document": "ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a \n\n\n\n ReaScript/Python scripts can call API functions using .\n\n\n\n All parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).\n\n\n\n Examples:\n\n # function returning a single (scalar) value:\n\n sec = RPR_parse_timestr(\"1:12\")\n\n\n\n # function returning information in the first parameter (function returns void):\n\n (str) = RPR_GetProjectPath(\"\", 512)\n\n\n\n # lower volume of track 3 by half (RPR_GetTrackUIVolPan returns Bool):\n\n tr = RPR_GetTrack(0, 2)\n\n (ok, tr, vol, pan) = RPR_GetTrackUIVolPan(tr, 0, 0)\n\n # this also works, if you only care about one of the returned values:\n\n vol = RPR_GetTrackUIVolPan(tr, 0, 0)[2]\n\n RPR_SetMediaTrackInfo_Value(tr, \"D_VOL\", vol*0.5)\n\n \n\n You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line: and call the function by using: \n\n Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript: \n\n In addition to the \n\n\n\n ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a free download . Python 2.7 is normally included with macOS, and the dynamic library is usually in /usr/lib. If you update to a newer version of Python, it will be installed to a different directory. After installing Python, REAPER may detect the Python dynamic library automatically. If not, you can enter the path in the ReaScript preferences page, at Options/Preferences/Plug-Ins/ReaScript.ReaScript/Python scripts can call API functions usingAll parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).Examples:You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line:and call the function by using:Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript:In addition to the standard API functions , Reascript/Python also has these built-in functions available:\n\nstring out = reaper.image_resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.relative_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn2(string in, string out, optional string checkSubDir)\n• col_main_textshadow : Main window text shadow (ignored if too close to text color)\n• col_nodarkmodemiscwnd : Do not use window theming on macOS dark mode\n• track_lanesolo_tabcol : Track fixed lane button when only this lane plays\n\n\n\n\n\n \n\n \n\n EEL2: \n\n\n\nReturns the absolute value of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the cosine of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n\n\n \n\n EEL2: \n\n\n\nUsed to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a file previously opened with fopen().\n\n\n\n \n\n EEL2: \n\n\n\nReturns nonzero if the file fp is at the end of file.\n\n\n\n \n\n EEL2: \n\n\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n\n\n \n\n EEL2: \n\n\n\nPerforms a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.\n\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\n\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n\n\n\n \n\n EEL2: \n\n\n\nPermute the input for ifft(), taking bands from in-order to the order ifft() requires. See \n\n\n\n \n\n EEL2: \n\n\n\nPermute the output of fft() to have bands in-order. See \n\n\n\n \n\n EEL2: \n\n\n\nPerforms an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.\n\n\n\n \n\n EEL2: \n\n\n\nReads a character from file fp, returns -1 if EOF.\n\n\n\n \n\n EEL2: \n\n\n\nReads a line from file fp into #str. Returns length of #str read.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n\n\n \n\n EEL2: \n\n\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and writes it to file fp. For more information on format specifiers, see \n\n\n\n \n\n EEL2: \n\n\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n\n\n \n\n EEL2: \n\n\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n\n\n \n\n EEL2: \n\n\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n\n\n \n\n EEL2: \n\n\n\nRetunrs the current file position.\n\n\n\n \n\n EEL2: \n\n\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n\n\n \n\n EEL2: \n\n\n\nQueries contextual information about the script, typically MIDI/OSC input values.\n\nReturns true if a new value has been updated.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n EEL2: \n\n\n\nThe following global variables are special and will be used by the graphics system:\n• gfx_a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx_mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().\n• gfx_x - current graphics position X. Some drawing functions use as start position and update.\n• gfx_y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx_clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx_dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx_texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx_ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx_w/gfx_h/etc will be doubled, but on other systems gfx_w/gfx_h will remain the same and gfx_ext_retina is a scaling hint for drawing.\n• mouse_x - current X coordinate of the mouse relative to the graphics window.\n• mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx_getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n EEL2: \n\n\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n EEL2: \n\n\n\nCopies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).\n\nIf destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n EEL2: \n\n\n\nDeprecated, use gfx_blit instead.\n\n\n\n \n\n EEL2: \n\n\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a circle, optionally filling/antialiasing. \n\n\n\n \n\n EEL2: \n\n\n\nConverts client coordinates x,y to screen coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n EEL2: \n\n\n\nCall with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/size\n\n\n\n \n\n EEL2: \n\n\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n\n\n \n\n EEL2: \n\n\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n\n\n \n\n EEL2: \n\n\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx_getchar() at least once causes mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n EEL2: \n\n\n\nEnumerates any drag/dropped files. call gfx_dropfile(-1) to clear the list when finished. Returns 1 if idx is valid, 0 if idx is out of range.\n\n\n\n \n\n EEL2: \n\n\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n\n\n \n\n EEL2: \n\n\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n\n\n \n\n EEL2: \n\n\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n\n\n \n\n EEL2: \n\n\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n EEL2: \n\n\n\nInitializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nLoad image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n EEL2: \n\n\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n EEL2: \n\n\n\nCloses the graphics window.\n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a rectangle with rounded corners. \n\n\n\n \n\n EEL2: \n\n\n\nConverts screen coordinates x,y to client coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n\n\n\n \n\n EEL2: \n\n\n\nSpecify 0 resource_id and custom_cursor_name from https://www.reaper.fm/sdk/cursors/cursors.php (e.g. 'arrow') to set the cursor. Alternatively can specify resource_id for a Windows cursor or built-in REAPER cursor.\n\n\n\n \n\n EEL2: \n\n\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n\n\n \n\n EEL2: \n\n\n\nResize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n EEL2: \n\n\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n\n\n \n\n EEL2: \n\n\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n EEL2: \n\n\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a filled triangle, or any convex polygon. \n\n\n\n\n\n EEL2: \n\n\n\nUpdates the graphics display, if opened\n\n\n\n \n\n EEL2: \n\n\n\nPerform an inverse FFT. For more information see fft().\n\n\n\n \n\n EEL2: \n\n\n\nPerforms an inverse FFT, but takes size/2 complex input pairs and produces size real output values. Usually used along with fft_ipermute(size/2).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n\n\n \n\n EEL2: \n\n\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax. \n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n• %x, %d, %u, and %f are available for use similarly\n• %c can be used, but can't take any length modifiers\n• Use uppercase (%S, %D, etc) for lazy matching\n\n \n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n\n\n \n\n EEL2: \n\n\n\nCase-insensitive version of match().\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nShuffles contents of buf right by 1, inserts value at buf[0], returns previous buf[len-1].\n\n\n\n \n\n EEL2: \n\n\n\nCalculates the sum of the products of values pointed to by src1 and src2. If src1 is -1, then calculates the sum of squares of src2, if -2, the sum of the absolute values of src2, if -3, calculates the sum of the values of src2. Other negative values are undefined.\n\n\n\n \n\n EEL2: \n\n\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n\n\n \n\n EEL2: \n\n\n\nSets length items of memory at offset to value.\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n\n\n \n\n EEL2: \n\n\n\nReturns a pseudorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n EEL2: \n\n\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n\n\n \n\n EEL2: \n\n\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include: \n\nMany standard C printf() modifiers can be used, including:\n• %.10s = string, but only print up to 10 characters\n\n \n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n\n\n \n\n EEL2: \n\n\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n\n\n \n\n EEL2: \n\n\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters): \n\n\n\n \n\n EEL2: \n\n\n\nInserts srcstr into #str at offset pos. Returns #str\n\n\n\n \n\n EEL2: \n\n\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. See str_getchar() for more information on types.\n\n\n\n \n\n EEL2: \n\n\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies the contents of srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n\n\n \n\n EEL2: \n\n\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the length of the string passed as a parameter\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the tangent of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n\n\n \n\n EEL2: \n\n\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n\n\n \n\n EEL2: \n\n\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n\n\n \n\n EEL2: \n\n\n\nEnds listening on port specified.\n\n\n\n \n\n EEL2: \n\n\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n\n\n \n\n EEL2: \n\n\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n\n\n \n\n EEL2: \n\n\n\nSets whether a connection blocks.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n\n\n \n\n EEL2: \n\n\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n\n\n EEL2:Returns the absolute value of the parameter.EEL2:Returns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.EEL2:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.EEL2:Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).EEL2:Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.EEL2:Returns the cosine of the angle specified (specified in radians).EEL2:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.EEL2:Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.EEL2:Returns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.EEL2:Used to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).EEL2:Closes a file previously opened with fopen().EEL2:Returns nonzero if the file fp is at the end of file.EEL2:If file fp is open for writing, flushes out any buffered data to disk.EEL2:Performs a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.Note that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.Note that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.EEL2:Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft () for more information.EEL2:Permute the output of fft() to have bands in-order. See fft () for more information.EEL2:Performs an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.EEL2:Reads a character from file fp, returns -1 if EOF.EEL2:Reads a line from file fp into #str. Returns length of #str read.EEL2:Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).EEL2:Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.EEL2:Formats a string and writes it to file fp. For more information on format specifiers, see sprintf (). Returns bytes written to file.EEL2:Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.EEL2:Hints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.EEL2:Seeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.EEL2:Retunrs the current file position.EEL2:Writes up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.EEL2:Queries contextual information about the script, typically MIDI/OSC input values.Returns true if a new value has been updated.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)EEL2:The following global variables are special and will be used by the graphics system:EEL2:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.EEL2:Copies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).If destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).EEL2:Deprecated, use gfx_blit instead.EEL2:Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.EEL2:Draws a circle, optionally filling/antialiasing.EEL2:Converts client coordinates x,y to screen coordinates.EEL2:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.EEL2:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/sizeEEL2:Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.EEL2:Draws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.EEL2:Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Lua: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()\n\nReturns contextual information about the script, typically MIDI/OSC input values.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n Lua: \n\n\n\n The following global variables are special and will be used by the graphics system:\n• gfx.a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx.mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit().\n• gfx.x - current graphics position X. Some drawing functions use as start position and update.\n• gfx.y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx.clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx.dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx.texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx.ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx.w/gfx.h/etc will be doubled, but on other systems gfx.w/gfx.h will remain the same and gfx.ext_retina is a scaling hint for drawing.\n• gfx.mouse_x - current X coordinate of the mouse relative to the graphics window.\n• gfx.mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• gfx.mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx.getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n Lua: \n\n\n\n Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n Lua: \n\n\n\n Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).\n\nIf destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n Lua: \n\n\n\n Deprecated, use gfx.blit instead.\n\n\n\n \n\n Lua: \n\n\n\n Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Draws a circle, optionally filling/antialiasing. \n\n\n\n \n\n Lua: \n\n\n\n Converts the coordinates x,y to screen coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n Lua: \n\n\n\n Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/size\n\n\n\n \n\n Lua: \n\n\n\n Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n\n\n\n \n\n Lua: \n\n\n\n Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.\n\n\n\n \n\n Lua: \n\n\n\n Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\n\n\n\n \n\n Lua: \n\n\n\n If char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx.getchar() at least once causes gfx.mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n Lua: \n\n\n\n Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n\n\n\n \n\n Lua: \n\n\n\n Returns current font index, and the actual font face used by this font (if available).\n\n\n\n \n\n Lua: \n\n\n\n Retreives the dimensions of an image specified by handle, returns w, h pair.\n\n\n\n \n\n Lua: \n\n\n\n Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n\n\n\n \n\n Lua: \n\n\n\n Fills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n Lua: \n\n\n\n Initializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx.update() should be called periodically. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Load image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a character with the current font (as set by gfx.setfont). Returns width and height of character.\n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n Lua: \n\n\n\n Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n Lua: \n\n\n\n Closes the graphics window.\n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y. \n\n\n\n \n\n Lua: \n\n\n\n Draws a rectangle with rounded corners. \n\n\n\n \n\n Lua: \n\n\n\n Converts the screen coordinates x,y to client coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n\n\n\n \n\n Lua: \n\n\n\n Sets the mouse cursor to resource_id and/or custom_cursor_name. \n\n\n\n \n\n Lua: \n\n\n\n Can select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx.setfont(), gfx.texth may be updated to reflect the new average line height.\n\n\n\n \n\n Lua: \n\n\n\n Resize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n Lua: \n\n\n\n Writes a pixel of r,g,b to gfx.x,gfx.y.\n\n\n\n \n\n Lua: \n\n\n\n Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx.showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx.showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n Lua: \n\n\n\n Blits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (table can be a regular table or (for less overhead) a reaper.array). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n Lua: \n\n\n\n Draws a filled triangle, or any convex polygon. \n\n\n\n \n\n Lua: \n\n\n\n Updates the graphics display, if opened\n\n\n\n \n\n Lua: \n\n\n\n Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach. 6.20+: returns previous shared memory segment name.\n\n\n\n \n\n Lua: \n\n\n\n Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Creates a new reaper.array object of maximum and initial size size, if specified, or from the size/values of a table/array. Both size and table/array can be specified, the size parameter will override the table/array size.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n reaper.set_action_options(flag)\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n Lua: \n\n\n\n Sets the value of zero or more items in the array. If value not specified, 0.0 is used. offset is 1-based, if size omitted then the maximum amount available will be set.\n\n\n\n \n\n Lua: \n\n\n\n Convolves complex value pairs from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs. size is in normal items (so it must be even)\n\n\n\n \n\n Lua: \n\n\n\n Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward real->complex FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Returns the maximum (allocated) size of the array.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards complex->real FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Resizes an array object to size. size must be [0..max_size].\n\n\n\n \n\n Lua: \n\n\n\n Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n\n\n\n Lua:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Lua:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Lua:is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()Returns contextual information about the script, typically MIDI/OSC input values.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)Lua:The following global variables are special and will be used by the graphics system:Lua:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.Lua:Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).If destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).Lua:Deprecated, use gfx.blit instead.Lua:Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.Lua:Draws a circle, optionally filling/antialiasing.Lua:Converts the coordinates x,y to screen coordinates, returns those values.Lua:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.Lua:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/sizeLua:Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.Lua:Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.Lua:Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Python: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n Python:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly."
    },
    {
        "link": "https://reaper.fm/sdk/reascript/reascript.php",
        "document": "EEL2\n\n A language developed in-house (but A language developed in-house (but open source ) which has some similarities to C and JavaScript. EEL is also used to write JSFX plug-ins, OSCII-bot scripts, and video processing effects in REAPER. EEL offers high run-time performance. It supports basic UI management (dedicated script window, docking, context menus, mouse input, etc) and graphics manipulation (drawing primitives, loading image files, etc). EEL is embedded within REAPER and requires no additional downloads or settings. Lua (v5.4)\n\n A popular scripting language. Lua is probably easier to learn and use than EEL or Python, and offers good performance. It supports the same UI and graphic features as EEL. As a general-use scripting language, Lua also benefits from third-party resources, libraries, tutorials, and code examples. Lua is embedded within REAPER and requires no additional downloads or settings. Note that REAPER v6.x and earlier used Lua v5.3. Python (v2.7-v3.x)\n\n Another popular scripting language. Python must be downloaded and installed separately (see \n\n Another popular scripting language. Python must be downloaded and installed separately (see requirements ) and as such, will never be as portable between users as EEL or Lua. Within REAPER, Python performance is not as good as EEL or Lua, and does not offer any UI or graphic features. However, Python does benefit from a vast number of third-party resources, libraries, tutorials, and code examples.\n• Unknown extension API. Perhaps the script was written against a newer version of REAPER.\n• Incorrect use of the Extension API. Verify how the function parameters and return value should be used in the REAPER-generated ReaScript documentation.\n• Lua: invalid \"objects\". Check variables for before passing to functions.\n• Python: REAPER cannot find the Python library. Is the proper 32/64-bit Python installed? Is it enabled in Preferences?\n• SetExtState() and GetExtState() allow ReaScripts to set and get key/value pairs that will persist between ReaScripts, and optionally persist between REAPER instances as well. For example, a Python module called \"utility\" might want to remember that some flag is set: RPR_SetExtState(\"utility\", \"someflag\", \"2\", True) val=RPR_GetExtState(\"utility\", \"someflag\") # even if called after REAPER is closed and reopened, val will be equal to \"2\"\n• SetProjExtState() and GetProjExtState() allow ReaScripts to save data within the project RPP file.\n\nThere are also API functions for manually creating undo points, as well as API functions to Undo and Redo previous points.\n\nThe best way to manually create an undo point for your script is to call Undo_BeginBlock() before most of your code, and Undo_EndBlock() after your code finishes.\n• These functions operate on the active project only (if multiple tabs are open) -- do not switch project tabs from your code while in an Undo block.\n• You must always pair with . If you call and then fail to call , an undo block will be left open, which may cause undesired undo behaviors.\n• The final parameter of is a bitmask of what you would like to add to the undo state. If you are simply calling other actions (via or similar functions), this should be 0. If you modify the state of the project directly, it's safest to set the bitmask to -1. A more specific combination of flags may be an optimization, depending on what your script is doing.\n• Always give the \"desc\" parameter of a valid (non-empty) descriptive string."
    },
    {
        "link": "https://extremraym.com/cloud/reascript-doc",
        "document": "Thank you for considering making a donation or buy one of Premium Scripts to support this free work! ❤️"
    },
    {
        "link": "https://mespotin.uber.space/Ultraschall/Reaper_Api_Documentation.html",
        "document": ""
    },
    {
        "link": "https://forum.cockos.com/showthread.php?p=2477740",
        "document": "Looks like a very solid framework, and also a very solid documentation generator, well done and thanks for sharing ! Also, written all this doc for all this tools... that is kind of a hard passionate work ! Thanks! Yes, the documentation was a shocking amount of work. But it's always a good exercise as writing docs shakes out quite a lot of janky and half-baked stuff. \n\n \n\n \n\n I would say that focusing on what ReaImGui can't do would make sense. Scalable text is one of them as far as know. Your box approach CSS like system seems promising. I think there will inevitably be a nontrivial amount of overlap just because they aim to accomplish similar things. But there are certainly enough differences to justify both projects. And at least to me ImGui aesthetically reminds me of Unix GUIs from the early 90s (and not in the nice nostalgic way). But I bet it's fast as balls. \n\n \n\n \n\n Anyway, I think the priority is to add screenshots to the doc. This would help us a lot to see what we can expect, what we can do etc. Definitely. The docs do have screenshots for rtk.OptionMenu, \n\n \n\n \n\n Also, I think making the examples reapack compatible could make sense so we can try out of the box. That's a fine idea, but I first need to write some better, more comprehensive demos.\n\n \n\n \n\n So how do we keep up to date version of rtk ? Does this means than any fix you made have to been pushed by other scripters too? I think centralized distribution like scythe or reaimgui are quite interesting cause if the extension got a fixed, than all script depending on them will got one. But I guess a scripter could have his own instance of rtk, used by all his script ? I have been and continue to be wrestling with this one.\n\n \n\n Having a single installation that all scripts use imposes strict requirements on API stability. It simply won't do to have an rtk update break even a single script. I'm not at the stage yet where I can claim the API is stable. To be clear, I don't have any breaking changes planned, but it's only ever been my eyeballs on this thing, so I'd want to get a bunch more feedback before I make a commitment to not making breaking changes.\n\n \n\n So having script authors distribute the version of rtk they have developed and tested against in their ReaPacks seems like a reasonable compromise. It mitigates the risk of changes (which could include bug fixes, if the buggy behavior was actually relied upon) made outside the script author's control negatively affecting their scripts. I've tried to make this process relatively simple by bundling the entirety of rtk into one file for distribution.\n\n \n\n But I am receptive to arguments on this one. And as I gain more confidence with the API's stability I can see myself introducing a centralized distribution via ReaPack, giving script writers the option of whether to bundle their own copy or use the central one.\n\n \n\n \n\n PS: maybe even a scripting video from scratch could be nice at this point. :P I'm definitely game for that. I think I'd wait and see what some of the initial questions, confusions, and pain points are with getting started so I'd have a better idea what to focus on. At this point I'm probably a little too disconnected from how other developers will approach it.\n\n \n\n Thanks for your feedback X-Raym, I really appreciate it. Thanks! Yes, the documentation was a shocking amount of work. But it's always a good exercise as writing docs shakes out quite a lot of janky and half-baked stuff.I think there will inevitably be a nontrivial amount of overlap just because they aim to accomplish similar things. But there are certainly enough differences to justify both projects. And at least to me ImGui aesthetically reminds me of Unix GUIs from the early 90s (and not in the nice nostalgic way). But I bet it's fast as balls.Definitely. The docs do have screenshots for rtk.Button rtk.Application , and visualizations of some of the container types , but there are a few gaps to flesh out for sure.That's a fine idea, but I first need to write some better, more comprehensive demos.I have been and continue to be wrestling with this one.Having a single installation that all scripts use imposes strict requirements on API stability. It simply won't do to have an rtk update break even a single script. I'm not at the stage yet where I can claim the API is stable. To be clear, I don't have any breaking changes planned, but it's only ever been my eyeballs on this thing, so I'd want to get a bunch more feedback before I make a commitment to not making breaking changes.So having script authors distribute the version of rtk they have developed and tested against in their ReaPacks seems like a reasonable compromise. It mitigates the risk of changes (which could include bug fixes, if the buggy behavior was actually relied upon) made outside the script author's control negatively affecting their scripts. I've tried to make this process relatively simple by bundling the entirety of rtk into one file for distribution.But I am receptive to arguments on this one. And as I gain more confidence with the API's stability I can see myself introducing a centralized distribution via ReaPack, giving script writers the option of whether to bundle their own copy or use the central one.I'm definitely game for that. I think I'd wait and see what some of the initial questions, confusions, and pain points are with getting started so I'd have a better idea what to focus on. At this point I'm probably a little too disconnected from how other developers will approach it.Thanks for your feedback X-Raym, I really appreciate it.\n\nOne design question I have -- had you considered a declarative format for the component definitions? Something like S-expressions or XML/HTML? I've always had S-expressions on my mind, actually. This is almost possible now -- the only thing that's missing is the ability to declare children on constructors of container widgets, but that's actually a trivial addition.\n\n \n\n So something like this can be made possible quite easily:\n\n \n\n But to be honest, for large and complex interfaces, I'm not convinced this approach is actually more readable than more conventional flat code. I think an XML-based approach would be more readable, but then I'm not super thrilled by the prospect of writing an XML parser in Lua. (Would be nice if Reaper's native XML parsing was exposed to Lua.)\n\n \n\n And the main gap that would still need to be addressed is some way to reference declared widgets in event handler functions. This is almost a problem in the onchange() handler in the above example, except that the rtk.Window happens to be accessible as an attribute on every widget, so I get away with it in my example. But suppose the onclick() handler for the button wanted to modify the rtk.CheckBox below it, this wouldn't be possible currently. (At least not without manually doing a traversal of the widget hierarchy from the window, which is lame.)\n\n \n\n So the obvious solution here is borrow more ideas from the DOM and allow a user-custom \"id\" attribute (which currently is just a monotonically increasing number per widget), and then offer a global function, say rtk.id(), to lookup widgets by their custom ids.\n\n \n\n I'm not sure about the ergonomics of that approach, but the real concern is that by maintaining global references to all widgets we much more easily get into dangerous territory with memory leaks (inasmuch as the program has abandoned with the widget but there remains a global reference to it). I know Lua supports weak tables, and that'd definitely be required here, but I don't know if there be dragons with weak tables. (They can get tricky in other languages.)\n\n \n\n And finally once you start building UIs that way, you're very quickly going to want something like CSS to manage the inevitable boilerplate. \n\n \n\n I think I'll go ahead and add the code to support passing children on constructors like shown above (it's only like 5 extra lines). (Edit: this is committed now). The problem of how to reference widgets declared in this way warrants some more thought, so I'd be grateful to hear opinions on that. I've always had S-expressions on my mind, actually. This ispossible now -- the only thing that's missing is the ability to declare children on constructors of container widgets, but that's actually a trivial addition.So something like this can be made possible quite easily:But to be honest, for large and complex interfaces, I'm not convinced this approach is actually more readable than more conventional flat code. I think an XML-based approach would be more readable, but then I'm not super thrilled by the prospect of writing an XML parser in Lua.(Would be nice if Reaper's native XML parsing was exposed to Lua.)And the main gap that would still need to be addressed is some way to reference declared widgets in event handler functions. This isa problem in the onchange() handler in the above example, except that the rtk.Window happens to be accessible as an attribute on every widget, so I get away with it in my example. But suppose the onclick() handler for the button wanted to modify the rtk.CheckBox below it, this wouldn't be possible currently. (At least not without manually doing a traversal of the widget hierarchy from the window, which is lame.)So the obvious solution here is borrow more ideas from the DOM and allow a user-custom \"id\" attribute (which currently is just a monotonically increasing number per widget), and then offer a global function, say rtk.id(), to lookup widgets by their custom ids.I'm not sure about the ergonomics of that approach, but the real concern is that by maintaining global references to all widgets we much more easily get into dangerous territory with memory leaks (inasmuch as the program has abandoned with the widget but there remains a global reference to it). I know Lua supports weak tables, and that'd definitely be required here, but I don't know if there be dragons with weak tables. (They can get tricky in other languages.)And finally once you start building UIs that way, you're very quickly going to want something like CSS to manage the inevitable boilerplate.I think I'll go ahead and add the code to support passing children on constructors like shown above (it's only like 5 extra lines). (Edit: this is committed now). The problem of how to reference widgets declared in this way warrants some more thought, so I'd be grateful to hear opinions on that. Last edited by tack; 09-07-2021 at .\n\nThere are Lua templating engines which are self-contained and have no dependencies, the ones I could find were: So I actually ended up writing something from scratch. I took a look at xml2lua specifically, but I didn't want anything overly large. I decided while a fully compliant XML parser might be a bit much, implementing enough of a subset wasn't too difficult. So I'll call it RML, which is close enough to XML to be useful. Going from RML to a nested table structure was only about 120 lines of code. (Admittedly that code is not fully baked yet.)\n\n \n\n I'm somewhat debating how I want variable scoping to work with expressions in the RML, though I think I have that sorted out. (At first I went with a dynamic scope approach but decided that's probably too clever, so will stick with lexical scoping, where the environment of executed code is determined at compile time, but can be explicitly overridden by passing a table at render time.)\n\n \n\n The approach I'm taking around conditionals and loops is more inspired by Vue, which you mentioned in your earlier post, and which I myself am familiar with from other projects.\n\n \n\n So my earlier example could be rewritten as:\n\n \n\n This shows:\n• Different types of handlers: inline expressions (with \"self\" being an injected magic variable like \"this\" is in javascript handlers) as well reference to externally defined functions\n• Conditional expression (checkbox only shows if js_ReaScriptAPI is available)\n• Single compile-and-render rml() convenience function (but template compiling and subsequent execution with custom variables injected into the function environment is also supported) \n\n Mustache syntax is supported, both in attribute values as well as element content. But not for control flow -- that would be handled by the \"if\" and \"for\" attributes, a la Vue.\n\n \n\n I still need to think about how for loops should work. Using a Lua expression is actually not straightforward to implement. I'll probably end up with a custom syntax that supports looping over tables, or iterating N times.\n\n \n\n There is a risk here that with all this capability, reactivity will be assumed. But reactive updates are a whole other level of complexity entirely, and while it would undoubtedly be cool, it's hard to justify the effort at this stage.\n\n \n\n Anyway, thanks for raising this to the foreground. I too wanted it early on, but it seemed a bit too ambitious, so I mainly just made sure to have a design to easily support S-expressions, knowing something XML-like would require it, so I could revisit this later. Now that I'm on the other side of rtk's design, implementing this doesn't seem like it will be too onerous. My code is still extremely experimental though, so who knows what dragons lurk around upcoming corners.\n\n \n\n The question of how to access arbitrary widgets from event handlers still needs to be solved. There isn't (and almost certainly won't be) a CSS-like selector capability, so something like custom ids and rtk.id() is my best idea. Interested to hear your thoughts on that. So I actually ended up writing something from scratch. I took a look at xml2lua specifically, but I didn't want anything overly large. I decided while a fully compliant XML parser might be a bit much, implementing enough of a subset wasn't too difficult. So I'll call it RML, which is close enough to XML to be useful. Going from RML to a nested table structure was only about 120 lines of code. (Admittedly that code is not fully baked yet.)I'm somewhat debating how I want variable scoping to work with expressions in the RML, though I think I have that sorted out. (At first I went with a dynamic scope approach but decided that's probably too clever, so will stick with lexical scoping, where the environment of executed code is determined at compile time, but can be explicitly overridden by passing a table at render time.)The approach I'm taking around conditionals and loops is more inspired by Vue, which you mentioned in your earlier post, and which I myself am familiar with from other projects.So my earlier example could be rewritten as:This shows:Mustache syntax is supported, both in attribute values as well as element content. But not for control flow -- that would be handled by the \"if\" and \"for\" attributes, a la Vue.I still need to think about how for loops should work. Using a Lua expression is actually not straightforward to implement. I'll probably end up with a custom syntax that supports looping over tables, or iterating N times.There is a risk here that with all this capability, reactivity will be assumed. But reactive updates are a whole other level of complexity entirely, and while it would undoubtedly be cool, it's hard to justify the effort at this stage.Anyway, thanks for raising this to the foreground. I too wanted it early on, but it seemed a bit too ambitious, so I mainly just made sure to have a design to easily support S-expressions, knowing something XML-like would require it, so I could revisit this later. Now that I'm on the other side of rtk's design, implementing this doesn't seem like it will be too onerous. My code is still extremely experimental though, so who knows what dragons lurk around upcoming corners.The question of how to access arbitrary widgets from event handlers still needs to be solved. There isn't (and almost certainly won't be) a CSS-like selector capability, so something like custom ids and rtk.id() is my best idea. Interested to hear your thoughts on that. Last edited by tack; 09-11-2021 at .\n\nThe approach I'm taking around conditionals and loops is more inspired by Vue, which you mentioned in your earlier post, and which I myself am familiar with from other projects.\n\n \n\n So my earlier example could be rewritten as: (...)\n\n \n\n Mustache syntax is supported, both in attribute values as well as element content. But not for control flow -- that would be handled by the \"if\" and \"for\" attributes, a la Vue.\n\n \n\n I still need to think about how for loops should work. Using a Lua expression is actually not straightforward to implement. I'll probably end up with a custom syntax that supports looping over tables, or iterating N times. Oh my god, Vue for REAPER! Incredible!!\n\n \n\n I've been writing Vue professionally since ~2016, right around the time Vue 2.0 was released, and I've written (nearly) everything.\n\n \n\n From oldschool server-rendered templates -> jQuery -> old Angular.js -> React before Redux et all existed, whatnot.\n\n \n\n Vue is simply the easiest/most productive and intuitive approach to modeling and building applications I've ever had the pleasure of working with. I used to speak frequently at Vue.js events.\n\n \n\n Anyways, about this point:\n\n I still need to think about how for loops should work. Using a Lua expression is actually not straightforward to implement. So one way I can think of off the top of my head, is to parse the \"for\" expression with a regex, and then call loadstring() on the \"of\" variable within the scope that contains the variable binding.\n\n Then inject the dynamically evaluated result into the child template, aliased as the \"for\" variable in the closure\n\n \n\n If you're like me, then trying to understand anything more complex than a potato described with words is impossible to follow, so here's roughly what I am trying to say:\n\n \n\n (Note: Using EmmyLua annotations for type-safety \n\n ---@alias ForOfExpression {for: string, of: string} ---@type fun(expr: string): ForOfExpression function parse_for_of_expression(expr) -- Match \"for=\" content in EG: <text for=\"item in items\"> local pattern = \"(%a+) [in|of] (%a+)\" local _, _, alias, variable = string.find(expr, pattern) ---@type ForOfExpression local for_of_expression = { for = alias, of = variable } return for_of_expression end ---@type fun(for_of_table: ForOfExpression): any function get_for_of_variable_from_lexical_scope(for_of_expression) return loadstring(for_of_expression.of) end function render_for_of_template(template) local for_of_expression = parse_for_of_expression(fill_me_in) local value_bound_to_of = get_for_of_variable_from_lexical_scope(for_of_expression) return render_template(template) .with_value(value_bound_to_of) .as(for_of_expression.for) end And about this:\n\n \n\n There is a risk here that with all this capability, reactivity will be assumed. But reactive updates are a whole other level of complexity entirely, and while it would undoubtedly be cool, it's hard to justify the effort at this stage. I think you might be surprised how \"easy\" this is if you use the proper tooling so that the data in the templates is wrapped in a \"reactive\" type.\n\n \n\n I wrote my own (shitty, just for fun) JS framework, including my own JSX rendering implementation and reactive data + rendering part, and managed to do it in about 60 lines by re-using Vue's low-level reactive() type.\n\n \n\n In reaction to data being changed, I just re-called \"render()\" and passed in the updated state, check this out:\n\n \n\n https://gist.github.com/GavinRay97/a...a89e9236994ca6\n\n \n\n // Using the \"h()\" function as TSX pragma and writing your own Vue\n\n// By re-using the reactivity primitives and using \"morphdom\" to efficiently update the DOM\n\n It looks like there's an \"RxLua\" that's self-contained, maybe you could use this or some other event-emitter type library?\n\n \n\n https://github.com/bjornbytes/RxLua\n\n \n\n I'm sure it's not going to be this simple, but something roughly like:\n\n \n\n If you wanted to go hardcore, I believe Vue uses a \"scheduler\", with a queue and eventing/messages + ticks, but fuckkk all of that haha. Oh my god, Vue for REAPER! Incredible!!I've been writing Vue professionally since ~2016, right around the time Vue 2.0 was released, and I've written (nearly) everything.From oldschool server-rendered templates -> jQuery -> old Angular.js -> React before Redux et all existed, whatnot.Vue is simply the easiest/most productive and intuitive approach to modeling and building applications I've ever had the pleasure of working with. I used to speak frequently at Vue.js events.Anyways, about this point:So one way I can think of off the top of my head, is to parse the \"for\" expression with a regex, and then callon the \"of\" variable within the scope that contains the variable binding.Then inject the dynamically evaluated result into the child template, aliased as the \"for\" variable in the closureIf you're like me, then trying to understand anything more complex than a potato described with words is impossible to follow, so here's roughly what I am trying to say:(Note: Using EmmyLua annotations for type-safety https://emmylua.github.io/annotations/type.html And about this:I think you might be surprised how \"easy\" this is if you use the proper tooling so that the data in the templates is wrapped in a \"reactive\" type.I wrote my own (shitty, just for fun) JS framework, including my own JSX rendering implementation and reactive data + rendering part, and managed to do it in about 60 lines by re-using Vue's low-leveltype.In reaction to data being changed, I just re-called \"render()\" and passed in the updated state, check this out:It looks like there's an \"RxLua\" that's self-contained, maybe you could use this or some other event-emitter type library?I'm sure it's not going to be this simple, but something roughly like:If you wanted to go hardcore, I believe Vue uses a \"scheduler\", with a queue and eventing/messages + ticks, but fuckkk all of that haha. __________________\n\n Seasoned codemonkey\n\n Dunno a thing about making music (here to learn!) Last edited by gxray; 09-11-2021 at ."
    },
    {
        "link": "https://forum.cockos.com/showthread.php?p=2746081",
        "document": "I'd have literally NO idea how to use that C++ thing within a Lua script, and I wouldn't be at all surprised to hear it's impossible.\n\n \n\n I'm really quite new to this - the last time I wrote any computer code was at University in the 1980s!!\n\n \n\n Doing OK with Lua for now, and managing to make some scripts that are really useful in my workflow, but nothing too complex :-)\n\n \n\n The reason for asking this was to see if it might help with the Undo problem discussed here: \n\n \n\n https://forum.cockos.com/showthread.php?t=211932\n\n \n\n (ie if a script could intercept keyboard commands then it could continue performing an action as the key was repeatedly pressed, then after a certain \"timeout\" of no presses, it could exit and make an Undo point).\n\n \n\n But it sounds like it's a blind alley. Thanks again.I'd have literally NO idea how to use that C++ thing within a Lua script, and I wouldn't be at all surprised to hear it's impossible.I'm really quite new to this - the last time I wrote any computer code was at University in the 1980s!!Doing OK with Lua for now, and managing to make some scripts that are really useful in my workflow, but nothing too complex :-)The reason for asking this was to see if it might help with the Undo problem discussed here:(ie if a script could intercept keyboard commands then it could continue performing an action as the key was repeatedly pressed, then after a certain \"timeout\" of no presses, it could exit and make an Undo point).But it sounds like it's a blind alley.\n\n\n\n Location: Somewhere over the Rainbow \n\n \n\n \n\n \n\n https://gist.github.com/cfillion/d86...fd7b2ea82f7ff6 Keyboard input can be intercepted globally (within REAPER) using accelerator_register_t from the C++ extension API. Oh, that's great \n\n \n\n How difficult would it be to add it to Julian's plugin?\n\n \n\n @andyp24\n\n You can't use C++-stuff directly from Lua, but if someone adds that as a function into an extension, you could use it, like any other ReaScript-API-function.\n\n You would just need to install that extension that contains this new function. Oh, that's greatHow difficult would it be to add it to Julian's plugin?@andyp24You can't use C++-stuff directly from Lua, but if someone adds that as a function into an extension, you could use it, like any other ReaScript-API-function.You would just need to install that extension that contains this new function. \n\n Use you/she/her.Ultraschall-Api Lua Api4Reaper - ReaGirl - a GuiLib for guis working for blind people\n\n\n\n but I have interrogations : \n\n - does it work only on windows ?\n\n - does it work on any \"local\" keyboard (qwerty, azerty)\n\n \n\n And it works even if the script is not focused ! (contrary to gfx.getchar())\n\n Note that the JS_VKeys_Intercept function behaves sometimes strangely: \n\n it allows to block the transmission of the captured key to Reaper, which can be nice,\n\n except (at least) the SPACE key (PLAY that might be more hardcoded ?).\n\n \n\n -------\n\n \n\n So here is my test code (needs JS-extension).\n\n If a MAC and/or LINUX user can test it, it would be nice\n\n And also a WINDOW user with QWERTY keyboard (I have AZERTY)\n\n \n\n Please Type a, z, e, a, s, d, z, x, c, F1, F12, and these special keys that are local-specific (;:!,<*ù$^=²)\n\n \n\n And post a copy of the console text, with eventually comments on special keys, so that I can recognize where they are on your keyboard...\n\n \n\n ---------------------------------------------------------------------------------------------------------- key_low, key_hi = 8, 0xFE --0xA5 -- Range of virtual key codes to check for key presses keys_zero = string.rep(\"\\0\", key_hi-key_low+1) -- For quick comparison to zero state keys_state = \"\" -- states of key currently pressed keys_down = \"\" -- keys pressed since last call keys_prev = \"\" time_keys_prev = 0.0 KEYCODES = { VK_LBUTTON = 0x01, -- The left mouse button VK_RBUTTON = 0x02, -- The right mouse button VK_CANCEL = 0x03, -- The Cancel virtual key, used for control-break processing VK_MBUTTON = 0x04, -- The middle mouse button VK_BACK = 0x08, -- Backspace VK_TAB = 0x09, -- Tab VK_CLEAR = 0x0C, -- 5 (keypad without Num Lock) VK_ENTER = 0x0D, -- Enter VK_SHIFT = 0x10, -- Shift (either one) VK_CONTROL = 0x11, -- Ctrl (either one) VK_MENU = 0x12, -- Alt (either one) VK_PAUSE = 0x13, -- Pause VK_CAPITAL = 0x14, -- Caps Lock VK_ESCAPE = 0x1B, -- Esc VK_SPACE = 0x20, -- Spacebar VK_PAGEUP = 0x21, -- Page Up VK_PAGEDOWN = 0x22, -- Page Down VK_END = 0x23, -- End VK_HOME = 0x24, -- Home VK_LEFT = 0x25, -- Left Arrow VK_UP = 0x26, -- Up Arrow VK_RIGHT = 0x27, -- Right Arrow VK_DOWN = 0x28, -- Down Arrow VK_SELECT = 0x29, -- Select VK_PRINT = 0x2A, -- Print (only used by Nokia keyboards) VK_EXECUTE = 0x2B, -- Execute (not used) VK_SNAPSHOT = 0x2C, -- Print Screen VK_INSERT = 0x2D, -- Insert VK_DELETE = 0x2E, -- Delete VK_HELP = 0x2F, -- Help VK_0 = 0x30, -- 0 VK_1 = 0x31, -- 1 VK_2 = 0x32, -- 2 VK_3 = 0x33, -- 3 VK_4 = 0x34, -- 4 VK_5 = 0x35, -- 5 VK_6 = 0x36, -- 6 VK_7 = 0x37, -- 7 VK_8 = 0x38, -- 8 VK_9 = 0x39, -- 9 VK_A = 0x41, -- A VK_B = 0x42, -- B VK_C = 0x43, -- C VK_D = 0x44, -- D VK_E = 0x45, -- E VK_F = 0x46, -- F VK_G = 0x47, -- G VK_H = 0x48, -- H VK_I = 0x49, -- I VK_J = 0x4A, -- J VK_K = 0x4B, -- K VK_L = 0x4C, -- L VK_M = 0x4D, -- M VK_N = 0x4E, -- N VK_O = 0x4F, -- O VK_P = 0x50, -- P VK_Q = 0x51, -- Q VK_R = 0x52, -- R VK_S = 0x53, -- S VK_T = 0x54, -- T VK_U = 0x55, -- U VK_V = 0x56, -- V VK_W = 0x57, -- W VK_X = 0x58, -- X VK_Y = 0x59, -- Y VK_Z = 0x5A, -- Z VK_STARTKEY = 0x5B, -- Start Menu key VK_CONTEXTKEY = 0x5D, -- Context Menu key VK_NUMPAD0 = 0x60, -- 0 (keypad with Num Lock) VK_NUMPAD1 = 0x61, -- 1 (keypad with Num Lock) VK_NUMPAD2 = 0x62, -- 2 (keypad with Num Lock) VK_NUMPAD3 = 0x63, -- 3 (keypad with Num Lock) VK_NUMPAD4 = 0x64, -- 4 (keypad with Num Lock) VK_NUMPAD5 = 0x65, -- 5 (keypad with Num Lock) VK_NUMPAD6 = 0x66, -- 6 (keypad with Num Lock) VK_NUMPAD7 = 0x67, -- 7 (keypad with Num Lock) VK_NUMPAD8 = 0x68, -- 8 (keypad with Num Lock) VK_NUMPAD9 = 0x69, -- 9 (keypad with Num Lock) VK_MULTIPLY = 0x6A, -- * (keypad) VK_ADD = 0x6B, -- = 0x(keypad) VK_SEPARATOR = 0x6C, -- Separator (never generated by the keyboard) VK_SUBTRACT = 0x6D, -- - (keypad) VK_DECIMAL = 0x6E, -- . (keypad with Num Lock) VK_DIVIDE = 0x6F, -- / (keypad) VK_F1 = 0x70, -- F1 VK_F2 = 0x71, -- F2 VK_F3 = 0x72, -- F3 VK_F4 = 0x73, -- F4 VK_F5 = 0x74, -- F5 VK_F6 = 0x75, -- F6 VK_F7 = 0x76, -- F7 VK_F8 = 0x77, -- F8 VK_F9 = 0x78, -- F9 VK_F10 = 0x79, -- F10 VK_F11 = 0x7A, -- F11 VK_F12 = 0x7B, -- F12 VK_F13 = 0x7C, -- F13 VK_F14 = 0x7D, -- F14 VK_F15 = 0x7E, -- F15 VK_F16 = 0x7F, -- F16 VK_F17 = 0x80, -- F17 VK_F18 = 0x81, -- F18 VK_F19 = 0x82, -- F19 VK_F20 = 0x83, -- F20 VK_F21 = 0x84, -- F21 VK_F22 = 0x85, -- F22 VK_F23 = 0x86, -- F23 VK_F24 = 0x87, -- F24 VK_NUMLOCK = 0x90, -- Num Lock VK_OEM_SCROLL = 0x91, -- Scroll Lock VK_OEM_1 = 0xBA, -- ; VK_OEM_PLUS = 0xBB, -- = VK_OEM_COMMA = 0xBC, -- , VK_OEM_MINUS = 0xBD, -- - VK_OEM_PERIOD = 0xBE, -- . VK_OEM_2 = 0xBF, -- / VK_OEM_3 = 0xC0, -- ` VK_OEM_4 = 0xDB, -- [ VK_OEM_5 = 0xDC, -- \\ VK_OEM_6 = 0xDD, -- ] VK_OEM_7 = 0xDE, -- ' VK_OEM_8 = 0xDF, -- (unknown) VK_ICO_F17 = 0xE0, -- F17 on Olivetti extended keyboard (internal use only) VK_ICO_F18 = 0xE1, -- F18 on Olivetti extended keyboard (internal use only) VK_OEM_102 = 0xE2, -- < or | on IBM-compatible 102 enhanced non-U.S. keyboard VK_ICO_HELP = 0xE3, -- Help on Olivetti extended keyboard (internal use only) VK_ICO_00 = 0xE4, -- 00 on Olivetti extended keyboard (internal use only) VK_ICO_CLEAR = 0xE6, -- Clear on Olivette extended keyboard (internal use only) VK_OEM_RESET = 0xE9, -- Reset (Nokia keyboards only) VK_OEM_JUMP = 0xEA, -- Jump (Nokia keyboards only) VK_OEM_PA1 = 0xEB, -- PA1 (Nokia keyboards only) VK_OEM_PA2 = 0xEC, -- PA2 (Nokia keyboards only) VK_OEM_PA3 = 0xED, -- PA3 (Nokia keyboards only) VK_OEM_WSCTRL = 0xEE, -- WSCTRL (Nokia keyboards only) VK_OEM_CUSEL = 0xEF, -- CUSEL (Nokia keyboards only) VK_OEM_ATTN = 0xF0, -- ATTN (Nokia keyboards only) VK_OEM_FINNISH = 0xF1, -- FINNISH (Nokia keyboards only) VK_OEM_COPY = 0xF2, -- COPY (Nokia keyboards only) VK_OEM_AUTO = 0xF3, -- AUTO (Nokia keyboards only) VK_OEM_ENLW = 0xF4, -- ENLW (Nokia keyboards only) VK_OEM_BACKTAB = 0xF5, -- BACKTAB (Nokia keyboards only) VK_ATTN = 0xF6, -- ATTN VK_CRSEL = 0xF7, -- CRSEL VK_EXSEL = 0xF8, -- EXSEL VK_EREOF = 0xF9, -- EREOF VK_PLAY = 0xFA, -- PLAY VK_ZOOM = 0xFB, -- ZOOM VK_NONAME = 0xFC, -- NONAME VK_PA1 = 0xFD, -- PA1 VK_OEM_CLEAR = 0xFE, -- CLEAR } KEYCODES_NAME = { \"VK_LBUTTON\", \"VK_RBUTTON\", \"VK_CANCEL\", \"VK_MBUTTON\", \"\", \"\", \"\", \"VK_BACK\", \"VK_TAB\", \"\", \"\", \"VK_CLEAR\", \"VK_ENTER\", \"\", \"\", \"VK_SHIFT\", \"VK_CONTROL\", \"VK_MENU\", \"VK_PAUSE\", \"VK_CAPITAL\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_ESCAPE\", \"\", \"\", \"\", \"\", \"VK_SPACE\", \"VK_PAGEUP\", \"VK_PAGEDOWN\", \"VK_END\", \"VK_HOME\", \"VK_LEFT\", \"VK_UP\", \"VK_RIGHT\", \"VK_DOWN\", \"VK_SELECT\", \"VK_PRINT\", \"VK_EXECUTE\", \"VK_SNAPSHOT\", \"VK_INSERT\", \"VK_DELETE\", \"VK_HELP\", \"VK_0\", \"VK_1\", \"VK_2\", \"VK_3\", \"VK_4\", \"VK_5\", \"VK_6\", \"VK_7\", \"VK_8\", \"VK_9\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_A\", \"VK_B\", \"VK_C\", \"VK_D\", \"VK_E\", \"VK_F\", \"VK_G\", \"VK_H\", \"VK_I\", \"VK_J\", \"VK_K\", \"VK_L\", \"VK_M\", \"VK_N\", \"VK_O\", \"VK_P\", \"VK_Q\", \"VK_R\", \"VK_S\", \"VK_T\", \"VK_U\", \"VK_V\", \"VK_W\", \"VK_X\", \"VK_Y\", \"VK_Z\", \"VK_STARTKEY\", \"\", \"VK_CONTEXTKEY\", \"\", \"\", \"VK_NUMPAD0\", \"VK_NUMPAD1\", \"VK_NUMPAD2\", \"VK_NUMPAD3\", \"VK_NUMPAD4\", \"VK_NUMPAD5\", \"VK_NUMPAD6\", \"VK_NUMPAD7\", \"VK_NUMPAD8\", \"VK_NUMPAD9\", \"VK_MULTIPLY\", \"VK_ADD\", \"VK_SEPARATOR\", \"VK_SUBTRACT\", \"VK_DECIMAL\", \"VK_DIVIDE\", \"VK_F1\", \"VK_F2\", \"VK_F3\", \"VK_F4\", \"VK_F5\", \"VK_F6\", \"VK_F7\", \"VK_F8\", \"VK_F9\", \"VK_F10\", \"VK_F11\", \"VK_F12\", \"VK_F13\", \"VK_F14\", \"VK_F15\", \"VK_F16\", \"VK_F17\", \"VK_F18\", \"VK_F19\", \"VK_F20\", \"VK_F21\", \"VK_F22\", \"VK_F23\", \"VK_F24\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_NUMLOCK\", \"VK_OEM_SCROLL\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_OEM_1\", \"VK_OEM_PLUS\", \"VK_OEM_COMMA\", \"VK_OEM_MINUS\", \"VK_OEM_PERIOD\", \"VK_OEM_2\", \"VK_OEM_3\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_OEM_4\", \"VK_OEM_5\", \"VK_OEM_6\", \"VK_OEM_7\", \"VK_OEM_8\", \"VK_ICO_F17\", \"VK_ICO_F18\", \"VK_OEM_102\", \"VK_ICO_HELP\", \"VK_ICO_00\", \"\", \"VK_ICO_CLEAR\", \"\", \"\", \"VK_OEM_RESET\", \"VK_OEM_JUMP\", \"VK_OEM_PA1\", \"VK_OEM_PA2\", \"VK_OEM_PA3\", \"VK_OEM_WSCTRL\", \"VK_OEM_CUSEL\", \"VK_OEM_ATTN\", \"VK_OEM_FINNISH\", \"VK_OEM_COPY\", \"VK_OEM_AUTO\", \"VK_OEM_ENLW\", \"VK_OEM_BACKTAB\", \"VK_ATTN\", \"VK_CRSEL\", \"VK_EXSEL\", \"VK_EREOF\", \"VK_PLAY\", \"VK_ZOOM\", \"VK_NONAME\", \"VK_PA1\", \"VK_OEM_CLEAR\", \"\", } ---------------------------------------------------------------------------------------------------------- function msg(param, clr) if clr then reaper.ClearConsole() end reaper.ShowConsoleMsg(tostring(param)..\"\n\n\") end ---------------------------------------------------------------------------------------------------------- function main() time_now = reaper.time_precise() -- keys_state = reaper.JS_VKeys_GetState(time_keys_prev):sub(key_low, key_hi) keys_down = reaper.JS_VKeys_GetDown(time_keys_prev):sub(key_low, key_hi) do_quit = false if keys_down ~= keys_prev and keys_down ~= keys_zero then local p = 0 repeat p = keys_down:find(\"\\1\", p+1) if p then if keys_prev:byte(p) == 0 then asc_code = key_low + p - 1 if asc_code == 27 then do_quit = true end msg(string.format(\"key=\\'%c\\' %03d $%02x %s\", asc_code, asc_code, asc_code, KEYCODES_NAME[asc_code])) end end until p == nil end time_keys_prev = time_now -- keys_prev = keys_state keys_prev = keys_down gfx.x, gfx.y = 10, 10 gfx.drawstr(\"Press keys, then copy console\") gfx.x, gfx.y = 10, 30 gfx.drawstr(\"Press Esc when done!\") gfx.update() if not(do_quit or gfx.getchar() == -1) then reaper.defer(main) end end ----------------------------------------------------------------------------------------- function quit() gfx.quit() reaper.JS_VKeys_Intercept(-1, -1) end ----------------------------------------------------------------------------------------- msg(\"\",true) gfx.init(\"key tests\", 300, 100, 0, 50,50) reaper.atexit(quit) reaper.JS_VKeys_Intercept(-1, 1) main() So it seems to work,but I have interrogations :- does it work only on windows ?- does it work on any \"local\" keyboard (qwerty, azerty)And it works even if the script is not focused ! (contrary to gfx.getchar())Note that the JS_VKeys_Intercept function behaves sometimes strangely:it allows to block the transmission of the captured key to Reaper, which can be nice,except (at least) the SPACE key (PLAY that might be more hardcoded ?).-------So here is my test code (needs JS-extension).If a MAC and/or LINUX user can test it, it would be niceAnd also a WINDOW user with QWERTY keyboard (I have AZERTY)Please Type a, z, e, a, s, d, z, x, c, F1, F12, and these special keys that are local-specific (;:!,<*ù$^=²)And post a copy of the console text, with eventually comments on special keys, so that I can recognize where they are on your keyboard... Last edited by binbinhfr; 10-27-2022 at .\n\n\n\n \n\n Took a few hours to make it work, so through I'd share. It doesn't run any code in the background.\n\n \n\n EDIT: been using if for some days and made it work even better:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local keysObj = { _13 = 'enter', _27 = 'escape', _16 = 'shift', _17 = 'cmd', _18 = 'alt', _91 = 'ctrl', _37 = 'left', _38 = 'up', _39 = 'right', _40 = 'down', _43 = '+', _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _48 = 0, _65 = 'A', _66 = 'B', _67 = 'C', _68 = 'D', _69 = 'E', _70 = 'F', _71 = 'G', _72 = 'H', _73 = 'I', _74 = 'J', _75 = 'K', _76 = 'L', _77 = 'M', _78 = 'N', _79 = 'O', _80 = 'P', _81 = 'Q', _82 = 'R', _83 = 'S', _84 = 'T', _85 = 'U', _86 = 'V', _87 = 'W', _88 = 'X', _89 = 'Y', _90 = 'Z', _230 = 'æ', _248 = 'ø', _229 = 'å', _198 = 'Æ', _216 = 'Ø', _197 = 'Å', _44 = ',', _46 = '.', _59 = ';', _58 = ':', _96 = 0, _97 = 1, _98 = 2, _99 = 3, _100 = 4, _101 = 5, _102 = 6, _103 = 7, _104 = 8, _105 = 9, _106 = '*', _107 = '+', _108 = '=', _109 = '-', _110 = ',', _111 = '/', _144 = 'clear' } cmd = false shift = false alt = false ctrl = false if reaper.APIExists(\"JS_VKeys_Intercept\") then for i = 0, 255 do -- What key is down? if reaper.JS_VKeys_GetState(0):byte(i) == 1 then local keyPress = keysObj['_' .. i] if keyPress == nil then reaper.ShowConsoleMsg('Key not mapped: ' .. i .. '\n\n') else if keyPress == 'alt' then alt = true elseif keyPress == 'shift'then shift = true elseif keyPress == 'cmd' then cmd = true elseif keyPress == 'ctrl' then ctrl = true else mainKey = keyPress end end reaper.JS_VKeys_Intercept(i, -1) end end else reaper.MB(\"This script requires the js_ReaScriptAPI extension!\", \"Missing API\", 0) reaper.defer(function () end) end if mainKey then main(mainKey) end This works for meTook a few hours to make it work, so through I'd share. It doesn't run any code in the background.EDIT: been using if for some days and made it work even better: Last edited by saxmand; 12-15-2023 at .\n\n\n\n \n\n So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands. \n\n \n\n Below is what I have so far:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context() local KEYCODES = { _1 = \"The left mouse button\", _2 = \"The right mouse button\", _3 = \"The Cancel virtual key, used for control-break processing\", _4 = \"The middle mouse button\", _8 = \"Backspace\", _9 = \"Tab\", _12 = \"5 (keypad without Num Lock)\", _13 = \"Enter\", _16 = \"Shift (either one)\", _17 = \"Ctrl (either one)\", _18 = \"Alt (either one)\", _19 = \"Pause\", _20 = \"Caps Lock\", _27 = \"Esc\", _32 = \"Spacebar\", _33 = \"Page Up\", _34 = \"Page Down\", _35 = \"End\", _36 = \"Home\", _37 = \"Left Arrow\", _38 = \"Up Arrow\", _32807 = \"Right Arrow\", _32808 = \"Down Arrow\", _32805 = \"Left Arrow\", _32806 = \"Up Arrow\", _39 = \"Right Arrow\", _40 = \"Down Arrow\", _41 = \"Select\", _42 = \"Print (only used by Nokia keyboards)\", _43 = \"Execute (not used)\", _44 = \"Print Screen\", _45 = \"Insert\", _46 = \"Delete\", _47 = \"Help\", _48 = 0, _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _65 = \"A\", _66 = \"B\", _67 = \"C\", _68 = \"D\", _69 = \"E\", _70 = \"F\", _71 = \"G\", _72 = \"H\", _73 = \"I\", _74 = \"J\", _75 = \"K\", _76 = \"L\", _77 = \"M\", _78 = \"N\", _79 = \"O\", _80 = \"P\", _81 = \"Q\", _82 = \"R\", _83 = \"S\", _84 = \"T\", _85 = \"U\", _86 = \"V\", _87 = \"W\", _88 = \"X\", _89 = \"Y\", _90 = \"Z\", _91 = \"Start Menu key\", _93 = \"Context Menu key\", _96 = 0, --keypad _97 = 1, --keypad _98 = 2, --keypad _99 = 3, --keypad _100 = 4, --keypad _101 = 5, --keypad _102 = 6, --keypad _103 = 7, --keypad _104 = 8, --keypad _105 = 9, --keypad _106 = \"keypad *\", --keypad _107 = \"keypad +\", --keypad _108 = \"keypad =\", _109 = \"keypad -\", --keypad _110 = \"keypad .\", --keypad _111 = \"keypad /\", --keypad _112 = \"F1\", _113 = \"F2\", _114 = \"F3\", _115 = \"F4\", _116 = \"F5\", _117 = \"F6\", _118 = \"F7\", _119 = \"F8\", _120 = \"F9\", _121 = \"F10\", _122 = \"F11\", _123 = \"F12\", _124 = \"F13\", _125 = \"F14\", _126 = \"F15\", _127 = \"F16\", _128 = \"F17\", _129 = \"F18\", _130 = \"F19\", _131 = \"F20\", _132 = \"F21\", _133 = \"F22\", _134 = \"F23\", _135 = \"F24\", _144 = \"Num Lock\", _145 = \"Scroll Lock\", _186 = \";\", _187 = \"=\", _188 = \",\", _189 = \"-\", _190 = \".\", _191 = \"/\", _192 = \"`\", _219 = \"[\", _220 = \"\\\\\", _221 = \"]\", _222 = \"'\", _223 = \"(unknown)\" } --contextstr = \"key:VSW:100\" isKey = string.sub(contextstr,1,3) == 'key' inputStr = string.sub(contextstr,5) or \"\" positionOfSplit = string.find(inputStr, \":\") or 0 keys = string.sub(inputStr,1,positionOfSplit -1) number = string.sub(inputStr,positionOfSplit+1) alt = string.match(keys, \"A\") == \"A\" shift = string.match(keys, \"S\") == \"S\" cmd = string.match(keys, \"C\") == \"C\" ctrl = string.match(keys, \"W\") == \"W\" mainKey = KEYCODES[\"_\" .. number] or \"\" --[[ reaper.ShowConsoleMsg( \"isKey: \" .. tostring(isKey)..\"\n\n\" .. \"inputStr: \" .. inputStr .. \"\n\n\" .. \"keys: \" .. keys .. \"\n\n\" .. \"alt: \" .. tostring(alt) .. \"\n\n\" .. \"shift: \" .. tostring(shift) .. \"\n\n\" .. \"cmd: \" .. tostring(cmd) .. \"\n\n\" .. \"ctrl: \" .. tostring(ctrl) .. \"\n\n\" .. \"mainKey: \" .. mainKey .. \"\n\n\" )]]-- if mainKey ~= \"\" then main(mainKey) end For anyone that'll maybe find this topic later:So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands.Below is what I have so far: __________________\n\n Trying to make Reaper the best DAW for film composing!\n\n\n\n Location: Somewhere over the Rainbow \n\n \n\n So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands. \n\n \n\n Below is what I have so far:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context() local KEYCODES = { _1 = \"The left mouse button\", _2 = \"The right mouse button\", _3 = \"The Cancel virtual key, used for control-break processing\", _4 = \"The middle mouse button\", _8 = \"Backspace\", _9 = \"Tab\", _12 = \"5 (keypad without Num Lock)\", _13 = \"Enter\", _16 = \"Shift (either one)\", _17 = \"Ctrl (either one)\", _18 = \"Alt (either one)\", _19 = \"Pause\", _20 = \"Caps Lock\", _27 = \"Esc\", _32 = \"Spacebar\", _33 = \"Page Up\", _34 = \"Page Down\", _35 = \"End\", _36 = \"Home\", _37 = \"Left Arrow\", _38 = \"Up Arrow\", _32807 = \"Right Arrow\", _32808 = \"Down Arrow\", _32805 = \"Left Arrow\", _32806 = \"Up Arrow\", _39 = \"Right Arrow\", _40 = \"Down Arrow\", _41 = \"Select\", _42 = \"Print (only used by Nokia keyboards)\", _43 = \"Execute (not used)\", _44 = \"Print Screen\", _45 = \"Insert\", _46 = \"Delete\", _47 = \"Help\", _48 = 0, _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _65 = \"A\", _66 = \"B\", _67 = \"C\", _68 = \"D\", _69 = \"E\", _70 = \"F\", _71 = \"G\", _72 = \"H\", _73 = \"I\", _74 = \"J\", _75 = \"K\", _76 = \"L\", _77 = \"M\", _78 = \"N\", _79 = \"O\", _80 = \"P\", _81 = \"Q\", _82 = \"R\", _83 = \"S\", _84 = \"T\", _85 = \"U\", _86 = \"V\", _87 = \"W\", _88 = \"X\", _89 = \"Y\", _90 = \"Z\", _91 = \"Start Menu key\", _93 = \"Context Menu key\", _96 = 0, --keypad _97 = 1, --keypad _98 = 2, --keypad _99 = 3, --keypad _100 = 4, --keypad _101 = 5, --keypad _102 = 6, --keypad _103 = 7, --keypad _104 = 8, --keypad _105 = 9, --keypad _106 = \"keypad *\", --keypad _107 = \"keypad +\", --keypad _108 = \"keypad =\", _109 = \"keypad -\", --keypad _110 = \"keypad .\", --keypad _111 = \"keypad /\", --keypad _112 = \"F1\", _113 = \"F2\", _114 = \"F3\", _115 = \"F4\", _116 = \"F5\", _117 = \"F6\", _118 = \"F7\", _119 = \"F8\", _120 = \"F9\", _121 = \"F10\", _122 = \"F11\", _123 = \"F12\", _124 = \"F13\", _125 = \"F14\", _126 = \"F15\", _127 = \"F16\", _128 = \"F17\", _129 = \"F18\", _130 = \"F19\", _131 = \"F20\", _132 = \"F21\", _133 = \"F22\", _134 = \"F23\", _135 = \"F24\", _144 = \"Num Lock\", _145 = \"Scroll Lock\", _186 = \";\", _187 = \"=\", _188 = \",\", _189 = \"-\", _190 = \".\", _191 = \"/\", _192 = \"`\", _219 = \"[\", _220 = \"\\\\\", _221 = \"]\", _222 = \"'\", _223 = \"(unknown)\" } --contextstr = \"key:VSW:100\" isKey = string.sub(contextstr,1,3) == 'key' inputStr = string.sub(contextstr,5) or \"\" positionOfSplit = string.find(inputStr, \":\") or 0 keys = string.sub(inputStr,1,positionOfSplit -1) number = string.sub(inputStr,positionOfSplit+1) alt = string.match(keys, \"A\") == \"A\" shift = string.match(keys, \"S\") == \"S\" cmd = string.match(keys, \"C\") == \"C\" ctrl = string.match(keys, \"W\") == \"W\" mainKey = KEYCODES[\"_\" .. number] or \"\" --[[ reaper.ShowConsoleMsg( \"isKey: \" .. tostring(isKey)..\"\n\n\" .. \"inputStr: \" .. inputStr .. \"\n\n\" .. \"keys: \" .. keys .. \"\n\n\" .. \"alt: \" .. tostring(alt) .. \"\n\n\" .. \"shift: \" .. tostring(shift) .. \"\n\n\" .. \"cmd: \" .. tostring(cmd) .. \"\n\n\" .. \"ctrl: \" .. tostring(ctrl) .. \"\n\n\" .. \"mainKey: \" .. mainKey .. \"\n\n\" )]]-- if mainKey ~= \"\" then main(mainKey) end For anyone that'll maybe find this topic later:So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands.Below is what I have so far: Important note: this detects the shortcut with which the action was started, so it's limited to the shortcuts you associated with the action. Important note: this detects the shortcut with which the action was started, so it's limited to the shortcuts you associated with the action. \n\n Use you/she/her.Ultraschall-Api Lua Api4Reaper - ReaGirl - a GuiLib for guis working for blind people"
    },
    {
        "link": "https://forum.cockos.com/showthread.php?p=2608281",
        "document": "I'd have literally NO idea how to use that C++ thing within a Lua script, and I wouldn't be at all surprised to hear it's impossible.\n\n \n\n I'm really quite new to this - the last time I wrote any computer code was at University in the 1980s!!\n\n \n\n Doing OK with Lua for now, and managing to make some scripts that are really useful in my workflow, but nothing too complex :-)\n\n \n\n The reason for asking this was to see if it might help with the Undo problem discussed here: \n\n \n\n https://forum.cockos.com/showthread.php?t=211932\n\n \n\n (ie if a script could intercept keyboard commands then it could continue performing an action as the key was repeatedly pressed, then after a certain \"timeout\" of no presses, it could exit and make an Undo point).\n\n \n\n But it sounds like it's a blind alley. Thanks again.I'd have literally NO idea how to use that C++ thing within a Lua script, and I wouldn't be at all surprised to hear it's impossible.I'm really quite new to this - the last time I wrote any computer code was at University in the 1980s!!Doing OK with Lua for now, and managing to make some scripts that are really useful in my workflow, but nothing too complex :-)The reason for asking this was to see if it might help with the Undo problem discussed here:(ie if a script could intercept keyboard commands then it could continue performing an action as the key was repeatedly pressed, then after a certain \"timeout\" of no presses, it could exit and make an Undo point).But it sounds like it's a blind alley.\n\n\n\n Location: Somewhere over the Rainbow \n\n \n\n \n\n \n\n https://gist.github.com/cfillion/d86...fd7b2ea82f7ff6 Keyboard input can be intercepted globally (within REAPER) using accelerator_register_t from the C++ extension API. Oh, that's great \n\n \n\n How difficult would it be to add it to Julian's plugin?\n\n \n\n @andyp24\n\n You can't use C++-stuff directly from Lua, but if someone adds that as a function into an extension, you could use it, like any other ReaScript-API-function.\n\n You would just need to install that extension that contains this new function. Oh, that's greatHow difficult would it be to add it to Julian's plugin?@andyp24You can't use C++-stuff directly from Lua, but if someone adds that as a function into an extension, you could use it, like any other ReaScript-API-function.You would just need to install that extension that contains this new function. \n\n Use you/she/her.Ultraschall-Api Lua Api4Reaper - ReaGirl - a GuiLib for guis working for blind people\n\n\n\n but I have interrogations : \n\n - does it work only on windows ?\n\n - does it work on any \"local\" keyboard (qwerty, azerty)\n\n \n\n And it works even if the script is not focused ! (contrary to gfx.getchar())\n\n Note that the JS_VKeys_Intercept function behaves sometimes strangely: \n\n it allows to block the transmission of the captured key to Reaper, which can be nice,\n\n except (at least) the SPACE key (PLAY that might be more hardcoded ?).\n\n \n\n -------\n\n \n\n So here is my test code (needs JS-extension).\n\n If a MAC and/or LINUX user can test it, it would be nice\n\n And also a WINDOW user with QWERTY keyboard (I have AZERTY)\n\n \n\n Please Type a, z, e, a, s, d, z, x, c, F1, F12, and these special keys that are local-specific (;:!,<*ù$^=²)\n\n \n\n And post a copy of the console text, with eventually comments on special keys, so that I can recognize where they are on your keyboard...\n\n \n\n ---------------------------------------------------------------------------------------------------------- key_low, key_hi = 8, 0xFE --0xA5 -- Range of virtual key codes to check for key presses keys_zero = string.rep(\"\\0\", key_hi-key_low+1) -- For quick comparison to zero state keys_state = \"\" -- states of key currently pressed keys_down = \"\" -- keys pressed since last call keys_prev = \"\" time_keys_prev = 0.0 KEYCODES = { VK_LBUTTON = 0x01, -- The left mouse button VK_RBUTTON = 0x02, -- The right mouse button VK_CANCEL = 0x03, -- The Cancel virtual key, used for control-break processing VK_MBUTTON = 0x04, -- The middle mouse button VK_BACK = 0x08, -- Backspace VK_TAB = 0x09, -- Tab VK_CLEAR = 0x0C, -- 5 (keypad without Num Lock) VK_ENTER = 0x0D, -- Enter VK_SHIFT = 0x10, -- Shift (either one) VK_CONTROL = 0x11, -- Ctrl (either one) VK_MENU = 0x12, -- Alt (either one) VK_PAUSE = 0x13, -- Pause VK_CAPITAL = 0x14, -- Caps Lock VK_ESCAPE = 0x1B, -- Esc VK_SPACE = 0x20, -- Spacebar VK_PAGEUP = 0x21, -- Page Up VK_PAGEDOWN = 0x22, -- Page Down VK_END = 0x23, -- End VK_HOME = 0x24, -- Home VK_LEFT = 0x25, -- Left Arrow VK_UP = 0x26, -- Up Arrow VK_RIGHT = 0x27, -- Right Arrow VK_DOWN = 0x28, -- Down Arrow VK_SELECT = 0x29, -- Select VK_PRINT = 0x2A, -- Print (only used by Nokia keyboards) VK_EXECUTE = 0x2B, -- Execute (not used) VK_SNAPSHOT = 0x2C, -- Print Screen VK_INSERT = 0x2D, -- Insert VK_DELETE = 0x2E, -- Delete VK_HELP = 0x2F, -- Help VK_0 = 0x30, -- 0 VK_1 = 0x31, -- 1 VK_2 = 0x32, -- 2 VK_3 = 0x33, -- 3 VK_4 = 0x34, -- 4 VK_5 = 0x35, -- 5 VK_6 = 0x36, -- 6 VK_7 = 0x37, -- 7 VK_8 = 0x38, -- 8 VK_9 = 0x39, -- 9 VK_A = 0x41, -- A VK_B = 0x42, -- B VK_C = 0x43, -- C VK_D = 0x44, -- D VK_E = 0x45, -- E VK_F = 0x46, -- F VK_G = 0x47, -- G VK_H = 0x48, -- H VK_I = 0x49, -- I VK_J = 0x4A, -- J VK_K = 0x4B, -- K VK_L = 0x4C, -- L VK_M = 0x4D, -- M VK_N = 0x4E, -- N VK_O = 0x4F, -- O VK_P = 0x50, -- P VK_Q = 0x51, -- Q VK_R = 0x52, -- R VK_S = 0x53, -- S VK_T = 0x54, -- T VK_U = 0x55, -- U VK_V = 0x56, -- V VK_W = 0x57, -- W VK_X = 0x58, -- X VK_Y = 0x59, -- Y VK_Z = 0x5A, -- Z VK_STARTKEY = 0x5B, -- Start Menu key VK_CONTEXTKEY = 0x5D, -- Context Menu key VK_NUMPAD0 = 0x60, -- 0 (keypad with Num Lock) VK_NUMPAD1 = 0x61, -- 1 (keypad with Num Lock) VK_NUMPAD2 = 0x62, -- 2 (keypad with Num Lock) VK_NUMPAD3 = 0x63, -- 3 (keypad with Num Lock) VK_NUMPAD4 = 0x64, -- 4 (keypad with Num Lock) VK_NUMPAD5 = 0x65, -- 5 (keypad with Num Lock) VK_NUMPAD6 = 0x66, -- 6 (keypad with Num Lock) VK_NUMPAD7 = 0x67, -- 7 (keypad with Num Lock) VK_NUMPAD8 = 0x68, -- 8 (keypad with Num Lock) VK_NUMPAD9 = 0x69, -- 9 (keypad with Num Lock) VK_MULTIPLY = 0x6A, -- * (keypad) VK_ADD = 0x6B, -- = 0x(keypad) VK_SEPARATOR = 0x6C, -- Separator (never generated by the keyboard) VK_SUBTRACT = 0x6D, -- - (keypad) VK_DECIMAL = 0x6E, -- . (keypad with Num Lock) VK_DIVIDE = 0x6F, -- / (keypad) VK_F1 = 0x70, -- F1 VK_F2 = 0x71, -- F2 VK_F3 = 0x72, -- F3 VK_F4 = 0x73, -- F4 VK_F5 = 0x74, -- F5 VK_F6 = 0x75, -- F6 VK_F7 = 0x76, -- F7 VK_F8 = 0x77, -- F8 VK_F9 = 0x78, -- F9 VK_F10 = 0x79, -- F10 VK_F11 = 0x7A, -- F11 VK_F12 = 0x7B, -- F12 VK_F13 = 0x7C, -- F13 VK_F14 = 0x7D, -- F14 VK_F15 = 0x7E, -- F15 VK_F16 = 0x7F, -- F16 VK_F17 = 0x80, -- F17 VK_F18 = 0x81, -- F18 VK_F19 = 0x82, -- F19 VK_F20 = 0x83, -- F20 VK_F21 = 0x84, -- F21 VK_F22 = 0x85, -- F22 VK_F23 = 0x86, -- F23 VK_F24 = 0x87, -- F24 VK_NUMLOCK = 0x90, -- Num Lock VK_OEM_SCROLL = 0x91, -- Scroll Lock VK_OEM_1 = 0xBA, -- ; VK_OEM_PLUS = 0xBB, -- = VK_OEM_COMMA = 0xBC, -- , VK_OEM_MINUS = 0xBD, -- - VK_OEM_PERIOD = 0xBE, -- . VK_OEM_2 = 0xBF, -- / VK_OEM_3 = 0xC0, -- ` VK_OEM_4 = 0xDB, -- [ VK_OEM_5 = 0xDC, -- \\ VK_OEM_6 = 0xDD, -- ] VK_OEM_7 = 0xDE, -- ' VK_OEM_8 = 0xDF, -- (unknown) VK_ICO_F17 = 0xE0, -- F17 on Olivetti extended keyboard (internal use only) VK_ICO_F18 = 0xE1, -- F18 on Olivetti extended keyboard (internal use only) VK_OEM_102 = 0xE2, -- < or | on IBM-compatible 102 enhanced non-U.S. keyboard VK_ICO_HELP = 0xE3, -- Help on Olivetti extended keyboard (internal use only) VK_ICO_00 = 0xE4, -- 00 on Olivetti extended keyboard (internal use only) VK_ICO_CLEAR = 0xE6, -- Clear on Olivette extended keyboard (internal use only) VK_OEM_RESET = 0xE9, -- Reset (Nokia keyboards only) VK_OEM_JUMP = 0xEA, -- Jump (Nokia keyboards only) VK_OEM_PA1 = 0xEB, -- PA1 (Nokia keyboards only) VK_OEM_PA2 = 0xEC, -- PA2 (Nokia keyboards only) VK_OEM_PA3 = 0xED, -- PA3 (Nokia keyboards only) VK_OEM_WSCTRL = 0xEE, -- WSCTRL (Nokia keyboards only) VK_OEM_CUSEL = 0xEF, -- CUSEL (Nokia keyboards only) VK_OEM_ATTN = 0xF0, -- ATTN (Nokia keyboards only) VK_OEM_FINNISH = 0xF1, -- FINNISH (Nokia keyboards only) VK_OEM_COPY = 0xF2, -- COPY (Nokia keyboards only) VK_OEM_AUTO = 0xF3, -- AUTO (Nokia keyboards only) VK_OEM_ENLW = 0xF4, -- ENLW (Nokia keyboards only) VK_OEM_BACKTAB = 0xF5, -- BACKTAB (Nokia keyboards only) VK_ATTN = 0xF6, -- ATTN VK_CRSEL = 0xF7, -- CRSEL VK_EXSEL = 0xF8, -- EXSEL VK_EREOF = 0xF9, -- EREOF VK_PLAY = 0xFA, -- PLAY VK_ZOOM = 0xFB, -- ZOOM VK_NONAME = 0xFC, -- NONAME VK_PA1 = 0xFD, -- PA1 VK_OEM_CLEAR = 0xFE, -- CLEAR } KEYCODES_NAME = { \"VK_LBUTTON\", \"VK_RBUTTON\", \"VK_CANCEL\", \"VK_MBUTTON\", \"\", \"\", \"\", \"VK_BACK\", \"VK_TAB\", \"\", \"\", \"VK_CLEAR\", \"VK_ENTER\", \"\", \"\", \"VK_SHIFT\", \"VK_CONTROL\", \"VK_MENU\", \"VK_PAUSE\", \"VK_CAPITAL\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_ESCAPE\", \"\", \"\", \"\", \"\", \"VK_SPACE\", \"VK_PAGEUP\", \"VK_PAGEDOWN\", \"VK_END\", \"VK_HOME\", \"VK_LEFT\", \"VK_UP\", \"VK_RIGHT\", \"VK_DOWN\", \"VK_SELECT\", \"VK_PRINT\", \"VK_EXECUTE\", \"VK_SNAPSHOT\", \"VK_INSERT\", \"VK_DELETE\", \"VK_HELP\", \"VK_0\", \"VK_1\", \"VK_2\", \"VK_3\", \"VK_4\", \"VK_5\", \"VK_6\", \"VK_7\", \"VK_8\", \"VK_9\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_A\", \"VK_B\", \"VK_C\", \"VK_D\", \"VK_E\", \"VK_F\", \"VK_G\", \"VK_H\", \"VK_I\", \"VK_J\", \"VK_K\", \"VK_L\", \"VK_M\", \"VK_N\", \"VK_O\", \"VK_P\", \"VK_Q\", \"VK_R\", \"VK_S\", \"VK_T\", \"VK_U\", \"VK_V\", \"VK_W\", \"VK_X\", \"VK_Y\", \"VK_Z\", \"VK_STARTKEY\", \"\", \"VK_CONTEXTKEY\", \"\", \"\", \"VK_NUMPAD0\", \"VK_NUMPAD1\", \"VK_NUMPAD2\", \"VK_NUMPAD3\", \"VK_NUMPAD4\", \"VK_NUMPAD5\", \"VK_NUMPAD6\", \"VK_NUMPAD7\", \"VK_NUMPAD8\", \"VK_NUMPAD9\", \"VK_MULTIPLY\", \"VK_ADD\", \"VK_SEPARATOR\", \"VK_SUBTRACT\", \"VK_DECIMAL\", \"VK_DIVIDE\", \"VK_F1\", \"VK_F2\", \"VK_F3\", \"VK_F4\", \"VK_F5\", \"VK_F6\", \"VK_F7\", \"VK_F8\", \"VK_F9\", \"VK_F10\", \"VK_F11\", \"VK_F12\", \"VK_F13\", \"VK_F14\", \"VK_F15\", \"VK_F16\", \"VK_F17\", \"VK_F18\", \"VK_F19\", \"VK_F20\", \"VK_F21\", \"VK_F22\", \"VK_F23\", \"VK_F24\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_NUMLOCK\", \"VK_OEM_SCROLL\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_OEM_1\", \"VK_OEM_PLUS\", \"VK_OEM_COMMA\", \"VK_OEM_MINUS\", \"VK_OEM_PERIOD\", \"VK_OEM_2\", \"VK_OEM_3\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"VK_OEM_4\", \"VK_OEM_5\", \"VK_OEM_6\", \"VK_OEM_7\", \"VK_OEM_8\", \"VK_ICO_F17\", \"VK_ICO_F18\", \"VK_OEM_102\", \"VK_ICO_HELP\", \"VK_ICO_00\", \"\", \"VK_ICO_CLEAR\", \"\", \"\", \"VK_OEM_RESET\", \"VK_OEM_JUMP\", \"VK_OEM_PA1\", \"VK_OEM_PA2\", \"VK_OEM_PA3\", \"VK_OEM_WSCTRL\", \"VK_OEM_CUSEL\", \"VK_OEM_ATTN\", \"VK_OEM_FINNISH\", \"VK_OEM_COPY\", \"VK_OEM_AUTO\", \"VK_OEM_ENLW\", \"VK_OEM_BACKTAB\", \"VK_ATTN\", \"VK_CRSEL\", \"VK_EXSEL\", \"VK_EREOF\", \"VK_PLAY\", \"VK_ZOOM\", \"VK_NONAME\", \"VK_PA1\", \"VK_OEM_CLEAR\", \"\", } ---------------------------------------------------------------------------------------------------------- function msg(param, clr) if clr then reaper.ClearConsole() end reaper.ShowConsoleMsg(tostring(param)..\"\n\n\") end ---------------------------------------------------------------------------------------------------------- function main() time_now = reaper.time_precise() -- keys_state = reaper.JS_VKeys_GetState(time_keys_prev):sub(key_low, key_hi) keys_down = reaper.JS_VKeys_GetDown(time_keys_prev):sub(key_low, key_hi) do_quit = false if keys_down ~= keys_prev and keys_down ~= keys_zero then local p = 0 repeat p = keys_down:find(\"\\1\", p+1) if p then if keys_prev:byte(p) == 0 then asc_code = key_low + p - 1 if asc_code == 27 then do_quit = true end msg(string.format(\"key=\\'%c\\' %03d $%02x %s\", asc_code, asc_code, asc_code, KEYCODES_NAME[asc_code])) end end until p == nil end time_keys_prev = time_now -- keys_prev = keys_state keys_prev = keys_down gfx.x, gfx.y = 10, 10 gfx.drawstr(\"Press keys, then copy console\") gfx.x, gfx.y = 10, 30 gfx.drawstr(\"Press Esc when done!\") gfx.update() if not(do_quit or gfx.getchar() == -1) then reaper.defer(main) end end ----------------------------------------------------------------------------------------- function quit() gfx.quit() reaper.JS_VKeys_Intercept(-1, -1) end ----------------------------------------------------------------------------------------- msg(\"\",true) gfx.init(\"key tests\", 300, 100, 0, 50,50) reaper.atexit(quit) reaper.JS_VKeys_Intercept(-1, 1) main() So it seems to work,but I have interrogations :- does it work only on windows ?- does it work on any \"local\" keyboard (qwerty, azerty)And it works even if the script is not focused ! (contrary to gfx.getchar())Note that the JS_VKeys_Intercept function behaves sometimes strangely:it allows to block the transmission of the captured key to Reaper, which can be nice,except (at least) the SPACE key (PLAY that might be more hardcoded ?).-------So here is my test code (needs JS-extension).If a MAC and/or LINUX user can test it, it would be niceAnd also a WINDOW user with QWERTY keyboard (I have AZERTY)Please Type a, z, e, a, s, d, z, x, c, F1, F12, and these special keys that are local-specific (;:!,<*ù$^=²)And post a copy of the console text, with eventually comments on special keys, so that I can recognize where they are on your keyboard... Last edited by binbinhfr; 10-27-2022 at .\n\n\n\n \n\n Took a few hours to make it work, so through I'd share. It doesn't run any code in the background.\n\n \n\n EDIT: been using if for some days and made it work even better:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local keysObj = { _13 = 'enter', _27 = 'escape', _16 = 'shift', _17 = 'cmd', _18 = 'alt', _91 = 'ctrl', _37 = 'left', _38 = 'up', _39 = 'right', _40 = 'down', _43 = '+', _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _48 = 0, _65 = 'A', _66 = 'B', _67 = 'C', _68 = 'D', _69 = 'E', _70 = 'F', _71 = 'G', _72 = 'H', _73 = 'I', _74 = 'J', _75 = 'K', _76 = 'L', _77 = 'M', _78 = 'N', _79 = 'O', _80 = 'P', _81 = 'Q', _82 = 'R', _83 = 'S', _84 = 'T', _85 = 'U', _86 = 'V', _87 = 'W', _88 = 'X', _89 = 'Y', _90 = 'Z', _230 = 'æ', _248 = 'ø', _229 = 'å', _198 = 'Æ', _216 = 'Ø', _197 = 'Å', _44 = ',', _46 = '.', _59 = ';', _58 = ':', _96 = 0, _97 = 1, _98 = 2, _99 = 3, _100 = 4, _101 = 5, _102 = 6, _103 = 7, _104 = 8, _105 = 9, _106 = '*', _107 = '+', _108 = '=', _109 = '-', _110 = ',', _111 = '/', _144 = 'clear' } cmd = false shift = false alt = false ctrl = false if reaper.APIExists(\"JS_VKeys_Intercept\") then for i = 0, 255 do -- What key is down? if reaper.JS_VKeys_GetState(0):byte(i) == 1 then local keyPress = keysObj['_' .. i] if keyPress == nil then reaper.ShowConsoleMsg('Key not mapped: ' .. i .. '\n\n') else if keyPress == 'alt' then alt = true elseif keyPress == 'shift'then shift = true elseif keyPress == 'cmd' then cmd = true elseif keyPress == 'ctrl' then ctrl = true else mainKey = keyPress end end reaper.JS_VKeys_Intercept(i, -1) end end else reaper.MB(\"This script requires the js_ReaScriptAPI extension!\", \"Missing API\", 0) reaper.defer(function () end) end if mainKey then main(mainKey) end This works for meTook a few hours to make it work, so through I'd share. It doesn't run any code in the background.EDIT: been using if for some days and made it work even better: Last edited by saxmand; 12-15-2023 at .\n\n\n\n \n\n So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands. \n\n \n\n Below is what I have so far:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context() local KEYCODES = { _1 = \"The left mouse button\", _2 = \"The right mouse button\", _3 = \"The Cancel virtual key, used for control-break processing\", _4 = \"The middle mouse button\", _8 = \"Backspace\", _9 = \"Tab\", _12 = \"5 (keypad without Num Lock)\", _13 = \"Enter\", _16 = \"Shift (either one)\", _17 = \"Ctrl (either one)\", _18 = \"Alt (either one)\", _19 = \"Pause\", _20 = \"Caps Lock\", _27 = \"Esc\", _32 = \"Spacebar\", _33 = \"Page Up\", _34 = \"Page Down\", _35 = \"End\", _36 = \"Home\", _37 = \"Left Arrow\", _38 = \"Up Arrow\", _32807 = \"Right Arrow\", _32808 = \"Down Arrow\", _32805 = \"Left Arrow\", _32806 = \"Up Arrow\", _39 = \"Right Arrow\", _40 = \"Down Arrow\", _41 = \"Select\", _42 = \"Print (only used by Nokia keyboards)\", _43 = \"Execute (not used)\", _44 = \"Print Screen\", _45 = \"Insert\", _46 = \"Delete\", _47 = \"Help\", _48 = 0, _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _65 = \"A\", _66 = \"B\", _67 = \"C\", _68 = \"D\", _69 = \"E\", _70 = \"F\", _71 = \"G\", _72 = \"H\", _73 = \"I\", _74 = \"J\", _75 = \"K\", _76 = \"L\", _77 = \"M\", _78 = \"N\", _79 = \"O\", _80 = \"P\", _81 = \"Q\", _82 = \"R\", _83 = \"S\", _84 = \"T\", _85 = \"U\", _86 = \"V\", _87 = \"W\", _88 = \"X\", _89 = \"Y\", _90 = \"Z\", _91 = \"Start Menu key\", _93 = \"Context Menu key\", _96 = 0, --keypad _97 = 1, --keypad _98 = 2, --keypad _99 = 3, --keypad _100 = 4, --keypad _101 = 5, --keypad _102 = 6, --keypad _103 = 7, --keypad _104 = 8, --keypad _105 = 9, --keypad _106 = \"keypad *\", --keypad _107 = \"keypad +\", --keypad _108 = \"keypad =\", _109 = \"keypad -\", --keypad _110 = \"keypad .\", --keypad _111 = \"keypad /\", --keypad _112 = \"F1\", _113 = \"F2\", _114 = \"F3\", _115 = \"F4\", _116 = \"F5\", _117 = \"F6\", _118 = \"F7\", _119 = \"F8\", _120 = \"F9\", _121 = \"F10\", _122 = \"F11\", _123 = \"F12\", _124 = \"F13\", _125 = \"F14\", _126 = \"F15\", _127 = \"F16\", _128 = \"F17\", _129 = \"F18\", _130 = \"F19\", _131 = \"F20\", _132 = \"F21\", _133 = \"F22\", _134 = \"F23\", _135 = \"F24\", _144 = \"Num Lock\", _145 = \"Scroll Lock\", _186 = \";\", _187 = \"=\", _188 = \",\", _189 = \"-\", _190 = \".\", _191 = \"/\", _192 = \"`\", _219 = \"[\", _220 = \"\\\\\", _221 = \"]\", _222 = \"'\", _223 = \"(unknown)\" } --contextstr = \"key:VSW:100\" isKey = string.sub(contextstr,1,3) == 'key' inputStr = string.sub(contextstr,5) or \"\" positionOfSplit = string.find(inputStr, \":\") or 0 keys = string.sub(inputStr,1,positionOfSplit -1) number = string.sub(inputStr,positionOfSplit+1) alt = string.match(keys, \"A\") == \"A\" shift = string.match(keys, \"S\") == \"S\" cmd = string.match(keys, \"C\") == \"C\" ctrl = string.match(keys, \"W\") == \"W\" mainKey = KEYCODES[\"_\" .. number] or \"\" --[[ reaper.ShowConsoleMsg( \"isKey: \" .. tostring(isKey)..\"\n\n\" .. \"inputStr: \" .. inputStr .. \"\n\n\" .. \"keys: \" .. keys .. \"\n\n\" .. \"alt: \" .. tostring(alt) .. \"\n\n\" .. \"shift: \" .. tostring(shift) .. \"\n\n\" .. \"cmd: \" .. tostring(cmd) .. \"\n\n\" .. \"ctrl: \" .. tostring(ctrl) .. \"\n\n\" .. \"mainKey: \" .. mainKey .. \"\n\n\" )]]-- if mainKey ~= \"\" then main(mainKey) end For anyone that'll maybe find this topic later:So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands.Below is what I have so far: __________________\n\n Trying to make Reaper the best DAW for film composing!\n\n\n\n Location: Somewhere over the Rainbow \n\n \n\n So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands. \n\n \n\n Below is what I have so far:\n\n \n\n local function main(keyPress) -- Your function that you can filter by the different modifiers and keystrokes you'll attach to the command end local is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context() local KEYCODES = { _1 = \"The left mouse button\", _2 = \"The right mouse button\", _3 = \"The Cancel virtual key, used for control-break processing\", _4 = \"The middle mouse button\", _8 = \"Backspace\", _9 = \"Tab\", _12 = \"5 (keypad without Num Lock)\", _13 = \"Enter\", _16 = \"Shift (either one)\", _17 = \"Ctrl (either one)\", _18 = \"Alt (either one)\", _19 = \"Pause\", _20 = \"Caps Lock\", _27 = \"Esc\", _32 = \"Spacebar\", _33 = \"Page Up\", _34 = \"Page Down\", _35 = \"End\", _36 = \"Home\", _37 = \"Left Arrow\", _38 = \"Up Arrow\", _32807 = \"Right Arrow\", _32808 = \"Down Arrow\", _32805 = \"Left Arrow\", _32806 = \"Up Arrow\", _39 = \"Right Arrow\", _40 = \"Down Arrow\", _41 = \"Select\", _42 = \"Print (only used by Nokia keyboards)\", _43 = \"Execute (not used)\", _44 = \"Print Screen\", _45 = \"Insert\", _46 = \"Delete\", _47 = \"Help\", _48 = 0, _49 = 1, _50 = 2, _51 = 3, _52 = 4, _53 = 5, _54 = 6, _55 = 7, _56 = 8, _57 = 9, _65 = \"A\", _66 = \"B\", _67 = \"C\", _68 = \"D\", _69 = \"E\", _70 = \"F\", _71 = \"G\", _72 = \"H\", _73 = \"I\", _74 = \"J\", _75 = \"K\", _76 = \"L\", _77 = \"M\", _78 = \"N\", _79 = \"O\", _80 = \"P\", _81 = \"Q\", _82 = \"R\", _83 = \"S\", _84 = \"T\", _85 = \"U\", _86 = \"V\", _87 = \"W\", _88 = \"X\", _89 = \"Y\", _90 = \"Z\", _91 = \"Start Menu key\", _93 = \"Context Menu key\", _96 = 0, --keypad _97 = 1, --keypad _98 = 2, --keypad _99 = 3, --keypad _100 = 4, --keypad _101 = 5, --keypad _102 = 6, --keypad _103 = 7, --keypad _104 = 8, --keypad _105 = 9, --keypad _106 = \"keypad *\", --keypad _107 = \"keypad +\", --keypad _108 = \"keypad =\", _109 = \"keypad -\", --keypad _110 = \"keypad .\", --keypad _111 = \"keypad /\", --keypad _112 = \"F1\", _113 = \"F2\", _114 = \"F3\", _115 = \"F4\", _116 = \"F5\", _117 = \"F6\", _118 = \"F7\", _119 = \"F8\", _120 = \"F9\", _121 = \"F10\", _122 = \"F11\", _123 = \"F12\", _124 = \"F13\", _125 = \"F14\", _126 = \"F15\", _127 = \"F16\", _128 = \"F17\", _129 = \"F18\", _130 = \"F19\", _131 = \"F20\", _132 = \"F21\", _133 = \"F22\", _134 = \"F23\", _135 = \"F24\", _144 = \"Num Lock\", _145 = \"Scroll Lock\", _186 = \";\", _187 = \"=\", _188 = \",\", _189 = \"-\", _190 = \".\", _191 = \"/\", _192 = \"`\", _219 = \"[\", _220 = \"\\\\\", _221 = \"]\", _222 = \"'\", _223 = \"(unknown)\" } --contextstr = \"key:VSW:100\" isKey = string.sub(contextstr,1,3) == 'key' inputStr = string.sub(contextstr,5) or \"\" positionOfSplit = string.find(inputStr, \":\") or 0 keys = string.sub(inputStr,1,positionOfSplit -1) number = string.sub(inputStr,positionOfSplit+1) alt = string.match(keys, \"A\") == \"A\" shift = string.match(keys, \"S\") == \"S\" cmd = string.match(keys, \"C\") == \"C\" ctrl = string.match(keys, \"W\") == \"W\" mainKey = KEYCODES[\"_\" .. number] or \"\" --[[ reaper.ShowConsoleMsg( \"isKey: \" .. tostring(isKey)..\"\n\n\" .. \"inputStr: \" .. inputStr .. \"\n\n\" .. \"keys: \" .. keys .. \"\n\n\" .. \"alt: \" .. tostring(alt) .. \"\n\n\" .. \"shift: \" .. tostring(shift) .. \"\n\n\" .. \"cmd: \" .. tostring(cmd) .. \"\n\n\" .. \"ctrl: \" .. tostring(ctrl) .. \"\n\n\" .. \"mainKey: \" .. mainKey .. \"\n\n\" )]]-- if mainKey ~= \"\" then main(mainKey) end For anyone that'll maybe find this topic later:So playing around more with this I found that you can get it much easier using the get_action_context function. It needs a bit of string parsing. But with the code below it makes it very easy to have a script that will react differently to different key commands.Below is what I have so far: Important note: this detects the shortcut with which the action was started, so it's limited to the shortcuts you associated with the action. Important note: this detects the shortcut with which the action was started, so it's limited to the shortcuts you associated with the action. \n\n Use you/she/her.Ultraschall-Api Lua Api4Reaper - ReaGirl - a GuiLib for guis working for blind people"
    },
    {
        "link": "https://reaper.fm/sdk/reascript/reascripthelp.html",
        "document": "ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a \n\n\n\n ReaScript/Python scripts can call API functions using .\n\n\n\n All parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).\n\n\n\n Examples:\n\n # function returning a single (scalar) value:\n\n sec = RPR_parse_timestr(\"1:12\")\n\n\n\n # function returning information in the first parameter (function returns void):\n\n (str) = RPR_GetProjectPath(\"\", 512)\n\n\n\n # lower volume of track 3 by half (RPR_GetTrackUIVolPan returns Bool):\n\n tr = RPR_GetTrack(0, 2)\n\n (ok, tr, vol, pan) = RPR_GetTrackUIVolPan(tr, 0, 0)\n\n # this also works, if you only care about one of the returned values:\n\n vol = RPR_GetTrackUIVolPan(tr, 0, 0)[2]\n\n RPR_SetMediaTrackInfo_Value(tr, \"D_VOL\", vol*0.5)\n\n \n\n You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line: and call the function by using: \n\n Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript: \n\n In addition to the \n\n\n\n ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a free download . Python 2.7 is normally included with macOS, and the dynamic library is usually in /usr/lib. If you update to a newer version of Python, it will be installed to a different directory. After installing Python, REAPER may detect the Python dynamic library automatically. If not, you can enter the path in the ReaScript preferences page, at Options/Preferences/Plug-Ins/ReaScript.ReaScript/Python scripts can call API functions usingAll parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).Examples:You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line:and call the function by using:Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript:In addition to the standard API functions , Reascript/Python also has these built-in functions available:\n\nstring out = reaper.image_resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.relative_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn2(string in, string out, optional string checkSubDir)\n• col_main_textshadow : Main window text shadow (ignored if too close to text color)\n• col_nodarkmodemiscwnd : Do not use window theming on macOS dark mode\n• track_lanesolo_tabcol : Track fixed lane button when only this lane plays\n\n\n\n\n\n \n\n \n\n EEL2: \n\n\n\nReturns the absolute value of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the cosine of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n\n\n \n\n EEL2: \n\n\n\nUsed to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a file previously opened with fopen().\n\n\n\n \n\n EEL2: \n\n\n\nReturns nonzero if the file fp is at the end of file.\n\n\n\n \n\n EEL2: \n\n\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n\n\n \n\n EEL2: \n\n\n\nPerforms a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.\n\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\n\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n\n\n\n \n\n EEL2: \n\n\n\nPermute the input for ifft(), taking bands from in-order to the order ifft() requires. See \n\n\n\n \n\n EEL2: \n\n\n\nPermute the output of fft() to have bands in-order. See \n\n\n\n \n\n EEL2: \n\n\n\nPerforms an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.\n\n\n\n \n\n EEL2: \n\n\n\nReads a character from file fp, returns -1 if EOF.\n\n\n\n \n\n EEL2: \n\n\n\nReads a line from file fp into #str. Returns length of #str read.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n\n\n \n\n EEL2: \n\n\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and writes it to file fp. For more information on format specifiers, see \n\n\n\n \n\n EEL2: \n\n\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n\n\n \n\n EEL2: \n\n\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n\n\n \n\n EEL2: \n\n\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n\n\n \n\n EEL2: \n\n\n\nRetunrs the current file position.\n\n\n\n \n\n EEL2: \n\n\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n\n\n \n\n EEL2: \n\n\n\nQueries contextual information about the script, typically MIDI/OSC input values.\n\nReturns true if a new value has been updated.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n EEL2: \n\n\n\nThe following global variables are special and will be used by the graphics system:\n• gfx_a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx_mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().\n• gfx_x - current graphics position X. Some drawing functions use as start position and update.\n• gfx_y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx_clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx_dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx_texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx_ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx_w/gfx_h/etc will be doubled, but on other systems gfx_w/gfx_h will remain the same and gfx_ext_retina is a scaling hint for drawing.\n• mouse_x - current X coordinate of the mouse relative to the graphics window.\n• mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx_getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n EEL2: \n\n\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n EEL2: \n\n\n\nCopies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).\n\nIf destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n EEL2: \n\n\n\nDeprecated, use gfx_blit instead.\n\n\n\n \n\n EEL2: \n\n\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a circle, optionally filling/antialiasing. \n\n\n\n \n\n EEL2: \n\n\n\nConverts client coordinates x,y to screen coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n EEL2: \n\n\n\nCall with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/size\n\n\n\n \n\n EEL2: \n\n\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n\n\n \n\n EEL2: \n\n\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n\n\n \n\n EEL2: \n\n\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx_getchar() at least once causes mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n EEL2: \n\n\n\nEnumerates any drag/dropped files. call gfx_dropfile(-1) to clear the list when finished. Returns 1 if idx is valid, 0 if idx is out of range.\n\n\n\n \n\n EEL2: \n\n\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n\n\n \n\n EEL2: \n\n\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n\n\n \n\n EEL2: \n\n\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n\n\n \n\n EEL2: \n\n\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n EEL2: \n\n\n\nInitializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nLoad image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n EEL2: \n\n\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n EEL2: \n\n\n\nCloses the graphics window.\n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a rectangle with rounded corners. \n\n\n\n \n\n EEL2: \n\n\n\nConverts screen coordinates x,y to client coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n\n\n\n \n\n EEL2: \n\n\n\nSpecify 0 resource_id and custom_cursor_name from https://www.reaper.fm/sdk/cursors/cursors.php (e.g. 'arrow') to set the cursor. Alternatively can specify resource_id for a Windows cursor or built-in REAPER cursor.\n\n\n\n \n\n EEL2: \n\n\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n\n\n \n\n EEL2: \n\n\n\nResize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n EEL2: \n\n\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n\n\n \n\n EEL2: \n\n\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n EEL2: \n\n\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a filled triangle, or any convex polygon. \n\n\n\n\n\n EEL2: \n\n\n\nUpdates the graphics display, if opened\n\n\n\n \n\n EEL2: \n\n\n\nPerform an inverse FFT. For more information see fft().\n\n\n\n \n\n EEL2: \n\n\n\nPerforms an inverse FFT, but takes size/2 complex input pairs and produces size real output values. Usually used along with fft_ipermute(size/2).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n\n\n \n\n EEL2: \n\n\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax. \n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n• %x, %d, %u, and %f are available for use similarly\n• %c can be used, but can't take any length modifiers\n• Use uppercase (%S, %D, etc) for lazy matching\n\n \n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n\n\n \n\n EEL2: \n\n\n\nCase-insensitive version of match().\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nShuffles contents of buf right by 1, inserts value at buf[0], returns previous buf[len-1].\n\n\n\n \n\n EEL2: \n\n\n\nCalculates the sum of the products of values pointed to by src1 and src2. If src1 is -1, then calculates the sum of squares of src2, if -2, the sum of the absolute values of src2, if -3, calculates the sum of the values of src2. Other negative values are undefined.\n\n\n\n \n\n EEL2: \n\n\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n\n\n \n\n EEL2: \n\n\n\nSets length items of memory at offset to value.\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n\n\n \n\n EEL2: \n\n\n\nReturns a pseudorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n EEL2: \n\n\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n\n\n \n\n EEL2: \n\n\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include: \n\nMany standard C printf() modifiers can be used, including:\n• %.10s = string, but only print up to 10 characters\n\n \n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n\n\n \n\n EEL2: \n\n\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n\n\n \n\n EEL2: \n\n\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters): \n\n\n\n \n\n EEL2: \n\n\n\nInserts srcstr into #str at offset pos. Returns #str\n\n\n\n \n\n EEL2: \n\n\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. See str_getchar() for more information on types.\n\n\n\n \n\n EEL2: \n\n\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies the contents of srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n\n\n \n\n EEL2: \n\n\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the length of the string passed as a parameter\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the tangent of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n\n\n \n\n EEL2: \n\n\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n\n\n \n\n EEL2: \n\n\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n\n\n \n\n EEL2: \n\n\n\nEnds listening on port specified.\n\n\n\n \n\n EEL2: \n\n\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n\n\n \n\n EEL2: \n\n\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n\n\n \n\n EEL2: \n\n\n\nSets whether a connection blocks.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n\n\n \n\n EEL2: \n\n\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n\n\n EEL2:Returns the absolute value of the parameter.EEL2:Returns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.EEL2:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.EEL2:Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).EEL2:Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.EEL2:Returns the cosine of the angle specified (specified in radians).EEL2:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.EEL2:Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.EEL2:Returns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.EEL2:Used to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).EEL2:Closes a file previously opened with fopen().EEL2:Returns nonzero if the file fp is at the end of file.EEL2:If file fp is open for writing, flushes out any buffered data to disk.EEL2:Performs a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.Note that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.Note that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.EEL2:Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft () for more information.EEL2:Permute the output of fft() to have bands in-order. See fft () for more information.EEL2:Performs an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.EEL2:Reads a character from file fp, returns -1 if EOF.EEL2:Reads a line from file fp into #str. Returns length of #str read.EEL2:Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).EEL2:Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.EEL2:Formats a string and writes it to file fp. For more information on format specifiers, see sprintf (). Returns bytes written to file.EEL2:Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.EEL2:Hints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.EEL2:Seeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.EEL2:Retunrs the current file position.EEL2:Writes up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.EEL2:Queries contextual information about the script, typically MIDI/OSC input values.Returns true if a new value has been updated.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)EEL2:The following global variables are special and will be used by the graphics system:EEL2:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.EEL2:Copies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).If destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).EEL2:Deprecated, use gfx_blit instead.EEL2:Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.EEL2:Draws a circle, optionally filling/antialiasing.EEL2:Converts client coordinates x,y to screen coordinates.EEL2:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.EEL2:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/sizeEEL2:Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.EEL2:Draws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.EEL2:Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Lua: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()\n\nReturns contextual information about the script, typically MIDI/OSC input values.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n Lua: \n\n\n\n The following global variables are special and will be used by the graphics system:\n• gfx.a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx.mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit().\n• gfx.x - current graphics position X. Some drawing functions use as start position and update.\n• gfx.y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx.clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx.dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx.texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx.ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx.w/gfx.h/etc will be doubled, but on other systems gfx.w/gfx.h will remain the same and gfx.ext_retina is a scaling hint for drawing.\n• gfx.mouse_x - current X coordinate of the mouse relative to the graphics window.\n• gfx.mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• gfx.mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx.getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n Lua: \n\n\n\n Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n Lua: \n\n\n\n Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).\n\nIf destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n Lua: \n\n\n\n Deprecated, use gfx.blit instead.\n\n\n\n \n\n Lua: \n\n\n\n Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Draws a circle, optionally filling/antialiasing. \n\n\n\n \n\n Lua: \n\n\n\n Converts the coordinates x,y to screen coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n Lua: \n\n\n\n Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/size\n\n\n\n \n\n Lua: \n\n\n\n Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n\n\n\n \n\n Lua: \n\n\n\n Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.\n\n\n\n \n\n Lua: \n\n\n\n Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\n\n\n\n \n\n Lua: \n\n\n\n If char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx.getchar() at least once causes gfx.mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n Lua: \n\n\n\n Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n\n\n\n \n\n Lua: \n\n\n\n Returns current font index, and the actual font face used by this font (if available).\n\n\n\n \n\n Lua: \n\n\n\n Retreives the dimensions of an image specified by handle, returns w, h pair.\n\n\n\n \n\n Lua: \n\n\n\n Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n\n\n\n \n\n Lua: \n\n\n\n Fills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n Lua: \n\n\n\n Initializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx.update() should be called periodically. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Load image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a character with the current font (as set by gfx.setfont). Returns width and height of character.\n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n Lua: \n\n\n\n Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n Lua: \n\n\n\n Closes the graphics window.\n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y. \n\n\n\n \n\n Lua: \n\n\n\n Draws a rectangle with rounded corners. \n\n\n\n \n\n Lua: \n\n\n\n Converts the screen coordinates x,y to client coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n\n\n\n \n\n Lua: \n\n\n\n Sets the mouse cursor to resource_id and/or custom_cursor_name. \n\n\n\n \n\n Lua: \n\n\n\n Can select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx.setfont(), gfx.texth may be updated to reflect the new average line height.\n\n\n\n \n\n Lua: \n\n\n\n Resize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n Lua: \n\n\n\n Writes a pixel of r,g,b to gfx.x,gfx.y.\n\n\n\n \n\n Lua: \n\n\n\n Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx.showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx.showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n Lua: \n\n\n\n Blits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (table can be a regular table or (for less overhead) a reaper.array). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n Lua: \n\n\n\n Draws a filled triangle, or any convex polygon. \n\n\n\n \n\n Lua: \n\n\n\n Updates the graphics display, if opened\n\n\n\n \n\n Lua: \n\n\n\n Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach. 6.20+: returns previous shared memory segment name.\n\n\n\n \n\n Lua: \n\n\n\n Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Creates a new reaper.array object of maximum and initial size size, if specified, or from the size/values of a table/array. Both size and table/array can be specified, the size parameter will override the table/array size.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n reaper.set_action_options(flag)\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n Lua: \n\n\n\n Sets the value of zero or more items in the array. If value not specified, 0.0 is used. offset is 1-based, if size omitted then the maximum amount available will be set.\n\n\n\n \n\n Lua: \n\n\n\n Convolves complex value pairs from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs. size is in normal items (so it must be even)\n\n\n\n \n\n Lua: \n\n\n\n Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward real->complex FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Returns the maximum (allocated) size of the array.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards complex->real FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Resizes an array object to size. size must be [0..max_size].\n\n\n\n \n\n Lua: \n\n\n\n Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n\n\n\n Lua:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Lua:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Lua:is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()Returns contextual information about the script, typically MIDI/OSC input values.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)Lua:The following global variables are special and will be used by the graphics system:Lua:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.Lua:Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).If destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).Lua:Deprecated, use gfx.blit instead.Lua:Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.Lua:Draws a circle, optionally filling/antialiasing.Lua:Converts the coordinates x,y to screen coordinates, returns those values.Lua:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.Lua:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/sizeLua:Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.Lua:Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.Lua:Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Python: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n Python:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly."
    },
    {
        "link": "https://admiralbumblebee.com/music/2018/09/22/Reascript-Tutorial.html",
        "document": "Today we’re going to learn to write ReaScript, specifically Lua.\n\nIf you’ve never programmed in your life, I’m going to try to take you from that point to your very first script with a GUI.\n\nThis isn’t a super trivial example either! This is a useful script that lets you create sidechaining via automation items.\n\nTHIS IS A LOT OF READING!. You do not need to do it all at once. Try it in sections, take a break if you need to, and come back another time. Programming takes time to learn, and time to do. Don’t force it all on yourself at once.\n\nI’ve a video walking you through it as well. Let’s get on with it…\n• Beginner Tutorial Part 2 - Programming in Reaper\n• How to try code\n• Where to find information\n• How to interpret that page\n• Beginner Tutorial Part 3 - Writing the script\n• Put it all together\n\nBefore we start, I want to thank Justin of Cockos. Without his surprisingly timely support this entire post wouldn’t be possible.\n\nThank you to Evildragon for helping proofread, I really needed it this time. :) (there is some irony here…)\n\nLokasenna for his GUI Library, constant contributions to the REAPER community and pleasant chats.\n\nX-Raym and his fantastic website full of ReaScript resources and scripts for REAPER. He also helped me proofread and improve this article.\n\nJon @ The REAPER Blog for giving me an incredible community resource to utilize.\n\nCFillion for his amazing work on ReaPack and a variety of important REAPER projects.\n\nMPL for his demonstration of an advanced script that shows what REAPER is capable of and offers a more elegant solution to this use-case. Check out the Reaper Script Showcase to see many more of his amazing scripts. (Many of them replicate features from other DAWs that are paid add-ons, but he does it better!)\n\nThis entire post, including the code, was written using Dragon for Mac v6.\n\nI have developed a number of vocalizations that allow me to create common programming syntax, plus I have a number of snippets that I used in Visual Studio Code.\n\nI normally write my blog posts in emacs, however Dragon does not like typing words into Emacs. I have had a good deal of luck using VS code, however there are occasionally some issues\n\nIf you have ever wondered how well the speech to text software works, like Dragon, then let this be a demonstration. I have been using Dragon for nearly all of my text for the last week now and it has been incredibly accurate. I can edit the vocabulary and create custom commands that let me do nearly anything I want.\n\nI was even able to feed it a number of my blog posts to start out, and it built a vocabulary based on things that I commonly write. Thusly I could write things like REAPER, Cubase, VST or FLStudio without ever having to train the software.\n\nDue to the amount of pain that I have had in my arm and my hand this has been an incredible addition to my software arsenal. if you have ever been curious about speech to text software I can wholeheartedly recommend Dragon. It does require some set up, and you will need to spend some time adding the commands you need, but out-of-the-box it does an amazing job of voice recognition without any training or any set up.\n\nWithout Dragon, I do not think I would have been able to write this post at all, or it would have taken me literally weeks due to number of long pauses I would have to take while typing.\n\nThis entire lesson (mostly) is available on youtube as a ~39 minute produced video (not just rambling while someone fumbles around).\n\nReaScript is a generalized word that refers to miniature programs that can control REAPER. There are various computer programming languages that can be used to do this: Python, Lua and EEL.\n\nThere is also an API for C.\n\nIn this tutorial we will be using Lua to create a script that creates new automation items in the envelope lane that correspond to edits in media items. This will become more clear as I show the results of the script.\n\nDon’t fear, I will be leading you through everything as if you have no clue how to program or how to use REAPER.\n• - code is like this\n• “variable” - when I refer to a variable in the code, it will be in double quotes.\n\nI also put REAPER shortcuts . It should be clear when something is a shortcut, or if it’s code.\n\n“Sidechaining” is a a techinque people use for having the content of one track affect another. You’ll have a transient item like a kick drum, and a non-transient item like a bass that occupy the same sonic space. You want the bass to be turned down for a short period of time when the kick hits. This lets the kick be full sounding without clashing with the bass sound.\n\nREAPER has a concept called automation items. These are items that encapsulate automation so that you can:\n• Move the automation around and apply transformations to it (such as changing the shape) independently\n• “Pool” automation items. This allows you to have encapsulated automation anywhere in your project that is mirrored. If you change one of the items, all of the other items change the exact same.\n• These pooled items can be anywhere on an automation envelope. You can have pooled items on pan, volume, VST effect etc… all at the same time, and they all have the same data.\n\nThis script requires that you’ve split your audio part (using the menu item “View->Dynamic split”).\n\nWhen the item is split, you will have new items that have the start of the item right at the transient.\n\nOur script will get all of the items on the selected track then create new automation items on the selected envelope. The automation items will have matching start times to the items, and a configurable length.\n\nThis setup allows you to edit the automation items to have a custom shape to sidechain whatever you want. It also alllows you to individually shift parts, or shift all of the automation items at once.\n\nHere’s the things that you need:\n• Script: Set Lokasenna_GUI v2 library path.lua - this must be run before any of the GUI Library\n\nIn order to find the documentation for REAPER, open REAPER then goto the menu “Help->ReaScript Documentation”. Better yet, go here for better formatted documentation.\n\nYou can edit code in any editor you want like vim, emacs, Intellij, Sublime Text and…\n\nLokasenna has some fantastic extensions for VS Code that give you a bunch of snippets, highlighting and API documentation inline.\n\nJump to the GUI section to see how GUIs are done. There are a few other GUI Widget libraries, but Lokasennas is the most complete that I’m aware of. You can also find a number of examples insides your Reaper directory. (also available on github)\n\nThere is some digging you may need to do in order to understand how to use some functions, but general it’s only a cycle of two of feeding a function some garbage data to get an error message and be pointed in the right direction.\n\nIn order to be able to do this there are two things that you will need, you will need Reapack and you will need SWS.\n\nREAPER’s bare functionality is lacking sometimes. There’s a bunch of functions that can be added to REAPER that are necessary for certain scripts, or necessary for bare functionality.\n\nSWS Extensions provides a great deal of extra capability to REAPER and it acts as a library to give the programmer extra functions to use. These functions are automatically added to the ReaScript Docs.\n\nOnce it is installed you will see a new menu in REAPER named “Extensions”. If you do not see that window, then please utilize google and the REAPER forums to see what you may have done wrong.\n\nReaPack allows you to install Libraries and other people’s scripts.\n\nFollow the directions to install it.\n\nOnce it is installed you will see a menu inside “Extensions” named “ReaPack”. Click “Browse packages” to see the window above.\n\nInstalling with ReaPack is slightly tricky. You right click a package and select “Install”, but that does not install the package. You need to select the packages to install then hit “apply”.\n\nExplore the interface and see what else you can do with it.\n\nBefore we start actually writing some code let’s go over some basics of programming. I’m going to assume that you have never programmed in your life, and that you can just barely operate REAPER.\n\nThis tutorial is only written in the context of Lua for REAPER. Some of these concepts don’t apply necessarily to other languages.\n\nYou will need to read this tutorial at least twice if you are a total beginner. The concepts presented won’t make much sense until you see them in action, then you will need to go back and read about the concepts again and see them in action again.\n\nYou can try all of the examples here by going to repl.it, pasting the code and hitting the “run” button.\n\nAs the tutorial progresses, you will learn to use REAPER for this task.\n\nIf you do not understand the first time then please make sure to read the entire thing all the way through at least twice\n\nComputer software generally deals with two things: doing things to data, and dealing with events generated by outside sources like users.\n\nWhen your program encounters new data then it needs to store it somewhere, and you need a way to reference that data sometime in the future.\n\nYou will also sometimes need to create your own data that is included in the software (such as pre-defined settings for your script), and you will want to reference this data by some sort of name.\n\nThis is what variables allow you to do: store data, and then refer to it at some other point in time by a name.\n\nLet’s look at some code:\n\nIn that line we declare a variable named “a”, and it is assigned a value of one. Anywhere we use the letter “a” it will be just like using the number one. So let’s look at that more.\n\nI assume that you can guess what the value of “c” is.\n\nVariables in Lua can store any data that we want. It can be words, they can be numbers, and variables can even hold things like functions.\n\nSo when there is some data that you want to save and refer to later, then you assign it to a variable.\n\nData comes in a variety of types. This data can be numbers, strings (words), functions and other types of data that were not going to worry about right now.\n\nYou can assign any type of data to any variable in Lua, however sometimes you will need to use a specific type of data such as a number or a string.\n\nis a special type of data in Lua. It simply means, “nothing at all”. It is also read as a “false” value, which you well learn later.\n\nWe will only be working with numbers, strings and in this (explicitly at least. The only things you will need to know are how to convert between strings and numbers.)\n\nLua has a concept called tables, which is how you can store many things in a single variable.\n\nThe variable “numbers” is storing four strings.\n\nIf we want to access one of them then we use the variables name, and square brackets with the index of the value we wish to use. So “numbers[1]” will get the first thing in our table.\n\nI’m assuming that you can guess what “numbers[3]” will return, right? Be careful and look closely!\n\nWhen we want to process an entire table, item by item, then we use loops.\n\nIn Lua for REAPER your entire script will be put inside what is called a function named “main()”. This is not necessary, but it is a tidier way to work.\n\nFunctions are how you do things. A function will contain variable assignments, loops, conditionals and calls to other functions. Let’s look at what a function looks like:\n\nIn this function we assigned two variables, then assigned a third variable which was the addition of the first two variables.\n\nLua understands what belongs to the function due to the statement. Code is read more often than it is written, so we try to make this easier by indenting the things that belong to the function. As you can see, this makes it more obvious what things are “inside of the function”. Indentation is actually a complex topic(!!??), the only thing that is really important is that you are consistent with your style.\n\nIf we wanted to use this function, then we need to “call it”. When you call a function then the program jumps to that section of code and does everything inside that function block. Let’s see what that looks like:\n\nThe line with doesn’t do anything but declare the function as something that exists. If we want to use the function then we need to write .\n\nThat is not very useful though. We will want the function to interact with the outside world. It will need to take in its own data, and produce new data.\n\nTo give data to a function we use a feature called “arguments”.\n\nWe no longer need to assign A and B to variables. When we call the function with we are telling it that we want A to equal 1 and B to equal 2. Look at where we declare the function and where we call the function.\n\nWe are still missing a piece here though. If we send data to a function then it would stand to reason that we would also want to sometimes get data back from a function. There is a special word we use, . Let’s see that in action…\n\nWhen the function is called then we add “a” and “b”, assign it to “c and then we . That means that we can call the function, and immediately assign the result of the function to another variable.\n\nRemember, the line with only says ‘Here I am!’. The line is where the function is called, and there are 2 things happening:\n• Things are processed from the most inner-most (). So this means that is processed.\n• Now is called. It sees a value of 3, and it prints that.\n\nWhere did come from though? This is a function built-in to Lua that lets us print things to the screen. It’s not something that we use in ReaScripts, but while we are learning the the basic of Lua it’s perfect. You will learn REAPER’s equivalent of the print() statement later\n\nProgramming is not just about writing code, but about reading it as well.\n\nIn order to write a line that is not interpreted as code then place two hyphens in front of it.\n\nIf you want to have a comment that spans multiple lines then each line needs to have two hyphens in front of it or you can use this syntax:\n\nComments aren’t just for writing notes for yourself, or for somebody who might read your code. Comments can be used to temporarily disable parts of your code. If you have a portion of code that is no longer needed, or if you want to disable something so that you can test something, then use comments.\n\nImagine for a moment that you are making a script in REAPER that deals with moving items around. Often you will want to store the position of an item inside of a function. You may have many functions that move items around or store the position of an item.\n\nSo you may want to use a variable named “item_position”. That’s great, but if function “a()” uses “item_position” and function “b()” uses “item_position”, but the two functions need to store different values then what happens?\n\nIf you simply declare a variable in Lua, then it is visible to the entire program. If you want a variable to only be seen by the enclosing block (such as a function, conditional, loops, etc… almost anything with an ‘end’) then you need to put the word “local” in front of it.\n\nThis is a slightly tricky one. The function can see the variables “a” and “b” because they are what is called ‘global’. Any function can see them, and any function can change them.\n\nThe trick here is that even though “c” is declared inside a function, it is also able to be seen from outside the function!\n\nLet’s try to make “c” only visible to the function .\n\nThe first statement works, but the one at the end gives us a value. The word makes it so that “c” is only visible inside of the function .\n\nThis is a very important concept to understand! When in doubt, make your variable local.\n\nScope in Lua can be confusing for even experienced programmers, so don’t get discouraged if you find variables with the wrong value or you get some errors about a variable not existing. is your friend and it will guide you through the darkness.\n\nOften when programming you need to make choices, and the statement is what allows you to do that, so let’s just go ahead and try an statement:\n\ngenerates a number between one and five, then assign that value to “a”. This is another function built-in to Lua.\n\nNow we use the statement, and then compare “a” to 1. This is done using . takes the two values to the left and right of it, compares them, and returns true or false.\n\nBe careful! is for comparing things. is for assigning things. If you use in your if statement then you may be surprised with an error (thankfully Lua gives an error… other languages will let you assign things in an if statement, a frequent source of confusion)\n\nThe if statement executes the stuff inside of it if the condition is true. isn’t the only thing you can use though, there are other comparison operators…\n\nThis code will print “a” if it is less than 3. There’s a number of ways to compare things:\n• <= less than OR equal to\n• >= greater than or equal to\n\nSometimes your code will need to test two different things before it does something, so LUA has the operators and (also is available):\n\nThis code will only print “a” and print “b” if “a” is greater than 3 and “b” is less than 5. (note: repl.it always gives the same random values… so your code may never work correctly depending on the output! See if you can figure out how to make this code work by utilizing scope and print statements)\n\nOccasionally you will need to do one thing if a value is something, or do another thing if that the value is something else. This is where comes in.\n\nOther times you may need to test the value for something else. This is where you use , which can be combined with like this…:\n\nThis code should be pretty self-explanatory. Note that needs a new comparison, and does not. happens if no other comparisons are true, so it exists on its own.\n\nTry some , and statements yourself to get a feel for it.\n\nWhen programming you will frequently need to do things multiple times, or process a bunch of items one after the other in the same way. Loops are how you do this.\n\nThe statement declares a local variable, in this case named “index”. Then it executes the code inside the block.\n\nWhen it is done it goes back and increases the value of index by one, so now it’d be doing . This increases until “index” is 4, and the loop stops.\n\nWhat if we only wanted to print every other value?\n\nHere we have added a third number to our statement, “2”. This tells the for loop to increment index by two every time it loops.\n\nLua has another way of looping, but it will not be necessary for this tutorial. I will show you anyways, if this is confusing then you can ignore it for the context of this article.\n\nTables in Lua are what is called associative arrays. Each slot is two values, the key and the value.\n\nSo far we have been using keys that correspond to the “index”, or position in the table, and the value associated with that index.\n\nWhen using a for loop in Lua you can extract the key and the value using the format above. Lua will go through every single key and value pair then print the key and the value. (But it does not loop in order if we use . That is outside the context of this tutorial! It also does not matter for us.)\n\nPerhaps this example will make it more clear…\n\nYou can ignore those square brackets in the “numbers” declaration for now, that’s just a weird thing about Lua.\n\nHowever if you run this code you will see that the keys are a string and the values are a string. Anything can be a key and anything can be a value, and that is how you iterate over them.\n\nMost programmers want to write as little code as possible, and they want the code to be as correct as possible.\n\nOne way of achieving the first part, and hopefully the second part is to use somebody else’s code. people will put all their code together in a file and distribute it as what is called a “library”.\n\nWhat we will be using is called a “module” in Lua.\n\nThis lets us take somebody else’s code, imported into ours, and then use the functions from the other person’s code.\n\nWe will be using this concept to take somebody’s GUI functions so that we can draw a GUI easily without having to write all the annoying code.\n\nThis is done like this for the code that we will be writing:\n\nBut you don’t need to worry about that, because the GUI builder that we will be using automatically generates this code.\n\nYou can learn more about loading modules right here, but the concept that we use is loading files.\n\nIn Lua it is possible to load libraries from other people using the “module” concept, or we can take an entire file or a string that contains a Lua code and import that into our project.\n\nIn this tutorial we will copy and paste the code into our file.\n\nIf you are truly a beginner, I suspect you probably didn’t fully comprehend everything that I just covered, and that is totally fine.\n\nIt is now time to actually do some stuff in reaper.\n\nHow to try code\n\nThe first thing you need to do is press or just . This brings up the action list.\n\nClick the button next to ReaScript that says new, and then save the file wherever you want.\n\nThis is where you edit code. Let’s go ahead and try something simple:\n\nSave the file by pressing ctrl-s on Linux and Windows, or command-s on macOS.\n\nNow you are presented with a box saying hello to me.\n\nIf you want to get back to your code after closing that window, then go back to the actions list by pressing , searching for the name of your script, selecting your script, then clicking edit in the lower right-hand corner.\n\nIf you prefer to edit your code in another program you can do that. REAPER will pick up changes as the file is saved.\n\nLet’s look at that command we used again . How did I figure out that this command exists?\n\nIn REAPER go to the help menu and select “ReaScript Documentation”.\n\nThis will open a window in your web browser with a bunch of documentation. Alternatively you can use this nicely formatted documentation.\n\nWhen inside your browser press ctrl-f (win/lin) or cmd-f (mac) to bring up the search and enter “ShowConsoleMsg”.\n\nNow you will see the documentation for `reaper.ShowConsoleMsg() with information for C, EEL, Lua and Python.\n\nHow to interpret that page\n\nIn order to use these functions we need to understand what all this mess of text means. So let’s take the . Open the documentation and find this function by using the search feature in your browser.\n\nThe Lua line looks like this\n\nSo let’s break this down piece by piece:\n• “Lua:” - this tells us that this is the definition of the function for Lua\n• - as we discussed before in the functions section, functions can often return data to the thing that called to the function. The word integer tells us that the function returns an integer, or a number.\n• “ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO” - if you look below at the integer type argument in the function, then you can see that there are multiple types of windows we can create with different types of buttons. will return a numeric value that corresponds to which button the user pressed. Based on that information we can proceed in our code likely by using a conditional\n• - all functions for Lua are preceded by the word reaper, followed by the name of the function. I’ve seen this as a common mistake for beginners where they forget to put the word reaper in front of functions provided by reaper.\n• - once again as discussed in the functions section, function sometimes need to take data from outside. this function takes a string, another string and an integer. we do not need to provide all of these, as you can see above that we only provide a string initially.\n• - this is the message that is shown\n• - this will change the title of the window that is showing the message\n• - in the documentation we see “type 0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL”, so if for instance we provided the number 2, then we would get a window with aboart, retry and ignore buttons.\n\nThis may seem like a lot of information to process at first, but as you are looking for functions that do what you need it will become more obvious what the return values and arguments need to be.\n\nIf all else fails, then you just need to experiment… the documentation is not that great.\n\nAlright it’s time to write the script. Let’s just dig right in.\n\nThe first thing our script needs to do is get some information, it needs to know the track and the envelope that we wish to affect.\n\nSo what were going to start with is to get the select the track and the selected envelope.\n\nOpen up your REAPER documentation and search for “getselected”. You’ll see some options and look until you find these:\n\nWe are always going to pass a value of 0 for . That means that we wish to affect the current project and not something in the background.\n\nhas a value named “seltrackidx”. Since you can select multiple tracks in reaper, ReaScript needs to know which of the selected tracks you wish to grab, and we will always grab the first selected track, which has an index value of 0.\n\nSo in our code will look like this:\n\nNow the value “sel_track” contains data of the type . So when we want to use another function that is expecting we can pass “sel_track” to it.\n\nThe same goes for “sel_env”, which now has a stored inside of it.\n\nBefore we do anything with “sel_track” or “sel_env” we need to make sure that it exists. If we try to use a value that does not exist then we will get an error. So let’s make sure were careful about this\n\nGo ahead and test this code.\n\nSince we can identify two different things that we are doing separately, let’s put these things into functions so that we can reuse them easily.\n\nWe put all of the code for getting a track and getting an envelope into their own functions. If we need to get the track or get the function multiple times when we do not need to rewrite this code we just call the function.\n\nNote that the values of “sel_track” and “sel_env” are not local. That means that other functions in the program can see these variables. This will be important later.\n\nThis is generally not good programming practice, but for the simplicity of this tutorial and how simple the script is, we will be totally fine using these global variables.\n\nThe script that we are writing requires that the user has split the items at transients. This means the track will contain many media items that start at a transient.\n\nWe want to place an automation item on the selected envelope that corresponds to the start of every media on the selected track.\n\nIn order to do this we need to be able to get a table of all the media items, and then loop over all of those items.\n\nLet’s add a new function called “main()” that uses get_track() to get all of the media items on that track.\n\nSo here is what happens in the main function:\n• We want to select all of the items on the track, but what if the user has many tracks selected? We must make sure that no tracks are selected with .\n• Then we select our desired track with .\n• We call . This executes the action “Item: Select all items in track”. This will ensure that we have items selected if there are any.\n• Now we get the number of items that are selected with then assign that to a local variable named item_count\n• We create a for loop that goes from 0 to the size of item_count minus one. This is because in REAPER, values start at 0 (in Lua things start at 1, so we need to be explicit about what we want!).\n• Inside of the loop we create a variable named “sel_item”. This will contain a type value that comes from . Look up “GetSelectedMediaItem” in the ReaScript docs to see if you can figure out why we called it with a zero and with the i. Remember that i represents the current index in the loop, so it goes from zero up to the number of items we have minus one.\n• Now we use to get the current position of the item in the project and assign that to a local variable named “i_pos”\n• Lastly we make a console message that takes “i_pos” and combines it with “\n\n”. “\n\n” indicates that we want a new line. The “..” tells Lua that we want to combine two strings. You can think of it as an addition sign when you want to add the strings together.\n\nMake sure that you understand how works. Look at the documentation and experiment with it a little bit. You can see the values of variables on the right-hand side of the editor while the code is running, or you can use to see the values of things.\n\nNow we need to do something with that position, such as use that position to create new automation items on the envelope with the same position.\n\nWe have only added a few lines here.\n\nSo let’s look at this. This says that if we are making the first automation item, then we need to give it a pool ID of -1. This is necessary because as of this writing reaper does not let you create arbitrary pools.\n\nAutomation items that are in the same pool will all contain the same data and all change simultaneously when we change any single one of them.\n\nOnce we create this new automation item, then we need to get the pool ID from it so that all of the new automation items we create also have that pool_ID.\n\nIf were not processing the first automation item then we know we have a valid pool_ID and we can simply insert the automation item.\n\nI strongly suggest looking to the documentation and looking up:\n\nOnce you think you have a basic idea of how these work and let’s move onto the next section.\n\nIn our code so far we simply set an automation length of one. I would like to use the length of the smallest item, and later we will allow the user to input a length.\n\nSo let’s find the item when the shortest length\n\nThis function makes the scary assumption that we have selected items, which we may not have. I’m going to leave it up to you to fix that.\n\nAfter that assumption we go through all of the selected items as we have before. We store the current selected item in the loop in “sel_item”, then we use “sel_item” to get the length of the item.\n\nIf this is our first time through the loop then we assign “min_len” to the length of that item. ( …)\n\nFor each subsequent item that we evaluate, we assign “min_len” to either “i_len” or “min_len”. Math.min() takes two values and returns the lesser of the two.\n\nAs we loop through the items eventually “min_len” will be the value of the smallest item.\n\nThen we return that so that we can use that value in the place that we call the function.\n\nI strongly suggest taking a minute to use to show yourself what is happening in this function. Print out the current “i” value, the current “i_len”, the current “min_len” and perhaps the name of the media item that you are processing. You remember how to do that?\n\nUse things like “..” to put strings together and “\n\n” to create a new line.\n\nDo this any time you become confused! I actually had an issue while writing this code were I accidentally typed “min_length” instead of “min_len”. I ended up getting this cryptic error that I could not figure out until I started putting little messages to give me idea of what values were at what point.\n\nThis tends to be called “printf debugging” (due to how print is done in C). Some other languages have fancy debuggers, but with any language this is a powerful and quick way to figure out what is happening in your code. Don’t be afraid of it.\n\nPut it all together\n\nIt looks like we actually have all of our working code down. this will take the selected track, the selected envelope and make a new automation item at the start of every media item, and the length of the automation item equals the length of the smallest media item.\n\nThis time I have added some comments to the code to help make it be more clear for first-time readers.\n\nWe did add one small thing here,\n\nIf there is no “sel_track” or “sel_env” then we wanna abort our mission immediately. We from our function immediately, and no further code will be processed.\n\nIdeally we’d encapsulate this all in a class (using metatables) and pass values (and a few closures) around via functions while relying on no globals, but that would add complexity for zero benefit in this simple case. I also don’t want to make this tutorial too long :)\n\nAs your scripts become complex, you’ll google for solutions and find out about better practices, new functionality and see some fun arguments about how things should be done.\n\nOur code works if you run it and you have a track and an envelope selected. However, there is no way for the user to set the length of time that they want that automation items to be.\n\nSo let’s create a GUI that allows the user to select a track, select an envelope, set the length of the automation item and then do the process when they are ready.\n\nThe first thing you need to do is to go to ReaPack->Browse Packages. Install the following packages:\n\nNow go to the actions list using ( ). Select “Script: Set Lokasenna_GUI v2 library path.lua” and hit run.\n\nRight click in the middle of the window that pops up, this is where you can add new GUI elements to the screen.\n\nTo move a GUI widget or select a GUI widget for editing you need to hold shift and click it.\n\nBuild something like the GUI that you see above.\n\nYou will at least need these elements:\n• A textbox to get the length of the AI\n• A button to get the currently selected Track\n• A button to get the currently selected Envelope\n• A button to clear the currently selected Track\n• A button to clear the currently selected Envelope\n• A button to DO IT!\n\nWhen you’re done with your GUI go to the menu item “File->Export” and export the file to a location you are familiar with.\n\nIt really is that easy!\n\nJust play around with it and make a few rubbish attempts. It works quite nicely.\n\nThis is basically what is output from the GUI editor.\n\nSo what we need to do is insert our code into this file, and then connect the buttons to functions.\n\nSo where I have the comment that says “Insert code here”, place your current code in that location. We could keep our GUI code in a separate file and use a function called “loadfile” which lets you load a file into your current code. You can try doing this yourself, but for this tutorial we will just insert our current code into the generated GUI.\n\nThe next thing we need to do is add some code to the buttons so that they do something when you press it. Let’s look at what we need to do to the envelope button.\n\nI have done two things here:\n• Add a comma after . Every item, except the last item, needs a comma at the end. Since we’re adding a new item to the end, this is no longer the last item and it will need a comma\n• Add as the last item. This tells the button that when it is pressed, we want it to run the function. CAREFUL. You want and NOT . The latter will call the function immediately. We only want to pass the name of the function, so we leave out the parenthesis.\n\nSo go ahead and connect the buttons to your main function, to the get_track function, and you will need to create two “clear” functions. The information you need to create the “clear_envelope” and “clear_track” functions are in the next section.\n\nAt this point you can load the script, run it, and you’ll get a nice GUI… that doesn’t work at all.\n\nWhen the user presses the “Get track”, or “Get envelope” then we want the GUI to display the name of the track or envelope in the text box that we created.\n\nHere we’ve added an ‘else’ section to our code. If the sel_track exists then we want to change the GUI.\n\nThere is a trick here though. Look at this line:\n\nWhat is that ?\n\nThe function returns two values. The declaration is:\n\nWe only need the track name, but it returns . We need to deal with both values though! That’s what lets us do.\n\nsays “Forget the first return value, assign the second value to ”.\n\nThis is a powerful feature of Lua, and it can be slightly confusing sometimes. Just know that if a function has multiple return values, then you need to somehow assign all of them to a variable. If you want to ignore one, then use in that place.\n\nThe return values are processed in order. So if we had a function like that is declared as:\n\nIf we want to use any of those values, we need to process all of them. Something like this:\n• retval will not be assigned\n• beatpos will not be assigned\n• bpm will not be assigned\n\nWe can now use the variables , , , , , in our code. They were all simultaneously assigned by the return function.\n\nLua lets us return many values from a function, and we can assign these multiple return values at once. We can also ignore return values by using\n\nI want to do more than just list the envelope name in the text box. I want to do something like “track_name - envelope_name”. So first we need to get the name of the envelope.\n\nuses the trick. Look up “GetEnvelopeName” to see why we needed to do that.\n\nOnce we have the envelope name, we want the name of the track that the envelope is attached to. “GetSetMediaTrackInfo_String”s first argument is . That means we need a variable with a type of “MediaTrack”.\n\nSo I searched through the documentation until I found something that uses the envelope and returns a “MediaTrack”. does this!\n\nWe really only need the , so we use our trick to get that and ignore everything else.\n\nNow that we have the name of the track and the name of the envelope, we can set the text box to . Remember that just puts two strings together. We combine the track name with “ - “ and then the envelope name.\n\nI’m not going to tell you how to do this! The code I publish at the end will not have this either.\n\nYou need to set and to and clear the GUI textboxes.\n\nRemember to attach your and functions to the buttons too.\n\nPart of setting up the GUI was that we wanted the user to be able to set the length of the automation items that are created.\n\nWe already have the code for finding the minimum length. All we need to do is get the value from the GUI. If the GUI does not have a value then we use the minimum length code we used.\n\nOtherwise (else) we convert the “gui_len” to a number and return it to whereever the function was called.\n\nSince we have buttons that do and for us, we don’t need these in the “main()” block anymore.\n\nWhen we use this, we will want the user to be able to undo the action. So before we do anything, we put in. This tells REAPER that anything we do is going to be consolidated into a single undo stage.\n\nAfter we do all of our work we put the code . the first argument to will be what the undo shows up in REAPER’s undo history. (What’s the second argument? Find it, and figure it out, yourself!)\n\nThat code works, and there’s still some that you need to fill in yourself as I described earlier.\n\nI have also included (at least) 2 code paths that could lead to a crash. See if you can figure out where a user may do something that could crash the script. Read through the code and think to yourself “Does this variable always exist?” I tried to make this fairly easy to find for an intermediate developer. Beginners may need some time to find it.\n\nYou also need to think about what happens if a user already has some media items selected. That will mess everything up! Fix that.\n\nmpl has taken the idea of this script and removed the need to pre-split the ‘triggering’ items. His script reads the audio, figures out the location of the peaks and puts automation items on the selected envelope.\n\nIt has some parameters to tune the peak detection.\n\nMuch nicer than what we’ve created and a further example of what is possible with ReaScript.\n\nX-Raym has a fantastic series on learning more about ReaScript.\n\nAdam T Croft has some excellent content about learning ReaScript.\n\nMore LUA language resources (don’t bother reading the official docs, they are poorly written.)\n\nThat sure ramped up quickly didn’t it. That is kinda how programming works! You start with something small and then you slowly start building on it. Before you know it you have this giant piece of code that spans thousands of lines long and you don’t even realize that you did it.\n\nDon’t be discouraged buy how daunting a project may seem, just start with the smallest thing you can think of and slowly build up from there.\n\nIt is quite a bit like music, where you need to just put down one small part and then build on it by adding more parts, and more parts, and more parts. Eventually you go back and you start to remove some things, refine some things and potentially clean up your project to make everything look nice.\n\nIf you are a musician, then you can be a programmer. You basically already do the exact same thing anyway!\n\nThis post took 28 hours to screencast, debug, write and edit. If you appreciate the information presented then please consider joining patreon or paying me for my time spent bringing you quality content!"
    },
    {
        "link": "https://github.com/cfillion/reascripts/blob/master/cfillion_GFX%20Input%20Inspector.lua",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://reaper.fm/sdk/reascript/reascripthelp.html",
        "document": "ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a \n\n\n\n ReaScript/Python scripts can call API functions using .\n\n\n\n All parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).\n\n\n\n Examples:\n\n # function returning a single (scalar) value:\n\n sec = RPR_parse_timestr(\"1:12\")\n\n\n\n # function returning information in the first parameter (function returns void):\n\n (str) = RPR_GetProjectPath(\"\", 512)\n\n\n\n # lower volume of track 3 by half (RPR_GetTrackUIVolPan returns Bool):\n\n tr = RPR_GetTrack(0, 2)\n\n (ok, tr, vol, pan) = RPR_GetTrackUIVolPan(tr, 0, 0)\n\n # this also works, if you only care about one of the returned values:\n\n vol = RPR_GetTrackUIVolPan(tr, 0, 0)[2]\n\n RPR_SetMediaTrackInfo_Value(tr, \"D_VOL\", vol*0.5)\n\n \n\n You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line: and call the function by using: \n\n Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript: \n\n In addition to the \n\n\n\n ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a free download . Python 2.7 is normally included with macOS, and the dynamic library is usually in /usr/lib. If you update to a newer version of Python, it will be installed to a different directory. After installing Python, REAPER may detect the Python dynamic library automatically. If not, you can enter the path in the ReaScript preferences page, at Options/Preferences/Plug-Ins/ReaScript.ReaScript/Python scripts can call API functions usingAll parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).Examples:You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line:and call the function by using:Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript:In addition to the standard API functions , Reascript/Python also has these built-in functions available:\n\nstring out = reaper.image_resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.relative_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn2(string in, string out, optional string checkSubDir)\n• col_main_textshadow : Main window text shadow (ignored if too close to text color)\n• col_nodarkmodemiscwnd : Do not use window theming on macOS dark mode\n• track_lanesolo_tabcol : Track fixed lane button when only this lane plays\n\n\n\n\n\n \n\n \n\n EEL2: \n\n\n\nReturns the absolute value of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the cosine of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n\n\n \n\n EEL2: \n\n\n\nUsed to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a file previously opened with fopen().\n\n\n\n \n\n EEL2: \n\n\n\nReturns nonzero if the file fp is at the end of file.\n\n\n\n \n\n EEL2: \n\n\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n\n\n \n\n EEL2: \n\n\n\nPerforms a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.\n\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\n\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n\n\n\n \n\n EEL2: \n\n\n\nPermute the input for ifft(), taking bands from in-order to the order ifft() requires. See \n\n\n\n \n\n EEL2: \n\n\n\nPermute the output of fft() to have bands in-order. See \n\n\n\n \n\n EEL2: \n\n\n\nPerforms an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.\n\n\n\n \n\n EEL2: \n\n\n\nReads a character from file fp, returns -1 if EOF.\n\n\n\n \n\n EEL2: \n\n\n\nReads a line from file fp into #str. Returns length of #str read.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n\n\n \n\n EEL2: \n\n\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and writes it to file fp. For more information on format specifiers, see \n\n\n\n \n\n EEL2: \n\n\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n\n\n \n\n EEL2: \n\n\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n\n\n \n\n EEL2: \n\n\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n\n\n \n\n EEL2: \n\n\n\nRetunrs the current file position.\n\n\n\n \n\n EEL2: \n\n\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n\n\n \n\n EEL2: \n\n\n\nQueries contextual information about the script, typically MIDI/OSC input values.\n\nReturns true if a new value has been updated.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n EEL2: \n\n\n\nThe following global variables are special and will be used by the graphics system:\n• gfx_a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx_mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().\n• gfx_x - current graphics position X. Some drawing functions use as start position and update.\n• gfx_y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx_clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx_dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx_texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx_ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx_w/gfx_h/etc will be doubled, but on other systems gfx_w/gfx_h will remain the same and gfx_ext_retina is a scaling hint for drawing.\n• mouse_x - current X coordinate of the mouse relative to the graphics window.\n• mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx_getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n EEL2: \n\n\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n EEL2: \n\n\n\nCopies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).\n\nIf destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n EEL2: \n\n\n\nDeprecated, use gfx_blit instead.\n\n\n\n \n\n EEL2: \n\n\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a circle, optionally filling/antialiasing. \n\n\n\n \n\n EEL2: \n\n\n\nConverts client coordinates x,y to screen coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n EEL2: \n\n\n\nCall with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/size\n\n\n\n \n\n EEL2: \n\n\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n\n\n \n\n EEL2: \n\n\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n\n\n \n\n EEL2: \n\n\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx_getchar() at least once causes mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n EEL2: \n\n\n\nEnumerates any drag/dropped files. call gfx_dropfile(-1) to clear the list when finished. Returns 1 if idx is valid, 0 if idx is out of range.\n\n\n\n \n\n EEL2: \n\n\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n\n\n \n\n EEL2: \n\n\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n\n\n \n\n EEL2: \n\n\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n\n\n \n\n EEL2: \n\n\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n EEL2: \n\n\n\nInitializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nLoad image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n EEL2: \n\n\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n EEL2: \n\n\n\nCloses the graphics window.\n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a rectangle with rounded corners. \n\n\n\n \n\n EEL2: \n\n\n\nConverts screen coordinates x,y to client coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n\n\n\n \n\n EEL2: \n\n\n\nSpecify 0 resource_id and custom_cursor_name from https://www.reaper.fm/sdk/cursors/cursors.php (e.g. 'arrow') to set the cursor. Alternatively can specify resource_id for a Windows cursor or built-in REAPER cursor.\n\n\n\n \n\n EEL2: \n\n\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n\n\n \n\n EEL2: \n\n\n\nResize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n EEL2: \n\n\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n\n\n \n\n EEL2: \n\n\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n EEL2: \n\n\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a filled triangle, or any convex polygon. \n\n\n\n\n\n EEL2: \n\n\n\nUpdates the graphics display, if opened\n\n\n\n \n\n EEL2: \n\n\n\nPerform an inverse FFT. For more information see fft().\n\n\n\n \n\n EEL2: \n\n\n\nPerforms an inverse FFT, but takes size/2 complex input pairs and produces size real output values. Usually used along with fft_ipermute(size/2).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n\n\n \n\n EEL2: \n\n\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax. \n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n• %x, %d, %u, and %f are available for use similarly\n• %c can be used, but can't take any length modifiers\n• Use uppercase (%S, %D, etc) for lazy matching\n\n \n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n\n\n \n\n EEL2: \n\n\n\nCase-insensitive version of match().\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nShuffles contents of buf right by 1, inserts value at buf[0], returns previous buf[len-1].\n\n\n\n \n\n EEL2: \n\n\n\nCalculates the sum of the products of values pointed to by src1 and src2. If src1 is -1, then calculates the sum of squares of src2, if -2, the sum of the absolute values of src2, if -3, calculates the sum of the values of src2. Other negative values are undefined.\n\n\n\n \n\n EEL2: \n\n\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n\n\n \n\n EEL2: \n\n\n\nSets length items of memory at offset to value.\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n\n\n \n\n EEL2: \n\n\n\nReturns a pseudorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n EEL2: \n\n\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n\n\n \n\n EEL2: \n\n\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include: \n\nMany standard C printf() modifiers can be used, including:\n• %.10s = string, but only print up to 10 characters\n\n \n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n\n\n \n\n EEL2: \n\n\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n\n\n \n\n EEL2: \n\n\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters): \n\n\n\n \n\n EEL2: \n\n\n\nInserts srcstr into #str at offset pos. Returns #str\n\n\n\n \n\n EEL2: \n\n\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. See str_getchar() for more information on types.\n\n\n\n \n\n EEL2: \n\n\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies the contents of srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n\n\n \n\n EEL2: \n\n\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the length of the string passed as a parameter\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the tangent of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n\n\n \n\n EEL2: \n\n\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n\n\n \n\n EEL2: \n\n\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n\n\n \n\n EEL2: \n\n\n\nEnds listening on port specified.\n\n\n\n \n\n EEL2: \n\n\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n\n\n \n\n EEL2: \n\n\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n\n\n \n\n EEL2: \n\n\n\nSets whether a connection blocks.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n\n\n \n\n EEL2: \n\n\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n\n\n EEL2:Returns the absolute value of the parameter.EEL2:Returns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.EEL2:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.EEL2:Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).EEL2:Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.EEL2:Returns the cosine of the angle specified (specified in radians).EEL2:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.EEL2:Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.EEL2:Returns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.EEL2:Used to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).EEL2:Closes a file previously opened with fopen().EEL2:Returns nonzero if the file fp is at the end of file.EEL2:If file fp is open for writing, flushes out any buffered data to disk.EEL2:Performs a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.Note that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.Note that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.EEL2:Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft () for more information.EEL2:Permute the output of fft() to have bands in-order. See fft () for more information.EEL2:Performs an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.EEL2:Reads a character from file fp, returns -1 if EOF.EEL2:Reads a line from file fp into #str. Returns length of #str read.EEL2:Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).EEL2:Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.EEL2:Formats a string and writes it to file fp. For more information on format specifiers, see sprintf (). Returns bytes written to file.EEL2:Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.EEL2:Hints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.EEL2:Seeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.EEL2:Retunrs the current file position.EEL2:Writes up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.EEL2:Queries contextual information about the script, typically MIDI/OSC input values.Returns true if a new value has been updated.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)EEL2:The following global variables are special and will be used by the graphics system:EEL2:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.EEL2:Copies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).If destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).EEL2:Deprecated, use gfx_blit instead.EEL2:Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.EEL2:Draws a circle, optionally filling/antialiasing.EEL2:Converts client coordinates x,y to screen coordinates.EEL2:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.EEL2:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/sizeEEL2:Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.EEL2:Draws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.EEL2:Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Lua: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()\n\nReturns contextual information about the script, typically MIDI/OSC input values.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n Lua: \n\n\n\n The following global variables are special and will be used by the graphics system:\n• gfx.a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx.mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit().\n• gfx.x - current graphics position X. Some drawing functions use as start position and update.\n• gfx.y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx.clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx.dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx.texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx.ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx.w/gfx.h/etc will be doubled, but on other systems gfx.w/gfx.h will remain the same and gfx.ext_retina is a scaling hint for drawing.\n• gfx.mouse_x - current X coordinate of the mouse relative to the graphics window.\n• gfx.mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• gfx.mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx.getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n Lua: \n\n\n\n Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n Lua: \n\n\n\n Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).\n\nIf destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n Lua: \n\n\n\n Deprecated, use gfx.blit instead.\n\n\n\n \n\n Lua: \n\n\n\n Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Draws a circle, optionally filling/antialiasing. \n\n\n\n \n\n Lua: \n\n\n\n Converts the coordinates x,y to screen coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n Lua: \n\n\n\n Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/size\n\n\n\n \n\n Lua: \n\n\n\n Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n\n\n\n \n\n Lua: \n\n\n\n Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.\n\n\n\n \n\n Lua: \n\n\n\n Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\n\n\n\n \n\n Lua: \n\n\n\n If char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx.getchar() at least once causes gfx.mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n Lua: \n\n\n\n Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n\n\n\n \n\n Lua: \n\n\n\n Returns current font index, and the actual font face used by this font (if available).\n\n\n\n \n\n Lua: \n\n\n\n Retreives the dimensions of an image specified by handle, returns w, h pair.\n\n\n\n \n\n Lua: \n\n\n\n Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n\n\n\n \n\n Lua: \n\n\n\n Fills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n Lua: \n\n\n\n Initializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx.update() should be called periodically. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Load image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a character with the current font (as set by gfx.setfont). Returns width and height of character.\n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n Lua: \n\n\n\n Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n Lua: \n\n\n\n Closes the graphics window.\n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y. \n\n\n\n \n\n Lua: \n\n\n\n Draws a rectangle with rounded corners. \n\n\n\n \n\n Lua: \n\n\n\n Converts the screen coordinates x,y to client coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n\n\n\n \n\n Lua: \n\n\n\n Sets the mouse cursor to resource_id and/or custom_cursor_name. \n\n\n\n \n\n Lua: \n\n\n\n Can select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx.setfont(), gfx.texth may be updated to reflect the new average line height.\n\n\n\n \n\n Lua: \n\n\n\n Resize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n Lua: \n\n\n\n Writes a pixel of r,g,b to gfx.x,gfx.y.\n\n\n\n \n\n Lua: \n\n\n\n Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx.showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx.showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n Lua: \n\n\n\n Blits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (table can be a regular table or (for less overhead) a reaper.array). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n Lua: \n\n\n\n Draws a filled triangle, or any convex polygon. \n\n\n\n \n\n Lua: \n\n\n\n Updates the graphics display, if opened\n\n\n\n \n\n Lua: \n\n\n\n Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach. 6.20+: returns previous shared memory segment name.\n\n\n\n \n\n Lua: \n\n\n\n Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Creates a new reaper.array object of maximum and initial size size, if specified, or from the size/values of a table/array. Both size and table/array can be specified, the size parameter will override the table/array size.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n reaper.set_action_options(flag)\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n Lua: \n\n\n\n Sets the value of zero or more items in the array. If value not specified, 0.0 is used. offset is 1-based, if size omitted then the maximum amount available will be set.\n\n\n\n \n\n Lua: \n\n\n\n Convolves complex value pairs from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs. size is in normal items (so it must be even)\n\n\n\n \n\n Lua: \n\n\n\n Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward real->complex FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Returns the maximum (allocated) size of the array.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards complex->real FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Resizes an array object to size. size must be [0..max_size].\n\n\n\n \n\n Lua: \n\n\n\n Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n\n\n\n Lua:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Lua:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Lua:is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()Returns contextual information about the script, typically MIDI/OSC input values.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)Lua:The following global variables are special and will be used by the graphics system:Lua:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.Lua:Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).If destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).Lua:Deprecated, use gfx.blit instead.Lua:Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.Lua:Draws a circle, optionally filling/antialiasing.Lua:Converts the coordinates x,y to screen coordinates, returns those values.Lua:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.Lua:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/sizeLua:Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.Lua:Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.Lua:Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Python: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n Python:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly."
    },
    {
        "link": "https://forum-amz.cockos.com/showthread.php?p=2557563",
        "document": ""
    },
    {
        "link": "https://reaper.fm/sdk/reascript/reascript.php",
        "document": "EEL2\n\n A language developed in-house (but A language developed in-house (but open source ) which has some similarities to C and JavaScript. EEL is also used to write JSFX plug-ins, OSCII-bot scripts, and video processing effects in REAPER. EEL offers high run-time performance. It supports basic UI management (dedicated script window, docking, context menus, mouse input, etc) and graphics manipulation (drawing primitives, loading image files, etc). EEL is embedded within REAPER and requires no additional downloads or settings. Lua (v5.4)\n\n A popular scripting language. Lua is probably easier to learn and use than EEL or Python, and offers good performance. It supports the same UI and graphic features as EEL. As a general-use scripting language, Lua also benefits from third-party resources, libraries, tutorials, and code examples. Lua is embedded within REAPER and requires no additional downloads or settings. Note that REAPER v6.x and earlier used Lua v5.3. Python (v2.7-v3.x)\n\n Another popular scripting language. Python must be downloaded and installed separately (see \n\n Another popular scripting language. Python must be downloaded and installed separately (see requirements ) and as such, will never be as portable between users as EEL or Lua. Within REAPER, Python performance is not as good as EEL or Lua, and does not offer any UI or graphic features. However, Python does benefit from a vast number of third-party resources, libraries, tutorials, and code examples.\n• Unknown extension API. Perhaps the script was written against a newer version of REAPER.\n• Incorrect use of the Extension API. Verify how the function parameters and return value should be used in the REAPER-generated ReaScript documentation.\n• Lua: invalid \"objects\". Check variables for before passing to functions.\n• Python: REAPER cannot find the Python library. Is the proper 32/64-bit Python installed? Is it enabled in Preferences?\n• SetExtState() and GetExtState() allow ReaScripts to set and get key/value pairs that will persist between ReaScripts, and optionally persist between REAPER instances as well. For example, a Python module called \"utility\" might want to remember that some flag is set: RPR_SetExtState(\"utility\", \"someflag\", \"2\", True) val=RPR_GetExtState(\"utility\", \"someflag\") # even if called after REAPER is closed and reopened, val will be equal to \"2\"\n• SetProjExtState() and GetProjExtState() allow ReaScripts to save data within the project RPP file.\n\nThere are also API functions for manually creating undo points, as well as API functions to Undo and Redo previous points.\n\nThe best way to manually create an undo point for your script is to call Undo_BeginBlock() before most of your code, and Undo_EndBlock() after your code finishes.\n• These functions operate on the active project only (if multiple tabs are open) -- do not switch project tabs from your code while in an Undo block.\n• You must always pair with . If you call and then fail to call , an undo block will be left open, which may cause undesired undo behaviors.\n• The final parameter of is a bitmask of what you would like to add to the undo state. If you are simply calling other actions (via or similar functions), this should be 0. If you modify the state of the project directly, it's safest to set the bitmask to -1. A more specific combination of flags may be an optimization, depending on what your script is doing.\n• Always give the \"desc\" parameter of a valid (non-empty) descriptive string."
    },
    {
        "link": "https://forums.cockos.com/showthread.php?p=2768778",
        "document": "[new scripts]Mrtnz scripts: Use and discussion \n\n Here I will share my simple scripts that I made for myself and use them regularly. \n\n \n\n \n\n \n\n Sort of like a tempo detector for item:\n\n \n\n \n\n \n\n \n\n \n\n \n\n While the shortcut is held, mutes all but the atem under the cursor(or the selected atem), soloing it, and also sets the time selection with loop enabled and plays it. (The script works as long as the hotkey is pressed).\n\n Corrections:\n\n Previously mute'd artifacts that were in the mute on completion remain in the mute\n\n If the time selection was already set before startup, it returns it back on completion \n\n If loop was not enabled, the script enables it, and on completion returns it to the way it was originally set:\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Does the same thing as the last script only toggles trim/touch for the selected track while the hotkey is pressed(thanks sexan three times, but probably more)\n\n \n\n Script: mrtnz_trim-touch track(focused fx or under mouse or selection or last touched).lua \n\n \n\n \n\n \n\n Not the most popular script, but I turn it on when I'm going to write music in fast mode \n\n While the script is on, immediately changes the input to midi > all channels after any VSTI AUI etc is placed on the track. (additionally the track is renamed to the name of that fx) \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n While active the script paints the track red if it has ARM enabled. Be careful, if you have autocolor for children, there may be failures in colors, all child tracks will be colored if you enable recording on the folder).\n\n \n\n \n\n \n\n \n\n \n\n Freeze a track, and unfreeze it if it was previously frozen(comes in the freeze/unfreeze track toolkit).\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Splits and deletes an aitem on the right or left side depending on the closest end/initial length. This is useful if you want to cut a small piece at the beginning and end:\n\n \n\n Script: mrtnz_split item under mouse cursor and remove left or right side.lua \n\n \n\n \n\n \n\n \n\n \n\n Move fx between each other with drag, move fx with mouse wheel, freeze only a few fx in a track, freeze fx in several levels\\ sub-levels and then unfreeze necessary levels, copy or move fx from script window to track with drag, create a customized \"pseudo-smart\" sidechain by sending drag sends to script window updating pins and channels, view frozen fx and return them: \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Change the pan of the two selected tracks simultaneously in the opposite direction from each other\n\n \n\n \n\n \n\n \n\n \n\n I once wondered on the reaper forum about the smoothness of different knobs, and we came to the conclusion that this cannot be achieved due to performance. But for fun, I made the same instance of changing the panorama, which quite \"smoothly\" and animatedly allows you to change the panorama synchronously in different directions:\n\n \n\n \n\n \n\n \n\n \n\n \n\n If you want something new, you can change synchronously the pan parameter of the two selected tracks with a tricky animation that reaper does not have. Visually beautiful? - Yes. Practical? - Not really, but it works \n\n \n\n In the reapack the script is called Change the pan of two tracks to the opposite side(animated). - after installing it you will see two instances of the script for forward and backward direction.\n\n \n\n mrtnz_change the pan of two tracks to the opposite side(forward, animated version).lua \n\n \n\n mrtnz_change the pan of two tracks to the opposite side(backward, animated version).lua \n\n \n\n \n\n \n\n edit:\n\n I advise you to trigger the script to run multiple times so that such a window appears. Next, check the \"Remember my answer for this script\" checkbox and then select \"New Instance\". Then there will be no problems for sure!\n\n \n\n \n\n \n\n \n\n \n\n \n\n ...There will be more scripts here after the edit....\n\n \n\n Sort of like a tempo detector for item:While the shortcut is held, mutes all but the atem under the cursor(or the selected atem), soloing it, and also sets the time selection with loop enabled and plays it. (The script works as long as the hotkey is pressed).Corrections:Previously mute'd artifacts that were in the mute on completion remain in the muteIf the time selection was already set before startup, it returns it back on completionIf loop was not enabled, the script enables it, and on completion returns it to the way it was originally set:Does the same thing as the last script only toggles trim/touch for the selected track while the hotkey is pressed(thanks sexan three times, but probably more)Not the most popular script, but I turn it on when I'm going to write music in fast modeWhile the script is on, immediately changes the input to midi > all channels after any VSTI AUI etc is placed on the track. (additionally the track is renamed to the name of that fx)While active the script paints the track red if it has ARM enabled. Be careful, if you have autocolor for children, there may be failures in colors, all child tracks will be colored if you enable recording on the folder).Freeze a track, and unfreeze it if it was previously frozen(comes in the freeze/unfreeze track toolkit).Splits and deletes an aitem on the right or left side depending on the closest end/initial length. This is useful if you want to cut a small piece at the beginning and end:Move fx between each other with drag, move fx with mouse wheel, freeze only a few fx in a track, freeze fx in several levels\\ sub-levels and then unfreeze necessary levels, copy or move fx from script window to track with drag, create a customized \"pseudo-smart\" sidechain by sending drag sends to script window updating pins and channels, view frozen fx and return them:Change the pan of the two selected tracks simultaneously in the opposite direction from each otherI once wondered on the reaper forum about the smoothness of different knobs, and we came to the conclusion that this cannot be achieved due to performance. But for fun, I made the same instance of changing the panorama, which quite \"smoothly\" and animatedly allows you to change the panorama synchronously in different directions:If you want something new, you can change synchronously the pan parameter of the two selected tracks with a tricky animation that reaper does not have. Visually beautiful? - Yes. Practical? - Not really, but it worksIn the reapack the script is called- after installing it you will see two instances of the script for forward and backward direction.edit:I advise you to trigger the script to run multiple times so that such a window appears. Next, check the \"Remember my answer for this script\" checkbox and then select \"New Instance\". Then there will be no problems for sure!...There will be more scripts here after the edit.... Last edited by erikmartinez; 12-15-2023 at .\n\n\n\n One of the big custom actions that turned into a script. It seems to work consistently, but sometimes not reliable since this is where I started to learn how to write. - \n\n The script sets Pre-Reverb\\Reverb Swell, Reverse Reverb at the set time selection and the selected aitem. You can use any length you want, as well as four popular reverbs:\n\n The script will determine the length of the time selection and set the decay\\length normalizing this parameter to the time selection, so the script can be called a bit \"smart\". You can also use any other reverb you like by presetting it, but the script is not so smart to change the length of absolutely any fx . I used GLUE as a basis to quickly apply the effects, and to avoid taking tail fx thanks to Meo Ada the script will set the right Tail Fx length, do its thing and then return everything as it was originally. So it's the fastest way to create a reverse reverb (it can also work with midi aitems, it just takes a bit more time). Demo: \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n If I have time and someone likes it, I will continue to work on it, as I was going to make a kind of builder of inverse reverbs with envelope support, fx chains and stuff like that\n\n \n\n \n\n \n\n If you want to use a virtual keyboard (VKB) but you don't want to see it, then you can use this script that automatically opens the virtual keyboard and hides it outside the window, as well as in a \"smart\" way turns on the midi message, and sets rest/month on the selected track if it has a Forex tool. I'm going to make a second version of the script that will allow, on the contrary, to run only at the moment when the track with the AC tool is selected and if it has a course enabled, then it will run. Let me know if you need it too:\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n I've long needed a quick way to create a tape slowdown, tape stop, tape stop effect. I usually use a free plugin for this - kHs Tape Stop, and for a faster speed I wrote a simple script that does the following just for this fx:\n\n Along the length of the razor edit creates an envelope item, and in that area sets the stop parameter to \"on\" mode to activate it in the desired range. And also sets the stop time relative to the length of the razor-edit. You can disable the automatic length setting by clearing the flag in the editor here to false:\n\n To quickly create the desired slowdown effects without auto-setting. Also, the exact same script will be attached to this script soon, but it will be placed inside an athame and set the envelope points. \n\n \n\n \n\n \n\n Demo:\n\n \n\n \n\n \n\n One of the big custom actions that turned into a script. It seems to work consistently, but sometimes not reliable since this is where I started to learn how to write. -The script sets Pre-Reverb\\Reverb Swell, Reverse Reverb at the set time selection and the selected aitem. You can use any length you want, as well as four popular reverbs:The script will determine the length of the time selection and set the decay\\length normalizing this parameter to the time selection, so the script can be called a bit \"smart\". You can also use any other reverb you like by presetting it, but the script is not so smart to change the length of absolutely any fx. I used GLUE as a basis to quickly apply the effects, and to avoid taking tail fx thanks to Meo Ada the script will set the right Tail Fx length, do its thing and then return everything as it was originally. So it's the fastest way to create a reverse reverb (it can also work with midi aitems, it just takes a bit more time). Demo:If you want to use a virtual keyboard (VKB) but you don't want to see it, then you can use this script that automatically opens the virtual keyboard and hides it outside the window, as well as in a \"smart\" way turns on the midi message, and sets rest/month on the selected track if it has a Forex tool. I'm going to make a second version of the script that will allow, on the contrary, to run only at the moment when the track with the AC tool is selected and if it has a course enabled, then it will run. Let me know if you need it too:I've long needed a quick way to create a tape slowdown, tape stop, tape stop effect. I usually use a free plugin for this -, and for a faster speed I wrote a simple script that does the following just for this fx:Along the length of the razor edit creates an envelope item, and in that area sets the stop parameter to \"on\" mode to activate it in the desired range. And also sets the stop time relative to the length of the razor-edit. You can disable the automatic length setting by clearing the flag in the editor here to false:To quickly create the desired slowdown effects without auto-setting. Also, the exact same script will be attached to this script soon, but it will be placed inside an athame and set the envelope points.Demo: Last edited by erikmartinez; 12-14-2023 at .\n\nHi everyone and thanks for the kind words, glad you like it. Feel free to ask any questions regarding these or possible scenarios!\n\n \n\n \n\n Maybe a link to this thread could be added in your repo's about section, and the descriptions here added to the script's about tags so it shows up in ReaPack. Installed many of these from ReaPack but wasn't sure on the usage so this thread is helpful.Maybe a link to this thread could be added in your repo's about section, and the descriptions here added to the script's about tags so it shows up in ReaPack. Good point, I've only recently figured out the invention of reapack and familiarized myself with github, I was thinking of just trying it out and then creating a new (clean) repo, but went ahead with this one. I'll find a minute and move everything described here to 'about' scripts!\n\n \n\n \n\n Beautiful scripts. Thanks for making them! Just donated WOW! Arthur McArthur, I can't find the words to thank you, that's very generous of you! It really put me through the wringer and because I wasn't expecting this, thank you! You are always welcome to contact me, even though you write scripts too\n\n \n\n \n\n Can I suggest you replace \"My\" by your pseudo or name in the thread name?\n\n \n\n \n\n will avoid confusion and be better for SEO and forum search 😉 Yes, you're right. I changed the title, so I think it will be clearer \n\n \n\n \n\n \n\n \n\n And when loading the chopper I get the error message \"...Scripts/ReaperScripts/MIDI Editor/mrtnz_MIDI chopper.lua:376: ImGui_SetNextWindowSize: ImGui assertion failed: (0) && \"Could not load font file!\"\" Although I have one question regarding the vbk-hiding script: The keyboard is still shown on the bottom left on my screen, do you think there is a way to completely hide it?And when loading the chopper I get the error message \"...Scripts/ReaperScripts/MIDI Editor/mrtnz_MIDI chopper.lua:376: ImGui_SetNextWindowSize: ImGui assertion failed: (0) && \"Could not load font file!\"\" I have released update 1.03, it added a new flag and two parameters to offset the coordinates of the VKB window, if the problem still persists try playing with these two parameters to hide the window outside the window. Unfortunately, most of the problems that can be on mac with my scripts I can't test properly, so I have to ask users \n\n \n\n Parameters:\n\n \n\n Is the pre-reverb verson 1.5. from the screenshots available to download? I seem to only get 1.0 through the repository and don't understand yet how to change the preset from the reverbs (if that's possible at all, or does the script always use the \"default\"-state of the reverbs? It also seems that it doesnt matter how long my time selection is - even when time-selecting only a small part of the item there is always the complete item processed. Yes, I highly recommend updating or completely reinstalling (or synchronize packages) the repository to install the latest versions of everything. Version 1.0 works a bit differently and has no presets. In order for the plugin you are using to have a preset changed, you need to pre-create it with either the name 'preverb' , or any other name (one for all) which would also need to be changed in the editor:\n\n In this preset you can make the desired customization, for example changing the attack or pre-delay to your liking. I wanted to add randomization of the parameters of these fx in the future except of course decay.\n\n Also note that the time selection will only set the reverb (decay) length of the four fx:\n\n Otherwise if these fx don't have a saved preset, it will just adaptively change the decay depending on the length of the time selection, which is already pretty handy \n\n \n\n And when loading the chopper I get the error message \"...Scripts/ReaperScripts/MIDI Editor/mrtnz_MIDI chopper.lua:376: ImGui_SetNextWindowSize: ImGui assertion failed: (0) && \"Could not load font file!\"\" I tried to solve the problem in version 1.3(don't forget it's only alpha), let me know if everything works or if you still get this error. As I wrote above, I have problems with not being able to test scripts on systems other than windows, so you are doing me a favor! -- @version 1.3 Good point, I've only recently figured out the invention of reapack and familiarized myself with github, I was thinking of just trying it out and then creating a new (clean) repo, but went ahead with this one. I'll find a minute and move everything described here to 'about' scripts!WOW! Arthur McArthur, I can't find the words to thank you, that's very generous of you! It really put me through the wringer and because I wasn't expecting this, thank you! You are always welcome to contact me, even though you write scripts tooYes, you're right. I changed the title, so I think it will be clearerI have released update 1.03, it added a new flag and two parameters to offset the coordinates of the VKB window, if the problem still persists try playing with these two parameters to hide the window outside the window. Unfortunately, most of the problems that can be on mac with my scripts I can't test properly, so I have to ask usersParameters:Yes, I highly recommend updating or completely reinstalling (or synchronize packages) the repository to install the latest versions of everything. Version 1.0 works a bit differently and has no presets. In order for the plugin you are using to have a preset changed, you need to pre-create it with either the name 'preverb' , or any other name (one for all) which would also need to be changed in the editor:In this preset you can make the desired customization, for example changing the attack or pre-delay to your liking. I wanted to add randomization of the parameters of these fx in the future except of course decay.Also note that the time selection will only set the reverb (decay) length of the four fx:Otherwise if these fx don't have a saved preset, it will just adaptively change the decay depending on the length of the time selection, which is already pretty handyI tried to solve the problem in version 1.3(don't forget it's only alpha), let me know if everything works or if you still get this error. As I wrote above, I have problems with not being able to test scripts on systems other than windows, so you are doing me a favor! -- @version 1.3"
    },
    {
        "link": "https://mespotin.uber.space/Ultraschall/Reaper_Api_Documentation.html",
        "document": ""
    }
]