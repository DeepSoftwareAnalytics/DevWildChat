[
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-roblox-pathfinding-service-20/1857779",
        "document": "Ladies and gentlemen welcome back to another Roblox scripting tutorial where in today’s tutorial we are going to talk about how you can use Pathfinding service in Roblox!\n\nLet’s see where we left off last time…\n\nIt’s been more than a year since this topic was mentioned on here…\n\nWell, it’s been a year since I said that and everyone was wondering where is it…\n\nWell here it is! I was just being a lazy couch potato and can’t think of new ideas on how to make this more interesting, until some new additions to the pathfinding service, such as the new Pathfinding Modifiers.\n\nSo buckle your seatbelts up everyone. because today we are going to learn:\n• Explaining why my old tutorial about Pathfinding Service is bad\n\nIf this is your first time learning Pathfinding service, you can still read this tutorial as I’ve planned this tutorial to rework on the old one since the old script from the old tutorial is inefficient and buggy… heh. Without any further ado, let’s get rolling!\n\nThis section will cover the nitty-gritty of utilising to its maximum. At the end of this section, you will be able to script a humanoid that can walk to a certain position and smartly create a new path to the position again if it is blocked by another part when traversing through the path.\n• Get a working R6 or R15 dummy model in your game. You can do this by using the Rig Builder plugin provided by Roblox Studio default. im gonna use r15 in this case\n• Most important step, unanchor every single BaseParts in the dummy model. This is to ensure that the model can walk without any anchored parts connecting it to prevent it from walking. You can simply click the model in the explorer tab and unanchor the model.\n• Insert a server script in the model and declare a few variables such as referring Pathfinding service itself, the model, humanoid instance and HumanoidRootPart.\n• Now, we will use function. As its name suggests, it basically creates a instance which we are going to use. Don’t mind the argument in the function. We will cover that later. We are also going to define some constants which is useful for our functions soon. We will also declare a variable named which will be useful soon.\n• Create a function named . This function will be the brain of the operation of this whole thing. Add two parameters, and (determines whether or not to yield the script until the humanoid has reached the destination.) After creating the function, call it with the respective arguments. I have created a base part named under workspace.\n• Now let’s dive into the main part! To create or compute the path between two points, we have to use on the instance we have created through . The first argument of the function is the starting point (I use the root part’s Position) and the second argument is an ending point (targetPosition parameter), both in terms of . This function makes network calls, in other words, this function can fail from time to time due to network errors (or just backend issues that you can’t control), so in order to counter this, we will use along with a retry system. If the function has retried a lot of times and it still fails, then we will not do anything but warn the error message in the output. local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 -- add one retry success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then -- if it fails, warn the message warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then -- if computing the path has no issues else -- if retry chance is maxed out warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end Notice that I did not use the function like so: This is because it creates another function to do another function, which is unnecessary work. So I just typed out like that to save some spaces. Also notice that I did not use when indexing the . is not suitable to be used here so we use , and then the second argument of that is the instance itself because\n• If the function was successfully called with no issues, then we must check if the function was able to find a path between the two points. If it can compute a path, then will be . Hence, we can get the path’s waypoints, a table consisting of all points the humanoid must traverse through to get to the end goal, and cycle through each waypoint. We will create a variable which tells the humanoid to move to the corresponding waypoints. We will then use to tell the humanoid to walk to that waypoint’s position, which can be accessed by getting the waypoint’s position property shown in the code below. If the waypoint requires the humanoid to jump, we will set to true. if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 -- not 1, because 1 is the waypoint of the starting position. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) -- move to the nth waypoint if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then -- if it requires the humanoid to jump humanoid.Jump = true end else -- if the path can't be computed between two points, do nothing! return end else -- this only runs IF the function has problems computing the path in its backend, NOT if a path can't be created between two points. warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end\n• Awesome! But we only told the humanoid to move one waypoint, so how do we cycle through the whole waypoints? If you think of using , you are right! BUT, for loops are not suitable in this case. I will tell you why later. Instead, we will use an event called . This basically gets fired every time the humanoid has reached a position called by . In this case, this event gets fired every time it has reached a waypoint. When the event fires, we want to check if it has reached the waypoint in time (8 seconds) and has yet to reach the end goal, then we will tell the humanoid to move to the next waypoint. if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end end end) end humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else return And we are done! For now. If your script has no issues and run the game, your humanoid would start walking to its assigned end goal. Works smoothly, but there are some issues you have probably noticed besides the video if you pay attention closely. Firstly in the video, the humanoid model walks to the end goal without playing any idle or running animation. This is because we don’t have a script that handles the animation of the script. To solve this issue, we can script a- “WE DO NOT WANT TO SCRIPT A STUPID ANIMATION SCRIPT” Okay, that’s fine! We have another method which is as shortcut. What we can do is we can “steal” the animation script inside of our character’s player model. All you need to do is run the game with your character, find your character model in Workspace, find a script called Animate, copy it, stop the game and paste it in workspace. You should notice there are also other things parented underneath it, all you need to do is delete the named , and then transfer the whole script into a server script since local scripts don’t work and you are done. Sure, I have uploaded the scripts required to handle the animations. All you need to do is just select the script according to your rig type, place it under your humanoid model and let it do all the magic. Onto the next issue, notice that our connection variable never disconnects. This can cause unnecessary memory leaks when something is no longer needed. Memory leaks can cause your game to use up more memory which is unnecessary and jamming up the performance. So what do we do? That’s right! We have to disconnect the event when the path has been cycled. To do this, we can add an statement inside the connected function where we tell the script to disconnect the event. reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() reachedConnection = nil -- you need to manually set this to nil! because calling disconnect function does not make the variable to be nil. end end) Memory leaks is a wide and challenging topic to understand and overcome (at least for me), if you are interested in learning more, you can check out this awesome tutorial. Furthermore, you will notice that our dummy model is unable to handle paths that are blocked, as shown in the video below:\n\n This might not be an issue if your NPC is only moving from one location to another location for only one time and the path is inaccessible by other things, but, for the sake of this tutorial, we will combat all normal and common kinds of issues you have to deal with in . So how do we approach to this issue? Luckily, there’s an event called for every object created through the service. This event, you guessed it, basically fires every time the path is being blocked by a physical part, so all we can do is, every time this event gets fired, we will tell the bot to stop cycling through its currently assigned path, compute a new one with the same arguments, and then cycle that newly created path. But here’s the problem, the event does not know whether the waypoint of the path being blocked has been cycled through by the bot. Thankfully, the connected function of the event provides an argument we can use, that states the number of waypoint that is currently being blocked. For example, if there is a part blocking between the 5th and 6th waypoint, the event will fire and give the number 6 as the argument in the connected function. To take advantage of this, we can check whether the current waypoint index is smaller than this number, and if it is, we will tell the bot to stop cycling through the current path and follow the newly computed one. Otherwise, we will do nothing as that waypoint has been cycled through.\n• Create a new variable called under the variable .\n• In the function right after setting up the connection, set to the event and connect it to a function. Make sure you create a parameter that represents the blocked waypoint index. Go ahead and set up the function with the applied description of it I just have just given. pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then -- blocked path is ahead of the bot reachedConnection:Disconnect() -- disconnect these events to prevent memory leaks pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) -- compute and cycle new path end end) Since also contains an event like how has as well, you have to disconnect it and set it to nil when it is no longer used, so apply this logic also when is unnecessary. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil end Give it a test and it should be working!\n\n One thing that I have totally forgotten is the parameter in our function. We are going to need to implement a function for that.\n• At the top of the script where the constant variables lives, creating a new constant variable named , this will contain a boolean value that tells us if the function will yield. This must be in the main scope of the script and not the local scope as re-computations of new paths when the old path is blocked needs to refer it.\n• In the main function after the two setups of the connections, we will use a loop to yield the main thread when the function needs to yield, until becomes true. humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else\n• We have to set to false at some part in our script so that it can stop yielding and move onto the next parts of the script, so we have to do that when the path has been fully cycled through. And that’s actually it for the basic usage of service. Here’s the full code. -- SERVICES -- local PathfindingService = game:GetService(\"PathfindingService\") -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local model = script.Parent local humanoid = model.Humanoid local humanoidRootPart = model.HumanoidRootPart local path = PathfindingService:CreatePath() local reachedConnection local pathBlockedConnection local function walkTo(targetPosition, yieldable) local RETRY_NUM = 0 local success, errorMessage repeat RETRY_NUM += 1 success, errorMessage = pcall(path.ComputeAsync, path, humanoidRootPart.Position, targetPosition) if not success then warn(\"Pathfind compute path error: \"..errorMessage) task.wait(RETRY_COOLDOWN) end until success == true or RETRY_NUM > MAX_RETRIES if success then if path.Status == Enum.PathStatus.Success then local waypoints = path:GetWaypoints() local currentWaypointIndex = 2 if not reachedConnection then reachedConnection = humanoid.MoveToFinished:Connect(function(reached) if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end else reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil YIELDING = false end end) end pathBlockedConnection = path.Blocked:Connect(function(waypointNumber) if waypointNumber > currentWaypointIndex then reachedConnection:Disconnect() pathBlockedConnection:Disconnect() reachedConnection = nil pathBlockedConnection = nil walkTo(workspace.EndGoal.Position, true) end end) humanoid:MoveTo(waypoints[currentWaypointIndex].Position) if waypoints[currentWaypointIndex].Action == Enum.PathWaypointAction.Jump then humanoid.Jump = true end if yieldable then YIELDING = true repeat task.wait() until YIELDING == false end else return end else warn(\"Pathfind compute retry maxed out, error: \"..errorMessage) return end end walkTo(workspace.EndGoal.Position, true)\n\nThrough , we are also exposed to some features that allow us to customize our path to make it look more “smarter”. At its most basic form, service only computes a path with the shortest distance as much as possible. It ignores whether or not if the path that is computed is suited for your expectations and preferences. If we were to use our script and make our character model to walk to the red part, it would walk in a straight line like so.\n\n But what if we wanted our character to move along the blue lines?\n\n This is where s come in! They are modifiers that allows to compute paths that suits our preferences. Not only that, we can also adjust some other properties that affects the final path as well. To understand what they are, meet the dictionary. If you look at the developer hub, you’ll find information about it, but I will explain all of its properties simply here:\n• AgentRadius key determines the radius of our character. This is useful if we want to keep up a minimum separation distance between our character and its surrounding obstacles. Default value is 2, which is the default radius value of all rigs in Roblox. Anything higher than the default value will make the character have a minimum separation distance between obstacles with this formula:\n• AgentHeight key is self explanatory. The default value of 5 is the default height for all rigs in Roblox.\n• AgentCanJump key is also self explanatory. Determines whether or not our character can jump. Default value is true.\n• AgentCanClimb key determines whether or not the humanoid can climb (only using Roblox’s truss part, you have to program your own climbing logic and use if you are not using the truss part!) . Default value is false.\n• WaypointSpacing key determines the minimum amount of spacing between waypoints in a straight line(waypoints around a corner does not count). Default value is 4. If set to , it will create the least amount of waypoints whilst still providing the shortest path as much as possible. NOTE that changing this value does not respect the parameter/argument mentioned in the connection. For instance, if you make each waypoints too far away from each other in a path, the value will return even when your humanoid reaches the waypoint in more than 8 seconds. i am unsure if this will increase performance soo lol\n• Costs key contains a dictionary for our . Feel free to mess around with the other keys, since they are easy to learn. This part of the tutorial will mainly focus on the object in the key. When I first learnt about this, I was puzzled. Thankfully, @Hexcede managed to brighten me up! So what do these things do? These things are also known as “multipliers”, meaning that if I set a higher number in this multiplier, it will make the path “harder” to traverse/walk through it. For instance, imagine a path that has a distance of 100 studs before reaching a goal. If I set a cost of multiplier of 5, this will make it so that this path is 5x harder to traverse. It sounds confusing, but the point here is that it stores a multiplier value that decides on how hard is to get to the goal through this goal. You might be asking what is this multiplier value multiplying with? Well, we don’t have a clear answer but according to @Hexcede, costs are somewhat directly proportional to distance traveled. This means, the higher the cost, the harder it is for the humanoid to traverse that path. For example, travelling on 30-studs-long path with a cost value of 10 will cost around 300 to travel on, on the other hand a 100-studs-long path with a cost value of 2 will cost 200 to travel on. In conclusion, would prefer the 100-studs-long path because it costs less than 100 by the 30-studs-long path. This allow us to make our humanoids walk on longer paths with a low cost value over short paths with a high cost of values. Imagine a situation where you wanna force a humanoid to walk on the longer path when it has to choose which path to go, each with different lengths in studs. With the Costs parameter, we can make it so that the shorter path costs more than the longer path to travel, which will make pathfinding service to choose the longer path instead. How is this useful you may ask? Well, just like the problem I have shown earlier, we can make it so that pathfinding service will choose to walk on the Cyan paths by lowering the cost to travel on that part. How do we do that? We can either make it so that the cost of traversing to the goal through the corroded metal part is higher than the cost of the Cyan parts or lower the cost of traversing on the Cyan parts. The way on how we lower the cost is by simply giving it a multiplier value of less than 1, because any number that is multiplied with less than 1 will output a lower number than its original. For instance, . The addition of this is also as simple as how we implement our method to counter blocked paths. It just needs one variable and that’s it! At the beginning of the script, we create a variable named which contains a dictionary to customize our computed path. Inside it, we will add the key which contains another dictionary to store all the costs to traverse on certain parts/materials. In our case, the Cyan part has a metal material, so we would have to name the key as Metal exactly, then its value will be the multiplier cost. I am going to set this lower than 1 so that pathfinding service would likely choose that material to be appeared in our final path more often. local Path:Path local AgentParameters = { WaypointSpacing = 4, Costs = { Metal = 0.1 -- if your material is other than Metal, name that material as the key exactly. -- set it to lower than 1 to make the service more likely to include that material in the path } } Path = PathfindingService:CreatePath(AgentParameters) -- the function receives an optional parameter which contains our AgentParameter dictionary in order to customize our path. In the dictionary, each key inside it can either be the name of a material, terrain material of a unique ID for a object which I will demonstrate later. And that’s actually it! No catches, no strings no nothing. Let’s compare it with a path without the costs. Without the dictionary (all costs are the same)\n\n With the dictionary (Metal material cost is 0.1)\n\n Of course, as I’ve said it is not limited to just BasePart materials, it can also be a terrain material or the object! \n\n the big corroded metal part contains the pathfinding modifier object \n\n \n\n Use the Label property as the name of the key. local AgentParameters = { WaypointSpacing = 4, Costs = { AvoidThis = math.huge -- this will make it so that this part will never be included in the path even though it is the only way to get to the goal } } The object is useful if you want to define a certain region in your game as either traversable or not. To do this, you can define the region using a part, make sure its CanCollide property is false and make it transparent. To define the region as non-traversable, you can set its cost to a higher value according to the Label property of its object. Otherwise, check the PassThrough property and the service will mark the region as traversable. You do not have to set its cost in this case. This is extremely useful if you are making a bot to walk through a hinged door in your game. There is also a object, which is useful if you wanna trigger a custom event through attachments when your humanoid object is heading to a certain waypoint in the path. This is also useful if you want to make the humanoid traverse to waypoints that are impossible to get to without a special function that makes it possible to traverse. You can check out the developer hub as it has already explains it well, but I will just do one example. Let’s say I want this humanoid to jump over the gap to get to the red block:\n\n If we use to compute the path, it fails because it is unable to find a clear path for the humanoid to traverse through. BUT, if we use , this is possible!\n• First, add two attachments and parent them under 2 parts. In this case, I will put one attachment each in the 2 big parts in the photo I have just shown.\n• Then, position both attachments to your desired location. As long as it is logical, it will work. In my case, I have to place it close but not touching to each other like so:\n\n This really depends on where you want your humanoid to utilise these special waypoints, so you have to experiment this a lot to find your sweet spot.\n• Now, add a object. Give it a name. I’ll call mine\n• In the properties panel, assign and to those attachments. The order does not matter .Name the label as the name of your object.\n\n \n\n forgot to name my Label Also just in case if you are wondering, is the reason why the order of the attachments does not matter. If it is false, then is the starting point and is the ending point.\n• Back inside the script, let’s create a dictionary, where inside the dictionary, we will add our label with its respective value. I’ll give it a 2 so that it prefers walking instead of jumping assuming the gap is connected with a part. -- CONSTANTS -- local MAX_RETRIES = 5 local RETRY_COOLDOWN = 5 local YIELDING = false local AGENT_PARAMETERS = { AgentCanClimb = true, -- this does not matter. i just want my humanoid to jump. Costs = { JumpGap = 2 } }\n• To make this easier for you to add and update new objects you may add in the future, we will create a dictionary which stores a key equivalent to a label’s name, and its respective value which is a function that stimulates the logic of that label. In our case, we want the humanoid to jump when it has reached that special waypoint (created by the first attachment), and then move to its connected waypoint (the second attachment). -- SPECIAL WAYPOINTS FUNCTIONS -- local SPECIAL_WAYPOINTS = { JumpGap = function(model, waypoints, currentWaypointIndex) -- every other logic functions may need to use these arguments for their own logic. local humanoid = model:FindFirstChildWhichIsA(\"Humanoid\") if humanoid then humanoid.Jump = true humanoid:MoveTo(waypoints[currentWaypointIndex + 1].Position) end end, } -- remember, key = label, value = its logic function.\n• In the variable which stores the event with its connected function, after we add one to , we will need to check if this next waypoint’s label ( ) can be found in the table, and if such value exists, we will call that function, simple as that! Otherwise, we just tell it to move to the next waypoint. if reached and currentWaypointIndex < #waypoints then currentWaypointIndex += 1 if SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label] ~= nil then SPECIAL_WAYPOINTS[waypoints[currentWaypointIndex].Label](model, waypoints, currentWaypointIndex) else humanoid:MoveTo(waypoints[currentWaypointIndex].Position) end And you are basically done!\n\n This pretty much concludes how you can modify paths for your own liking using some special features offered by PathfindingService`.\n\nI’m sure all of you have at least play a game where you have to escape from a threat before it gets you, take the game Piggy for example. In the game, a bot would spawn and pathfind its way to chase the closest player near to itself and when it touched the player, the player dies. How does this work using pathfinding script? If you’ve dissected a bot AI chasing model, you’ll notice that most of them contains a function that gets the closest player’s character’s torso, and then pathfind it by only making the humanoid walking to either the second or third waypoint of the path. Why is that? Based on my experience, I am sure it is something to do with whatever the bot is trying to get to. The script that I have taught you guys just now isn’t suitable to do such things. Here are a number of reasons:\n• The script itself generally is only used for bots that is going to pathfind a location that’s fixed. If you are going to make a pathfind script for a bot that’s going to constantly chase a player that its position is dynamically changed every few seconds, it’s better if we just don’t make the bot walk through the whole series of the path, instead we want it to only walk to either the second or third waypoint of the path. With this, the bot doesn’t have to wait until it finishes looping through the whole path and start going to another position after that.\n• The script can be severely deoptimized if not used right. The main reason why my previous pathfinding script in my last Pathfinding Service usage tutorial sucks and deoptimized is because of how frequently it is called per second. Previously, I would use a repetitive loop that spawns around 60 threads per second using event. The result? The script ended up calling that same function around 60 times per second and that is not good. To add the salt on the wound, there is a in the function which would be ran around 60 times per second or the same rate as how many times the function was called per second. This ended up making our bot look buggy and stuttering. So how do we solve this? Simple, with the logic I’ve explained in the previous reason, we will need a loop that waits for the humanoid to stop walking to the waypoint before executing the same function over and over again. loop is already good enough as it doesn’t spawns multiple threads per second and it yields if any code inside it has a yielding function.\n• The events (for handling blocked path and waypoint reached) connected inside the script would just add more performance drop in our script, but without it how can we solve such problems? Well, the first reason I’ve stated is already enough to counter this problem. Since the position of the player’s character model is constantly changing, we would compute a new path every time the while loop has done executing the function (when the yield is finished), and when we compute a new path, we would have a new series of waypoints with different positions. By computing a new path everytime our bot has reached to the second/third waypoint of the previous path, the computation of the path would avoid any obstacles and go around it to make our bot get to us without any issues. Now that I’ve explained the reasons why, it’s time to create a new script. The flow of the script is simple. Everytime the while loop runs, it will call a function which tells the script to detect any closest player to the bot itself. If it managed to find one, we will tell the script to compute the path to it, and make our bot to only loop/walk through the second or third waypoint of the path before ending the function. Then this whole sequence would be repeated until our bot touches the player and makes the player die. Simple enough. This part of the tutorial will be out soon.\n\nI hope this tutorial benefits you. If there is any questions, feel free to leave a comment down…"
    },
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-use-pathfinding-service-in-roblox/881628",
        "document": "DISCLAIMER: THIS THREAD IS OLD AND OUTDATED, REFER TO THE NEWEST VERSION OF THIS THREAD: How To Use Roblox Pathfinding Service 2.0\n\nHello everyone! This is my first tutorial. Please correct me anything if I taught something wrong.\n\nIn this post, I will be teaching you guys on how to use the Pathfinding service in Roblox! This tutorial is specially for people who are decent at scripting and new to this service. Anyway without ay further ado...\n\nWhat the heck is Pathfinding service? In Roblox, PathfindingService is a service used to find a clear path between 2 points/destination. Imagine an NPC that can walk with this service. Pretty uninteresting right? Well, with PathfindingService, the NPC will find a clear path to walk to it’s destination without getting stuck at blocking obstacles. This will make the NPC smart enough to get to a specific position.\n\nThis is because, as I’ve stated earlier, PathfindingService allows an NPC to find a clear path between 2 destination points. If you get the idea, a clear path means a path with nothing to block the path. You might be asking, why can’t we just use the MoveTo() function from the humanoid instead? This is because MoveTo() function will ONLY find the fastest path, which is a straight line, from one point to an end point. This makes it hard for the NPC to reach because imagine there’s gaps between the path, blocking obstacles, jumping platforms and even more! With PathfindingService, this issue will be resolved.\n\nHow can we use it? Glad you asked! Follow the steps below.\n• Make sure you use a server script for this, and maybe try to parent it in a NPC model so we can script more easily.\n• Remove the code inside it and get the service of it.\n• Now, let’s create some variables for the NPC’s root part, humanoid and the destination/position we want it to walk to. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead.\n• Cool! Now we can start the real stuffs here. We need to create a path so we can tell the NPC to walk to that destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath()\n• Alright, now we need to give the two points to the path variable so that we will successfully create a path between the starting point and the ending point. Okay, you might be a bit confused. But let me explain. We re calling our path variable and then we use a function called ComputeAsync() which will create a clear path between 2 points. The first parameter of the function is the starting point of our path, in this case we use rootPart.Position as the starting point, then we use destination as our ending point of the path, which is the second argument we need to pass in this function. NOTE: IF YOU'RE NOT USING VECTOR3 AS THE DESTINATION, YOU CAN USE A PART'S POSITION AS THE ENDING POINT. MAKE SURE TO ADD .Position !!! WHICH WILL BE LIKE ComputeAsync(rootPart.Position,part.Position).\n• Now that we have computed the path, it will provide a series of waypoints, which we will tell the NPC to move to each waypoint until it reached it’s destination. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints()\n• Now, we will use a for loop so that we can tell the NPC to move to each waypoint after they’ve reached the previous ones. local pathfinding = game:GetService(\"PathfindingService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local humanoid = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local path = pathfinding:CreatePath() path:ComputeAsync(rootPart.Position,destination) local waypoints = path:GetWaypoints() for i,v in pairs(waypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end Okay, so what we did is, for every waypoint that’s being iterated in the table of waypoints, we tell the NPC to move to that waypoint using MoveTo(). The gaps between each waypoint is small enough for the NPC to walk to the next waypoint in a straight line. Then, you’ll notice there’s an if statement to it. This checks if whether the NPC reaches a waypoint that needs the humanoid to jump or not. Waypoints have a property called Action and this have 2 values, Jump and Walk. The waypoint will determine whether it’s action is either Jump or Walk. So, we use an if statement to check if the action is jump using an enumeration of PathWaypointAction. If it’s true, we will set the humanoid’s jump to true. And this should work now! Play the game and see the magic happens. Due to my trashy laptop, I’m unable to record it working in Roblox Studio. And there you go! You successfully make a smart NPC!\n\nWait! How can we make it so that when it handles blocked paths? This got me hard when I was trying to find a solution of it. While you can actually use path.Blocked event, I can’t manage to find how to use this event to handle this issue. But, the best thing we can solve this issue is to create a new path and compute it constantly. So for this, we will use RunService.Heartbeat as an alternative way for while true do loop. Then, instead of making a script that’s not good-looking, we will create functions which will do a separate job. So we will create a function that creates a path and returns it, then another function which will tell the NPC to move to each waypoints. The key is to tell the script to constantly create a new path, and compute it, as creating a path and compute it only once only keeps that path forever, so if we do this method, it will create a new clear path constantly. So if you want the full code instead of just trying to create the functions by yourself, here it is. NOTE: I wouldn’t recommend you guys to copy this code. Try to be creative and use your brain instead! local pathfinding = game:GetService(\"PathfindingService\") local run = game:GetService(\"RunService\") local rootPart = script.Parent:WaitForChild(\"HumanoidRootPart\") or script.Parent:WaitForChild(\"Torso\") local hum = script.Parent:WaitForChild(\"Humanoid\") local destination = Vector3.new(30,0,0) -- I'm gonna use vector3 instead. local function GetPath(destination) local path = pathfinding:CreatePath() if typeof(destination) == \"Vector3\" then -- This line is untested yet. Please tell me if it works. path:ComputeAsync(rootPart.Position,destination) else path:ComputeAsync(rootPart.Position,destination.Position) end return path end local function WalkToWaypoints(tableWaypoints) for i,v in pairs(tableWaypoints) do hum:MoveTo(v.Position) if v.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end hum.MoveToFinished:Wait() end end local function WalkTo(destination) local path = GetPath(destination) if path.Status == Enum.PathStatus.Success then -- the path will return either success as true value or nopath as false value if it's computed. WalkToWaypoints(path:GetWaypoints()) end end run.Heartbeat:Connect(function() WalkTo(destination) end)\n\nThank you for reading my post! Again, please leave feedbacks and any mistakes and corrections under this post. I will update the post if I did anything wrong.\n\nEDIT 1: I made a spelling mistake while spelling humanoid in the scripts. I accidentally spell it hum as humanoid. If you wanna change it, you can use Ctrl + H or Cmd + H while typing in the script to change these spellings immediately. Sorry for the mistake!"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/PathfindingService/CreatePath",
        "document": "-- This model contains a start, end and three paths between the player can walk on: Snow, Metal and LeafyGrass\n\n-- This will ensure the path created avoids the Snow and Metal paths and guides\n\n-- the user towards the LeafyGrass path\n\n-- For each waypoint, create a part to visualize the path"
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/UserInputService",
        "document": "This property describes whether the user's device has an accelerometer An accelerometer is a component found in most mobile devices that measures acceleration (change in speed). For example, the following code snippet demonstrates how to check if the user's device has an accelerometer. If the device has an enabled accelerometer, you can get its current acceleration by using the UserInputService:GetDeviceAcceleration() function or track when the device's acceleration changes by using the UserInputService.DeviceAccelerationChanged event. As UserInputService is client-side only, this property can only be used in a LocalScript. This property describes whether the device being used by a user has an available gamepad. If gamepads are available, you can use UserInputService:GetConnectedGamepads() to retrieve a list of connected gamepads. As UserInputService is client-side only, this property can only be used in a LocalScript. How to Set the Active Gamepad for Input -- Nothing is connected; set up for \"Gamepad1\" This property describes whether the user's device has a gyroscope. A gyroscope is a component found in most mobile devices that detects orientation and rotational speed. If a user's device has a gyroscope, you can use incorporate it into your game using the UserInputService:GetDeviceRotation() function and UserInputService.DeviceRotationChanged event. As UserInputService is client-side only, this property can only be used in a LocalScript. This property describes whether the user's device has a keyboard available. This property is true when the user's device has an available keyboard, and false when it does not. It can be used to determine whether the user has an available keyboard - which can be important if you want to check if you can use UserInputService:IsKeyDown() or UserInputService:GetKeysPressed() to check for keyboard input. As UserInputService is client-side only, this property can only be used in a LocalScript. \"The user's device has an available keyboard!\" \"The user's device does not have an available keyboard!\" This property sets how the user's mouse behaves based on the Enum.MouseBehavior enum. It can be set to three values:\n• None — The mouse moves freely around the user's screen. — The mouse moves freely around the user's screen.\n• None — The mouse is locked and cannot move from the center of the user's screen. — The mouse is locked and cannot move from the center of the user's screen.\n• None — The mouse is locked and cannot move from its current position on the user's screen at the time of locking. — The mouse is locked and cannot move from its current position on the user's screen at the time of locking. The value of this property does not affect the sensitivity of events tracking mouse movement. For example, GetMouseDelta returns the same Vector2 screen position in pixels regardless of whether the mouse is locked or able to move freely around the user's screen. As a result, default scripts like those controlling the camera are not impacted by this property. This property is overridden if a GuiButton with Modal enabled is GuiButton.Visible unless the player's right mouse button is down. Note that, if the mouse is locked, UserInputService.InputChanged will still fire when the player moves the mouse and will pass in the Delta that the mouse attempted to move by. Additionally, if the player is kicked from the game, the mouse will be forcefully unlocked. As UserInputService is client-side only, this property can only be used in a LocalScript. -- Reset camera back to CFrame and FieldOfView before zoom -- Allow camera to be changed by script -- anything higher would make looking up and down harder; recommend anything between 0~1 -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events This property determines the sensitivity of the user's Mouse. The sensitivity determines the extent to which a movement of the physical mouse translates to a movement of the mouse in-game. This can be used to adjusted how sensitive events tracking mouse movement, like GetMouseDelta, are to mouse movement. This property does not affect the movement of the mouse icon. Nor does it affect the Camera Sensitivity setting found in the Settings tab of the client's Settings menu, which also adjusts the sensitivity of events tracking mouse movement. This property has a maximum value of 10 and a minimum value of 0. A lower value corresponds to lower sensitivity, and a higher value to higher sensitivity. When sensitivity is 0, events that track the mouse's movement will still fire but all parameters and properties indicating the change in mouse position will return Vector2.new(), or Vector3.new() in the case of InputObject.Delta. For example, GetMouseDelta will always return (0, 0). -- Reset camera back to CFrame and FieldOfView before zoom -- Allow camera to be changed by script -- anything higher would make looking up and down harder; recommend anything between 0~1 This property describes whether the user's device has a mouse available. This property is true when the user's device has an available mouse, and false when it does not. \"The user's device has an available mouse!\" \"The user's device does not have an available mouse!\" It is important to check this before using UserInputService mouse functions such as UserInputService:GetMouseLocation(). As UserInputService is client-side only, this property can only be used in a LocalScript. -- Reset camera back to CFrame and FieldOfView before zoom -- Allow camera to be changed by script -- anything higher would make looking up and down harder; recommend anything between 0~1 The MouseIcon property determines the image used as the pointer. If blank, a default arrow is used. While the cursor hovers over certain UI objects such as an ImageButton, TextButton, TextBox, or ProximityPrompt, this image will be overridden and temporarily ignored. To hide the cursor entirely, do not use a transparent image. Instead, set UserInputService.MouseIconEnabled to false. -- In order to restore the cursor to what it was set to previously, it will need to be saved to a variable -- Only update the saved cursor if it's not currently saved -- Only restore the mouse cursor if there's a saved cursor to restore -- Don't restore the same cursor twice (might overwrite another script) This property determines whether the Mouse icon is visible When true the mouse's icon is visible, when false it is not. For example, the code snippet below hides the mouse's icon. As UserInputService is client-side only, this property can only be used in a LocalScript. This property describes the position of the on-screen keyboard in pixels. The keyboard's position is Vector2.new(0, 0) when it is not visible. As UserInputService is client-side only, this property can only be used in a LocalScript, or a Script with RunContext set to Enum.RunContext.Client. See also OnScreenKeyboardVisible and OnScreenKeyboardSize. This property describes the size of the on-screen keyboard in pixels. The keyboard's size is Vector2.new(0, 0) when it is not visible. As UserInputService is client-side only, this property can only be used in a LocalScript, or a Script with RunContext set to Enum.RunContext.Client. See also OnScreenKeyboardVisible and OnScreenKeyboardPosition. This property describes whether an on-screen keyboard is currently visible on the user's screen. As UserInputService is client-side only, this property can only be used in a LocalScript, or a Script with RunContext set to Enum.RunContext.Client. See also OnScreenKeyboardSize and OnScreenKeyboardPosition. This property describes whether the user's current device has a touch screen available. The property is used to determine if the user's device has a touch screen, and therefore if touch events will fire. If TouchEnabled is true, you can use UserInputService events such as UserInputService.TouchStarted and UserInputService.TouchEnded to track when a user starts and stops touching the screen of their device. The code snippet below prints whether the user's device has a touch screen. \"The user's device does not have a touchscreen!\" -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events This property describes whether the user is using a virtual reality (VR) device. If a VR device is enabled, you can interact with its location and movement through functions such as UserInputService:GetUserCFrame(). You can also react to VR device movement using the UserInputService.UserCFrameChanged event. \"User is not using a VR headset!\" As UserInputService is client-side only, this property can only be used in a LocalScript.\n\nThis function returns whether the given Enum.UserInputType gamepad supports a button corresponding with the given Enum.KeyCode. This function is used to determine valid gamepad inputs. To determine which Enum.UserInputType gamepads are connected, use UserInputService:GetConnectedGamepads(). As UserInputService is client-side only, this function can only be used in a LocalScript. The Enum.UserInputType of the gamepad. The Enum.KeyCode of the button in question. \n\n Whether the given gamepad supports a button corresponding with the given Enum.KeyCode. This function returns an array of Enum.UserInputType gamepads currently connected. If no gamepads are connected, this array will be empty. Additionally, it only returns UserInputType objects that are gamepads. For instance, this event will return a connected Gamepad1 object but not a Keyboard object. For example, the following code snippet retrieves the connected gamepads and stores them in a variable named connectedGamepads. To check if a specific gamepad is connected, use UserInputService:GetGamepadConnected(). As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n An array of UserInputTypes corresponding with the gamepads connected to the user's device. How to Set the Active Gamepad for Input -- Nothing is connected; set up for \"Gamepad1\" The GetDeviceAcceleration function determines the current acceleration of the user's device. It returns an InputObject that describes the device's current acceleration. In order for this to work, the user's device must have an enabled accelerometer. To check if a user's device has an enabled accelerometer, you can check the UserInputService.AccelerometerEnabled property. If you want to track when the user's device's acceleration changes instead, you can use the UserInputService.DeviceAccelerationChanged event. Since it only fires locally, it can only be used in a LocalScript. \n\n \"Cannot get device acceleration because device does not have an enabled accelerometer!\" This function returns an InputObject describing the device's current gravity vector. The gravity vector is determined by the device's orientation relative to the real-world force of gravity. For instance, if a device is perfectly upright (portrait), the gravity vector is Vector3.new(0, 0, -9.18). If the left side of the device is pointing down, the vector is Vector3.new(9.81, 0, 0). Finally, if the back of the device is pointing down, the vector is Vector3.new(0, -9.81, 0). This function might be used to enable the user's device to impact or control gravity within the game or move in-game objects such as a ball. Gravity is only tracked for players using a device with an enabled gyroscope - such as a mobile device. To check if a user's device has an enabled gyroscope, check the value of UserInputService.GyroscopeEnabled. If the device has an enabled gyroscope, you can also use the UserInputService.DeviceGravityChanged event to track when force of gravity on the user's device changes. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n -- Move the bubble in the world based on the gyroscope data This function returns an InputObject and a CFrame describing the device's current rotation vector. This is fired with an InputObject. The Position property of the input object is a Enum.InputType.Gyroscope that tracks the total rotation in each local device axis. Device rotation can only be tracked on devices with a gyroscope. As this function fires locally, it can only be used in a LocalScript.\n• None The delta property describes the amount of rotation that last happened\n• None The CFrame is the device's current rotation relative to its default reference frame. \"Cannot get device rotation because device does not have an enabled gyroscope!\" This function returns the TextBox the client is currently focused on. A TextBox can be manually selected by the user, or selection can be forced using the TextBox:CaptureFocus() function. If no TextBox is selected, this function will return nil. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n This function returns whether a gamepad with the given Enum.UserInputType is connected to the client. This can be used to check if a specific gamepad, such as 'Gamepad1' is connected to the client's device. To retrieve a list of all connected gamepads, use UserInputService:GetConnectedGamepads(). As UserInputService is client-side only, this function can only be used in a LocalScript. The Enum.UserInputType of the gamepad in question. \n\n Whether a gamepad associated with Enum.UserInputType is connected. \"Gamepad1 is connected to the client\" \"Gamepad1 is not connected to the client\" This function returns an array of InputObjects for all available inputs on the given Enum.UserInputType gamepad, representing each input's last input state. To find the UserInputTypes of connected gamepads, use UserInputService:GetConnectedGamepads(). As this function only fires locally, it can only be used in a LocalScript. The Enum.UserInputType corresponding with the gamepad in question. \n\n An array of InputObjects representing the current state of all available inputs for the given gamepad. This method takes the requested Enum.KeyCode and returns the associated image for the currently connected gamepad device (limited to Xbox, PlayStation and Windows). This means that if the connected controller is an Xbox One controller, the user sees Xbox assets. Similarly, if the connected device is a PlayStation controller, the user sees PlayStation assets. If you want to use custom assets, see GetStringForKeyCode(). The Enum.KeyCode for which to fetch the associated image. \n\n This function returns an array of InputObjects associated with the keys currently being pressed down. This array can be iterated through to determine which keys are currently being pressed, using the InputObject.KeyCode values. To check if a specific key is being pressed, use UserInputService:IsKeyDown(). As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n An array of InputObjects associated with the keys currently being pressed. -- Double jump during freefall if able to -- Allow player to jump again after they land This function returns 'Enum.UserInputType` associated with the user's most recent input. For example, if the user's previous input had been pressing the spacebar, the Enum.UserInputType returned would be 'Keyboard'. The UserInputService.LastInputTypeChanged event can be used to track when the last Enum.UserInputType used by the user changes. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n The Enum.UserInputType associated with the user's most recent input. \"Most recent input was via keyboard\" This function returns an array of InputObjects corresponding to the mouse buttons currently being pressed down. Mouse buttons that are tracked by this function include: If the user is not pressing any mouse button down when the function is called, it will return an empty array. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n An array of InputObjects corresponding to the mouse buttons currently being currently held down. -- InputBegan is a UserInputService event that fires when the player -- Returns an array of the pressed MouseButtons This function returns the change, in pixels, of the position of the player's Mouse in the last rendered frame as a Vector2. This function only works if the mouse has been locked using the UserInputService.MouseBehavior property. If the mouse has not been locked, the returned Vector2 values will be zero. The sensitivity of the mouse, determined in the client's settings and UserInputService.MouseDeltaSensitivity, will influence the result. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n Change in movement of the mouse. -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events This function returns a Vector2 representing the current screen location of the player's Mouse in pixels relative to the top‑left corner. This does not account for the Enum.ScreenInsets; to get the top‑left and bottom‑right insets, call GuiService:GetGuiInset(). If the location of the mouse pointer is offscreen or the player's device does not have a mouse, the returned value will be undetermined. As UserInputService is client-side only, this function can only be used in a LocalScript. \n\n A Vector2 representing the current screen location of the mouse, in pixels. This function returns an array of gamepad UserInputTypes that are connected and enabled for GUI navigation. This list is in descending order of priority, meaning it can be iterated over to determine which gamepad should have navigation control. Whether a connected gamepad is a navigation gamepad only determines which gamepad(s) control the navigation GUIs. This does not influence navigation controls. Since UserInputService is client-side only, this function can only be used in a LocalScript.\n• None , to enable or disable a gamepad for GUI navigation , to enable or disable a gamepad for GUI navigation\n• None , to verify if a gamepad is enabled for GUI navigation , to verify if a gamepad is enabled for GUI navigation\n• None , to return all gamepads connected regardless of GUI navigational control , to return all gamepads connected regardless of GUI navigational control \n\n An array of UserInputTypes that can be used for GUI navigation, in descending order of priority. GetStringForKeyCode returns a string representing a key the user should press in order to input a given Enum.KeyCode, keeping in mind their keyboard layout. For key codes that require some modifier to be held, this function returns the key to be pressed in addition to the modifier. See the examples below for further explanation. When using Roblox with a non‑QWERTY keyboard layout, key codes are mapped to equivalent QWERTY positions. For example, pressing A on an AZERTY keyboard results in Enum.KeyCode.Q. This mapping can lead to mismatched information on experience UI elements. For example, \"Press M to open the map\" is inaccurate on an AZERTY keyboard; it would need to be \"Press ? to open the map\" which is in the same position as M on QWERTY. This function solves this issue by providing the actual key to be pressed while using non‑QWERTY keyboard layouts. because is typed with GetStringForKeyCode() returns the string mapping for the Enum.KeyCode for the most recently connected gamepad. If the connected controller is not supported, the function returns the default string conversion for the requested key code. The following example shows how you can map custom assets for ButtonA: The directional pad key codes do not have any differences based on device. Enum.KeyCode.ButtonSelect has slightly different behavior in some cases. Use both PlayStation mappings to ensure users see the correct buttons. When using a Enum.KeyCode that may be better represented as an image, such as for an ImageLabel in a user interface, you can use the following legacy icons. However, it's recommended that you use GetImageForKeyCode() as a more modern, cross‑platform method to retrieve Xbox and PlayStation controller icons. \n\n This function returns an array of KeyCodes that the gamepad associated with the given Enum.UserInputType supports. This function can be used to determine which KeyCodes are supported and not supported by a connected gamepad. To determine if a specific KeyCode is supported, use UserInputService:GamepadSupports(). If called on a non existent, or non connected, gamepad, this function will return an empty array. As UserInputService is client-side only, this function can only be used in a LocalScript. The Enum.UserInputType of the gamepad. \n\n An array of KeyCodes supported by the given gamepad. -- Since this function does not return anything, this handler will -- \"sink\" the input and no other action handlers will be called after This function checks if a particular button is pressed on a particular gamepad. It returns true if the gamepad has the specified button pressed down, otherwise it returns false. The specified gamepad should be one of the following UserInputType enum values: The specified button should be one of the following KeyCodes enum values: This can be used to check whether a specific button, such as A, is being held down. For example: Since UserInputService is client-side only, this function can only be used in a LocalScript.\n• None - A similar method with a different use: To check if a given on a is pressed. - A similar method with a different use: To check if a givenon ais pressed. The Enum.UserInputType of the given gamepad. The Enum.KeyCode of the specified button. \n\n Whether the specified gamepad button on the given gamepad is pressed is pressed. -- nothing is connected, at least set up for gamepad1 This function returns whether the user is holding down the key associated with the given Enum.KeyCode. It returns true if the specified key is pressed or false if it is not pressed. This can be used to check if a specific key, such as the space bar, is being pressed. For example: To retrieve a list of all keys pressed by the user, use the UserInputService:GetKeysPressed() function. Since UserInputService is client-side only, this function can only be used in a LocalScript.\n• None - A similar event with a different use: To check if a given on a is pressed. - A similar event with a different use: To check if a givenon ais pressed. The Enum.KeyCode of the key. \n\n Whether the specified key is being held down. -- Return whether left or right shift keys are down -- Handle user input began differently depending on whether a shift key is pressed This function takes a mouse button Enum.UserInputType and returns a bool that indicates whether it is currently pressed. The mouse button checked depends on the Enum.UserInputType value passed to the function as an argument. For example: Since UserInputService is client-side only, this function can only be used in a LocalScript.\" The Enum.UserInputType of the mouse button. \n\n Whether the given mouse button is currently held down. -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events This function returns true if the specified Enum.UserInputType gamepad is allowed to control Navigation and Selection GuiObjects. If you want to set a navigation gamepad, you can use UserInputService:SetNavigationGamepad(). You can also use UserInputService:GetNavigationGamepads() to get a list of all navigation gamepads. For example, the code below checks if the gamepad1 is as a navigation gamepad: A list of all connected gamepads, regardless of navigation can be retrieved using`UserInput/GetConnectedGamepads. Since UserInputService is client-side only, this function can only be used in a LocalScript. The Enum.UserInputType of the specified gamepad. \n\n Whether the specified gamepad is a navigation gamepad. This function recenters the CFrame of the VR headset to the current orientation of the headset worn by the user. This means that the headset's current orientation is set to CFrame.new(). Use this function to move the headset CFrame to the center of the play area if it seems to be at a weird offset. This behaves identically to the VRService function, VRService:RecenterUserHeadCFrame(). Since UserInputService is client-side only, this function can only be used in a LocalScript. \n\n The SetNavigationGamepad function sets whether the specified Enum.UserInputType gamepad can move the GUI navigator. A gamepad that is allowed to move the GUI navigator is considered a navigation gamepad. If the enabled argument is passed as true, the Gamepad can move the GUI navigator. If the argument is false, the Gamepad can not move the GUI navigator. If you want to check if a specified Gamepad is a set to be a navigation gamepad, you can use the UserInputService:IsNavigationGamepad() function. You can also use the UserInputService:GetNavigationGamepads() to retrieve a list of all navigation gamepads. Since UserInputService is client-side only, this function can only be used in a LocalScript. The Enum.UserInputType of the specified gamepad. Whether the specified gamepad can move the GUI navigator. \n\n\n\nThe DeviceAccelerationChanged event fires when a user moves a device that has an accelerometer. An accelerometer is a component found in most mobile devices that measures acceleration (change in speed). To determine whether a user's device has an accelerometer enabled, seeUserInputService.AccelerometerEnabled. This event can be used to track the movement of a device that has an accelerometer. A sample usage includes moving the player character when a mobile device accelerates. Additionally, this event can be used along with UserInputService:GetDeviceAcceleration() to determine the current movement of a user's device if the device has an accelerometer. This event only fires locally - which means that only the player whose device moves can use the event and it will only work in a LocalScript. An InputObject, with a UserInputType of 'Accelerometer', and Position that shows the force of gravity on each local device axis. \n\n The UserInputService.DeviceGravityChanged event fires when the device's gravity Vector3 changes on a device that has an accelerometer. A device's gravity vector represent the force of gravity on each of the device's X, Y, and Z axes. While gravity never changes, the force it exerts on each axis changes when the device rotates and changes orientation. The force value exerted on each axis is a unit vector ranging from -1 to 1. An accelerometer is a component found in most mobile devices that measures acceleration (change in speed). This event can be used to determine the real-world direction of the force of gravity on a user's device. This even can then be used to simulate the force of gravity on a user's device within the game, such as on in-game objects (see example below). To check if a user's device has an enabled accelerometer, see UserInputService.AccelerometerEnabled. If the device has an enabled accelerometer, you can use the UserInputService:GetDeviceGravity() function to get the current force of gravity on the user's device. An InputObject, with a InputObject.Position property that shows the force of gravity on each local device axis. This position can be used as a direction to determine the direction of gravity relative to the device. \n\n The DeviceRotationChanged event fires when a user rotates a device that has a gyroscope. A gyroscope is a component found in most mobile devices that detects orientation and rotational speed. The event is useful when tracking the orientation of the device and how changes as the user rotates their device. To determine the current device rotation, you can use the UserInputService:GetDeviceRotation() function. To check if a user's device has an enabled gyroscope, and that this event will fire, see UserInputService.GyroscopeEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. An InputObject providing info about the device's rotation. InputObject.Position represents the new rotation a Vector3 positional value and InputObject.Delta represents the change in rotation in a Vector3 positional value. \n\n The GamepadConnected event fires when a gamepad is connected to the client. Since a Roblox game supports multiple controllers, this event is useful when paired with the UserInputService.GamepadDisconnected event to track which controllers/gamepads are active. You can also use UserInputService:GetConnectedGamepads() to find the correct gamepad to use. The following example demonstrates a usage example of a tracking when a gamepad is connected to the client. If you want to see which devices are connected, you can use the UserInputService:GetConnectedGamepads() function. As this event fires locally, it can only be used in a LocalScript. The Enum.UserInputType of the connected gamepad. \n\n The GamepadDisconnected event fires when a gamepad is disconnected. Since a Roblox game supports multiple controllers, this event is useful when paired with the UserInputService.GamepadConnected event to track which controllers/gamepads are active. You can also use UserInputService:GetConnectedGamepads() to find the correct gamepad to use. The following example demonstrates a usage example of a tracking when a gamepad is disconnected from the client. As this event fires locally, it can only be used in a LocalScript. \n\n The InputBegan event fires when a user begins interacting via a Human-Computer Interface device (mouse button down, touch begin, keyboard button down, etc.). It can be used to track the beginning of user interaction, such as when a user first interacts with a GUI element, a gamepad, etc. It does not capture mouse wheel movements. This event can be used along with UserInputService.InputChanged and UserInputService.InputEnded to track when user input begins, changes, and ends. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user's input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- In order to use the InputBegan event, the UserInputService service must be used -- A sample function providing multiple usage cases for various types of user input \"A key is being pushed down! Key:\" \"The left mouse button has been pressed down at\" \"The right mouse button has been pressed down at\" \"A button is being pressed on a gamepad! Button:\" \"The game engine did not internally observe this input!\" The InputChanged event fires when a user changes how they're interacting via a Human-Computer Interface device (mouse button down, touch begin, keyboard button down, etc). To ignore events that are automatically handled by Roblox, like scrolling in a ScrollingFrame, check the gameProcessedEvent argument is false. This event can be used along with UserInputService.InputBegan and UserInputService.InputEnded to track when user input begins, changes, and ends. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user's input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- In order to use the InputChanged event, the UserInputService service must be used -- Prints the current input position and the change (delta) in position -- A sample function providing multiple usage cases for various types of user input \"The mouse has been moved!\" \"The mouse wheel has been scrolled!\" \"The left thumbstick has been moved!\" \"The right thumbstick has been moved!\" \"The pressure being applied to the left trigger has changed!\" \"The pressure being applied to the right trigger has changed!\" \"The user's finger is moving on the screen!\" \"The rotation of the user's mobile device has been changed!\" \"The acceleration of the user's mobile device has been changed!\" The InputEnded event fires when a user stops interacting via a Human-Computer Interface device (mouse button down, touch begin, keyboard button down, etc). This is useful when tracking when a user releases a keyboard key, mouse button, touchscreen input, etc. This event can be used along with UserInputService.InputBegan and UserInputService.InputChanged to track when user input begins, changes, and ends. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- In order to use the InputChanged event, the UserInputService service must be used -- A sample function providing multiple usage cases for various types of user input \"The left mouse button has been released at\" \"The right mouse button has been released at\" \"A touchscreen input has been released at\" \"A button has been released on a gamepad! Button:\" \"The game engine did not internally observe this input!\" The UserInputService JumpRequest event fires when there is a jump request from the client, for example when the client presses the spacebar or jump button on mobile. This event fires whenever the user tries to make their Player.Character jump. Default behavior responds to a jump request by setting the player's Humanoid.Jump property to true, which makes the player's character jump. The event can be used to track every time a player wants to jump. Instead of using it to make a player jump, this should be used to change default jump behavior - such as disabling jumping. For example, the code below prints \"Jump\" every time the player sends a jump request. Since this event fires multiple times for a single jump request, using a debounce is suggested. If you would like to connect keys or buttons to other actions, consider using events such as UserInputService:GetKeysPressed() and UserInputService.InputBegan or the ContextActionService. As this event only fires locally, it can only be used in a LocalScript. \n\n -- Fires when the user tries to jump The UserInputService.LastInputTypeChanged event fires whenever the client changes how they are interacting via a Human-Computer Interface device. (i.e. from MouseMovement to MouseWheel or from Thumbstick1 to Thumbstick2). To get the value of the last input type, regardless of whether it has changed, you can use the UserInputService:GetLastInputType() function. As this event only fires locally, it can only be used in a LocalScript. \n\n PointerAction fires when the user performs a specific pointer action. In particular, scrolling the mouse wheel. \n\n The TextBoxFocusReleased event fires when a client loses focus on a TextBox, typically when a client stops text entry by pressing return or clicking/touching elsewhere on the screen. For example, the code below prints the name of the TextBox losing focus when the event fires. It can be used alongside UserInputService.TextBoxFocused to track when a TextBox gains and loses focus. As this event only fires locally, it can only be used in a LocalScript. \n\n This event fires when a gains focus on a TextBox, typically when a client clicks/taps on a text box to begin inputting text. This also fires if a text box focus is focused using TextBox:CaptureFocus(). For example, the code below prints the name of the TextBox focused when the event fires. It can be used alongside UserInputService.FocusReleased to track when a text box gains and loses focus. As this event only fires locally, it can only be used in a LocalScript. \n\n The TouchEnded event fires when a user released their finger from the screen of a TouchEnabled device, ending touch input with the device. This event can be used to determine when a user stops touching the screen of their device. It can be paired with UserInputService.TouchStarted to determine when a user starts and stops touching the screen. For example, the code below prints the screen position where the user stops touching the screen. The touch input object is the same input object throughout the lifetime of the touch. So comparing InputObjects when they are touch objects is valid to determine if it is the same finger. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user's input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The Difference Between TouchTap and TouchLongPress -- The parent of this script (a ScreenGui) -- Create the GUI frame that the user interacts with through Touch -- Fires when the touches their device's screen -- Fires when a user starts touching their device's screen and does not -- move their finger for a short period of time -- Fires when the user moves their finger while touching their device's -- Fires when the user stops touching their device's screen -- Only use the Touch events if the user is on a mobile device Fired when a user holds at least one finger for a short amount of time on the same screen position of a TouchEnabled device. This event can be used to determine when a user holds their finger down on an in-game GuiObject or element. The example below prints the state of the long press when the user holds at least one finger for a short amount of time on the same screen position. Possible states include: Begin, Change, End, Cancel, and None. To check if a user's device is TouchEnabled, and that touch events will fire, seeUserInputService.TouchEnabled. It can be paired with UserInputService.TouchStarted and UserInputService.TouchEnded to determine when a user starts and stops touching the screen. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An array of Vector2 objects, indicating the position of the fingers involved in the gesture. The Enum.UserInputState of the gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The Difference Between TouchTap and TouchLongPress -- The parent of this script (a ScreenGui) -- Create the GUI frame that the user interacts with through Touch -- Fires when the touches their device's screen -- Fires when a user starts touching their device's screen and does not -- move their finger for a short period of time -- Fires when the user moves their finger while touching their device's -- Fires when the user stops touching their device's screen -- Only use the Touch events if the user is on a mobile device The TouchMoved event fires when a user moves their finger on a TouchEnabled device. This event can be used to determine when a user moves their finger while touching the screen of a TouchEnabled device. It can be useful to track whether a user is moving their finger on the screen, as well as where the user is moving their finger. The code below prints \"Touch moved from\" the previous Vector2 position \"to \" the new Vector2 position of the user's touch on a TouchEnabled device. It can be paired with UserInputService.TouchStarted and UserInputService.TouchEnded to determine when a user starts touching the screen, how their finger moves while touching it, and when the they stop touching the screen. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user's input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The Difference Between TouchTap and TouchLongPress -- The parent of this script (a ScreenGui) -- Create the GUI frame that the user interacts with through Touch -- Fires when the touches their device's screen -- Fires when a user starts touching their device's screen and does not -- move their finger for a short period of time -- Fires when the user moves their finger while touching their device's -- Fires when the user stops touching their device's screen -- Only use the Touch events if the user is on a mobile device The TouchPan event fires when a user drags at least one finger on a TouchEnabled device. This event can be used to determine when a user pans their finger along screen of a TouchEnabled device - such as to rotate the Camera in a custom camera script. The snippet below prints \"Speed of touch drag\" followed by the velocity of the user's touch when the user drags their finger on the screen. Take a look at another useful UserInputService function here UserInputService.TouchRotate. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An array of Vector2 objects, indicating the positions of the touches (e.g. fingers) involved in the gesture. The size of the pan gesture from start to end (in pixels). The speed of the pan gesture (in pixels) per second. The Enum.UserInputState of the gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events Fired when a user places and moves two fingers on the screen of a TouchEnabled device. For instance, the snippet below prints how much the camera zoom scale has changed since the beginning of the touch pinch. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An array of Vector2s, indicating the screen position, in pixels, of the fingers involved in the pinch gesture. The magnitude of the pinch from start to finish (in pixels) divided by the starting pinch positions. The speed of the pinch gesture (in pixels) per second. The Enum.UserInputState of the gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events The TouchRotate event fires when a user rotates two fingers on a TouchEnabled device. For example, the following code prints how much the camera has rotated since the beginning of the touch rotation. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. The core scripts that control the user's camera on a mobile device use code that functions similarly to this event. Best practice for this event is to use it when creating a mobile camera system to override the default core scripts. An array of Vector2s, indicating the positions of the fingers involved in the gesture. The number of degree the gesture has rotated since the start of the gesture. The change in rotation (in degrees) divided by the duration of the change (in seconds). The Enum.UserInputState of the gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n -- Determine whether the user is on a mobile device -- The user is on a mobile device, use Touch events -- The user is not on a mobile device use Input events The TouchStarted event fires when a user places their finger on a TouchEnabled device, beginning touch input with the device. This event can be used to determine when a user starts touching the screen of their device. It can be paired with UserInputService.TouchEnded to determine when a user starts and stops touching the screen. The touch input object is the same input object throughout the lifetime of the touch. So comparing InputObjects when they are touch objects is valid to determine if it is the same finger. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An InputObject instance, which contains information about the user's input. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The TouchSwipe event fires when a user swipes their fingers on a TouchEnabled device. This event can be used to determine when a user swipes their fingers on the screen of their device and the direction that the user swiped. For more precise tracking of touch input movement, use using UserInputService.TouchMoved To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An Enum.SwipeDirection, indicating the direction the user swiped. Number of touches (e.g. fingers) involved in the gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The TouchTap event fires when the user touches/taps their finger on the screen on a TouchEnabled device. This event will fire regardless of whether the user touches/taps the game world or a GuiObject element. If you are looking for an event that only fires when the user touches/taps the game world, use UserInputService.TouchTapInWorld. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As this event only fires locally, it can only be used in a LocalScript. An array of Vector2 objects, indicating the position of the fingers involved in the tap gesture. Indicates whether the game engine internally observed this input and acted on it. Generally this refers to UI processing, so if a button was touched or clicked from this input, gameProcessedEvent would be true. This is also true for input events connected via ContextActionService. \n\n The Difference Between TouchTap and TouchLongPress -- The parent of this script (a ScreenGui) -- Create the GUI frame that the user interacts with through Touch -- Fires when the touches their device's screen -- Fires when a user starts touching their device's screen and does not -- move their finger for a short period of time -- Fires when the user moves their finger while touching their device's -- Fires when the user stops touching their device's screen -- Only use the Touch events if the user is on a mobile device The TouchTapInWorld event fires when the user touches/taps their finger on the screen on a TouchEnabled device. It is fired when the user taps in the game world. This event can be used to determine when a user taps the screen and does not tap a GuiObject element. If the user taps a GUI element, UserInputService.TouchTap will fire instead of TouchTapInWorld. To check if a user's device is TouchEnabled, and that touch events will fire, see UserInputService.TouchEnabled. This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized. As it only fires locally, it can only be used in a LocalScript. A Vector2 indicating the position of the touch. \n\n -- Do not create a part if the player clicked on a GUI/UI element -- Get Vector3 world position from the Vector2 viewport position -- Create a new part at the world position if the player clicked on a part -- Do not create a new part if player clicks on empty skybox The UserInputService WindowFocusReleased event fires when the window of the Roblox client loses focus - typically when the Roblox client is minimized by the user. For example, the code below prints \"Window focus released\" whenever the Roblox client loses focus. This event can be used alongside UserInputService.WindowFocused to track whether the Roblox client is actively focused on a user's screen. Since it only fires locally, it can only be used in a LocalScript. \n\n The UserInputService WindowFocused event fires when the window of the Roblox client gains focus - typically when the Roblox client is maximized/actively open on the user's screen. For example, the code below prints \"Window focused\" whenever the Roblox client gains focus. This event can be used alongside UserInputService.WindowFocusReleased to track whether the Roblox client is actively focused on a user's screen. As this event only fires locally, it can only be used in a LocalScript."
    },
    {
        "link": "https://devforum.roblox.com/t/best-way-to-handle-character-movement/3143180",
        "document": "Hello,\n\n The title is a bit vague, what i want to know what the best and optimal way is to handle character movement, but not only movement, just character related things in generall. What do i mean by that?\n\nNormally, with the current knowledge i would just create 3 local scripts and then put them in startercharacterscripts. But thats seems kinda unnecessary, because i would need to make 3 different scripts and all need to have the same lines of code over and over again\n\n\n\n We can see in this image i have 3 scripts as stated before the drop down. In all of these scripts i have this typed:\n\nlocal runner = {} runner.__index = runner local runSpeed = 30 local cas = game:GetService(\"ContextActionService\") local runKeybind = Enum.KeyCode.LeftShift local ll = \"Run\" function runner.new(char:Model) local hum = char:FindFirstChildWhichIsA(\"Humanoid\") local self = setmetatable({}, runner) self.oldSpeed = hum.WalkSpeed self.running = false self.hum = hum local function handler(_, state) if state == Enum.UserInputState.Begin then runner:Run() elseif state == Enum.UserInputState.End then runner:UnRun() end end cas:BindAction(ll, handler, true, runKeybind) return self end function runner:Run() self.hum.WalkSpeed = runSpeed end function runner:UnRun() self.hum.WalkSpeed = self.oldSpeed end function runner:Disconnect() cas:UnbindAction(ll) end return runner This module script didnt work as i wanted, and instead bonked me in the head with this error:\n\nMy initial thoughts was to use module scripts and then have 1 local script that handles the module scripts, but i dont know how i would make that happen. I would like to hear yall thoughts, or maybe how you do it."
    },
    {
        "link": "https://devforum.roblox.com/t/how-do-you-use-userinputservice/828909",
        "document": "So I was practicing a little bit of scripting in studio, whilst watching Peaspod’s Advanced Tutorial on key pressing events. I scrolled through the comments a little and people have said that the KeyDown and KeyUp function is outdated and that I should be using the UserInputService event instead. So I did a little bit of research on the UserInputService | Documentation - Roblox Creator Hub and I also tried various ways in my script (It was written just to mess around with events and stuff from the object browser), however I still can’t get this to work and I still don’t know how to do this.\n\nHere is my code. It is giving me an error: [15:51:05.223 - GetService is not a valid member of Player “Players.HexTheSpy”. Hopefully You guys can help me.\n\n Thank you very much!!!"
    },
    {
        "link": "https://devforum.roblox.com/t/help-setting-up-a-advanced-input-system/2658712",
        "document": "You don’t need a coroutine for event connections like . Think of them less like loops and more like functions you’ve declared, they don’t block the rest of the script:\n\nYou could have a for-loop that checks through the keybinds module for anything that has the same input like so:"
    },
    {
        "link": "https://devforum.roblox.com/t/how-does-roblox-move-the-player/201944",
        "document": "Here’s a brief rundown of what’s going on with the Humanoid’s movement stuff.\n\nThere is a function under the Player object called Move, as mentioned above:\n\nThe Humanoid also has this function:\n\nIn both cases, the Vector3 value you pass to it is a unit vector, which is just a Vector3 value with a length of 1. Unit vectors describe how to move in a certain direction 1 unit.\n\nThe Humanoid uses a unit vector to figure out what direction it should be turning towards, and what direction it should apply forces in to move the character in that direction.\n\nThe argument is optional, and tells the Humanoid that its move direction is being described relative to the direction the client’s camera is facing.\n\nRoblox’s default movement script calls during every frame, and just locates the player’s current humanoid and passes the arguments over to that instead. Here’s a Lua port:\n\nMoveTo on the other hand, tells the Humanoid to try and walk towards a specific position. The Humanoid will automatically calculate a movement direction to use while its in a MoveTo state, and it won’t stop until it\n• Times out because it couldn’t reach the goal (8 seconds)\n• A call is made to the Humanoid’s Move/MoveTo function again."
    }
]