[
    {
        "link": "https://reddit.com/r/PowerShell/comments/11htjw4/gui_for_powershell",
        "document": "I'd like to make a gui for all my powershell script almost like a tool box where I can arrange them and run on a click.\n\nAny ideas on the best way to start. Am a complete noob."
    },
    {
        "link": "https://devblogs.microsoft.com/powershell-community/simple-form-development-using-powershell",
        "document": "PowerShell is a tool for the command line. Most people who use it are comfortable with the command line. But sometimes, there are valid use cases to provide Graphical User Interface (GUI).\n\nForms are based on .NET classes, but I have implemented a framework, so you do nothing more than create a JSON configuration and write simple functions in PowerShell. These functions are event-based functions contained in PowerShell cmdlets.\n\nI am going to break this post into 3 parts:\n• Lets just get some forms up and running\n• How does all that work\n• Use cases for forms and PowerShell\n\nLets just get some forms up and running\n• If you know about PowerShell modules, add all the modules, or ALL the files to your current setup. If you don’t, that is OK, have a quick read of Creating a scalable, customised running environment, which shows you how to set up your PowerShell environment. The instructions in that post are actually for the same repository that this post uses, so it should be pretty helpful.\n• Restart your current PowerShell session, which should load all the new modules.\n• In the PS terminal window, run the cmdlet. The PS terminal window that you launch the form from is now a slave to the form you have opened. I basically use this as an output for the user, so put it next to the opened form. If you have made it this far, thats it! If not, review your as suggested in Creating a scalable, customised running environment.\n• Press the buttons and see what happens. You should see responses appear in the PS terminal window. The tram buttons call an API to get trams approaching stops in Melbourne, Australia for the current time. The other two buttons are just some fun ones I found when searching for functionality to show in the forms.\n\nHow do I create my own forms\n\nRather than following documentation (which, lets be honest, I have not written), understanding the basics, and copying the examples is really the quickest way. Lets look at the SampleForm and work it through. You need a matching json and ps1 form.\n\nI am not going to go into all the specifics, they should be obvious from the examples. But basically, a form has a list of elements, and they are placed at an x-y coordinate based on the x-y attribute in the element. When creating elements, the following is important:\n• Create a base json file of the right form size, with nothing in it.\n• Create base matching cmdlet with only and sections in it. These 2 sections are identical in all form cmdlets.\n• Restart your PowerShell session to pick up the new cmdlet.\n• Add in elements 1 by 1 to the json file, getting them in the right position. You run the cmdlet after making changes to the json file.\n• : follow a naming convention, type_form_specificElement, for two reasons.\n• Firstly you can’t have the same name for an element on the form\n• Secondly, if you start getting fancy and having tabs, including the form in the name is going to help you immensely. (I had to do a lot of refactoring when I added in tabs!)\n• Add in the functions for your buttons. In keeping it simple, most of your functionality will be driven by your buttons. After updating your cmdlets, you will need to restart your PowerShell session to pick up the changes. I have found that using VS Code and PowerShell plugins and restarting PowerShell sessions is much cleaner than trying to unload, and load modules when you update/add cmdlets.\n\nAnd that is it. As a good friend/co-worker of mine says, it sounds easy when you say it quick, but the devil is in the detail. It can also be hard to debug.\n\nWith just this, and some diving into the other examples, you will be surprised the amount of functionality you can expose through your own GUI.\n\nHow does all that work\n\nPowerShell has access to all the .NET classes sitting underneath it and it has a rich and well developed set of widgets to add to forms. Now I am not a .NET developer, but it is pretty intuitive.\n\nLoad the Assemblies and look at the base cmdlets\n\nInside you will see:\n• The first lines are my standard practice to load all the cmdlets in the module\n• The lines here are the crucial ones. They tell the PowerShell session to load the .NET classes required for forms to function.\n• Inside the module are 3 important cmdlets\n• is sort of the driver, reads the json file, and iterates over all the elements, loading them onto the form by calling..\n• which is where all the heavy .NET lifting is done. .NET Forms have been around so long, and are so consistent (and trust me, coming from an early 2000’s web developer, this is wonderful), that with a basic switch, you can implement them all very easily and expose the features easily through our JSON configuration. This could be developed infinitely more, but see the caveat at the start of this post – KISS is very important.\n• One of the most useful techniques in PowerShell is to always use the native objects (hashes and lists) so that the operations are consistent. I have found this particularly relevant for JSON files. I have included this as I rely on it heavily due to PowerShell 5 having some deficiencies in this area. I like to have all my stuff work in PowerShell 5 AND 7. It is based on a post Convert JSON to a PowerShell hash table.\n\nThe above is a template for creating any form. I am a firm believer of convention over configuration. It makes for less code and simpler design. With that in mind:\n• cmdlet should be in file .\n• will be the configuration file for the form.\n• The TOP section finds the json file for the cmdlet based on convention, then loads all the elements.\n• The BOTTOM section makes the form appear.\n• TOP and BOTTOM sections will not change between different forms.\n\nEverything else in between is where the fun happens. Copy and paste functions, rename them following your JSON configuration, and you are away.\n\nUse cases for forms and PowerShell\n\nThe support team I am involved with have gone through a maturation of using PowerShell for support tasks over the last couple of years. We started just writing small cmdlets to do repeatable tasks. Stuff to do with file movement, Active Directory changes, data manipulation. Next we made some cmdlets to access vendors API’s that helped us do tasks quickly instead of through the vendor GUI application.\n\nAll this functionality is now available through a tool that all the support guys use daily, and have even started contributing to.\n\nIf you don’t know Postman, it is a tool used to test API’s / Web Services and is one of a modern developers most useful tools. But we have some very technically savvy users, that are not developers, and the ability for them to use some complex API’s dramatically improves their productivity (especially in non-production). Its too easy to make mistakes in Postman, and for repeatable tasks with half dozen inputs, we now have a tool that does some basic validation, and hits the API endpoint with consistent and useful data.\n\nYou can get some big bang for minimal effort with the .NET Forms and help your fellow workers in an environment that may just be a bit easier for some of them than native cmdlets. Sooooo…"
    },
    {
        "link": "https://medium.com/@bonguides25/winforms-creating-guis-in-windows-powershell-with-winforms-54bc2e144175",
        "document": "I have created many PowerShell scripts for the last couple of years. All with a single purpose to automate my IT work as much as possible. But this week I needed to create a script that could be run by the users themselves. And users and command line aren’t the best combination, so let’s take a look at using the PowerShell GUI.\n\nThe objective of this chapter is to cover the basics of creating a graphical user interface (GUI) using Windows PowerShell. Although Windows PowerShell itself does not include any GUI capabilities, it does have access to the .NET framework, including the WinForms programming interface.\n\nWinForms is a subset of the .NET framework designed specifically for the creation of Windows based GUIs. It allows GUI controls (such as buttons and labels) to be placed in containers (such as a form) and displayed to the user.\n\nIn addition, an event handling mechanism allows the programmer to define what actions are taken when a user interacts with a control or container (for example clicking on a button or resizing a dialog). Through the use of properties, the programmer is also able to control the appearance and behavior of controls and containers, for example changing the text displayed by a label.\n\nIn the remainder of this chapter, we will work through some examples which cover the key aspects of WinForms based GUI development using Windows PowerShell.\n\nAs outlined in the chapter entitled An Overview of Windows PowerShell 1.0 and .NET, only a few .NET assemblies are loaded into Windows PowerShell by default. As WinForms is not amongst the pre-loaded assemblies, it is necessary to load WinForms prior to creating GUIs. Assemblies are loaded using the static LoadWith PartialName method of the [reflection.assembly] class, passing through the name of the WinForms assembly as an argument:\n\nOnce loaded, we are ready to create a simple GUI from within Windows PowerShell.\n\nOnce the WinForms assembly has been loaded the next step is to create a simple example. As previously discussed, WinForms GUIs consist of containers, controls and events. With this in mind, the following example creates a form (container) and a button (control), adds the button to the form and displays the dialog:\n\nNote\n\n Note: Before we start creating a form is it important to know that the PowerShell script is run sequentially. So you define your form and show it. But any code after you displayed the form won’t be executed until you close the form.\n\n \n\n ×\n\n Dismiss this alert.\n\n \n\n \n\n\n\nWhen executed, the resulting dialog will appear as follows:\n\nThe next area to cover involves the handling of events. An event is typically triggered when a user interacts with a control. For example, clicking on a button control will trigger an event. Event handlers are nothing more than lines of code which define what is to happen when the event is triggered (for example, an event handler may be written to exit the application when a Close button is clicked).\n\nIn Windows PowerShell, event handlers take the form of scriptblocks, which are essentially sequences of commands wrapped in braces ().\n\nEvent handlers are added to a control using methods which have the following syntax:\n\nWhere is the name of the event to be handled and is the code to be executed when the event is triggered. For example, to close the dialog in the above example when the button is clicked:\n\nUsing scriptblocks would quickly become unwieldy if all the code to be executed had to be included along with the add_ method. An alternative to this approach is to call a function instead. The following adaptation of our example defines a function called MyFunction and subsequently references it in the event handler scriptblock:\n\nWinForms components are essentially objects, and as such, have properties which can be set to alter component appearance and behavior. As with other object properties, these can be accessed using standard dot notation. In the previous example, we used this approach to set the text of the button control:\n\nSimilarly, we could set the title of the form using the form object’s text property:\n\nBringing it all Together\n\nNow that we have seen a simple GUI created in Windows PowerShell and covered some of the basic techniques we can create a slightly more complex GUI.\n\nThe following script creates a GUI containing a label, button and text field. An event handler is configured on the button such that when it is clicked the text is extracted from the text field and used to construct a message which is then displayed on the label control.\n\nNote\n\n Tip: The creation of Drawing.Point objects to configure the size and location of controls on the form.\n\n \n\n ×\n\n Dismiss this alert.\n\n \n\n Click to reveal the code \n\n \n\n # Load the Winforms assembly\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n#Set the dialog title\n\n$form.text = \"PowerShell WinForms Example\"\n\n# Create the label control and set text, size and location\n\n$label = New-Object Windows.Forms.Label\n\n$label.Location = New-Object Drawing.Point 50,30\n\n$label.Size = New-Object Drawing.Point 200,15\n\n$label.text = \"Enter your name and click the button\"\n\n# Create TextBox and set text, size and location\n\n$textfield = New-Object Windows.Forms.TextBox\n\n$textfield.Location = New-Object Drawing.Point 50,60\n\n$textfield.Size = New-Object Drawing.Point 200,30\n\n# Create Button and set text and location\n\n$button = New-Object Windows.Forms.Button\n\n$button.text = \"Greeting\"\n\n$button.Location = New-Object Drawing.Point 100,90\n\n# Set up event handler to extarct text from TextBox and display it on the Label.\n\n$button.add_click(\n\n$label.Text = \"Hello \" + $textfield.text\n\n)\n\n# Add the controls to the Form\n\n$form.controls.add($button)\n\n$form.controls.add($label)\n\n$form.controls.add($textfield)\n\n# Display the dialog\n\n$form.ShowDialog()\n\nWhen adding controls to the form to display them in the GUI. You can add them one by one, or you can add all of them using AddRange property.\n\n...\n\n# Add the controls to the Form\n\n$form.controls.add($button)\n\n$form.controls.add($label)\n\n$form.controls.add($textfield)\n\n# Add the controls to the Form\n\n$form.controls.AddRange(@($button,$label,$textfield))\n\n...\n\nWe have the following controls that we can use on our forms:\n\nSo, let’s create some controls on our form. Add the code below to your script. Make sure that ShowDialog is at the end of your script.\n\nThe textbox control is used to accept and display an input as a single line of text. For example, the following script creates a GUI containing a label, button and text field. An event handler is configured on the button such that when it is clicked the text is extracted from the text field and used to construct a message which is then displayed on the label control.\n\nClick to reveal the code (TextBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(330,150)\n\n# Create a label control\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(30,20)\n\n$label.Text = 'Enter your name then click Submit button:'\n\n$label.ForeColor = 'Blue'\n\n$label.AutoSize = $true\n\n# Create a textbox control\n\n$textbox = New-Object System.Windows.Forms.TextBox\n\n$textbox.Location = New-Object System.Drawing.Point(30,40)\n\n$textbox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$textbox.ForeColor = 'Blue'\n\n$textbox.AutoSize = $true\n\n# Create a button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.location = New-Object System.Drawing.Point(28,70)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(110,77)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Red'\n\n$label1.AutoSize = $true\n\n# Event handler when click the button\n\n$submitButton.add_click(\n\n $label1.Text = 'Hello ' + $textbox.Text\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($textbox,$label,$label1,$submitButton))\n\n[void]$form.ShowDialog()\n\nThe place of the controls is based on points/pixels from the left side and the top side. So, the location 30,50 is 30 pixels from the left side and 50 points from the top side. And you can configure additional prroperties for the label control such as drawing size, font family, font size…\n\nYou can define the width and height of each control by $control.Size, but if your content is longer then the element it will only be partially displayed. So, by setting the Autosize to true, you are assured that the user can read the whole label.\n\n➡️ Navigate to the list of controls.\n\nThe next control you can add to the form is ComboBox (Dropdown list). The code below is pretty clear I think, we create the combo box and add the items with a single line foreach loop to the list. Again, we also define the position and I have set the size for the control.\n\nClick to reveal the code (ComboBox) \n\n \n\n Add-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n$form = New-Object Windows.Forms.Form\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Text = \"Select a category:.\"\n\n$label.Location = New-Object System.Drawing.Point(30,30)\n\n$label.AutoSize = $true\n\n$combobox = New-Object system.Windows.Forms.ComboBox\n\n$combobox.Text = \"\"\n\n$combobox.Size = New-Object Drawing.Point 150,20\n\n$combobox.location = New-Object System.Drawing.Point(30,60)\n\n# $combobox.Autosize = $true\n\n# Add the items in the dropdown list\n\n@('PowerShell','Microsoft 365','Windows Server') | ForEach-Object $combobox.Items.Add($_)\n\n# Select the default value\n\n$combobox.SelectedIndex = 0\n\n$form.controls.AddRange(@($label,$combobox))\n\n$form.ShowDialog()\n\nYou can set a default value for your dropdown list by selecting the index. Below is output if we’re not configured the default value for the combobox.\n\n➡️ Navigate to the list of controls.\n\nIn the previous section, we got the handling of events when a user interacts with a control. Now, in this section we’ll get more detail with a button in a PowerShell winforms. A button can have a standard action, like (\n\nOK, Cancel, Abort, Retry, Ignore, Yes, or No) or you can assign a custom function to it.\n\nThe buttons we are going to add are Cancel and Enter.\n• Cancel button will just close the form and does nothing else.\n• Enter button will run our logic to show a text. Add the buttons with the code below, again make sure you add the variables of the buttons to the $form.controls.AddRange\n\n➡️ Navigate to the list of controls.\n\nPictureBox is a rectangular region for an image. It supports many image formats. It has an adjustable size. It can access image files from your disk or from the Internet.\n\nA picture can be loaded to the form from your local computer with ImageLocation property as follows:\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n$form.AutoScale = $true\n\n$form.AutoSize = $true\n\n# Create a PictureControl control\n\n$pictureBox = New-Object System.Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Point(20,20)\n\n$pictureBox.ImageLocation = \"C:imageschart.png\"\n\n$pictureBox.AutoSize = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($pictureBox))\n\n[void]$form.ShowDialog()\n\nThe image cannot be shown if the script runs on another computer. You can upload the image to any cloud location, get the direct link of the image then Load it into the form.\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n$form.AutoScale = $true\n\n$form.AutoSize = $true\n\n# Create a PictureControl control\n\n$pictureBox = New-Object System.Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Point(20,20)\n\n$pictureBox.Load('https://bonguides.com/img/143614112023.png')\n\n$pictureBox.AutoSize = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($pictureBox))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nThe checkbox is a very common element in forms. The most common usage I have seen for checkboxes is on a survey, or when you agree to a license agreement during a software install. The script below is a nice example of how to enable and disable the OK button by checking the checkbox.\n\nClick to reveal the code (CheckBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n# Create a label\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(140,84)\n\n$label.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$label.AutoSize = $true\n\n# Create your checkbox \n\n$checkbox1 = New-Object System.Windows.Forms.checkbox\n\n$checkbox1.Location = New-Object System.Drawing.Size(20,20)\n\n$checkbox1.Size = New-Object System.Drawing.Size(250,20)\n\n$checkbox1.Text = \"Enable/Disable OK button\"\n\n# Add an OK button\n\n$OKButton = New-Object System.Windows.Forms.Button\n\n$OKButton.Location = New-Object System.Drawing.Size(20,70)\n\n$OKButton.Size = New-Object System.Drawing.Size(100,40)\n\n$OKButton.Text = \"OK\"\n\n$OKButton.Enabled = $false\n\n$OKButton.Add_Click($Form.Close())\n\n# Do something when the state of the checkbox changes\n\n$checkbox1.Add_CheckStateChanged(\n\n $OKButton.Enabled = $checkbox1.Checked\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($checkbox1,$OKButton,$label))\n\n$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nGroupBox combines a header with a box around other control. Nest a Grid within GroupBox. With a GroupBox, we can place them within a box that has a header. This makes interfaces easier to understand and interact with.\n\nIn a GroupBox we can nest another control. We used the Grid, Label, CheckBox… controls within a GroupBox. For example, we’ll create a groupbox with combobox, label, picturebox, textbox and button.\n\nClick to reveal the code (GroupBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(450,350)\n\n# Create a group that will contain your radio buttons\n\n$groupBox = New-Object System.Windows.Forms.GroupBox\n\n$groupBox.Location = '20,20'\n\n$groupBox.Size = '400,220'\n\n$groupBox.Text = \"Do you like Coffee?\"\n\n$groupBox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$groupBox.SendToBack()\n\n# Create the collection of radio buttons\n\n$RadioButton1 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton1.Location = '20,40'\n\n$RadioButton1.AutoSize = $true\n\n$RadioButton1.Checked = $true \n\n$RadioButton1.Text = \"Yes - I like Coffee.\"\n\n$RadioButton2 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton2.Location = '20,70'\n\n$RadioButton2.AutoSize = $true\n\n$RadioButton2.Checked = $false\n\n$RadioButton2.Text = \"No - I don't like Coffee.\"\n\n$RadioButton3 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton3.Location = '20,100'\n\n$RadioButton3.AutoSize = $true\n\n$RadioButton3.Checked = $false\n\n$RadioButton3.Text = \"This is not a Coffee related response.\"\n\n$pictureBox = New-Object Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Size(320,30)\n\n$pictureBox.Load('https://bonguides.com/img/163014112023.png')\n\n$pictureBox.Size = New-Object System.Drawing.Size(50,50)\n\n$pictureBox.SizeMode = 'StretchImage'\n\n$pictureBox.BringToFront()\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.Text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.Location = New-Object System.Drawing.Point(20,260)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n$cancelButton = New-Object System.Windows.Forms.Button\n\n$cancelButton.BackColor = \"red\"\n\n$cancelButton.Text = \"Cancel\"\n\n$cancelButton.Size = New-Object System.Drawing.Point (70,30)\n\n$cancelButton.Location = New-Object System.Drawing.Point(100,260)\n\n$cancelButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(20,140)\n\n$label1.Text = 'Leave a comment:'\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Regular)\n\n$label1.AutoSize = $true\n\n# Create a textbox control\n\n$textbox = New-Object System.Windows.Forms.TextBox\n\n$textbox.Location = New-Object System.Drawing.Point(20,163)\n\n$textbox.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$textbox.Size = New-Object System.Drawing.Size(350,50)\n\n# Add radio buttons into the groupbox control\n\n$groupBox.Controls.AddRange(@($Radiobutton1,$RadioButton2,$RadioButton3,$pictureBox,$label1,$textbox))\n\n# Event handler when click the buttons\n\n$submitButton.add_click()\n\n$cancelButton.add_click(\n\n $form.Close()\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($groupBox,$cancelButton,$submitButton))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nRadio buttons are another element used when creating forms. They allow an end-user to select one option from a group. For example, you post a question on a form — Do you like coffee? — The options for the answer would be:\n• Sometimes — depending on the type of coffee.\n\nThese answers cover all the possible answers to the question. When presented to the end user you only want them to select one option from the group.\n\nTo set this up in PowerShell we have to do a few things:\n• Create the radio buttons and give them values,\n• Create the form and add the usual Submit and Cancel buttons.\n\nThe code for all of this is below:\n\nClick to reveal the code (RadioButton) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(450,350)\n\n# Create a group that will contain your radio buttons\n\n$groupBox = New-Object System.Windows.Forms.GroupBox\n\n$groupBox.Location = '20,20'\n\n$groupBox.Size = '400,150'\n\n$groupBox.Text = \"Do you like Coffee?\"\n\n$groupBox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$groupBox.SendToBack()\n\n# Create the collection of radio buttons\n\n$RadioButton1 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton1.Location = '20,40'\n\n$RadioButton1.AutoSize = $true\n\n$RadioButton1.Checked = $true \n\n$RadioButton1.Text = \"Yes - I like Coffee.\"\n\n$RadioButton2 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton2.Location = '20,70'\n\n$RadioButton2.AutoSize = $true\n\n$RadioButton2.Checked = $false\n\n$RadioButton2.Text = \"No - I don't like Coffee.\"\n\n$RadioButton3 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton3.Location = '20,100'\n\n$RadioButton3.AutoSize = $true\n\n$RadioButton3.Checked = $false\n\n$RadioButton3.Text = \"This is not a Coffee related response.\"\n\n# Add radio buttons into the groupbox control\n\n$groupBox.Controls.AddRange(@($Radiobutton1,$RadioButton2,$RadioButton3,$pictureBox))\n\n$pictureBox = New-Object Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Size(320,30)\n\n$pictureBox.Load('https://bonguides.com/img/163014112023.png')\n\n$pictureBox.Size = New-Object System.Drawing.Size(50,50)\n\n$pictureBox.SizeMode = 'StretchImage'\n\n$pictureBox.BringToFront()\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.location = New-Object System.Drawing.Point(20,190)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n$cancelButton = New-Object System.Windows.Forms.Button\n\n$cancelButton.BackColor = \"red\"\n\n$cancelButton.text = \"Cancel\"\n\n$cancelButton.Size = New-Object System.Drawing.Point (70,30)\n\n$cancelButton.location = New-Object System.Drawing.Point(100,190)\n\n$cancelButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(20,250)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Green'\n\n$label1.AutoSize = $true\n\n# Event handler when click the buttons\n\n# Check the current state of each radio button and respond accordingly\n\n$submitButton.add_click(\n\n if ($RadioButton1.Checked) \n\n # So the popup\n\n # [System.Windows.Forms.MessageBox]::Show(\"You like Coffee.\" , \"Great\")\n\n # Print message into the form\n\n $label1.Text = \"You like Coffee. Great\"\n\n elseif ($RadioButton2.Checked) \n\n [System.Windows.Forms.MessageBox]::Show(\"So your not a fan of Coffee.\" , \"Awe\")\n\n \n\n elseif ($RadioButton3.Checked) \n\n [System.Windows.Forms.MessageBox]::Show(\"That's OK - You don't have to answer the questions\" , \"'No' to coffee\")\n\n \n\n)\n\n$cancelButton.add_click(\n\n $form.Close()\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($groupBox,$cancelButton,$submitButton,$label1,$pictureBox))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nThis indicates the progress of an operation. ProgressBar is best used on a long-running computation or task. The ProgressBar control is often used with a threading mechanism such as BackgroundWorker. It helps let your users know the application is still active. Below is the code to showing a progressbar when downloading a file. The logic is:\n\nClick to reveal the code (ProgressBar) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(320,250)\n\n# Create button control\n\n$downloadButton = New-Object System.Windows.Forms.Button\n\n$downloadButton.BackColor = \"Green\"\n\n$downloadButton.Text = \"> Click to download\"\n\n$downloadButton.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$downloadButton.Size = New-Object System.Drawing.Point (220,50)\n\n$downloadButton.Location = New-Object System.Drawing.Point(40,40)\n\n$downloadButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(40,140)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Green'\n\n$label1.AutoSize = $true\n\n# Create a progressbar control\n\n$ProgressBar = New-Object System.Windows.Forms.ProgressBar\n\n$ProgressBar.Location = New-Object System.Drawing.Size(40,100)\n\n$ProgressBar.Size = New-Object System.Drawing.Size(218,10)\n\n$ProgressBar.Style = \"Marquee\"\n\n$ProgressBar.MarqueeAnimationSpeed = 10\n\n$ProgressBar.Hide()\n\n# Create the function\n\nfunction PSDownloader \n\n $downloadButton.BackColor = \"#1F1F1F\"\n\n $downloadButton.Text = \"Downloading...\"\n\n $ProgressBar.Visible = $true \n\n $label1.Text = \"It could take a while to complete...\"\n\n $job = Start-Job -ScriptBlock \n\n Invoke-WebRequest 'http://ipv4.download.thinkbroadband.com/10MB.zip' -OutFile 'C:10MB.zip'\n\n \n\n do [System.Windows.Forms.Application]::DoEvents() until ($job.State -eq \"Completed\")\n\n Remove-Job -Job $job -Force\n\n $downloadButton.BackColor = \"Green\"\n\n $downloadButton.Text = \"> Click to download\"\n\n $ProgressBar.Hide()\n\n $label1.Text = \"Completed\"\n\n \n\n# Event handler when click the buttons (call function)\n\n$downloadButton.add_click(PSDownloader)\n\n# Add the controls to the form then display the dialog.\n\n$form.Controls.AddRange(@($downloadButton,$label1,$ProgressBar))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nListBox stores several text items. It can interact with other controls. In the below example code, we create a list of DNS server, this will be used as a data source. Select a DNS server from the list then click Submit button to check online status of it.\n\nClick to reveal the code (ListBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(500,400)\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(20,10)\n\n$label.Size = New-Object System.Drawing.Size(280,20)\n\n$label.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Regular)\n\n$label.Text = 'Please select a DNS server:'\n\n# Create a listbox control\n\n$listbox = New-Object System.Windows.Forms.ListBox\n\n$listbox.Location = New-Object System.Drawing.Point(20,30)\n\n$listbox.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Regular)\n\n$listbox.Size = New-Object System.Drawing.Size(450,70)\n\n# Add the items in the listbox\n\n@('8.8.8.8','8.8.4.4','1.1.1.1') | ForEach-Object $listbox.Items.Add($_)\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"Green\"\n\n$submitButton.Text = \"Submit\"\n\n$submitButton.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Bold)\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.Location = New-Object System.Drawing.Point(20,100)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n# Create a textbox to display the output\n\n$textboxOutput = New-Object system.Windows.Forms.TextBox\n\n$textboxOutput.Multiline = $true\n\n$textboxOutput.Text = \"Waiting for results...\"\n\n$textboxOutput.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Bold)\n\n$textboxOutput.Size = New-Object System.Drawing.Size(450,200)\n\n$textboxOutput.Location = New-Object System.Drawing.Point(20,140)\n\n$textboxOutput.BackColor = \"#1F1F1F\"\n\n$textboxOutput.ForeColor = 'Cyan'\n\n# Event handler when click the button\n\n$submitButton.add_click(\n\n $textboxOutput.Text = (powershell -noprofile -Command \"ping $($listBox.SelectedItem)\" )\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($listbox,$label,$submitButton,$textboxOutput))\n\n[void]$form.ShowDialog()\n\nThe items in a listbox can be added manually or can be passed from a pipeline. For example, below code pull the list of services or list of disabled user into the listbox.\n\n# Add the items in the listbox manualy\n\n# @('8.8.8.8','8.8.4.4','1.1.1.1') | ForEach-Object $listbox.Items.Add($_)\n\n# Pull the list of services into the listbox\n\nGet-Service | ForEach-Object $listbox.Items.Add($_.Name)\n\n# Get the list of disabled users on Active Directory\n\nGet-ADUser -Filter (Enabled -eq \"false\") | Foreach $listbox.Items.Add($_.Name)\n\n➡️ Navigate to the list of controls.\n\nThe DataGridView control provides a visual interface to a data object. It gives the ability to display and allow editing in a tabular format. In a GUI application, the scripters can take advantage of using this control to present the data to the user.\n\nBelow is an example of DataGridView to display the list of services on a Windows computer.\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(470,360)\n\n# Get the list of services into an array\n\n$gps = get-process | Select-Object Name,ID,Description,@n='Memory';e=$_.WorkingSet\n\n$list = New-Object System.collections.ArrayList\n\n$list.AddRange($gps)\n\n# Create a DataGridView control\n\n$dataGridView = New-Object System.Windows.Forms.DataGridView\n\n$dataGridView.Size = New-Object System.Drawing.Size(460,290)\n\n$dataGridView.DataSource = $list\n\n$dataGridView.ColumnHeadersVisible = $true\n\n$dataGridView.ColumnHeadersVisible = $true\n\n$dataGridView.AllowUserToAddRows = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($dataGridView))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nYou can allow for color selection in your PowerShell GUI with the System.Windows.Forms.ColorDialog. Below is a simple example to change the form background with ColorDialog.\n\nClick to reveal the code (ColorDialog) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(400,360)\n\n# Create colorDialog\n\n$colorDialog = New-Object System.Windows.Forms.ColorDialog\n\n# Create a button\n\n$enterButton = New-Object System.Windows.Forms.Button\n\n$enterButton.Size = New-Object System.Drawing.Point (30,30)\n\n$enterButton.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat\n\n$enterButton.FlatAppearance.BorderSize = '0'\n\n$enterButton.Location = New-Object System.Drawing.Point(340,20)\n\n$enterButton.Image = [System.Drawing.Image]::Fromfile(\"E:img91015112023.png\")\n\n# Create event handler\n\n$enterButton.add_click(\n\n $colorDialog.ShowDialog()\n\n $form.BackColor = $colordialog.Color\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.Controls.AddRange(@($enterButton))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls."
    },
    {
        "link": "https://techtarget.com/searchitoperations/tutorial/Boost-productivity-with-these-PowerShell-GUI-examples",
        "document": "Although PowerShell is a command-line environment, it is possible to create GUI-based PowerShell scripts. With examples ranging from simple to complex, GUI-based PowerShell scripts can be a great addition to any team's PowerShell strategies.\n\nFrom an IT standpoint, there are two main reasons you might choose to build a GUI for a PowerShell script. First, if you find yourself regularly using a particular PowerShell cmdlet that requires multiple parameters, you can use a GUI as an alternative to tedious typing.\n\nFor example, a GUI can simplify the process of creating a Hyper-V VM. The process normally involves entering the New-VM cmdlet, followed by several parameters. However, the GUI can prompt the user for the required information and then supply that information to the New-VM cmdlet behind the scenes, thus automating the VM creation process.\n\nGUI-based PowerShell scripts are also commonly employed when the IT department needs to create a script that someone outside of IT will use. Implementing a GUI enhances the script's usability, making it more accessible for non-IT personnel.\n\nThis tutorial covers two examples: creating simple PowerShell GUIs, and the more complex process of using a PowerShell GUI to create a Hyper-V VM. By following these steps and commands, teams can streamline the creation of PowerShell scripts, turning a time-consuming and complex process into one that's efficient and straightforward.\n\nAlthough GUI-based PowerShell scripts are often complex, it's relatively easy to create a simple GUI. Let's create a simple script that displays the words \"Hello World\" inside a text box within a GUI. The first step when creating a GUI-based PowerShell script is to load the required assemblies. Load the assembly and the assembly with the following commands. Next, create the individual interface elements that you will use within the GUI. This might include labels (text), text boxes, combo boxes (menus), buttons or other graphical elements. Although the exact lines of code will vary based on the GUI element you create, the basic process is the same for most GUI elements. The following example code block highlights the basic process. To define a GUI interface element, create a variable that will represent that element. In my example, the variable represents a textbox object because I call the variable and set it equal to . Once you define a GUI interface element object, you must then pin various attributes to that object. These attributes might include things like the size, color, position or font the object uses. Many of the available attributes are optional, but you almost always must define the object's size and location. The location is relative to the upper left corner of the GUI window. In my example code block, the object is located 20 pixels to the right of and 80 pixels below the window's upper-left corner. The size is set to 100 pixels wide by 100 pixels tall. My example is a single line text box because is set to . As such, Windows will ignore the text box height and simply make the text box as tall as it needs to be to accommodate a single line of text. Next, create a form object. The form is essentially the GUI; it's basically an empty canvas. You can see the form creation process in the following code block. Here, I have created a form object and tied it to a variable named . The form's size is 300 pixels wide by 200 pixels high. I have also opted to color the form light blue and give the window the name \"Posey's Example GUI.\" Now that you have defined the form, tell PowerShell to add your individual GUI elements to the form. In this case, I have a single GUI element called . You can add it to the form by using the following command. Incidentally, there is no concept of clearing the screen with PowerShell forms. If you need to clear the screen, remove the GUI elements. You can add or remove GUI elements at any point in the script. The last step in the process is to activate and display the form. You can do so using these lines of code. Figure 1. Following the example code and steps results in a simple\n\nAfter learning how to build a basic PowerShell GUI, you can practice more complex scripts, such as using a GUI to create a Hyper-V VM. While this example does not create a comprehensive interface that makes every Hyper-V option available, it illustrates how to use a GUI to simplify an administrative task. As shown in Figure 2, the script prompts the user to enter a name for their new VM and to specify the amount of memory that the VM will use, along with the virtual hard disk size. All the fields are prepopulated, but the user can enter different values. Once the user has entered their preferred values, they simply click the Submit button. At that point, the fields are cleared and the VM is created, as shown in Figure 3. At a structural level, this script works very similarly to my \"Hello World\" example. The biggest difference is that I have defined many more GUI interface elements. All the text that appears within the GUI is controlled by label objects. There are also two text boxes for entering the VM name and virtual hard disk size. The GUI also contains a combo box used to select the memory amount and a Submit button. When you create a button object, you generally need to associate a click action with the button as a way of telling PowerShell what to do when the button is clicked. In this case, the click action contains several lines of code that retrieve the values that have been entered into the GUI and puts those values into a normalized format. From there, the script builds a string that mimics the command used to create the VM. You can then use the command to execute the string's contents. You can review the full code below. Add-Type -AssemblyName System.Windows.Forms Add-Type -AssemblyName System.Drawing $GreetingLabel = New-Object Windows.Forms.Label $GreetingLabel.Text = \"Hyper-V VM Creation Utility\" $GreetingLabel.Font = New-Object Drawing.Font(\"Arial\", 24, [Drawing.FontStyle]::Bold) $GreetingLabel.AutoSize = $true $GreetingLabel.Location = New-Object Drawing.Point(10,10) $GreetingLabel.ForeColor = [System.Drawing.Color]::Black $VMNameBox = New-Object System.Windows.Forms.textbox $VMNameBox.Text = \"NewVM\" $VMNameBox.Multiline = $False $VMNameBox.Size = New-Object System.Drawing.Size(100,100) $VMNameBox.Location = new-object System.Drawing.Size(10,150) $VMNameLabel = New-Object Windows.Forms.Label $VMNameLabel.Text = \"Virtual Machine Name\" $VMNameLabel.AutoSize = $true $VMNameLabel.Location = New-Object Drawing.Point(10,180) $VMNameLabel.ForeColor = [System.Drawing.Color]::Black $MemoryComboBox = New-Object system.Windows.Forms.ComboBox $MemoryComboBox.text = \"\" $MemoryComboBox.width = 100 $MemoryComboBox.autosize = $true $MemoryComboBox.location = New-Object System.Drawing.Point(200,170) # Add the items in the dropdown list @(2,4,6,8,10,12,14,16) | ForEach-Object {[void] $MemoryComboBox.Items.Add($_)} # Select the default value $MemoryComboBox.SelectedIndex = 0 $MemoryLabel = New-Object Windows.Forms.Label $MemoryLabel.Text = \"Memory (GB)\" $MemoryLabel.AutoSize = $true $MemoryLabel.Location = New-Object Drawing.Point(200,150) $MemoryLabel.ForeColor = [System.Drawing.Color]::Black $VHDSizeBox = New-Object System.Windows.Forms.textbox $VHDSizeBox.Text = 40 $VHDSizeBox.Multiline = $False $VHDSizeBox.Size = New-Object System.Drawing.Size(100,100) $VHDSizeBox.Location = new-object System.Drawing.Size(10,220) $VHDSizeLabel = New-Object Windows.Forms.Label $VHDSizeLabel.Text = \"Virtual Hard Disk Size (GB)\" $VHDSizeLabel.AutoSize = $true $VHDSizeLabel.Location = New-Object Drawing.Point(10,250) $VHDSizeLabel.ForeColor = [System.Drawing.Color]::Black $CreateButton = New-Object System.Windows.Forms.Button $CreateButton.Location = New-Object System.Drawing.Size (200,220) $CreateButton.Size = New-Object System.Drawing.Size(160,30) $CreateButton.Font=New-Object System.Drawing.Font(\"Lucida Console\",18,[System.Drawing.FontStyle]::Regular) $CreateButton.BackColor = \"LightGray\" $CreateButton.Text = \"Submit\" $CreateButton.Add_Click({ #Get VM Name $VMName=$VMNameBox.Text $VMNameBox.Text=\"\" #Get VM Memory $Index=$MemoryComboBox.SelectedIndex [String]$VMMem=$MemoryComboBox.Items[$Index] $VMMem=$VMMem + \"GB\" $Index=$MemoryComboBox.SelectedIndex=0 #Get Virtual Hard Disk Size [String]$VHDX = $VHDSizeBox.Text $VHDX = $VHDX + \"GB\" $VHDSizeBox.Text = \"\" #Create VHD Path $VHDPath=\"C:\\temp\\\" + $VMName + \".VHDX\" #Form VM Creation Command [String]$NewVMCommand = \"New-VM -Name $VMName -MemoryStartupBytes $VMMem -NewVHDPath $VHDPath -NewVHDSizeBytes $VHDX\" #Create Virtual Machine Invoke-Expression $NewVMCommand }) $Form = New-Object Windows.Forms.Form $Form.Text = \"VM Creation Tool\" $Form.Width = 550 $Form.Height = 350 $Form.BackColor=\"LightBlue\" $Form.Controls.add($GreetingLabel) $Form.Controls.add($VMNameBox) $Form.Controls.add($VMNameLabel) $Form.Controls.add($VHDSizeBox) $Form.Controls.add($VHDSizeLabel) $Form.Controls.add($MemoryComboBox) $Form.Controls.add($MemoryLabel) $Form.Controls.add($CreateButton) $Form.Add_Shown({$Form.Activate()}) $Form.ShowDialog() Brien Posey is a 15-time Microsoft MVP with two decades of IT experience. He has served as a lead network engineer for the U.S. Department of Defense and as a network administrator for some of the largest insurance companies in America."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/893884/creating-gui-based-form-interface-for-powershell-d",
        "document": "If you need a web based solution, then use Visual Studio and build a C# ASPX web site. With VS you would get s full blown IDE which would make it easier to write the code behind object events.\n\nIf you want to write a Powershell GUI, just do an internet search for examples.\n\nOr sign up for PoshGUI and use their interface to design your own."
    },
    {
        "link": "https://techtarget.com/searchitoperations/tutorial/Boost-productivity-with-these-PowerShell-GUI-examples",
        "document": "Although PowerShell is a command-line environment, it is possible to create GUI-based PowerShell scripts. With examples ranging from simple to complex, GUI-based PowerShell scripts can be a great addition to any team's PowerShell strategies.\n\nFrom an IT standpoint, there are two main reasons you might choose to build a GUI for a PowerShell script. First, if you find yourself regularly using a particular PowerShell cmdlet that requires multiple parameters, you can use a GUI as an alternative to tedious typing.\n\nFor example, a GUI can simplify the process of creating a Hyper-V VM. The process normally involves entering the New-VM cmdlet, followed by several parameters. However, the GUI can prompt the user for the required information and then supply that information to the New-VM cmdlet behind the scenes, thus automating the VM creation process.\n\nGUI-based PowerShell scripts are also commonly employed when the IT department needs to create a script that someone outside of IT will use. Implementing a GUI enhances the script's usability, making it more accessible for non-IT personnel.\n\nThis tutorial covers two examples: creating simple PowerShell GUIs, and the more complex process of using a PowerShell GUI to create a Hyper-V VM. By following these steps and commands, teams can streamline the creation of PowerShell scripts, turning a time-consuming and complex process into one that's efficient and straightforward.\n\nAlthough GUI-based PowerShell scripts are often complex, it's relatively easy to create a simple GUI. Let's create a simple script that displays the words \"Hello World\" inside a text box within a GUI. The first step when creating a GUI-based PowerShell script is to load the required assemblies. Load the assembly and the assembly with the following commands. Next, create the individual interface elements that you will use within the GUI. This might include labels (text), text boxes, combo boxes (menus), buttons or other graphical elements. Although the exact lines of code will vary based on the GUI element you create, the basic process is the same for most GUI elements. The following example code block highlights the basic process. To define a GUI interface element, create a variable that will represent that element. In my example, the variable represents a textbox object because I call the variable and set it equal to . Once you define a GUI interface element object, you must then pin various attributes to that object. These attributes might include things like the size, color, position or font the object uses. Many of the available attributes are optional, but you almost always must define the object's size and location. The location is relative to the upper left corner of the GUI window. In my example code block, the object is located 20 pixels to the right of and 80 pixels below the window's upper-left corner. The size is set to 100 pixels wide by 100 pixels tall. My example is a single line text box because is set to . As such, Windows will ignore the text box height and simply make the text box as tall as it needs to be to accommodate a single line of text. Next, create a form object. The form is essentially the GUI; it's basically an empty canvas. You can see the form creation process in the following code block. Here, I have created a form object and tied it to a variable named . The form's size is 300 pixels wide by 200 pixels high. I have also opted to color the form light blue and give the window the name \"Posey's Example GUI.\" Now that you have defined the form, tell PowerShell to add your individual GUI elements to the form. In this case, I have a single GUI element called . You can add it to the form by using the following command. Incidentally, there is no concept of clearing the screen with PowerShell forms. If you need to clear the screen, remove the GUI elements. You can add or remove GUI elements at any point in the script. The last step in the process is to activate and display the form. You can do so using these lines of code. Figure 1. Following the example code and steps results in a simple\n\nAfter learning how to build a basic PowerShell GUI, you can practice more complex scripts, such as using a GUI to create a Hyper-V VM. While this example does not create a comprehensive interface that makes every Hyper-V option available, it illustrates how to use a GUI to simplify an administrative task. As shown in Figure 2, the script prompts the user to enter a name for their new VM and to specify the amount of memory that the VM will use, along with the virtual hard disk size. All the fields are prepopulated, but the user can enter different values. Once the user has entered their preferred values, they simply click the Submit button. At that point, the fields are cleared and the VM is created, as shown in Figure 3. At a structural level, this script works very similarly to my \"Hello World\" example. The biggest difference is that I have defined many more GUI interface elements. All the text that appears within the GUI is controlled by label objects. There are also two text boxes for entering the VM name and virtual hard disk size. The GUI also contains a combo box used to select the memory amount and a Submit button. When you create a button object, you generally need to associate a click action with the button as a way of telling PowerShell what to do when the button is clicked. In this case, the click action contains several lines of code that retrieve the values that have been entered into the GUI and puts those values into a normalized format. From there, the script builds a string that mimics the command used to create the VM. You can then use the command to execute the string's contents. You can review the full code below. Add-Type -AssemblyName System.Windows.Forms Add-Type -AssemblyName System.Drawing $GreetingLabel = New-Object Windows.Forms.Label $GreetingLabel.Text = \"Hyper-V VM Creation Utility\" $GreetingLabel.Font = New-Object Drawing.Font(\"Arial\", 24, [Drawing.FontStyle]::Bold) $GreetingLabel.AutoSize = $true $GreetingLabel.Location = New-Object Drawing.Point(10,10) $GreetingLabel.ForeColor = [System.Drawing.Color]::Black $VMNameBox = New-Object System.Windows.Forms.textbox $VMNameBox.Text = \"NewVM\" $VMNameBox.Multiline = $False $VMNameBox.Size = New-Object System.Drawing.Size(100,100) $VMNameBox.Location = new-object System.Drawing.Size(10,150) $VMNameLabel = New-Object Windows.Forms.Label $VMNameLabel.Text = \"Virtual Machine Name\" $VMNameLabel.AutoSize = $true $VMNameLabel.Location = New-Object Drawing.Point(10,180) $VMNameLabel.ForeColor = [System.Drawing.Color]::Black $MemoryComboBox = New-Object system.Windows.Forms.ComboBox $MemoryComboBox.text = \"\" $MemoryComboBox.width = 100 $MemoryComboBox.autosize = $true $MemoryComboBox.location = New-Object System.Drawing.Point(200,170) # Add the items in the dropdown list @(2,4,6,8,10,12,14,16) | ForEach-Object {[void] $MemoryComboBox.Items.Add($_)} # Select the default value $MemoryComboBox.SelectedIndex = 0 $MemoryLabel = New-Object Windows.Forms.Label $MemoryLabel.Text = \"Memory (GB)\" $MemoryLabel.AutoSize = $true $MemoryLabel.Location = New-Object Drawing.Point(200,150) $MemoryLabel.ForeColor = [System.Drawing.Color]::Black $VHDSizeBox = New-Object System.Windows.Forms.textbox $VHDSizeBox.Text = 40 $VHDSizeBox.Multiline = $False $VHDSizeBox.Size = New-Object System.Drawing.Size(100,100) $VHDSizeBox.Location = new-object System.Drawing.Size(10,220) $VHDSizeLabel = New-Object Windows.Forms.Label $VHDSizeLabel.Text = \"Virtual Hard Disk Size (GB)\" $VHDSizeLabel.AutoSize = $true $VHDSizeLabel.Location = New-Object Drawing.Point(10,250) $VHDSizeLabel.ForeColor = [System.Drawing.Color]::Black $CreateButton = New-Object System.Windows.Forms.Button $CreateButton.Location = New-Object System.Drawing.Size (200,220) $CreateButton.Size = New-Object System.Drawing.Size(160,30) $CreateButton.Font=New-Object System.Drawing.Font(\"Lucida Console\",18,[System.Drawing.FontStyle]::Regular) $CreateButton.BackColor = \"LightGray\" $CreateButton.Text = \"Submit\" $CreateButton.Add_Click({ #Get VM Name $VMName=$VMNameBox.Text $VMNameBox.Text=\"\" #Get VM Memory $Index=$MemoryComboBox.SelectedIndex [String]$VMMem=$MemoryComboBox.Items[$Index] $VMMem=$VMMem + \"GB\" $Index=$MemoryComboBox.SelectedIndex=0 #Get Virtual Hard Disk Size [String]$VHDX = $VHDSizeBox.Text $VHDX = $VHDX + \"GB\" $VHDSizeBox.Text = \"\" #Create VHD Path $VHDPath=\"C:\\temp\\\" + $VMName + \".VHDX\" #Form VM Creation Command [String]$NewVMCommand = \"New-VM -Name $VMName -MemoryStartupBytes $VMMem -NewVHDPath $VHDPath -NewVHDSizeBytes $VHDX\" #Create Virtual Machine Invoke-Expression $NewVMCommand }) $Form = New-Object Windows.Forms.Form $Form.Text = \"VM Creation Tool\" $Form.Width = 550 $Form.Height = 350 $Form.BackColor=\"LightBlue\" $Form.Controls.add($GreetingLabel) $Form.Controls.add($VMNameBox) $Form.Controls.add($VMNameLabel) $Form.Controls.add($VHDSizeBox) $Form.Controls.add($VHDSizeLabel) $Form.Controls.add($MemoryComboBox) $Form.Controls.add($MemoryLabel) $Form.Controls.add($CreateButton) $Form.Add_Shown({$Form.Activate()}) $Form.ShowDialog() Brien Posey is a 15-time Microsoft MVP with two decades of IT experience. He has served as a lead network engineer for the U.S. Department of Defense and as a network administrator for some of the largest insurance companies in America."
    },
    {
        "link": "https://medium.com/tomtalkspowershell/creating-gui-applications-with-powershell-a-step-by-step-guide-2713997728ef",
        "document": "In the fast-paced world of IT and system administration, efficiency is paramount. As system administrators and IT professionals, we often find ourselves juggling multiple tasks, scripts, and command-line operations to manage our environments effectively. However, the traditional command-line interface, while powerful, can be daunting for users who are not well-versed in scripting languages. This is where PowerShell comes to the rescue, offering a robust solution to enhance usability through the creation of graphical user interfaces (GUIs).\n\nIn this blog post, we will delve into the world of GUI applications using PowerShell, providing a step-by-step guide tailored specifically for IT professionals. We will cover the fundamentals of building user-friendly interfaces that can simplify complex scripts, making them more accessible for users across your organization. You will learn how to leverage PowerShell’s capabilities to create interactive forms and dialogs, enabling you to present data and receive input in a visually appealing manner.\n\nBy the end of this tutorial, you will know how to transform your PowerShell scripts into intuitive applications that enhance the efficiency and effectiveness of your IT operations. Whether you’re automating routine tasks or providing tools for your team, creating GUIs with PowerShell will empower you to streamline processes and improve user experience. Join us as we unlock the potential of PowerShell GUIs and take your scripting skills to the next level!\n\nBefore you begin, ensure that you have PowerShell installed on your machine. Most Windows environments come with PowerShell by default, but it’s good to check.\n\nPowerShell can leverage .NET Framework’s Windows Forms to create GUI applications. The first step in building a GUI is to load the necessary assembly.\n\nNow, let’s create a basic form. This form will serve as the foundation for our GUI applications.\n\nControls are the elements like buttons, text boxes, and labels that users interact with. Let’s add a button and a label to our form.\n\nTo make your GUI interactive, you need to handle events. We’ll write a simple event for the button click.\n\nNow that we have our controls and events defined, we need to add them to the form.\n\nFinally, to display the form, you call the ShowDialog() method.\n\nStep 8: Putting It All Together\n\nOnce you are comfortable with creating simple forms, you can expand functionality by adding more controls, such as text boxes, radio buttons, and dropdown lists, to gather user inputs. You can also interact with PowerShell cmdlets to perform tasks based on user input.\n\nCreating GUI applications with PowerShell allows system administrators and IT professionals to make their scripts more user-friendly and accessible. By following this step-by-step guide, you’ve learned the basics of setting up a form, adding controls, and handling events. As you become more familiar with these concepts, you can build more complex applications tailored to your specific IT tasks.\n• The example provided serves as a foundation for more complex applications.\n\nWhy GUI Applications Matter in IT\n\nIn the fast-paced world of IT, time is of the essence. GUI applications built with PowerShell can streamline everyday tasks, allowing administrators to focus on more strategic initiatives rather than repetitive manual processes. These applications serve as a bridge between complex backend scripts and end-users, making it easier for them to execute tasks such as user management, system monitoring, and reporting without needing to understand the intricacies of PowerShell.\n\nConsider a scenario where an IT team needs to onboard new employees. Traditionally, this might involve running multiple scripts to create user accounts, set permissions, and configure email accounts. By creating a PowerShell GUI application, the onboarding process can be simplified into a few clicks. The application can prompt the user for necessary information, validate the input, and execute the required scripts in the background, all while providing real-time feedback. This not only reduces the likelihood of errors but also frees up IT personnel to tackle other responsibilities.\n• User Management Tool: One practical application of PowerShell GUIs is user management. An IT team developed a GUI application that allows helpdesk staff to reset passwords, unlock accounts, and modify user attributes in Active Directory. The application includes dropdown menus for selecting users and input fields for specifying changes. By implementing this tool, the team reduced the average time spent on user requests from 15 minutes to just 5 minutes, significantly improving service delivery.\n• System Monitoring Dashboard: Another example is creating a system monitoring dashboard. An organization faced challenges in monitoring server health and performance metrics. The IT team designed a PowerShell GUI that aggregates data from various servers and displays it in a visually appealing format. The dashboard shows CPU usage, memory consumption, and disk space in real-time, enabling administrators to quickly identify and address potential issues before they escalate. As a result, the organization improved its proactive maintenance efforts and reduced downtime.\n• Backup Management Interface: Backup management is critical for data integrity and disaster recovery. An IT department developed a GUI application that simplifies the backup process for critical data. Users can select which folders to back up, set schedules, and monitor backup statuses through a user-friendly interface. This application not only ensured that backups were performed consistently but also provided an easy way for non-technical staff to initiate backups, mitigating the risk of data loss.\n\nAt a mid-sized financial institution, the IT department was struggling with a manual process for generating compliance reports. These reports required pulling data from various systems, running multiple scripts, and compiling the results into a single document. This time-consuming process often led to delays and inaccuracies. To address this, the team decided to create a PowerShell GUI application that automated data collection and report generation.\n\nThe GUI allowed users to select the type of report they needed, specify date ranges, and choose the output format. Behind the scenes, PowerShell scripts gathered the necessary information, processed it, and generated a polished report in a matter of seconds. As a result, the IT team reduced report generation time from hours to minutes, enabling them to focus on higher-value tasks and ensuring compliance with regulatory requirements.\n\nCreating GUI applications with PowerShell is not just about aesthetics; it’s about enhancing productivity and efficiency in IT operations. By leveraging the power of PowerShell to build user-friendly interfaces, system administrators can empower their teams, streamline processes, and ultimately deliver better service to their organizations. As you explore the capabilities of PowerShell GUIs, consider how you can transform your scripts into applications that make daily tasks easier and more efficient for everyone involved.\n\nHere are some engaging projects you can undertake to reinforce your learning and apply PowerShell GUI techniques in real-world scenarios:\n\nObjective: Create a GUI application that displays system information such as OS version, RAM, and CPU details.\n• Create a new script and start with the following code to create a form:\n• Run the script. Click the ‘Get System Info’ button to display your system’s details in the label.\n\nExpected Outcome: A simple GUI that presents your system’s OS, CPU, and RAM information at the click of a button.\n\nObjective: Develop a GUI to back up a specified folder to a selected destination.\n• Start a new script in your PowerShell editor.\n• Use the following code to create a backup tool:\n• Run the script. Enter the source and destination folders, then click ‘Back Up’ to copy files.\n\nExpected Outcome: A functional GUI tool that allows you to specify directories for backing up files, providing a simple interface for a common IT task.\n\nObjective: Construct a GUI for managing user accounts, allowing you to create and delete users easily.\n• Create a new script in your PowerShell environment.\n• Use the following code to build the user management tool:\n• Run the script. Enter a username and use the buttons to create or delete user accounts.\n\nBy engaging in these projects, you’ll not only solidify your understanding of PowerShell GUIs but also create tools that can save time and streamline processes in your day-to-day work. Don’t hesitate to modify and expand on these ideas as you see fit! Happy scripting!\n\nAs you explore the topic of ‘Creating GUI Applications with PowerShell: A Step-by-Step Guide’, it’s crucial to have access to quality resources that can enhance your understanding and skills as a system administrator or IT professional. Below is a curated list of supplementary materials that will provide deeper insights and practical knowledge:\n\nPowerShell GUI — How to get started — LazyAdmin: https://lazyadmin.nl/powershell/powershell-gui-howto/\n\nContinuous learning is key to mastering any subject, and these resources are designed to support your journey in IT management. Dive into these materials to expand your horizons and apply new concepts to your work.\n\nUnlock the full potential of PowerShell with “Mastering PowerShell for System Administrators.” This essential guide is perfect for both beginners and seasoned IT professionals looking to enhance their skills. Get your copy today and start transforming your workflow!\n\nDive into a world of insights, resources, and inspiration at Tom Austin’s Website. Whether you’re keen on deepening your tech knowledge, exploring creative projects, or discovering something new, our site has something for everyone. Visit us today and embark on your journey!"
    },
    {
        "link": "https://reddit.com/r/PowerShell/comments/11htjw4/gui_for_powershell",
        "document": "I'd like to make a gui for all my powershell script almost like a tool box where I can arrange them and run on a click.\n\nAny ideas on the best way to start. Am a complete noob."
    },
    {
        "link": "https://reddit.com/r/PowerShell/comments/wa8sqe/adding_a_gui_for_powershell_scripts_preferred_and",
        "document": "I had been looking for a way to add a GUI to my powershell scripts in the past and could not find one that was simple enough for me to get started.\n\nI am aware normally its built using .NET but I think the learning curve on that would be a bit intense just to learn how to add some GUI to my scripts? If someone know any specifc training I would appreciate.\n\nI know how to use Tkinter on Python, and have tried some parse powershell commands to python but the results were kind of messy and not really friendly.\n\nDoes anyone know what is the best, and what is the easiest option to go around learning how to add my scripts to a GUI format?"
    },
    {
        "link": "https://medium.com/@bonguides25/winforms-creating-guis-in-windows-powershell-with-winforms-54bc2e144175",
        "document": "I have created many PowerShell scripts for the last couple of years. All with a single purpose to automate my IT work as much as possible. But this week I needed to create a script that could be run by the users themselves. And users and command line aren’t the best combination, so let’s take a look at using the PowerShell GUI.\n\nThe objective of this chapter is to cover the basics of creating a graphical user interface (GUI) using Windows PowerShell. Although Windows PowerShell itself does not include any GUI capabilities, it does have access to the .NET framework, including the WinForms programming interface.\n\nWinForms is a subset of the .NET framework designed specifically for the creation of Windows based GUIs. It allows GUI controls (such as buttons and labels) to be placed in containers (such as a form) and displayed to the user.\n\nIn addition, an event handling mechanism allows the programmer to define what actions are taken when a user interacts with a control or container (for example clicking on a button or resizing a dialog). Through the use of properties, the programmer is also able to control the appearance and behavior of controls and containers, for example changing the text displayed by a label.\n\nIn the remainder of this chapter, we will work through some examples which cover the key aspects of WinForms based GUI development using Windows PowerShell.\n\nAs outlined in the chapter entitled An Overview of Windows PowerShell 1.0 and .NET, only a few .NET assemblies are loaded into Windows PowerShell by default. As WinForms is not amongst the pre-loaded assemblies, it is necessary to load WinForms prior to creating GUIs. Assemblies are loaded using the static LoadWith PartialName method of the [reflection.assembly] class, passing through the name of the WinForms assembly as an argument:\n\nOnce loaded, we are ready to create a simple GUI from within Windows PowerShell.\n\nOnce the WinForms assembly has been loaded the next step is to create a simple example. As previously discussed, WinForms GUIs consist of containers, controls and events. With this in mind, the following example creates a form (container) and a button (control), adds the button to the form and displays the dialog:\n\nNote\n\n Note: Before we start creating a form is it important to know that the PowerShell script is run sequentially. So you define your form and show it. But any code after you displayed the form won’t be executed until you close the form.\n\n \n\n ×\n\n Dismiss this alert.\n\n \n\n \n\n\n\nWhen executed, the resulting dialog will appear as follows:\n\nThe next area to cover involves the handling of events. An event is typically triggered when a user interacts with a control. For example, clicking on a button control will trigger an event. Event handlers are nothing more than lines of code which define what is to happen when the event is triggered (for example, an event handler may be written to exit the application when a Close button is clicked).\n\nIn Windows PowerShell, event handlers take the form of scriptblocks, which are essentially sequences of commands wrapped in braces ().\n\nEvent handlers are added to a control using methods which have the following syntax:\n\nWhere is the name of the event to be handled and is the code to be executed when the event is triggered. For example, to close the dialog in the above example when the button is clicked:\n\nUsing scriptblocks would quickly become unwieldy if all the code to be executed had to be included along with the add_ method. An alternative to this approach is to call a function instead. The following adaptation of our example defines a function called MyFunction and subsequently references it in the event handler scriptblock:\n\nWinForms components are essentially objects, and as such, have properties which can be set to alter component appearance and behavior. As with other object properties, these can be accessed using standard dot notation. In the previous example, we used this approach to set the text of the button control:\n\nSimilarly, we could set the title of the form using the form object’s text property:\n\nBringing it all Together\n\nNow that we have seen a simple GUI created in Windows PowerShell and covered some of the basic techniques we can create a slightly more complex GUI.\n\nThe following script creates a GUI containing a label, button and text field. An event handler is configured on the button such that when it is clicked the text is extracted from the text field and used to construct a message which is then displayed on the label control.\n\nNote\n\n Tip: The creation of Drawing.Point objects to configure the size and location of controls on the form.\n\n \n\n ×\n\n Dismiss this alert.\n\n \n\n Click to reveal the code \n\n \n\n # Load the Winforms assembly\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n#Set the dialog title\n\n$form.text = \"PowerShell WinForms Example\"\n\n# Create the label control and set text, size and location\n\n$label = New-Object Windows.Forms.Label\n\n$label.Location = New-Object Drawing.Point 50,30\n\n$label.Size = New-Object Drawing.Point 200,15\n\n$label.text = \"Enter your name and click the button\"\n\n# Create TextBox and set text, size and location\n\n$textfield = New-Object Windows.Forms.TextBox\n\n$textfield.Location = New-Object Drawing.Point 50,60\n\n$textfield.Size = New-Object Drawing.Point 200,30\n\n# Create Button and set text and location\n\n$button = New-Object Windows.Forms.Button\n\n$button.text = \"Greeting\"\n\n$button.Location = New-Object Drawing.Point 100,90\n\n# Set up event handler to extarct text from TextBox and display it on the Label.\n\n$button.add_click(\n\n$label.Text = \"Hello \" + $textfield.text\n\n)\n\n# Add the controls to the Form\n\n$form.controls.add($button)\n\n$form.controls.add($label)\n\n$form.controls.add($textfield)\n\n# Display the dialog\n\n$form.ShowDialog()\n\nWhen adding controls to the form to display them in the GUI. You can add them one by one, or you can add all of them using AddRange property.\n\n...\n\n# Add the controls to the Form\n\n$form.controls.add($button)\n\n$form.controls.add($label)\n\n$form.controls.add($textfield)\n\n# Add the controls to the Form\n\n$form.controls.AddRange(@($button,$label,$textfield))\n\n...\n\nWe have the following controls that we can use on our forms:\n\nSo, let’s create some controls on our form. Add the code below to your script. Make sure that ShowDialog is at the end of your script.\n\nThe textbox control is used to accept and display an input as a single line of text. For example, the following script creates a GUI containing a label, button and text field. An event handler is configured on the button such that when it is clicked the text is extracted from the text field and used to construct a message which is then displayed on the label control.\n\nClick to reveal the code (TextBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(330,150)\n\n# Create a label control\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(30,20)\n\n$label.Text = 'Enter your name then click Submit button:'\n\n$label.ForeColor = 'Blue'\n\n$label.AutoSize = $true\n\n# Create a textbox control\n\n$textbox = New-Object System.Windows.Forms.TextBox\n\n$textbox.Location = New-Object System.Drawing.Point(30,40)\n\n$textbox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$textbox.ForeColor = 'Blue'\n\n$textbox.AutoSize = $true\n\n# Create a button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.location = New-Object System.Drawing.Point(28,70)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(110,77)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Red'\n\n$label1.AutoSize = $true\n\n# Event handler when click the button\n\n$submitButton.add_click(\n\n $label1.Text = 'Hello ' + $textbox.Text\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($textbox,$label,$label1,$submitButton))\n\n[void]$form.ShowDialog()\n\nThe place of the controls is based on points/pixels from the left side and the top side. So, the location 30,50 is 30 pixels from the left side and 50 points from the top side. And you can configure additional prroperties for the label control such as drawing size, font family, font size…\n\nYou can define the width and height of each control by $control.Size, but if your content is longer then the element it will only be partially displayed. So, by setting the Autosize to true, you are assured that the user can read the whole label.\n\n➡️ Navigate to the list of controls.\n\nThe next control you can add to the form is ComboBox (Dropdown list). The code below is pretty clear I think, we create the combo box and add the items with a single line foreach loop to the list. Again, we also define the position and I have set the size for the control.\n\nClick to reveal the code (ComboBox) \n\n \n\n Add-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n$form = New-Object Windows.Forms.Form\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Text = \"Select a category:.\"\n\n$label.Location = New-Object System.Drawing.Point(30,30)\n\n$label.AutoSize = $true\n\n$combobox = New-Object system.Windows.Forms.ComboBox\n\n$combobox.Text = \"\"\n\n$combobox.Size = New-Object Drawing.Point 150,20\n\n$combobox.location = New-Object System.Drawing.Point(30,60)\n\n# $combobox.Autosize = $true\n\n# Add the items in the dropdown list\n\n@('PowerShell','Microsoft 365','Windows Server') | ForEach-Object $combobox.Items.Add($_)\n\n# Select the default value\n\n$combobox.SelectedIndex = 0\n\n$form.controls.AddRange(@($label,$combobox))\n\n$form.ShowDialog()\n\nYou can set a default value for your dropdown list by selecting the index. Below is output if we’re not configured the default value for the combobox.\n\n➡️ Navigate to the list of controls.\n\nIn the previous section, we got the handling of events when a user interacts with a control. Now, in this section we’ll get more detail with a button in a PowerShell winforms. A button can have a standard action, like (\n\nOK, Cancel, Abort, Retry, Ignore, Yes, or No) or you can assign a custom function to it.\n\nThe buttons we are going to add are Cancel and Enter.\n• Cancel button will just close the form and does nothing else.\n• Enter button will run our logic to show a text. Add the buttons with the code below, again make sure you add the variables of the buttons to the $form.controls.AddRange\n\n➡️ Navigate to the list of controls.\n\nPictureBox is a rectangular region for an image. It supports many image formats. It has an adjustable size. It can access image files from your disk or from the Internet.\n\nA picture can be loaded to the form from your local computer with ImageLocation property as follows:\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n$form.AutoScale = $true\n\n$form.AutoSize = $true\n\n# Create a PictureControl control\n\n$pictureBox = New-Object System.Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Point(20,20)\n\n$pictureBox.ImageLocation = \"C:imageschart.png\"\n\n$pictureBox.AutoSize = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($pictureBox))\n\n[void]$form.ShowDialog()\n\nThe image cannot be shown if the script runs on another computer. You can upload the image to any cloud location, get the direct link of the image then Load it into the form.\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n$form.AutoScale = $true\n\n$form.AutoSize = $true\n\n# Create a PictureControl control\n\n$pictureBox = New-Object System.Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Point(20,20)\n\n$pictureBox.Load('https://bonguides.com/img/143614112023.png')\n\n$pictureBox.AutoSize = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($pictureBox))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nThe checkbox is a very common element in forms. The most common usage I have seen for checkboxes is on a survey, or when you agree to a license agreement during a software install. The script below is a nice example of how to enable and disable the OK button by checking the checkbox.\n\nClick to reveal the code (CheckBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(300,180)\n\n# Create a label\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(140,84)\n\n$label.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$label.AutoSize = $true\n\n# Create your checkbox \n\n$checkbox1 = New-Object System.Windows.Forms.checkbox\n\n$checkbox1.Location = New-Object System.Drawing.Size(20,20)\n\n$checkbox1.Size = New-Object System.Drawing.Size(250,20)\n\n$checkbox1.Text = \"Enable/Disable OK button\"\n\n# Add an OK button\n\n$OKButton = New-Object System.Windows.Forms.Button\n\n$OKButton.Location = New-Object System.Drawing.Size(20,70)\n\n$OKButton.Size = New-Object System.Drawing.Size(100,40)\n\n$OKButton.Text = \"OK\"\n\n$OKButton.Enabled = $false\n\n$OKButton.Add_Click($Form.Close())\n\n# Do something when the state of the checkbox changes\n\n$checkbox1.Add_CheckStateChanged(\n\n $OKButton.Enabled = $checkbox1.Checked\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($checkbox1,$OKButton,$label))\n\n$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nGroupBox combines a header with a box around other control. Nest a Grid within GroupBox. With a GroupBox, we can place them within a box that has a header. This makes interfaces easier to understand and interact with.\n\nIn a GroupBox we can nest another control. We used the Grid, Label, CheckBox… controls within a GroupBox. For example, we’ll create a groupbox with combobox, label, picturebox, textbox and button.\n\nClick to reveal the code (GroupBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(450,350)\n\n# Create a group that will contain your radio buttons\n\n$groupBox = New-Object System.Windows.Forms.GroupBox\n\n$groupBox.Location = '20,20'\n\n$groupBox.Size = '400,220'\n\n$groupBox.Text = \"Do you like Coffee?\"\n\n$groupBox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$groupBox.SendToBack()\n\n# Create the collection of radio buttons\n\n$RadioButton1 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton1.Location = '20,40'\n\n$RadioButton1.AutoSize = $true\n\n$RadioButton1.Checked = $true \n\n$RadioButton1.Text = \"Yes - I like Coffee.\"\n\n$RadioButton2 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton2.Location = '20,70'\n\n$RadioButton2.AutoSize = $true\n\n$RadioButton2.Checked = $false\n\n$RadioButton2.Text = \"No - I don't like Coffee.\"\n\n$RadioButton3 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton3.Location = '20,100'\n\n$RadioButton3.AutoSize = $true\n\n$RadioButton3.Checked = $false\n\n$RadioButton3.Text = \"This is not a Coffee related response.\"\n\n$pictureBox = New-Object Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Size(320,30)\n\n$pictureBox.Load('https://bonguides.com/img/163014112023.png')\n\n$pictureBox.Size = New-Object System.Drawing.Size(50,50)\n\n$pictureBox.SizeMode = 'StretchImage'\n\n$pictureBox.BringToFront()\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.Text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.Location = New-Object System.Drawing.Point(20,260)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n$cancelButton = New-Object System.Windows.Forms.Button\n\n$cancelButton.BackColor = \"red\"\n\n$cancelButton.Text = \"Cancel\"\n\n$cancelButton.Size = New-Object System.Drawing.Point (70,30)\n\n$cancelButton.Location = New-Object System.Drawing.Point(100,260)\n\n$cancelButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(20,140)\n\n$label1.Text = 'Leave a comment:'\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Regular)\n\n$label1.AutoSize = $true\n\n# Create a textbox control\n\n$textbox = New-Object System.Windows.Forms.TextBox\n\n$textbox.Location = New-Object System.Drawing.Point(20,163)\n\n$textbox.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$textbox.Size = New-Object System.Drawing.Size(350,50)\n\n# Add radio buttons into the groupbox control\n\n$groupBox.Controls.AddRange(@($Radiobutton1,$RadioButton2,$RadioButton3,$pictureBox,$label1,$textbox))\n\n# Event handler when click the buttons\n\n$submitButton.add_click()\n\n$cancelButton.add_click(\n\n $form.Close()\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($groupBox,$cancelButton,$submitButton))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nRadio buttons are another element used when creating forms. They allow an end-user to select one option from a group. For example, you post a question on a form — Do you like coffee? — The options for the answer would be:\n• Sometimes — depending on the type of coffee.\n\nThese answers cover all the possible answers to the question. When presented to the end user you only want them to select one option from the group.\n\nTo set this up in PowerShell we have to do a few things:\n• Create the radio buttons and give them values,\n• Create the form and add the usual Submit and Cancel buttons.\n\nThe code for all of this is below:\n\nClick to reveal the code (RadioButton) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(450,350)\n\n# Create a group that will contain your radio buttons\n\n$groupBox = New-Object System.Windows.Forms.GroupBox\n\n$groupBox.Location = '20,20'\n\n$groupBox.Size = '400,150'\n\n$groupBox.Text = \"Do you like Coffee?\"\n\n$groupBox.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$groupBox.SendToBack()\n\n# Create the collection of radio buttons\n\n$RadioButton1 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton1.Location = '20,40'\n\n$RadioButton1.AutoSize = $true\n\n$RadioButton1.Checked = $true \n\n$RadioButton1.Text = \"Yes - I like Coffee.\"\n\n$RadioButton2 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton2.Location = '20,70'\n\n$RadioButton2.AutoSize = $true\n\n$RadioButton2.Checked = $false\n\n$RadioButton2.Text = \"No - I don't like Coffee.\"\n\n$RadioButton3 = New-Object System.Windows.Forms.RadioButton\n\n$RadioButton3.Location = '20,100'\n\n$RadioButton3.AutoSize = $true\n\n$RadioButton3.Checked = $false\n\n$RadioButton3.Text = \"This is not a Coffee related response.\"\n\n# Add radio buttons into the groupbox control\n\n$groupBox.Controls.AddRange(@($Radiobutton1,$RadioButton2,$RadioButton3,$pictureBox))\n\n$pictureBox = New-Object Windows.Forms.PictureBox\n\n$pictureBox.Location = New-Object System.Drawing.Size(320,30)\n\n$pictureBox.Load('https://bonguides.com/img/163014112023.png')\n\n$pictureBox.Size = New-Object System.Drawing.Size(50,50)\n\n$pictureBox.SizeMode = 'StretchImage'\n\n$pictureBox.BringToFront()\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"green\"\n\n$submitButton.text = \"Submit\"\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.location = New-Object System.Drawing.Point(20,190)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n$cancelButton = New-Object System.Windows.Forms.Button\n\n$cancelButton.BackColor = \"red\"\n\n$cancelButton.text = \"Cancel\"\n\n$cancelButton.Size = New-Object System.Drawing.Point (70,30)\n\n$cancelButton.location = New-Object System.Drawing.Point(100,190)\n\n$cancelButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(20,250)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Green'\n\n$label1.AutoSize = $true\n\n# Event handler when click the buttons\n\n# Check the current state of each radio button and respond accordingly\n\n$submitButton.add_click(\n\n if ($RadioButton1.Checked) \n\n # So the popup\n\n # [System.Windows.Forms.MessageBox]::Show(\"You like Coffee.\" , \"Great\")\n\n # Print message into the form\n\n $label1.Text = \"You like Coffee. Great\"\n\n elseif ($RadioButton2.Checked) \n\n [System.Windows.Forms.MessageBox]::Show(\"So your not a fan of Coffee.\" , \"Awe\")\n\n \n\n elseif ($RadioButton3.Checked) \n\n [System.Windows.Forms.MessageBox]::Show(\"That's OK - You don't have to answer the questions\" , \"'No' to coffee\")\n\n \n\n)\n\n$cancelButton.add_click(\n\n $form.Close()\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($groupBox,$cancelButton,$submitButton,$label1,$pictureBox))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nThis indicates the progress of an operation. ProgressBar is best used on a long-running computation or task. The ProgressBar control is often used with a threading mechanism such as BackgroundWorker. It helps let your users know the application is still active. Below is the code to showing a progressbar when downloading a file. The logic is:\n\nClick to reveal the code (ProgressBar) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(320,250)\n\n# Create button control\n\n$downloadButton = New-Object System.Windows.Forms.Button\n\n$downloadButton.BackColor = \"Green\"\n\n$downloadButton.Text = \"> Click to download\"\n\n$downloadButton.Font = New-Object System.Drawing.Font(\"Consolas\",11,[System.Drawing.FontStyle]::Bold)\n\n$downloadButton.Size = New-Object System.Drawing.Point (220,50)\n\n$downloadButton.Location = New-Object System.Drawing.Point(40,40)\n\n$downloadButton.ForeColor = \"#ffffff\"\n\n# Create a label control\n\n$label1 = New-Object System.Windows.Forms.Label\n\n$label1.Location = New-Object System.Drawing.Point(40,140)\n\n$label1.Font = New-Object System.Drawing.Font(\"Consolas\",9,[System.Drawing.FontStyle]::Bold)\n\n$label1.ForeColor = 'Green'\n\n$label1.AutoSize = $true\n\n# Create a progressbar control\n\n$ProgressBar = New-Object System.Windows.Forms.ProgressBar\n\n$ProgressBar.Location = New-Object System.Drawing.Size(40,100)\n\n$ProgressBar.Size = New-Object System.Drawing.Size(218,10)\n\n$ProgressBar.Style = \"Marquee\"\n\n$ProgressBar.MarqueeAnimationSpeed = 10\n\n$ProgressBar.Hide()\n\n# Create the function\n\nfunction PSDownloader \n\n $downloadButton.BackColor = \"#1F1F1F\"\n\n $downloadButton.Text = \"Downloading...\"\n\n $ProgressBar.Visible = $true \n\n $label1.Text = \"It could take a while to complete...\"\n\n $job = Start-Job -ScriptBlock \n\n Invoke-WebRequest 'http://ipv4.download.thinkbroadband.com/10MB.zip' -OutFile 'C:10MB.zip'\n\n \n\n do [System.Windows.Forms.Application]::DoEvents() until ($job.State -eq \"Completed\")\n\n Remove-Job -Job $job -Force\n\n $downloadButton.BackColor = \"Green\"\n\n $downloadButton.Text = \"> Click to download\"\n\n $ProgressBar.Hide()\n\n $label1.Text = \"Completed\"\n\n \n\n# Event handler when click the buttons (call function)\n\n$downloadButton.add_click(PSDownloader)\n\n# Add the controls to the form then display the dialog.\n\n$form.Controls.AddRange(@($downloadButton,$label1,$ProgressBar))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nListBox stores several text items. It can interact with other controls. In the below example code, we create a list of DNS server, this will be used as a data source. Select a DNS server from the list then click Submit button to check online status of it.\n\nClick to reveal the code (ListBox) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(500,400)\n\n$label = New-Object System.Windows.Forms.Label\n\n$label.Location = New-Object System.Drawing.Point(20,10)\n\n$label.Size = New-Object System.Drawing.Size(280,20)\n\n$label.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Regular)\n\n$label.Text = 'Please select a DNS server:'\n\n# Create a listbox control\n\n$listbox = New-Object System.Windows.Forms.ListBox\n\n$listbox.Location = New-Object System.Drawing.Point(20,30)\n\n$listbox.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Regular)\n\n$listbox.Size = New-Object System.Drawing.Size(450,70)\n\n# Add the items in the listbox\n\n@('8.8.8.8','8.8.4.4','1.1.1.1') | ForEach-Object $listbox.Items.Add($_)\n\n# Create button control\n\n$submitButton = New-Object System.Windows.Forms.Button\n\n$submitButton.BackColor = \"Green\"\n\n$submitButton.Text = \"Submit\"\n\n$submitButton.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Bold)\n\n$submitButton.Size = New-Object System.Drawing.Point (70,30)\n\n$submitButton.Location = New-Object System.Drawing.Point(20,100)\n\n$submitButton.ForeColor = \"#ffffff\"\n\n# Create a textbox to display the output\n\n$textboxOutput = New-Object system.Windows.Forms.TextBox\n\n$textboxOutput.Multiline = $true\n\n$textboxOutput.Text = \"Waiting for results...\"\n\n$textboxOutput.Font = New-Object System.Drawing.Font(\"Consolas\",10,[System.Drawing.FontStyle]::Bold)\n\n$textboxOutput.Size = New-Object System.Drawing.Size(450,200)\n\n$textboxOutput.Location = New-Object System.Drawing.Point(20,140)\n\n$textboxOutput.BackColor = \"#1F1F1F\"\n\n$textboxOutput.ForeColor = 'Cyan'\n\n# Event handler when click the button\n\n$submitButton.add_click(\n\n $textboxOutput.Text = (powershell -noprofile -Command \"ping $($listBox.SelectedItem)\" )\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($listbox,$label,$submitButton,$textboxOutput))\n\n[void]$form.ShowDialog()\n\nThe items in a listbox can be added manually or can be passed from a pipeline. For example, below code pull the list of services or list of disabled user into the listbox.\n\n# Add the items in the listbox manualy\n\n# @('8.8.8.8','8.8.4.4','1.1.1.1') | ForEach-Object $listbox.Items.Add($_)\n\n# Pull the list of services into the listbox\n\nGet-Service | ForEach-Object $listbox.Items.Add($_.Name)\n\n# Get the list of disabled users on Active Directory\n\nGet-ADUser -Filter (Enabled -eq \"false\") | Foreach $listbox.Items.Add($_.Name)\n\n➡️ Navigate to the list of controls.\n\nThe DataGridView control provides a visual interface to a data object. It gives the ability to display and allow editing in a tabular format. In a GUI application, the scripters can take advantage of using this control to present the data to the user.\n\nBelow is an example of DataGridView to display the list of services on a Windows computer.\n\n# Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(470,360)\n\n# Get the list of services into an array\n\n$gps = get-process | Select-Object Name,ID,Description,@n='Memory';e=$_.WorkingSet\n\n$list = New-Object System.collections.ArrayList\n\n$list.AddRange($gps)\n\n# Create a DataGridView control\n\n$dataGridView = New-Object System.Windows.Forms.DataGridView\n\n$dataGridView.Size = New-Object System.Drawing.Size(460,290)\n\n$dataGridView.DataSource = $list\n\n$dataGridView.ColumnHeadersVisible = $true\n\n$dataGridView.ColumnHeadersVisible = $true\n\n$dataGridView.AllowUserToAddRows = $true\n\n# Add the controls to the form then display the dialog.\n\n$form.controls.AddRange(@($dataGridView))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls.\n\nYou can allow for color selection in your PowerShell GUI with the System.Windows.Forms.ColorDialog. Below is a simple example to change the form background with ColorDialog.\n\nClick to reveal the code (ColorDialog) \n\n \n\n # Load the .Net assemblies\n\nAdd-Type -AssemblyName System.Windows.Forms, System.Drawing\n\n[System.Windows.Forms.Application]::EnableVisualStyles()\n\n# Create the form\n\n$form = New-Object Windows.Forms.Form\n\n$form.Text = 'www.bonguides.com'\n\n$form.Size = New-Object System.Drawing.Size(400,360)\n\n# Create colorDialog\n\n$colorDialog = New-Object System.Windows.Forms.ColorDialog\n\n# Create a button\n\n$enterButton = New-Object System.Windows.Forms.Button\n\n$enterButton.Size = New-Object System.Drawing.Point (30,30)\n\n$enterButton.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat\n\n$enterButton.FlatAppearance.BorderSize = '0'\n\n$enterButton.Location = New-Object System.Drawing.Point(340,20)\n\n$enterButton.Image = [System.Drawing.Image]::Fromfile(\"E:img91015112023.png\")\n\n# Create event handler\n\n$enterButton.add_click(\n\n $colorDialog.ShowDialog()\n\n $form.BackColor = $colordialog.Color\n\n)\n\n# Add the controls to the form then display the dialog.\n\n$form.Controls.AddRange(@($enterButton))\n\n[void]$form.ShowDialog()\n\n➡️ Navigate to the list of controls."
    }
]