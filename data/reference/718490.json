[
    {
        "link": "https://geeksforgeeks.org/basics-file-handling-c",
        "document": "File handling in C is the process in which we create, open, read, write, and close operations on a file. C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc. to perform input, output, and many different C file operations in our program.\n\nWhy do we need File Handling in C?\n\nSo far the operations using the C program are done on a prompt/terminal which is not stored anywhere. The output is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program. The use of file handling is exactly what the situation calls for.\n\nIn order to understand why file handling is important, let us look at a few features of using files:\n• Reusability: The data stored in the file can be accessed, updated, and deleted anywhere and anytime providing high reusability.\n• Portability: Without losing any data, files can be transferred to another in the computer system. The risk of flawed coding is minimized with this feature.\n• Efficient: A large amount of input may be required for some programs. File handling allows you to easily access a part of a file using few instructions which saves a lot of time and reduces the chance of errors.\n• Storage Capacity: Files allow you to store a large amount of data without having to worry about storing everything simultaneously in a program.\n\nTypes of Files in C\n\nA file can be classified into two types based on the way the file stores the data. They are as follows:\n\nA text file contains data in the form of ASCII characters and is generally used to store a stream of characters.\n• None Each line in a text file ends with a new line character (‘\n\n’).\n• None It can be read or written by any text editor.\n• None They are generally stored with .txt\n• None Text files can also be used to store the source code.\n\nA binary file contains data in binary form (i.e. 0’s and 1’s) instead of ASCII characters. They contain data that is stored in a similar manner to how it is stored in the main memory.\n• None The binary files can be created only from within a program and their contents can only be read by a program.\n• None More secure as they are not easily readable.\n• None They are generally stored with .bin\n\nC file operations refer to the different possible operations that we can perform on a file in C such as:\n• fopen() with attributes as “a” or “a+” or “w” or “w+”\n\nThe highlighted text mentions the C function used to perform the file operations.\n\nA file pointer is a reference to a particular position in the opened file. It is used in file handling to perform all file operations such as read, write, close, etc. We use the FILE macro to declare the file pointer variable. The FILE macro is defined inside <stdio.h> header file.\n\nFile Pointer is used in almost all the file operations in C.\n\nFor opening a file in C, the fopen() function is used with the filename or file path along with the required access modes.\n• file_name: name of the file when present in the same directory as the source file. Otherwise, full path.\n• access_mode: Specifies for what operation the file is being opened.\n• None If the file is opened successfully, returns a file pointer to it.\n• None If the file is not opened, then returns NULL.\n\nFile opening modes or access modes specify the allowed operations on the file to be opened. They are passed as an argument to the fopen() function. Some of the commonly used file access modes are listed below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) returns NULL. Open for reading in binary mode. If the file does not exist, fopen( ) returns NULL. Open for writing in text mode. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens only in the append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. If the file does not exist, it will be created. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file does not exist, fopen( ) returns NULL. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist a new file is created. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens the file in both reading and append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. If the file does not exist, it will be created.\n\nAs given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”.\n\nThe file is not opened because it does not exist in the source directory. But the fopen() function is also capable of creating a file if it does not exist. It is shown below\n\nThe fopen() function can not only open a file but also can create a file if it does not exist already. For that, we have to use the modes that allow the creation of a file if not found such as w, w+, wb, wb+, a, a+, ab, and ab+.\n\nThe file read operation in C can be performed using functions fscanf() or fgets(). Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. There are also other functions we can use to read from a file. Such functions are listed below:\n\nSo, it depends on you if you want to read the file line by line or character by character.\n\nThe getc() and some other file reading functions return EOF (End Of File) when they reach the end of the file while reading. EOF indicates the end of the file and its value is implementation-defined.\n\nThe file write operations can be performed by the functions fprintf() and fputs() with similarities to read operations. C programming also provides some other functions that can be used to write data to a file such as:\n\nThe fclose() function is used to close the file. After successful file operations, you must always close a file to remove it from the memory.\n\nwhere the file_pointer is the pointer to the opened file.\n\nExamples of File Handing in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nThis program will create a file named GfgTest.c in the same directory as the source file which will contain the following text: “GeeksforGeeks-A Computer Science Portal for Geeks”.\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nThis program reads the text from the file named GfgTest.c which we created in the previous example and prints it in the console.\n\nTill now, we have only discussed text file operations. The operations on a binary file are similar to text file operations with little difference.\n\nTo open a file in binary mode, we use the rb, rb+, ab, ab+, wb, and wb+ access mode in the fopen() function. We also use the .bin file extension in the binary filename.\n\nWe use fwrite() function to write data to a binary file. The data is written to the binary file in the from of bits (0’s and 1’s).\n• ptr: pointer to the block of memory to be written.\n• size: size of each element to be written (in bytes).\n\nExample: Program to write to a Binary file using fwrite()\n\nThe fread() function can be used to read data from a binary file in C. The data is read from the file in the same form as it is stored i.e. binary form.\n• ptr: pointer to the block of memory to read.\n• size: the size of each element to read(in bytes).\n\nExample: Program to Read from a binary file using fread()\n\nIf we have multiple records inside a file and need to access a particular record that is at a specific position, so we need to loop through all the records before it to get the record. Doing this will waste a lot of memory and operational time. To reduce memory consumption and operational time we can use fseek() which provides an easier way to get to the required data. fseek() function in C seeks the cursor to the given record in the file.\n\nThe rewind() function is used to bring the file pointer to the beginning of the file. It can be used in place of fseek() when you want the file pointer at the start.\n\nMore Functions for C File Operations\n\nThe following table lists some more functions that can be used to perform file operations or assist in performing them."
    },
    {
        "link": "https://stackoverflow.com/questions/25903590/c-vs-c-file-handling",
        "document": "An interesting critical comparison can be found here.\n\nNot exactly polite, but makes to think...\n\nThe C++ FQA (that is a critical response to the C++ FAQ) is often considered by the C++ community a \"stupid joke issued by a silly guy the even don't understand what C++ is or wants to be\"(cit. from the FQA itself).\n\nThese kind of argumentation are often used to flame (or escape from) religion battles between C++ believers, Others languages believers or language atheists each in his own humble opinion convinced to be in something superior to the other.\n\nI'm not interested in such battles, I just like to stimulate critical reasoning about the pros and cons argumentation. The C++ FQA -in this sens- has the advantage to place both the FQA and the FAQ one over the other, allowing an immediate comparison. And that the only reason why I referenced it.\n\nFollowing TonyD comments, below (tanks for them, I makes me clear my intention need a clarification...), it must be noted that the OP is not just discussing the and (I just talk about them in my comments just for brevity) but the entire function-set that makes up the I/O model of C and C++.\n\nWith this idea in mind, think also to other \"imperative\" languages (Java, Python, D ...) and you'll see they are all more conformant to the C model than C++. Sometimes making it even type safe (what the C model is not, and that's its major drawback).\n\nWhat my point is all about\n\nAt the time C++ came along as mainstream (1996 or so) the library (note the \".h\": pre-ISO) was in a language where templates where not yet fully available, and, essentially, no type-safe support for varadic functions (we have to wait until C++11 to get them), but with type-safe overloaded functions.\n\nThe idea of oveloading retuning it's first parameter over and over is -in fact- a way to chain a variable set of arguments using only a binary function, that can be overload in a type-safe manner. That idea extends to whatever \"state management function\" (like or ) through manipulators (like ) appear as a natural consequence. This points -despite of what you may thing to the FQA author- are real facts. And is also a matter of fact that FQA is the only site I found that talks about it.\n\nThat said, years later, when the D language was designed starting offering varadic templates, the function was added in the D standard library providing a -like syntax, but also being perfectly type-safe. (see here)\n\nNowadays C++11 also have varadic templates ... so the same approach can be putted in place just in the same way.\n\nBoth C++ and C io models appear \"outdated\" respect to a modern programming style. C retain speed, C++ type safety and a \"more flexible abstraction for localization\" (but I wonder how many C++ programmers are in the world that are aware of locales and facets...) at a runtime-cost (jut track with a debugger the << of a number, going through stream, buffer locale and facet ... and all the related virtual functions!).\n\nThe C model, is also easily extensible to parametric messages (the one the order of the parameters depends on the localization of the text they are in) with format strings like\n\nThe C++ model has no concept of \"format string\": the parameter order is fixed and itermixed with the text.\n\nBut C++11 varadic templates can be used to provide a support that:\n• can offer both compile-time and run-time locale selection\n• can offer both compile-time and run-time parametric order\n\nIs it time to standardize a new C++ i/o model ?"
    },
    {
        "link": "https://geeksforgeeks.org/c-fopen-function-with-examples",
        "document": "In C, the fopen() function is used to open a file in the specified mode. The function returns a file pointer (FILE *) which is used to perform further operations on the file, such as reading from or writing to it. If the file exists then the fopen() function opens the particular file else a new file is created in some cases.\n\nLet’s take a look at an example:\n\nOn running the following program, a new file will be created by the name “demo_file.txt” with the following content:\n• filename: Name of the file to be opened (with extension)\n• mode: For what purpose file is to be opened.\n• None Returns a FILE pointer if the file is successfully opened.\n\nThe below table lists valid mode values for feof() function with their meaning:\n\nSearches file. Opens the file for reading only. If the file is opened successfully fopen() loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen() returns NULL. Searches file. If the file exists already, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. It creates a new file for writing only(no reading). Searches file. If the file is opened successfully fopen() loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The file is opened only for appending(writing at the end of the file). Searches file. Opens the file for both reading and writing. If opened successfully, fopen() loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The difference between w and w+ is that we can also read the file created using w+. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. The file is opened for reading and appending(writing at the end of the file). Open the binary file in read mode. If the file does not exist, the open() function returns NULL. Open the binary file in write mode. As the pointer is set to the start of the file, the contents are overwritten. If the file does not exist, a new file is created. Open the binary file in append mode. The file pointer is set after the last character in the file. A new file is created if no file exists with the name. Open the binary file in read and write mode. If the file does not exist, the open() function returns NULL. Open the binary file in read and write mode. Contents are overwritten if the file exists. It will be created if the file does not exist. Open the binary file in read and append mode. A file will be created if the file does not exist.\n\nIt is recommended to close the opened file after doing the required operations using fclose().\n\nThe below examples demonstrate how to use the fopen() for opening files in different modes:\n\nExplanation: The file example.txt is opened in read mode (“r”). If the file exists, it opens successfully. If the file doesn’t exist, fopen() returns NULL, and the program outputs an error message.\n\nExplanation: The file output.txt is opened in write mode (“w”). If the file does not exist, it is created. The program writes a string to the file using fprintf(). After writing, the file is closed using fclose().\n\nExplanation: The file append_example.txt is opened in append mode (“a”). If the file exists, the new content is appended to the end of the file. If the file does not exist, it is created. The program appends the text using fprintf().\n\nExplanation: This code tries to open a non-existent file non_existent_file.txt in read mode (“r”). If the file doesn’t exist, fopen() returns NULL. The perror() function is used to print a detailed error message explaining why the file could not be opened."
    },
    {
        "link": "https://scaler.com/topics/c/file-handling-in-c",
        "document": "File handling in C involves a series of operations including creation, opening, reading, writing, and closing of files. To accomplish these tasks, C provides a set of functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), among others. These functions enable input, output, and various file operations in C programs.\n\nWhy do we need File Handling in C?\n\nFile handling in C is crucial for various reasons, enhancing the functionality and usability of programs:\n• Reusability: Data stored in files can be accessed, modified, and deleted as needed, providing high reusability of information.\n• Portability: Files can be easily transferred between different systems without data loss. This feature minimizes the risk of coding errors and ensures seamless operation across platforms.\n• Efficiency: File handling in C simplifies the process of accessing and manipulating large amounts of data. It allows programs to efficiently retrieve specific information from files with minimal code, saving time and reducing the likelihood of errors.\n• Storage Capacity: Files provide a means to store vast amounts of data without the need to hold everything in memory simultaneously. This capability is particularly useful for handling large datasets and prevents memory overload in programs.\n\nTypes of Files in C\n\nWe will be working with two types of files: -\n\nLet’s understand them in brief -\n\nText file - The user can create these files easily while handling files in C. It stores information in the form of ASCII characters internally, and when the file is opened, the content is readable by humans. It can be created by any text editor with a .txt or .rtf (rich text)extension. Since text files are simple, they can be edited by any text editor like Microsoft Word, Notepad, Apple Text Edit, etc.\n\nBinary file - It stores information in the form of 0’s or 1’s, and it is saved with the .bin extension, taking less space. Since it is stored in a binary number system format, it is not readable by humans. Therefore it is more secure than a text file.\n\nThere are different kinds of file operations in C:\n\nIn file handling in C, a file pointer serves as a reference to a specific position within an opened file. It facilitates various file operations in C like reading, writing, closing, and more. The FILE macro is employed to declare a file pointer variable, and it is defined within the <stdio.h> header file.\n\nFile pointers are utilized extensively in nearly all file operations in C programming.\n\nTo open a file in C, the fopen() function is employed, specifying the filename or file path along with the desired access modes.\n• : If the file resides in the same directory as the source file, provide its name; otherwise, specify the full path.\n• : Specifies the operation for which the file is being opened.\n• If the file is successfully opened, it returns a file pointer to it.\n• If the file fails to open, it returns NULL.\n\nWe use fopen() with different opening modes to open a file. The most common modes used are listed below.\n\nIn append mode, we can write data into an existing file without deleting existing contents. In contrast, in write mode, existing data is deleted, which was already present in the file.\n\nThe fopen() function in C not only opens existing files but also creates a new file if it doesn't already exist. This behavior is achieved by using specific modes that allow file creation, such as \"w\", \"w+\", \"wb\", \"wb+\", \"a\", \"a+\", \"ab\", and \"ab+\".\n\nTo read data from an existing file, we will use “r” mode in file opening. To read the file character by character, we use getc(). And to read line by line, we use fgets().\n\nAdditionally, there exist alternative functions available for reading from a file, which are enumerated below:\n\nIn the program above, the getc() function is utilized to read the file character by character until it reaches the end of the file (EOF).\n\nAs file2.txt was already present in my directory, the output is as shown.\n\nFile writing operations in C are facilitated by functions like fprintf() and fputs(), which exhibit similarities to their counterparts used for reading operations. Additionally, C programming provides several other functions suitable for writing data to a file, including:\n\nThe fclose() function is utilized to close a file in C programming. It is essential to close a file after performing file operations in C to release system resources and ensure proper memory management.\n\nHere, file_pointer is a pointer to the opened file that you want to close.\n\nAfter completing the necessary file operations in C, the fclose() function is called to close the file pointed to by fptr.\n\nExamples of File Handling in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nWhen intending to operate on a file in binary mode, utilize the access modes \"rb\", \"rb+\", \"ab\", \"ab+\", \"wb\", or \"wb+\" with the fopen() function. Additionally, employ the \".bin\" file extension for binary files.\n\nIn this example, the file \"example.bin\" is opened in binary mode for reading using the \"rb\" access mode.\n\nWhen writing data to a binary file, the fwrite() function proves invaluable. This function allows us to store information in binary form, comprising sequences of bits (0s and 1s).\n• : A reference to the memory block holding the data intended for writing.\n• : The byte size of each element to be written.\n• : The count of elements to be written.\n• : The FILE pointer associated with the output file stream.\n\nThe function returns the number of objects successfully written.\n\nExample: Program to write to an Binary file using the fwrite() function\n\nWhen retrieving data from a binary file, the fread() function serves as a pivotal tool. This function facilitates the extraction of data from the file in its binary representation.\n• : A pointer to the memory block where the data will be stored.\n• : The size of each element to be read (in bytes).\n• : The number of elements to be read.\n• : The FILE pointer pointing to the input file stream.\n\nThe function returns the number of objects successfully read.\n\nExample: Program to Read from an binary file using the fread() function\n\nWhen dealing with files containing multiple records, locating a specific record can be cumbersome and inefficient if we have to traverse through all the preceding records. This not only consumes memory but also increases operational time. To address this, we can utilize fseek() which efficiently positions the file cursor to the desired record.\n• : Number of bytes to offset from the position specified by .\n• : Position from where the offset is applied. It can take one of the following values:\n\nIn this instance, we initiate the opening of a binary file named \"data.bin\" for reading in binary mode (\"rb\"). We then use fseek() to move the file pointer to the end of the file (SEEK_END). Finally, we print the position of the file pointer using ftell(), which will indicate the size of the file in bytes.\n\nThe rewind() function in C is utilized to move the file pointer back to the beginning of the file. It serves as a convenient alternative to fseek() when the intention is to position the file pointer at the start of the file.\n\nIn this example, we open a file named \"data.txt\" in write mode with reading capabilities (\"w+\"). We write the string \"Hello, World!\n\n\" to the file using fprintf(). Then, we use rewind() to reset the file pointer to the beginning of the file. Next, we read the content of the file using fscanf(), storing it in the buffer array, and finally, we print the content read from the file.\n\nMore Functions for C File Operations"
    },
    {
        "link": "https://programiz.com/c-programming/c-file-input-output",
        "document": "A file is a container in computer storage devices used for storing data.\n• When a program is terminated, the entire data is lost. Storing in a file will preserve your data even if the program terminates.\n• If you have to enter a large number of data, it will take a lot of time to enter them all.\n\n However, if you have a file containing all the data, you can easily access the contents of the file using a few commands in C.\n• You can easily move your data from one computer to another without any changes.\n\nWhen dealing with files, there are two types of files you should know about:\n\nText files are the normal .txt files. You can easily create text files using any simple text editors such as Notepad.\n\nWhen you open those files, you'll see all the contents within the file as plain text. You can easily edit or delete the contents.\n\nThey take minimum effort to maintain, are easily readable, and provide the least security and takes bigger storage space.\n\nBinary files are mostly the .bin files in your computer.\n\nInstead of storing data in plain text, they store it in the binary form (0's and 1's).\n\nThey can hold a higher amount of data, are not readable easily, and provides better security than text files.\n\nIn C, you can perform four major operations on files, either text or binary:\n• Reading from and writing information to a file\n\nWhen working with files, you need to declare a pointer of type file. This declaration is needed for communication between the file and the program.\n\nOpening a file is performed using the function defined in the header file.\n\nThe syntax for opening a file in standard I/O is:\n• Let's suppose the file doesn't exist in the location . The first function creates a new file named and opens it for writing as per the mode 'w'.\n\n The writing mode allows you to create and edit (overwrite) the contents of the file.\n• Now let's suppose the second binary file exists in the location . The second function opens the existing file for reading in binary mode 'rb'.\n\n The reading mode only allows you to read the file, you cannot write into the file.\n\nThe file (both text and binary) should be closed after reading/writing.\n\nClosing a file is performed using the function.\n\nHere, is a file pointer associated with the file to be closed.\n\nFor reading and writing to a text file, we use the functions and\n\nThey are just the file versions of and . The only difference is that and expects a pointer to the structure FILE.\n\nThis program takes a number from the user and stores in the file .\n\nAfter you compile and run this program, you can see a text file created in C drive of your computer. When you open the file, you can see the integer you entered.\n\nThis program reads the integer present in the file and prints it onto the screen.\n\nIf you successfully created the file from Example 1, running this program will get you the integer you entered.\n\nOther functions like , etc. can be used in a similar way.\n\nFunctions and are used for reading from and writing to a file on the disk respectively in case of binary files.\n\nTo write into a binary file, you need to use the function. The functions take four arguments:\n• address of data to be written in the disk\n• size of data to be written in the disk\n• number of such type of data\n• pointer to the file where you want to write.\n\nExample 3: Write to a binary file using fwrite()\n\nIn this program, we create a new file in the C drive.\n\nWe declare a structure with three numbers - , and define it in the main function as num.\n\nNow, inside the for loop, we store the value into the file using .\n\nThe first parameter takes the address of and the second parameter takes the size of the structure .\n\nSince we're only inserting one instance of , the third parameter is . And, the last parameter points to the file we're storing the data.\n\nFunction also take 4 arguments similar to the function as above.\n\nExample 4: Read from a binary file using fread()\n\nIn this program, you read the same file and loop through the records one by one.\n\nIn simple terms, you read one record of size from the file pointed by into the structure .\n\nYou'll get the same records you inserted in Example 3.\n\nIf you have many records inside a file and need to access a record at a specific position, you need to loop through all the records before it to get the record.\n\nThis will waste a lot of memory and operation time. An easier way to get to the required data can be achieved using .\n\nAs the name suggests, seeks the cursor to the given record in the file.\n\nThe first parameter stream is the pointer to the file. The second parameter is the position of the record to be found, and the third parameter specifies the location where the offset starts.\n\nThis program will start reading the records from the file in the reverse order (last to first) and prints it."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/filename-search-functions?view=msvc-170",
        "document": "These functions search for and close searches for specified file names:\n\nThe function provides information about the first instance of a file name that matches the file specified in the argument. You can use in any combination of wildcard characters that is supported by the host operating system.\n\nThe functions return file information in a structure, which is defined in . Various functions in the family use many variations on the structure. The basic structure includes the following elements:\n\n\n\n Time of file creation ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last file access ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last write to file. This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Length of the file in bytes.\n\n[ ] -terminated name of matched file or directory, without the path.\n\nIn file systems that don't support the creation and last access times of a file, such as the FAT system, the and fields are always .\n\nis defined in as 260 bytes.\n\nYou can't specify target attributes (such as ) to limit the find operation. These attributes are returned in the field of the structure and can have the following values (defined in ). Users shouldn't rely on these attributes being the only values possible for the field.\n\n\n\n Archive. Set whenever the file is changed and cleared by the command. Value: .\n\n\n\n Hidden file. Not often seen with the command, unless you use the option. Returns information about normal files and files that have this attribute. Value: .\n\n\n\n Normal. File has no other attributes set and can be read or written to without restriction. Value: .\n\n\n\n Read-only. File can't be opened for writing and a file that has the same name can't be created. Value: .\n\n\n\n System file. Not ordinarily seen with the command, unless the or option is used. Value: .\n\nfinds the next name, if any, that matches the argument specified in an earlier call to . The argument should point to a structure initialized by the previous call to . If a match is found, the structure contents are changed as described earlier. Otherwise, it's left unchanged. closes the specified search handle and releases all associated resources for both and . The handle returned by either or must first be passed to , before modification operations, such as deleting, can be performed on the directories that form the paths passed to them.\n\nYou can nest the functions. For example, if a call to or finds the file that is a subdirectory, a new search can be initiated with another call to or .\n\nand are wide-character versions of and . The structure argument of the wide-character versions has the data type, which is defined in and in . The fields of this data type are the same as the fields of the data type, except that in the field is of type instead of type . Otherwise, and behave identically to and .\n\nand use the 64-bit time type. If you must use the old 32-bit time type, you can define . The versions of these functions that have the suffix in their names use the 32-bit time type, and the ones with the suffix use the 64-bit time type.\n\nFunctions , , , and also behave identically to the 32-bit time type versions of these functions except they use and return 64-bit file lengths. Functions , , , and use the 64-bit time type but use 32-bit file lengths. These functions use appropriate variations of the type in which the fields have different types for the time and the file size.\n\nis actually a macro that evaluates to (or if is defined). The following table summarizes the variations on :"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/findfirst-functions?view=msvc-170",
        "document": "Provide information about the first instance of a file name that matches the file specified in the argument.\n\n\n\n File information buffer. For more information about the structs, see the Remarks in Filename search functions and see Data type mappings. The structs are defined in the same header file as the function that uses them as a parameter.\n\nIf successful, returns a unique search handle identifying the file or group of files that match the specification, which can be used in a subsequent call to or to . Otherwise, returns -1 and sets to one of the following values.\n\nFor more information about these and other return codes, see , , , and .\n\nIf an invalid parameter is passed in, these functions invoke the invalid parameter handler, as described in Parameter validation.\n\nYou must call after you're finished with either the or function (or any variants) provided the call to succeeded. frees resources used by these functions in your application. Calling on an invalid handle returns and sets to .\n\nThe variations of these functions that have the prefix are wide-character versions; otherwise, they're identical to the corresponding single-byte functions.\n\nVariations of these functions support 32-bit or 64-bit time types and 32-bit or 64-bit file sizes. The first numeric suffix ( or ) indicates the size of the time type; the second suffix is either or , and indicates whether the file size is represented as a 32-bit or 64-bit integer. For information about which versions support 32-bit and 64-bit time types and file sizes, see the following table. The or suffix is omitted if it's the same as the size of the time type, so also supports 64-bit file lengths and supports only 32-bit file lengths.\n\nThese functions use various forms of the structure for the parameter. For more information about the structure, see Filename search functions.\n\nThe variations that use a 64-bit time type enable file-creation dates to be expressed up through 23:59:59, December 31, 3000, UTC. The ones that use 32-bit time types represent dates only through 23:59:59 January 18, 2038, UTC. Midnight, January 1, 1970, is the lower bound of the date range for all these functions.\n\nUnless you have a specific reason to use the versions that specify the time size explicitly, use or or, if you need to support file sizes larger than 3 GB, use or . All these functions use the 64-bit time type. In earlier versions, these functions used a 32-bit time type. If this change is a breaking change for an application, you might define to revert to the old behavior. If is defined, , , and their corresponding Unicode versions use a 32-bit time.\n\nBy default, this function's global state is scoped to the application. To change this behavior, see Global state in the CRT.\n\nFor more compatibility information, see Compatibility."
    },
    {
        "link": "https://github.com/MicrosoftDocs/cpp-docs/blob/master/docs/c-runtime-library/filename-search-functions.md",
        "document": "These functions search for and close searches for specified file names:\n\nThe function provides information about the first instance of a file name that matches the file specified in the argument. You can use in any combination of wildcard characters that is supported by the host operating system.\n\nThe functions return file information in a structure, which is defined in . Various functions in the family use many variations on the structure. The basic structure includes the following elements:\n\n\n\n Time of file creation ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last file access ( for FAT file systems). This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Time of the last write to file. This time is stored in UTC format. To convert to the local time, use .\n\n\n\n Length of the file in bytes.\n\n[ ] -terminated name of matched file or directory, without the path.\n\nIn file systems that don't support the creation and last access times of a file, such as the FAT system, the and fields are always .\n\nis defined in as 260 bytes.\n\nYou can't specify target attributes (such as ) to limit the find operation. These attributes are returned in the field of the structure and can have the following values (defined in ). Users shouldn't rely on these attributes being the only values possible for the field.\n\n\n\n Archive. Set whenever the file is changed and cleared by the command. Value: .\n\n\n\n Hidden file. Not often seen with the command, unless you use the option. Returns information about normal files and files that have this attribute. Value: .\n\n\n\n Normal. File has no other attributes set and can be read or written to without restriction. Value: .\n\n\n\n Read-only. File can't be opened for writing and a file that has the same name can't be created. Value: .\n\n\n\n System file. Not ordinarily seen with the command, unless the or option is used. Value: .\n\nfinds the next name, if any, that matches the argument specified in an earlier call to . The argument should point to a structure initialized by the previous call to . If a match is found, the structure contents are changed as described earlier. Otherwise, it's left unchanged. closes the specified search handle and releases all associated resources for both and . The handle returned by either or must first be passed to , before modification operations, such as deleting, can be performed on the directories that form the paths passed to them.\n\nYou can nest the functions. For example, if a call to or finds the file that is a subdirectory, a new search can be initiated with another call to or .\n\nand are wide-character versions of and . The structure argument of the wide-character versions has the data type, which is defined in and in . The fields of this data type are the same as the fields of the data type, except that in the field is of type instead of type . Otherwise, and behave identically to and .\n\nand use the 64-bit time type. If you must use the old 32-bit time type, you can define . The versions of these functions that have the suffix in their names use the 32-bit time type, and the ones with the suffix use the 64-bit time type.\n\nFunctions , , , and also behave identically to the 32-bit time type versions of these functions except they use and return 64-bit file lengths. Functions , , , and use the 64-bit time type but use 32-bit file lengths. These functions use appropriate variations of the type in which the fields have different types for the time and the file size.\n\nis actually a macro that evaluates to (or if is defined). The following table summarizes the variations on :"
    },
    {
        "link": "https://stackoverflow.com/questions/45608205/recursively-find-files-with-a-certain-extension-using-findfirstfile-and-findnext",
        "document": "You need to search recursively for each subdirectory. I happen to have some code to do this, the following code might help.\n\nHere is an example of the usage of the function above:\n\nAnd you will get the following output:\n\nThe maxdepth I passed to the function is 1. Pass -1 to search all the subdirectories."
    },
    {
        "link": "https://stackoverflow.com/questions/646673/how-can-i-get-findfirstfile-to-sort-files",
        "document": "As everyone has pointed out, does not and can not sort the files it returns. It operates at a fairly low level, and returns files in an order that relates to file system's natural order of directory entries in a directory.\n\nOn a disk formatted with FAT and FAT32, that order will strongly relate to the order in which the files were created, modified by file deletions and possible re-use of now empty directory entry slots. This is because FAT directories are (as on many unix filesystems) simply a packed array of fixed-size directory entry structs, along with an ugly hack to fit long file names written in Unicode into a directory structure designed for 8.3 names written in ASCII. Unlike Unix, Win32 API calls are required to read the directory entries, but that doesn't affect the order in which the entries are read.\n\nOn NTFS (as I understand it) directories are represented in some variant of a B-Tree and the natural order of files seen by the Win32 API is therefore related to the indexing natural to that data structure.\n\nYou can see the differences with the command at the command prompt. On a FAT32 volume, shows the files in a different order than it will if that same folder is copied to an NTFS volume. should list files in the same order regardless of the underlying file system in use.\n\nNeither unsorted order produced by DIR is the same as the order produced by Windows Explorer when you sort by Name. (For that matter, isn't the same, either.)\n\nWindows Explorer uses a case-independent sort, that also seems to ignore some punctuation marks in the sort, and tries to be clever about numbers. In particular, a simple use of with won't get the same answer as Explorer. It isn't clear if the actual sort order used by either Explorer or DIR is documented anywhere.\n\nFor example, the following names sort like this in DIR:\n\nbut transcribing from Explorer sorted in the Name column they are in this order:\n\nI'm having trouble imagining the simple to apply in a comparison function to get the latter effect."
    }
]