[
    {
        "link": "https://tutorialspoint.com/pascal/pascal_basic_syntax.htm",
        "document": "You have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.\n\nA variable definition is put in a block beginning with a var keyword, followed by definitions of the variables as follows:\n\nPascal variables are declared outside the code-body of the function which means they are not declared within the begin and end pairs, but they are declared after the definition of the procedure/function and before the begin keyword. For global variables, they are defined after the program header.\n\nIn Pascal, a procedure is set of instructions to be executed, with no return value and a function is a procedure with a return value. The definition of function/procedures will be as follows −\n\nThe multiline comments are enclosed within curly brackets and asterisks as (* ... *). Pascal allows single-line comment enclosed within curly brackets { ... }.\n\nPascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.\n\nPascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.\n\nThe statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.\n\nFollowing is a list of reserved words available in Pascal.\n\nThe entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier. An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier."
    },
    {
        "link": "https://docs.oracle.com/cd/E19957-01/802-5762/802-5762.pdf",
        "document": ""
    },
    {
        "link": "https://downloads.freepascal.org/fpc/docs-pdf/ref.pdf",
        "document": ""
    },
    {
        "link": "https://freepascal.org/docs-html/ref/ref.html",
        "document": ""
    },
    {
        "link": "http://pascal.hansotten.com/uploads/standardpascal/Standard%20PASCAL.pdf",
        "document": ""
    },
    {
        "link": "https://forum.lazarus.freepascal.org/index.php?topic=36445.0",
        "document": "\n• Kallstadt seems a good place to evict Trump to. Re: How to efficiently generate a list of random integers within a range? \n\nIt seems actually pretty good, provided you know it doesn't really pass any serious random tests. It merely fools you.\n\nBut it looks random and is unique It's also faster than a linked lists + swap and remove\n• None // The 5 integers out of range are mapped to themselves. \n\n\n\n Note that if you do any math scaling, you will loose that uniqueness , though, so it may not be suitable for Bart without further work.\n\nQuick tested with a TList<Cardinal> from rtl-generics, List.sort and Assert(List.IndexOf(List[i-1]) = List.LastIndexOf(List[i-1]),'Has duplicates'); over 3.000.000 entries: no duplicates as expected.\n\n Here's a class translated from https://github.com/preshing/RandomSequence/blob/master/randomsequence.h It seems actually pretty good, provided you know it doesn't really pass any serious random tests. It merely fools you.But it looks random and is uniqueIt's also faster than a linked lists + swap and remove, though, so it may not be suitable for Bart without further work.Quick tested with a TList from rtl-generics, List.sort and Assert(List.IndexOf(List[i-1]) = List.LastIndexOf(List[i-1]),'Has duplicates'); over 3.000.000 entries: no duplicates as expected. « Last Edit: April 09, 2017, 10:55:49 am by Thaddy » But I am sure they don't want the Trumps back...\n• Kallstadt seems a good place to evict Trump to. Re: How to efficiently generate a list of random integers within a range? I have a version of my above code that stores m_index at hi(qword) and the random at lo(qword) in one go.\n\nWhen the number of required randoms are stored in a list or array and sorted on random, the m_index value becomes a unique random for the range.\n\nThe result is a very fast random - because the random sequence is pre-calculated - after initial setup and sort at the cost of memory for the list. If this is acceptable for Bart I can put it here as well.\n\n\n\nI also did some tests on the randomness for the original code with diehard. It's pretty good for its purpose. \n\nNote it is more or less an LCG and the uniqueness comes from its modulo (superhigh prime). Other LCG's can do the same or massaged to do the same given a high prime for a 32 bits unsigned. An LCG will never repeat itself for values: 0 < random < prime unless you perform an extra operation like a multiplication. (e.g 2 x 6 = 3 x 4 = 1 x 12 etc) But I am sure they don't want the Trumps back...\n• Kallstadt seems a good place to evict Trump to. Re: How to efficiently generate a list of random integers within a range? When you google you will often find the same sources. Note that I found a direct link to the C++ sourcecode for the class that I translated. But indeed, after a few clicks on molly's links you finally arrive at the same spot.\n\n\n\nAnd that reaction by Eugene was about the sattoro code, which is different from Molly's links.\n\n[edit] Ah I see, Molly links to Fisher Yates. Sattoro is not Fisher Yates...It is an improvement on Fisher Yates (just one cycle) . Same answer:independent. « Last Edit: April 10, 2017, 09:32:17 am by Thaddy » But I am sure they don't want the Trumps back...\n• Kallstadt seems a good place to evict Trump to. Re: How to efficiently generate a list of random integers within a range? \"Decrement max by 1 and continue. When max is 0, set max back to the size of the array - 1\"\n\nIs the wrong order. element zero will never be processed... N=1000... as the comments tell you. But I am sure they don't want the Trumps back..."
    },
    {
        "link": "https://stackoverflow.com/questions/4965863/how-to-get-a-random-number-in-pascal",
        "document": "I want to get a random number in pascal from between a range. Basically something like this:\n\nThe above code would then have a random number between 100 and 200.\n\nThe built in pascal function only lets you get a number from between 0-your range, while i need to specify the minimum number to return"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/qb7pw2/how_does_a_random_number_generator_work",
        "document": "I wanna implement a dice system but i don’t want to use rand() or premade functions. In order to do so i wanna know how exactly a random number is generated but i cant seem to find any code for it (most results is people using rand() function)"
    },
    {
        "link": "https://pcg-random.org/posts/bounded-rands.html",
        "document": "The vast majority of my posts about random number generation have focused on looking at the properties of different generation schemes. But, perhaps surprisingly, the performance of your randomized algorithm may hinge not on the generation scheme you chose, but on other factors. In this post (inspired by and building on an excellent recent paper by Daniel Lemire), we'll explore a common source of overhead in random number generation that frequently outweighs PRNG engine performance.\n\nFor their homework, Huan and Sasha both sit down to implement the same randomized algorithm in C++, running it on the same machine at the university on the same data sets. Their code is almost identical except for random number generation. Huan is eager to get to music practice and so just uses the Mersenne Twister. Sasha, on the other hand, spends several extra hours doing lots of investigation. Sasha benchmarks several fast PRNGs that have been touted lately on social media, and picks the fastest. When Huan and Sasha meet up, Huan can't wait to show off, asking Sasha, “What did you use as your PRNG?”\n\n“Oh, I just used the Mersenne Twister—it's built in and it seemed to work well,” says Huan.\n\n“Ha!” says Sasha. “I used . It goes much faster than something old and slow like the Mersenne Twister! My program was done in three minutes fifteen seconds!”.\n\n“Hmm, well, mine got done in under a minute,” says Huan and shrugs. “Anyhow, I'm off to a concert. Want to come?”\n\n“No,” says Sasha. “I, uh, want to take another look at my code….”\n\nThis embarrassing fictional scenario is not particularly contrived; it is actually based on real-world results. If your randomized algorithm isn't running as fast as you'd like and the bottleneck seems to be generating random numbers, somewhat counterintuitively the problem might not be with your random number generator!\n\nMost modern good-quality random number generators produce machine words filled with random bits, thus typically generating numbers in the range [0..232) or [0..264). But in many use cases users need numbers in a particular range—simple examples such as rolling a die or choosing a random playing card require numbers in small fixed ranges, but many algorithms from shuffling to reservoir sampling to randomized BSTs all need numbers drawn from different ranges.\n\nWe'll cover a number of different methods. To simplify the discussion, rather than generate in the range [i..j) or [i..j] we will generate numbers in the range [0..k). With such a scheme in hand, we can, for example, generate numbers in the range [i..j) by setting k = j - i, generating a number in the range [0..k) and then adding i to it.\n\nIn many languages there are built-in facilities for getting a random number in a range. For example, to draw a card from a 52-card deck using scripting languages like Perl and Python we can say and , respectively. In C++, we can similarly use .\n\nThe C++ code to implement this approach is just\n\nTypically, built-in approaches use one of the other techniques we will describe below, but most users will simply use the facilities provided without thinking too deeply about what is happening behind the scenes, assuming that they are well enough engineered and sufficiently efficient. In C++, the built-in techniques are more complex because they must be able to deal with quite arbitrary generation engines—a generator that produces values between -3 and 17 would be quite legal and can be used with to produce numbers in any range, such as [0..1000). C++'s built-in facilities are thus over-engineered for most of the uses to which they are put.\n\nLet's move from an over-engineered approach to an under-engineered one.\n\n When I was learning to program, we generated numbers in a range (e.g., to draw a card from a 52-card deck) using the modulo operator by writing something like to get a random number in the range [0..52).\n\nIn C++, we could write this approach as\n\nAlthough this approach is simple, it also illustrates why getting numbers within a range is typically slow—it requires division (to calculate the remainder produced by the operator). Division is typically at least an order of magnitude slower than other arithmetical operations, and so this single arithmetic operation takes longer than all the work done by a fast PRNG.\n\nBut in addition to being slow, it is also biased. To understand why produces biased numbers, if we assume that produces numbers in the range [0..232), observe that 52 does not perfectly divide 232, it divides it 82,595,524 times with remainder 48. Meaning that if we use , there will be 82,595,525 ways to select the first 48 cards from our 52-card deck and only 82,595,524 ways to select the final four cards . In other words, there is a 0.00000121% bias against these last four cards (perhaps these are the kings!). Back when I was a student writing homework assignments rolling dice or drawing cards, no one really worried about these tiny biases, but as the range increases, the bias increases linearly. For a 32-bit PRNG, a bounded range of less than 224 has a bias of less than 0.5% but above 231 the bias is 50%—some numbers will occur half as often as others.\n\nIn this article, our primary focus is on techniques that adopt strategies to avoid bias, but it's probably worth realizing that for a 64-bit PRNG the amount of bias in typical use cases is likely to be negligible.\n\nOne other concern we might have is that some generators have weak low-order bits. For example, the Xoroshiro+ and Xoshiro+ families of PRNGs have low-order bits that fail statistical tests. When we perform (because 52 is even) we pass the lowest bit straight through into the output.\n\nAnother common technique is to use a PRNG that generates floating point numbers in the unit interval [0..1), and then convert those numbers into the desired range. Perl adopts this approach, recommending using to generate an integer in the range [0..10) by generating a floating-point number and then rounding it down.\n\nIn C++, we would write this approach as\n\nThis approach is just as biased as the classic modulo approach, but the bias manifests itself differently. For example, if we were choosing numbers in the range [0..52), the numbers 0, 13, 26 and 39 would appear once less often than the others.\n\nThis version is also more annoying to generalize to 64 bits because it requires a floating point type with at least 64 bits of mantissa. On x86 Linux and macOS we can use to access x86 extended precision floating point which has a 64-bit mantissa, but is not universally portable—on some systems is equivalent to .\n\nOn the positive side, this approach works better than modulo-based approaches on PRNGs that have weak low order bits.\n\nThe multiplication method can be adjusted to used fixed-point arithmetic rather than floating point. Essentially we just multiply throughout by 232,\n\nIt might appear that this version requires 64-bit arithmetic, but on x86 CPUs, a good compiler will compile this code to a 32-bit instruction (which yields two 32-bit outputs, one of which is the return value). We should expect this version to be fast, but biased in exactly the same way as the floating-point multiplication method.\n\nWe can rearrange the above fixed-point–multiplication scheme into a division-based scheme. Instead of calculating , we calculate . Because we are doing integer arithmetic, this version has different rounding behavior and will sometimes generate values outside of the desired range. If we reject those values (i.e., throw them away and generate new ones), we end up with an unbiased technique.\n\nFor example, in the case of drawing a card using a 32-bit PRNG, we can generate a 32-bit number and divide it by 232/52 = 82,595,524 to choose our card. This method works when the random value from the 32-bit PRNG is less than 52 × 82595524 = 232/32 – 48. If the random value from the PRNG is one of the final 48 values at the top end of the range of the generator, it must be rejected and another sought.\n\nOur code for this version uses a trick to divide 232 by without using any 64-bit math. Calculating directly requires us to represent 232, which is too big (by one!) to be represented in a 32-bit integer. Instead, we observe that for unsigned integers, unary negation of calculates the positive value 232 – ; dividing this value by will produce an answer one less than .\n\nThus C++ code to generate numbers via division with rejection is\n\nOf course, this approach requires two slow division-based operations which are typically slower than other arithmetic operations, so we should not expect it to be quick.\n\nWe can also apply a rejection approach to debias the classic modulo method. In our playing card example, we will again need to reject 48 values. In this version, rather than reject the last 48 values, we (equivalently) reject the first 48 values.\n\nHere's a C++ implementation of this approach:\n\nThis technique eliminates bias, but it requires two time-consuming modulo operations for each output (and may require the underlying generator to produce more than one number). Thus we should expect it to be about half the speed of the classic biased approach.\n\nThe code for OpenBSD's (which is also used on OS X and iOS) adopts this strategy.\n\nJava adopts a different approach to generating a number in a range that manages to use only one modulo operation except in the relatively rare occasions when rejection occurs. The code is\n\nIt may take a little thought to figure out why this variant works. Unlike the previous version based on remainders, which removes bias by removing some of the lowest values from the underlying generation engine, this version filters out values from the top part of the engine's range.\n\nMuch as we removed bias from the modulo technique, we can also remove bias from the integer multiplication method. This method was devised by Lemire.\n\nOur final approach avoids division and remainder operations entirely. Instead it uses a simple masking operation to get a random number in the range [0..2k) where k is the smallest value such that 2k is greater than the range. If the value is too large for our range, we discard and try another. Code below:\n\nThis approach was adopted by Apple when (in the macOS Sierra release) they made their own revision to the code for .\n\nWe now have several approaches to evaluate. Unfortunately, benchmarking is tricky when we're concerned about the cost of a single division operation. No benchmark is going to capture all the factors that might be in play in your application and there's no guarantee that what is best for your application is necessarily best for mine.\n\nWe'll use three benchmarks, and test with a plethora of different PRNGs.\n\nPerhaps the most obvious benchmark to run is a shuffle benchmark. In this benchmark we will simulate performing a large shuffle. To sort an array of size N, we must generate numbers in the ranges [0..N), [0..(N-1)), … , [0..1). For this benchmark, we will assume N is as large as possible (232-1 for ). The code is\n\nNote that we “use” each number by adding it to (to avoid it being optimized away) but do not actually do any shuffling to keep the focus on number generation.\n\nTo test 64-bit generation, we have an analogous test, but it is not practical to run a test corresponding to shuffling an array of size 264 – 1 (because this larger-sized benchmark would take many thousands of years to run). Instead we cross the entire 64-bit range but generate the same number of outputs as the 32-bit test. The code is\n\nThe results below show the performance of this benchmark for each of the methods we've discussed, using the Mersenne Twister and testing at both 32-bit (with 's ) as discussed in this article and analogous 64-bit code (with 's ). Results are the geometric mean of 15 runs with different seeds, then normalized to make the classic biased-mod method have unit time.\n\nIt might appear that we have some clear answers about performance—we seem to have a clear progression of better techniques and might also perhaps wonder what the designers of were thinking when they wrote such a terrible implementation for 32-bit sizes—but as is so often the case with benchmarking, the situation is more complex than these results might seem to show. First, there is a risk that our results might somehow be specific to the Mersenne Twister, so we will broaden the set of PRNGs tested. Second, there may be a subtle issue with the benchmark itself. Let's address the first problem first.\n\nFor 32-bit PRNGs, we'll test with , , , , , , , , , , , , and , and for 64-bit PRNGs we'll use , , , , , , , , , , , , and . These collections give us some slow PRNGs and a number of very fast ones.\n\nHere are the results:\n\nWe can see some key differences from our early Mersenne-Twister-only results. Faster PRNGs will shift the balance towards the bounding code and thus the differences between our various approaches become more pronounced, especially for 64-bit PRNGs. With this broader collection of PRNGs the implementation now no longer seems terrible.\n\nIn this benchmark, the biased multiplication-based approach is fastest by a significant margin. There are many situations where bounds will be small relative to the size of the PRNG and performance is absolutely critical. In these situations a negligible amount of bias may be unlikely to have any noticeable effect but PRNG speed will. One such example is random-pivot Quicksort. For unbiased approaches, the bitmask technique also seems promising.\n\nBut before we draw too many conclusions, we should recognize that a significant issue with this benchmark is that the bulk of the time is spent with very high bounds, which likely overemphasizes large ranges. Thus we shall move on to a second benchmark.\n\nThis benchmark is similar to the previous one, but performs a much smaller “array shuffle” (executing it multiple times). The code is\n\nThis benchmark avoids overemphasis on larger bounds and more accurately reflects real use cases, but now omits larger bounds entirely.\n\nThis benchmark aims to avoid the deficiencies of the previous two by doing some testing at each power-of-two size, ensuring that each size is represented but not overrepresented.\n\nMany of our conclusions remain. The biased-multiply method is fast if we can tolerate bias, and the bitmask scheme seems like a good all-rounder.\n\nWe could be done at this point if we weren't willing to go back, look critically at our code, and make some adjustments.\n\nAlthough the all-ranges benchmark is probably the most representative one, we'll finish with two other benchmarks for the special case where the compiler knows that the range is a constant and can optimize the algorithms accordingly. Typically the compiler can produce code that is specialized for that particular range (e.g., modulo by a constant can avoid using the mod instruction).\n\nFor this benchmark, we use the small constant 52 as our range:\n\nEven though the compiler can and does optimize the bitmask version (precalculating the necessary mask) this algorithm rejects much more often than the other unbiased methods, spoiling its performance in this context. Versions based on integer multiplication win out, but the margin between them and versions based on division or modulo is much smaller.\n\nThis benchmark is similar to the previous one, but uses range closer to the maximum possible value rather than the minimum possible.\n\nIn this case, the bitmask version is not rejecting more often than the other techniques and so has similar performance. The 64-bit floating point code is apparently harder to optimize and actually turns in performance more than 8× worse than classic mod.\n\nThus far, all of our debiasing approaches require the use of an extra modulo operation, which causes them to run considerably slower than their biased counterparts. It would be helpful if we could find ways to reduce this overhead.\n\nA few of our algorithms have code involving a threshold, such as\n\nWhen is small compared to the output range of the PRNG, most of the time the number will be much greater than the threshold. Thus if we can have an estimate of the threshold that might be a little high, we can save an expensive modulo operation.\n\nThe code below achieves this goal:\n\nThis change can be applied to both the “Debiased Mod (Twice)” method (above) and the “Debiased Integer Multiply” approach. The idea is Lemire's, who applied it to the latter approach (but not the former).\n\nThis optimization results in notable improvements for the 64-bit benchmark (where modulo is even slower), but actually very slightly worsens performance in the 32-bit benchmark. Despite improvements, the bitmask approach still wins.\n\nOn the other hand, this change significantly speeds the small-shuffle benchmark for both the integer-multiply approach and the two-modulo approach, in each case moving their performance close to that of their unbiased variants. For the two-modulo (OpenBSD) approach, its performance is now almost identical to the single-modulo (Java) approach.\n\nWe see similar improvement in the all-ranges benchmark.\n\nIt seems like we can declare a new winner overall: Lemire's optimized debiased–integer-multiplication method.\n\nWe see little effect on the small-constant and large-constant benchmarks.\n\nUsually calculating requires division, but in situations where the result is simply with no division required, and, when , the result is simply . Thus, rather than calculate\n\nwe can instead run\n\nDivision is sufficiently expensive that the added overhead of this more complex code may pay off by the time saved by avoiding division.\n\nAdding this optimization noticeably helps the large-shuffle benchmark. Again, it is more noticeable for 64-bit code where modulo is more expensive. For the two-modulo approach (OpenBSD-style), we show versions with the optimization made for just one of its modulo operations and the other applying it to both.\n\nIn this benchmark, the bitmask approach is still the winner but the margin between it and Lemire's approach has narrowed significantly.\n\nAdding this optimization does not improve performance in the small-shuffle benchmark, so the question becomes whether it adds any noticeable cost. In some cases it does not, but in other cases it does add modest overhead.\n\nSimilarly, there is little change in the all-ranges benchmark.\n\nAgain, we see little effect on the small-constant and large-constant benchmarks.\n\nThe main reason for using a constellation of multiple PRNGs to test our number-in-range schemes was to avoid unintentionally skewing the results due to the peculiarities of one particular PRNG scheme. But we can also use the same underlying test results to compare the generation schemes themselves.\n\nThe graph below shows the performance of different 32-bit generation schemes, averaged across all the techniques and fifteen runs, normalized to the performance of the 32-bit Mersenne Twister:\n\nWe can see that there is greater improvement relative to the Mersenne Twister for the small-constant and large-constant benchmarks. This effect should not be a surprise—as we lower the cost of the number-in-a-range aspect, the performance of the generation engine becomes a greater factor in performance.\n\nOn the one hand, I'm pleased to see that is indeed fast. But it also shows why I rarely get too wound up about the performance of most modern high-performance general-purpose PRNGs—the differences between different techniques are very modest. In particular, the fastest four schemes differ in performance by less than 5%, which I consider to be “in the noise”.\n\nThe graph below shows the performance of different 64-bit generation schemes, averaged across all the techniques and fifteen runs, normalized to the performance of the 32-bit Mersenne Twister. It might seem strange to normalize to the 32-bit Mersenne Twister, but doing so helps us see the added cost of using 64-bit generation when 32-bit generation would have been sufficient.\n\nThese results confirm that is blazingly fast, but again the last four techniques differ by only about 5% so there is very little to choose between the fastest methods. and must necessarily be slower than because they have 128-bit LCGs and 128-bit MCGs as their base generators. Despite not being the fastest techniques in this collection, is still from 20% to 33% faster than the 64-bit Mersenne Twister.\n\nBut perhaps more importantly, these results also show that if you don't actually need 64-bit output, using a 64-bit PRNG is usually slower than using a 32-bit PRNG.\n\nFrom our benchmarks, we can see that switching from a commonly-used PRNG (e.g., the 32-bit Mersenne Twister) to a faster PRNG reduced the execution time of our benchmarks by 45%. But switching from a commonly used method for finding a number in a range to our fastest method reduced our benchmark time by about 66%, in other words reducing execution time to one third of the original time.\n\nThe fastest (unbiased) method is Lemire's (with an extra tweak from me). Here it is:\n\nUsing Lemire's method will make more of a difference to the performance of most randomized algorithms than switching from a fast generation engine to a slightly faster one.\n\nCode for all of the tests is on GitHub. Overall, I tested 23 methods for using 26 different PRNGs (13 32-bit PRNGs and 13 64-bit PRNGs), across two compilers, GCC 8 and and LLVM 6, resulting in 26 * 23 * 2 = 1196 executables, each of which was run with the same 15 seeds, resulting in 1196 * 15 = 17,940 distinct test runs, each combining three benchmarks. I ran tests primarily on a 48-core machine with four Xeon E7-4830v3 CPUs running at 2.1 GHz. Running the full set of tests required a little less than a month of CPU time.\n\nFinally, returning to our test scenario from the introduction, we imagine that Sasha used whereas Huan used . On Benchmark 3, the latter code takes 69.6% less time. Thus the times in the scenario are based on real-world data."
    },
    {
        "link": "https://reddit.com/r/pascal/comments/6mb7zi/generating_random_numbers_in_pascal",
        "document": "I am running an experiment that requires a decent random number generator. I need to use Pascal due to the constraints of my hardware. Here is the function I have written:\n\nPlease note that \"MPCGlobal:MPCGlobalPtr\" in the function argument is related to the specialized hardware that I am using, and can be ignored.\n\nI generated 100 random numbers between 0 and 1 using the above function, and plotted them in Matlab (Link). The black line and markers correspond to random numbers generated by my function; the red line and markers correspond to random numbers generated by Matlab's rand() function.\n\nAs you can see, the Pascal random numbers don't look very random at all - there is a definite pattern of ups and downs, and if you look closely at the labeled points, you will notice that the Y coordinates are all separated by 0.027.\n\nNot really sure why this is happening - if anyone here with more Pascal experience knows what is going on, would really appreciate some insight."
    },
    {
        "link": "https://en.wikibooks.org/wiki/Pascal_Programming/Arrays",
        "document": "An array is a structure concept for custom data types. It groups elements of the same data type. You will use arrays a lot if you are dealing with lots of data of the same data type.\n\nIn general, an array is a limited and arranged aggregation of objects, all of which having the same data type called base type or component type.[1] An array has at least one discrete, bounded dimension, continuously enumerating all its objects. Each object can be uniquely identified by one or more scalar values, called indices, along those dimensions.\n\nIn Pascal an array data type is declared using the reserved word in combination with the auxiliary reserved word , followed by the array’s base type:\n\nBehind the word follows a non-empty comma-separated list of dimensions surrounded by brackets.[fn 1] All array’s dimensions have to be ordinal data types, yet the base type type can be of any kind. If an array has just one dimension, like the one above, we may also call it a list.\n\nA variable of the data type as declared above, holds five independent values. Accessing them follows a specific scheme:\n\nThis will print , since it is the value of that has the index value . Arrays are like a series of “buckets” each holding one of the base data type’s values. Every bucket can be identified by a value according to the dimension specifications. When referring to one of the buckets, we have to name the group, that is the variable name (in this case ), and a proper index surrounded by brackets.\n\nLists of characters frequently have and had special support with respect to and manipulation. This section is primarily about understanding, as in the next chapter we will get to know a more sophisticated data type called .\n\nString literals can be assigned to variables using an assignment statement, thus instead of writing:\n\nNote, that you do not need to specify any index anymore. You are referring to the entire array variable on the of the assignment symbol ( ). This only works for overwriting the values of the whole array. There are extensions allowing you to overwrite merely parts of a array, but more on that in the next chapter.\n\nMost implementations of string literal to array assignments will pad the given string literal with insignificant values if it is shorter than the variable’s capacity. Padding a string means to fill the remaining positions with other characters in order meet a certain size. The uses space characters ( ), whereas the uses values whose inal value is zero ( ).\n\nAlthough not standardized,[fn 2] / and / usually support writing to and reading from variables.\n\nThis works because files, like the standard files and , are understood to be infinite sequences of values.[fn 3] Since our is also, although finite sequence of values, individual values can be copied pretty much directly to and from files, not requiring any kind of conversion.\n\nUnlike other arrays, variables can be compared using and .\n\nThis kind of comparison only works as expected for identical data types. It is a primitive character-by-character comparison. If either array is longer or shorter, an comparison will always fail, because not all characters can be compared to each other. Correspondingly, an comparison will always succeed for values that differ in length.\n\nNote, the standard also defines the and functions, beside many more. The difference to and is that blank padding (i. e. in FPC or in GPC) has no significance in and . In consequence, that means using these functions you can compare strings and arrays regardless of their respective maximum capacity and still get the naturally expected result. The and comparisons on the other hand look at the memory’s internal representation.\n\nAn array’s base type can be any data type,[fn 4] even another array. If we want to declare an “array of arrays” there is a short syntax for that:\n\nThis has already been described above. The last line is identical to:\n\nIt can be expanded to two separate declarations allowing us to “re-use” the “inner” array data type:\n\nNote that in the latter case uses as the base type which is an array by itself. Yet in the short notation we specify as the base type, not a but its base type.\n\nWhen an array was declared to contain another array, there is a short notation for accessing individual array items, too:\n\nThis corresponds to the array’s declaration. It is vital to ensure the indices you are specifying are indeed valid. In the latter loop the branch checks for that. Attempting to access non-existent array values, i. e. by supplying illegal indices, may crash the program, or worse remain undetected thus causing difficult to find mistakes.\n\nNote, the “unusual” order of and has been chosen to facilitate drawing an upright graph:\n\nThat means, it is still possible to refer to entire “sub”-arrays as a whole. You are not forced to write all dimension an array value has, given it makes sense.\n\nArray data types that have exactly two dimensions are also called matrices, singular matrix.\n\nAs introduced in one of the first chapters the data type is part of the Pascal programming language. It is used to store integer values in combination with an optional fractional part.\n\nIn order to distinguish literals from literals, specifying values in your source code (and also for / ) differs slightly. The following source code excerpt shows some literals:\n• A value literal always contains either a as a radix mark, or an / to separate an exponent (the in ), or both.\n• There is at least one Western-Arabic decimal digit before and one after the (if there is any).\n• The entire number and exponent are preceded by signs, yet a positive sign is optional.\n\nAs it has always been, all number values cannot contain spaces.\n\nThe data type has many limitations you have to be aware of in order to effectively use it. First of all, we want to re-emphasize an issue that was mentioned when data types were introduced: In computing variables can only store a subset of rational numbers (ℚ).[2] That means, for example, you cannot store the (mathematically speaking) real number (ℝ) . This number is an irrational number (i. e. not a rational number). If you cannot write a number as a finite literal, it is impossible to store it in a system using a finite amount of memory, such as computer systems do.\n\nFortunately, in three constants aide your usage of values. is the smallest positive value. It conjunction with the constant , it is guaranteed that all arithmetic operations in produce, quote, reasonable approximations.[3] It is not specified what exactly constitutes a “reasonable” approximation, thus it can, for example, mean that yields as “an approximation” .[fn 5] Also, it is quite possible that variables can store larger values than .\n\nis short for “epsilon ”. The small Greek letter ε (epsilon) frequently denotes in mathematics an infinitely small (positive) value, yet not zero. According to the standard 10206 (“Extended Pascal”), is the result of subtracting from the smallest value that is greater than .[3] No other value can be represented between this value and , thus represents the highest precision available, but just at that point.[fn 6] Most implementations of the data type will show a significantly varying degree of precision. Most notable, the precision of data type implementations complying with the standard 754 format, decays toward the extremes, when approaching (and going beyond) and . Therefore you usually use, if at all, a reasonable multiple of that fits the given situation.\n\nPascal’s strong typing system prevents you from assigning values to variables. The value may contain a fractional part that an variable cannot store.\n\nPascal defines, as part of the language, two standard functions addressing this issue in a well-defined manner.\n• The function , short for “truncation”, simply discards any fractional part and returns, as an , the integer part. As a consequence this is effectively rounding a number toward zero. will return the value .\n• If this feels “unnatural”, the function rounds a number to its closest value. is (regarding the resulting value) equivalent to for non-negative values, and equivalent to for negative values. fn 7 In other words, this is what you were probably taught in grade school, or the first rounding method you learned in homeschooling. It is commonly referred to as “commercial rounding”.\n\nBoth functions will fail if there is no such value fulfilling the function’s respective definition.\n\nThere is no function if you want to (explicitly) “transfer” an value to a value. Instead, one uses arithmetically neutral operations:\n\nThese expressions make use of the fact, as it was mentioned earlier as a passing remark in the chapter on expressions, that the expression’s overall data type will become as soon as one value is involved.[4]\n\nWhile this style is very universal, it may also be unusual for some readers. Particularly the notation is something now rather archaic, usually only seen on pocket calculators, i. e. devices lacking of enough display space.\n\nLuckily, / allow us to customize the displayed style.\n\nThe procedures / accept for type values (and only for values) another colon-separated format specifier. This second number determines the (exact) number of post-decimal digits, the “fraction part”. Supplying two format specifiers also disables scientific notation. All values are printed using regular positional notation. That may mean for “large” numbers such as printing a one followed by a hundred zeros (just for the integer part).\n\nIn some regions and languages it is customary to use a (comma) or other character instead of a dot as a radix mark. Pascal’s on-board / procedures will, on the other hand, always print a dot, and for that matter – / will always accept dots as radix marks only. Nevertheless, all current Pascal programming suites, Delphi, and provide appropriate utilities to overcome this restriction. For further details we refer to their manuals. This issue should not keep us from continuing learning Pascal.\n\nFirst of all, all (arithmetic) comparison operators do work with values. The operators and , though, are particularly tricky to handle.\n\nIn most applications you do not compare values to each other when checking for equality or inequality. The problem is that numbers such as ⅓ cannot be stored exactly with a finite series of binary digits, only approximated, yet there is not one valid approximation for ⅓ but many legit ones. The and operators, however, compare – so to speak — for specific bit patterns. This is usually not desired (for values that cannot be represented exactly). Instead, you want to ensure the values you are comparing are within a certain range, like:\n\nDelphi and the ’s standard provide the function as part of the unit. You do not want to program something other people already have programmed for you, i. e. use the resources.\n\nNow that we know the data type used for storing (a subset of) rational numbers, in Pascal known as , we can perform and use the result of another arithmetic operation: The division.\n• The operator performs an integer division and discards, if applicable, any remainder. The expression’s resulting data type is always . The operator only works if both operands are expressions.\n• The, probably more familiar, operator (a forward slash), divides the number (the dividend) by the number (the divisor), too, but a -division always yields a type value. 4 This is also the case if the fractional part is zero. A “remainder” does not exist for the operation.\n\nThe operation can be put in terms of :\n\nHowever, this is only a semantic equivalent,[fn 9] it is not how it is actually calculated. The reason is, the operator would first convert both operands to values and since, as explained above, not all values can necessarily be represented exactly as values, this would produce results potentially suffering from rounding imprecisions. The operator on the other hand is a pure operator and works with “integer precision”, that means no rounding is involved in actually calculating the result.\n\nNote, since there is no generally accepted definition for division by zero, a zero divisor is illegal and will result in your program to abort. If your divisor is not a constant and depends on run-time data (such as a variable read from user input), you should check that it is non-zero before doing a division:\n\nAlternatively, you can declare data types excluding zero, so any assignment of a zero value will be detected:\n\nSome Pascal dialects introduce the concept of “exceptions” that can be used to identify such problems. Exceptions may be mentioned again in the “Extensions” part of this Wikibook.\n\nArrays can be copied with one simple assignment . This requires, however, as it is customary with Pascal’s strong type safety, that both arrays are assignment-compatible: That means their base type and dimension specifications are the same.[fn 10]\n\nBecause calling a routine involves invisible assignments, writing general-purpose code dealing with lots of different situations would be virtually impossible if the entire program had to use one array type only. In order to mitigate this situation, conformant array type parameters allow writing routines accepting differing array dimension lengths. Array dimension data types still have to match.\n\nLet’s look at an example program using this feature:\n\nA conformant-array parameter looks pretty similar to a regular array variable declaration, but the dimensions are specified differently. Usually, when declaring new arrays you provide constant values as dimension limits. Since we do not want constants, though, we name placeholder identifiers for the actual dimension limits of any array will receive. In this case they are named and , joined by inbetween indicating a range.\n\nand become variables inside the definition of , but you are not allowed to assign any values to them.[fn 11] You are not allowed to declare new identifiers bearing the same name as the array boundary variables.\n\nIn Pascal all constants implicitly have an unambiguously determinable data type. Since our array limit identifiers are in fact variables they require a data type. The indicates both and have the data type .\n\nOnce we have declared and defined we can use it with lots of differently sized arrays:\n\nDelphi and the (as of version 3.2.0 released in 2020) do not support conformant-array parameters, but the does.\n\nPrior the 21st century logarithm tables and slide rules were heavily utilized tools in manual calculations, so much so it led to the inclusion of two basic functions in Pascal.\n• The function exponentiates a number to the base , Euler’s constant. The value of is equivalent to the mathematical term .\n• The function , short for Latin “logaritmus naturalis”, takes the natural logarithm of a positive number. “Natural” refers to again.\n\nSince the use of logarithms is not necessarily taught in all curricula, or you might just need a refresher, here is a short primer: The basic idea of logarithms is that all operations are lifted one level.\n\nOn the lifted level many operations become simpler, especially if the numbers are large. For instance, you can perform a rather easy addition if you actually mean to take the product of two numbers. For this you have to “lift” all operands one level up: This is done by taking the logarithm. Pay particular attention to : On the logarithm level is a non-“logarithmized” factor, you only take the logarithm of\n\nOnce you are done, you have descend one level again to get the actual “real” result of the intended operation (on the underlying level). The reverse operation of is .[fn 12] To put this principle in Pascal terms:\n\nRemember, and have to be positive in order to be valid parameters to .\n\nTaking the logarithm and then exponentiating values again are considered “slow” operations and introduce a certain overhead. In programming, overhead means taking steps that are not directly related to the actual underlying problem, but only facilitate solving it. In general, overhead is avoided, since (at first) it takes us even farther away from the solution.\n\nAs you can see, this goes to the detriment of precision. It is a compromise between fast operations, and “accurate enough” results.\n\nThe best solution is, of course, finding a better algorithm. The above demonstration is effectively , that is (remember, squaring a number always yields a non-negative number). This operation’s result will stay in the range of .\n\nAll tasks, including those in the following chapters, can be solved without conformant-array parameters. This takes account of the fact that not all major compilers support them.[fn 13] Nonetheless, using routines with conformant-array parameters are often the most elegant solution.\n\n\n\n More tasks you can solve can be found on the following Wikibook pages:"
    },
    {
        "link": "https://tutorialspoint.com/pascal/pascal_quick_guide.htm",
        "document": "Pascal is a general-purpose, high-level language that was originally developed by Niklaus Wirth in the early 1970s. It was developed for teaching programming as a systematic discipline and to develop reliable and efficient programs.\n\nPascal is Algol-based language and includes many constructs of Algol. Algol 60 is a subset of Pascal. Pascal offers several data types and programming structures. It is easy to understand and maintain the Pascal programs.\n\nPascal has grown in popularity in the teaching and academics arena for various reasons:\n• It can be compiled on a variety of computer platforms.\n\nPascal has the following features −\n• It offers several data types like arrays, records, files and sets.\n• It supports structured programming through functions and procedures.\n• None The Pascal language was named for Blaise Pascal, French mathematician and pioneer in computer development.\n• None Niklaus Wirth completed development of the original Pascal programming language in 1970.\n• None Pascal is based on the block structured style of the Algol programming language.\n• None Pascal was developed as a language suitable for teaching programming as a systematic discipline, whose implementations could be both reliable and efficient.\n• None The ISO 7185 Pascal Standard was originally published in 1983.\n• None Pascal was the primary high-level language used for development in the Apple Lisa, and in the early years of the Mac.\n• None In 1986, Apple Computer released the first Object Pascal implementation, and in 1993, the Pascal Standards Committee published an Object-Oriented Extension to Pascal.\n\nWhy to use Pascal?\n\nPascal allows the programmers to define complex structured data types and build dynamic and recursive data structures, such as lists, trees and graphs. Pascal offers features like records, enumerations, subranges, dynamically allocated variables with associated pointers and sets.\n\nPascal allows nested procedure definitions to any level of depth. This truly provides a great programming environment for learning programming as a systematic discipline based on the fundamental concepts.\n\nAmong the most amazing implementations of Pascal are −\n\nThere are several Pascal compilers and interpreters available for general use. Among these are −\n• None Turbo Pascal − provides an IDE and compiler for running Pascal programs on CP/M, CP/M-86, DOS, Windows and Macintosh.\n• None Delphi − provides compilers for running Object Pascal and generates native code for 32- and 64-bit Windows operating systems, as well as 32-bit Mac OS X and iOS. Embarcadero is planning to build support for the Linux and Android operating system.\n• None Free Pascal − it is a free compiler for running Pascal and Object Pascal programs. Free Pascal compiler is a 32- and 64-bit Turbo Pascal and Delphi compatible Pascal compiler for Linux, Windows, OS/2, FreeBSD, Mac OS X, DOS and several other platforms.\n• None Turbo51 − It is a free Pascal compiler for the 8051 family of microcontrollers, with Turbo Pascal 7 syntax.\n• None Oxygene − It is an Object Pascal compiler for the .NET and Mono platforms.\n• None GNU Pascal (GPC) − It is a Pascal compiler composed of a front end to GNU Compiler Collection.\n\nWe will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: Download Free Pascal\n\nThe Linux distribution of Free Pascal comes in three forms −\n• None a tar.gz version, also available as separate files.\n\nWhere X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).\n\nInstallation code for the Debian version (like Ubuntu) −\n\nWhere XXX is the version number of the .deb file.\n\nIf you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.\n\nFor Windows, you will download the Windows installer, setup.exe. This is a usual installation program. You need to take the following steps for installation −\n• None Select parts of the package you want to install.\n• None Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.\n\nThis will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.\n\nName and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux or UNIX.\n\nThe files you create with your editor are called source files and contain program source code. The source files for Pascal programs are typically named with the extension .pas.\n\nBefore starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.\n\nBefore we study basic building blocks of the Pascal programming language, let us look a bare minimum Pascal program structure so that we can take it as a reference in upcoming chapters.\n\nA Pascal program basically consists of the following parts −\n• Statements and Expressions within each block\n\nEvery pascal program generally has a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program −\n\nFollowing is a simple pascal code that would print the words \"Hello, World!\" −\n\nThis will produce following result −\n\nLet us look various parts of the above program −\n• None The first line of the program program HelloWorld; indicates the name of the program.\n• None The second line of the program uses crt; is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.\n• None The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a begin statement and an end statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;).\n• None The begin statement of the main program block is where the program execution begins.\n• None The lines within (*...*) will be ignored by the compiler and it has been put to add a comment in the program.\n• None The statement writeln('Hello, World!'); uses the writeln function available in Pascal which causes the message \"Hello, World!\" to be displayed on the screen.\n• None The statement readkey; allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.\n• None The last statement end. ends your program.\n• None Open a command prompt and go to the directory, where you saved the file.\n• None Type fpc hello.pas at command prompt and press enter to compile your code.\n• None If there are no errors in your code, the command prompt will take you to the next line and would generate hello executable file and hello.o object file.\n• None Now, type hello at command prompt to execute your program.\n• None You will be able to see \"Hello World\" printed on the screen and program waits till you press any key.\n\nMake sure that free pascal compiler fpc is in your path and that you are running it in the directory containing source file hello.pas.\n\nYou have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.\n\nA variable definition is put in a block beginning with a var keyword, followed by definitions of the variables as follows:\n\nPascal variables are declared outside the code-body of the function which means they are not declared within the begin and end pairs, but they are declared after the definition of the procedure/function and before the begin keyword. For global variables, they are defined after the program header.\n\nIn Pascal, a procedure is set of instructions to be executed, with no return value and a function is a procedure with a return value. The definition of function/procedures will be as follows −\n\nThe multiline comments are enclosed within curly brackets and asterisks as (* ... *). Pascal allows single-line comment enclosed within curly brackets { ... }.\n\nPascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.\n\nPascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.\n\nThe statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.\n\nFollowing is a list of reserved words available in Pascal.\n\nThe entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier. An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.\n\nData types of an entity indicates the meaning, constraints, possible values, operations, functions and mode of storage associated with it.\n\nInteger, real, Boolean and character types are referred as standard data types. Data types can be categorized as scalar, pointer and structured data types. Examples of scalar data types are integer, real, Boolean, character, subrange and enumerated. Structured data types are made of the scalar types; for example, arrays, records, files and sets. We will discuss the pointer data types later.\n\nPascal data types can be summarized as below in the following diagram −\n\nThe type declaration is used to declare the data type of an identifier. Syntax of type declaration is −\n\nFor example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.\n\nFollowing table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal −\n\nUse of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows numerical, logical, string and character constants. Constants can be declared in the declaration part of the program by specifying the const declaration.\n\nSyntax of constant type declaration is follows −\n\nFollowing are some examples of constant declarations −\n\nAll constant declarations must be given before the variable declaration.\n\nEnumerated data types are user-defined data types. They allow values to be specified in a list. Only assignment operators and relational operators are permitted on enumerated data type. Enumerated data types can be declared as follows −\n\nFollowing are some examples of enumerated type declarations −\n\nThe order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.\n\nSubrange types allow a variable to assume values that lie within a certain range. For example, if the age of voters should lie between 18 to 100 years, a variable named age could be declared as −\n\nWe will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows −\n\nFollowing are some examples of subrange type declarations −\n\nSubrange types can be created from a subset of an already defined enumerated type, For example −\n\nA variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Pascal has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.\n\nThe name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Pascal is not case-sensitive, so uppercase and lowercase letters mean same here. Based on the basic types explained in previous chapter, there will be following basic variable types −\n\nPascal programming language also allows defining various other types of variables, which we will cover in subsequent chapters like Pointer, Array, Records, Sets, and Files, etc. For this chapter, let us study only basic variable types.\n\nAll variables must be declared before we use them in Pascal program. All variable declarations are followed by the var keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is −\n\nHere, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here −\n\nIn the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,\n\nNow, the types so defined can be used in variable declarations −\n\nPlease note the difference between type declaration and var declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare type declaration in Pascal with typedef in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.\n\nVariables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is −\n\nBy default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the var keyword and the syntax of initialization is as follows −\n\nLet us look at an example, which makes use of various types of variables discussed so far −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as −\n\nWhen you have declared an enumerated type, you can declare variables of that type. For example,\n\nThe following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nThe following program illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared −\n• Pointer types (but the only allowed value is Nil).\n\nSyntax for declaring constants is as follows −\n\nThe following table provides examples of some valid constant declarations −\n\nThe following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nObserve the formatting in the output statement of the program. The variable c is to be formatted with total number of digits 7 and 2 digits after the decimal sign. Pascal allows such output formatting with the numerical variables.\n\nAn operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Pascal allows the following types of operators −\n\nLet us discuss the arithmetic, relational, Boolean and bit operators one by one. We will discuss the set operators and string operations later.\n\nFollowing table shows all the arithmetic operators supported by Pascal. Assume variable A holds 10 and variable B holds 20, then −\n\nFollowing table shows all the relational operators supported by Pascal. Assume variable A holds 10 and variable B holds 20, then −\n\nFollowing table shows all the Boolean operators supported by Pascal language. All these operators work on Boolean operands and produce Boolean results. Assume variable A holds true and variable B holds false, then −\n\nBitwise operators work on bits and perform bit-by-bit operation. All these operators work on integer operands and produces integer results. The truth table for bitwise and (&), bitwise or (|), and bitwise not (~) are as follows −\n\nAssume if A = 60; and B = 13; now in binary format they will be as follows −\n\nThe Bitwise operators supported by Pascal are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:\n\nPlease note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators −\n\nOperator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.\n\nFor example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.\n\nHere, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.\n\nDecision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.\n\nFollowing is the general form of a typical decision making structure found in most of the programming languages −\n\nPascal programming language provides the following types of decision making statements. Click the following links to check their detail.\n\nThere may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.\n\nProgramming languages provide various control structures that allow for more complicated execution paths.\n\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −\n\nPascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.\n\nLoop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\n\nPascal supports the following control statements. Click the following links to check their details.\n\nA subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design.' A subprogram can be invoked by a subprogram/program, which is called the calling program.\n\nPascal provides two kinds of subprograms −\n• None Procedures − these subprograms do not return a value directly.\n\nA function is a group of statements that together perform a task. Every Pascal program has at least one function, which is the program itself, and all the most trivial programs can define additional functions.\n\nA function declaration tells the compiler about a function's name, return type, and parameters. A function definition provides the actual body of the function.\n\nPascal standard library provides numerous built-in functions that your program can call. For example, function AppendStr() appends two strings, function New() dynamically allocates memory to variables and many more functions.\n\nIn Pascal, a function is defined using the function keyword. The general form of a function definition is as follows −\n\nA function definition in Pascal consists of a function header, local declarations and a function body. The function header consists of the keyword function and a name given to the function. Here are all the parts of a function −\n• None Arguments − The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type. The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.\n• None Return Type − All functions must return a value, so all functions must be assigned a type. The function-type is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.\n• None Local declarations − Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.\n• None Function Body − The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end. It is the part of a function where all computations are done. There must be an assignment statement of the type - name := expression; in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.\n\nFollowing is an example showing how to define a function in pascal −\n\nA function declaration tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.\n\nA function declaration has the following parts −\n\nFor the above-defined function max(), following is the function declaration −\n\nFunction declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.\n\nWhile creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.\n\nTo call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nProcedures are subprograms that, instead of returning a single value, allow to obtain a group of results.\n\nIn Pascal, a procedure is defined using the procedure keyword. The general form of a procedure definition is as follows −\n\nA procedure definition in Pascal consists of a header, local declarations and a body of the procedure. The procedure header consists of the keyword procedure and a name given to the procedure. Here are all the parts of a procedure −\n• None Arguments − The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.\n• None Local declarations − Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.\n• None Procedure Body − The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.\n\nFollowing is the source code for a procedure called findMin(). This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by reference (we will discuss passing arguments by reference a little later) −\n\nA procedure declaration tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.\n\nA procedure declaration has the following syntax −\n\nPlease note that the name of the procedure is not associated with any type. For the above defined procedure findMin(), following is the declaration −\n\nWhile creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.\n\nTo call a procedure, you simply need to pass the required parameters along with the procedure name as shown below −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nWe have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.\n\nTo illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as −\n\nThe following program calculates the factorial of a given number by calling itself recursively.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFollowing is another example, which generates the Fibonacci Series for a given number using a recursive function −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIf a subprogram (function or procedure) is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the formal parameters of the subprogram.\n\nThe formal parameters behave like other local variables inside the subprogram and are created upon entry into the subprogram and destroyed upon exit.\n\nWhile calling a subprogram, there are two ways that arguments can be passed to the subprogram −\n\nBy default, Pascal uses call by value to pass arguments. In general, this means that code within a subprogram cannot alter the arguments used to call the subprogram. The example program we used in the chapter 'Pascal - Functions' called the function named max() using call by value.\n\nWhereas, the example program provided here (exProcedure) calls the procedure findMin() using call by reference.\n\nA scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places, where variables can be declared in Pascal programming language −\n• None Inside a subprogram or a block which is called local variables\n• None Outside of all subprograms which is called global variables\n• None In the definition of subprogram parameters which is called formal parameters\n\nLet us explain what are local and global variables and formal parameters.\n\nVariables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here, all the variables a, b and c are local to program named exLocal.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nNow, let us extend the program little more, let us create a procedure named display, which will have its own set of variables a, b and c and display their values, right from the program exLocal.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nGlobal variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.\n\nA global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using global and local variables −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPlease note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.\n\nLet us change the previous example a little, now the local variables for the procedure display has same names as a, b, c −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nThe string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more common types of strings used in programs.\n\nYou can define a string in many ways −\n• None Character arrays − This is a character string which is a sequence of zero or more byte-sized characters enclosed in single quotes.\n• None String variables − The variable of String type, as defined in Turbo Pascal.\n• None Short strings − The variable of String type with size specification.\n• None AnsiStrings − Ansistrings are strings that have no length limit.\n\nPascal provides only one string operator, string concatenation operator (+).\n\nThe following program prints first four kinds of strings. We will use AnsiStrings in the next example.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFollowing example makes use of few more functions, let's see −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal supports a wide range of functions and procedures that manipulate strings. These subprograms vary implement-wise. Here, we are listing various string manipulating subprograms provided by Free Pascal −\n\nPascal provides data type Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions, etc.\n\nBoolean values are basically integer type. Boolean type variables have two pre-defined possible values True and False. The expressions resolving to a Boolean value can also be assigned to a Boolean type.\n\nFree Pascal also supports the ByteBool, WordBool and LongBool types. These are of type Byte, Word or Longint, respectively.\n\nThe value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value. A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.\n\nIt should be noted that logical operators and, or and not are defined for Boolean data types.\n\nA variable of Boolean type is declared using the var keyword.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n\nInstead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.\n\nAll arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.\n\nPlease note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.\n\nTo declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.\n\nThe general form of type declaration of one-dimensional array is −\n• None array-identifier − indicates the name of the array type.\n• None index-type − specifies the subscript of the array; it can be any scalar data type except real\n• None element-type − specifies the types of values that are going to be stored\n\nNow, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.\n\nTo start the array from 0 index, the declaration would be −\n\nIn Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.\n\nLet us take up another example where the subscript is of character type −\n\nSubscript could be of enumerated type −\n\nIn Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.\n\nAn element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example −\n\nThe above statement will take the first element from the array named alphabet and assign the value to the variable a.\n\nFollowing is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nArrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer −\n\nPointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Pascal programmer. Let's start learning them in simple and easy steps.\n\nAs you know, every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.\n\nA pointer is a dynamic variable, whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is −\n\nThe pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type. The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the var declaration to declare pointer variables.\n\nFollowing are some valid pointer declarations −\n\nThe pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer rptr, is rptr^. It can be accessed as −\n\nThe following example will illustrate this concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIn Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.\n\nLet us extend the above example to print the memory address stored in the pointer iptr −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIt is always a good practice to assign a NIL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NIL points to nowhere. Consider the following program −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nTo check for a nil pointer you can use an if statement as follows −\n\nPointers have many but easy concepts and they are very important to Pascal programming. There are following few important pointer concepts, which should be clear to a Pascal programmer −\n\nPascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user-defined data type available in Pascal which allows you to combine data items of different kinds.\n\nRecords consist of different fields. Suppose you want to keep track of your books in a library, you might want to track the following attributes about each book −\n\nTo define a record type, you may use the type declaration statement. The record type is defined as −\n\nHere is the way you would declare the Book record −\n\nThe record variables are defined in the usual way as\n\nAlternatively, you can directly define a record type variable as −\n\nTo access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou can define pointers to records in very similar way as you define pointer to any other variable as follows −\n\nNow, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword −\n\nBefore using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.\n\nTo access the members of a record using a pointer to that record, you must use the ^. operator as follows −\n\nFinally, don't forget to dispose the used storage, when it is no longer in use −\n\nLet us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nWe have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The With statement provides an alternative way to do that.\n\nLook at the following code snippet taken from our first example −\n\nThe same assignment could be written using the With statement as −\n\nPascal supports a unique type of storage named variants. You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime. Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.\n\nStructured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant. You can also assign a pointer to a variant.\n\nYou can declare variant type like any other types using the var keyword. The syntax for declaring a variant type is −\n\nNow, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.\n\nThe following example would illustrate the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within braces{}. However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.\n\nVariables of set type are defined as\n\nExamples of some valid set type declaration are −\n\nYou can perform the following set operations on Pascal sets.\n\nFollowing table shows all the set operators supported by Free Pascal. Assume that S1 and S2 are two character sets, such that −\n\nThe following example illustrates the use of some of these operators −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal treats a file as a sequence of components, which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as −\n\nWhere, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the var declaration −\n\nFollowing are some examples of defining some file types and file variables −\n\nLet us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it −\n\nWhen compiled and run, the program would create a file named students.dat into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.\n\nWe have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.\n\nPlease note that, if you use a file parameter with subprograms, it must be declared as a var parameter.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nA text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as −\n\nDifference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nAppending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nFree Pascal provides the following functions/procedures for file handling −\n\nThis chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.\n\nWhile doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows −\n\nBut now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic. Here, we need to define a pointer to string without defining how much memory is required.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nNow, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the getmem function or the getmem procedure, which has the following syntax −\n\nIn the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, getmem subprogram allows specifying that. Let us rewrite the previous example, using getmem −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nSo, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.\n\nWhen your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.\n\nPascal provides the procedure dispose to free a dynamically created variable using the procedure new. If you have allocated memory using the getmem subprogram, then you need to use the subprogram freemem to free this memory. The freemem subprograms have the following syntax −\n\nAlternatively, you can increase or decrease the size of an allocated memory block by calling the function ReAllocMem. Let us check the above program once again and make use of ReAllocMem and freemem subprograms. Following is the syntax for ReAllocMem −\n\nFollowing is an example which makes use of ReAllocMem and freemem subprograms −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management −\n\nA Pascal program can consist of modules called units. A unit might consist of some code blocks, which in turn are made up of variables and type declarations, statements, procedures, etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.\n\nBoth the built-in units and user-defined units are included in a program by the uses clause. We have already used the variants unit in Pascal - Variants tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit crt in your program −\n\nThe following example illustrates using the crt unit −\n\nIt is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.\n\nTo create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with .pas extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example −\n\nFollowing are three important steps in creating a Pascal unit −\n• None The name of the file and the name of the unit should be exactly same. So, our unit calculateArea will be saved in a file named calculateArea.pas.\n• None The next line should consist of a single keyword interface. After this line, you will write the declarations for all the functions and procedures that will come in this unit.\n• None Right after the function declarations, write the word implementation, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.\n\nThe following program creates the unit named calculateArea −\n\nNext, let us write a simple program that would use the unit we defined above −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nMost of the softwares you write need implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers.\n\nPascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nThe Date function returns the current date in TDateTime format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nThe Now function returns the current date and time −\n\nWhen the above code was compiled and executed, it produces the following result −\n\nFree Pascal provides a simple time stamp structure named TTimeStamp, which has the following format −\n\nFree Pascal provides the following date and time functions −\n\nThe following example illustrates the use of some of the above functions −\n\nWhen the above code was compiled and executed, it produced the following result:\n\nWe can imagine our universe made of different objects like sun, earth, moon, etc. Similarly, we can imagine our car made of different objects like wheel, steering, gear, etc. Same way, there are object-oriented programming concepts, which assume everything as an object and implement a software using different objects. In Pascal, there are two structural data types used to implement a real world object −\n\nBefore we go in detail, let's define important Pascal terms related to Object-Oriented Pascal.\n• None Object − An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.\n• None Class − A Class is defined in almost the same way as an Object, but there is a difference in way they are created. The Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. It is a pointer to the object, not the object itself.\n• None Instantiation of a class − Instantiation means creating a variable of that class type. Since a class is just a pointer, when a variable of a class type is declared, there is memory allocated only for the pointer, not for the entire object. Only when it is instantiated using one of its constructors, memory is allocated for the object. Instances of a class are also called 'objects', but do not confuse them with Object Pascal Objects. In this tutorial, we will write 'Object' for Pascal Objects and 'object' for the conceptual object or class instance.\n• None Member Variables − These are the variables defined inside a Class or an Object.\n• None Member Functions − These are the functions or procedures defined inside a Class or an Object and are used to access object data.\n• None Visibility of Members − The members of an Object or Class are also called the fields. These fields have different visibilities. Visibility refers to accessibility of the members, i.e., exactly where these members will be accessible. Objects have three visibility levels: public, private and protected. Classes have five visibility types: public, private, strictly private, protected and published. We will discuss visibility in details.\n• None Inheritance − When a Class is defined by inheriting existing functionalities of a parent Class, then it is said to be inherited. Here child class will inherit all or few member functions and variables of a parent class. Objects can also be inherited.\n• None Parent Class − A Class that is inherited by another Class. This is also called a base class or super class.\n• None Child Class − A class that inherits from another class. This is also called a subclass or derived class.\n• None Polymorphism − This is an object-oriented concept where same function can be used for different purposes. For example, function name will remain same but it may take different number of arguments and can do different tasks. Pascal classes implement polymorphism. Objects do not implement polymorphism.\n• None Overloading − It is a type of polymorphism in which some or all of operators have different implementations depending on the types of their arguments. Similarly functions can also be overloaded with different implementation. Pascal classes implement overloading, but the Objects do not.\n• None Data Abstraction − Any representation of data in which the implementation details are hidden (abstracted).\n• None Encapsulation − Refers to a concept where we encapsulate all the data and member functions together to form an object.\n• None Constructor − Refers to a special type of function which will be called automatically whenever there is an object formation from a class or an Object.\n• None Destructor − Refers to a special type of function which will be called automatically whenever an Object or Class is deleted or goes out of scope.\n\nAn object is declared using the type declaration. The general form of an object declaration is as follows −\n\nLet us define a Rectangle Object that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.\n\nAfter creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.\n\nFollowing example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.\n\nFollowing is a complete example to show how to use objects in Pascal −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nVisibility indicates the accessibility of the object members. Pascal object members have three types of visibility −\n\nBy default, fields and methods of an object are public and are exported outside the current unit.\n\nConstructors are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.\n\nDestructors are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.\n\nFollowing example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nPascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named TableTop, which is inheriting from the Rectangle object.\n\nFollowing are the important points which should be noted down −\n• None The object Tabletop has inherited all the members of the Rectangle object.\n• None There is a draw method in TableTop also. When the draw method is called using a TableTop object, TableTop's draw gets invoked.\n• None There is an implicit instance named self that refers to the current instance of the object.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou have seen that Pascal Objects exhibit some characteristics of object-oriented paradigm. They implement encapsulation, data hiding and inheritance, but they also have limitations. For example, Pascal Objects do not take part in polymorphism. So classes are widely used to implement proper object-oriented behavior in a program, especially the GUI-based software.\n\nA Class is defined in almost the same way as an Object, but is a pointer to an Object rather than the Object itself. Technically, this means that the Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. In other words, when you declare a variable the object type, it will take up as much space on the stack as the size of the object, but when you declare a variable of the class type, it will always take the size of a pointer on the stack. The actual class data will be on the heap.\n\nA class is declared in the same way as an object, using the type declaration. The general form of a class declaration is as follows −\n\nIts worth to note following important points −\n• None Class definitions should come under the type declaration part of the program only.\n• None A class is defined using the class keyword.\n• None Fields are data items that exist in each instance of the class.\n• None Methods are declared within the definition of a class.\n• None There is a predefined constructor called Create in the Root class. Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.\n• None There is a predefined destructor called Destroy in the Root class. Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.\n\nLet us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.\n\nLet us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions −\n• None You will need to include the {$mode objfpc} directive for using the classes.\n• None You will need to include the {$m+} directive for using constructors.\n• None Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.\n\nHere is the complete example −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nVisibility indicates the accessibility of the class members. Pascal class members have five types of visibility −\n\nConstructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.\n\nPascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.\n\nFollowing example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nLike the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.\n\nPascal class definitions can optionally inherit from a parent class definition. The syntax is as follows −\n\nFollowing example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.\n\nWhen the above code is compiled and executed, it produces the following result −\n\nIts worth to note following important points −\n• None The members of the Books class have protected visibility.\n• None The Novels class has two constructors, so the overload operator is used for function overloading.\n• None The Books.Display procedure has been declared virtual, so that the same method from the Novels class can override it.\n• None The Novels.Create constructor calls the base class constructor using the inherited keyword.\n\nInterfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface −\n\nPlease note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.\n\nAn abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this −\n\nWhen inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.\n\nDeclaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept −\n\nWhen the above code is compiled and executed, it produces the following result −\n\nYou must use the directive {$static on} for using the static members."
    },
    {
        "link": "https://stackoverflow.com/questions/42519050/dynamic-array-in-turbo-pascal",
        "document": "As MartynA says, there is no dynamic array type in Turbo Pascal. You need to manually allocate memory using pointers, and be careful if you use rangechecks.\n\nwhere spillbytes is a constant for a small deduction because you can't use the whole 64k, see what the compiler accepts. (Probably this deduction is for heapmanager structures inside the 64k block)\n\nand a variable to it\n\nand you allocate nrelement elements using getmem;\n\nand optionally fill them with zero to initialize them:\n\nYou can access elements using\n\nto free them, use freemem using the exact opposite of the getmem line.\n\nWhich means you have to save the allocated number of elements somewhere. This was fixed/solved in Delphi and FPC.\n\nAlso keep in mind that you can't find bugs with rangechecking anymore.\n\nIf you want arrays larger than 64k, that is possible, but only with constraints, and it matters more which exact TP target (dos, dos-protected or Windows you use) I advise you to search for the online SWAG archive that has many examples. And of course I would recommend to go to FreePascal/Lazarus too where you can simply do:\n\nand be done with it without additional lines and forget about all of this nonsense."
    },
    {
        "link": "https://labs.cs.uregina.ca/cplusplus/Csyntax-files/pascal-htmls/pas-array.html",
        "document": ""
    },
    {
        "link": "https://studocu.com/row/document/taita-taveta-university/information-technology/programming-with-pascal-sample-programs/97788291",
        "document": "Write a Pascal program to calculate the area of circle\n\nLesson 2 Use of If Statement\n\nWrite a Pascal program to determine a larger number between tow numbers input at the"
    }
]