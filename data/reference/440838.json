[
    {
        "link": "https://pluralsight.com/resources/blog/cloud/conditions-in-bash-scripting-if-statements",
        "document": "\n• The first difference can be seen in the above example; when comparing strings, the double-bracket syntax features shell globbing. This means that an asterisk (\"*\") will expand to literally anything, just as you probably know from normal command-line usage. Therefore, if $stringvar contains the phrase \"string\" anywhere, the condition will return true. Other forms of shell globbing are allowed, too. If you'd like to match both \"String\" and \"string\", you could use the following syntax: Note that only general shell globbing is allowed. Bash-specific things like {1..4} or {foo,bar} will not work. Also note that the globbing will not work if you quote the right string. In this case you should leave it unquoted.\n• The second difference is that word splitting is prevented. Therefore, you could omit placing quotes around string variables and use a condition like the following without problems: Nevertheless, the quoting string variables remains a good habit, so I recommend just to keep doing it.\n• The third difference consists of not expanding filenames. I will illustrate this difference using two examples, starting with the old single-bracket situation: The above condition will return true if there is one single file in the working directory that has a .sh extension. If there are none, it will return false. If there are several .sh files, bash will throw an error and stop executing the script. This is because *.sh is expanded to the files in the working directory. Using double brackets prevents this: The above condition will return true only if there is a file in the working directory called \"*.sh\", no matter what other .sh files exist. The asterisk is taken literally, because the double-bracket syntax does not expand filenames.\n• The fourth difference is the addition of more generally known combining expressions, or, more specific, the operators \"&&\" and \"||\". Example: The above condition returns true if $num is equal to 3 and $stringvar is equal to \"foo\". The -a and -o known from the single-bracket syntax is supported, too.Note that the and operator has precedence over the or operator, meaning that \"&&\" or \"-a\" will be evaluated before \"||\" or \"-o\".\n• The fifth difference is that the double-bracket syntax allows regex pattern matching using the \"=~\" operator. See the table for more information."
    },
    {
        "link": "https://medium.com/@promisevector/bash-scripting-variables-conditionals-and-looping-5100198da227",
        "document": "In this episode of the series, we delve further into Bash scripting, focusing on the heart of scripting. Previously, we explored the powerful text editor, Vi IMproved (Vim), in the last episode, which you can access here. Now, let’s shift our attention to the core aspects of scripting in Bash.\n\nVariables in Bash are used to store values that can be manipulated and referenced throughout a script. They provide a way to store data temporarily or pass information between different parts of the script. Think of it as a container that you can use to store different types of data. Here’s how you can define and use variables in Bash:\n• They can consist of letters, digits, and underscores.\n• The first character must be a letter or an underscore.\n\nTo access variables in bash, you use the symbol to reference the name of the variable.\n\nConditionals allow you to make decisions based on certain conditions in your script. They enable you to execute different blocks of code depending on whether a specific condition is true or false. Bash provides various conditional statements, including , , and . Here's an example:\n\nNote: The conditions within square brackets ( ) are usually constructed using comparison operators, such as (equal), (not equal), (less than), (greater than), (less than or equal), and (greater than or equal).\n\nLooping structures allow you to repeat a certain block of code multiple times. Looping is repetition until something happens; imagine having to Bash provides several looping constructs, including , , and , which give you flexibility in iterating over lists, performing actions until a condition is met, or executing code while a condition is true. Let's explore each of these:\n• ‘for’ Loop: The for-loop is used when there is a set number of iterations before the condition is passed. In simpler terms, the loop has to continue until it has satisfied the condition a set number of times.\n\n2. ‘while’ loop: The while loop executes until the condition set returns true, then it terminates.\n\nA good example of a bash script that has a combination of all covered topics in this episode can be:\n\nMastering variables, conditionals, and looping structures is essential for effective Bash scripting. With variables, you can store and manipulate data, while conditionals enable you to make decisions and execute specific code blocks based on conditions. Looping structures provide the ability to repeat code blocks, iterating over lists or executing code until a condition is met. By combining these concepts, you can create powerful scripts to automate tasks, manage system configurations, and much more.\n\nAs you continue your journey with Bash scripting, remember to practice and experiment with different scenarios. The more you familiarize yourself with variables, conditionals, and looping structures, the more confident you will become in writing efficient and robust scripts."
    },
    {
        "link": "https://tldp.org/LDP/abs/abs-guide.pdf",
        "document": ""
    },
    {
        "link": "https://bjpcjp.github.io/pdfs/bash/bash-scripting.pdf",
        "document": ""
    },
    {
        "link": "https://guide.bash.academy",
        "document": "This guide is an introduction to basic and advanced concepts of the bash shell.\n\nIt teaches both newcomers and long-time users the best ways to write safe and robust bash scripts, and how to interact efficiently and speedily with the shell as a command line interface.\n\nThe primary author and maintainer of this guide is lhunath (Maarten Billemont).\n\nFor many years I've worked as a volunteer educator, attempting to assist users with their shell scripting problems. During that time I found that most of them held serious misconceptions about the shell, largely due to the the widespread publishing of naïve advice, poor practices, and often outright misinformation. I also found an acute lack of reliable, clear, and accessible information to improve their knowledge, and so I decided to write this guide.\n\nThis guide is open source, licensed under Creative Commons Attribution-ShareAlike 4.0 International License (CC-BY-SA). The source code is available at GitHub. Go there to report issues or fork the guide to contribute changes (big or small). To keep up to date with new chapters or improvements to this guide, you could star the GitHub project.\n\nFor advice, comments, suggestions, corrections or recommendations, contact lhunath, file an issue or visit the Libera.chat #bash community on IRC.\n\nThis guide has gone through several iterations and is a continuing active work in progress. New chapters are being written and existing chapters are continuously being updated and improved.\n\nIn writing this guide, I am sharing my knowledge and expertise with the world freely in the hopes of benefitting you and all others like you. If you've benefitted from the knowledge and experience gained through this guide, consider \"giving back\" to encourage a society of open access and freedom of information. You can give back by providing feedback on the guide at the GitHub project page, making corrections by hitting the edit buttons on the chapter pages, sharing this guide with any of your friends that have similar interests so that they too may learn as you have, or contributing financially in gratitude for my work, time and effort put into writing and maintaining this guide.\n\nAfter introducing new practical concepts, the guide offers a set of exercises to allow you to practice your new knowledge. For a summary of all exercises in this guide, see our exercises index.\n• Inceptionbeta: What is bash, and where does it live? An introduction to bash, installing and starting it; the terminal, the keyboard and the display; programs, processes and how their flow of information is connected.\n• Commands And Argumentsbeta: How do I give bash instructions? About what a command is, and how to issue them; interactive mode and scripts; command syntax, searching commands and programs by name; arguments and word splitting as well as input and output redirection.\n• Variables and Expansionsalpha: How do I store and work with data? Bash parameters and variables; environment variables, special parameters and array parameters; expanding parameters, expansion operators, command substitution and process substitution; pathname expansion, tilde expansion and brace expansion.\n• Tests And Conditionalsdraft: Different commands for different data. Exit codes, success and failure, testing files, strings and numbers, handling different conditions, conditional operators and conditional compound commands.\n• Loops And Functionstodo: Avoid repeating yourself. Iterating commands using for loops, while and until loops, select statements and grouping them in functions.\n• Asynchronous Commandstodo: Doing work in the background and managing jobs.\n• Colors And Terminal Commandstodo: Advanced control over the terminal display. Terminals and terminal sequences, terminal identifiers, terminfo and terminal capabilities, outputting colors, moving the cursor and querying the terminal's state.\n• Customizing The Prompttodo: Changing the look and feel of the interactive shell. Prompting, prompt commands and the DEBUG signal, readline, bind and input modes and hotkeys, programmatic command completion.\n• Advanced Topicstodo: About syntax sugar, specific use cases and shell tricks.\n• Recommendations And Pitfallstodo: How to do things well and how to do things very, very badly.\n• Noteworthy External Toolstodo: Bash is limited, but augmented by a powerful toolset."
    },
    {
        "link": "https://unix.stackexchange.com/questions/671780/how-to-avoid-use-of-rm-rf-in-bash-scripts",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://serverfault.com/questions/337082/how-do-i-prevent-accidental-rm-rf",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://serverfault.com/questions/199798/best-practices-to-prevent-rm-rf-in-bash-scripts",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/992737/safe-rm-rf-function-in-shell-script",
        "document": "This question is similar to What is the safest way to empty a directory in *nix?\n\nI'm writing bash script which defines several path constants and will use them for file and directory manipulation (copying, renaming and deleting). Often it will be necessary to do something like:\n\nWhile developing this script I'd want to protect myself from mistyping names like PATH1 and PATH2 and avoid situations where they are expanded to empty string, thus resulting in wiping whole disk. I decided to create special wrapper:\n\nWhich will be called as:\n\nRegex (or sed expression) should catch paths like \"*\", \"/*\", \"/**/\", \"///*\" etc. but allow paths like \"dir\", \"/dir\", \"/dir1/dir2/\", \"/dir1/dir2/*\". Also I don't know how to enable shell globbing in case like \"/dir with space/*\". Any ideas?\n\nEDIT: this is what I came up with so far:\n\nIntended use is (note an asterisk inside quotes):\n\nwhere $SOMEPATH is not system or /home directory (in my case all such operations are performed on filesystem mounted under /scratch directory).\n• not tested very well\n• not intended to use with paths possibly containing '..' or '.'\n• should not be used with user-supplied paths\n• rm -rf with asterisk probably can fail if there are too many files or directories inside $SOMEPATH (because of limited command line length) - this can be fixed with 'for' loop or 'find' command"
    },
    {
        "link": "https://superuser.com/questions/382407/best-practices-to-alias-the-rm-command-and-make-it-safer",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]