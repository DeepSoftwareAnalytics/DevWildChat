[
    {
        "link": "https://man7.org/linux/man-pages/man2/mmap.2.html",
        "document": "Pages that refer to this page: memusage(1), alloc_hugepages(2), arch_prctl(2), clone(2), execve(2), fcntl(2), fork(2), futex(2), get_mempolicy(2), getpagesize(2), getrlimit(2), ioctl_userfaultfd(2), io_uring_register(2), io_uring_setup(2), madvise(2), mbind(2), memfd_create(2), memfd_secret(2), mincore(2), mlock(2), mmap2(2), mprotect(2), mremap(2), msync(2), open(2), perf_event_open(2), personality(2), posix_fadvise(2), PR_SET_MM_ARG_START(2const), PR_SET_MM_START_CODE(2const), PR_SET_TAGGED_ADDR_CTRL(2const), readahead(2), remap_file_pages(2), seccomp(2), sendfile(2), set_mempolicy(2), shmget(2), shmop(2), statx(2), syscalls(2), UFFDIO_API(2const), uselib(2), userfaultfd(2), vfork(2), avc_init(3), avc_open(3), cap_launch(3), fopen(3), io_uring_queue_exit(3), io_uring_queue_init(3), io_uring_queue_init_mem(3), io_uring_queue_init_params(3), mallinfo(3), malloc(3), malloc_stats(3), mallopt(3), numa(3), off_t(3type), pthread_attr_setguardsize(3), pthread_attr_setstack(3), selinux_status_open(3), sem_init(3), shm_open(3), core(5), proc(5), proc_meminfo(5), proc_pid_map_files(5), proc_pid_maps(5), proc_sys_kernel(5), proc_sys_vm(5), systemd.exec(5), tmpfs(5), capabilities(7), fanotify(7), file-hierarchy(7), futex(7), inode(7), inotify(7), io_uring(7), pkeys(7), shm_overview(7), spufs(7), ld.so(8), netsniff-ng(8), setarch(8), trafgen(8), xfs_io(8)"
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/009604499/functions/mmap.html",
        "document": "The mmap() function shall establish a mapping between a process' address space and a file, shared memory object, or [TYM] typed memory object. The format of the call is as follows: The mmap() function shall establish a mapping between the address space of the process at an address pa for len bytes to the memory object represented by the file descriptor fildes at offset off for len bytes. The value of pa is an implementation-defined function of the parameter addr and the values of flags, further described below. A successful mmap() call shall return pa as its result. The address range starting at pa and continuing for len bytes shall be legitimate for the possible (not necessarily current) address space of the process. The range of bytes starting at off and continuing for len bytes shall be legitimate for the possible (not necessarily current) offsets in the file, shared memory object, or [TYM] typed memory object represented by fildes. [TYM] If fildes represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, the memory object to be mapped shall be that portion of the typed memory object allocated by the implementation as specified below. In this case, if off is non-zero, the behavior of mmap() is undefined. If fildes refers to a valid typed memory object that is not accessible from the calling process, mmap() shall fail. The mapping established by mmap() shall replace any previous mappings for those whole pages containing any part of the address space of the process starting at pa and continuing for len bytes. If the size of the mapped file changes after the call to mmap() as a result of some other operation on the mapped file, the effect of references to portions of the mapped region that correspond to added or removed portions of the file is unspecified. The mmap() function shall be supported for regular files, shared memory objects, and [TYM] typed memory objects. Support for any other type of file is unspecified. If len is zero, mmap() shall fail and no mapping shall be established. The parameter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot shall be either PROT_NONE or the bitwise-inclusive OR of one or more of the other flags in the following table, defined in the <sys/mman.h> header. If an implementation cannot support the combination of access types specified by prot, the call to mmap() shall fail. An implementation may permit accesses other than those specified by prot; [MPR] however, if the Memory Protection option is supported, the implementation shall not permit a write to succeed where PROT_WRITE has not been set or shall not permit any access where PROT_NONE alone has been set. The implementation shall support at least the following values of prot: PROT_NONE, PROT_READ, PROT_WRITE, and the bitwise-inclusive OR of PROT_READ and PROT_WRITE. If the Memory Protection option is not supported, the result of any access that conflicts with the specified protection is undefined. The file descriptor fildes shall have been opened with read permission, regardless of the protection options specified. If PROT_WRITE is specified, the application shall ensure that it has opened the file descriptor fildes with write permission unless MAP_PRIVATE is specified in the flags parameter as described below. The parameter flags provides other information about the handling of the mapped data. The value of flags is the bitwise-inclusive OR of these options, defined in <sys/mman.h>: Implementations that do not support the Memory Mapped Files option are not required to support MAP_PRIVATE. It is implementation-defined whether MAP_FIXED shall be supported. [XSI] MAP_FIXED shall be supported on XSI-conformant systems. MAP_SHARED and MAP_PRIVATE describe the disposition of write references to the memory object. If MAP_SHARED is specified, write references shall change the underlying object. If MAP_PRIVATE is specified, modifications to the mapped data by the calling process shall be visible only to the calling process and shall not change the underlying object. It is unspecified whether modifications to the underlying object done after the MAP_PRIVATE mapping is established are visible through the MAP_PRIVATE mapping. Either MAP_SHARED or MAP_PRIVATE can be specified, but not both. The mapping type is retained across fork(). [TYM] When fildes represents a typed memory object opened with either the POSIX_TYPED_MEM_ALLOCATE flag or the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, mmap() shall, if there are enough resources available, map len bytes allocated from the corresponding typed memory object which were not previously allocated to any process in any processor that may access that typed memory object. If there are not enough resources available, the function shall fail. If fildes represents a typed memory object opened with the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, these allocated bytes shall be contiguous within the typed memory object. If fildes represents a typed memory object opened with the POSIX_TYPED_MEM_ALLOCATE flag, these allocated bytes may be composed of non-contiguous fragments within the typed memory object. If fildes represents a typed memory object opened with neither the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag nor the POSIX_TYPED_MEM_ALLOCATE flag, len bytes starting at offset off within the typed memory object are mapped, exactly as when mapping a file or shared memory object. In this case, if two processes map an area of typed memory using the same off and len values and using file descriptors that refer to the same memory pool (either from the same port or from a different port), both processes shall map the same region of storage. When MAP_FIXED is set in the flags argument, the implementation is informed that the value of pa shall be addr, exactly. If MAP_FIXED is set, mmap() may return MAP_FAILED and set errno to [EINVAL]. If a MAP_FIXED request is successful, the mapping established by mmap() replaces any previous mappings for the process' pages in the range [pa,pa+len). When MAP_FIXED is not set, the implementation uses addr in an implementation-defined manner to arrive at pa. The pa so chosen shall be an area of the address space that the implementation deems suitable for a mapping of len bytes to the file. All implementations interpret an addr value of 0 as granting the implementation complete freedom in selecting pa, subject to constraints described below. A non-zero value of addr is taken to be a suggestion of a process address near which the mapping should be placed. When the implementation selects a value for pa, it never places a mapping at address 0, nor does it replace any extant mapping. The off argument is constrained to be aligned and sized according to the value returned by sysconf() when passed _SC_PAGESIZE or _SC_PAGE_SIZE. When MAP_FIXED is specified, the application shall ensure that the argument addr also meets these constraints. The implementation performs mapping operations over whole pages. Thus, while the argument len need not meet a size or alignment constraint, the implementation shall include, in any mapping operation, any partial page specified by the range [pa,pa+len). The system shall always zero-fill any partial page at the end of an object. Further, the system shall never write out any modified portions of the last page of an object which are beyond its end. [MPR] References within the address range starting at pa and continuing for len bytes to whole pages following the end of an object shall result in delivery of a SIGBUS signal. An implementation may generate SIGBUS signals when a reference would cause an error in the mapped object, such as out-of-space condition. The mmap() function shall add an extra reference to the file associated with the file descriptor fildes which is not removed by a subsequent close() on that file descriptor. This reference shall be removed when there are no more mappings to the file. The st_atime field of the mapped file may be marked for update at any time between the mmap() call and the corresponding munmap() call. The initial read or write reference to a mapped region shall cause the file's st_atime field to be marked for update if it has not already been marked for update. The st_ctime and st_mtime fields of a file that is mapped with MAP_SHARED and PROT_WRITE shall be marked for update at some point in the interval between a write reference to the mapped region and the next call to msync() with MS_ASYNC or MS_SYNC for that portion of the file by any process. If there is no such call and if the underlying file is modified as a result of a write reference, then these fields shall be marked for update at some time after the write reference. There may be implementation-defined limits on the number of memory regions that can be mapped (per process or per system). [XSI] If such a limit is imposed, whether the number of memory regions that can be mapped by a process is decreased by the use of shmat() is implementation-defined. If mmap() fails for reasons other than [EBADF], [EINVAL], or [ENOTSUP], some of the mappings in the address range starting at addr and continuing for len bytes may have been unmapped.\n\nThe following sections are informative.\n\nUse of mmap() may reduce the amount of memory available to other memory allocation functions. Use of MAP_FIXED may result in unspecified behavior in further use of malloc() and shmat(). The use of MAP_FIXED is discouraged, as it may prevent an implementation from making the most effective use of resources. The application must ensure correct synchronization when using mmap() in conjunction with any other file access method, such as read() and write(), standard input/output, and shmat(). The mmap() function allows access to resources via address space manipulations, instead of read()/ write(). Once a file is mapped, all a process has to do to access it is use the data at the address to which the file was mapped. So, using pseudo-code to illustrate the way in which an existing program might be changed to use mmap(), the following:\n\nAfter considering several other alternatives, it was decided to adopt the mmap() definition found in SVR4 for mapping memory objects into process address spaces. The SVR4 definition is minimal, in that it describes only what has been built, and what appears to be necessary for a general and portable mapping facility. Note that while mmap() was first designed for mapping files, it is actually a general-purpose mapping facility. It can be used to map any appropriate object, such as memory, files, devices, and so on, into the address space of a process. When a mapping is established, it is possible that the implementation may need to map more than is requested into the address space of the process because of hardware requirements. An application, however, cannot count on this behavior. Implementations that do not use a paged architecture may simply allocate a common memory region and return the address of it; such implementations probably do not allocate any more than is necessary. References past the end of the requested area are unspecified. If an application requests a mapping that would overlay existing mappings in the process, it might be desirable that an implementation detect this and inform the application. However, the default, portable (not MAP_FIXED) operation does not overlay existing mappings. On the other hand, if the program specifies a fixed address mapping (which requires some implementation knowledge to determine a suitable address, if the function is supported at all), then the program is presumed to be successfully managing its own address space and should be trusted when it asks to map over existing data structures. Furthermore, it is also desirable to make as few system calls as possible, and it might be considered onerous to require an munmap() before an mmap() to the same address range. This volume of IEEE Std 1003.1-2001 specifies that the new mappings replace any existing mappings, following existing practice in this regard. It is not expected, when the Memory Protection option is supported, that all hardware implementations are able to support all combinations of permissions at all addresses. When this option is supported, implementations are required to disallow write access to mappings without write permission and to disallow access to mappings without any access permission. Other than these restrictions, implementations may allow access types other than those requested by the application. For example, if the application requests only PROT_WRITE, the implementation may also allow read access. A call to mmap() fails if the implementation cannot support allowing all the access requested by the application. For example, some implementations cannot support a request for both write access and execute access simultaneously. All implementations supporting the Memory Protection option must support requests for no access, read access, write access, and both read and write access. Strictly conforming code must only rely on the required checks. These restrictions allow for portability across a wide range of hardware. The MAP_FIXED address treatment is likely to fail for non-page-aligned values and for certain architecture-dependent address ranges. Conforming implementations cannot count on being able to choose address values for MAP_FIXED without utilizing non-portable, implementation-defined knowledge. Nonetheless, MAP_FIXED is provided as a standard interface conforming to existing practice for utilizing such knowledge when it is available. Similarly, in order to allow implementations that do not support virtual addresses, support for directly specifying any mapping addresses via MAP_FIXED is not required and thus a conforming application may not count on it. The MAP_PRIVATE function can be implemented efficiently when memory protection hardware is available. When such hardware is not available, implementations can implement such \"mappings\" by simply making a real copy of the relevant data into process private memory, though this tends to behave similarly to read(). The function has been defined to allow for many different models of using shared memory. However, all uses are not equally portable across all machine architectures. In particular, the mmap() function allows the system as well as the application to specify the address at which to map a specific region of a memory object. The most portable way to use the function is always to let the system choose the address, specifying NULL as the value for the argument addr and not to specify MAP_FIXED. If it is intended that a particular region of a memory object be mapped at the same address in a group of processes (on machines where this is even possible), then MAP_FIXED can be used to pass in the desired mapping address. The system can still be used to choose the desired address if the first such mapping is made without specifying MAP_FIXED, and then the resulting mapping address can be passed to subsequent processes for them to pass in via MAP_FIXED. The availability of a specific address range cannot be guaranteed, in general. The mmap() function can be used to map a region of memory that is larger than the current size of the object. Memory access within the mapping but beyond the current end of the underlying objects may result in SIGBUS signals being sent to the process. The reason for this is that the size of the object can be manipulated by other processes and can change at any moment. The implementation should tell the application that a memory reference is outside the object where this can be detected; otherwise, written data may be lost and read data may not reflect actual data in the object. Note that references beyond the end of the object do not extend the object as the new end cannot be determined precisely by most virtual memory hardware. Instead, the size can be directly manipulated by ftruncate(). Process memory locking does apply to shared memory regions, and the MEMLOCK_FUTURE argument to mlockall() can be relied upon to cause new shared memory regions to be automatically locked. Existing implementations of mmap() return the value -1 when unsuccessful. Since the casting of this value to type void * cannot be guaranteed by the ISO C standard to be distinct from a successful value, this volume of IEEE Std 1003.1-2001 defines the symbol MAP_FAILED, which a conforming implementation does not return as the result of a successful call.\n\nThe mmap() function is marked as part of the Memory Mapped Files option. The Open Group Corrigendum U028/6 is applied, changing (void *)-1 to MAP_FAILED. The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:\n• The DESCRIPTION is updated to describe the use of MAP_FIXED.\n• The DESCRIPTION is updated to describe the addition of an extra reference to the file associated with the file descriptor passed to mmap().\n• The DESCRIPTION is updated to state that there may be implementation-defined limits on the number of memory regions that can be mapped.\n• The DESCRIPTION is updated to describe constraints on the alignment and size of the off argument.\n• The [EINVAL] and [EMFILE] error conditions are added.\n• The [EOVERFLOW] error condition is added. This change is to support large files. The following changes are made for alignment with the ISO POSIX-1:1996 standard:\n• The DESCRIPTION is updated to describe the cases when MAP_PRIVATE and MAP_FIXED need not be supported. The following changes are made for alignment with IEEE Std 1003.1j-2000:\n• Semantics for typed memory objects are added to the DESCRIPTION.\n• New [ENOMEM] and [ENXIO] errors are added to the ERRORS section.\n• The posix_typed_mem_open() function is added to the SEE ALSO section. The DESCRIPTION is updated to avoid use of the term \"must\" for application requirements. IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/34 is applied, changing the margin code in the SYNOPSIS from MF|SHM to MC3 (notation for MF|SHM|TYM). IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/60 is applied, updating the DESCRIPTION and ERRORS sections to add the [EINVAL] error when len is zero."
    },
    {
        "link": "https://gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html",
        "document": "On modern operating systems, it is possible to mmap (pronounced “em-map”) a file to a region of memory. When this is done, the file can be accessed just like an array in the program.\n\nThis is more efficient than or , as only the regions of the file that a program actually accesses are loaded. Accesses to not-yet-loaded parts of the mmapped region are handled in the same way as swapped out pages.\n\nSince mmapped pages can be stored back to their file when physical memory is low, it is possible to mmap files orders of magnitude larger than both the physical memory and swap space. The only limit is address space. The theoretical limit is 4GB on a 32-bit machine - however, the actual limit will be smaller since some areas will be reserved for other purposes. If the LFS interface is used the file size on 32-bit systems is not limited to 2GB (offsets are signed which reduces the addressable area of 4GB by half); the full 64-bit are available.\n\nMemory mapping only works on entire pages of memory. Thus, addresses for mapping must be page-aligned, and length values will be rounded up. To determine the default size of a page the machine uses one should use:\n\nOn some systems, mappings can use larger page sizes for certain files, and applications can request larger page sizes for anonymous mappings as well (see the flag below).\n\nThe following functions are declared in :\n\nThe function creates a new mapping, connected to bytes ( ) to ( + - 1) in the file open on . A new reference for the file specified by is created, which is not removed by closing the file. gives a preferred starting address for the mapping. expresses no preference. Any previous mapping at that address is automatically removed. The address you give may still be changed, unless you use the flag. contains flags that control what kind of access is permitted. They include , , and . The special flag reserves a region of address space for future use. The function can be used to change the protection flags. See Memory Protection. contains flags that control the nature of the map. One of or must be specified. This specifies that writes to the region should never be written back to the attached file. Instead, a copy is made for the process, and the region will be swapped normally if memory runs low. No other process will see the changes. Since private mappings effectively revert to ordinary memory when written to, you must have enough virtual memory for a copy of the entire mmapped region if you use this mode with . This specifies that writes to the region will be written back to the file. Changes made will be shared immediately with other processes mmaping the same file. Note that actual writing may take place at any time. You need to use , described below, if it is important that other processes using conventional I/O get a consistent view of the file. This forces the system to use the exact mapping address specified in and fail if it can’t. This flag tells the system to create an anonymous mapping, not connected to a file. and are ignored, and the region is initialized with zeros. Anonymous maps are used as the basic primitive to extend the heap on some systems. They are also useful to share data between multiple tasks without creating a file. On some systems using private anonymous mmaps is more efficient than using for large blocks. This is not an issue with the GNU C Library, as the included automatically uses where appropriate. This requests that the system uses an alternative page size which is larger than the default page size for the mapping. For some workloads, increasing the page size for large mappings improves performance because the system needs to handle far fewer pages. For other workloads which require frequent transfer of pages between storage or different nodes, the decreased page granularity may cause performance problems due to the increased page size and larger transfers. In order to create the mapping, the system needs physically contiguous memory of the size of the increased page size. As a result, mappings are affected by memory fragmentation, and their creation can fail even if plenty of memory is available in the system. Not all file systems support mappings with an increased page size. The flag is specific to Linux. returns the address of the new mapping, or for an error. Either was unusable (because it is not a multiple of the applicable page size), or inconsistent were given. If was specified, the file or system does not support large page sizes. was not open for the type of access specified in . Either there is not enough memory for the operation, or the process is out of address space. This file is of a type that doesn’t support mapping. The file is on a filesystem that doesn’t support mapping.\n\nThis function is only available on a few systems. Except for performing optional optimizations one should not rely on this function.\n\nNot all file descriptors may be mapped. Sockets, pipes, and most devices only allow sequential access and do not fit into the mapping abstraction. In addition, some regular files may not be mmapable, and older kernels may not support mapping at all. Thus, programs using should have a fallback method to use should it fail. See Mmap in .\n\nThis function can be used to provide the system with about the intended usage patterns of the memory region starting at and extending bytes. The valid BSD values for are: The region should receive no further special treatment. The region will be accessed via random page references. The kernel should page-in the minimal number of pages for each page fault. The region will be accessed via sequential page references. This may cause the kernel to aggressively read-ahead, expecting further sequential references after any page fault within this region. The region will be needed. The pages within this region may be pre-faulted in by the kernel. The region is no longer needed. The kernel may free these pages, causing any changes to the pages to be lost, as well as swapped out pages to be discarded. Indicate that it is beneficial to increase the page size for this mapping. This can improve performance for larger mappings because the system needs to handle far fewer pages. However, if parts of the mapping are frequently transferred between storage or different nodes, performance may suffer because individual transfers can become substantially larger due to the increased page size. This flag is specific to Linux. Undo the effect of a previous advice. This flag is specific to Linux. The POSIX names are slightly different, but with the same meanings: returns 0 for success and -1 for error. Errors include: An invalid region was given, or the was invalid. There is no existing mapping in at least part of the given region.\n\nThe function returns a file descriptor which can be used to create memory mappings using the function. It is similar to the function in the sense that these mappings are not backed by actual files. However, the descriptor returned by does not correspond to a named object; the argument is used for debugging purposes only (e.g., will appear in ), and separate invocations of with the same will not return descriptors for the same region of memory. The descriptor can also be used to create alias mappings within the same process. The descriptor initially refers to a zero-length file. Before mappings can be created which are backed by memory, the file size needs to be increased with the function. See File Size. The argument can be a combination of the following flags: The descriptor is created with the flag. The descriptor supports the addition of seals using the function. This requests that mappings created using the returned file descriptor use a larger page size. See above for details. This flag is incompatible with . returns a file descriptor on success, and -1 on failure. The following error conditions are defined for this function: An invalid combination is specified in , or is too long. The argument does not point to a string. The operation would exceed the file descriptor limit for this process. The operation would exceed the system-wide file descriptor limit. There is not enough memory for the operation."
    },
    {
        "link": "https://gnu.org/s/libc/manual/pdf/libc.pdf",
        "document": ""
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/7908799/xsh/mmap.html",
        "document": "The mmap() function establishes a mapping between the address space of the process at an address pa for len bytes to the memory object represented by the file descriptor fildes at offset off for len bytes. The value of pa is an implementation-dependent function of the parameter addr and the values of flags, further described below. A successful mmap() call returns pa as its result. The address range starting at pa and continuing for len bytes will be legitimate for the possible (not necessarily current) address space of the process. The range of bytes starting at off and continuing for len bytes will be legitimate for the possible (not necessarily current) offsets in the file or shared memory object represented by fildes.\n\nThe mapping established by mmap() replaces any previous mappings for those whole pages containing any part of the address space of the process starting at pa and continuing for len bytes.\n\nIf the size of the mapped file changes after the call to mmap() as a result of some other operation on the mapped file, the effect of references to portions of the mapped region that correspond to added or removed portions of the file is unspecified.\n\nThe mmap() function is supported for regular files and shared memory objects. Support for any other type of file is unspecified.\n\nThe parameter prot determines whether read, write, execute, or some combination of accesses are permitted to the data being mapped. The prot should be either PROT_NONE or the bitwise inclusive OR of one or more of the other flags in the following table, defined in the header <sys/mman.h>.\n\nIf an implementation cannot support the combination of access types specified by prot, the call to mmap() fails. An implementation may permit accesses other than those specified by prot; however, the implementation will not permit a write to succeed where PROT_WRITE has not been set or permit any access where PROT_NONE alone has been set. The implementation will support at least the following values of prot: PROT_NONE, PROT_READ, PROT_WRITE, and the inclusive OR of PROT_READ and PROT_WRITE. The file descriptor fildes will have been opened with read permission, regardless of the protection options specified. If PROT_WRITE is specified, the application must have opened the file descriptor fildes with write permission unless MAP_PRIVATE is specified in the flags parameter as described below.\n\nThe parameter flags provides other information about the handling of the mapped data. The value of flags is the bitwise inclusive OR of these options, defined in <sys/mman.h>:\n\nMAP_SHARED and MAP_PRIVATE describe the disposition of write references to the memory object. If MAP_SHARED is specified, write references change the underlying object. If MAP_PRIVATE is specified, modifications to the mapped data by the calling process will be visible only to the calling process and will not change the underlying object. It is unspecified whether modifications to the underlying object done after the MAP_PRIVATE mapping is established are visible through the MAP_PRIVATE mapping. Either MAP_SHARED or MAP_PRIVATE can be specified, but not both. The mapping type is retained across fork().\n\nWhen MAP_FIXED is set in the flags argument, the implementation is informed that the value of pa must be addr, exactly. If MAP_FIXED is set, mmap() may return MAP_FAILED and set errno to [EINVAL]. If a MAP_FIXED request is successful, the mapping established by mmap() replaces any previous mappings for the process' pages in the range [pa, pa + len).\n\nWhen MAP_FIXED is not set, the implementation uses addr in an unspecified manner to arrive at pa. The pa so chosen will be an area of the address space that the implementation deems suitable for a mapping of len bytes to the file. All implementations interpret an addr value of 0 as granting the implementation complete freedom in selecting pa, subject to constraints described below. A non-zero value of addr is taken to be a suggestion of a process address near which the mapping should be placed. When the implementation selects a value for pa, it never places a mapping at address 0, nor does it replace any extant mapping.\n\nThe off argument is constrained to be aligned and sized according to the value returned by sysconf() when passed _SC_PAGESIZE or _SC_PAGE_SIZE. When MAP_FIXED is specified, the argument addr must also meet these constraints. The implementation performs mapping operations over whole pages. Thus, while the argument len need not meet a size or alignment constraint, the implementation will include, in any mapping operation, any partial page specified by the range [pa, pa + len).\n\nThe system always zero-fills any partial page at the end of an object. Further, the system never writes out any modified portions of the last page of an object that are beyond its end. References within the address range starting at pa and continuing for len bytes to whole pages following the end of an object result in delivery of a SIGBUS signal.\n\nAn implementation may deliver SIGBUS signals when a reference would cause an error in the mapped object, such as out-of-space condition.\n\nThe mmap() function adds an extra reference to the file associated with the file descriptor fildes which is not removed by a subsequent close() on that file descriptor. This reference is removed when there are no more mappings to the file.\n\nThe st_atime field of the mapped file may be marked for update at any time between the mmap() call and the corresponding munmap() call. The initial read or write reference to a mapped region will cause the file's st_atime field to be marked for update if it has not already been marked for update.\n\nThe st_ctime and st_mtime fields of a file that is mapped with MAP_SHARED and PROT_WRITE, will be marked for update at some point in the interval between a write reference to the mapped region and the next call to msync() with MS_ASYNC or MS_SYNC for that portion of the file by any process. If there is no such call, these fields may be marked for update at any time after a write reference if the underlying file is modified as a result.\n\nThere may be implementation-dependent limits on the number of memory regions that can be mapped (per process or per system). If such a limit is imposed, whether the number of memory regions that can be mapped by a process is decreased by the use of shmat() is implementation-dependent."
    },
    {
        "link": "https://opensource.com/article/19/4/interprocess-communication-linux-storage",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/49310908/inter-process-communication-using-shared-memorymmap-and-semaphores",
        "document": "I am trying to improvise a program I had written for single producer multiple consumer multi threading using counting semaphores. I want to implement inter process communication using shared memory (mmap() system call). I want to use anonymous mapping with no backing file.\n\nThis is the structure I want to share between the parent and its multiple child processes.\n\nThe parent process is the function which does produces something and puts it in buffer[i], based on some inputs. The child processes go to function which consumes what is put in its buffer[j]. Each reducer or child process should have access to its buffer. The child processes are forked() in the main function and then the parent process control goes to . I have initialized the synchronization primitives to be process shared.\n\nIs my method the correct way of doing it ? I am also getting type casting errors for return value of , which is a pointer, but I am not sure how to handle it and then use it. I also think should not be used in line 47 for allocating space to tuples but instead itself should be used. Can anyone please help ? This is my program -\n\nThese are the links I am trying to follow - https://computing.llnl.gov/tutorials/pthreads/man/pthread_mutexattr_init.txt https://github.com/bradfa/tlpi-dist/blob/master/mmap/anon_mmap.c"
    },
    {
        "link": "https://blog.minhazav.dev/memory-sharing-in-linux",
        "document": "\n• MISC: MMAP is faster than reading a file in blocks\n\nis a UNIX system call that maps files into memory. It’s a method used for memory-mapped file I/O. It brings in the optimization of or such that the I/O or reading file doesn’t happen when the memory allocation is done, but when the memory is accessed. After the memory is no longer needed it can be cleared with call. supports certain flags or argument which makes it suitable for allocating memory without file mapping as well. In Linux kernel, the call uses with flag for large allocations.\n\nIn this article, I’ll be explaining how what is and how it can be used for sharing memory in Linux. It kind of is the backbone of shared memory in Android.\n\ncreates a new mapping in the virtual address space of the calling process. If you check out the Linux kernel page for mmap you’ll see several arguments and flags. On the other hand, is used to free the allocated memory.\n• The specifies the starting address of the allocation and if it’s passed as the kernel chooses the starting address.\n• The argument specifies the length of allocation in bytes and should be .\n• The argument describes the protection level\n• Pages may be not be accessed. The flags can be passed with bitwise OR operator and the default protection level is\n• The argument is used to do various customizations, the interesting ones are:\n• or determines if the pages would be shared across processes or owned by a single process.\n• (or ) is used to indicate that the pages are not backed by any file and are anonymous. could use this flag to create a large memory allocation.\n• The indicates the file descriptor that represents the file backing the memory. This is not needed when using flag and can be set to .\n• The indicates the offset in bytes from which the file should be read to memory. The allocated memory will load to bytes from the file when the memory access happens.\n• The is the address of allocation to free, essentially what you got from calling the . After calling , any access on the memory address shall raise errors.\n• The determines the area of memory to clear. The area of memory from to would be freed on this call.\n\ncan be thought of as the core memory allocation API in Linux and several high-level constructs take advantage of this for providing various features. Linux kernel is the core of Android OS and components like uses in its core. is used for sharing memory in Android in different components like ContentProviders or Binder IPC.\n\nThis is fairly simple to visualize. A allocation with flag can be accessed directly by the child process.\n\nThis is very helpful in sharing the memory of core components in Android. All applications in Android are forked from a bare-bone process called which loads the core libraries and code required by all applications with . is loaded into memory on device boot and when a user attempts to open an application for the first time the system forks and then the application logic is initialized.\n\nWhile it’s easy to visualize how memory can be shared in ancestry between a parent and child. The logic is very similar but involves Inter-Process Communication (IPC). Two common ways to achieve this could be:\n\nThe concept is similar, the two processes say and can communicate with each other via certain IPC technology.\n• creates a file and allocates memory on that with flag and appropriate protection level and length. This process can write some data in the allocated memory space.\n• shares this file descriptor with Process 2 via a certain IPC method.\n• receives this file descriptor and calls on that. So the system returns the virtual address of the same memory allocation and based on the protection levels set by , can read, write or execute the shared memory pages.\n\nHowever, these processes are responsible for explicitly deallocating memory, otherwise, it cannot be reused by another process in need of memory.\n\nIn this case, another process acts as the manager of shared memory and exposes interface or methods to allocate or retrieve memory allocations. Let’s say there is a memory manager called and exposes APIs like this:\n• could allocate a chunk of memory using and share the with another process via a certain IPC mechanism.\n• could use to get the same allocation and act on it.\n• Any of these processes could use the to explicitly free the memory.\n\nWhile the way of dealing with shared memory seems very similar with or without a manager instance, a centralized manager can abstract some memory freeing techniques thus taking away the expectation of being good citizens from the calling processes like:\n• Freeing memory after use, the Manager can take care of freeing when the calling processes die.\n• Some components like ASHMEM, support features like PINNING and UNPINNING section of memory which allows the consumer process to set which part of memory can be cleared when the system is out of free memory. This protects the consumer apps from being killed by the Low Memory Killer (LMK) when it’s reclaiming memory. ASHMEM has its process on deciding which UNPINNED memory to clear when available memory is system goes below a certain threshold.\n\nMISC: MMAP is faster than reading a file in blocks\n\nWhile exploring these concepts I was wondering how file-backed memory manages to be performant while file IO operation like is generally considered much slower than memory operations. There are a few interesting StackOverflow questions like Why mmap() is faster than sequential IO? and mmap() vs. reading blocks which answer this questions pretty well.\n\nI wish I could add a TL;DR; answer to this question here but there isn’t one. Both and have their pros and cons and could be more performant in different situations. While seems like magic, it’s simply not.\n\nIn the future, I intend to write about what ASHMEM is, how it works, why it was brought when MMAP existed and examples of how it’s been used in Android. Another interesting memory manager in Android is the ION memory manager which was added to Linux kernel in 2011 by a patch from Google to solve issues around large memory allocations needed by components like GPU, display, camera, etc."
    },
    {
        "link": "https://courses.grainger.illinois.edu/cs241/sp2014/lecture/27-IPC.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/4836863/shared-memory-or-mmap-linux-c-c-ipc",
        "document": "The context is Inter-Process-Communication where one process(\"Server\") has to send fixed-size structs to many listening processes(\"Clients\") running on the same machine.\n\nI am very comfortable doing this in Socket Programming. To make the communication between the Server and the Clients faster and to reduce the number of copies, I want to try out using Shared Memory(shm) or mmaps.\n\nSince I am a newbie, please suggest which should I use. I'd appreciate it if someone could point me to a book or online resource to learn the same.\n\nThanks for the answers. I wanted to add that the Server ( Market Data Server ) will typically be receiving multicast data, which will cause it to be \"sending\" about 200,000 structs per second to the \"Clients\", where each struct is roughly 100 Bytes. Does shm_open/mmap implementation outperform sockets only for large blocks of data or a large volume of small structs as well ?"
    }
]