[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByTagName",
        "document": "The method of interface returns an of elements with the given tag name. The complete document is searched, including the root node. The returned is live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call again.\n\nIn the following example, starts from a particular parent element and searches top-down recursively through the DOM from that parent element, building a collection of all descendant elements which match the tag parameter. This demonstrates both and the functionally identical , which starts the search at a specific element within the DOM tree. Clicking the buttons uses to count the descendant paragraph elements of a particular parent (either the document itself or one of two nested elements). <!doctype html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <title>getElementsByTagName example</title> <script> function getAllParaElems() { const allParas = document.getElementsByTagName(\"p\"); const num = allParas.length; alert(`There are ${num} paragraph in this document`); } function div1ParaElems() { const div1 = document.getElementById(\"div1\"); const div1Paras = div1.getElementsByTagName(\"p\"); const num = div1Paras.length; alert(`There are ${num} paragraph in #div1`); } function div2ParaElems() { const div2 = document.getElementById(\"div2\"); const div2Paras = div2.getElementsByTagName(\"p\"); const num = div2Paras.length; alert(`There are ${num} paragraph in #div2`); } </script> </head> <body style=\"border: solid green 3px\"> <p>Some outer text</p> <p>Some outer text</p> <div id=\"div1\" style=\"border: solid blue 3px\"> <p>Some div1 text</p> <p>Some div1 text</p> <p>Some div1 text</p> <div id=\"div2\" style=\"border: solid red 3px\"> <p>Some div2 text</p> <p>Some div2 text</p> </div> </div> <p>Some outer text</p> <p>Some outer text</p> <button onclick=\"getAllParaElems();\"> Show all p elements in document </button> <br /> <button onclick=\"div1ParaElems();\"> Show all p elements in div1 element </button> <br /> <button onclick=\"div2ParaElems();\"> Show all p elements in div2 element </button> </body> </html>\n\nWhen called on an HTML document, lower-cases its argument before proceeding. This is undesirable when trying to match camel case SVG elements in a subtree in an HTML document. is useful in that case. See also Firefox bug 499656. is similar to , except that its search encompasses the whole document."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe method returns a live of elements with the given tag name.\n\nAll descendants of the specified element are searched, but not the element itself. The returned list is live, which means it updates itself with the DOM tree automatically. Therefore, there is no need to call with the same element and arguments repeatedly if the DOM changes in between calls.\n\nWhen called on an HTML element in an HTML document, lower-cases the argument before searching for it. This is undesirable when trying to match camel-cased SVG elements (such as ) in an HTML document. Instead, use , which preserves the capitalization of the tag name.\n\nis similar to , except that it only searches for elements that are descendants of the specified element."
    },
    {
        "link": "https://w3schools.com/jsref/met_document_getelementsbytagname.asp",
        "document": "Get all elements with the tag name \"li\": Try it Yourself » Get all elements in the document: Try it Yourself » Change the inner HTML of the first <p> element in the document: Try it Yourself »\n\nThe method returns a collection of all elements with a specified tag name.\n\nreturns all elements in the document.\n\nAn HTMLCollection is an array-like collection (list) of HTML elements.\n\nThe length Property returns the number of elements in the collection.\n\nThe elements can be accessed by index (starts at 0).\n\nAn HTMLCollection is live. It is automatically updated when the document is changed.\n\nIt is fully supported in all browsers:"
    },
    {
        "link": "https://geeksforgeeks.org/html-dom-getelementsbytagname-method",
        "document": "The getElementsByTagName() method in the HTML DOM allows the selection of elements by their tag name. It returns a collection of elements with the specified tag name within the specified document or element.\n\nTo extract any info just iterate through all the elements using the length property.\n• elements is a collection of all the found elements in the order they appear with the given tag name.\n• name is a string representing the name of the elements. The special string “*” represents all elements.\n\nExample 1: In this example, we will change the background color of the element using document.getElementByTagName() function.\n• None In the above example we defines an HTML document with a title, heading, paragraph, and a button.\n• None When the button is clicked, the geek() function is called, which modifies the style of the first paragraph.\n• None It uses document.getElementsByTagName() to select all <p> elements and applies style changes to the first one.\n• None The paragraph’s background color is set to green, and its text color is set to white.\n\nExample 2: In this example, we will change the properties of multiple elements using document.getElementsByTagName() function.\n• None In this example we contains multiple paragraphs and a button.\n• None When the button is clicked, the geek() function is executed.\n• None The function selects all <p> elements using getElementsByTagName() and changes their background and text colors.\n• None Each paragraph’s background color is set to green, and text color to white.\n\nHow to get the entire HTML document as a string in JavaScript ?\n\nTo get the entire HTML document as a string in JavaScript, use document.documentElement.outerHTML, which returns the HTML content including the root element as a string.\n\nWhat are the efficient ways to iterate over all DOM elements ?\n\nEfficient ways to iterate over all DOM elements include using `document.querySelectorAll()` for specific selections or document.getElementsByTagName(‘*’) to target all elements.\n\nHow to read all spans of a div dynamically ?\n\nTo dynamically read all spans within a div using getElementsByTagName(), utilize getElementsByTagName(‘span’) on the div element. Then iterate through the returned HTMLCollection to access the content of each span.\n\nWe have a complete list of HTML DOM methods, to check those please go through this HTML DOM Object Complete reference article.\n\nThe browser supported by the getElementsByTagName() method are listed below:\n\nWe have a Cheat Sheet on JavaScript where we covered all the important topics of Javascript to check those please go through Javascript Cheat Sheet-A Basic guide to JavaScript."
    },
    {
        "link": "https://w3schools.com/jsref/met_element_getelementsbytagname.asp",
        "document": "Change the HTML content of the first <li> element in a list: Try it Yourself » Try it Yourself » Change the font size of the second <p> element in \"myDIV\": Try it Yourself »\n\nThe method returns a collection of all child elements with a given tag name.\n\nAn HTMLCollection is an array-like collection (list) of HTML elements.\n\nThe length Property returns the number of elements in the collection.\n\nThe elements can be accessed by index (starts at 0).\n\nAn HTMLCollection is live. It is automatically updated when the document is changed.\n\nis supported in all browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/37070552/datatables-dynamic-columns",
        "document": "I understand that this question has been asked before, but my variation does not match the other answers.\n\nI have a json data source in this form :\n\nI am loading the data like this :\n\nThe above works flawlessly. What I need, is to load the columns dynamically, like this :\n\nAll I get is a aDataSource error. If I run the .getJSON thing anywhere else in the code I get the expected response, the one I need. Any ideas?\n\nI would like to make this to work as it is preferably as my datasource keeps changing based on filters I apply that affect the json source, dataset etc.\n\nThe way the table is initialized :"
    },
    {
        "link": "https://datatables.net/forums/discussion/60722/dynamic-columns",
        "document": "I found other posts that deal with grammatically creating columns. My data seems exactly the same but I am getting an error. So I am guessing it is because my json is formatted differently.\n\nHere is the link where someone else got it working: https://datatables.net/forums/discussion/comment/162006/#Comment_162006\n\nHere is my code:\n\nhere is the format of my JSON\n\nthe first line of code JSON.parse(data) results in 'unexpected token...\n\n the second line of code (from the post that I have the link to above) results in Cannot read property '0' of undefined and is talking about the line: columnNames = Object.keys(tableData.data[0]);\n\nSo I assume something is wrong with the structure of the object tableData but I can't figure it out."
    },
    {
        "link": "https://datatables.net/reference/api/columns().data()",
        "document": "Get the data for the cells in the selected columns.\n\nThis method is used to get the data used for the cells in the columns matched by the selector from DataTables.\n\nPlease note that the order of the data in the returned array and which rows the data is obtained from (searched rows, visible rows etc) is controlled by the option of the selector used to get the selected columns.\n\nObtain the data for the columns from the selector DataTables API instance with data for each cell in the selected columns in the result set. This is a 2D array with the top level array entries for each column matched by the selector.\n\nThe following options are directly related and may also be useful in your application development."
    },
    {
        "link": "https://stackoverflow.com/questions/39644079/how-to-display-the-column-headers-dynamically-in-jquery-data-table",
        "document": "Assuming the structure of the objects in the dataSet does not change, you could use the first object to build the json object external to the DataTable declaration. If the objects are not of a consistent structure, then you can tweak the logic inside the $.each structure to handle that.\n\nYou should also consider removing all the static table content in your HTML like this"
    },
    {
        "link": "https://datatables.net/manual/data",
        "document": "Data is complex, and all data is different. Accordingly, DataTables has a wealth of options which can be used to configure how it will obtain the data to display in the table, and how it processes that data.\n\nThere are three core concepts in how DataTables handles data, which are discussed in detail on this page:\n\nDataTables has two different modes of processing data (ordering, searching, etc. of data):\n• Client-side processing - the full data set is loaded up-front and data processing is done in the browser.\n• Server-side processing - an Ajax request is made for every table redraw, with only the data required for each display returned. The data processing is performed on the server.\n\nEach has its own advantages and disadvantages, but the key indicator for which mode you should select is based on the number of rows in your table. As a rule of thumb, if you are working with less than 10,000 rows use client-side processing, for greater than 100,000 rows use server-side processing. In-between is a grey area where you will need to make a decision based upon the nature of your app and the data you wish to display!\n\nPlease note that the two processing modes are mutually exclusive - they cannot be used at the same time, nor is it possible to dynamically change from one mode to the other.\n\nClient-side processing is the default operating mode of DataTables as it is easy to use and requires no additional code to be written. In client-side processing mode, the ordering of the data in the table, searching, paging and all other data processing operations that DataTables performs are done in the browser by DataTables itself.\n\nWhere server-side processing comes into play is when you have very large quantities of data that you wish to display in the table (millions of rows for example). At these levels, sending the data to the client, and then having Javascript process the data can involve noticeable overhead, and may result in poor performance of the end application. In server-side processing mode, all ordering, searching, etc. of the data is handed off to the server which can make use of the database engines available there, which are highly tuned for exactly these kinds of operations. Each page of data (referred to as a draw in DataTables terminology) involves making an Ajax request to the server. Although each Ajax request might take a fraction of a second to complete, this approach might be preferable to a large wait up-front as all data loads.\n\nServer-side processing is enabled by the option, and full documentation for how server-side processing operates is available in its section of this manual.\n\nThe main data source used for a DataTable must always be an array (it is created automatically when using DOM sourced data). Each item in that array will define a row to be displayed and DataTables can use three basic Javascript data types as the data source for the rows:\n\nDataTables can consume data from any of these options using the and options. The default mode of operation is an array, but objects and instances can be useful as they are typically more intuitive when working with complex data.\n\nArrays are easy to work with in a DataTable as the mapping between array elements to the column the data appears in is performed simply by the column index reading the array element value in that position. For example, the first table column maps to the first array element for the row's data source, etc.\n\nDue to this, when using arrays as your data source, the number of elements in each array must be equal to the number of columns in the table. For example, for a 6 column table you might have:\n\nWhich would result in a table such as:\n\nObjects are great for intuitive use in a slightly different way from arrays. If you are actively working with the data through the API, objects can make obtaining a particular piece of data very easy as you need only use a property name, rather than remembering which array index that data is in (for example , rather than ).\n\nObjects can also contain more information than is required for the DataTable display, which can be very useful for operating on the data (for example including a database primary key which is not visible to the end user).\n\nThe down side of using objects is that you need to explicitly tell DataTables which property it should use from the object for each column. This is done using the and / or options.\n\nObject based data may look like:\n\nNote that only 4 columns are defined and that data displayed in each column is easily defined by changing where each property is used, rather than needing to reorder the source objects as would be the case with an array data source\n\nThis would result in a table such as:\n\nIt can be quite useful to have DataTables display information from Javascript object instances, as these instances define abstract methods which can be used to update data. For example you might have an class, or a class, etc. depending on the data you are modelling. Instances can be used in DataTables in much the same way as objects - simply pass in your object and give the method or property name to for the data for each column.\n\nNote that is a method of the class above, while , and are properties. DataTables will automatically realise that there is a function, execute it and use the returned value for the cell (note you could also use the syntax to be explicit that a function is used - see for further information).\n\nLike the object based data source method above, although in this case the column is shown at the end of the table to show that the properties can be read in any order, this would result in a table such as:\n\nWith the concepts of the processing mode and data types now defined, we can consider how DataTables actually gets the data it is to operate with. There are three basic sources for the data that DataTables will display in the table:\n• DOM (i.e. the plain HTML of the document)\n\nWhen DataTables starts up, it will automatically check the table it is operating on for data that already exists inside it and use it for the table (note that it will throw this data away if you pass in data using or to get new data!). This is the simplest method of using DataTables - working with a regular HTML table.\n\nNote that when using a DOM sourced table, DataTables will use arrays as the data source (see above) by default, although you could use the option to have it construct objects for the row data instead.\n\nDataTables can also make use of HTML5 attributes, which can provide DataTables with additional information for ordering and search data. For example you might have a column with a date formatted such as \"21st November 2016\". Browsers will struggle to sort that, but you could provide a attribute as part of the HTML for the cell which contains a timestamp that can be easily sorted upon. Extending that, search data can be provided using . For example:\n\nSee the manual entry for orthogonal data for further information.\n\nYou can instruct DataTables to use data given to it using the initialisation option. This data can be in the form of arrays, objects or instances (see above) and can be sourced from anywhere you want! As long as Javascript can access the data, you can send it to DataTables (be it from a custom Ajax call, a WebSocket or just a good old fashioned array of data).\n\nThis method can be particularly useful when working extensively with the DataTables API, in particular the and methods can be used to add and remove data from the table dynamically, again from whatever source you wish to choose.\n\nAjax sourced data is much like Javascript sourced data, but DataTables will make an Ajax call to get the data for you. It can often be very useful to source table data from a specific script, separating the logic for retrieving the data from the display. Ajax sourced data in DataTables is controlled by the option. In its simplest form, you set the property value as a string, pointing at the URL you want to load data from.\n\nLike Javascript sourced data, Ajax sourced data can be in the form of objects or arrays (see above), but not, in this case, instances (since they cannot be represented in JSON).\n\nServer-side processing as discussed above is a special form of Ajax sourced data, whereby the data to be shown for each page in the DataTable is retrieved by an Ajax request only when that page is required for display to the user. This allows the power of the database engine on servers to be utilised for large data sets. For more information about server-side processing, and how it can be implemented, please refer to its documentation in this manual.\n\nAjax loading of data is discussed in detail in the next section of this manual.\n\nWhere to go next\n\nData is of course at the core of DataTables and it is impossible to cover the topic fully in a single page. This page gives a general overview of how DataTables handles data, but other topics include:"
    }
]