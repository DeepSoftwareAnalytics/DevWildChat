[
    {
        "link": "https://wiki.debian.org/NetworkInterfaceNames",
        "document": "See below for a \"Predictable Names\" Migration HOWTO.\n\nThis page deals with the various schemes by which wired and wireless network interfaces are assigned names (that is, the underlying system labels like or ), and has nothing to do with the \"connection profile\" names (like \"Wired connection 1\") used by apps such as NetworkManager. It was originally created as something for the Release Notes to point at for the 2019 dist-upgrade from Debian 9 \"stretch\" to Debian 10 \"buster\", but it turns out to be a perennial.\n\nBack in the nineties, , , etc were simply assigned by the kernel.\n\nWhy it was abandoned\n\nAt least in theory, if module probes completed in a different order, and might switch places on successive boots. As boot processes became less linear and interfaces became more hotpluggable this became more of a concern.\n\nHow to get it back\n\nIf you wipe out all other name-assignment mechanisms then you'll be left with this one.\n\nThe simple way of disabling the whole current interface naming scheme (which you might want to try for one-off testing) is just to boot with the kernel parameter , which can be set in an interactive session at boot or made persistent by editing and running .\n\nAlternatively, you can override , with a custom version in , or similarly override , or mask the latter by using a symlink instead of a custom version, or... there seem to be lots of ways of doing this, so make sure you haven't done it in more than one way or it'll trip you up in a couple of years when you try to undo it. See the external links below on standard methods for overriding systemd configuration. Oh, and beware of initrd skew.\n\nThis scheme, introduced somewhere around Debian 5 \"lenny\", used to identify interfaces by MAC address and assign a fixed interface number to any interface it recognized (writing the rules to ). This could have annoying side-effects (e.g. if you were replacing a machine's sole NIC, you'd also have to take special care to ensure it took over as network interface number 0) but these were minor and predictable.\n\nSince Debian 9 \"stretch\", newly installed machines no longer start with an file, though such files are maintained if they still exist (with new lines added for newly installed network hardware). On Debian 10 \"buster\" the file that appends to it was also missing, though legacy files were still honored.\n\nWhy this one was abandoned\n\nThis still had subtle race conditions, required to be on a writable file system, and had problems with virtualization, so it's no longer supported upstream. The plan (still taken for granted in most of the documentation) was for it not to be supported in Debian 10 \"buster\", but hand-crafted files continued working. In Debian 11 \"bullseye\" and later this is apparently no longer the case, though details are unclear; still reads files, and claims that matching rules can rename network interfaces, so what has changed?\n\nHow to cling to it for now\n\nIf you've got a working \"legacy\" file and want to stick with it, you can safely upgrade through Debian 9 \"stretch\" and Debian 10 \"buster\". The on these releases still respects that file if present (and will accept a freshly created one). However, bear in mind that you'll need to maintain it yourself, and be ready to switch to a different scheme for Debian 11 \"bullseye\".\n\nHow to let go and move on\n\nIf you're currently running something newer than Debian 8 \"jessie\" with a legacy file but have decided to switch to the new regime, you can do that just by disabling the file (then updating the initrd before you reboot); see the README.Debian.gz and the more detailed guide below.\n\nSeveral workarounds for renaming interfaces grew up in the early days of hotpluggable wireless interfaces, but if they still work it'll be because like ifrename they now use rules under the hood. It's not clear what remaining advantage this has over the canonical .link approach - is it perhaps useful for non-systemd machines?\n\nOld releases of RedHat (among others) used a biosdevname system, but that's never been supported under Debian.\n\nThe new scheme uses names usually derived from the location of the interface in terms of hardware buses etc: , . The idea was that this provides \"Predictable Names\", though as it turns out the main thing that's predictable about it is that calling it this will cause furious users to pop up disputing the appropriateness of that name. (Can we just skip all that here, please?)\n\nHow to cope with it on fresh installs\n\nThis should be easy enough; before you start configuring firewalls etc., just look at (e.g.) the output of and note the names of the interfaces. Unlike the old days, when the only way to guess which cable was plugged into and which was was to keep track of MAC addresses, this system provides extra clues in the interface names.\n\nHow to migrate to this scheme on upgraded systems\n\nIt's advisable to do this as a separate migration in its own right, not as part of a general distribution upgrade. However, if your PC only has one network interface and not much is at stake you can try:\n• None wait until breaks your networking, if it's going to, or trigger the change yourself.\n• None ask what new name it's using, and fix your configuration files.\n\nYou should probably at least check in advance to see what files hard-code interface names, by running something like\n\nObvious likely hits include and configuration files for firewalls, wifi, DHCP... but it's possible that (e.g.) a laptop with a single wifi interface managed by NetworkManager might need no fixing at all.\n\nOh, and hang on, aren't there apps that want you to put per-interface configuration into a file named after the interface, like ? You might need to check for those, too:\n\nThis strategy, more or less compulsory for remote servers, runs along the lines of:\n• None consider a dead-man's-handle cronjob or the like\n• None consult the list of corner cases below and search the Internet for others\n• once you're sure you're safe, implement your migration plan\n\nTo find out what names would be choosing between if you switched over to the new system, first get a list of the network devices the system knows about:\n\nFor each device path (other than ), ask what NET_IDs it knows:\n\nIt's likely to tell you about things like ID_OUI_FROM_DATABASE and an ID_NET_NAMING_SCHEME, but the lines that matter are the ones (given in random order) starting with ID_NET_NAME_. One of these is the name that will give priority to - the list of candidates may be so short that all you need to know is that ..._PATH beats ..._MAC, but there are also some rarer possibilities, and in general if something unusual shows up then it will take priority.\n\nFrom highest priority to lowest, the list is:\n• None ID_NET_NAME_FROM_DATABASE= Very rare and not to be confused with ID_OUI_FROM_DATABASE; if present, it outranks any other ID_NET_NAME. The database is hardcoded into and has only one known entry, the spooky-sounding .\n• None ID_NET_NAME_ONBOARD= Appears for some but not all kinds of onboard network card - it's usually a nice simple name like or .\n• None ID_NET_NAME_SLOT= Appears for some PCIe-hotplug cards. Usually looks like or . (Does this ever occur alongside _ONBOARD?)\n• None ID_NET_NAME_PATH= Always present; usually something just complicated enough to be easy to forget, like or . Note that all numbers are in hex.\n• None ID_NET_NAME_MAC= Also always present, but with a low enough priority that by default it won't be used; e.g.\n\nOne good reason for doing the migration separately from a dist-upgrade is that the answers you get from the in stable aren't absolutely guaranteed to be identical to the answers you'd get on testing. This further implies that any time you upgrade and reboot there's a chance your server might fall off the net, which seems like a good argument for using a customized scheme at least for the interface you're SSHing in on.\n\nthe brave way of finding out what network interface names you'll get without a file is to delete it (and update your initrd before you reboot), but you don't need to go that far. Just renaming it (e.g. to ) or commenting out particular lines should be enough. See the file. Note that it is possible to have a mixed system with (say) an named from its hardware path alongside a still defined as a \"persistent\" name. if you're ignoring ID_NET_NAME_SOMETHING on the assumption that anything you don't understand probably isn't important, you need to reread the above - the general rule is, if you don't recognise it, it'll mess things up. wired devices get a prefixed for Ethernet, wireless ones get (and there are also a few more obscure possibilities such as for InfiniBand); then in principle it's possible to decipher all the following sequences of code letters plus hex digits that encode hardware topology. But there's not much point trying to learn all the details, since the only workable way of predicting what ID_NET_NAMEs an interface will get is to ask , which will tell you the full strings. On Debian 11 \"bullseye\" and later you should also have a local copy of that as the man page systemd.net-naming-scheme(7), but (assuming your networking is still working) you may be better off with the online latest version, since its HISTORY section may provide advance warning of upcoming changes to the rules. if you look at on Debian 10 \"buster\" or later, you'll see that the standard priority hierarchy goes \" \" (ordered from highest to lowest; only gets considered via a different mechanism). There's a distinct shortage of documentation for those first three name-types, but the best source for (again assuming you're on \"buster\" or later) is (n.b. not ), which explains that it was formerly treated as present by default, and now exists as an explicit rule that names assigned by custom .link files won't be overridden. The name-type means something similar for interface names such as , which the kernel declares to be already predictable and therefore exempt from renaming. Then is just for - a possibility that isn't covered in systemd.net-naming-scheme(7) but does at least turn up in systemd.link(5). since they might get plugged into a different socket each time, these use ID_NET_NAME_MAC - automated via . on virtual machines (according to the README) you will need to remove the files and (if using virtio network devices) , then rebuild the initrd.\n\nThe scheme detailed above is the new standard default, but there's also a canonical way of overriding the default: you can use files to set up naming policies to suit your needs. Thus for instance if you have two PCs each of which has only a single wireless card, but one calls it and the other , you can arrange for them both to use the name to simplify sharing firewall configurations. For details see systemd.link(5).\n\nHere's a relatively futureproof \"manual\" version of the example given above:\n\nDon't use names like that the kernel might claim for another interface.\n\nIf instead of trusting your new policies to work after a reboot you want to take things step by step:\n• then\n• None for hotplug NICs, disconnect and reconnect them (or unload/reload the driver; if your SSH session doesn't go through this NIC...)\n• None for non-hotplug NICs, run , then check the logs (your SSH connection should still be okay even if your file was rejected as nonsense), then restart networking.\n\nIt is also possible to reorganize the naming policy by overriding , for instance to insist that all network interfaces are named purely by MAC address:\n\nNote that even though a lookup will explicitly mention in its stderr output that it's reading your file, names defined this way are not taken into account in its stdout output (any more than you can expect to know if you've told grub to add a to your kernel commandline).\n\nThe nearest the upstream docs ever got to a canonical migration-HOWTO was https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/. The big problem with this was that it delegated all its technical details to a link pointing at the sourcecode:https://github.com/systemd/systemd/blob/main/src/udev/udev-builtin-net_id.c ...but most of the useful comments that used to be at the top of that file were then thrown out, so you need to find your way back through the tree to a previous version such as https://github.com/systemd/systemd/blob/eefe36e64c1a583bb9470884ed92115e0ce4647e/src/udev/udev-builtin-net_id.c. Meanwhile, the page now claims to be obsolete, and points instead to https://www.freedesktop.org/software/systemd/man/systemd.net-naming-scheme.html, which is much less helpful. So the nearest thing left to an official HOWTO is probably (though it doesn't cover the \"how to predict the names\" part at all).\n\nA guide that (unlike that official reference text) mentions ID_NET_NAME_FROM_DATABASE: https://major.io/2015/08/21/understanding-systemds-predictable-network-device-names/"
    },
    {
        "link": "https://reddit.com/r/debian/comments/17awpo3/cannot_revert_to_old_network_interface_names_in",
        "document": "Hello all, I'm new to Debian, but have been working with Linux in general for a number of years. Typically, I've used `net.ifnames=0 biosdevname=0` as the value for `GRUB_CMDLINE_LINUX` and have been able to get `eth0`. But this does not seem to be the case in Debian 12. I've checked `dmesg` and the params are being used at boot, but my network interface stubbornly remains named `ens5`.\n\nI've checked `/etc/udev/rules.d/70-persistent-net.rules` and it's empty. I also tried creating `/etc/systemd/network/99-default.link` both as an empty file as well as with the contents:\n\nIt should be noted this an instance running on AWS with the ENA driver.\n\nAnyone know how to overcome this problem? I'm looking for a workaround that I can employ for provisioning instances with. So getting the MAC address and using that in `70-persistent-net.rules` is not really a solution that will work for me."
    },
    {
        "link": "https://wiki.debian.org/NetworkConfiguration",
        "document": "\n• The interfaces configuration file at /etc/network/interfaces (this page): for basic or simple configurations (e.g. workstation)\n• None NetworkManager: This is the default for Laptop configuration\n\nThe majority of network setup can be done via the configuration file at . Here, you can give your network card an IP address (or use dhcp), set up routing information, configure IP masquerading, set default routes and much more.\n\nRemember to add interfaces that you want brought up at boot time to the 'auto' line.\n\nSee for more options.\n\nInterfaces configured with can be brought up and down with the ifup and ifdown commands.\n\nSome outdated guides instruct to restart the networking service to apply changes to , however this was deprecated because it is possible that not all interfaces will be restarted. Instead use and to apply changes to each interface, for example with an interface named enp7s0:\n\nIf you make more fundamental network changes e.g. adding new virtual interfaces (e.g. bridge) in you can reinitialize the network configuration by restarting the daemon:\n\nSee NetworkInterfaceNames. Since Stretch, new systems by default no longer use old-style interface names such as eth0, eth1, wlan0, wlan1. The new system uses names based on hardware location, like eno0, enp0s31f6, wlp1s7 (or in the case of USB dongles, MAC address: enx2c56ac39ec0d).\n\nYou can list interfaces with:\n\nVarious examples below continue to use \"eth0\" as a default interface name, even though it is unlikely to exist on a modern system.\n\nStretch and Buster still retain support for the old naming system as long as the file is still in place, but users are advised to switch ahead of the upgrade to Bullseye.\n\nUsing DHCP to automatically configure the interface\n\nIf you're just using DHCP then all you need is something like:\n\nFor DHCPv6 (used for IPv6), append also the following stanza\n\nAlternatively, IPv6 can be autoconfigured using stateless address autoconfiguration, or SLAAC, which is specified using instead of in the stanza:\n\nIf you're configuring it manually then something like this will set the default gateway (network, broadcast and gateway are optional):\n\nIf you want to add an IPv6 address, too, append something like:\n\nSee for more options.\n\nMake sure to disable all DHCP services, e.g. .\n\nMixing manual and automatic configuration is also possible, e.g. to use IPv6 SLAAC for internet connectivity and static addresses within the network:\n\nAutonegotiation repeatedly failing is often a symptom of faulty cabling, so investigate physical matters before assuming that the interfaces' autonegotiation algorithms are incompatible. If you turn off autonegotiation and set speed and duplex manually then the partner interface at the other end of the cable will assume that the absence of autonegotiation indicates a speed of 10Mbps and a duplex of half. For error-free operation if you set speed and duplex manually you must ensure that exactly the same speed and duplex are configured on the partner interface.\n\nIf you set your interface's speed and duplex by hand, then some trial and error may be required. Here are the basic steps:\n• None Install the ethtool and net-tools packages, so that you have the and programs. One or both of these might work for your interface.\n• None Make sure you have a way to login to the system in case the network interface becomes nonfunctional. An SSH connection could be disrupted, so you should have a fallback strategy.\n• Identify the interface in question (it will often be eth0). Adjust the remainder of these instructions accordingly.\n• Try to determine what its current speed and duplex settings are. This is where it gets fun:\n• None As root, try first, and see whether the \"Speed:\" and \"Duplex:\" lines look valid. If not, the may not be supported by your device.\n• None As root, try and see whether its output looks correct. If not, them may not be supported by your device.\n• None If neither one is supported, you may have to set parameters directly on the kernel driver module. Identify which driver module you're using by reading the output of and . You can then try to see what parameters it accepts, if any. (You can use even on modules that are not loaded, for comparison.) ToDo: where does one set kernel module parameters?\n• Next, try to change the settings of the interface while it's operating. You'll need to be root, of course. Either: In each case, re-check to see whether the interface settings actually changed, and then try sending some data in and out of the system to see whether the NIC is operating correctly.\n• None If one of these commands successfully set your NIC, then you can put it into so it runs when you bring the interface up (e.g. at boot time). However, before you do that, you should understand that some drivers and devices behave differently than others. When the driver module is loaded, the NIC may begin autonegotiation without any way to stop it (particularly with drivers that do not accept parameters). The settings from are applied at some point after that, which may be right in the middle of the negotiation. So, some people find it necessary to delay the or command by a few seconds. Thus:\n• Reboot the machine to make sure it comes up correctly, and be prepared to intervene manually (e.g. Ctrl-Alt-Del and then boot into single-user mode from GRUB or LILO) if things don't work.\n\nBringing up an interface without an IP address\n\nTo create a network interface without an IP address at all use the manual method and use pre-up and post-down commands to bring the interface up and down.\n\nIf the interface is a VLAN interface, the up/down commands must be executed after/before the vlan hooks. (You also have to install the vlan package.)\n\nNote: If you create the VLAN interface only to put it into a bridge, there is no need to define the VLAN interface manually. Just configure the bridge, and the VLAN interface will be created automatically when creating the bridge (see below).\n\nBefore a computer can connect to an external network resource (say, for example, a web server), it must have a means of converting any alpha-numeric names (e.g. wiki.debian.org) into numeric network addresses (e.g. 140.211.166.4). (The Internet uses these structured numeric IP addresses as network addresses.)\n\nThe C library and other resolver libraries look to for a list of nameservers. In the simplest case, that is the file to edit to set the list of name servers. But note that various other programs for dynamic configuration will be happy to overwrite your settings:\n\nIn most situations, the file to edit is the configuration file for such a program.\n\nIn the most complex situations, using really is the way to go, though in more simple configurations it is probably overkill.\n\nThe configuration file at contains information that allows a computer connected to a network to resolve names into addresses. (Note: Do not confuse this configuration file with the program , which unfortunately has a nearly identical name.)\n\nThe file typically contains the IP addresses of nameservers (DNS name resolvers) that will attempt to translate names into addresses for any node available on the network. There will be a line or lines that look like this:\n\nIn this example, the system is using nameservers at the IP addresses and . Simply edit the file and enter the IP addresses of the nameservers you need to use after each . Add more lines if you have more nameservers. Don't use this method if you have the program installed.\n\nThe configuration file has many other options for defining how resolver looks up names. See for details.\n\nThe program keeps track of system information about the currently available nameservers. It should not be confused with the configuration file , which unfortunately has a nearly identical name. The program is optional on a Debian system.\n\nThe configuration file contains information about the nameservers to be used by the system. However, when multiple programs need to dynamically modify the configuration file they can step on each other and the file can become out-of-sync. The program addresses this problem. It acts as an intermediary between programs that supply nameserver information (e.g. dhcp clients) and programs that use nameserver information (e.g. resolver).\n\nWhen is properly installed, the configuration file at is replaced by a symbolic link to and the resolver instead uses the configuration file that is dynamically generated by at .\n\nThe program is generally only necessary when a system has multiple programs that need to dynamically modify the nameserver information. In a simple system where the nameservers do not change often or are only changed by one program, the configuration file is adequate.\n\nIf the program is installed, you should not edit the configuration file manually as it will be dynamically changed by programs in the system. If you need to manually define the nameservers (as with a static interface), add a line something like the following to the configuration file at :\n\nPlace the line indented within an stanza, e.g., right after the line. Enter the IP addresses of the nameservers you need to use after . Put all of them on one line separated by spaces. Don't forget the \" \" on the end of .\n\nThe program is a fairly new addition to Debian and many older programs need to be updated or reconfigured to work properly with it. If you have problems, see . It has lots of information on making other programs get along with .\n\nNetworkManager will override dhcp settings, overwriting resolv.conf even if you've configured DNS in /etc/dhcp/dhclient.conf, e.g. causing DNS to first search the local domain, which may have to time out before DNS resolution continues causing lengthy DNS resolution times. You can get an idea of what NetworkManager thinks the settings should be by executing nm-tool at the command line.\n\nYou may configure these settings using a GUI by launching nm-connection-editor which currently (13.11.23) isn't to be found in System Tools → Administration menu, rather it must be launched by hand from the command line. After launching:\n• Choose a connection (from the Wired or Wireless tab) and click Edit.\n• Choose 'Automatic (DHCP) addresses only' instead of just 'Automatic (DHCP)'.\n• Enter the DNS servers in the “DNS servers” field, separated by spaces (e.g. 208.67.222.222 for OpenDNS).\n\nNetworkManager saves these settings in . Example :\n\nRunning nm-tool again should show that NetworkManager now has the right idea of how your DNS should be resolved.\n\nsystemd-resolved is not installed by default but you can use it it runs a local caching dns resolver that can intergrate with ?NetowrkManager and Systemd-network\n\nBy default it does not get enabled so you need to switch over to use it.\n\nAlso for glibc apps using nss you need to edit the /etc/nsswitch.conf file so the hosts line reads as follows. This will use for resolution.\n\nNote that resolved supports /etc/hosts so should to go before the files entry.\n\nChecking the status and flushing the cache in systemd-resolved\n\nYou can check the status using\n\nYou can flush the cache that resolved has with the following\n\nGeneral settings for systemd-resolved are managed in see for more info.\n\nExample: dhclient3 uses . The setting you want is:\n\nNote the leading space since the string is literally appended to the search domain provided by other configurations.\n\nSee the dhclient.conf(5) manual page for details.\n\nBridging puts multiple interfaces into the same network segment. This is very popular when connecting a server to multiple switches for high availability or with virtualization. In the latter case it is usually used to create a bridge in the host (eg. dom0) and put the virtual interfaces of the guests (domU) into the bridge.\n• None The bridge-utils package is required to create bridged interfaces.\n\nExample: Connect a server to 2 switches (via eth0 and eth1) by defining bridge 0 and give the server an IP address in this subnet:\n\nIf a server is connected to multiple switches then you usually need to run the spanning tree protocol to avoid loops. Therefore STP must be turned on via an \"up\" command as shown above.\n\nExample: Bridge setup without IP address configuration (use \"manual\" instead of \"static\") to \"forward\" an interface to a guest VM. (The static bridge config contains only 1 physical interface. The virtual interface will be added to the bridge when the VM is started.)\n\nNote: The Linux bridge supports only STP, no RSTP (Rapid Spanning Tree). Therefore it supports only the old STP Costs, not the new RSTP Costs (see Spanning_Tree_Protocol). This is usually fine with Cisco Switches, but eg. Juniper switches use the RSTP costs and therefore this may lead to different spanning tree calculations and loop problems. This can be fixed by settings the costs manually, either on the switch or on the server. Setting the cost on the switch is preferred as Linux switches back to the default costs whenever an interface does down/up.\n\nBy default the Linux bridge acts like a switch. This means, it remembers the MAC addresses behind a switch port and if the destination MAC address is known, data packets or only forward to the respective port - otherwise packets will be broadcasted.\n\nIn some setups this is bad. For example if the bridge connects 2 trunk interfaces and the same MAC addresses may be seen from both interfaces, depending on the VLAN. As the Linux bridge does not support VLANs (dedicated MAC address tables per each VLAN), in such setups you have to disable the MAC address learning and put the bridge into a real \"bridge\" mode with:\n\nThe interface name should be the raw interface name (the same as specified by vlan-raw-device), then a dot, then the VLAN ID, for example eth0.100. It can instead be \"vlan\" then the VLAN ID, for example vlan100. In either case, the VLAN ID is on the end, and this is the only place that it is configured.\n\nNote: If you name your VLAN interfaces ethX.YYY, then there is no need to specify the vlan-raw-device, as the raw device can be retrieved from the interface name.\n\nIf you create VLAN interfaces only to put them into a bridge, there is no need to define the VLAN interfaces manually. Just config the bridge, and the VLAN interface will be created automatically when creating the bridge, e.g:\n\nCaveats when using bridging and vlan\n\nIf you are using a brigded VLAN setup, which is probably useful for networking in virtualization environments, take care to only attach either a bridge device or VLAN devices to an underlying physical device - like shown above. Attaching the physical interface (eth0) to a bridge (eg. bri1) while using the same physical interface on apparently different VLANs will result in all packets to remain tagged. (Kernel newer than 2.6.37 and older than 3.2).\n\nHow to configure one of the above server active backup bonding 3 vlan {vlan10,vlan20,vlan30} Debian networking without SPOF without native vlan.\n• None In Debian Buster, you must use interface names for VLANs in the form of: , , and instead of , ,\n\nHow to set the MTU (Max transfer unit / packet size) with VLANS over a bonded interface\n\nMTU needs to be configured on the bonding interface and slave interfaces after the reset of the configuration has been applied to the bonding interfaces. This is done using a post-up line in the bonding interface configuration.\n\nInterface aliasing allows one interface to have multiple IP addresses. This is useful when more than one server is to be visible via the Internet. Note that virtual hosts can support multiple Apache servers with a single IP address. Apache responds to the domain name supplied by the client in the HTTP header. In many other situations, one external IP is needed for each server using a port.\n\nThis /etc/network/interfaces text assigns three IP addresses to eth0.\n\nAn alias interface should not have \"gateway\" or \"dns-nameservers\"; dynamic IP assignment is permissible.\n\nThe above configuration is the previous traditional method that reflects the traditional use of ifconfig to configure network devices. ifconfig has introduced the concept of aliased or virtual interfaces. Those types of virtual interfaces have names of the form interface:integer and ifconfig treats them very similarly to real interfaces.\n\nNowadays ifupdown uses the ip utility from the iproute2 package instead of ifconfig. The newer ip utility does not use the same concept of aliases or virtual interfaces. However, it supports assigning arbitrary names to the interfaces (they're called labels). ifupdown uses this feature to support aliased interfaces while using ip.\n\nAlso, ifupdown supports specifying multiple interfaces by repeating iface sections with the same interface name. The key difference from the method described above is that all such sections are treated by ifupdown as just one interface, so user can't add or remove them individually. However, up/down commands, as well as scripts, are called for every section as it used to be.\n\nNote however that this method is dangerous! Certain driver/hardware combinations may sometimes fail to bring the link up if no labels are assigned to the alias interfaces. (Seen this on Debian Wheezy and Jessie with RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 01) auto-negotiating to 10/full. A similar warning from another person exists in the history of this page.)\n\nThis /etc/network/interfaces text assigns three IP addresses to eth0."
    },
    {
        "link": "https://unix.stackexchange.com/questions/91085/udev-renaming-my-network-interface",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://forum.level1techs.com/t/debian-network-interface-naming-lottery/207848",
        "document": "Hey, I came across this weird issue with fresh server install of Debian 12. tl;dr interface names can change after reboot. No hardware changes, nothing. Just after reboot. I’ve installed debian 12 on ProLiant DL580 Gen9, as you can see every interface has a proper “persistent” altname, but it’s not used. For example, can become after reboot and then come back to ens back again. My fails to load when that happens. Can I force the system to switch to “altnames”? 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n\n link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n\n inet 127.0.0.1/8 scope host lo\n\n valid_lft forever preferred_lft forever\n\n inet6 ::1/128 scope host noprefixroute\n\n valid_lft forever preferred_lft forever\n\n 2: ens8f0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c0 brd ff:ff:ff:ff:ff:ff\n\n altname enp69s0f0\n\n 3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c2 brd ff:ff:ff:ff:ff:ff\n\n altname enp69s0f1\n\n 4: eth2: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c4 brd ff:ff:ff:ff:ff:ff\n\n altname enp70s0f0\n\n 5: ens8f1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c6 brd ff:ff:ff:ff:ff:ff\n\n altname enp70s0f1\n\n inet 172.24.44.241/24 scope global ens8f1\n\n valid_lft forever preferred_lft forever\n\n inet6 fe80::210:18ff:feae:a8c6/64 scope link\n\n valid_lft forever preferred_lft forever\n\n 6: eno49: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 48:0f:cf:f5:e5:00 brd ff:ff:ff:ff:ff:ff\n\n altname enp3s0\n\n 7: eno49d1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 48:0f:cf:f5:e5:01 brd ff:ff:ff:ff:ff:ff\n\n altname enp3s0d1\n\n 8: ens9: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 50:65:f3:8a:fe:b0 brd ff:ff:ff:ff:ff:ff\n\n altname enp4s0\n\n 9: ens9d1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 50:65:f3:8a:fe:b1 brd ff:ff:ff:ff:ff:ff\n\n altname enp4s0d1\n\nWell, the thing is that first of all, you can see I have a mix and match of old and new naming, and if possible, instead of reverting to eth1,2,3, i’d much rather have the system use consistently. I’m curious if someone has also come across this and dealt with it without creating custom udev rules, because this seems to be mostly debian related.\n\nI wrote a script for this. Your mileage may vary. add to cron to start at reboot or write a systemd service (better idea) for it. released on a dwtfyw (do what the f*** you want) license . no warranties, no guarantees , no money back if it hoses your system. so yes back up before doing this.\n\nI wrote a script for this. Your mileage may vary. Nice script, but please do not use the old and outdated , this is better: #!/bin/bash INTERFACES=( \"enp1s0\" \"enp2s0\" ) ALIASES=( \"eth0\" \"eth1\" ) for i in ${!INTERFACES[*]}; do ip link dev ${INTERFACES[$i]} set down ip link dev ${INTERFACES[$i]} set name ${ALIASES[$i]} done service networking restart Now all you need to do is change the two arrays at the start, YW\n\nSure, here’s the two configs off my router (I use debian to route stuff) The first one deals with naming: The second one then does, in this case, dhcp with a ton of options for various reasons. … you can check what’s going at runtime with .\n\nThis bug is ancient, I recall something with udev rules. Proxmox 6 had this bug ages ago on HPE dl380 gen8. Never fixed it, but since rebooting was so infrequent, didn’t really care much. It got fixed with proxmox 7 upgrade. The bug in my case was interfaces getting named to “rename6,” “rename7” and alike (instead of anything sane like “ethX” or “enpXsY” or whatever). this seems to be mostly debian related. This also affected some version of SLES, I think it was old though, something like SLES 12 (saw it on some customer’s servers), but the behavior was more like yours than like what I’ve had to deal with. I don’t have a fix other than identifying the interfaces and renaming them with ‘ip’. The problem is, if the interfaces get random names (like eth7 or rename8), despite only being 6 interfaces on the server, (which happened to me), then the script will still fail. Not sure if interfaces get consistently named to new and old styles with the same names each time, or if they get a new name on each reboot, or every other reboot. Sometimes eth1 was rename3 and sometimes it was rename4 (I never had rename1 and 2 for some reason, which explains why it went all the way up to rename8, but I digress). I don’t have any solution, like mentioned. Changing udev rules is probably the only real solution.\n\nThe easiest way would be to bind an interface name to the mac adress. You can do it here: I got annoyed, because whenever I removed/exchanged a PCIe card my network interface names changed - this broke my network bridges I setup earlier. This way interface names remain fixed. I strongly recommend to stick to interface names which aren’t reserved by the system like lo, eth0 etc. Here ist the link to the Debian wiki (last paragraph):\n\n https://wiki.debian.org/NetworkInterfaceNames#THE_.22PERSISTENT_NAMES.22_SCHEME\n\nTrying to get a interface name that will stay put on a bench machine, where I’m likely to add hardware. Had tried setting my own name based on matching MAC address: partly worked: I also have VLANs, and run KVM-QEMU hypervisor with guests on various VLANs. Problem is the VLANS have the same MAC and systemd was trying to rename them to same as physical, which of course failed.\n\n Fixed:\n\n add to Dratatto’s answer additional match on Type=ether. The vlans will by type=vlan so prevents them from matching."
    },
    {
        "link": "https://wiki.debian.org/NetworkInterfaceNames",
        "document": "See below for a \"Predictable Names\" Migration HOWTO.\n\nThis page deals with the various schemes by which wired and wireless network interfaces are assigned names (that is, the underlying system labels like or ), and has nothing to do with the \"connection profile\" names (like \"Wired connection 1\") used by apps such as NetworkManager. It was originally created as something for the Release Notes to point at for the 2019 dist-upgrade from Debian 9 \"stretch\" to Debian 10 \"buster\", but it turns out to be a perennial.\n\nBack in the nineties, , , etc were simply assigned by the kernel.\n\nWhy it was abandoned\n\nAt least in theory, if module probes completed in a different order, and might switch places on successive boots. As boot processes became less linear and interfaces became more hotpluggable this became more of a concern.\n\nHow to get it back\n\nIf you wipe out all other name-assignment mechanisms then you'll be left with this one.\n\nThe simple way of disabling the whole current interface naming scheme (which you might want to try for one-off testing) is just to boot with the kernel parameter , which can be set in an interactive session at boot or made persistent by editing and running .\n\nAlternatively, you can override , with a custom version in , or similarly override , or mask the latter by using a symlink instead of a custom version, or... there seem to be lots of ways of doing this, so make sure you haven't done it in more than one way or it'll trip you up in a couple of years when you try to undo it. See the external links below on standard methods for overriding systemd configuration. Oh, and beware of initrd skew.\n\nThis scheme, introduced somewhere around Debian 5 \"lenny\", used to identify interfaces by MAC address and assign a fixed interface number to any interface it recognized (writing the rules to ). This could have annoying side-effects (e.g. if you were replacing a machine's sole NIC, you'd also have to take special care to ensure it took over as network interface number 0) but these were minor and predictable.\n\nSince Debian 9 \"stretch\", newly installed machines no longer start with an file, though such files are maintained if they still exist (with new lines added for newly installed network hardware). On Debian 10 \"buster\" the file that appends to it was also missing, though legacy files were still honored.\n\nWhy this one was abandoned\n\nThis still had subtle race conditions, required to be on a writable file system, and had problems with virtualization, so it's no longer supported upstream. The plan (still taken for granted in most of the documentation) was for it not to be supported in Debian 10 \"buster\", but hand-crafted files continued working. In Debian 11 \"bullseye\" and later this is apparently no longer the case, though details are unclear; still reads files, and claims that matching rules can rename network interfaces, so what has changed?\n\nHow to cling to it for now\n\nIf you've got a working \"legacy\" file and want to stick with it, you can safely upgrade through Debian 9 \"stretch\" and Debian 10 \"buster\". The on these releases still respects that file if present (and will accept a freshly created one). However, bear in mind that you'll need to maintain it yourself, and be ready to switch to a different scheme for Debian 11 \"bullseye\".\n\nHow to let go and move on\n\nIf you're currently running something newer than Debian 8 \"jessie\" with a legacy file but have decided to switch to the new regime, you can do that just by disabling the file (then updating the initrd before you reboot); see the README.Debian.gz and the more detailed guide below.\n\nSeveral workarounds for renaming interfaces grew up in the early days of hotpluggable wireless interfaces, but if they still work it'll be because like ifrename they now use rules under the hood. It's not clear what remaining advantage this has over the canonical .link approach - is it perhaps useful for non-systemd machines?\n\nOld releases of RedHat (among others) used a biosdevname system, but that's never been supported under Debian.\n\nThe new scheme uses names usually derived from the location of the interface in terms of hardware buses etc: , . The idea was that this provides \"Predictable Names\", though as it turns out the main thing that's predictable about it is that calling it this will cause furious users to pop up disputing the appropriateness of that name. (Can we just skip all that here, please?)\n\nHow to cope with it on fresh installs\n\nThis should be easy enough; before you start configuring firewalls etc., just look at (e.g.) the output of and note the names of the interfaces. Unlike the old days, when the only way to guess which cable was plugged into and which was was to keep track of MAC addresses, this system provides extra clues in the interface names.\n\nHow to migrate to this scheme on upgraded systems\n\nIt's advisable to do this as a separate migration in its own right, not as part of a general distribution upgrade. However, if your PC only has one network interface and not much is at stake you can try:\n• None wait until breaks your networking, if it's going to, or trigger the change yourself.\n• None ask what new name it's using, and fix your configuration files.\n\nYou should probably at least check in advance to see what files hard-code interface names, by running something like\n\nObvious likely hits include and configuration files for firewalls, wifi, DHCP... but it's possible that (e.g.) a laptop with a single wifi interface managed by NetworkManager might need no fixing at all.\n\nOh, and hang on, aren't there apps that want you to put per-interface configuration into a file named after the interface, like ? You might need to check for those, too:\n\nThis strategy, more or less compulsory for remote servers, runs along the lines of:\n• None consider a dead-man's-handle cronjob or the like\n• None consult the list of corner cases below and search the Internet for others\n• once you're sure you're safe, implement your migration plan\n\nTo find out what names would be choosing between if you switched over to the new system, first get a list of the network devices the system knows about:\n\nFor each device path (other than ), ask what NET_IDs it knows:\n\nIt's likely to tell you about things like ID_OUI_FROM_DATABASE and an ID_NET_NAMING_SCHEME, but the lines that matter are the ones (given in random order) starting with ID_NET_NAME_. One of these is the name that will give priority to - the list of candidates may be so short that all you need to know is that ..._PATH beats ..._MAC, but there are also some rarer possibilities, and in general if something unusual shows up then it will take priority.\n\nFrom highest priority to lowest, the list is:\n• None ID_NET_NAME_FROM_DATABASE= Very rare and not to be confused with ID_OUI_FROM_DATABASE; if present, it outranks any other ID_NET_NAME. The database is hardcoded into and has only one known entry, the spooky-sounding .\n• None ID_NET_NAME_ONBOARD= Appears for some but not all kinds of onboard network card - it's usually a nice simple name like or .\n• None ID_NET_NAME_SLOT= Appears for some PCIe-hotplug cards. Usually looks like or . (Does this ever occur alongside _ONBOARD?)\n• None ID_NET_NAME_PATH= Always present; usually something just complicated enough to be easy to forget, like or . Note that all numbers are in hex.\n• None ID_NET_NAME_MAC= Also always present, but with a low enough priority that by default it won't be used; e.g.\n\nOne good reason for doing the migration separately from a dist-upgrade is that the answers you get from the in stable aren't absolutely guaranteed to be identical to the answers you'd get on testing. This further implies that any time you upgrade and reboot there's a chance your server might fall off the net, which seems like a good argument for using a customized scheme at least for the interface you're SSHing in on.\n\nthe brave way of finding out what network interface names you'll get without a file is to delete it (and update your initrd before you reboot), but you don't need to go that far. Just renaming it (e.g. to ) or commenting out particular lines should be enough. See the file. Note that it is possible to have a mixed system with (say) an named from its hardware path alongside a still defined as a \"persistent\" name. if you're ignoring ID_NET_NAME_SOMETHING on the assumption that anything you don't understand probably isn't important, you need to reread the above - the general rule is, if you don't recognise it, it'll mess things up. wired devices get a prefixed for Ethernet, wireless ones get (and there are also a few more obscure possibilities such as for InfiniBand); then in principle it's possible to decipher all the following sequences of code letters plus hex digits that encode hardware topology. But there's not much point trying to learn all the details, since the only workable way of predicting what ID_NET_NAMEs an interface will get is to ask , which will tell you the full strings. On Debian 11 \"bullseye\" and later you should also have a local copy of that as the man page systemd.net-naming-scheme(7), but (assuming your networking is still working) you may be better off with the online latest version, since its HISTORY section may provide advance warning of upcoming changes to the rules. if you look at on Debian 10 \"buster\" or later, you'll see that the standard priority hierarchy goes \" \" (ordered from highest to lowest; only gets considered via a different mechanism). There's a distinct shortage of documentation for those first three name-types, but the best source for (again assuming you're on \"buster\" or later) is (n.b. not ), which explains that it was formerly treated as present by default, and now exists as an explicit rule that names assigned by custom .link files won't be overridden. The name-type means something similar for interface names such as , which the kernel declares to be already predictable and therefore exempt from renaming. Then is just for - a possibility that isn't covered in systemd.net-naming-scheme(7) but does at least turn up in systemd.link(5). since they might get plugged into a different socket each time, these use ID_NET_NAME_MAC - automated via . on virtual machines (according to the README) you will need to remove the files and (if using virtio network devices) , then rebuild the initrd.\n\nThe scheme detailed above is the new standard default, but there's also a canonical way of overriding the default: you can use files to set up naming policies to suit your needs. Thus for instance if you have two PCs each of which has only a single wireless card, but one calls it and the other , you can arrange for them both to use the name to simplify sharing firewall configurations. For details see systemd.link(5).\n\nHere's a relatively futureproof \"manual\" version of the example given above:\n\nDon't use names like that the kernel might claim for another interface.\n\nIf instead of trusting your new policies to work after a reboot you want to take things step by step:\n• then\n• None for hotplug NICs, disconnect and reconnect them (or unload/reload the driver; if your SSH session doesn't go through this NIC...)\n• None for non-hotplug NICs, run , then check the logs (your SSH connection should still be okay even if your file was rejected as nonsense), then restart networking.\n\nIt is also possible to reorganize the naming policy by overriding , for instance to insist that all network interfaces are named purely by MAC address:\n\nNote that even though a lookup will explicitly mention in its stderr output that it's reading your file, names defined this way are not taken into account in its stdout output (any more than you can expect to know if you've told grub to add a to your kernel commandline).\n\nThe nearest the upstream docs ever got to a canonical migration-HOWTO was https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/. The big problem with this was that it delegated all its technical details to a link pointing at the sourcecode:https://github.com/systemd/systemd/blob/main/src/udev/udev-builtin-net_id.c ...but most of the useful comments that used to be at the top of that file were then thrown out, so you need to find your way back through the tree to a previous version such as https://github.com/systemd/systemd/blob/eefe36e64c1a583bb9470884ed92115e0ce4647e/src/udev/udev-builtin-net_id.c. Meanwhile, the page now claims to be obsolete, and points instead to https://www.freedesktop.org/software/systemd/man/systemd.net-naming-scheme.html, which is much less helpful. So the nearest thing left to an official HOWTO is probably (though it doesn't cover the \"how to predict the names\" part at all).\n\nA guide that (unlike that official reference text) mentions ID_NET_NAME_FROM_DATABASE: https://major.io/2015/08/21/understanding-systemds-predictable-network-device-names/"
    },
    {
        "link": "https://reddit.com/r/debian/comments/17awpo3/cannot_revert_to_old_network_interface_names_in",
        "document": "Hello all, I'm new to Debian, but have been working with Linux in general for a number of years. Typically, I've used `net.ifnames=0 biosdevname=0` as the value for `GRUB_CMDLINE_LINUX` and have been able to get `eth0`. But this does not seem to be the case in Debian 12. I've checked `dmesg` and the params are being used at boot, but my network interface stubbornly remains named `ens5`.\n\nI've checked `/etc/udev/rules.d/70-persistent-net.rules` and it's empty. I also tried creating `/etc/systemd/network/99-default.link` both as an empty file as well as with the contents:\n\nIt should be noted this an instance running on AWS with the ENA driver.\n\nAnyone know how to overcome this problem? I'm looking for a workaround that I can employ for provisioning instances with. So getting the MAC address and using that in `70-persistent-net.rules` is not really a solution that will work for me."
    },
    {
        "link": "https://forum.level1techs.com/t/debian-network-interface-naming-lottery/207848",
        "document": "Hey, I came across this weird issue with fresh server install of Debian 12. tl;dr interface names can change after reboot. No hardware changes, nothing. Just after reboot. I’ve installed debian 12 on ProLiant DL580 Gen9, as you can see every interface has a proper “persistent” altname, but it’s not used. For example, can become after reboot and then come back to ens back again. My fails to load when that happens. Can I force the system to switch to “altnames”? 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n\n link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n\n inet 127.0.0.1/8 scope host lo\n\n valid_lft forever preferred_lft forever\n\n inet6 ::1/128 scope host noprefixroute\n\n valid_lft forever preferred_lft forever\n\n 2: ens8f0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c0 brd ff:ff:ff:ff:ff:ff\n\n altname enp69s0f0\n\n 3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c2 brd ff:ff:ff:ff:ff:ff\n\n altname enp69s0f1\n\n 4: eth2: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c4 brd ff:ff:ff:ff:ff:ff\n\n altname enp70s0f0\n\n 5: ens8f1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n\n link/ether 00:10:18:ae:a8:c6 brd ff:ff:ff:ff:ff:ff\n\n altname enp70s0f1\n\n inet 172.24.44.241/24 scope global ens8f1\n\n valid_lft forever preferred_lft forever\n\n inet6 fe80::210:18ff:feae:a8c6/64 scope link\n\n valid_lft forever preferred_lft forever\n\n 6: eno49: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 48:0f:cf:f5:e5:00 brd ff:ff:ff:ff:ff:ff\n\n altname enp3s0\n\n 7: eno49d1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 48:0f:cf:f5:e5:01 brd ff:ff:ff:ff:ff:ff\n\n altname enp3s0d1\n\n 8: ens9: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 50:65:f3:8a:fe:b0 brd ff:ff:ff:ff:ff:ff\n\n altname enp4s0\n\n 9: ens9d1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\n\n link/ether 50:65:f3:8a:fe:b1 brd ff:ff:ff:ff:ff:ff\n\n altname enp4s0d1\n\nWell, the thing is that first of all, you can see I have a mix and match of old and new naming, and if possible, instead of reverting to eth1,2,3, i’d much rather have the system use consistently. I’m curious if someone has also come across this and dealt with it without creating custom udev rules, because this seems to be mostly debian related.\n\nI wrote a script for this. Your mileage may vary. add to cron to start at reboot or write a systemd service (better idea) for it. released on a dwtfyw (do what the f*** you want) license . no warranties, no guarantees , no money back if it hoses your system. so yes back up before doing this.\n\nI wrote a script for this. Your mileage may vary. Nice script, but please do not use the old and outdated , this is better: #!/bin/bash INTERFACES=( \"enp1s0\" \"enp2s0\" ) ALIASES=( \"eth0\" \"eth1\" ) for i in ${!INTERFACES[*]}; do ip link dev ${INTERFACES[$i]} set down ip link dev ${INTERFACES[$i]} set name ${ALIASES[$i]} done service networking restart Now all you need to do is change the two arrays at the start, YW\n\nSure, here’s the two configs off my router (I use debian to route stuff) The first one deals with naming: The second one then does, in this case, dhcp with a ton of options for various reasons. … you can check what’s going at runtime with .\n\nThis bug is ancient, I recall something with udev rules. Proxmox 6 had this bug ages ago on HPE dl380 gen8. Never fixed it, but since rebooting was so infrequent, didn’t really care much. It got fixed with proxmox 7 upgrade. The bug in my case was interfaces getting named to “rename6,” “rename7” and alike (instead of anything sane like “ethX” or “enpXsY” or whatever). this seems to be mostly debian related. This also affected some version of SLES, I think it was old though, something like SLES 12 (saw it on some customer’s servers), but the behavior was more like yours than like what I’ve had to deal with. I don’t have a fix other than identifying the interfaces and renaming them with ‘ip’. The problem is, if the interfaces get random names (like eth7 or rename8), despite only being 6 interfaces on the server, (which happened to me), then the script will still fail. Not sure if interfaces get consistently named to new and old styles with the same names each time, or if they get a new name on each reboot, or every other reboot. Sometimes eth1 was rename3 and sometimes it was rename4 (I never had rename1 and 2 for some reason, which explains why it went all the way up to rename8, but I digress). I don’t have any solution, like mentioned. Changing udev rules is probably the only real solution.\n\nThe easiest way would be to bind an interface name to the mac adress. You can do it here: I got annoyed, because whenever I removed/exchanged a PCIe card my network interface names changed - this broke my network bridges I setup earlier. This way interface names remain fixed. I strongly recommend to stick to interface names which aren’t reserved by the system like lo, eth0 etc. Here ist the link to the Debian wiki (last paragraph):\n\n https://wiki.debian.org/NetworkInterfaceNames#THE_.22PERSISTENT_NAMES.22_SCHEME\n\nTrying to get a interface name that will stay put on a bench machine, where I’m likely to add hardware. Had tried setting my own name based on matching MAC address: partly worked: I also have VLANs, and run KVM-QEMU hypervisor with guests on various VLANs. Problem is the VLANS have the same MAC and systemd was trying to rename them to same as physical, which of course failed.\n\n Fixed:\n\n add to Dratatto’s answer additional match on Type=ether. The vlans will by type=vlan so prevents them from matching."
    },
    {
        "link": "https://reddit.com/r/linuxadmin/comments/11ktbbd/interface_name_changed_on_debian",
        "document": "we have some debian 10 VM on some cloud provider. and yesterday out of the blue on one of them the interface name changed. from enp2xxxx to enp3xxxx. Of course that caused some problem because some config files we used are based on nic names.\n\nAny idea what could have cause the name change? or how can i check (which logs?) what caused it?"
    },
    {
        "link": "https://unix.stackexchange.com/questions/437011/wrong-predictable-network-interface-name-in-debian",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]