[
    {
        "link": "https://docs.sympy.org",
        "document": ""
    },
    {
        "link": "https://docs.sympy.org/latest/modules/evalf.html",
        "document": "Exact SymPy expressions can be converted to floating-point approximations (decimal numbers) using either the method or the function. is equivalent to . By default, numerical evaluation is performed to an accuracy of 15 decimal digits. You can optionally pass a desired accuracy (which should be a positive integer) as an argument to or : If the expression contains symbols or for some other reason cannot be evaluated numerically, calling or returns the original expression, or in some cases a partially evaluated expression. For example, when the expression is a polynomial in expanded form, the coefficients are evaluated: You can also use the standard Python functions , to convert SymPy expressions to regular Python numbers: If these functions are used, failure to evaluate the expression to an explicit number (for example if the expression contains symbols) will raise an exception. There is essentially no upper precision limit. The following command, for example, computes the first 100,000 digits of π/e: This shows digits 999,951 through 1,000,000 of pi: High-precision calculations can be slow. It is recommended (but entirely optional) to install gmpy (https://github.com/aleaxit/gmpy), which will significantly speed up computations such as the one above.\n\nFloating-point numbers in SymPy are instances of the class . A can be created with a custom precision as second argument: As the last example shows, some Python floats are only accurate to about 15 digits as inputs, while others (those that have a denominator that is a power of 2, like 0.125 = 1/8) are exact. To create a from a high-precision decimal number, it is better to pass a string, , or a : The precision of a number determines 1) the precision to use when performing arithmetic with the number, and 2) the number of digits to display when printing the number. When two numbers with different precision are used together in an arithmetic operation, the higher of the precisions is used for the result. The product of 0.1 +/- 0.001 and 3.1415 +/- 0.0001 has an uncertainty of about 0.003 and yet 5 digits of precision are shown. So the displayed precision should not be used as a model of error propagation or significance arithmetic; rather, this scheme is employed to ensure stability of numerical algorithms. and can be used to change the precision of existing floating-point numbers:\n\nWhen the input to or is a complicated expression, numerical error propagation becomes a concern. As an example, consider the 100’th Fibonacci number and the excellent (but not exact) approximation \\(\\varphi^{100} / \\sqrt{5}\\) where \\(\\varphi\\) is the golden ratio. With ordinary floating-point arithmetic, subtracting these numbers from each other erroneously results in a complete cancellation: and keep track of errors and automatically increase the precision used internally in order to obtain a correct result: Unfortunately, numerical evaluation cannot tell an expression that is exactly zero apart from one that is merely very small. The working precision is therefore capped, by default to around 100 digits. If we try with the 1000’th Fibonacci number, the following happens: The lack of digits in the returned number indicates that failed to achieve full accuracy. The result indicates that the magnitude of the expression is something less than 10^84, but that is not a particularly good answer. To force a higher working precision, the keyword argument can be used: Normally, can be set very high (thousands of digits), but be aware that this may cause significant slowdown in extreme cases. Alternatively, the option can be set to force an exception instead of silently returning a value with less than the requested accuracy: : from zero. Try simplifying the input, using chop=True, or providing a higher maxn for evalf If we add a term so that the Fibonacci approximation becomes exact (the full form of Binet’s formula), we get an expression that is exactly zero, but does not know this: In situations where such cancellations are known to occur, the options is useful. This basically replaces very small numbers in the real or imaginary portions of a number with exact zeros: In situations where you wish to remove meaningless digits, re-evaluation or the use of the method are useful: If you are dealing with a numeric expression that contains no floats, it can be evaluated to arbitrary precision. To round the result relative to a given decimal, the round method is useful:\n\nSums (in particular, infinite series) and integrals can be used like regular closed-form expressions, and support arbitrary-precision evaluation: By default, the tanh-sinh quadrature algorithm is used to evaluate integrals. This algorithm is very efficient and robust for smooth integrands (and even integrals with endpoint singularities), but may struggle with integrals that are highly oscillatory or have mid-interval discontinuities. In many cases, / will correctly estimate the error. With the following integral, the result is accurate but only good to four digits: It is better to split this integral into two pieces: A similar example is the following oscillatory integral: It can be dealt with much more efficiently by telling or to use an oscillatory quadrature algorithm: Oscillatory quadrature requires an integrand containing a factor cos(ax+b) or sin(ax+b). Note that many other oscillatory integrals can be transformed to this form with a change of variables: Infinite series use direct summation if the series converges quickly enough. Otherwise, extrapolation methods (generally the Euler-Maclaurin formula but also Richardson extrapolation) are used to speed up convergence. This allows high-precision evaluation of slowly convergent series: The Euler-Maclaurin formula is also used for finite series, allowing them to be approximated quickly without evaluating all terms: Note that makes some assumptions that are not always optimal. For fine-tuned control over numerical summation, it might be worthwhile to manually use the method . Special optimizations are used for rational hypergeometric series (where the term is a product of polynomials, powers, factorials, binomial coefficients and the like). / sum series of this type very rapidly to high precision. For example, this Ramanujan formula for pi can be summed to 10,000 digits in a fraction of a second with a simple command:"
    },
    {
        "link": "https://sympy.org",
        "document": ""
    },
    {
        "link": "https://docs.sympy.org/latest/modules/core.html",
        "document": "\n• None Always use , when accessing parameters of some instance:\n• None Never use internal methods or variables (the ones prefixed with ): # do not use this, use cot(x).args instead\n• None By “SymPy object” we mean something that can be returned by . But not all objects one encounters using SymPy are subclasses of Basic. For example, mutable objects are not: Never use self._args, always use self.args. Only use _args in __new__ when creating a new function. Do not override .args() from Basic (so that it is easy to change the interface in the future if needed). A stub to allow Basic args (like Tuple) to be skipped when computing the content and primitive components of an expression. Return the expression with any objects having structurally bound symbols replaced with unique, canonical symbols within the object in which they appear and having only the default assumption for commutativity being True. When applied to a symbol a new symbol having only the same commutativity will be returned. Any object that has structurally bound variables should have a property, \\(bound_symbols\\) that returns those symbols appearing in the object. are different objects. In other words, besides Python type (Symbol in this case), the initial assumptions are also forming their typeinfo. Returns the atoms that form the current object. By default, only objects that are truly atomic and cannot be divided into smaller pieces are returned: symbols, numbers, and number symbols like I and pi. It is possible to request atoms of any type, however, as demonstrated below. If one or more types are given, the results will contain only those types of atoms. Note that I (imaginary unit) and zoo (complex infinity) are special types of number symbols and are not part of the NumberSymbol class. The type can be given implicitly, too: Be careful to check your assumptions when using the implicit option since but is , a special type of SymPy atom, while is type and will find all integers in an expression: Finally, arguments to atoms() can select more than atomic atoms: any SymPy type (loaded in core/__init__.py) can be listed as an argument and those types of “atoms” as found in scanning the arguments of the expression recursively: Return a dictionary mapping any variable defined in to Symbols that do not clash with any free symbols in the expression. Return -1, 0, 1 if the object is less than, equal, or greater than other in a canonical sense. Non-Basic are always greater than Basic. If both names of the classes being compared appear in the \\(ordering_of_classes\\) then the ordering will depend on the appearance of the names there. If either does not appear in that list, then the comparison is based on the class name. If the names are the same then a comparison is made on the length of the hashable content. Items of the equal-lengthed contents are then successively compared using the same rules. If there is never a difference then 0 is returned. Wrapper for count_ops that returns the operation count. Evaluate objects that are not evaluated by default like limits, integrals, sums and products. All objects of this kind will be evaluated recursively, unless some species were excluded via ‘hints’ or unless the ‘deep’ hint was set to ‘False’. Return from the atoms of self those which are free symbols. Not all free symbols are . Eg: IndexedBase(‘I’)[0].free_symbols For most expressions, all symbols are free symbols. For some classes this is not true. e.g. Integrals use Symbols for the dummy variables which are bound variables, so Integral has a method to return all symbols except those. Derivative keeps track of symbols with respect to which it will perform a derivative; those are bound variables, too, so it has its own free_symbols method. Any other method that uses bound variables should implement a free_symbols method. Create a new object from an iterable. This is a convenience function that allows one to create objects from any iterable, without having to convert to a list or tuple first. The top-level function in an expression. The following should hold for all objects: Test whether any subexpression matches any of the patterns. Note is a structural algorithm with no knowledge of mathematics. Consider the following half-open interval: # there is no \"4\" in the arguments # there *is* a \"0\" in the arguments Instead, use to determine whether a number is in the interval or not: Note that is exactly equivalent to . In particular, is returned when the list of patterns is empty. Return True if self has object(s) as a free expression else False. This works for subexpressions and types, too: Return True if self has any of the patterns in s as a free argument, else False. This is like \\(Basic.has_free\\) but this will only report exact argument matches. Return True if self can be computed to a real number (or already is a real number) with precision, else False. A False result does not mean that \\(self\\) cannot be rewritten into a form that would be comparable. For example, the difference computed below is zero but without simplification it does not evaluate to a zero with precision: Return True if a and b are structurally the same, else False. If \\(approx\\) is supplied, it will be used to test whether two numbers are the same or not. By default, only numbers of the same type will compare equal, so S.Half != Float(0.5). In SymPy (unlike Python) two numbers do not compare the same if they are not of the same type: By supplying a function with which to compare two numbers, such differences can be ignored. e.g. \\(equal_valued\\) will return True for decimal numbers having a denominator that is a power of 2, regardless of precision. But decimals without a power of 2 denominator will compare as not being the same. But arbitrary differences can be ignored by supplying a function to test the equivalence of two numbers: Other objects might compare the same even though types are not the same. This routine will only return True if two expressions are identical in terms of class types. Return when expression (self) does not match with pattern. Otherwise return a dictionary such that: Structurally bound symbols are ignored during matching: But they can be identified if desired: The flag will give the old-style pattern matching where expressions and patterns are essentially solved to give the match. Both of the following give None unless : Helper method for match() that looks for a match between Wild symbols in self and expressions in expr. Apply on the argument recursively through the expression tree. This method is used to simulate a common abuse of notation for operators. For instance, in SymPy the following will not work: See the refine function in sympy.assumptions If then also return the mapping {old: new} where was a sub-expression found with query and is the replacement value for it. If the expression itself does not match the query, then the returned value will be otherwise it should be . Traverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, can be set to False. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the flag is None it will be set to True so the match will only succeed if all non-zero values are received for each Wild that appears in the match pattern. Setting this to False accepts a match of 0; while setting it True accepts all matches that have a 0 in them. See example below for cautions. The list of possible combinations of queries and replacement values is listed below: When object of type is found, replace it with the result of passing its argument(s) to . When object of type is found, apply to its argument(s). must be written to handle the number of arguments of . Replace subexpressions matching with the expression written in terms of the Wild symbols in . Matching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols: When set to False, the results may be non-intuitive: All behavior is the same as in 2.1 but now a function in terms of pattern variables is used rather than an expression: Replace subexpression with if is True. The expression itself is also targeted by the query but is done in such a fashion that changes are not made twice. When matching a single symbol, \\(exact\\) will default to True, but this may or may not be the behavior that is desired: Here, we want \\(exact=False\\): But here, the nature of matching makes selecting the right setting tricky: It is probably better to use a different form of the query that describes the target expression more precisely: substitution of subexpressions as defined by the objects themselves. exact node replacement in expr tree; also capable of using matching rules Rewriting transforms an expression to another, which is mathematically equivalent but structurally different. For example you can rewrite trigonometric functions as complex exponentials or combinatorial functions as gamma function. This method takes a pattern and a rule as positional arguments. pattern is optional parameter which defines the types of expressions that will be transformed. If it is not passed, all possible expressions will be rewritten. rule defines how the expression will be rewritten. A rule, or pattern and rule. - pattern is a type or an iterable of types. - rule can be any object. If , subexpressions are recursively transformed. Default is . If pattern is unspecified, all possible expressions are transformed. Pattern can be a type or an iterable of types. Rewriting behavior can be implemented by defining method. Defining method is supported for backwards compatibility reason. This may be removed in the future and using it is discouraged. See the simplify function in sympy.simplify Substitutes old for new in an expression after sympifying args.\n• None one iterable argument, e.g. foo.subs(iterable). The iterable may be o an iterable container with (old, new) pairs. In this case the replacements are processed in the order given with successive patterns possibly affecting replacements already made. o a dict or set whose key/value items correspond to old/new pairs. In this case the old/new pairs will be sorted by op count and in case of a tie, by number of args and the default_sort_key. The resulting sorted list is then processed as an iterable container (see previous). If the keyword is True, the subexpressions will not be evaluated until all the substitutions have been made. To replace only the x**2 but not the x**4, use xreplace: To delay evaluation until all substitutions have been made, set the keyword to True: This has the added feature of not allowing subsequent substitutions to affect those already made: In order to obtain a canonical result, unordered iterables are sorted by count_op length, number of arguments and by the default_sort_key to break any ties. All other iterables are left unsorted. The resulting expression represents a literal replacement of the old arguments with the new arguments. This may not reflect the limiting behavior of the expression: If the substitution will be followed by numerical evaluation, it is better to pass the substitution to evalf as as the former will ensure that the desired level of precision is obtained. replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements exact node replacement in expr tree; also capable of using matching rules calculates the given formula to a desired level of precision Replace occurrences of objects within the expression. xreplace : the result of the replacement Replacements occur only if an entire node in the expression tree is matched: xreplace does not differentiate between free and bound symbols. In the following, subs(x, y) would not change x since it is a bound symbol, but xreplace does: Trying to replace x with an expression raises an error: replacement capable of doing wildcard-like matching, parsing of match, and conditional replacements substitution of subexpressions as defined by the objects themselves. A parent class for atomic things. An atom is an expression with no subexpressions.\n\nEverything that requires arithmetic operations to be defined should subclass this class, instead of Basic (which should be used only for argument storage and expression manipulation, i.e. pattern matching, substitutions, etc). If you want to override the comparisons of expressions: Should use _eval_is_ge for inequality, or _eval_is_eq, with multiple dispatch. _eval_is_ge return true if x >= y, false if x < y, and None if the two types are not comparable or the comparison is indeterminate See the apart function in sympy.polys self is treated as a Mul and the ordering of the factors is maintained. If is True the commutative factors will be returned in a set. If there were repeated factors (as may happen with an unevaluated Mul) then an error will be raised unless it is explicitly suppressed by setting to False. Note: -1 is always separated from a Number unless split_1 is False. The arg is always treated as a Mul: Return the tuple (c, args) where self is written as an Add, . c should be a Rational added to any terms of the Add that are independent of deps. args should be a tuple of all other terms of ; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is an Add or not but you want to treat self as an Add or if you want to process the individual arguments of the tail of self as an Add.\n• None if you know self is an Add and want only the head, use self.args[0];\n• None if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail.\n• None if you want to split self into an independent and dependent parts use where x can be any symbolic expression. Return the tuple (c, args) where self is written as a Mul, . c should be a Rational multiplied by any factors of the Mul that are independent of deps. args should be a tuple of all other factors of m; args is empty if self is a Number or if self is independent of deps (when given). This should be used when you do not know if self is a Mul or not but you want to treat self as a Mul or if you want to process the individual arguments of the tail of self as a Mul.\n• None if you know self is a Mul and want only the head, use self.args[0];\n• None if you do not want to process the arguments of the tail but need the tail then use self.as_two_terms() which gives the head and tail;\n• None if you want to split self into an independent and dependent parts use Extracts symbolic coefficient at the given expression. In other words, this functions separates ‘self’ into the product of ‘expr’ and ‘expr’-free coefficient. If such separation is not possible it will return None. Two terms have E in them so a sum is returned. (If one were desiring the coefficient of the term exactly matching E then the constant from the returned expression could be selected. Or, for greater precision, a method of Poly can be used to indicate the desired term from which the coefficient is desired.) # just want the exact match Since the following cannot be written as a product containing E as a factor, None is returned. (If the coefficient is desired then the method should be used.) return sum of terms have a given factor separate the additive constant from an expression separate the multiplicative constant from an expression efficiently find the single coefficient of a monomial in Poly like coeff_monomial but powers of monomial terms are used Return a dictionary mapping terms to their Rational coefficient. Since the dictionary is a defaultdict, inquiries about terms which were not present will return a coefficient of 0. If symbols are provided, any multiplicative terms independent of them will be considered a coefficient and a regular dictionary of syms-dependent generators as keys and their corresponding coefficients as values will be returned. This method should recursively remove a Rational from all arguments and return that (content) and the new self (primitive). The content should always be positive and . The primitive need not be in canonical form and should try to preserve the underlying structure if possible (i.e. expand_mul should not be applied to self). The as_content_primitive function is recursive and retains structure: Integer powers will have Rationals extracted from the base: Terms may end up joining once their as_content_primitives are added: Radical content can also be factored out of the primitive: If clear=False (default is True) then content will not be removed from an Add if it can be distributed to leave one or more terms with integer coefficients. A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.:\n• None separatevars() to change Mul, Add and Pow (including exp) into Mul\n• None .expand(mul=True) to change Add or Mul into Add\n• None .expand(log=True) to change log expr into an Add The only non-naive thing that is done here is to respect noncommutative ordering of variables and to always return (0, 0) for \\(self\\) of zero regardless of hints. For nonzero \\(self\\), the returned tuple (i, d) has the following interpretation:\n• None i will has no variable that appears in deps\n• None d will either have terms that contain variables that are in deps, or be equal to 0 (when self is an Add) or 1 (when self is a Mul)\n• None if self is an Add then self = i + d\n• None if self is a Mul then self = i*d\n• None otherwise (self, S.One) or (S.One, self) is returned. To force the expression to be treated as an Add, use the hint as_Add=True non-commutative terms cannot always be separated out when self is a Mul – force self to be treated as an Add: – force self to be treated as a Mul: Note how the below differs from the above in making the constant on the dep term positive. – use .as_independent() for true independence testing instead of .has(). The former considers only symbols in the free symbols while the latter considers all symbols Note: when trying to get independent terms, a separation method might need to be used first. In this case, it is important to keep track of what you send to this routine so you know how to interpret the returned values Returns the leading (nonzero) term of the series expansion of self. The _eval_as_leading_term routines are used to do this, and they must always return a non-zero value. Return the numerator and the denominator of an expression. This is just a stub that should be defined by an object’s class methods to get anything else. Return list of ordered factors (if Mul) else [self]. Transform an expression to an ordered list of terms. Return self as a dictionary of factors with each factor being treated as a power. The keys are the bases of the factors and the values, the corresponding exponents. The resulting dictionary should be used with caution if the expression is a Mul and contains non- commutative factors since the order that they appeared will be lost in the dictionary. An alternative for noncommutative applications, returning an ordered list of factors. Similar to as_ordered_factors, but guarantees separation of commutative and noncommutative factors. Performs complex expansion on ‘self’ and returns a tuple containing collected both real and imaginary parts. This method cannot be confused with re() and im() functions, which does not perform complex expansion at evaluation. However it is possible to expand both re() and im() functions and get exactly the same results as with a single call to this function. Transform an expression to a list of terms. Asymptotic Series expansion of self. This is equivalent to . The expression whose series is to be expanded. It is the variable of the expression to be calculated. The value used to represent the order in terms of , up to which the series is to be expanded. Set this parameter to be True to produce hierarchical series. It stops the recursion at an early level and may provide nicer and more useful results. Use the parameter to give limit on rewriting coefficients in its normalised form. For rational expressions this method may return original expression without the Order term. >>> (1/x).aseries(x, n=8) 1/x This algorithm is directly induced from the limit computational algorithm provided by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first to look for the most rapidly varying subexpression w of a given expression f and then expands f in a series in w. Then same thing is recursively done on the leading coefficient till we get constant coefficients. If the most rapidly varying subexpression of a given expression f is f itself, the algorithm tries to find a normalised representation of the mrv set and rewrites f using this normalised representation. If the expansion contains an order term, it will be either or where belongs to the most rapidly varying expression of . See the docstring of this function for complete details of this wrapper. Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244. See the cancel function in sympy.polys Returns the coefficient from the term(s) containing . If is zero then all terms independent of will be returned. When is noncommutative, the coefficient to the left (default) or right of can be returned. The keyword ‘right’ is ignored when is commutative. You can select terms that have an explicit negative in front of them: You can select terms with no Rational coefficient: You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0] is returned (and 0 will be returned instead of None): You can select terms that have a numerical term in front of them: In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the following: If such factoring is desired, factor_terms can be used first: If there is more than one possible coefficient 0 is returned: If there is only one possible coefficient, it is returned: separate the expression into a coefficient and factor separate the additive constant from an expression separate the multiplicative constant from an expression efficiently find the single coefficient of a monomial in Poly like coeff_monomial but powers of monomial terms are used See the collect function in sympy.simplify See the combsimp function in sympy.simplify Deprecated function to compute the leading term of a series. as_leading_term is only allowed for results of .series() This is a wrapper to compute a series first. Return True if self has -1 as a leading factor or has more literal negative signs than positive signs in a sum, otherwise False. Though the is considered like , since it is in a product without a leading factor of -1, the result is false below: To put something in canonical form wrt to sign, use \\(signsimp\\): Return True if self == other, False if it does not, or None. If failing_expression is True then the expression which did not simplify to a 0 will be returned instead of None. If is a Number (or complex number) that is not zero, then the result is False. If is a number and has not evaluated to zero, evalf will be used to test whether the expression evaluates to zero. If it does so and the result has significance (i.e. the precision is either -1, for a Rational result, or is greater than 1) then the evalf value will be used to return True or False. See the docstring of the expand() function in sympy.core.function for more information. Like , but returns the free symbols only if they are contained in an expression node. If the expression is contained in a non-expression object, do not return the free symbols. Compare: Return self - c if it’s possible to subtract c from self and make all matching coefficients move towards zero, else return None. Try to write self as in a nice way. Return (z, n). If allow_half is True, also extract exp_polar(I*pi): Return None if it’s not possible to make self in the form c * something in a nice way, i.e. preserving the properties of arguments of self. See the factor() function in sympy.polys.polytools See the docstring of the in sympy.series.fourier for more information. See the docstring of the function in sympy.series.formal for more information. See the gammasimp function in sympy.simplify Returns the additive O(..) symbol if there is one, else None. Returns the order of the expression. The order is determined either from the O(…) term. If there is no O(…) term, it returns None. See the integrate function in sympy.integrals Return the multiplicative inverse of mod where (and ) may be symbolic expressions). This tests whether a given expression is algebraic or not, in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are “algebraic expressions” with symbolic exponents. This is a simple extension to the is_rational_function, including rational exponentiation. This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be an algebraic expression to become one. Return True if self is constant, False if not, or None if the constancy could not be determined conclusively. If an expression has no free symbols then it is a constant. If there are free symbols it is possible that the expression is a constant, perhaps (but not necessarily) zero. To test such expressions, a few strategies are tried: 1) numerical evaluation at two random points. If two such evaluations give two different values and the values have a precision greater than 1 then self is not constant. If the evaluations agree or could not be obtained with any precision, no decision is made. The numerical testing is done only if is different than the free symbols. 2) differentiation with respect to variables in ‘wrt’ (or all free symbols if omitted) to see if the expression is constant or not. This will not always lead to an expression that is zero even though an expression is constant (see added test in test_expr.py). If all derivatives are zero then self is constant with respect to the given symbols. 3) finding out zeros of denominator expression with free_symbols. It will not be constant if there are zeros. It gives more negative answers for expression that are not constant. If neither evaluation nor differentiation can prove the expression is constant, None is returned unless two numerical values happened to be the same and the flag is True – in that case the numerical value will be returned. If flag simplify=False is passed, self will not be simplified; the default is True since self should be simplified before testing. This tests whether an expression is meromorphic as a function of the given symbol at the point . This method is intended as a quick test that will return None if no decision can be made without simplification or more detailed analysis. Multivalued functions are considered meromorphic when their branches are meromorphic. Thus most functions are meromorphic everywhere except at essential singularities and branch points. In particular, they will be meromorphic also on branch cuts except at their endpoints. Returns True if has no free symbols and no undefined functions (AppliedUndef, to be precise). It will be faster than , however, since will fail as soon as it hits a free symbol or undefined function. Not all numbers are Numbers in the SymPy sense: If something is a number it should evaluate to a number with real and imaginary parts that are Numbers; the result may not be comparable, however, since the real and/or imaginary part of the result may not have precision. Return True if self is a polynomial in syms and False otherwise. This checks if self is an exact polynomial in syms. This function returns False for expressions that are “polynomials” with symbolic exponents. Thus, you should be able to apply polynomial algorithms to expressions for which this returns True, and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns True. The polynomial does not have to be in expanded form. If no symbols are given, all free symbols in the expression will be used. This is not part of the assumptions system. You cannot do Symbol(‘z’, polynomial=True). This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a polynomial to become one. Test whether function is a ratio of two polynomials in the given symbols, syms. When syms is not given, all free symbols will be used. The rational function does not have to be in expanded or in any kind of canonical form. This function returns False for expressions that are “rational functions” with symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply polynomial algorithms to the result for expressions for which this returns True. This is not part of the assumptions system. You cannot do Symbol(‘z’, rational_function=True). This function does not attempt any nontrivial simplifications that may result in an expression that does not appear to be a rational function to become one. Wrapper for series yielding an iterator of the terms of the series. Note: an infinite series will yield an infinite iterator. The following, for exaxmple, will never terminate. It will just keep printing terms of the sin(x) series: The advantage of lseries() over nseries() is that many times you are just interested in the next term in the series (i.e. the first term for example), but you do not know how many you should ask for in nseries() using the “n” parameter. Wrapper to _eval_nseries if assumptions allow, else to series. If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is called. This calculates “n” terms in the innermost expressions and then builds up the final series just by “cross-multiplying” everything out. The optional parameter can be used to replace any log(x) in the returned series with a symbolic value to avoid evaluating log(x) at 0. A symbol to use in place of log(x) should be provided. Advantage – it’s fast, because we do not have to determine how many terms we need to calculate in advance. Disadvantage – you may end up with less terms than you may have expected, but the O(x**n) term appended will always be correct and so the result, though perhaps shorter, will also be correct. If any of those assumptions is not met, this is treated like a wrapper to series which will try harder to return the correct number of terms. Handling of the parameter — in the following example the expansion fails since does not have an asymptotic expansion at -oo (the limit of log(x) as x approaches 0): In the following example, the expansion works but only returns self unless the parameter is used: See the nsimplify function in sympy.simplify See the powsimp function in sympy.simplify Return the positive Rational that can be extracted non-recursively from every term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul() method but primitive always extracts a positive Rational (never a negative or a Float). See the radsimp function in sympy.simplify See the ratsimp function in sympy.simplify Removes the additive O(..) symbol if there is one Return x rounded to the given decimal place. If a complex number would results, apply round to the real and imaginary components of the number. The Python function uses the SymPy method so it will always return a SymPy number (not a Python float or int): See the separate function in sympy.simplify Series expansion of “self” around yielding either terms of the series one by one (the lazy series given when n=None), else all the terms at once when n != None. Returns the series expansion of “self” around the point with respect to up to (default n is 6). If and is univariate, the univariate symbol will be supplied, otherwise an error will be raised. The expression whose series is to be expanded. It is the variable of the expression to be calculated. The value around which is calculated. Can be any value from to . The value used to represent the order in terms of , up to which the series is to be expanded. The series-expansion can be bi-directional. If , then (x->x0+). If ( or ), the argument is determined from the direction of the infinity (i.e., for ). It is used to replace any log(x) in the returned series with a symbolic value rather than evaluating the actual value. It stands for complex direction, and indicates the direction from which the expansion needs to be evaluated. Series expansion of the expression about x0 If “n” and “x0” are infinity objects If “x0” is an infinity object If then a generator of the series terms will be returned. For (default) the series is calculated from the right and for the series from the left. For smooth functions this flag will not alter the results. For rational expressions this method may return original expression without the Order term. >>> (1/x).series(x, n=8) 1/x This method is slow, because it differentiates n-times. Subclasses can redefine it to make it faster by using the “previous_terms”. See the together function in sympy.polys See the trigsimp function in sympy.simplify Expression that is not evaluated unless released. A parent class for object which are both atoms and Exprs. For example: Symbol, Number, Rational, Integer, … But not: Add, Mul, Pow, …\n\nFloating point numbers are represented by the Float class. Rational numbers (of any size) are represented by the Rational class. Integer numbers (of any size) are represented by the Integer class. Float and Rational are subclasses of Number; Integer is a subclass of Rational. For example, is represented as which is a different object from the floating point number obtained with Python division . Even for numbers that are exactly represented in binary, there is a difference between how two forms, such as and , are used in SymPy. The rational form is to be preferred in symbolic computations. Other kinds of numbers, such as algebraic numbers or complex numbers , are not instances of Number class as they are not atomic. Compute GCD and cofactors of \\(self\\) and \\(other\\). Compute GCD of \\(self\\) and \\(other\\). Compute LCM of \\(self\\) and \\(other\\). Creating Floats from strings (and Python and types) will give a minimum precision of 15 digits, but the precision will automatically increase to capture all digits entered. However, floating-point numbers (Python types) retain only 15 digits of precision: It may be preferable to enter high-precision decimal numbers as strings: The desired number of digits can also be specified: Float can automatically count significant figures if a null string is sent for the precision; spaces or underscores are also allowed. (Auto- counting is only allowed for strings, ints and longs). If a number is written in scientific notation, only the digits before the exponent are considered significant if a decimal appears, otherwise the “e” signifies only how to move the decimal: Floats are inexact by their nature unless their value is a binary-exact value. For calculation purposes, evalf needs to be able to change the precision but this will not increase the accuracy of the inexact value. The following is the most accurate 5-digit approximation of a value of 0.1 that had only 1 digit of precision: By contrast, 0.125 is exact in binary (as it is in base 10) and so it can be passed to Float or evalf to obtain an arbitrary precision with matching accuracy: Trying to make a high-precision Float from a float is not disallowed, but one must keep in mind that the underlying float (not the apparent decimal value) is being obtained with high precision. For example, 0.3 does not have a finite binary representation. The closest rational is the fraction 5404319552844595/2**54. So if you try to obtain a Float of 0.3 to 20 digits of precision you will not see the same thing as 0.3 followed by 19 zeros: If you want a 20-digit value of the decimal 0.3 (not the floating point approximation of 0.3) you should send the 0.3 as a string. The underlying representation is still binary but a higher precision than Python’s float is used: Although you can increase the precision of an existing Float using Float it will not increase the accuracy – the underlying value is not changed: The same thing happens when evalf is used on a Float: Finally, Floats can be instantiated with an mpf tuple (n, c, p) to produce the number (-1)**n*c*2**p: An actual mpf tuple also contains the number of bits in c as the last element of the tuple: This is not needed for instantiation and is not the same thing as the precision. The mpf tuple and the precision are two separate quantities that Float tracks. In SymPy, a Float is a number that can be computed with arbitrary precision. Although floating point ‘inf’ and ‘nan’ are not such numbers, Float can create these numbers: Zero in Float only has a single value. Values are not separate for positive and negative zeroes. Rational is unprejudiced in accepting input. If a float is passed, the underlying value of the binary representation will be returned: If the simpler representation of the float is desired then consider limiting the denominator to the desired value or convert the float to a string (which is roughly equivalent to limiting the denominator to 10**12): An arbitrarily precise Rational is obtained when a string literal is passed: The conversion of other types of strings can be handled by the sympify() function, and conversion of floats to expressions or simple fractions can be handled with nsimplify: But if the input does not reduce to a literal Rational, an error will be raised: Access numerator and denominator as .p and .q: Note that p and q return integers (not SymPy Integers) so some care is needed when using them in expressions: If an unevaluated Rational is desired, can be passed and this will keep common divisors of the numerator and denominator from being eliminated. It is not possible, however, to leave a negative value in the denominator. Return the tuple (R, self/R) where R is the positive Rational extracted from self. See docstring of Expr.as_content_primitive for more examples. A wrapper to factorint which return factors of self that are smaller than limit (or cheap to compute). Special methods of factoring are disabled by default so that only trial division is used. Closest Rational to self with denominator at most max_denominator. If a float or a rational is passed to Integer, the fractional part will be discarded; the effect is of rounding toward zero. A string is acceptable input if it can be parsed as an integer: It is rarely needed to explicitly instantiate an Integer, because Python integers are automatically converted to Integer when they are used in SymPy expressions. Symbolically, an instance of this class represents an element \\(\\alpha \\in \\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}\\). That is, the algebraic number \\(\\alpha\\) is represented as an element of a particular number field \\(\\mathbb{Q}(\\theta)\\), with a particular embedding of this field into the complex numbers. Formally, the primitive element \\(\\theta\\) is given by two data points: (1) its minimal polynomial (which defines \\(\\mathbb{Q}(\\theta)\\)), and (2) a particular complex number that is a root of this polynomial (which defines the embedding \\(\\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}\\)). Finally, the algebraic number \\(\\alpha\\) which we represent is then given by the coefficients of a polynomial in \\(\\theta\\). There are four instance attributes to be determined: See Parameters section for how they are determined. There are three distinct modes of construction, depending on what is passed as expr. (1) expr is an : In this case we begin by copying all four instance attributes from expr. If coeffs were also given, we compose the two coeff polynomials (see below). If an alias was given, it overrides. (2) expr is any other type of : Then will equal expr. Therefore it must express an algebraic quantity, and we will compute its . (3) expr is an ordered pair \\((m, r)\\) giving the \\(m\\), and a \\(r\\) thereof, which together define \\(\\theta\\). In this case \\(m\\) may be either a univariate or any which represents the same, while \\(r\\) must be some representing a complex number that is a root of \\(m\\), including both explicit expressions in radicals, and instances of or . This defines , giving the algebraic number \\(\\alpha\\) as a polynomial in \\(\\theta\\). If a list, the elements should be integers or rational numbers. If an , we take its coefficients (using its method). If , then the list of coefficients defaults to , meaning that \\(\\alpha = \\theta\\) is the primitive element of the field. If expr was an , let \\(g(x)\\) be its polynomial, and let \\(f(x)\\) be the polynomial defined by coeffs. Then will represent the composition \\((f \\circ g)(x)\\). This is a way to provide a name for the primitive element. We described several ways in which the expr argument can define the value of the primitive element, but none of these methods gave it a name. Here, for example, alias could be set as , in order to make this symbol appear when \\(\\alpha\\) is printed, or rendered as a polynomial, using the method. Recall that we are constructing an algebraic number as a field element \\(\\alpha \\in \\mathbb{Q}(\\theta)\\). Example (2): \\(\\alpha = 3 \\sqrt{2} - 5\\), \\(\\theta = \\sqrt{2}\\). We can either build on the last example: Example (3): \\(\\alpha = 6 \\sqrt{2} - 11\\), \\(\\theta = \\sqrt{2}\\). Again we can build on the previous example, and we see that the coeff polys are composed: Example (4): \\(\\alpha = \\sqrt{2}\\), \\(\\theta = \\sqrt{2} + \\sqrt{3}\\). The easiest way is to use the function: but if you already knew the right coefficients, you could construct it directly: Example (5): Construct the Golden Ratio as an element of the 5th cyclotomic field, supposing we already know its coefficients. This time we introduce the alias \\(\\zeta\\) for the primitive element of the field: Example (6): Building on the last example, construct the number \\(2 \\phi \\in \\mathbb{Q}(\\phi)\\), where \\(\\phi\\) is the Golden Ratio: Note that we needed to use , since passing as the first argument would have constructed the number \\(2 \\phi\\) as an element of the field \\(\\mathbb{Q}(\\zeta)\\): Returns all SymPy coefficients of an algebraic number. Form another element of the same number field. Like the coeffs arg to the class , defines the new element as a polynomial in the primitive element. If a list, the elements should be integers or rational numbers. If an , we take its coefficients (using its method). If we represent \\(\\alpha \\in \\mathbb{Q}(\\theta)\\), form another element \\(\\beta \\in \\mathbb{Q}(\\theta)\\) of the same number field. Say whether this algebraic number \\(\\alpha \\in \\mathbb{Q}(\\theta)\\) is equal to the primitive element \\(\\theta\\) for its field. Compute the minimal polynomial for this algebraic number. Recall that we represent an element \\(\\alpha \\in \\mathbb{Q}(\\theta)\\). Our instance attribute is the minimal polynomial for our primitive element \\(\\theta\\). This method computes the minimal polynomial for \\(\\alpha\\). Returns all native coefficients of an algebraic number. Get the primitive element \\(\\theta\\) for the number field \\(\\mathbb{Q}(\\theta)\\) to which this algebraic number \\(\\alpha\\) belongs. Convert to an instance that is equal to its own primitive element. If , then we will try to return an whose is an expression in radicals. If that is not possible (or if radicals is ), will be a . If we represent \\(\\alpha \\in \\mathbb{Q}(\\theta)\\), \\(\\alpha \n\neq \\theta\\), construct a new that represents \\(\\alpha \\in \\mathbb{Q}(\\alpha)\\). The represents the number \\(\\sqrt{2}\\) in the field \\(\\mathbb{Q}(\\sqrt{2} + \\sqrt{3})\\). Rendering as a polynomial, reflects the fact that \\(\\sqrt{2} = \\theta^3/2 - 9 \\theta/2\\), where \\(\\theta = \\sqrt{2} + \\sqrt{3}\\). is not equal to its own primitive element. Its minpoly we obtain an whose is that of the number itself. Convert to an that is not an , specifically, either a , or, optionally and where possible, an expression in radicals. If , then we will try to return the root as an expression in radicals. If that is not possible, we will return a . If the minimal polynomial for \\(self\\) has been pre-computed, it can be passed in order to save time. Return an interval with number_cls endpoints that contains the value of NumberSymbol. If not implemented, then return None. Should SymPy raise an exception on 0/0 or return a nan? Zero is a singleton, and can be accessed by One is a singleton, and can be accessed by . NegativeOne is a singleton, and can be accessed by . Half is a singleton, and can be accessed by . This serves as a place holder for numeric values that are indeterminate. Most operations on NaN, produce another NaN. Most indeterminate forms, such as or and , which all produce (this is consistent with Python’s float). NaN is loosely related to floating point nan, which is defined in the IEEE 754 floating point standard, and corresponds to the Python . Differences are noted below. NaN is mathematically not equal to anything else, even NaN itself. This explains the initially counter-intuitive results with and in the examples below. NaN is not comparable so inequalities raise a TypeError. This is in contrast with floating point nan where all inequalities are false. NaN is a singleton, and can be accessed by , or can be imported as . In real analysis the symbol \\(\\infty\\) denotes an unbounded limit: \\(x\\to\\infty\\) means that \\(x\\) grows without bound. Infinity is often used not only to define a limit but as a value in the affinely extended real number system. Points labeled \\(+\\infty\\) and \\(-\\infty\\) can be added to the topological space of the real numbers, producing the two-point compactification of the real numbers. Adding algebraic properties to this gives us the extended real numbers. Infinity is a singleton, and can be accessed by , or can be imported as . NegativeInfinity is a singleton, and can be accessed by . In complex analysis the symbol \\(\\tilde\\infty\\), called “complex infinity”, represents a quantity with infinite magnitude, but undetermined complex phase. ComplexInfinity is a singleton, and can be accessed by , or can be imported as . The transcendental number \\(e = 2.718281828\\ldots\\) is the base of the natural logarithm and of the exponential function, \\(e = \\exp(1)\\). Sometimes called Euler’s number or Napier’s constant. Exp1 is a singleton, and can be accessed by , or can be imported as . I is a singleton, and can be accessed by , or can be imported as . The transcendental number \\(\\pi = 3.141592654\\ldots\\) represents the ratio of a circle’s circumference to its diameter, the area of the unit circle, the half-period of trigonometric functions, and many other things in mathematics. Pi is a singleton, and can be accessed by , or can be imported as . \\(\\gamma = 0.5772157\\ldots\\) (also called Euler’s constant) is a mathematical constant recurring in analysis and number theory. It is defined as the limiting difference between the harmonic series and the natural logarithm: EulerGamma is a singleton, and can be accessed by . \\(G = 0.91596559\\ldots\\) is given by the infinite series Catalan is a singleton, and can be accessed by . \\(\\phi = \\frac{1 + \\sqrt{5}}{2}\\) is an algebraic number. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities, i.e. their maximum. GoldenRatio is a singleton, and can be accessed by . The tribonacci numbers are like the Fibonacci numbers, but instead of starting with two predetermined terms, the sequence starts with three predetermined terms and each term afterwards is the sum of the preceding three terms. The tribonacci constant is the ratio toward which adjacent tribonacci numbers tend. It is a root of the polynomial \\(x^3 - x^2 - x - 1 = 0\\), and also satisfies the equation \\(x + x^{-3} = 2\\). TribonacciConstant is a singleton, and can be accessed by . Return the number \\(c\\) such that, \\(a \\times c = 1 \\pmod{m}\\) where \\(c\\) has the same sign as \\(m\\). If no such value exists, a ValueError is raised. Suppose we wish to find multiplicative inverse \\(x\\) of 3 modulo 11. This is the same as finding \\(x\\) such that \\(3x = 1 \\pmod{11}\\). One value of x that satisfies this congruence is 4. Because \\(3 \\times 4 = 12\\) and \\(12 = 1 \\pmod{11}\\). This is the value returned by : When there is a common factor between the numerators of \\(a\\) and \\(m\\) the inverse does not exist: : inverse of 2 mod 4 does not exist In SymPy expressions with Floats compare unequal to corresponding expressions with rationals: However an individual Float compares equal to a Rational: In a future version of SymPy this might change so that Rational and Float compare unequal. This function provides the behavior currently expected of so that it could still be used if the behavior of were to change in future. In future SymPy verions Float and Rational might compare unequal and floats with different precisions might compare unequal. In that context a function is needed that can check if a number is equal to 1 or 0 etc. The idea is that instead of testing if we want to accept floats like as well then the test can be written as or . Since this function is intended to be used in situations where one or both operands are expected to be concrete numbers like 1 or 0 the function does not recurse through the args of any compound expression to compare any nested floats.\n\nIndicates what subclass to instantiate. Valid values can be found in the keys of Relational.ValidRelationOperator. Subclasses of Relational should generally be instantiated directly, but Relational can be instantiated with a valid value to dispatch to the appropriate subclass. A relation’s type can be defined upon creation using . The relation type of an existing expression can be obtained using its property. Here is a table of all the relation types, along with their and values: For example, setting to produces an relation, . So does setting to , or leaving unspecified. That is, the first three below all produce the same result. Using a from a different row in the table produces a different relation type. For example, the fourth below using for produces a inequality: To obtain the relation type of an existing expression, get its property. For example, is for the relation above, and for the strict less than inequality above: Return a canonical form of the relational by putting a number on the rhs, canonically removing a sign or else ordering the args canonically. No other simplification is attempted. Return True if the sides of the relationship are mathematically identical and the type of relationship is the same. If failing_expression is True, return the expression whose truth value was unknown. The left-hand side of the relation. This works more or less identical to / . The difference is that returns the relationship even if . Hence, this is useful in code when checking for e.g. negated relations to existing ones as it will not be affected by the \\(evaluate\\) flag. The right-hand side of the relation. return the strict version of the inequality or self return the non-strict version of the inequality or self An equal relation between two objects. Represents that two objects are equal. If they can be easily shown to be definitively equal (or unequal), this will reduce to True (or False). Otherwise, the relation is maintained as an unevaluated Equality object. Use the function on this object for more nontrivial evaluation of the equality relation. As usual, the keyword argument can be used to prevent any evaluation. Python treats 1 and True (and 0 and False) as being equal; SymPy does not. And integer will always compare as unequal to a Boolean: This class is not the same as the == operator. The == operator tests for exact structural equality between two expressions; this class compares expressions mathematically. If either object defines an method, it can be used in place of the default algorithm. If or returns anything other than None, that return value will be substituted for the Equality. If None is returned by , an Equality object will be created as usual. Since this object is already an expression, it does not respond to the method if one tries to create \\(x - y\\) from . If then write \\(eq.lhs - eq.rhs\\) to get . Deprecated since version 1.5: with a single argument is a shorthand for , but this behavior is deprecated and will be removed in a future version of SymPy. for representing equality between two boolean expressions See the integrate function in sympy.integrals The classes represent inequal relationships, where the left-hand side is generally bigger or smaller than the right-hand side. For example, the GreaterThan class represents an inequal relationship where the left-hand side is at least as big as the right side, if not bigger. In mathematical notation: In total, there are four classes, to represent the four inequalities: All classes take two arguments, lhs and rhs. In addition to the normal .lhs and .rhs of Relations, inequality objects also have the .lts and .gts properties, which represent the “less than side” and “greater than side” of the operator. Use of .lts and .gts in an algorithm rather than .lhs and .rhs as an assumption of inequality direction will make more explicit the intent of a certain section of code, and will make it similarly more robust to client code changes: 'x >= 1 is the same as 1 <= x' One generally does not instantiate these classes directly, but uses various convenience methods: Another option is to use the Python inequality operators ( , , , ) directly. Their main advantage over the , , , and counterparts, is that one can write a more “mathematical looking” statement rather than littering the math with oddball function calls. However there are certain (minor) caveats of which to be aware (search for ‘gotcha’, below). However, it is also perfectly valid to instantiate a class less succinctly and less conveniently: There are a couple of “gotchas” to be aware of when using Python’s operators. The first is that what your write is not always what you get: Due to the order that Python parses a statement, it may not immediately find two objects comparable. When is evaluated, Python recognizes that the number 1 is a native number and that x is not. Because a native Python number does not know how to compare itself with a SymPy object Python will try the reflective operation, and that is the form that gets evaluated, hence returned. If the order of the statement is important (for visual output to the console, perhaps), one can work around this annoyance in a couple ways: (2) use one of the wrappers or less succinct methods described above The second gotcha involves writing equality tests between relationals when one or both sides of the test involve a literal relational: # expecting False or the same thing as before : cannot determine truth value of Relational The solution for this case is to wrap literal relationals in parentheses: The third gotcha involves chained inequalities not involving or . Occasionally, one may be tempted to write: : symbolic boolean expression has no truth value. Due to an implementation detail or decision of Python [R146], there is no way for SymPy to create a chained inequality with that syntax so one must use And: Although this can also be done with the ‘&’ operator, it cannot be done with the ‘and’ operarator: : cannot determine truth value of Relational This implementation detail is that Python provides no reliable method to determine that a chained inequality is being built. Chained comparison operators are evaluated pairwise, using “and” logic (see https://docs.python.org/3/reference/expressions.html#not-in). This is done in an efficient way, so that each object being compared is only evaluated once and the comparison can short-circuit. For example, is evaluated by Python as . The operator coerces each side into a bool, returning the object itself when it short-circuits. The bool of the –Than operators will raise TypeError on purpose, because SymPy cannot determine the mathematical ordering of symbolic expressions. Thus, if we were to compute , with , , and being Symbols, Python converts the statement (roughly) into these steps: Because of the added at step 2, the statement gets turned into a weak ternary statement, and the first object’s method will raise TypeError. Thus, creating a chained inequality is not possible. In Python, there is no way to override the operator, or to control how it short circuits, so it is impossible to make something like work. There was a PEP to change this, PEP 335, but it was officially closed in March, 2012. The classes represent inequal relationships, where the left-hand side is generally bigger or smaller than the right-hand side. For example, the GreaterThan class represents an inequal relationship where the left-hand side is at least as big as the right side, if not bigger. In mathematical notation: In total, there are four classes, to represent the four inequalities: All classes take two arguments, lhs and rhs. In addition to the normal .lhs and .rhs of Relations, inequality objects also have the .lts and .gts properties, which represent the “less than side” and “greater than side” of the operator. Use of .lts and .gts in an algorithm rather than .lhs and .rhs as an assumption of inequality direction will make more explicit the intent of a certain section of code, and will make it similarly more robust to client code changes: 'x >= 1 is the same as 1 <= x' One generally does not instantiate these classes directly, but uses various convenience methods: Another option is to use the Python inequality operators ( , , , ) directly. Their main advantage over the , , , and counterparts, is that one can write a more “mathematical looking” statement rather than littering the math with oddball function calls. However there are certain (minor) caveats of which to be aware (search for ‘gotcha’, below). However, it is also perfectly valid to instantiate a class less succinctly and less conveniently: There are a couple of “gotchas” to be aware of when using Python’s operators. The first is that what your write is not always what you get: Due to the order that Python parses a statement, it may not immediately find two objects comparable. When is evaluated, Python recognizes that the number 1 is a native number and that x is not. Because a native Python number does not know how to compare itself with a SymPy object Python will try the reflective operation, and that is the form that gets evaluated, hence returned. If the order of the statement is important (for visual output to the console, perhaps), one can work around this annoyance in a couple ways: (2) use one of the wrappers or less succinct methods described above The second gotcha involves writing equality tests between relationals when one or both sides of the test involve a literal relational: # expecting False or the same thing as before : cannot determine truth value of Relational The solution for this case is to wrap literal relationals in parentheses: The third gotcha involves chained inequalities not involving or . Occasionally, one may be tempted to write: : symbolic boolean expression has no truth value. Due to an implementation detail or decision of Python [R147], there is no way for SymPy to create a chained inequality with that syntax so one must use And: Although this can also be done with the ‘&’ operator, it cannot be done with the ‘and’ operarator: : cannot determine truth value of Relational This implementation detail is that Python provides no reliable method to determine that a chained inequality is being built. Chained comparison operators are evaluated pairwise, using “and” logic (see https://docs.python.org/3/reference/expressions.html#not-in). This is done in an efficient way, so that each object being compared is only evaluated once and the comparison can short-circuit. For example, is evaluated by Python as . The operator coerces each side into a bool, returning the object itself when it short-circuits. The bool of the –Than operators will raise TypeError on purpose, because SymPy cannot determine the mathematical ordering of symbolic expressions. Thus, if we were to compute , with , , and being Symbols, Python converts the statement (roughly) into these steps: Because of the added at step 2, the statement gets turned into a weak ternary statement, and the first object’s method will raise TypeError. Thus, creating a chained inequality is not possible. In Python, there is no way to override the operator, or to control how it short circuits, so it is impossible to make something like work. There was a PEP to change this, PEP 335, but it was officially closed in March, 2012. An unequal relation between two objects. Represents that two objects are not equal. If they can be shown to be definitively equal, this will reduce to False; if definitively unequal, this will reduce to True. Otherwise, the relation is maintained as an Unequality object. This class is not the same as the != operator. The != operator tests for exact structural equality between two expressions; this class compares expressions mathematically. This class is effectively the inverse of Equality. As such, it uses the same algorithms, including any available \\(_eval_Eq\\) methods. The classes represent inequal relationships, where the left-hand side is generally bigger or smaller than the right-hand side. For example, the GreaterThan class represents an inequal relationship where the left-hand side is at least as big as the right side, if not bigger. In mathematical notation: In total, there are four classes, to represent the four inequalities: All classes take two arguments, lhs and rhs. In addition to the normal .lhs and .rhs of Relations, inequality objects also have the .lts and .gts properties, which represent the “less than side” and “greater than side” of the operator. Use of .lts and .gts in an algorithm rather than .lhs and .rhs as an assumption of inequality direction will make more explicit the intent of a certain section of code, and will make it similarly more robust to client code changes: 'x >= 1 is the same as 1 <= x' One generally does not instantiate these classes directly, but uses various convenience methods: Another option is to use the Python inequality operators ( , , , ) directly. Their main advantage over the , , , and counterparts, is that one can write a more “mathematical looking” statement rather than littering the math with oddball function calls. However there are certain (minor) caveats of which to be aware (search for ‘gotcha’, below). However, it is also perfectly valid to instantiate a class less succinctly and less conveniently: There are a couple of “gotchas” to be aware of when using Python’s operators. The first is that what your write is not always what you get: Due to the order that Python parses a statement, it may not immediately find two objects comparable. When is evaluated, Python recognizes that the number 1 is a native number and that x is not. Because a native Python number does not know how to compare itself with a SymPy object Python will try the reflective operation, and that is the form that gets evaluated, hence returned. If the order of the statement is important (for visual output to the console, perhaps), one can work around this annoyance in a couple ways: (2) use one of the wrappers or less succinct methods described above The second gotcha involves writing equality tests between relationals when one or both sides of the test involve a literal relational: # expecting False or the same thing as before : cannot determine truth value of Relational The solution for this case is to wrap literal relationals in parentheses: The third gotcha involves chained inequalities not involving or . Occasionally, one may be tempted to write: : symbolic boolean expression has no truth value. Due to an implementation detail or decision of Python [R148], there is no way for SymPy to create a chained inequality with that syntax so one must use And: Although this can also be done with the ‘&’ operator, it cannot be done with the ‘and’ operarator: : cannot determine truth value of Relational This implementation detail is that Python provides no reliable method to determine that a chained inequality is being built. Chained comparison operators are evaluated pairwise, using “and” logic (see https://docs.python.org/3/reference/expressions.html#not-in). This is done in an efficient way, so that each object being compared is only evaluated once and the comparison can short-circuit. For example, is evaluated by Python as . The operator coerces each side into a bool, returning the object itself when it short-circuits. The bool of the –Than operators will raise TypeError on purpose, because SymPy cannot determine the mathematical ordering of symbolic expressions. Thus, if we were to compute , with , , and being Symbols, Python converts the statement (roughly) into these steps: Because of the added at step 2, the statement gets turned into a weak ternary statement, and the first object’s method will raise TypeError. Thus, creating a chained inequality is not possible. In Python, there is no way to override the operator, or to control how it short circuits, so it is impossible to make something like work. There was a PEP to change this, PEP 335, but it was officially closed in March, 2012. The classes represent inequal relationships, where the left-hand side is generally bigger or smaller than the right-hand side. For example, the GreaterThan class represents an inequal relationship where the left-hand side is at least as big as the right side, if not bigger. In mathematical notation: In total, there are four classes, to represent the four inequalities: All classes take two arguments, lhs and rhs. In addition to the normal .lhs and .rhs of Relations, inequality objects also have the .lts and .gts properties, which represent the “less than side” and “greater than side” of the operator. Use of .lts and .gts in an algorithm rather than .lhs and .rhs as an assumption of inequality direction will make more explicit the intent of a certain section of code, and will make it similarly more robust to client code changes: 'x >= 1 is the same as 1 <= x' One generally does not instantiate these classes directly, but uses various convenience methods: Another option is to use the Python inequality operators ( , , , ) directly. Their main advantage over the , , , and counterparts, is that one can write a more “mathematical looking” statement rather than littering the math with oddball function calls. However there are certain (minor) caveats of which to be aware (search for ‘gotcha’, below). However, it is also perfectly valid to instantiate a class less succinctly and less conveniently: There are a couple of “gotchas” to be aware of when using Python’s operators. The first is that what your write is not always what you get: Due to the order that Python parses a statement, it may not immediately find two objects comparable. When is evaluated, Python recognizes that the number 1 is a native number and that x is not. Because a native Python number does not know how to compare itself with a SymPy object Python will try the reflective operation, and that is the form that gets evaluated, hence returned. If the order of the statement is important (for visual output to the console, perhaps), one can work around this annoyance in a couple ways: (2) use one of the wrappers or less succinct methods described above The second gotcha involves writing equality tests between relationals when one or both sides of the test involve a literal relational: # expecting False or the same thing as before : cannot determine truth value of Relational The solution for this case is to wrap literal relationals in parentheses: The third gotcha involves chained inequalities not involving or . Occasionally, one may be tempted to write: : symbolic boolean expression has no truth value. Due to an implementation detail or decision of Python [R149], there is no way for SymPy to create a chained inequality with that syntax so one must use And: Although this can also be done with the ‘&’ operator, it cannot be done with the ‘and’ operarator: : cannot determine truth value of Relational This implementation detail is that Python provides no reliable method to determine that a chained inequality is being built. Chained comparison operators are evaluated pairwise, using “and” logic (see https://docs.python.org/3/reference/expressions.html#not-in). This is done in an efficient way, so that each object being compared is only evaluated once and the comparison can short-circuit. For example, is evaluated by Python as . The operator coerces each side into a bool, returning the object itself when it short-circuits. The bool of the –Than operators will raise TypeError on purpose, because SymPy cannot determine the mathematical ordering of symbolic expressions. Thus, if we were to compute , with , , and being Symbols, Python converts the statement (roughly) into these steps: Because of the added at step 2, the statement gets turned into a weak ternary statement, and the first object’s method will raise TypeError. Thus, creating a chained inequality is not possible. In Python, there is no way to override the operator, or to control how it short circuits, so it is impossible to make something like work. There was a PEP to change this, PEP 335, but it was officially closed in March, 2012.\n\nLambda(x, expr) represents a lambda function similar to Python’s ‘lambda x: expr’. A function of several variables is written as Lambda((x, y, …), expr). It is also possible to unpack tuple arguments: The variables used in the internal representation of the function The return value of the function Return if this is an identity function. The expected form of the arguments to be unpacked into variables The variables used in the internal representation of the function A WildFunction function matches any function (with its arguments). To match functions with a given number of arguments, set to the desired value at instantiation: To match functions with a range of arguments, set to a tuple containing the desired number of arguments, e.g. if then functions with 1 or 2 arguments will be matched. Carries out differentiation of the given expression with respect to symbols. Denesting of derivatives retains the ordering of variables: Contiguously identical symbols are merged into a tuple giving the symbol and the count: If the derivative cannot be performed, and evaluate is True, the order of the variables of differentiation will be made canonical: Derivatives with respect to undefined functions can be calculated: Such derivatives will show up when the chain rule is used to evalulate a derivative: Substitution is used to represent derivatives of functions with arguments that are not symbols or functions: Because there can be a significant amount of simplification that can be done when multiple differentiations are performed, results will be automatically simplified in a fairly conservative fashion unless the keyword is set to False. If evaluate is set to True and the expression cannot be evaluated, the list of differentiation symbols will be sorted, that is, the expression is assumed to have continuous derivatives up to the order asked. For the most part, one may not differentiate wrt non-symbols. For example, we do not allow differentiation wrt \\(x*y\\) because there are multiple ways of structurally defining where x*y appears in an expression: a very strict definition would make (x*y*z).diff(x*y) == 0. Derivatives wrt defined functions (like cos(x)) are not allowed, either: To make it easier to work with variational calculus, however, derivatives wrt AppliedUndef and Derivatives are allowed. For example, in the Euler-Lagrange method one may write F(t, u, v) where u = f(t) and v = f’(t). These variables can be written explicitly as functions of time: The derivative wrt f(t) can be obtained directly: When differentiation wrt a non-Symbol is attempted, the non-Symbol is temporarily converted to a Symbol while the differentiation is performed and the same answer is obtained: The implication of this non-symbol replacement is that all functions are treated as independent of other functions and the symbols are independent of the functions that contain them: It also means that derivatives are assumed to depend only on the variables of differentiation, not on anything contained within the expression being differentiated: The last example can be made explicit by showing the replacement of Fx in Fxx with y: Since that in itself will evaluate to zero, differentiating wrt Fx will also be zero: One must be careful to replace undefined functions with expressions that contain variables consistent with the function definition and the variables of differentiation or else insconsistent result will be obtained. Consider the following example: The results differ because \\(f(x)\\) was replaced with an expression that involved both variables of differentiation. In the abstract case, differentiation of \\(f(x)\\) by \\(y\\) is 0; in the concrete case, the presence of \\(y\\) made that derivative nonvanishing and produced the extra \\(g(y)\\) term. An object must define ._eval_derivative(symbol) method that returns the differentiation result. This function only needs to consider the non-trivial case where expr contains symbol and it should call the diff() method internally (not _eval_derivative); Derivative should be the only one to call _eval_derivative. Any class can allow derivatives to be taken with respect to itself (while indicating its scalar nature). See the docstring of Expr._diff_wrt. An expression may be differentiated wrt a Derivative if it is in elementary form. A Derivative might be an unevaluated form of what will not be a valid variable of differentiation if evaluated. For example, Such an expression will present the same ambiguities as arise when dealing with any other product, like , so is False: Sort (variable, count) pairs into canonical order while retaining order of variables that do not commute during differentiation:\n• None symbols and functions commute with each other\n• None derivatives commute with each other\n• None a derivative does not commute with anything it contains\n• None any other object is not allowed to commute if it has free symbols in common with another object Contiguous items are collapsed into one pair: Symbols are sorted as far to the left as possible but never move to the left of a derivative having the same symbol in its variables; the same applies to AppliedUndef which are always sorted after Symbols: If sequence: discrete values (length >= order+1) of the independent variable used for generating the finite difference weights. If it is a coefficient, it will be used as the step-size for generating an equidistant sequence of length order+1 centered around . Default: 1 (step-size 1) the value of the independent variable ( ) at which the derivative is to be approximated. Default: same as . “with respect to” the variable for which the (partial) derivative is to be approximated for. If not provided it is required that the derivative is ordinary. Default: . The default step size and number of points are 1 and respectively. We can change the step size by passing a symbol as a parameter: We can also specify the discretized values to be used in a sequence: The algorithm is not restricted to use equidistant spacing, nor do we need to make the approximation around , but we can get an expression estimating the derivative at an offset: To approximate around using a non-equidistant spacing step, the algorithm supports assignment of undefined functions to : We can apply to instances in compound expressions using : When we can represent derivatives at a point, this should be folded into the normal evalf. For now, we need a special method. This is just a wrapper to unify .diff() and the Derivative class; its interface is similar to that of integrate(). You can use the same shortcuts for multiple variables as with Derivative. For example, diff(f(x), x, x, x) and diff(f(x), x, 3) both return the third derivative of f(x). You can pass evaluate=False to get an unevaluated Derivative class. Note that if there are 0 symbols (such as diff(f(x), x, 0), then the result will be the function (the zeroth derivative), even if evaluate=False. Note that syntax is meant only for convenience in interactive sessions and should be avoided in library code. Base class for function classes. FunctionClass is a subclass of type. Return a set of the allowed number of arguments for the function. If the function can take any number of arguments, the set of whole numbers is returned: If the function was initialized to accept one or more arguments, a corresponding set will be returned: The undefined function, after application, also has the nargs attribute; the actual number of arguments is always available by checking the attribute: It also serves as a constructor for undefined function classes. See the Writing Custom Functions guide for details on how to subclass and what methods can be defined. To create an undefined function, pass a string of the function name to . Assumptions can be passed to the same as with a . Alternatively, you can use a with assumptions for the function name and the function will inherit the name and assumptions associated with the : Note that assumptions on a function are unrelated to the assumptions on the variables it is called on. If you want to add a relationship, subclass and define custom assumptions handler methods. See the Assumptions section of the Writing Custom Functions guide for more details. The Writing Custom Functions guide has several Complete Examples of how to subclass to create a custom function. Returns the method as the 2-tuple (base, exponent). Returns the first derivative of the function. Tests whether the argument is an essential singularity or a branch point, or the functions is non-holomorphic. Not all functions are the same SymPy defines many functions (like and ). It also allows the user to create generic functions which act as argument holders. Such functions are created just like symbols: If you want to see which functions appear in an expression you can use the atoms method: If you just want the function you defined, not SymPy functions, the thing to search for is AppliedUndef: represents the expression resulting from substituting x with x0 in expr. A point or list of evaluation points corresponding to those variables. Subs are created when a particular substitution cannot be made. The x in the derivative cannot be replaced with 0 because 0 is not a valid variables of differentiation: Once f is known, the derivative and evaluation at 0 can be done: Subs can also be created directly with one or more variables: objects are generally useful to represent unevaluated derivatives calculated at a point. The variables may be expressions, but they are subjected to the limitations of subs(), so it is usually a good practice to use only symbols for variables, since in that case there can be no ambiguity. There’s no automatic expansion - use the method .doit() to effect all possible substitutions of the object and also of objects inside the expression. When evaluating derivatives at a point that is not a symbol, a Subs object is returned. One is also able to calculate derivatives of Subs objects - in this case the expression is always expanded (for the unevaluated form, use Derivative()). In order to allow expressions to combine before doit is done, a representation of the Subs expression is used internally to make expressions that are superficially different compare the same: This can lead to unexpected consequences when using methods like \\(has\\) that are cached: The variables to be evaluated The expression on which the substitution operates The values for which the variables are to be substituted The variables to be evaluated Expand an expression using methods given as hints. Hints evaluated unless explicitly set to False are: , , , , , and The following hints are supported but not applied unless set to True: , , and . In addition, the following meta-hints are supported by some or all of the other hints: , , , , and . is supported by all hints. Additionally, subclasses of Expr may define their own hints or meta-hints. The hint is used for any special rewriting of an object that should be done automatically (along with the other hints like ) when expand is called. This is a catch-all hint to handle any sort of expansion that may not be described by the existing hint names. To use this hint an object should override the method. Objects may also define their own expand methods, which are not run by default. See the API section below. If is set to (the default), things like arguments of functions are recursively expanded. Use to only expand on the top level. If the hint is used, assumptions about variables will be ignored in making the expansion. These hints are run by default This only happens by default if assumptions allow, or if the meta-hint is used: Note that in some cases where this expansion always holds, SymPy performs it automatically: Pull out power of an argument as a coefficient and split logs products into sums of logs. Note that these only work if the arguments of the log function have the proper assumptions–the arguments must be positive and the exponents must be real–or else the hint must be True: This hint is intended primarily as a way for custom subclasses to enable expansion by default. These hints are not run by default: Split an expression into real and imaginary parts. Note that this is just a wrapper around . Most objects that wish to redefine should consider redefining instead. Note that the forms of and in terms of and are not unique, due to the identity \\(\\sin^2(x) + \\cos^2(x) = 1\\). The current implementation uses the form obtained from Chebyshev polynomials, but this may change. See this MathWorld article for more information.\n• None You can shut off unwanted methods:\n• None Use deep=False to only expand on the top level:\n• None Hints are applied in an arbitrary, but consistent order (in the current implementation, they are applied in alphabetical order, except multinomial comes before mul, but this may change). Because of this, some hints may prevent expansion by other hints if they are applied first. For example, may distribute multiplications and prevent and from expanding them. Also, if is applied before multinomial`, the expression might not be fully distributed. The solution is to use the various ``expand_hint helper functions or to use to this function to finely control which hints are applied. Here are some examples: Here, we see that was applied before . To get the mul expanded form, either of the following will work: A similar thing can happen with the hint: To get the expanded form, either of the following will work: The parts of a rational expression can be targeted:\n• None The meta-hint can be used to reduce the coefficients of an expression post-expansion:\n• None Either the function or the method can be used. Both are equivalent: Objects can define their own expand hints by defining . The function should take the form: # Only apply the method to the top-level expression See also the example below. Objects should define methods only if applies to that specific object. The generic method defined in Expr will handle the no-op case. Each hint should be responsible for expanding that hint only. Furthermore, the expansion should be applied to the top-level expression only. takes care of the recursion that happens when . You should only call methods directly if you are 100% sure that the object has the method, as otherwise you are liable to get unexpected AttributeError``s. Note, again, that you do not need to recursively apply the hint to args of your object: this is handled automatically by ``expand() . should generally not be used at all outside of an method. If you want to apply a specific expansion from within another method, use the public function, method, or functions. In order for expand to work, objects must be rebuildable by their args, i.e., must hold. Expand methods are passed so that expand hints may use ‘metahints’–hints that control how different expand methods are applied. For example, the hint described above that causes to ignore assumptions is such a metahint. The meta-hint is handled exclusively by and is not passed to methods. Note that expansion hints should generally be methods that perform some kind of ‘expansion’. For hints that simply rewrite an expression, use the .rewrite() API. If there more than four args, doubling is not performed, unless force=True is also used (False by default). Return a representation (integer or expression) of the operations in expr. If expr is an iterable, the sum of the op counts of the items will be returned. If (default) then the sum of the coefficients of the visual expression will be returned. If then the number of each type of operation is shown with the core class types (or their virtual equivalent) multiplied by the number of times they occur. Although there is not a SUB object, minus signs are interpreted as either negations or subtractions: Here, there are two Adds and a Pow: In the following, an Add, Mul, Pow and two functions: Note that “what you type” is not always what you get. The expression 1/x/y is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather than two DIVs: The visual option can be used to demonstrate the difference in operations for expressions in different forms. Here, the Horner representation is compared with the expanded form of a polynomial: Wrapper around expand that only uses the mul hint. See the expand docstring for more information. Wrapper around expand that only uses the log hint. See the expand docstring for more information. Wrapper around expand that only uses the func hint. See the expand docstring for more information. Wrapper around expand that only uses the trig hint. See the expand docstring for more information. Wrapper around expand that only uses the complex hint. See the expand docstring for more information. Wrapper around expand that only uses the multinomial hint. See the expand docstring for more information. Wrapper around expand that only uses the power_exp hint. See the expand docstring for more information. If the value of the expression depends on the value of ; if the expression were expanded the result would be 0. So expansion is only done if : Wrapper around expand that only uses the power_base hint. A wrapper to expand(power_base=True) which separates a power with a base that is a Mul into a product of powers, without performing any other expansions, provided that assumptions about the power’s base and exponent allow. deep=False (default is True) will only apply to the top-level expression. force=True (default is False) will cause the expansion to ignore assumptions about the base and exponent. When False, the expansion will only happen if the base is non-negative or the exponent is an integer. Notice that sums are left untouched. If this is not the desired behavior, apply full to the expression: The power that is unexpanded can be expanded safely when , otherwise different values might be obtained for the expression: If we indicate that is positive but then replace it with a value of 0 after expansion, the expression becomes 0: But if the expression would not be zero: Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions. When processing dictionaries, do not modify the keys unless ."
    },
    {
        "link": "https://sandal.tw/upload/sympy-0.7.2-py3k.pdf",
        "document": ""
    },
    {
        "link": "https://docs.sympy.org/latest/modules/evalf.html",
        "document": "Exact SymPy expressions can be converted to floating-point approximations (decimal numbers) using either the method or the function. is equivalent to . By default, numerical evaluation is performed to an accuracy of 15 decimal digits. You can optionally pass a desired accuracy (which should be a positive integer) as an argument to or : If the expression contains symbols or for some other reason cannot be evaluated numerically, calling or returns the original expression, or in some cases a partially evaluated expression. For example, when the expression is a polynomial in expanded form, the coefficients are evaluated: You can also use the standard Python functions , to convert SymPy expressions to regular Python numbers: If these functions are used, failure to evaluate the expression to an explicit number (for example if the expression contains symbols) will raise an exception. There is essentially no upper precision limit. The following command, for example, computes the first 100,000 digits of π/e: This shows digits 999,951 through 1,000,000 of pi: High-precision calculations can be slow. It is recommended (but entirely optional) to install gmpy (https://github.com/aleaxit/gmpy), which will significantly speed up computations such as the one above.\n\nFloating-point numbers in SymPy are instances of the class . A can be created with a custom precision as second argument: As the last example shows, some Python floats are only accurate to about 15 digits as inputs, while others (those that have a denominator that is a power of 2, like 0.125 = 1/8) are exact. To create a from a high-precision decimal number, it is better to pass a string, , or a : The precision of a number determines 1) the precision to use when performing arithmetic with the number, and 2) the number of digits to display when printing the number. When two numbers with different precision are used together in an arithmetic operation, the higher of the precisions is used for the result. The product of 0.1 +/- 0.001 and 3.1415 +/- 0.0001 has an uncertainty of about 0.003 and yet 5 digits of precision are shown. So the displayed precision should not be used as a model of error propagation or significance arithmetic; rather, this scheme is employed to ensure stability of numerical algorithms. and can be used to change the precision of existing floating-point numbers:\n\nWhen the input to or is a complicated expression, numerical error propagation becomes a concern. As an example, consider the 100’th Fibonacci number and the excellent (but not exact) approximation \\(\\varphi^{100} / \\sqrt{5}\\) where \\(\\varphi\\) is the golden ratio. With ordinary floating-point arithmetic, subtracting these numbers from each other erroneously results in a complete cancellation: and keep track of errors and automatically increase the precision used internally in order to obtain a correct result: Unfortunately, numerical evaluation cannot tell an expression that is exactly zero apart from one that is merely very small. The working precision is therefore capped, by default to around 100 digits. If we try with the 1000’th Fibonacci number, the following happens: The lack of digits in the returned number indicates that failed to achieve full accuracy. The result indicates that the magnitude of the expression is something less than 10^84, but that is not a particularly good answer. To force a higher working precision, the keyword argument can be used: Normally, can be set very high (thousands of digits), but be aware that this may cause significant slowdown in extreme cases. Alternatively, the option can be set to force an exception instead of silently returning a value with less than the requested accuracy: : from zero. Try simplifying the input, using chop=True, or providing a higher maxn for evalf If we add a term so that the Fibonacci approximation becomes exact (the full form of Binet’s formula), we get an expression that is exactly zero, but does not know this: In situations where such cancellations are known to occur, the options is useful. This basically replaces very small numbers in the real or imaginary portions of a number with exact zeros: In situations where you wish to remove meaningless digits, re-evaluation or the use of the method are useful: If you are dealing with a numeric expression that contains no floats, it can be evaluated to arbitrary precision. To round the result relative to a given decimal, the round method is useful:\n\nSums (in particular, infinite series) and integrals can be used like regular closed-form expressions, and support arbitrary-precision evaluation: By default, the tanh-sinh quadrature algorithm is used to evaluate integrals. This algorithm is very efficient and robust for smooth integrands (and even integrals with endpoint singularities), but may struggle with integrals that are highly oscillatory or have mid-interval discontinuities. In many cases, / will correctly estimate the error. With the following integral, the result is accurate but only good to four digits: It is better to split this integral into two pieces: A similar example is the following oscillatory integral: It can be dealt with much more efficiently by telling or to use an oscillatory quadrature algorithm: Oscillatory quadrature requires an integrand containing a factor cos(ax+b) or sin(ax+b). Note that many other oscillatory integrals can be transformed to this form with a change of variables: Infinite series use direct summation if the series converges quickly enough. Otherwise, extrapolation methods (generally the Euler-Maclaurin formula but also Richardson extrapolation) are used to speed up convergence. This allows high-precision evaluation of slowly convergent series: The Euler-Maclaurin formula is also used for finite series, allowing them to be approximated quickly without evaluating all terms: Note that makes some assumptions that are not always optimal. For fine-tuned control over numerical summation, it might be worthwhile to manually use the method . Special optimizations are used for rational hypergeometric series (where the term is a product of polynomials, powers, factorials, binomial coefficients and the like). / sum series of this type very rapidly to high precision. For example, this Ramanujan formula for pi can be summed to 10,000 digits in a fraction of a second with a simple command:"
    },
    {
        "link": "https://docs.sympy.org/latest/explanation/best-practices.html",
        "document": "This page outlines some of the best practices for users of SymPy. The best practices here will help avoid some common bugs and pitfalls that can occur when using SymPy.\n\nThis page primarily focuses on best practices that apply generally to all parts of SymPy. Best practices that are specific to certain SymPy submodules or functions are outlined in the documentation for those specific functions.\n• None Define symbols with or . The function is the most convenient way to create symbols. It supports creating one or more symbols at once: It also supports shorthands for defining many numbered symbols at once: The constructor may also be used directly. Unlike , always creates one symbol. It is the best option if you want to make a symbol with unusual characters in its name or if you are creating symbols programmatically. The function should be avoided, except when working interactively. It works like the function, except it automatically injects symbol names into the calling namespace. This function is designed solely for interactive typing convenience and is not recommended for programmatic use. Do not use or to create symbols. This may appear to work: However, / are not designed to create symbols. They are designed to parse entire expressions. This method fails if the input string is not valid Python. It also fails if the string parses to a larger expression: Any Python string can be used as a valid Symbol name. Furthermore, all the same issues described in the Avoid String Inputs section below apply here.\n• None Add assumptions to symbols when they are known. Assumptions can be added by passing the relevant keywords to . The most common assumptions are , (or ), and . Assumptions are never required, but it is always recommended to include them if they are known because it will allow certain operations to simplify. If no assumptions are provided, symbols are assumed to be general complex numbers, and simplifications will not be made unless they are true for all complex numbers. Here, \\(\\int_0^\\infty e^{-ax}\\,dx\\) gives a piecewise result when is defined with no assumptions, because the integral only converges when is positive. Setting to be positive removes this piecewise. When you do use assumptions, the best practice is to always use the same assumptions for each symbol name. SymPy allows the same symbol name to be defined with different assumptions, but these symbols will be considered unequal to each other: See also Avoid String Inputs and Don’t Hardcode Symbol Names in Python Functions for related best practices around defining symbols. Don’t use strings as input to functions. Rather, create the objects symbolically using Symbols and the appropriate SymPy functions, and manipulate them. It’s always best to create expressions explicitly using Python operators, but sometimes you really do start with a string input, like if you accept an expression from the user. If you do have a string that you are starting with, you should parse it explicitly with . It is best to parse all strings early and only use symbolic manipulation from there on. There are many disadvantages to using strings as input to SymPy functions:\n• None It is unpythonic and makes code harder to read. See the Zen of Python “explicit is better than implicit”.\n• None Support for string inputs in general SymPy functions is mostly accidental. It happens because these functions call on their inputs in order to convert things like Python s into SymPy s. However, also parses strings into SymPy expressions, unless the flag is used. Automatic parsing of strings for general SymPy functions (other than or ) may go away in a future version of SymPy.\n• None Typos in symbol or function names can go unnoticed. This is because all undefined names in the string will be automatically parsed into Symbols or Functions. If the input has a typo, the string will still parse correctly, but the output will not be what was expected. For example Compare this to the explicit error you get when not using strings: # The typo is caught by a NameError : name 'sine' is not defined In the first example, , a typo for , is parsed into , and it appears that cannot handle it. In the second case, we immediately get an error from the undefined name , and fixing our typo, we see that can indeed do what we want.\n• None The biggest gotcha when using string inputs comes from using assumptions. In SymPy, if two symbols have the same name but different assumptions, they are considered unequal: It is generally recommended to avoid doing this, as it can lead to confusing expressions like the one above (see Defining Symbols above). However, string inputs will always create symbols without assumptions. So if you have a symbol with an assumption and later try to use the string version of it, you will end up with confusing results. The answer here is apparently wrong, but what happened is that the in parsed to with no assumptions, which SymPy considers to be a different symbol from , which is used as the second argument to . So as far as is concerned, the expression is constant and the result is 0. This sort of thing is particularly bad because it generally doesn’t lead to any errors. It will just silently give the “wrong” answer because SymPy will be treating symbols that you thought were the same as different. The situation is avoided by not using string inputs. If you are parsing strings, and you want some of the symbols in it to have certain assumptions, you should create those symbols and pass them to the dictionary to . For example: # a, b, and c in expr are different symbols without assumptions # a, b, and c are the same as the a, b, c with real=True defined above\n• None Many SymPy operations are defined as methods, not functions, that is, they are called like . These methods won’t work on strings, since they are not yet SymPy objects. For example:\n• None Symbol names can contain any character, including things that aren’t valid Python. But if you use strings as input, it is impossible to use such symbols. For example This doesn’t work because is not valid Python. But it is perfectly possible to use this as a Symbol name: Actually, the above is the best case scenario, where you get an error. It is also possible you might get something unexpected: What happened here is that instead of parsing as \\(x^1_2\\), it is parsed as ( is converted to and is ignored in numeric literals in Python). If we instead create a Symbol, the actual contents of the symbol name are ignored. It is always represented as a single symbol.\n• None If you use strings, syntax errors won’t be caught until the line is run. If you build up the expressions, syntax errors will be caught immediately by before any of it runs.\n• None Syntax highlighting in code editors doesn’t typically recognize and color-code the content of strings, whereas it can recognize Python expressions. If you find yourself doing a lot of string or regular expression manipulations on symbolic expressions, this is generally a sign that you are using SymPy incorrectly. It’s better to build up expressions directly with operators like , , , and and SymPy’s various functions and methods. String-based manipulations can introduce errors, grow complex quickly, and lose the benefits of symbolic expression structures. The reason for this is that there is no notion of a symbolic expression in a string. To Python, is no different from , which is the same string with the characters in another order. To contrast, a SymPy expression actually knows about what type of mathematical object it represents. SymPy has many methods and functions for building and manipulating expressions, and they all operate on SymPy objects, not strings. See also the previous section on avoiding string inputs to functions. If a number is known to be exactly equal to some quantity, avoid defining it as a floating-point number. However, this isn’t to say that you should never use floating-point numbers in SymPy, only that if a more exact value is known it should be preferred. SymPy does support arbitrary precision floating-point numbers, but some operations may not perform as well with them. This also applies to non-rational numbers which can be represented exactly. For example, one should avoid using and prefer , since the former is a numerical approximation to \\(\\pi\\) and the latter is exactly \\(\\pi\\) (see also Separate Symbolic and Numeric Code below; in general, one should avoid importing when using SymPy). Here is not exactly 0, because is not exactly \\(\\pi\\). One should also take care to avoid writing where both integers are explicit integers. This is because Python will evaluate this to a floating-point value before SymPy is able to parse it. # The exact value of 2/7 is lost In this case, use to create a rational number, or use shorthand if you want to save on typing. Exact values, if they are known, should be preferred over floats for the following reasons:\n• None An exact symbolic value can often be symbolically simplified or manipulated. A float represents an approximation to an exact real number, and therefore cannot be simplified exactly. For example, in the above example, does not produce because is not exactly \\(\\pi\\). It is just a floating-point number that approximates \\(\\pi\\) to 15 digits (effectively, a close rational approximation to \\(\\pi\\), but not exactly \\(\\pi\\)).\n• None Some algorithms will not be able to compute a result if there are floating-point values, but can if the values are rational numbers. This is because rational numbers have properties that make it easier for these algorithms to work with them. For instance, with floats, one can have a situation where a number should be 0, but due to approximation errors, does not equal exactly 0. A particularly notable example of this is with floating-point exponents. For example,\n• None SymPy Floats have the same loss of significance cancellation issues that can occur from using finite precision floating-point approximations: # the coefficient of x should be slightly less than 1 # Using rational numbers gives the coefficient of x exactly It is possible to avoid these issues in SymPy in many cases by making careful use of with its ability to evaluate in arbitrary precision. This typically involves either computing an expression with symbolic values and substituting them later with , or by starting with values with a precision higher than the default of 15 digits: A number can be converted to its exact rational equivalent by passing it to . Alternatively, you can use to find the nicest rational approximation. This can sometimes reproduce the number that was intended if the number is supposed to be rational (although again, it’s best to just start with rational numbers in the first place, if you can): (not to be confused with ) is designed as a general purpose heuristic. It tries various simplification algorithms on the input expression and returns the result that seems the “simplest” based on some metric. is perfectly fine for interactive use, where you just want SymPy to do whatever it can to an expression. However, in programmatic usage, it’s better to avoid and use more targeted simplification functions instead (e.g., , , or ). There are a few reasons why this is generally preferred:\n• None Due to its heuristical nature, can potentially be slow, since it tries a lot of different approaches to try to find the best simplification.\n• None There are no guarantees about what form an expression will have after being passed through . It may actually end up “less simple” by whatever metric you were hoping for. To contrast, targeted simplification functions are very specific about what behaviors they have and what they guarantee about the output. For example,\n• None will always factor a polynomial into irreducible factors.\n• None will always convert a rational function into the form \\(p/q\\) where \\(p\\) and \\(q\\) are expanded polynomials with no common factors. The documentation for each function describes exactly what behavior it will have on the input expression.\n• None A targeted simplification will not do something unexpected if the expression contains an unexpected form, or an unexpected subexpression. This is especially the case if simplification functions are applied with to only apply the simplification to the top-level expression. Some other simplification functions are heuristical in nature, and care should be taken with them as well. For example, the function is a heuristic targeted to trigonometric functions, but the routines in the submodule allow applying specific trigonometric identities. The simplify section of the tutorial and the simplify module reference list the various targeted simplification functions. In some cases, you may know exactly what simplification operations you wish to apply to an expression, but there may not be an exact set of simplification functions that do them. When this happens, you can create your own targeted simplification using , or in general, manually using advanced expression manipulation. Instead of hard-coding names inside of a function definition, make the symbols a parameter to the function. For example, consider a function that computes the theta operator \\(\\theta = zD_z\\): A hard-coded symbol name has the disadvantage of requiring all expressions to use that exact symbol name. In the above example, it is not possible to compute \\(\\theta = xD_x\\) because it is hard-coded to \\(zD_z\\). What’s worse, trying to do so silently leads to a wrong result instead of an error, since is treated as a constant expression: This is particularly problematic if the function accepts arbitrary user input, as the user may be using a different variable name that makes more sense in their mathematical context. And if the user already used the symbol but as a constant, they would need to swap things around with before being able to use the function. The other reason this antipattern is problematic is due to the gotcha that symbols with assumptions are considered unequal to symbols without assumptions. If someone defined their expression using for example, to make further simplifications possible (see Defining Symbols above), the function hard-coding without assumptions would not work: By making the symbol an argument to the function, like , these problems all go away. SymPy sets itself apart from most of the rest of the libraries in the Python ecosystem in that it operates symbolically, whereas other libraries, like NumPy, operate numerically. These two paradigms are different enough that it’s always best to keep them as separate as possible. Importantly, SymPy is not designed to work with NumPy arrays, and conversely, NumPy will not work directly with SymPy objects. # NumPy functions do not know how to handle SymPy expressions : loop of ufunc does not support argument 0 of type Symbol which has no callable sin method If you want to use both SymPy and NumPy, you should explicitly convert your SymPy expressions into NumPy functions using . The typical workflow in SymPy is to model your problem symbolically using SymPy, then convert the result into a numerical function with that can be evaluated on NumPy arrays. For advanced use-cases, /NumPy may not be enough and you may instead need to use SymPy’s more general code generation routines to generate code for other fast numerical languages such as Fortran or C. # First symbolically construct the expression you are interested in with SymPy # Then convert it to a numeric function with lambdify() # Now use this function with NumPy These are some antipatterns that should be generally avoided\n• None Do not use . It is virtually never necessary to use the standard library module alongside SymPy (or NumPy). Every function that is in is already in SymPy. SymPy can compute values numerically using evalf, which provides more precision and accuracy than . Or better, SymPy will by default compute things symbolically. Functions and constants in are floats, which are inexact. SymPy always works better with exact quantities when possible. For example, The result of is not as you might expect, because is only an approximation of \\(\\pi\\), equal to 16 digits. On the other hand, is exactly equal to \\(\\pi\\) because it is represented symbolically, so it is able to give the exact answer: So in general, one should prefer symbolic representations. But even if you actually do want a float, you are better off using SymPy’s rather than . This avoids the pitfall that functions can only operate on objects, not symbolic expressions And furthermore, SymPy’s is more accurate than , because it uses arbitrary precision arithmetic, and allows you to specify any number of digits. Even when using NumPy, should be avoided. NumPy functions are faster than their equivalents, support a larger range of numerical dtypes, and can operate on arrays of values, whereas functions can only operate on a single scalar at a time.\n• None Don’t pass SymPy expressions to a NumPy function. You should not pass a SymPy expression to a NumPy function. This includes anything in the or namespaces, as well as most functions from other Python libraries such as . These functions are only designed to work with NumPy arrays with numeric values.\n• None Don’t pass SymPy expressions to a lambdified function. Similar to the previous point, you should not pass SymPy expressions to a function created with . In effect, the functions returned by are NumPy functions, so the situation here is exactly the same. It is possible that in some cases a function created from will work with a SymPy expression, but this is just an accident of the way it works. See the “how it works” section of the documentation for more details on why this happens.\n• None Avoid storing SymPy expressions in a NumPy array. While it is technically possible to store SymPy expressions inside of a NumPy array, doing so usually represents a mistake. A sign that this is happening is if the of the NumPy array is (instead of a numeric dtype like or ). Just as one should avoid using NumPy when doing symbolic calculations with SymPy, one should stop using SymPy once the calculation have moved over to the numeric side of things with NumPy. A NumPy array that contains SymPy expressions effectively has the same problem as trying to call NumPy functions directly on a SymPy expression. They do not know how to operate on SymPy objects, so they will fail. This applies even if the SymPy objects are all SymPy s. # Note that the dtype is 'object' : loop of ufunc does not support argument 0 of type Float which has no callable sin method If you are doing this, you should probably either be using native NumPy floats, or, if you really do want to store an array of SymPy expressions, you should use SymPy’s or classes.\n\nBe careful with programmatic code that compares numerical quantities, either directly using an inequality ( , , , ) or indirectly with something like . The issue is that if an inequality is unknown, the result will be symbolic, like A symbolic inequality will raise an exception if is called on it, due to the ambiguity: : cannot determine truth value of Relational May work just fine if you only ever test it for numerical . But if can ever be symbolic, the above code is wrong. It will fail with TypeError: cannot determine truth value of Relational . If you ever see this exception, it means this error has been made somewhere (sometimes the error is in SymPy itself; if this appears to be the case, please open an issue). The exact same issue occurs when using , since this internally uses . : cannot determine truth value of Relational There are a few options for fixing this issue, and the correct one to choose depends on what you are doing:\n• None Disallow symbolic inputs. If your function cannot possibly work on symbolic inputs, you can explicitly disallow them. The primary benefit here is to give a more readable error message to users than TypeError: cannot determine truth value of Relational . The attribute can be used to check if an expression can be evaluated to a specific number with . If you want to only accept integers, you can check (after calling to convert Python ints). Beware that uses the assumptions system and may be True even for symbolic objects, like .\n• None Use the assumptions system. If you do support symbolic inputs, you should use the assumptions system to check for things like , e.g., using . When doing this, you should always be aware of the nuances of the three-valued fuzzy logic used in the assumptions system. That is, always be aware that an assumption could be , meaning its value is unknown and could be either true or false. For example, will only run the block if is , but you may want to do something when is .\n• None Return a Piecewise result. If the result of a function depends on an inequality or other boolean condition, you can use to return a result that represents both possibilities symbolically. This is generally preferred when possible, as it offers the most flexibility. This is because the result is represented symbolically, meaning, for instance, one can later substitute specific values for the symbols and it will evaluate to the specific case, even if it is combined with other expressions. this can be represented symbolically as\n• None Use to sort expressions into a canonical order. If you are trying to use because you want a canonical ordering, but you don’t particularly care what that ordering is, you can use . Alternatively, try to write the function in a way so that the correctness of the result does not depend on the order that arguments are processed in.\n\nSymPy is designed to be extended with custom classes, typically by subclassing Basic, Expr, or Function. All the symbolic classes in SymPy itself are written this way, and the points here apply equally to them as to user-defined classes. For an in-depth guide on how to write a subclass, see the guide on writing custom functions. Custom SymPy objects should always satisfy the following invariants: The first says that all elements of args should be instances of Basic. The second says that an expression should be rebuildable from its (note that func is usually the same as , though it may not always be). These two invariants are assumed throughout SymPy, and are essential for any function that manipulates expressions. For example, consider this simple function, which is a simplified version of : The function works by recursively traversing the of , and rebuilding it except any instances of are replaced by . It’s easy to see how this function would break if the args invariants did not hold:\n• None If an expression had args that were not , they would fail with on a recursive call, because the non- args would not have the or attributes.\n• None If an expression did not rebuild from its , the line would fail, even in the trivial case where none of the args are changed by the replacement, which should effectively be a no-op. Making all instances of usually just means calling on the inputs to the class so that they are basic instances. If you want to store a string on a class, you should either use a or . In some cases a class may accept args in multiple equivalent forms. It is important that whatever form is stored in is one of the ways that can be used to reconstruct the class. It is okay to normalize as long as that normalized form is accepted as input. For example, always stores the variable argument as a tuple to make things easier to process internally, but this form is also accepted by the class constructor: Note that most user-defined custom functions should be defined by subclassing (see the guide to writing custom functions). The class automatically takes care of both of the args invariants, so if you are using it, you do not need to worry about this. When defining a custom function, avoid doing too much automatic evaluation (i.e., evaluation in the or methods). Generally, automatic evaluation should only be done in instances where it is fast, and it is something that no one ever want to not happen. Automatic evaluation is difficult to undo. A good rule of thumb is to evaluate on explicit numeric values ( ), and leave everything else symbolically unevaluated. Further simplification using more advanced identities should be done in specific simplification functions or (see the custom functions guide for a list of common simplification routines that can be defined on SymPy objects). The custom functions guide goes over this in depth (but note that this guideline applies equally to all SymPy objects, not just functions). But in a nutshell, the reason for this is that the only way to prevent automatic evaluation is to use , which is fragile. Additionally, code will invariably be written assuming the invariants that are true due to automatic evaluations, meaning that expressions created with can lead to wrong results from this code. This also means that removing automatic evaluation later can be difficult. Evaluation that can potentially be expensive (for instance, applying a symbolic identity) is itself bad because it can make creating an expression without even doing anything with it allow. This also applies to checking for symbolic assumptions (like ), so this should also be avoided in class constructors. Note that not all the classes in SymPy currently follow this guideline very well, but it is something that we are improving. Functions and classes that accept an arbitrary number of arguments should either accept the arguments directly, like , or as a single argument, like . They should not try to support both at once. The reason is that this makes it impossible to represented nested collections. For example, take the class. It is constructed like (i.e., using ). It might be tempting to also support , to match the built-in . However, doing so would make it impossible to represent a nested containing a single , like \\(\\{\\{1, 2, 3\\}\\}\\): # We don't want this to be the same as {1, 2, 3} As to whether or should be used, if it is only possible for there to be a finite number of arguments, is generally better, as this makes things easier to deal with using the object’s args, since will be the direct arguments of the class. However, if it is possible that you might want to support a symbolic infinite collection in addition to finite ones, like or , then it is better to use as this will be impossible to do with . A common reason that you might want to create a custom SymPy object is that you want to store extra attributes on the object. However, doing this in a naive way, i.e., by simply storing the data as a Python attribute on the object, is almost always a bad idea. SymPy does not expect objects to have extra data stored in them beyond what is in their args. For instance, this breaks checking, which only compares an objects . See the Don’t Overwrite __eq__ section below for why it is a bad idea to override . This section and that one are closely related. Typically, there is a better way to do what you are trying to do, depending on the specific details of your situation:\n• None Store the extra data in the object’s . This is the best approach if the extra data you want to store is part of the mathematical description of your object. As long as the data is representable using other SymPy objects, it can be stored in . Note that an object’s should be usable to recreate the object (e.g., something like should recreate ). Additionally, it should be mentioned that it is not a good idea to subclass if you plan to store anything extra in . is designed around having no . You are better off subclassing (see Writing Custom Functions) or directly. If you simply want to have two symbols that are distinct from one another, the best approach is often just to give them different names. If you are concerned about how they are printed, you can replace them with a more canonical name when it comes time to print things, or use a custom printer.\n• None Store the data about the object separately. This is the best approach if the extra data is not directly related to an object’s mathematical properties. Remember that SymPy objects are hashable, so they can easily be used as dictionary keys. So maintaining a separate dictionary of pairs is straightforward. Note that some SymPy APIs already allow redefining how they operate on objects separately from the objects themselves. A big example of this is the printers, which allow defining custom printers that change how any SymPy object is printed without modifying those object themselves. Functions like and allow passing in a custom printer.\n• None Represent the attribute using different subclasses. This is often a good idea if there are only a few possible values for the attribute (e.g., a boolean flag). Code duplication can be avoided by using a common superclass.\n• None If the data you want to store is a Python function, it’s best to just use as a method on the class. In many cases, the method may already fit into one of the existing set of overridable SymPy methods. If you want to define how a function evaluates itself numerically, you can use .\n• None Represent the information using by modifying the object’s . This solution is much more complicated than the others, and should only be used when it is necessary. In some extreme cases, it is not possible to represent every mathematical aspect of an object using alone. This can happen, for example, because of the limitation that should only contain instances. It is still possible to create custom SymPy objects in these situations by using a custom func that is different from (in this case, you would override on the rather than on the class). However, this sort of situation is rare. When building a custom SymPy object, it is sometimes tempting to overwrite to define custom logic for the operator. This is almost always a bad idea. Custom SymPy classes should leave undefined and use the default implementation in the superclass. In SymPy, compares objects using structural equality. That is, means that and are exactly the same object. They have the same type and the same args. does not perform any sort of mathematical equality checking. For example, also always returns a boolean or . Symbolic equations can be represented with . There are several reasons for this\n• None Mathematical equality checking can be very expensive to compute, and in general, it is computationally impossible to determine.\n• None Python itself automatically uses in various places and assumes that it returns a boolean and is inexpensive to compute. For example, if is a builtin Python container like , , or , then uses .\n• None SymPy internally uses all over the place, both explicitly and implicitly via things like or dictionary keys. This usage all implicitly assumes that operates structurally. In affect, structural equality means that if is , then and are for all intents and purposes the same object. This is because all SymPy objects are immutable. When , any SymPy function may freely replace with in any subexpression. The default method on Basic checks if the two objects have the same type and the same . There are also many parts of SymPy that implicitly assume that if two objects are equal, then they have the same . Therefore, it is not a good idea to try to override as a way to avoid storing some identifying information about an object in its . The of an object should contain everything that is needed to recreate it (see args). Note that it is possible for an objects constructor to accept multiple forms of arguments, so long as it accepts the form stored in (e.g., it is perfectly fine for some args to have default values). Here are some examples of reasons you might be tempted to override and the preferred alternatives:\n• None To make apply some smarter equality check than purely structural equality. As noted above, this is a bad idea because too many things implicitly assume works structurally only. Instead, use a function or method to implement the smarter equality checking (for example, the method). Another option is to define a canonicalization method that puts objects into canonical form (e.g., via ), so that, for instance, is true whenever and are mathematically equal. This is not always possible because not every type of object has a computable canonical form, but it is a convenient approach when one does exist.\n• None To make check for some additional attributes beyond those stored in the of an expression. See the Avoid Storing Extra Attributes on an Object section above for more details on why it’s a bad idea to directly store extra attributes on a SymPy object, and what the best alternatives are.\n• None To make compare equal to some non-SymPy object. It is preferable to extend to be able to convert this object into the SymPy object. The default implementation will automatically call on the other argument if it isn’t a instance (e.g., gives ). It is possible to extend both for objects you control by defining a method and for objects you do not control by extending the dictionary. See the documentation for more details. When writing assumptions handlers on custom functions like (see the custom functions guide for details on how to do this), there are two important things to keep in mind: Firstly, avoid creating new expressions inside of an assumption handler. You should always pull apart the arguments of a function directly instead. The reason is that creating a new expression could itself result in an assumptions query. This can easily lead to infinite recursion. And even when it doesn’t, creating a new expression that itself could lead to many recursive assumptions queries is bad for performance compared to querying the desired property more directly. This generally means using methods like or ~.as_coeff_mul args` of expressions directly (see the custom functions guide for an example). Secondly, do not recursively evaluate assumptions on in assumptions handlers. Assumptions handlers should only check for assumptions on . The global assumptions system will automatically handle implications between different assumptions. For example, you may be tempted to write something like # Quick return if self is not real (do not do this). However, the check is completely unnecessary. The assumptions system already knows that implies , and it will not bother checking if it already knows that is False. If you define the function this way, it will lead to an infinite recursion: Instead, define the handler based on the arguments of the function only:"
    },
    {
        "link": "https://stackoverflow.com/questions/60140777/how-to-handle-floats-with-sympy",
        "document": "This is some dialogue that I had with python using\n\nHow to get there?\n\nI tried this and works:"
    },
    {
        "link": "https://stackoverflow.com/questions/25998314/sympy-not-handling-float-numbers",
        "document": "and as expected the answer is \"5.62527e-11\"\n\nbut when i change \"5.62527e-11\" to \"5.62527e-67\" and run the same code ...i am getting [0.0] as output which is awkward ...it is working for \"e-11\" but fails for \"e-67\" can someone please exp-lain why this is happening ..and can someone show me the solution ...i need a solution for this problem\n\nNote : the above code is just a piece of the actual code ...and i have to run it in the same way ...so can anyone please help me dealing with that number ?"
    },
    {
        "link": "https://discuss.python.org/t/mathematics-working-with-floats-or-fractions/50649",
        "document": "Hi,\n\n this will be maybe a repetitive question regarding how to deal with floats, but anyway:\n\n having the following expression: \n\n If I type it to google I get .\n\n If I type it to spreadsheet (of any provider) still I get the result .\n\n If I type it to Python, I get .\n\nI wonder what would be the correct approach if I wanted the output to be same as from google or spreadsheet?\n\nChatGPT suggests, one can use :\n\nor when used with print function:\n\n\n\nBut we still get the zero after floating point (whether one or many)…\n\nI’m thinking that probably one can also use decimal or fractions libraries here?\n\nJust how to make Python return just number 4 ? (as Google or Excel does)…"
    }
]