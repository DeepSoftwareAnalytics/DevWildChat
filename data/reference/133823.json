[
    {
        "link": "https://geeksforgeeks.org/python-program-for-depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a Boolean visited array. A graph can have more than one DFS traversal.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nPython Depth First Search Algorithm is used for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\nDFS Algorithm Time Complexity: O(V+E) where V is the number of vertices in the graph and E is the number of edges\n\nAuxiliary Space: O(V+E)\n\nPython Program for Depth First Search or DFS for a Graph – FAQs\n\nWhat is Depth First Search (DFS)?\n\nWhat is the difference between DFS and BFS?\n\nCan DFS be used for finding the shortest path?"
    },
    {
        "link": "https://datacamp.com/tutorial/depth-first-search-in-python",
        "document": "Level up your data science skills by creating visualizations using Matplotlib and manipulating DataFrames with pandas."
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://analyticsvidhya.com/blog/2024/06/depth-first-search-algorithm-in-python",
        "document": "Implementation of Depth First Search (DFS) Algorithm in Python\n\nIn depth-first search (DFS), all nodes are explored along some branch and backtracked. Think of it as being in a maze: DFS goes down one path until it reaches a dead-end before retracing its steps to take another, right? It is the same as going down, validating the tunnel, and so on for all tunnels.\n\nDFS is useful for:\n• Checking how different nodes are connected.\n\nWhile DFS dives deep, another method called Breadth-First Search (BFS) checks all neighbors at the current level before moving deeper. Both methods are important, but Depth First Search (DFS) helps you go as far as possible down one path before trying another.\n• DFS will exhaustively visit a single path before backtracking to a node with an unvisited path.\n• DFS-Recursive uses a call stack to manage traversal and goes deeper into each path.\n• Uses a separate stack to maintain the exploration; therefore, no recursion depth problem.\n• DFS’s time complexity is O(V+E)O(V + E)O(V+E), and its space complexity is O(V)O(V)O(V).\n• DFS is cool for many things. Some of the most common are pathfinding, cycle detection, topological sorting, and puzzle solving.\n• Difference between DFS and BFS BFS explores each level first and then goes to the next level, whereas DFS goes through one branch and then moves to the current.\n\nHow Does Depth First Search (DFS) Work?\n\nThe DFS algorithm involves visiting nodes as deeply as possible before backtracking. Here’s a step-by-step explanation:\n• Starting node: The search will start at the root node, in the case of a tree, or from an arbitrary node, in the case of the graph.\n• Explore: For each adjacent node, recursively visit the node if it has not been visited yet.\n• Backtrack: When a node with no unvisited adjacent nodes is reached, backtrack to the previous node and continue the process.\n\nAlso read: A Complete Python Tutorial to Learn Data Science from Scratch\n\nDFS—Depth First Search is a recursive algorithm. To implement it for a graph, we can either use recursion or implicit recursion using Stack.\n\nThe recursive implementation of DFS leverages the call stack to manage the traversal state. Here is a Python implementation:\n\nThe iterative implementation uses an explicit stack to manage the traversal. This can be useful to avoid potential issues with recursion depth in languages that limit the call stack size.\n\nThe code examples refer to the graph as an adjacency list. Each node is like a key, listing all the nodes directly connected to it. To avoid revisiting the same node, we have a set named visited, which stores the previous node.\n• Recursive DFS: The dfs_recursive function calls itself for each unvisited neighbor of the current node, diving deep into each path.\n• Iterative DFS: The dfs_iterative function uses a stack (a list where you add and remove items) to manage which nodes to visit next. This stack works like the call stack in the recursive method, helping track the order of visits.\n\nBoth methods ensure all parts of the graph are explored, but they do it differently.\n\nHere is the time and space complexity of DFS:\n• Time complexity: The time complexity of DFS is O(V + E), where V and E are the number of vertices and edges, respectively. In the worst case, each vertex and edge will be searched once.\n• Space Complexity: Space complexity would be O(V) since we need to keep track of visited nodes. In recursion, we would run a recursion stack, or we may push nodes into the stack in iterative.\n\nDepth First Search (DFS) has numerous applications in computer science and real-world problems:\n• Pathfinding: DFS would be useful for finding a path between two nodes in a graph.\n• Cycle Detection: It helps detect cycles in a graph and is useful in various domains, like dependency resolution.\n• Use cases for topological sorting: Scheduling the tasks so that each task depends on the others and must be performed in linear order.\n• Graph Traversal & Connected Components: DFS in an undirected graph to identify all connected components.\n• Maze and Puzzle Solving: Solve complex maze and puzzles by traversing every possible path.\n\nSuppose you have to find all the paths in a network of computers so that the data will be transmitted correctly. DFS is an algorithm that performs a depth-first search in a graph. It can be used to start from a particular computer and follow connections as far as they go, backtracking when no more connections can be followed.\n\nWhile DFS dives deep into a graph, BFS explores all neighbors of a node before moving to the next level. Each has its advantages:\n• DFS: Uses less memory and can find a path without exploring all nodes.\n• BFS: Guarantees finding the shortest path in an unweighted graph.\n\nDFS, or Depth-First Search, is a powerful utility for traversing graphs and using them in tree problems. DFS is useful when solving puzzles, finding your way in a maze, or organizing tasks. The two ways to use DFS are:\n• Recursive DFS: this uses function calls to track where you are coming from in the graph.\n• Iterative DFS: Using a stack to handle the steps.\n\nThe 2 methods guaranteed full coverage of the graph; every node was explored. Here is a list of how DFS can find paths, detect cycles, sort tasks, and connect components in a graph. Gaining knowledge about DFS will help you solve tough problems. After seeing the examples, you can explore DFS in your code.\n\nSo, are you looking for Python courses online? If yes, explore – Introduction to Python today!"
    },
    {
        "link": "https://stackoverflow.com/questions/12864004/tracing-and-returning-a-path-in-depth-first-search",
        "document": "So I have a problem that I want to use depth first search to solve, returning the first path that DFS finds. Here is my (incomplete) DFS function:\n\nThe startState and goalState variables are simply a tuple of x, y coordinates. problem is a class with a variety of methods. The important ones here are getSuccessors (which returns the children of a given state in the form of a list of 3 item tuples. for this part of the problem though, only the first element of the tuple, (child[0]), which returns the state of the child in x, y coordinates, is important) and isGoalState (which provides the x, y coordinates of the goal state).\n\nSo I THINK (difficult to test at this point), that this function, given proper implementation of everything else, will return once it has reached a goal state. Please let me know if I am missing something. My biggest issue, though, is WHAT to return. I want it to output a list of all of the states it takes to get to the goal state, in order from the beginning to the end. It doesn't seem like simply returning my stack will do the trick, since the stack will include many unvisited children. Nor will my visited list yield anything useful, since it is conceivable I could reach dead ends, have to backtrack, but still have the dead-end tuples in the visited list. How would I go about getting the list I desire?"
    },
    {
        "link": "https://geeksforgeeks.org/detect-cycle-in-a-graph",
        "document": "Given the root of a Directed graph , The task is to check whether the graph contains a cycle or not.\n\nThe problem can be solved based on the following idea:\n\nTo find cycle in a directed graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors in a DFS tree] present in the graph. To detect a back edge, we need to keep track of the visited nodes that are in the current recursion stack [i.e., the current path that we are visiting]. Please note that all ancestors of a node are present in recursion call stack during DFS. So if there is an edge to an ancestor in DFS, then this is a back edge. Note: If the graph is disconnected then get the DFS forest and check for a cycle in individual graphs by checking back edges.\n\nTo keep track of vertices that are in recursion call stack, we use a boolean array where we use vertex number as an index. Whenever we begin recursive call for a vertex, we mark its entry as true and whenever the recursion call is about to end, we mark false.\n\nBelow is the graph showing how to detect cycle in a graph using DFS:\n\n\n\nBelow is the implementation of the above approach:\n\n// If already present in the recursion call // stack, then there is a cycle // Recur for all the vertices adjacent // If already present in the recursion call // stack, then there is a cycle # If already present in the recursion call # stack, then there is a cycle # Recur for all the vertices adjacent // If already present in the recursion call // stack, then there is a cycle // If already present in the recursion call // stack, then there is a cycle // Recur for all the vertices adjacent\n\nTime Complexity: O(V + E), the Time Complexity of this method is the same as the time complexity of DFS traversal which is O(V+E). \n\nAuxiliary Space: O(V). To store the visited and recursion stack O(V) space is needed.\n\nIn the below article, another O(V + E) method is discussed : \n\nDetect Cycle in a direct graph using colors\n\nHere we are using Kahn’s algorithm for topological sorting, if it successfully removes all vertices from the graph, it’s a DAG with no cycles. If there are remaining vertices with in-degrees greater than 0 , it indicates the presence of at least one cycle in the graph. Hence, if we are not able to get all the vertices in topological sorting then there must be at least one cycle.\n\nBelow is the implementation of the above approach:\n\n// Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle # Function to add an edge to the adjacency list # If in-degree becomes 0, enqueue it # If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle // Function to add an edge to the adjacency list // If in-degree becomes 0, enqueue it // If not all vertices are visited, cycle\n\nTime Complexity: O(V + E), the time complexity of this method is the same as the time complexity of BFS traversal which is O(V+E). \n\nAuxiliary Space: O(V)"
    },
    {
        "link": "https://stackoverflow.com/questions/39427638/how-to-traverse-cyclic-directed-graphs-with-modified-dfs-algorithm",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/59820748/how-to-detect-a-cycle-in-a-directed-graph-with-python",
        "document": "I have some input like: . I want to look for if the existence of a cycle in a directed graph represented by this edgeList.\n\nI read a discussion: https://www.geeksforgeeks.org/detect-cycle-in-a-graph/, however it has some errors when the case is:\n\nIts result is 'Graph has no cycle'. This is clearly wrong. Can you help me to solve this problem?"
    },
    {
        "link": "https://w3schools.com/dsa/dsa_algo_graphs_cycledetection.php",
        "document": "A cycle in a Graph is a path that starts and ends at the same vertex, where no edges are repeated. It is similar to walking through a maze and ending up exactly where you started.\n\nA cycle can be defined slightly different depending on the situation. A self-loop for example, where an edge goes from and to the same vertex, might or might not be considered a cycle, depending on the problem you are trying to solve.\n\nIt is important to be able to detect cycles in Graphs because cycles can indicate problems or special conditions in many applications like networking, scheduling, and circuit design.\n\nThe two most common ways to detect cycles are:\n• Depth First Search (DFS): DFS traversal explores the Graph and marks vertices as visited. A cycle is detected when the current vertex has an adjacent vertex that has already been visited.\n• Union-Find: This works by initially defining each vertex as a group, or a subset. Then these groups are joined for every edge. Whenever a new edge is explored, a cycle is detected if two vertices already belong to the same group.\n\nHow cycle detection with DFS and Union-Find work, and how they are implemented, are explained in more detail below.\n\nTo detect cycles in an undirected Graph using Depth First Search (DFS), we use a code very similar to the DFS traversal code on the previous page, with just a few changes.\n\nRun the animation below to see how DFS cycle detection runs on a specific Graph, starting in vertex A (this is the same as the previous animation).\n\nThe DFS traversal starts in vertex A because that is the first vertex in the adjacency matrix. Then, for every new vertex visited, the traversal method is called recursively on all adjacent vertices that have not been visited yet. The cycle is detected when vertex F is visited, and it is discovered that the adjacent vertex C has already been visited.\n\nLine 66: The DFS cycle detection starts when the method is called.\n\nLine 37: The array is first set to for all vertices, because no vertices are visited yet at this point.\n\nLine 38-42: DFS cycle detection is run on all vertices in the Graph. This is to make sure all vertices are visited in case the Graph is not connected. If a node is already visited, there must be a cycle, and is returned. If all nodes are visited just ones, which means no cycles are detected, is returned.\n\nLine 24-34: This is the part of the DFS cycle detection that visits a vertex, and then visits adjacent vertices recursively. A cycle is detected and is returned if an adjacent vertex has already been visited, and it is not the parent node.\n\nTo detect cycles in Graphs that are directed, the algorithm is still very similar as for undirected Graphs, but the code must be modified a little bit because for a directed Graph, if we come to an adjacent node that has already been visited, it does not necessarily mean that there is a cycle.\n\nJust consider the following Graph where two paths are explored, trying to detect a cycle:\n\nIn path 1, the first path to be explored, vertices A->B->C are visited, no cycles detected.\n\nIn the second path to be explored (path 2), vertices D->B->C are visited, and the path has no cycles, right? But without changes in our program, a false cycle would actually be detected when going from D to the adjacent vertex B, because B has already been visited in path 1. To avoid such false detections, the code is modified to detect cycles only in case a node has been visited before in the same path.\n\nTo implement DFS cycle detection on a directed Graph, like in the animation above, we need to remove the symmetry we have in the adjacency matrix for undirected Graphs. We also need to use a array to keep track of visited vertices in the current recursive path.\n\nLine 6: This line is removed because it is only applicable for undirected Graphs.\n\nLine 26: The array keeps an overview over which vertices have been visited during a recursive exploration of a path.\n\nLine 14-19: For every adjacent vertex not visited before, do a recursive DFS cycle detection. If an adjacent vertex has been visited before, also in the same recursive path (line 13), a cycle has been found, and is returned.\n\nDetecting cycles using Union-Find is very different from using Depth First Search.\n\nUnion-Find cycle detection works by first putting each node in its own subset (like a bag or container). Then, for every edge, the subsets belonging to each vertex are merged. For an edge, if the vertices already belong to the same subset, it means that we have found a cycle.\n\nIn the animation above, Union-Find cycle detection explores the edges in the Graph. As edges are explored, the subset of vertex A grows to also include vertices B, C, and D. The cycle is detected when the edge between A and D is explored, and it is discovered that both A and D already belong to the same subset.\n\nThe edges between D, E, and F also construct a circle, but this circle is not detected because the algorithm stops (returns ) when the first circle is detected.\n\nUnion-Find cycle detection is only applicable for Graphs that are undirected.\n\nUnion-Find cycle detection is implemented using the adjacency matrix representation, so setting up the Graph structure with vertices and edges is basically the same as in previous examples.\n\nLine 6: The array contains the root vertex for every subset. This is used to detect a cycle by checking if two vertices on either side of an edge already belong to the same subset.\n\nLine 17: The method finds the root of the set that the given vertex belongs to.\n\nLine 29: The method uses the method to detect a cycle if two vertices and are already in the same subset. If a cycle is not detected, the method is used to combine the subsets."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-for-detect-cycle-in-a-directed-graph",
        "document": ""
    }
]