[
    {
        "link": "https://stackoverflow.com/questions/38246928/using-global-variable-in-python-among-modules-in-different-packages",
        "document": "The way to do this is to keep the module where the variable is as a reference:\n\nIf you do that everywhere you use it will have a consitent value across modules.\n\nThat happens because each time you do an assignment to a name in Python, the object associated with that name changes -\n\nThat is, if you do\n\nYour variable will point to a different object from that assignment on. And since numbers are immutable objects, there are even other problems with that.\n\nBut f you keep the original module around, you are changing an attribute in that module object - which behaves exactly like any other Python object. As long as other code access the variable as an attribute of the module, you are good."
    },
    {
        "link": "https://discuss.python.org/t/global-variables-shared-across-modules/16833",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/77259096/python-global-variables-in-shared-modules",
        "document": "I am trying to understand the behavior of variables shared across modules. My impression was a global variable in one module could be accessed in another, and sometimes this seems to be what happens, but sometimes it is not. (I recognize global variables are usually not the right tool, but there are situations where their use is appropriate.)\n\nHere is a code example to illustrate my confusion:\n\nWhen I run the program, I get the following output:\n• 'main' is not seeing the same scalar variable 'globalvar' that is being set by the 'set_globals' method in the shared module (the assignment 'took' and was printed within 'set_globals' but 'main' is printing something else.\n• It does appear to be seeing the same 'globalarray1' - the append(4) that modified globalarray1 in set_globals is recognized when it is printed by 'main'.\n• It is not seeing the same 'globalarray2' - the variable assigned in set_globals is correctly printed by 'set_globals', but 'main' is printing the original value assigned to globalarray2.\n\nCan someone explain what is going on? I have only seen fairly simple tutorial-type documentation about global variables; if there is documentation that describes what is happening here I would appreciate a pointer.\n\nADDED NOTE: This is not related to the way a local variable in a function hides a global variable with the same name; those are two different variables with the same name and different initial values. It does appear that the import creates a new module variable with the same name, but it starts with the initial value of the variable of the same name from the imported module."
    },
    {
        "link": "https://eng.libretexts.org/Bookshelves/Computer_Science/Programming_Languages/Think_Python_-_How_to_Think_Like_a_Computer_Scientist_(Downey)/02%3A_Dictionaries/2.07%3A_Global_Variables",
        "document": "In the previous example, is created outside the function, so it belongs to the special frame called . Variables in are sometimes called global because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.\n\nIt is common to use global variables for flags; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named to control the level of detail in the output:\n\nIf you try to reassign a global variable, you might be surprised. The following example is supposed to keep track of whether the function has been called:\n\nBut if you run it you will see that the value of doesn’t change. The problem is that creates a new local variable named . The local variable goes away when the function ends, and has no effect on the global variable.\n\nTo reassign a global variable inside a function you have to declare the global variable before you use it:\n\nThe statement tells the interpreter something like, “In this function, when I say , I mean the global variable; don’t create a local one.”\n\nHere’s an example that tries to update a global variable:\n\nIf you run it you get:\n\nPython assumes that is local, which means that you are reading it before writing it. The solution, again, is to declare global.\n\nIf the global value is mutable, you can modify it without declaring it:\n\nSo you can add, remove and replace elements of a global list or dictionary, but if you want to reassign the variable, you have to declare it:"
    },
    {
        "link": "https://realpython.com/python-use-global-variable-in-function",
        "document": "In Python, global variables are accessible across your entire program, including within functions. Understanding how Python handles global variables is key to writing efficient code. This tutorial will guide you through accessing and modifying global variables in Python functions using the keyword and the function. You’ll also learn to manage scope and avoid potential conflicts between local and global variables.\n\nBy the end of this tutorial, you’ll understand that:\n• A global variable in Python is a variable defined at the module level, accessible throughout the program.\n• Accessing and modifying global variables inside Python functions can be achieved using the keyword or the function.\n• Python handles name conflicts by searching scopes from local to built-in, potentially causing name shadowing challenges.\n• Creating global variables inside a function is possible using the keyword or , but it’s generally not recommended.\n• Strategies to avoid global variables include using constants, passing arguments, and employing classes and methods to encapsulate state.\n\nTo follow along with this tutorial, you should have a solid understanding of Python programming, including fundamental concepts such as variables, data types, scope, mutability, functions, and classes.\n\nGlobal variables are those that you can access and modify from anywhere in your code. In Python, you’ll typically define global variables at the module level. So, the containing module is their scope. Note: You can also define global variables inside functions, as you’ll learn in the section Creating Global Variables Inside a Function. Once you’ve defined a global variable, you can use it from within the module itself or from within other modules in your code. You can also use global variables in your functions. However, those cases can get a bit confusing because of differences between accessing and modifying global variables in functions. To understand these differences, consider that Python can look for variables in four different scopes:\n• The local, or function-level, scope, which exists inside functions\n• The enclosing, or non-local, scope, which appears in nested functions\n• The global scope, which exists at the module level\n• The built-in scope, which is a special scope for Python’s built-in names To illustrate, say that you’re inside an inner function. In that case, Python can look for names in all four scopes. When you access a variable in that inner function, Python first looks inside that function. If the variable doesn’t exist there, then Python continues with the enclosing scope of the outer function. If the variable isn’t defined there either, then Python moves to the global and built-in scopes in that order. If Python finds the variable, then you get the value back. Otherwise, you get a : : name 'some_variable' is not defined When you launch an interactive session, it starts off at the module level of global scope. In this example, you have , which defines as a nested function. From the perspective of this nested function, its own code block represents the local scope, while the code block before the call to represents the non-local scope. If you call without defining in either of your current scopes, then you get a exception because the name isn’t defined. If you define in the global scope and then call , then you get on your screen. Internally, Python has searched the local, non-local, and global scopes to find and print its content. Note that you can define this variable in any of the three scopes, and Python will find it. This search mechanism makes it possible to use global variables from inside functions. However, while taking advantage of this feature, you can face a few issues. For example, accessing a variable works, but directly modifying a variable doesn’t work: The function works fine. It looks for and finds it in the global scope. In contrast, doesn’t work as expected. Why doesn’t this function update the value of your global variable, ? The problem is the scope of the variable. You can’t directly modify a variable from a high-level scope like global in a lower-level scope like local. Internally, Python assumes that any name directly assigned within a function is local to that function. Therefore, the local name, , shadows its global sibling. In this sense, global variables behave as read-only names. You can access their values, but you can’t modify them. Note: The discussion about modifying global variables inside functions revolves around assignment operations rather than in-place mutations of mutable objects. You’ll learn about the effects of mutability on global variables in the section Understanding How Mutability Affects Global Variables. Getting an exception is another common issue when you try to modify a global variable inside a function. Consider the following demonstrative function that attempts to use some global variables: Inside , you first print the global variables , , and . Then you update the value of directly. Finally, you print the updated version of . You may be expecting the following output: However, this output never appears on your screen. Instead, you get an error that might surprise you: : where it is not associated with a value The problem is that the assignment creates a new local variable that overrides the original global variable, . So, you have a name conflict. The exception comes from the first call to because, at that time, the local version of isn’t defined yet. So, you get the . In practice, this issue most often occurs in augmented assignment operations with global variables: : where it is not associated with a value In Python, if your function simply references a variable from the global scope, then the function assumes that the variable is global. If you assign the variable’s name anywhere within the function’s body, then you define a new local variable with the same name as your original global. Inside a function, you can’t access a global variable directly if you’ve defined local variables with the same name anywhere in the function. If you want to modify a global variable inside a function, then you need to explicitly tell Python to use the global variable rather than creating a new local one. To do this, you can use one of the following: In the following sections, you’ll learn how to use both tools in your code to change global variables from inside your functions. You’ve already learned that accessing global variables directly from inside a function is completely possible unless you have local variables with the same name in the containing function. Apart from that, what if you also need to change the variable’s value? In that case, you can use the keyword to declare that you want to refer to the global variable. The general syntax to write a statement is as follows: Note that the first variable is required, while the rest of the variables are optional. To illustrate how you can use this statement, get back to the and example. You can fix the code by doing something like the following: In this new version of , you use the keyword to declare that you want the function to update the global variable, . With this statement, you’re now able to modify the value of inside your function, as you can see above. Note: Python has a keyword that works similarly to . It allows you to use non-local variables from nested functions. Non-local variables are those that you define in a function that holds nested functions. These variables will be non-local to the inner or nested functions. It’s important to note that you have to do your global declarations before you use the target variable. Otherwise, you’ll get a : SyntaxError: name 'counter' is assigned to before global declaration In this example, you try to increment without declaring it as global inside . Therefore, you get a . The statement tells the Python interpreter when you find the name in this function, it refers to the global variable, so don’t create a local one. In summary, you only need to use the keyword if you want to reassign the global variable within a function. If you just need to read or access the value of the global variable from within your function, then you don’t need the keyword. Even though the goal of the keyword is to deal with global variables in functions, this keyword isn’t the only tool that you can use for this purpose. You can also use the built-in function. The built-in function allows you to access the global scope’s name table, which is a writable dictionary containing your current global names and their corresponding values. You can use this function to either access or modify the value of a global variable from within your functions. For example, this function comes in handy when you have local variables with the same name as your target global variables, and you still need to use the global variable inside the function: In this new implementation of , refers to the local version of the variable, while refers to the global version. Because returns a dictionary, you can access its keys as you’d access the keys of a regular dictionary. Note that you need to use the variable’s name as a string to access the corresponding key in . The dictionary of names that returns is mutable, which means that you can change the value of existing global variables by taking advantage of this dictionary. In the final example, you can see how the global variable, , still holds the same value. Here’s another version of . It’s a bit harder to read, but it works: In this example, you’ve implemented using instead of the keyword. Both implementations work the same, which you can confirm from the content of after consecutive calls to the function. Note that using to access and update global variables can make your code difficult to read and understand, especially for large programs. It’s generally better to use the keyword unless you have local variables with the same name as your target globals.\n\nPython has mutable and immutable data types. Mutable types, such as lists and dictionaries, allow you to change or mutate their values in place. In contrast, immutable types, like numbers, strings, and tuples, don’t allow you to modify their values in place. To quickly illustrate how mutability and immutability work in Python, consider the following example, where you mutate a list in place, changing the value of its elements or items: In this example, you mutate the value of . Because Python lists are mutable objects, this mutation doesn’t change the identity of your list object, only its value. You can confirm this by comparing the output of the built-in function before and after the mutations. Now, what will happen if you try to perform a similar action on an immutable type like a tuple? In this code example, you give it a go: Here, you use a tuple to store letters. Python tuples are immutable, so you can’t change their items in place like you did with your list of numbers. If you try to do it, then you get a . When it comes to using global variables that point to mutable objects inside your functions, you’ll note that it’s possible to change their values in place directly. For example, say that you’re creating a REST API application. For convenience, you use a global dictionary to share the API configurations across the app’s code. Also for convenience, you write a short function that allows you to update the configuration parameters: In this example, the function allows you to update the app’s configuration parameters. The function takes keyword-only arguments. Each argument must be a valid configuration parameter with its corresponding value. You check this condition with the operator in a conditional statement. If the parameter is invalid, then the function raises a . Because Python dictionaries are mutable data types, you can change the values of in place from within without using or . You can even add new key-value pairs if they’re valid configuration parameters. For example, the first call to adds the parameter, while the second call updates the parameter. It’s important to note that configurations and settings are often an important part of an app or system’s global state. Changing a configuration while that system is running mutates its global state. You should only make this type of change if you’re being very careful. Some apps and software systems ask for a restart or reload after you change some of their configuration parameters. That’s a good way to deal with this kind of state mutation.\n\nAs you’ve already learned, you can use the keyword or the built-in function to access and modify a global variable inside a function. What’s really interesting and probably surprising is that you can also use these tools to create global variables inside a function. Note: While you can create global variables inside functions using the keyword or the function, this is pretty uncommon, and it’s not a best practice. It can make your code harder to understand and maintain. It’ll be better to define global variables at the module level outside of any functions. This way, their scope will be clear, and you won’t run the risk of getting a if you use the variable before calling the defining function. In this example, you create a global variable inside a function using the keyword: Here, the function uses the keyword to define as a global variable. When you call the function, is defined, and its value is set to . After the call, you can access from anywhere else in the program. You can also use the function to define new global variables inside your functions. This tool gives you additional flexibility, allowing you to create global variables dynamically: In this example, the function uses the function to define a new global variable using a name as a string and a value. The call to your function creates a new global variable called with a value of . For a more realistic example, say that you have a configuration file in JSON format. You want to process the file and load all the configuration parameters directly into your global namespace so that you can use these parameters in other parts of your code as global variables. Your file may look something like this: This file defines a key, whose value is a dictionary of keys and values. You’ll use this dictionary as the initial setting for your application’s database. The file also defines an API key, a base URL, and a timeout for connecting to an API. The following code takes care of loading the JSON file and creating the required set of global variables for you: In this code snippet, you define , which takes and as arguments. Then you use to create a global variable using as the variable name and as its value. In the statement, you open the configuration file for reading and assign the file object to the variable. Then you use a loop to process the loaded configuration and create new global variables for each key-value pair. After you’ve completed this process, you can access all your configuration parameters as global variables in your code. Even though defining global variables within your functions using either the keyword or the function is perfectly possible in Python, it’s not a best practice. You must be careful when defining global variables in this way. Those variables become available to your entire program, so other pieces of your code can modify them. Because of this, you can end up with code that’s difficult to understand, test, maintain, and debug. Maybe you’re noticing a bit of a pattern. There are plenty of ways to use and define global variables in your functions, but does that mean you should? In the next section, you’ll explore this question.\n\nAvoiding Global Variables in Your Code and Functions As you learned in the previous section, relying on global variables in your functions and in your code can cause a few undesirable effects. These variables can make your code harder to understand, test, and debug. They can also lead to less maintainable and reusable code. So, you must use global variables with care and control. Fortunately, there are some neat strategies that you can use to minimize the need for global variables in your code. Perhaps the most intuitive strategy for avoiding global variables is to use global constants. Unlike variables, constants must not change their value during the code execution. So, they promote the safe use of global names. Note: Python doesn’t support strict constants or non-reassignable names. To define a constant in Python, you should use uppercase letters with underscores. However, this is just a naming convention and doesn’t prevent developers from assigning new values to your constant. So, you need to be careful and never write code that changes the values of constants. To illustrate how to use constants instead of using global variables, say that you have some general configuration parameters and want to make them accessible from all parts of your program. In this case, you can use global constants. You’ll typically define constants at the top of your module right after the imports. Here’s an example of some constants in Python: You can use constants to store values that won’t change during your program’s execution. Constants can help you prevent accidental modification of values. They also improve code readability and maintainability. Once you’ve defined your constants, you can access them in your functions across your code. You just need to make sure to keep them unchanged. For example, below is a function that loads an image from NASA’s main API page: In this example, you import from the Python standard library. This module allows you to quickly open URLs in your default browser. Then you import the library to make HTTP requests to the target REST API. Note: To learn more about accessing REST APIs in your code, check out Python & APIs: A Winning Combo for Reading Public Data. Inside , you access the three global constants directly, just like you would do with any global variable in Python. However, you don’t change the value of any of the constants inside the function. Now you can reuse these constants in other related functions as well. Using constants this way allows you to improve your code’s readability and maintainability. Additionally, because they’re constant, you don’t have to keep track of their current values when you’re debugging or testing the code. You’ll always know their values. To give the above example a try, go ahead and run the following code: The call to will get you the image that NASA has for November 21, 2024. The image will open in your default browser. You can experiment with other dates and get your own images. Take Arguments and Return Values in Functions Writing functions that take arguments and return values instead of relying on global variables is another good strategy to avoid global variables in your code. These types of functions are known as pure functions and are the foundation of functional programming, which is a popular programming paradigm nowadays. Pure functions are often totally decoupled from other parts of your code. More importantly, they don’t produce any side effects, like changing the state of global variables. These features make them more reusable and easier to understand, debug, test, and maintain. As an example, here’s a new implementation of your old friend without using a global variable inside the function. In this case, the function just takes a value as an argument and returns it incremented by one: This new version of doesn’t rely on external values from global variables. So, its result will only depend on its input argument. Every time you run this function with the same argument, you’ll get the same result, which makes this function easier to test, understand, and debug. The function is completely decoupled from any other part of your program so that you can reuse it even in a different program. In this example, you mutate your variable only in the global scope. You don’t perform inter-scope mutations, so you make your code safer and easier to understand. Sometimes you have one or more functions that operate on or with some global variables. In those cases, you can think of writing a class that turns the functions into methods and the global variables into instance attributes. For example, say that you’re coding an app to manage your bank account. You start by creating a bunch of functions that operate on the account’s balance: \"Not enough funds for this transaction\" \"What would you like to do? \"Invalid operation. Please try again.\" In this code, you rely on a global variable to store the balance of your bank account. You have three functions that provide common operations on the account balance. You can deposit money, withdraw money, and check the current balance of your account. The function defines a loop that presents you with a text-based user interface (TUI). Through this interface, you can tell the app to perform the desired operations on your account. Here’s how this app works in practice: python account_global.py What would you like to do? What would you like to do? What would you like to do? What would you like to do? Great! The app works as expected. It allows you to make deposits, withdraw funds, and check your current balance. Now say that you don’t like depending on global variables too much, and you decide to refactor the app using a class. To do this, you need to run the following steps:\n• Define a class with an appropriate name. works for this example.\n• Move the global variables into the class, converting them into instance attributes.\n• Move the functions into the class as instance methods. \"Not enough funds for this transaction\" \"What would you like to do? \"Invalid operation. Please try again.\" In this new version of your accounting program, you’ve defined a class called . This class has an instance attribute to store the account’s balance. This attribute used to be your old global variable. You also converted the and functions into instance methods with the current instance, , as the first argument. Finally, inside the loop, you instantiate the class and call its methods on that instance to make the app work the same as the old version. Note that in this implementation, you don’t have a method. So, to access the account balance, you can directly use the attribute."
    },
    {
        "link": "https://discuss.python.org/t/global-variables-shared-across-modules/16833",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/32464260/using-and-modifying-global-variables-across-multiple-modules-in-python",
        "document": "Python is my newest language (Python-2.6), my background is in C/C++. Normally, I would create a global variable and be able to modify and access it across all of my files. I am trying to achieve that same functionality in python.\n\nBased off of this post: Python - Visibility of global variables in imported modules I see that \"Globals in Python are global to a module, not across all modules\". I have multiple variables that rely on user input, and must be accessed and modified by four different modules and in the main code, which is why I am trying to use global(ish) variables in Python.\n\nI have two attemps to make this work:\n\n1) If I stick the code with the modifiable global variables in my main code, I run into the issue of \"Executing the Main Module Twice\" as detailed here: http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html The program works, other than being executed twice.\n\n2) If I create a separate module and put the variables into a function, I find that I have undefined variables in my other modules and my code will error out. From steping through the code, I see that when the variables are accessible/modifiable by moduleA, but then everything breaks when moduleB and moduleC try to use them, because the modifications did not stay.\n\nHow do I utilize Python to suit my needs? I believe my problem lies with attempting to use global variables and importing the global variables"
    },
    {
        "link": "https://stackoverflow.com/questions/40015876/how-to-share-mutable-variables-across-python-modules",
        "document": "I need to share variables across multiple modules. These variables will be changed asynchronously by threads as the program runs.\n\nI need to be able to access the most resent state of the variable by multi modules at the same time.\n\nMultiple modules will also be writing to the same variable.\n\nBasically what I need is a shared memory space, like a Global var within a module, but is accessible & changeable by all other modules asynchronously.\n\nI'm familiar with locking a global variable within a module. I have no idea where to start doing this across multiple modules.\n\nHow is it done?"
    },
    {
        "link": "https://index.dev/blog/how-to-set-global-variables-python",
        "document": "Explore a complete guide on setting and managing global variables across multiple Python modules. Covers different approaches, best practices, and unique code examples.\n\nGlobal variables in Python let you store values that you can access across multiple modules in your project. But if you don’t handle them carefully, they can cause unexpected bugs and hard-to-debug issues.\n\nIn this guide, I’ll walk you through everything you need to know about managing global variables across modules, covering best practices, common mistakes, and practical examples.\n\nWant to work on exciting global projects? Join Index.dev and get matched with top companies for high-paying remote jobs!\n\nA is a variable declared at the top level of a script or module, making it accessible throughout that module. But if you need to use the same variable across multiple files, you have to structure your code properly.\n\nExample of a Simple Global Variable in One Module\n\nThis debug_mode variable is accessible in config.py, but if you want to use it across multiple files, you need to import it correctly.\n\nOne way to use global variables across modules is to define them in a separate module and import them where needed.\n\nNow, in another module:\n\nIf you change debug_mode inside main.py, it won’t affect config.py unless you explicitly update it:\n\nThe change persists only within the current script (main.py), but it doesn't modify config.py itself.\n\nIf you need to modify a global variable inside a function, use the global keyword.\n\nThen, in another module:\n\nThis ensures that changes made inside enable_debug() reflect across modules.\n\nBy default, Python caches imported modules. If a global variable changes in one module, other modules may not see the update unless they reload it.\n\nThis is useful if a module is modified dynamically, but in most cases, a structured approach with setter functions is better.\n\nInstead of using raw global variables, you can encapsulate them within a class for better organization.\n\nUsing a class keeps global state organized and prevents unintended overwrites.\n\nA singleton ensures that only one instance of a configuration object exists.\n\nThe singleton pattern ensures all modules share the same global state.\n\nBest Practices for Using Global Variables in Python\n• None Avoid modifying imported modules directly. Instead, use setter functions or classes.\n• None Use a dedicated config module for shared settings and constants.\n• None Consider using environment variables for sensitive or runtime-dependent settings.\n• None Use a singleton or class-based approach to avoid conflicts.\n\nLearn More: How to Check If a Set Is Mutually Exclusive in Python\n\nSetting global variables across modules in Python can be done in multiple ways, from simple imports to using the singleton pattern. The best approach depends on your use case. If you need a quick solution, using a separate config module works well. If you need better control, using classes or singletons is a cleaner approach.\n\nBy following best practices, you can manage global variables effectively without introducing unexpected bugs or performance issues.\n\nFor Developers: Level up your career with remote opportunities! and get matched with top companies worldwide.\n\nFor Clients: Need top Python developers? in 48 hours with a 30-day risk-free trial!"
    },
    {
        "link": "https://forum.visualcomponents.com/t/how-to-share-global-variables-between-python-files/529",
        "document": "I have one task list (tasks = [task1,task2,task3]) to be executed using AGV caller, however new task will be assigned using tasks.append(new task) as well when running the current task list. How can two scripts using the same global variable. I tested the import X.py module like below doesn’t work. x =0 # Default value of the ‘x’ configuration setting\n\n File: mod.py\n\nThis is a feature that is really missing and it is on my personal feature wish list since several years. At the moment it is only possible to share values of component properties or to send signals between the scripts as zesty already mentioned. The only way that succeed for me without using that sharing is to use the ctypes module and working with ctypes pointers from integer addresses. But for a clear working you need a lot of overhead to organize the python objects.\n\nI started ~ two weeks ago with VisualComponents.\n\n Maybe it helps, if you use a class to automatic add Properties\n\n to a Component. This is what I have done: from __future__ import print_function from collections import OrderedDict import sys from vcScript import * class GlobalVariables(object): _variables = OrderedDict() # def __init__(self, properties=None): # if properties is not None: # for name, property in properties.items(): # self[name] = property def __getitem__(self, key): return self._variables.get(key) def __setitem__(self, key, variable): if key in self._variables: return self._variables[key] = variable def __len__(self): return len(self._variables) def __repr__(self): return 'GlobalVariables({})'.format( list(self._variables.keys()) ) def __iter__(self): for item in self._variables.items(): yield item __getattr__ = __getitem__ class GlobalVariable(object): _register = GlobalVariables() _type_mapping = { str: VC_STRING, int: VC_INTEGER, float: VC_REAL, bool: VC_BOOLEAN, } _inv_type_mapping = {v: k for k, v in _type_mapping.items()} def __init__(self, name, type, component_name=\"GlobalVariables\"): self._app = getApplication() self._prop_name = name self._component_name = component_name self._type = type self._prop = self._find_prop() self._validate(self._prop) self._register[name] = self def _validate(self, prop): expected_prop_type = prop.Type expected_python_type = self._inv_type_mapping[prop.Type] given_python_type = self._type if expected_python_type != given_python_type: raise ValueError( 'The property is a type of {} and ' 'the expected Python type is {}, ' 'but got type {} instead.'.format( expected_prop_type, expected_python_type, given_python_type, ) ) def _get_component(self): comp = self._app.findComponent(self._component_name) if not comp: comp = self._app.createComponent() comp.Name = self._component_name return comp def _get_property(self, comp): prop = comp.getProperty(self._prop_name) if not prop: prop = comp.createProperty(self._type_mapping[self._type], self._prop_name) return prop def _find_prop(self): comp = self._get_component() prop = self._get_property(comp) return prop def get(self): return self._prop.Value def set(self, value): if not isinstance(value, self._type): raise ValueError('Got wrong data type {}. Excpected type {}'.format(self._type, type(value))) self._prop.Value = value @property def value(self): return self.get() @value.setter def value(self, value): self.set(value) def __call__(self, value=None): if value is None: return self.get() self.set(value) return value def __repr__(self): return 'GlobalVariable(name=\"{}\", type=\"{}\", component_name=\"{}\")'.format( self._prop_name, self._type, self._component_name, ) def __eq__(self, other): cond1 = self._prop_name == other._prop_name cond2 = self._component_name == other._component_name return cond1 and cond2 def __bool__(self): return bool(self.get()) __nonzero__ = __bool__ print('Getting or creating Properties and Component') all_vars = GlobalVariables() foo = GlobalVariable('foo', int) bar = GlobalVariable('bar', bool) baz = GlobalVariable('fizz', float) faz = GlobalVariable('faz', str) print('Trying an exception...') try: GlobalVariable('bar', float) # bar exists already with the type bool # this does not match except ValueError as e: print('Catching Error:', e, file=sys.stderr) print() print('Creating another bar instance') # creating another instance for 'bar' bar2 = GlobalVariable('bar', bool) # this time the right type print('Get bool of bar', bool(bar), bool(bar2), sep=',') print('Value of bar and bar2:', bar.value, bar2.value, sep=', ') print('Modify bar2 -> True') bar2.value = True # bar2(True) # bar2.set(True) print('Get bool of bar', bool(bar), bool(bar2), sep=', ') print('Testing equallity') print(bar == bar2) #print() #print('Representation:', all_vars) #print('Converted to a list', list(all_vars)) print(all_vars.bar) print(all_vars.bar.value) all_vars.bar.value = False print(all_vars.bar.get()) By the way, it sucks, that there is still Python 2.7 syntax used.\n\n I want format strings, I want typehints, I want asyncio, I want modern Python!\n\nIn Python, it is better to use a single module to hold all the global variables you want to use and whenever you want to use them, just import this module, and then you can modify that and it will be visible in other modules that do the same. Create another Python program to test value is changed or not\n\nif I import a own python script I get the same result like captain_feature here: https://forum.visualcomponents.com/t/how-to-import-pyodbc/243 So do u have a solution for this issue?\n\n Thanks"
    }
]