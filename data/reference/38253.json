[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas",
        "document": "Use the HTML element with either the canvas scripting API or the WebGL API to draw graphics and animations.\n\nThe height of the coordinate space in CSS pixels. Defaults to 150. Lets the canvas know whether translucency will be a factor. If the canvas knows there's no translucency, painting performance can be optimized. This is only supported by Mozilla-based browsers; use the standardized instead. The width of the coordinate space in CSS pixels. Defaults to 300.\n\nThe displayed size of the canvas can be changed using CSS, but if you do this the image is scaled during rendering to fit the styled size, which can make the final graphics rendering end up being distorted. It is better to specify your canvas dimensions by setting the and attributes directly on the elements, either directly in the HTML or by using JavaScript.\n\nThe exact maximum size of a element depends on the browser and environment. While in most cases the maximum dimensions exceed 10,000 x 10,000 pixels, notably iOS devices limit the canvas size to only 4,096 x 4,096 pixels. See canvas size limits in different browsers and devices. Note: Exceeding the maximum dimensions or area renders the canvas unusable — drawing commands will not work.\n\nA canvas can be rendered using the API where the document and canvas are decoupled. The benefit is that a worker thread can handle canvas rendering and the main thread of your web application is not blocked by canvas operations. By parallelizing work, other UI elements of your web application will remain responsive even if you are running complex graphics on an offscreen canvas. For more information, see the API documentation."
    },
    {
        "link": "https://w3schools.com/html/html5_canvas.asp",
        "document": "Your browser does not support the <canvas> element. The HTML element is used to draw graphics on a web page. The graphic to the left is created with . It shows four elements: a red rectangle, a gradient rectangle, a multicolor rectangle, and a multicolor text.\n\nThe HTML element is used to draw graphics, on the fly, via JavaScript.\n\nThe element is only a container for graphics. You must use JavaScript to actually draw the graphics.\n\nCanvas has several methods for drawing paths, boxes, circles, text, and adding images.\n\nCanvas is supported by all major browsers.\n\nA canvas is a rectangular area on an HTML page. By default, a canvas has no border and no content.\n\nThe markup looks like this:\n\nNote: Always specify an attribute (to be referred to in a script), and a and attribute to define the size of the canvas. To add a border, use the attribute.\n\nHere is an example of a basic, empty canvas:\n\nAfter creating the rectangular canvas area, you must add a JavaScript to do the drawing.\n\nHere are some examples:\n\nTo learn more about , please read our HTML Canvas Tutorial."
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://webfx.com/blog/web-design/canvas-element",
        "document": "The HTML5 element has a unique history. Starting out as an Apple creation and dating back to 2004, was eventually added to the official W3C HTML5 spec, becoming one of the most interesting and exciting parts of HTML5. It is used by web designers all over the world. Unfortunately, this element takes a bit of work to understand and, unlike your usual run-of-the-mill HTML elements, requires more than just static markup and styling. This element is great for sites looking for a more responsive web design, like maybe a realtor.\n\nIn this guide, I hope to get you started on understanding the element and what kinds of things are required and expected in its associated code. This should help you get a firm fundamental understanding of in preparation for creating something interesting and powerful with this unique HTML5 element.\n\nI can’t possibly define the element better than the official W3C spec, so I’ll just quote part of that document here:\n\nI also like the way Wikipedia describes its usage:\n\nAs you can see already, this element has a bit of complexity to it. Let’s take it one step at a time, beginning with the markup. The markup for the element looks like this:\n\nSimilar to the element, has a width and height set in the markup to give it an actual size.\n\nAnd because requires scripting for its full capabilities, I’ve added an attribute that will allow us to target it using either JavaScript or a JavaScript web development library like jQuery or MooTools. Once you have this basic markup, you can use CSS to make the visible or, using CSS3 properties, move it around — the same as you would do with any other HTML element. You can add a border, padding, background color, margins, you can float the , and assign CSS properties to it just like any HTML5 element.\n\nSome Basic Scripting to Make It Work\n\nTo start drawing on a canvas, you need to first target it using the Document Object Model (DOM).\n\nSince you can include more than one element on any given page, this is where an ID attribute comes into play (in this case, our ID is ). Once the is targeted, the JavaScript method needs to be called. This method identifies the context of the targeted element, which means you will have access to the canvas drawing API.\n\nHere’s an example of code that draws an object on the canvas:\n\nAfter defining the element via the DOM (line 1), the context is defined (line 2), then a shape is drawn and colored (lines 3 and 4). The first two lines are more or less standard stuff, whereas the third and fourth lines consist of a few examples of custom code using the properties and methods available in the drawing API. The four values given above in the method represent the distance from the x axis, the distance from the y axis, the width, and the height (in that order).\n\nThe above code would generate a box like this: Having this rudimentary understanding of the element, here are some points of note:\n• Every element starts out blank, so it will not appear on the page until something is drawn on it or if it’s styled via CSS (e.g. giving it a border or giving it a background color).\n• Each element appears in the DOM\n• You can erase everything that is drawn on the by resetting the width and/or height of the element\n• The method “returns an object that exposes an API for drawing” (definition straight from the spec)\n• There are currently two kinds of contexts available: and ( is currently the more commonly used context)\n• The element is “resolution-dependent,” which means (unlike SVG) it will not always scale cleanly after rendering\n• The default color for any shape drawn is black\n• Canvas-drawn objects are given colors using RGBA or Hex values\n\nThe 2D context allows for the use of a number of different drawing methods and properties, each utilizing syntaxes familiar to experienced CSS and JavaScript developers. So don’t be intimidated, it’s pretty straightforward stuff. Here are some of the JavaScript methods associated with drawing rectangles:\n• : Draws a rectangle according to the given size and coordinate values and fills the object with whatever is defined in the fill style\n• : Clears the pixels inside the space defined by the given size and coordinate values\n• : Draws the rectangle using strokes or borders (apart from the fill) according to the given size and coordinate values; this is done using the determined stroke style\n\nSimilar to the concept behind drawing rectangles, you can draw straight lines using the and methods. These methods define, by means of x and y coordinates, the start and end points of the lines, or paths, that will be drawn. These methods, however, do not actually draw the visible lines; they prepare the for the actual stroking of the lines that will occur when you call the method.\n\nAssuming the markup remains the same (with the canvas sized at 400×400), the code above (lines 3-6) draws a diagonal line from the top left corner of the canvas (0, 0) to the bottom right corner (400, 400). The last line of code uses the aforementioned method to stroke the path that was prepared on lines 3 and 4. Line 5 has the optional method that can give the line a color, gradient, or pattern. If a stroke style is not declared, the line will be black by default. This is the line that is drawn by the code block above: Here are some further points to note about the drawing API:\n• Coordinates that define paths and shapes can have decimal values, and this is encouraged to ensure line widths in certain circumstances are represented accurately\n• To draw multiple paths in multiple stroke styles, you use the method for each line, then the method to end the path after it’s drawn\n• You can draw any Unicode character onto a element, utilizing the , , and attributes to style and align the characters\n• If you don’t use the typographic attributes on text, the text will display using CSS styles applied to the element\n\nIn step with what is now possible in CSS3 in most modern browsers, the drawing API allows you to fill your shapes and paths with two types of gradients. Here is an example showing a rectangle being filled with a linear gradient:\n\nOn line 3 above, the gradient is stored in memory and is given 4 arguments. The first two arguments are the x and y coordinates that determine the starting point of the gradient; the second two arguments are the x and y coordinates that determine the end point of the gradient.\n\nAfter the gradient is created (but not drawn yet), color stops are added (lines 4-5). Then the fill style is defined on the canvas context, and the gradient that is created on line 3 is added as the value of the fill (line 5). After line 5, everything is just stored in memory, waiting to be used on a shape or path.\n\nThe last line makes the gradient visible by creating a shape on which to place the gradient. This is what the gradient looks like: Here are some notes on gradients:\n• The position of the gradient is relative to the , not the shape (which seems a little odd at first)\n• To make a diagonal gradient across an entire shape, the coordinates of the gradient would be identical to the coordinates and size of the shape\n• The first and last color stops in a linear gradient are represented by 0 and 1, respectively; any additional color stops are represented by decimal values in between 0 and 1. Putting a color stop at 50% of the object, then, would be .5.\n• Radial gradients are created using the method, which takes 6 arguments; the first 3 arguments create a circle for the starting point, and the last 3 create a circle for the end point\n\nOther Methods and Properties Available\n\nWhat I’ve discussed so far are some of the methods and properties that are easier to deal with and understand. Canvas, however, has a much broader set of tools available in its drawing API. Here’s some of what’s available, with links to appropriate parts of the spec:\n\nIt’s strongly recommended that fallback content be used for non-supporting devices. Fallback content is included by putting them between the opening and closing tags. For example, you might have something like this:\n\nThis is a pretty simple example.\n\nIf, for whatever reason, is unavailable, the user will see the image instead. That image will not display if is supported.\n\nMozilla’s Developer Center has a great “skeleton” template for drawing elements. This is the template with some minor modifications.\n\nThe JavaScript of the template does a couple of things. First, it checks when the window has fully loaded, which means the DOM is ready to be worked on.\n\nThis isn’t very efficient because the DOM will be ready even before the entire window is loaded, so on heavier pages, our function will take longer than it should to execute. The better solution would be to use with the argument of , but this isn’t supported in Internet Explorer (which wouldn’t really matter until IE9). If you use a JavaScript web development library like jQuery, then they’ll usually have methods or functions to handle this for you (i.e.\n\n). Another way to make this more efficient is to use inline JavaScript on the element to call the function (as in ), but this uses obtrusive JavaScript and isn’t really a good practice. Secondly, we use feature detection instead of browser sniffing to see if is supported.\n\nWe do this with an if/else control structure. If is not null, then we can assume is supported and that it is ready to be worked on. Otherwise ( ) we can run some code in the event that is not supported (such as telling the user that the page requires a browser with support).\n\nFor CSS, we just draw a black border around the area of the elements to make it easier to see. Then, finally, the HTML just involves giving the element an ID, width, and height.\n\nIf you’re going to spend the time to create some sort of fallback content, then it would be good to know the extent of browser support for the element and its associated scripting. is supported in the following browsers and devices:\n\nUsing a third-party library called ExplorerCanvas, support is available in Internet Explorer 6 and up. All that’s required is to include a single JavaScript file on any page that uses the element. From my limited experience in running some example pages included with the ExploreCanvas library, IE’s rendering of elements is very slow and resource-heavy, so unfortunately this workaround is not very inviting.\n\nYou might think that it’s a little counterproductive and counterintuitive to create simple objects using such complex means.\n\nCanvas, however, should not be utilized for static object creation. Canvas is best used for drawing objects dynamically according to user input, or for updating the display of objects that are dependent on some kind of a dynamic feed of information (such as real-time stock market fluctuations visualized through a line graph).\n\nAlthough I’m not a huge fan of experimental techniques, it may be of value at this point to show what is possible with the element. Here are a few examples of apps and other experiments that do some interesting and downright cool stuff with HTML5 :\n\nA virtual fish tank in your browser using attractive fish built without any graphic files.\n\nIt has realistic fish movements and bubbles. Click on the tank to add as many fish as you want!\n\nAn experiment taking HTML5 to the next level. Each of the circle you see in the background is a Twitter user.\n\nClick on a circle and you’ll see more information about that user. HTML5 Canvas and Audio Experiment\n\nA little experiment that loads 100 tweets related to HTML5 and displays them using a JavaScript-based particle engine. Each particle represents a tweet — click on one of them and it will appear on the screen.\n\nThe international Billiards Tournament is being infiltrated by the terrorist organization CHALK.\n\nDo not let them win! Sink as many balls as possible before the timer runs out.\n\nThis demo is an implementation of a full 8-bit color cycling engine, rendered into a 32-bit HTML5 in real-time.\n\nThere are many color cycling scenes to choose from, with some ambient environmental soundtracks to match.\n\nA simple motorcycle game using and JavaScript. Use keyboard controls to do as many back flips and front flips as you can.\n\nFinally, here are some further articles, tutorials, and libraries that discuss or use the element:\n• Canvas Toolkit: A basic HTML5 drawing library for those familiar with the java.awt.Graphics class in Java.\n• The canvas element: discussed in Mark Pilgrim’s Dive Into HTML5\n• Processing.js: An open programming language for people who want to program images, animation, and interactions using the HTML5 canvas element\n• <canvas> text: A library that allows canvas’s text-drawing methods to work in non-supporting browsers\n• Canvas Demos: Home to applications, games, tools and tutorials that use the HTML5 element\n• An Introduction to the Canvas 2D API: Tutorial on HTML5 Doctor\n• Bouncing a Ball Around with HTML5 and JavaScript\n\nIf you know of any cool libraries, demos, or experiments that use the HTML5 canvas element, please let us know in the comments.\n• Bouncing a Ball Around with HTML5 and JavaScript\n• The Only HTML5 Resources You Need for Getting Up to Speed"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nobjects describe a user interaction with the keyboard; each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard. The event type ( , , or ) identifies what kind of keyboard activity occurred. Note: events just indicate what interaction the user had with a key on the keyboard at a low level, providing no contextual meaning to that interaction. When you need to handle text input, use the event instead. Keyboard events may not be fired if the user is using an alternate means of entering text, such as a handwriting system on a tablet or graphics tablet.\n\nThe following constants identify which part of the keyboard the key event originates from. They are accessed as and so forth. The key described by the event is not identified as being located in a particular area of the keyboard; it is not located on the numeric keypad (unless it's the NumLock key), and for keys that are duplicated on the left and right sides of the keyboard, the key is, for whatever reason, not to be associated with that location. Examples include alphanumeric keys on the standard PC 101 US keyboard, the NumLock key, and the space bar. The key is one which may exist in multiple locations on the keyboard and, in this instance, is on the left side of the keyboard. Examples include the left Control key, the left Command key on a Macintosh keyboard, or the left Shift key. The key is one which may exist in multiple positions on the keyboard and, in this case, is located on the right side of the keyboard. Examples include the right Shift key and the right Alt key (Option on a Mac keyboard). The key is located on the numeric keypad, or is a virtual key associated with the numeric keypad if there's more than one place the key could originate from. The NumLock key does not fall into this group and is always encoded with the location . Examples include the digits on the numeric keypad, the keypad's Enter key, and the decimal point on the keypad.\n\nThis interface also inherits properties of its parents, and . Returns a boolean value that is if the ( or on macOS) key was active when the key event was generated. Returns a string with the code value of the physical key represented by the event. Warning: This ignores the user's keyboard layout, so that if the user presses the key at the \"Y\" position in a QWERTY keyboard layout (near the middle of the row above the home row), this will always return \"KeyY\", even if the user has a QWERTZ keyboard (which would mean the user expects a \"Z\" and all the other properties would indicate a \"Z\") or a Dvorak keyboard layout (where the user would expect an \"F\"). If you want to display the correct keystrokes to the user, you can use . Returns a boolean value that is if the key was active when the key event was generated. Returns a boolean value that is if the event is fired between after and before . Returns a string representing the key value of the key represented by the event. Returns a number representing the location of the key on the keyboard or other input device. A list of the constants identifying the locations is shown above in Keyboard locations. Returns a boolean value that is if the key (on Mac keyboards, the key; on Windows keyboards, the Windows key ( )) was active when the key event was generated. Returns a boolean value that is if the key is being held down such that it is automatically repeating. Returns a boolean value that is if the key was active when the key event was generated.\n\nSome keys toggle the state of an indicator light; these include keys such as Caps Lock, Num Lock, and Scroll Lock. On Windows and Linux, these keys dispatch only the and events. Note: On Linux, Firefox 12 and earlier also dispatched the event for these keys. However, a limitation of the macOS event model causes Caps Lock to dispatch only the event. Num Lock was supported on some older laptop models (2007 models and older), but since then, macOS hasn't supported Num Lock even on external keyboards. On older MacBooks with a Num Lock key, that key doesn't generate any key events. Gecko does support the Scroll Lock key if an external keyboard which has an F14 key is connected. In certain older versions of Firefox, this key generated a event; this inconsistent behavior was Firefox bug 602812."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe event is fired when a key is pressed.\n\nUnlike the deprecated event, the event is fired for all keys, regardless of whether they produce a character value.\n\nThe and events provide a code indicating which key is pressed, while indicates which character was entered. For example, a lowercase \"a\" will be reported as 65 by and , but as 97 by . An uppercase \"A\" is reported as 65 by all events.\n\nThe event target of a key event is the currently focused element which is processing the keyboard activity. This includes: , , anything that is , and anything else that can be interacted with the keyboard, such as , , and . If no suitable element is in focus, the event target will be the or the root. The event bubbles. It can reach and .\n\nThe event target might change between different key events. For example, the target for pressing the key would be different from the target, because the focus has changed."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener",
        "document": "Note: This feature is available in Web Workers. The method of the interface sets up a function that will be called whenever the specified event is delivered to the target. Common targets are , or its children, , and , but the target may be any object that supports events (such as ). Note: The method is the recommended way to register an event listener. The benefits are as follows:\n• It allows adding more than one handler for an event. This is particularly useful for libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries or extensions.\n• In contrast to using an property, it gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).\n• It works on any event target, not just HTML or SVG elements. The method works by adding a function, or an object that implements a function, to the list of event listeners for the specified event type on the on which it's called. If the function or object is already in the list of event listeners for this target, the function or object is not added a second time. Note: If a particular anonymous function is in the list of event listeners registered for a certain target, and then later in the code, an identical anonymous function is given in an call, the second function will also be added to the list of event listeners for that target. Indeed, anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, even if in a loop. Repeatedly defining the same unnamed function in such cases can be problematic. (See Memory issues, below.) If an event listener is added to an from inside another listener — that is, during the processing of the event — that event will not trigger the new listener. However, the new listener may be triggered during a later stage of event flow, such as during the bubbling phase.\n\nThe value of \"this\" within the handler It is often desirable to reference the element on which the event handler was fired, such as when using a generic handler for a set of similar elements. When attaching a handler function to an element using , the value of inside the handler will be a reference to the element. It will be the same as the value of the property of the event argument that is passed to the handler. my_element.addEventListener(\"click\", function (e) { console.log(this.className); // logs the className of my_element console.log(e.currentTarget === this); // logs `true` }); As a reminder, arrow functions do not have their own context. my_element.addEventListener(\"click\", (e) => { console.log(this.className); // WARNING: `this` is not `my_element` console.log(e.currentTarget === this); // logs `false` }); If an event handler (for example, ) is specified on an element in the HTML source, the JavaScript code in the attribute value is effectively wrapped in a handler function that binds the value of in a manner consistent with the ; an occurrence of within the code represents a reference to the element. <table id=\"my_table\" onclick=\"console.log(this.id);\"> <!-- `this` refers to the table; logs 'my_table' --> … </table> Note that the value of inside a function, called by the code in the attribute value, behaves as per standard rules. This is shown in the following example: <script> function logID() { console.log(this.id); } </script> <table id=\"my_table\" onclick=\"logID();\"> <!-- when called, `this` will refer to the global object --> … </table> The value of within is a reference to the global object (or in the case of strict mode. Specifying \"this\" using bind() The method lets you establish a fixed context for all subsequent calls — bypassing problems where it's unclear what will be, depending on the context from which your function was called. Note, however, that you'll need to keep a reference to the listener around so you can remove it later. This is an example with and without : class Something { name = \"Something Good\"; constructor(element) { // bind causes a fixed `this` context to be assigned to `onclick2` this.onclick2 = this.onclick2.bind(this); element.addEventListener(\"click\", this.onclick1, false); element.addEventListener(\"click\", this.onclick2, false); // Trick } onclick1(event) { console.log(this.name); // undefined, as `this` is the element } onclick2(event) { console.log(this.name); // 'Something Good', as `this` is bound to the Something instance } } const s = new Something(document.body); Another solution is using a special function called to catch any events: class Something { name = \"Something Good\"; constructor(element) { // Note that the listeners in this case are `this`, not this.handleEvent element.addEventListener(\"click\", this, false); element.addEventListener(\"dblclick\", this, false); } handleEvent(event) { console.log(this.name); // 'Something Good', as this is bound to newly created object switch (event.type) { case \"click\": // some code here… break; case \"dblclick\": // some code here… break; } } } const s = new Something(document.body); Another way of handling the reference to is to use an arrow function, which doesn't create a separate context. class SomeClass { name = \"Something Good\"; register() { window.addEventListener(\"keydown\", (e) => { this.someMethod(e); }); } someMethod(e) { console.log(this.name); switch (e.code) { case \"ArrowUp\": // some code here… break; case \"ArrowDown\": // some code here… break; } } } const myObject = new SomeClass(); myObject.register();\n\nconst elts = document.getElementsByTagName(\"*\"); // Case 1 for (const elt of elts) { elt.addEventListener( \"click\", (e) => { // Do something }, false, ); } // Case 2 function processEvent(e) { // Do something } for (const elt of elts) { elt.addEventListener(\"click\", processEvent, false); } In the first case above, a new (anonymous) handler function is created with each iteration of the loop. In the second case, the same previously declared function is used as an event handler, which results in smaller memory consumption because there is only one handler function created. Moreover, in the first case, it is not possible to call because no reference to the anonymous function is kept (or here, not kept to any of the multiple anonymous functions the loop might create.) In the second case, it's possible to do because is the function reference. Actually, regarding memory consumption, the lack of keeping a function reference is not the real issue; rather it is the lack of keeping a static function reference.\n\nIf an event has a default action — for example, a event that scrolls the container by default — the browser is in general unable to start the default action until the event listener has finished, because it doesn't know in advance whether the event listener might cancel the default action by calling . If the event listener takes too long to execute, this can cause a noticeable delay, also known as jank, before the default action can be executed. By setting the option to , an event listener declares that it will not cancel the default action, so the browser can start the default action immediately, without waiting for the listener to finish. If the listener does then call , this will have no effect. The specification for defines the default value for the option as always being . However, to realize the scroll performance benefits of passive listeners in legacy code, modern browsers have changed the default value of the option to for the , , and events on the document-level nodes , , and . That prevents the event listener from canceling the event, so it can't block page rendering while the user is scrolling. Because of that, when you want to override that behavior and ensure the option is , you must explicitly set the option to (rather than relying on the default). You don't need to worry about the value of for the basic event. Since it can't be canceled, event listeners can't block page rendering anyway. See Improving scroll performance using passive listeners for an example showing the effect of passive listeners.\n\nThe following example shows the effect of setting . It includes a that contains some text, and a check box. <div id=\"container\"> <p> But down there it would be dark now, and not the lovely lighted aquarium she imagined it to be during the daylight hours, eddying with schools of tiny, delicate animals floating and dancing slowly to their own serene currents and creating the look of a living painting. That was wrong, in any case. The ocean was different from an aquarium, which was an artificial environment. The ocean was a world. And a world is not art. Dorothy thought about the living things that moved in that world: large, ruthless and hungry. Like us up here. </p> </div> <div> <input type=\"checkbox\" id=\"passive\" name=\"passive\" checked /> <label for=\"passive\">passive</label> </div> The code adds a listener to the container's event, which by default scrolls the container. The listener runs a long-running operation. Initially the listener is added with the option, and whenever the checkbox is toggled, the code toggles the option. const passive = document.querySelector(\"#passive\"); passive.addEventListener(\"change\", (event) => { container.removeEventListener(\"wheel\", wheelHandler); container.addEventListener(\"wheel\", wheelHandler, { passive: passive.checked, once: true, }); }); const container = document.querySelector(\"#container\"); container.addEventListener(\"wheel\", wheelHandler, { passive: true, once: true, }); function wheelHandler() { function isPrime(n) { for (let c = 2; c <= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const quota = 1000000; const primes = []; const maximum = 1000000; while (primes.length < quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } console.log(primes); }\n• Initially, the listener is passive, so trying to scroll the container with the wheel is immediate.\n• If you uncheck \"passive\" and try to scroll the container using the wheel, then there is a noticeable delay before the container scrolls, because the browser has to wait for the long-running listener to finish."
    },
    {
        "link": "https://w3schools.com/js/js_htmldom_eventlistener.asp",
        "document": "The method attaches an event handler to the specified element.\n\nThe method attaches an event handler to an element without overwriting existing event handlers.\n\nYou can add many event handlers to one element.\n\nYou can add many event handlers of the same type to one element, i.e two \"click\" events.\n\nYou can add event listeners to any DOM object not only HTML elements. i.e the window object.\n\nThe method makes it easier to control how the event reacts to bubbling.\n\nWhen using the method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup.\n\nYou can easily remove an event listener by using the method.\n\n\n\nThe first parameter is the type of the event (like \" \" or \" \" or any other HTML DOM Event.)\n\nThe second parameter is the function we want to call when the event occurs.\n\nThe third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.\n\nAdd an Event Handler to an Element\n\nYou can also refer to an external \"named\" function:\n\nAdd Many Event Handlers to the Same Element\n\nThe method allows you to add many events to the same element, without overwriting existing events:\n\nYou can add events of different types to the same element:\n\nAdd an Event Handler to the window Object\n\nThe method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support events, like the object.\n\nWhen passing parameter values, use an \"anonymous function\" that calls the specified function with the parameters:\n\nThere are two ways of event propagation in the HTML DOM, bubbling and capturing.\n\nEvent propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first?\n\nIn bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.\n\nIn capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.\n\nWith the addEventListener() method you can specify the propagation type by using the \"useCapture\" parameter:\n\nThe default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n\nThe method removes event handlers that have been attached with the addEventListener() method:\n\nFor a list of all HTML DOM events, look at our complete HTML DOM Event Object Reference."
    },
    {
        "link": "https://geekster.in/articles/keyboard-event-in-javascript",
        "document": "Keyboard events are a feature of JavaScript. They enable developers to handle user interactions through events, allowing them to respond to user keystrokes in real-time. Whether you’re building a game, a form, or an interactive application, understanding how to handle keyboard events is essential.\n• : Developers used this deprecated event to capture the typed character. For modern applications, it’s recommended to use the event for this purpose.\n• : The value of the key pressed (e.g., ‘a’, ‘Enter’).\n• : The physical key on the keyboard (e.g., ‘KeyA’, ‘ArrowRight’).\n• , , , : Boolean properties that indicate whether these modifier keys are pressed.\n• : Indicates if holding down the key causes the event to fire repeatedly..\n\nJavaScript allows attaching event listeners to specific elements or the entire document to capture keyboard events. This can be done using .\n\nWhen you open this HTML file in a browser and press any key, the text inside the element will update to show the key and code of the key pressed. For example, pressing the ‘A’ key will display .\n• Enhanced User Interaction: Keyboard events allow developers to create rich and interactive user experiences.\n• Accessibility: Keyboard events enable navigation and interaction for users who rely on keyboards instead of mice, improving accessibility.\n• Efficiency: For power users, keyboard shortcuts can significantly speed up interaction with web applications.\n• Game Development: Essential for capturing user input in real-time, making them indispensable for web-based game development.\n\nUnderstanding and utilizing keyboard events in JavaScript is crucial for creating responsive and user-friendly web applications. By leveraging these events, developers can enhance interactivity, improve accessibility, and provide a seamless user experience. With the knowledge of event types, properties, and handling methods, you have the capability to implement keyboard interactions in your projects effectively.\n\n1. What is the difference between keydown and keypress events? Pressing any key triggers the keydown event, while typing a character fired the (now deprecated) keypress event. For modern applications, developers recommend using keydown or input to capture character input. 2. Can I detect if modifier keys like Shift or Ctrl are pressed? Yes, you can use the properties , , , and to check if these keys are pressed. 3. Why is the keypress event deprecated? Browsers deprecated the keypress event because it is inconsistent across different browsers and does not handle non-character keys well. Developers find using keydown or input events more reliable and consistent. Using keydown or input events is more reliable and consistent."
    }
]