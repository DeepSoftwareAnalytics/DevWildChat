[
    {
        "link": "https://reddit.com/r/ProgrammingLanguages/comments/aab27a/minimal_programming_language_syntax",
        "document": "Hello! I was thinking of doing interpreter for fun, but I want parsing phase to be very small and efficient. So I was thinking what language syntaxes are minimal, but yet powerful enough to be a useful. Obvious candidate from functional world is LISP/Sheme and obvious candidate from OOP world is Smalltalk. But other options do I have?"
    },
    {
        "link": "https://pointersgonewild.com/2022/05/23/minimalism-in-programming-language-design",
        "document": "Four years ago, I wrote a blog post titled Minimalism in Programming, in which I tried to formulate an argument as to why it's usually a good idea to try to minimize complexity in your programming projects. Today, I want to write about something I've been thinking about for a long time, which is the idea that we also ought to take a more intentionally minimalistic philosophy when designing programming languages.\n\nDesigning a programming language to be intentionally minimalistic is an idea that's highly underrated in my opinion. Most modern programming languages adopt much more of a maximalist design approach. Rapidly adding new features is seen as a competitive edge over other programming languages. The general thinking seems to be that if your language doesn't have feature X, then people will choose to use another language, or that adding more features is an easy way to show progress. This line of thinking is simplistic, and disregards many other key aspects that are necessary for a programming language to succeed and thrive, such as learnability, stability, tool support and performance.\n\nI'd like to make the argument that intentionally designing a programming languages to have fewer features, and to change less rapidly over time, is in itself a powerful feature. When a programming language changes often, it necessarily causes breakage and churn. Tools become out of date, codebases need to be updated, libraries become broken, but it causes churn on the human side too.\n\nI first started programming in C++ around 1998. I haven't really touched the language in a few years, and I have to say, I feel kind of lost. So many new features have been added that it's a different language now. Last year, I wanted to use C++20 modules in a new project, only to find that support in G++ and Clang was so incomplete that modules were just not a viable feature. My general impression at the time was that there aren't enough people working on C++ compilers to keep said compilers up to date. The language has become so complex, and so many new features have been added, that compiler developers are kind of burned out. It seems to me that slowly but surely, C++ is crumbling under its own weight.\n\nSomething that many people forget, is that for a language to succeed, there has to be good tool support. If the language and its feature set keeps changing, then tools need to be updated constantly. One of the many problems with C++ is that its grammar is very hard to parse. That was already the case back in 1998. If you add on top of that the problem that the grammar changes to become even more complex every year or two, what do you think the impact of that will be? The people maintaining C++ tools are going to want to go do something else with their lives, and so will the users of those tools.\n\nMore recently, colleagues and I have decided to port a C codebase to Rust. I'm generally pleased with the core feature set of Rust and I feel that in many ways it's a great improvement over C and C++. However, one of the main weaknesses of Rust, in my opinion, is its high complexity. Both at the syntactic and semantic level, Rust is a very complex language. The syntax can get very verbose, and there's a lot to know, a lot of rules and unintuitive subtleties about what you can and can't do where. The learning curve is steep and the cognitive load is high.\n\nLast week, I was pair programming with a colleague when he said \"I feel like the Rust compiler is always telling me that I'm too stupid\". That remark surprised me, because I'd had the same thought. Somehow Rust feels unergonomic, and the high complexity of the language surely contributes to that feeling that the language is a bit user-hostile. It breaks your intuition, and it constantly feels like the compiler is telling you that you're writing code wrong. Two days after my colleague made that remark, I saw a post appear on Hacker News titled Rust: A Critical Retrospective which echoed similar feelings about Rust's complexity.\n\nIn a lot of ways, I feel like designing a language to be minimalistic, to have fewer concepts, and to choose primitives that combine well together, is a good way to make the language easier to learn. If the programming language has fewer concepts, there's less to learn, and your level of proficiency will increase faster. Code written in a more minimalistic language may also be easier to read. If we think about C++ code, we have a situation where the language has so many redundant features that a typical workplace will mandate that code be written in a subset of C++, with some language features being explicitly banned. That can mean that people writing C++ code at different workplaces will have a hard time reading each other's code because foreign C++ code will be written in a different dialect.\n\nIn some ways, I feel like intentionally minimizing complexity and keeping the feature set small is a way of better respecting programmers. It means we respect that programmers are people with potentially busy lives and many things to do, and that they probably don't have time to read hundreds of pages of documentation to learn our language. Programming languages are user interfaces, and as such, they should obey the principle of least surprise. Minimizing complexity is also a way to reduce cognitive load and respect human limitations. Human beings are amazingly capable creatures, but we're also basically just clever monkeys that can talk. We can only keep a few items in our working memory, we can only account for so many design constraints, and we can only focus for so long. A well-designed programming language ought to help us succeed despite our human limitations.\n\nAt the end of the day, I think that a language's complexity and how intuitive it feels is going to affect its ability to attract and retain new users. In my opinion, the focus on reducing friction contributed greatly to Python's initial success and rapid increase in popularity. I think it's also fair to say that many people were frustrated when the complexity of the Python ecosystem increased, for example, during the switch from Python 2 to 3, or when the redundant walrus operator was introduced.\n\nSo far, I've made multiple references to minimalism and I've also briefly mentioned the principle of least surprise. I've hinted that minimalism also means having a smaller feature set and less concepts to learn. Minimalism doesn't just mean a smaller feature set though. It also means carefully choosing features that combine together seamlessly. If we design a language with a large feature set, there's a combinatorial explosion in how these different features could interact, which means we're more likely to end up with situations where some language features interact together poorly.\n\nImperative programming languages typically make a grammatical distinction between statements and expression. Functional languages instead tend to be structured in a way that everything inside a function body is an expression. The latter is more minimalistic, and also imposes less constraints on the programmer. Some languages impose a distinction between code that can be run at compile time vs code that can be run at program execution time. This distinction often increases the complexity of the language as there tends to be a duplication of language features and fairly arbitrary restrictions as to what code the compiler is able to run at compilation time.\n\nIn terms of minimizing surprise, we want to avoid introducing strange corner cases that only show up in some circumstances. Another important pitfall to avoid is introducing hidden behaviors that the programmer may not expect. An example of this would be the equality operator in JavaScript, which actually includes an implicit conversion to the string type, meaning that evaluates to true. Because of this undesirable hidden behavior, JS actually has a separate strict equality operator which doesn't perform the hidden string conversion. This suggests to me that JS should only ever have had a strict equality operator, and that if you want to convert the values you're comparing to strings before performing the equality comparison, you should just have to explicitly spell that out. It should not be the default behavior.\n\nLanguage design is hard because the space of possible programming languages is infinite, and so compromises have to be made. It's hard to provide hard numbers to quantify what makes one design better than another. Some of the things that can be quantified to some degree are the complexity of the implementation of a language and also the way that a particular language implementation performs.\n\nMy PhD thesis involved the implementation of a JIT compiler for JavaScript ES5. As such, I got to become intimately familiar with the semantics of the language and everything that has to go on behind the scenes to make JavaScript code run fast. At times, that was a frustrating experience. I've become convinced that a lot of the complexity and the hidden behaviors in JS and in many other languages are essentially bad for everyone.\n\nUnnecessary complexity in a language is bad for those learning the language, because it makes the language less intuitive and harder to learn. It's bad for the programmers working with the language everyday, because it increases their cognitive load and makes it harder to communicate about code. It's bad for language implementers and tool maintainers, because it makes their job harder, but at the end of the day, it's also bad for end users, because it leads to software with more bugs and poorer performance.\n\nTo give you an example of unnecessary implementation complexity, many object-oriented languages have this idea, borrowed from Smalltalk, that everything should be an object, including booleans and integer values. At the same time, languages implementation for these languages have to do a lot of work behind the scenes to try and represent integers efficiently (as machine integers) while presenting an interface to the user that resembles that of an object. However, the abstraction presented to the user for an integer object is typically not really the same as that of a normal OOP object, it's a leaky abstraction, because being able to redefine integer values makes no sense, because integer values have to be singletons, and because being able to store properties/attributes on integers is both dumb and terrible for performance and so typically isn't allowed.\n\nUltimately, integers are not objects in the object oriented sense. They're a distinct type of atomic value with a special meaning, and that's okay. The mistaken idea that \"everything should be an object\" doesn't actually simplify anything in practice. We're lying to ourselves, and in doing so, we actually makes the life of both language implementers and programmers more complicated.\n\nThis blog post has turned into more of a rant than I expected it to be. It's easy to critique the status quo, but I'll also try to conclude with some actionable advice. My first piece of advice for aspiring language designers is that you should start small. Your language is a user interface, and an API which people use to interface with machines. The smaller the API surface, the less you risk introducing accidental complexity and subtle design mistakes.\n\nMy second piece of advice is that if you can, you should try to keep your language small. Limiting yourself to a smaller feature set likely means you will want to choose features that don't overlap and that provide the most expressiveness, the most value to programmers. If you do want to grow your language, do it slowly. Take some time to write code in your language and work through the potential implications of the design changes that you are making.\n\nIt's easy to add new features later on, but if you add new features and people begin using them, it's going to be hard or even impossible to take these features back, so choose wisely. Remember that you don't have to please everyone and say yes to every feature request. No language or tool can possibly satisfy every use case, and in my opinion, trying to do so is a mistake.\n\nLastly, remember that language design is an art. It's a delicate balance of many different constraints, just like user interface design. Brainfuck is a language that is very small and has very few concepts, but nobody would call it expressive or elegant. Lisp is regarded by many as one of the most beautiful and elegant languages in existence, but my PhD advisor, a Scheme fanatic, had the habit of writing code with single-letter variable names and very few comments. An elegant language doesn't automatically make for elegant code, but you can encourage good coding practices if you lead by example."
    },
    {
        "link": "https://news.ycombinator.com/item?id=31488778",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/ProgrammingLanguages/comments/tt7kq9/what_syntax_design_choices_do_you_love_and_what",
        "document": "I've recently started working on a language of my own as a hobby project, and with that comes a lot of decisions about syntax. Every language does things a bit differently, and even languages that are very similar have their quirks.\n\nI'm interested in hearing outside opinions; what are some aspects of syntax design that you love to work with, and what are some that make you dread using a language?"
    },
    {
        "link": "https://cstheory.stackexchange.com/questions/52859/where-is-the-model-theory-in-programming-language-theory",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://esoteric.codes/blog/jon-corbett",
        "document": "Jon Corbett's languages Cree# and Ancestral Code allow programming in Cree keywords using Cree concepts and metaphors. In addition to this language, Corbett's PhD research has led to his Indigenous Coding Framework, a work-in-progress that will help other Indigenous communities bring to computation not only their languages but their cultural logic and values as well. Corbett describes the challenges of this work, from the danger of accidentally including colonial understandings in such a system, to working with technologies that assume programming languages have Roman-character keywords.\n\n\n\n» First, for people who are not yet familiar with Cree#, can you describe the how you expect it to be used?\n\n\n\nMy desired output for this language is graphical based. I originally envisioned it as a kind of “Processing for Indigenous Languages”. Where the output is generative and graphic. The generative aspect is crucial in the representation of the Indigenous worldview, because when the program ends whatever display was generated is destroyed (comes to end of life). And subsequent running of the program – though they may produce similar results will never be graphically identical to any previous execution. This mimics the “real” world equivalent of listening to a story from a storyteller – who might change it slightly each time, so the same story is never the same twice.\n\n\n\nAdditionally, many Indigenous peoples use their arts and crafts as knowledge and story histories. So being able to create a graphic from story ties the language to a visual archive, and moves the creative process into a digital practice that has the same result.\n\n» Is it entirely built around story-telling (both in the code itself and in its execution)?\n\n\n\nYes. The programmatic input is provided in story form using nehiyawewin syllabics. Which means existing stories can be used for input, though they may require some formatting adjustments, but the input is thought of as being story-based.\n\n\n\nThe output is also story-based, as it portrays a visual representation of what the story is in text form. However, the output is also dependant on the collection of visual data the programmer has. For example, I currently have a library of “raven” animations, so I can tell a story of “Raven”. But if told a story with “Bear” and “Raven”, it would only show “Raven” until I introduce at least one image to represent “Bear”. These visual collections are necessary at the moment, but I do hope to include modules with instructions for these kinds of characters that then become fully constructed by the program itself. (But that is a future vision idea and I’m not there yet).\n\n» Can it be used for mundane computing tasks as well?\n\nProbably, but depends on your definition of mundane… For example if I wanted to say render a functional calculator, then yes I think I could do that. But if I wanted to write a read-parse method/function for an XML document – then probably not.\n\n» And how does the language function?\n\nIt was (and still is) in a radical flux status – I took my code line editor concept and started adding in some of the comments and suggestions from my prospectus presentation. I am now bringing in a bunch of visual coding ideas that won’t interrupt the “story stream”. But as a quick run through:\n• Starts with a “smudge” command to prep the program\n\nDisplays a visual smoke stream to the user to simulate the smudge\n• Executes the code\n• Now the code is a whole story. Whether it is written by the programmer, or transcribed into the programming interface, this is the base from which the programing is applied.\n\nThe interface I am currently building is combination of other interfaces, but has an almost cinematic editing structure, where the programmer adds or inserts “verbs” at relevant points and further applies “nouns” or parameters if needed.\n• Additionally, the command line coding interface can be brought up for these insertion points to provide direct coding if/when necessary.\n• Because code can run very quickly, there is a “speed/time” control that is ever present that the programmer can use to control when events trigger.\n• Here is a current list of the coding tokens I have thus far, just so you have an idea of what aspects are in the language itself:\n• Keywords\n• – this and that\n• Actors (common entities that are in stories and cannot be used as generic “noun” variable assignments)\n• Numbers\n• The actual words for each number are reserved (there are 104)\n• - a prefix for describing a massive amount of something\n• – literally means “a number”; used in conjunction with syllabic numerals to separate text syllabics from numbers such as:\n• This is changing in my new ui, where you can highlight/tag the numbers instead of specifying that the next “word” is a numeric value as in the (b) example above\n• In terms of using the non-numeric numbers like “ ” I have it structured to use these as randoms for numbers 100 to 1K, 1K to 100K, and 100K to 1M. Because of the generative nature of the outputs I want to create, I wanted these representations to be arbitrary and not-controllable, thereby reflecting the aspects of nature we can’t control. I still feel the system needs a little of this autonomy and that the programmer cannot always have full control.\n\n» Cree# (like Cree) is a morphemic language. Could you explain a bit about how word construction works?\n\nThough I use Cree# (primarily for English speakers). There are actually 3 different iterations of the programming concepts I have been working on:\n• Cree# is my language that includes Western punctuation and notation methods and mimics coding languages like C# and Java.\n• Ancestral Code is my attempt to remove these notations and stick to a more “story-based” NPL-style language that I am more focused on developing now.\n• And wisakecak (sounds kind of like “whiskeyjack” in English) is the Cree word for “Raven, the trickster” who is the “god” character of learning and knowledge in Cree mythology. This iteration of the language is a kind of hybrid of the two (I touch on it briefly in question 10).\n• But these assignments aside, my Cree# version is where I invested a fair bit of time in just figuring out how to write a programming language, and all of the questions and answers here are from this perspective.\n\nSo in terms of construction – here is just a regular language example: the English word horse in Cree is “mistatim” which is a compound of “mista” and “atim” which translates literally to English as “make big” and “a dog” (based on context, if you were on a farm mistatim is unmistakably a horse, and at the pet store you might actually be talking about a large dog). But you can also add a diminutive to “atim” as in “atimosis” (dog made small), and then a combination of all three “mistatimosis” which (again based on context) is either a “small horse/ or a pony” or the “puppy of a large dog”. This kind of construction allows you to alter a word to make it change meaning, and is necessary because there are no adjectives or adverbs in Cree only nouns and verbs. So a “puppy” as a noun is a compound of the noun “dog” and a verb “to make small”.\n\n\n\nAt the moment I use these ideas in image scaling functions. Using “mista” as a prefix to a noun to indicate it is larger and a suffix “osis” or “is” to indicate that it is smaller. So for example using “Raven” (kahkakiw): to display the Raven in a larger size I use mistakahkakiw and to make it smaller it becomes kahkakis (the “is ending” version).\n\n\n\nWe can use another morphemic piece called a re-duplicate to apply a kind of “repeat until” or “loop”. This usually is a “ma” or “pa” or a repeat of the first syllable. For example the word “pimohte” is the word for “to walk/step”, “papimohte” is walking (but not continuous), and “papapimohte” is “keep walking all the time (i.e. continuously without break)”.\n\n\n\nI also use the “kan/ihkan” suffix for variables, this suffix just indicates the noun is artificial. So one could write “kahkakiw kahkakiwihkan” which loosely translates as “Raven is an artificial Raven” or in more traditional equivalent notation:\n\n» How you represent variables, numbers, etc in Cree#?\n• As above the suffix is used to identify variables. Without a preceding word the variable is actually self-assigning because otherwise it is semantically redundant. So using just with nothing preceding the noun of “kahkakiw” becomes the variable and is equivalent to saying:\n\n (the variable “artificial raven” is equal to the actual raven (library))\n\n\n\nOr for a more traditional anglicized code notation\n• Numbers and Arithmetic operators are represented by Cree syllabics but are usually visually smaller. Though Cree Numeracy is no longer widely practiced and we have for the most part adopted Arabic Numerals there are still Cree speakers who know this numeric framework.\n• The basic numeric syllabic chart (1 to 100) looks like this:\n• Single numbers “ones” and “twos” are represented by vertical lines “l” or “sticks”\n• when you have three sticks they combine to the “ᐅ” character for 3\n• the combination of “ᐅᐊ” for 6 can also be read as “almost seven”\n• an interesting note. The written word for 9 in Cree is “kika-mitataht” which literally translates as “almost 10”, yet the Cree numeral is “ᐊll” or 7+2\n• Zero is an 8 pointed star and the “✷” glyph (Unicode 2737) or “✴” (Unicode 2734) are the closest symbols available in Unicode, but the actual star should have the points oriented vertical, horizontal, and at each 45 degree interval, not in the rectilinear fashion. The pinwheel 8 pointed star “✵” is the right idea, but shouldn’t be decorative in appearance.\n• Once I have the opportunity to go back to community, I will see if I can get feedback from users if any of the existing available 8 point glyphs “❂✸✷✵✴⁕” are going to work or if a new glyph will be needed and added to the syllabic orthographic library.\n• The mathematic symbols are also represented by syllabics, for example “ ” for Multiplication which is the syllabic “ka” but is often a leading syllabic in many Cree words.\n• Numerals in this context then, must be rendered in different color fonts and different sizes in the interface. I am now working on a separate font specifically for these so they become visually different from the rest of the code parts because these symbols also represent numbers as well as syllables; confusion in the code when using numbers at the moment is a challenge especially with parsing. So knowing that these symbols represent numerics and are different from the other code-text will help.\n• And an example of a simple calculation like 3*2 would be written: And not as:\n\n» In addition to Cree# itself, you're designing an Indigenous Computing Framework; could you explain the needs it addresses? and communities you hope it will serve?\n\nModern computing frameworks (not just programming, but computing technologies in general) are often focused on efficiencies, logics, and choices that are typically not as valued in Indigenous cultures. Similarly, activities the computer does have evolved from notions of time and behaviors that don’t always reflect Indigenous concepts of “natural” orders. So an Indigenous computing framework puts into practice Indigenous concepts and knowledge. It may not necessarily change or alter the way the computer handles instructions, but it changes the philosophies used in construction and development of software and hardware such as my Cree programming language; and a syllabic keyboard that does not conform to the horizontal rowed keyboards that are ubiquitous to modern computing practices.\n\nAdditionally, this framework introduces axiological (i.e. ethical and spiritual) considerations into the computer’s systemic process, something that does not exist (as far as I know) in the traditional development of computing materials. There does exist some research on “spirituality AND technology” but nothing to my knowledge that treats technology as an integral component of a human’s spiritual being or existence. (Science fiction and cyborgism dabble in these kinds of things, but what I propose is kind of different? I think? lol)\n\nSo for example: A smudge is a small/personal ceremonial practice where a medicinal herb (usually sweetgrass or sage) is burnt. A person then passes their hands and/or objects to be “blessed” through the resulting smoke trails. In a normal smudge you use your hands to draw the smoke towards you – “anointing” your head, ears, eyes, mouth, heart, and body. And then, you “bless” anything else you wish to be “cleansed” of any negative energies such as food, tobacco, eye glasses, and apparently even your laptop. Essentially anything that is responsible for/or can affect your physical or mental well-being can (and many Elders say should) be smudged before use. I have heard from a number of Cree and Métis Elders now that they have physically smudged their laptop “to purify it” before Googling.\n\nUsing the Indigenous Computing Framework – digital representations of this can be encoded, even if just symbolic. But a functional example is the smudge routine I use to start an “acimo” (tell a story) the term I use that is like the term “sketch” used by other programming environments. This smudge routine in the Cree# language resets the screen canvas and prepares any system variables before the program actually starts its run.\n\nTherefore, this kind of reformatting or rethinking of a computing framework becomes a cultural extension of meaning making from a user standpoint (assuming they are invested in an Indigenous cultural experience). It goes beyond relating the requirements of the system, but defines the relationships within the system as cultural practices that occur outside the system making it easier to relate to in terms of the human-computer relationship.\n\nObviously my primary target communities here are Cree communities that are looking for new (and exciting) ways to encourage students (especially in the K-12 grades) to use their heritage language as much as possible, and resist using English as their primary language. Well, when it comes to computing, if there are no resources in their heritage language they are forced to adopt Western practices and English in order to engage with computing and computer programming. In Canada there are close to 600K Métis people (who may or may not speak their heritage language), and another 100K people who are Cree language speakers, and of those there are about 180K who are school-aged. So there is a great opportunity to be able to provide computing education starting at a very young age, without needing to introduce too many logical (i.e. Western) constructs, and without needing to dilute their own cultural practices to accommodate Western theory in order to engage with computers.\n\nRight now I work with people at the Blue Quills University in St. Paul Alberta, and Little Red River Cree Nation in High Level, Alberta and am targeting adult learners first, but my goal is to be able to introduce this programming language and framework to the primary and secondary school curriculum on a much larger scale\n\n» In your talk, you mentioned the danger of accidentally including colonial understandings; could you talk a bit about that challenge and how you decide to include or exclude specific features in the language or framework?\n\nThere are a number of concepts that as a programmer I have come to just accept. Things like “data types, “variables”, “looping”, “conditionals”, and “linear/sequential instructions”. Simply translating these into Cree is not that simple because some of these concepts don’t necessarily exist. Take for example English as a collection of 26 letters that form an alphabet, and is often taught as “ABC’s”. We are taught to read and learn these letters in a left to right sequential fashion, and is very much an algorithmic methodology. But Cree is often taught in a very heuristic and organic way, and is difficult to describe in an “alphabetic ordering”, this system of organization won’t always work.\n\nSo Cree is more of a lateral/parallel thinking form of language (as opposed to serial/sequential per se), so creating a language that relies on a linear (ie line by line process) is one of those “accidentals”. In designing a programming language for Cree, my challenge is to figure out answers to:\n• Is this process necessary? i.e. Must it exist in a linear system? Do I actually need “lines of code”?\n• Can lines of code be grouped and collected and executed in any order and still produce similar results to a strictly linear process?\n• The Cree Star Chart of syllabics is a 2D representation of the language, so can the new programming language also be represented in a 2D format? And how would that work? Is a visual object language better suited?\n• Many [English] programming languages rely on extended symbols and punctuation like quotation marks, semi-colons, braces/brackets, etc.. to mark code for function – in Cree written language there is no punctuation except a period. So is introducing punctuation and symbols that are not part of the language acceptable for purposes of “programming” or is it a form of colonial homogenization?\n\nTaking on other items like “variables” – if I try to describe it in an anglo perspective, it is an abstract item that can represent anything and change from one thing to another, there is no real equivalent in my understanding of Cree, except maybe a Rougarou, which is a Métis/Cree “shapeshifter”. So maybe I can call variables artificial “Rougarous”? But In terms of function, I might describe a variable as a container (like a basket), and that basket can be filled with anything, emptied, and refilled with something else. So declaring a variable I envision in two ways – either it is a changing object, or an object whose contents can be changed. Now which one makes more sense to a Cree language user? This is another step and I haven’t received any feedback on that yet.\n\nFor “data types”, these are separate definitions of entities like numbers or strings – again there is no differentiation in the Cree language for concepts like these. Categorization as a concept is a very fluid I’m still working on this concept, so right now all variables are not type-designated.\n\n“Conditionals”, I currently adopted the idea of “river” from the Alelo “Hawaiian” C# coding group project, so instead of writing “if a = b then” you write “The river flows into smaller rivers when a =b, b=c, c=d, etc…” which is more of a “Select/Case” statement. But it carries with it a sense of the cultural understanding.\n\nFinally, in my hardware design, my Cree Keyboard is based on the Cree Star Chart. In anglo-orientations, cartographic directions are almost situated so that N always points to the top of the page. But in the Cree Star Chart (as I recently discovered), N is the bottom [of the page]. So my PCB design has had to be altered (and I moved the microprocessor to the left side of the board which corresponds as E). This is a perfect example of my Western assumption that the directions are universal. The orientation of the microprocessor to the East is important because it represents the opening to the sun – and is based on knowledge sharing and transmission which is what the keyboard facilitates. So in other words, the Cree Star Chart situates E on the left side of the page not the right. So saying to someone using the keyboard to select the first syllabic character on the East-side of the keyboard, actually means the key that is closest to the center on the left side of the board (ie. reading from inside to outside, and on the left, because North is oriented facing down). These are concepts that are often overlooked and programming in the conventions of left-right, top to bottom, or W-E and N-S don’t fit with Cree epistemologies, and introducing these accidentally because of Western practices is a huge challenge that even I get caught in.\n\n» In terms of working with a high-number Unicode character set, what technical challenges did you face working with existing technologies?\n\nThe first was just getting the interface to accept the required Unicode characters as allowable characters. I use Processing quite a bit as a way to visualize or prototype, and you can can’t use syllabics like “ᑳᐦᑳᑭᐤ” as code, but they are acceptable as strings even though the coding windows show as “☒” characters, unless you use the UTF hex codes. It was a learning curve for sure to get it so I could just cut and paste and save text in syllabics. Notepad++ comes in handy here when things go awry because it retains the syllabics and I can use it to “undo” symbols that get lost or corrupted when running and saving coded stories.\n\nOf course I think one of the largest hurdles is I am not a fluent Cree speaker so language identification when I am in full Cree mode (i.e. All code AND errors are written back in the interface as syllabics), it can be (and often is) a very slow coding process. Even switching it to a Roman Orthography mode (Cree written in a phonetic English form) doesn’t help at times, and I am resisting the temptation to make these elements “English” readable. So a syntax error is one of the few errors I get that I know something happened. Other errors, that I haven’t translated yet, just get logged, but are rarely meaningful. Making sure sufficient error trapping and controls are in place and feedback to the user of problems is a huge undertaking that I think will be in development for a while.\n\n» How did you end up working with both C# and Go for development, and was one easier to work with in terms of these issues?\n\nI originally went with Go, solely based on the great tutorials and book that Thorsten Ball wrote. And I can write code in C# pretty quick, so being new to Go was (and still is) a huge learning curve, but being able to program the GUI and interface in C# helps with the feelings that things are moving along at a pace I am happy with. Since my PhD prospectus I have been thinking a lot about some of the comments and am now looking at making it a hybrid system that uses visual object controls (like Scratch or MaxMSP) in conjunction with textual editing. Because the code is still story-based, the story as code is integral, but I think adding in graphic objects that can be linked to the written story might be useful to speed things up. Especially when using the graphic libraries and animation sequences. Again, this is a new idea that might be worth investing the time now to integrate before I get further along in introducing more complex programming components.\n\nThe biggest hurdles I have are trying to visualize the language I want to make. And the limitations in Processing also carried over in to C#. Which is primarily problematic with just making sure the Unicode de/encoding classes in C# are accurate, this part was actually not that bad – but was tricky to flip my thinking back and forth between actually using the syllabic glyphs I want to use and the hex representation of them I need in the code. I think it is way easier in Go where I am actually able to define my “runes” as Unicode chars, so Unicode wasn’t really a problem per se in Go.\n\nThe next tricky area was converting/translating the instructions (the lexing/parsing process). I’m fairly new to programming language construction, and this part is/was the biggest challenge because of how am trying to keep the cultural aspects of the Cree language present even at that level. The morphemic construction I think is the hardest part. Where in “typical” or “classic” code syntax you can have fairly reliable and distinctive tokens, the challenge with Cree is the relationship of semantic and syntactic construction of morphemes that can be contradictory in an English equivalent but valid in Cree.\n\nSo in allowing a user to code with morphemes introduces a bit of a challenge with understanding how to break a particular word into its individual parts and then derive a programmatic meaning from them. And this is one aspect that I am trying to limit so that functionally it is easy to code with a simple understanding of these word forms – the trick is to make sure the allowed morpheme word combining translates to appropriate tokens and does not result in gibberish, so though it might be syntactically correct and can be executable without error, does it also remain semantically correct? I have yet to see.\n\n» More of an observation, but I'm struck by how your work shows that all programming languages are multicoding: even languages designed to make computer operations clear do so through a metaphor -- you've stated that culture must be a part of that underlying system, that it is always culturally determined. Was this observation what led to you creating these systems initially?\n\nI think this observation actually came about through my “doing” process. Though my original thoughts on using culture in coding came early on, I definitely viewed “culture” as a series of properties (i.e. static properties) of the coding language that I wanted to build, and not a series of characteristics (dynamic properties). The more I progressed in identifying Cree cultural concepts and theorizing their coded representations (and vice versa – identifying coding practices and concepts and attempting to relate them to Cree epistemologies and ontologies) the differences between existing coding paradigms and Cree cultural perspectives that I thought was going to be straight-forward, actually ended up revealing just how deep an individual’s cultural perspective is reflected in the code and the system (regardless of what coding language you use). That was when I started to see how the living and dynamic characteristics of culture can be represented as digital structures on which to build my programmatic language; and is also one of the reasons I needed to define an “Indigenous Computing Framework”. I needed to be able to describe the system in organic terms with respect to the cultural awareness of the programming platform, so things like language sensitivities, cultural practices, digital object behaviours, etc… could be presented with this kind of “meta-language” that carries the cultural metaphoric representations and relationships to the system and extended programmatic functions.\n\n» Who in the larger community has been helpful to you in this work? You mentioned the group working on Alelo -- are there others whose scholarship have been influential (inside or outside of academia)?\n\nWith respect to its overall construction the Alelo team is definitely one – and perhaps the most helpful, just because they encountered a lot of the same issues I had with how to represent programmatic structures with cultural reflection. Quite a bit of what I have built (am still building) is built from a spiritualistic/philosophical point of view. As such, it is very difficult to describe some of the inner workings without explaining a bunch of “the why” that it sits on. One of my greatest sources of “inspiration” comes from Margaret Noori (in particular her poetic description of the computer in the opening poem/paragraph of her article “Praying through a Wired Window”). Other inspirations come from Indigenous academics that have just recently started these crossovers of Indigenous cultural into digital representations. So the late Ahasiw Maskegon-Iskwew’s 2005 essay “Drumbeats to Drumbytes” is one of those first written works that struck me as significant. And more recently, Jennifer Wemigwans’ “A Digital Bundle” (her book, not her thesis) – She does a good job of identifying some of those areas of online and digital cultures that affect Indigenous ways of life, especially with how the Indigenous voice can be represented in digital technologies (without being utterly consumed and lost in the digital wastelands of the machine or cloud that our lives so heavily rely on these days).\n\nBesides those, both Outi Laiti’s and Beth LePansee’s work(s) with Indigenous game programming have also had a significant impact on the work I am involved with. Whether you are programming for a gaming community or for artistic/creative design, the underlying cultural perspectives must be described and exposed to the underlying system. So it is not the product or type of programming you do, but how you use the tools to do it. So, Outi is more focused on the Sami language and how to use it in programming, and Beth always seem to be more in tune with the program’s output, and how to decolonize the system so the resulting product changes the narrative of whatever it is that is being critiqued or (re)presented back to the user or audience.\n\nOf course, I also cannot exclude the Elders and fluent language speakers that I engage with either. But their guidance is never in relation to the machine, but with respect to the community and cultural teachings, which in a weird way these conversations have found their way into the structures I am building – the teachings and language are so heavily intertwined to our being that they have no other choice but to also be woven into how we interface with our machines.\n\nI lastly, in the past year, really enjoyed Ian Arawjo’s “To Write Code: The Cultural Fabrication of Programming Notation and Practice”, some of it is relevant to what I am working on and was actually a good way to define exactly what programming is. I’m also interested in his “Race as Cultural Algorithm, and Racecraft in HCI” article which I have not yet been able to track down (in other words the HCI Proceedings it is listed as being in weren’t available the last time I checked.)\n\n» And as you work on the Indigenous Toolkit, is this lateral / parallel form of computation helpful to other Indigenous groups who are working in this space?\n\nThat, I am not sure about. I like to think it is? Part of the challenge in answering that question, is that even those people I talk to that are technologically savvy and are decently aware of cultural and/or cultural studies – can’t wrap their head around some of the philosophies that I am pursuing (yet!). But I do know that I have had “some” influence on STEM curriculum development for Indigenous youth – based on the 3 different Key Note speeches I gave last year. The teachers and educational organizations that have requested me to speak, approached me because they are struggling with the development of computing courses and programs for computer programming, aimed specifically at Indigenous youth. The best comment I heard after one of my talks was, “I can’t believe we’ve been approaching this all wrong” LMAO. The biggest hurdle I see for others (even other Indigenous groups) is just how entrenched we all are in Western culture, so putting aside what we/they already know within a Western context is so hard to do sometimes, we often feel we have no choice in the decisions a computer makes – and that assumption is something I am absolutely trying to change.\n\n» In the CCSWG2020 thread, you mentioned the way larger numbers (sometimes over 100) are represented idiomatically and sometimes not given a specific value. Is this something which you could expand on a bit? As you develop Ancestral Code, do you see it perhaps handling numbers in this way? (as someone who has myself made a language with restricted numbering for very different reasons [Entropy], I'm curious about how you're handling this).\n\nNumbers are a fun and fascinating topic for me. In Cree, the “max” written number is 1000 or lᑭᒋ (note the 1 or | character at the front), and 1001 starts the numbering over (lᑭᒋl). But a million, which is 1000 x 1000 becomes lᑭᒋᑭᒋ (here note the l only appears at the front of the number group this is because “ᑭᒋ” literally translates as “thousands”) so in this case it is literally read as one thousand thousands. So all the backend math is done by grouping or breaking the numbers down in these groups of a thousands. It is very similar to Roman Numerals, but there are a number of differences that make it complex to program for. For example, my current algorithm still has issues correctly calculating numbers in the 100K – 1M range. It’s weird and might be related to the fact that in my backend I am converting these 1000 groupings into int16s... Still haven’t needed numbers higher than 100 so I am not too concerned about that part right now. But I will be sure to let you know if/when I figure it out. ;)\n\nBecause my original idea for Ancestral Code was to be portable to other cultures, the numeral/symbol representation was an important component I wanted to make sure I could support if the target language and culture were limited in their numeracy, I didn’t want the system to be limiting in that respect. As a way to incorporate those “other numbers” I am working on a special font set that includes ideograms for symbolic or special numbers, such as a circle = 0 (not much of a change there I know, but the number itself is “makikway” which literally means “not something”), ⨁ or ⨂ = 4, ✋= 5, ⛭= 8, person = 20, 🦌 = 100. These are the “special” representations I know I want to include, and I will be basing the designs for 20 and 100 on Cree petroglyphs. So even though (5, llᐅ,✋) would all be acceptable and systemically valid for the number 5, the user has a choice, and depending on the context of the story might opt to use ✋ over llᐅ for example if they were referring to people specifically. It is intended to provide yet another connection to underlying culture, indicating that the number being referred to is special or culturally significant in some way, and not just a symbol that the system requires for computation.\n\nAnother extension of this are symbols for “many” and “a lot” which I currently have as meaning: “many” = any number between 101 to 1000, and “a lot” = any number between 1K and 1M. The ideograms I haven’t figured out yet, but I envision them being predefined “randoms” for those numeric ranges. And I am still/always looking for more ways to use and/or represent numbers with symbolic glyphs.\n\nFinally, if you go back to that CCSG2020 thread, one of responses in that discussion was Jeremy’ (Douglass) comment about using emojis/emoticons for programming so ᐃ=🦆 would be valid. I really like that idea, and I think extending the number-symbols idea to culturally significant symbols in general is another avenue of cultural representation that I think would be a great to explore. So not limiting that discussion just to numbers but to the other programmatic language structures as well which I am looking at now and is one of the biggest changes I am trying to bring in to evolution of the Ancestral Code environment.\n\n» I'd love to hear your thoughts about representing Indigenous understandings in a lexical, top-level symbolism (having the programmer describe choice using a river instead of if/then) and having it embodied in the logic of the language. It is perhaps easier I would think with a more story-oriented language that isn't required to support mundane computer operation\n\nFunny you mention that. That is kind of how I am leaning now. I am still very much working through it GUI-wise, but I am moving towards adding in more visual elements, and am experimenting now with a kind of timeline and mark-up model (I’ll send along a screen shot if I can make it look like how I want it). Essentially, the interface that contains the story exists on a timeline that the programmer then applies program objects at the points in the story they want to render to the stage. And, (you touch on this a bit in the next question) but the first statement being “smudge” is one of those lexical items. Another is “kikway awas” as a SelectCase/Switch which in Cree literally means “What else?”\n\n» When we tell the computer to \"smudge,\" is it an act of automating this symbolic action, or is it an action that now is part of the act of writing code: the programmer visualizing this activity as they begin the act of writing a program?\n\nThis is an intriguing question. From a personal perspective I actually do visualize the smudge in a physical sense, and I also imagine the computer understands the importance as it performs its own tasks in getting everything prepared. There was a great thesis written by Michael Travers back in late 80s (ooh, add this to my list of influences too LOL). His MSc Thesis “Agar: An Animal Construction Kit” and specifically his programming language called Agar (Agents as Gated Rules) both guided me in how to approach the construction of my own language based on Cree. At a very high level, Travers talks about animacy in computing systems and much of his philosophy is in understanding animal behaviors in order to digitally simulate them which is very similar to what I am doing. Only in my case I’m swapping animals for culture – so I’m kind of looking at an environment of computational culturology as opposed to the computational ethology.\n\nI do believe there is a very symbolic interchange between the programmer and the computer, so every programmatic command is part of the storytelling but is also a conversation. I do envision my own programming in Ancestral Code as a conversation with the computer and in creating those symbolic actions there are a number of considerations I have taken – especially in my view of the four main attributes that I have encountered in most programming languages that I am familiar with: “data types, “variables”, “looping”, “conditionals” (as I mention in the last round of questions).\n\nData Types: Right now, I have two data types – that are loosely just described as nouns and verbs, and each has to have an indication of animate or inanimate. These are actually Western words and understandings, Cree never developed terms that describe words as noun/verb or male/female. But in English, noun and verb are acceptable terms and animate/inanimate is a binary that is equivalent to gender and is acceptable as well.\n\nVariables: come in 2 types - “ ” which is a berry bag, and “ ” which is a medicine bag. The difference between the two is in the symbolism attached to each. So if I am declaring a counter (i.e int x = 1) this would be a , it is just a basic container for a mundane or everyday items (and can be animate or inanimate at the moment). But if I need to refer to something that contains sacred meaning or special cultural significance I would use “maskihkîwiwat”. Systemically there is really no difference, but in practice (at the moment) adding or marking a section of the story with maskihkîwiwat will not reveal any new imagery to the stage; I guess it kind of acts as a comment in the code, but there are times when aspects of a variable may need to be revealed so this can be overridden.\n\nLoops: are “ ” (pipona is the plural of pipon). Literally, translates as “winters”, there are also extensions or related looping lexical elements like “ ” = next winter; “ ” = last winter; “ ” = every winter (this is my version of a foreach loop). The significance of winter is an old personal identity word and refers to one’s age. So I am currently 49 winters old, for example. And the reason it is “winter” and not another season is because back in the days before “housing”, if you survived winter it signified your resilience and survival of the most extreme of elements the Earth Mother has, and is a highly respected personal accomplishment. This was a fun one to figure out for me. And when I heard the story of “winter” it just naturally felt like a loop.\n\nConditionals: so far I have a select case/switch called “kikway awa” or translated as “what else or what is this”, and other than that, I used the Alelo group’s concept of river (or “sîpiy” in Cree). So sîpiy is/was the start of an if statement block. I have a pseudocode-mock up in SRO that looks like this:\n\n\n\n\n\nThis is one of those ideas that I don’t think I have come across the right Cree reference for, but I like the metaphor used in Hawaiian so I went with that for now. And I need a “return to the river” which is missing in my list of things I need to include, because right now I have no way to “break” out of the processing if the condition gets satisfied. Always a work in progress.\n\n» Is the smudge visible in the final story that is produced?\n\nFor the “smudge” (“tisamân” or “miyâhkasike”) both commands are acceptable. There is actually an animation I have created for the opening of a “sketch”, where I used a perlin noise filter in Processing to create a rising smoke cloud, so there is a visual that the audience does get to see, and it is the last of the instructions from the smudge call. Right now it is a recorded animation that runs about 10 seconds and is constructed from about 300 transparent .png’s that I merged together in Adobe Premier to make an mp4. So it is just a static item for now. But I am hoping to write this as its own library so the “smoke” is generative and is different each time. \n\n\n\nI have yet to come across a suitable closing though (i.e. to end a sketch). It would be nice to have a closing animation, but I am not aware of anything that I can visually simulate as a closing. The closing instruction I am using is “nipâw” which means to sleep; I originally used “awa nipiw” which means “this died” or “this came to an end” but in truth it is not the end of life for the story, so I “put it to sleep” instead. Once the code is created it becomes “living” and its existence means it lives on, but when not in use it is sleeping. This is also in line with linguistic ideas behind language extinction and revitalization, where languages that are dying due to non-use, are often described as “sleeping” and not extinct per se because as long as records of the language exist (in theory anyway) someone might be able to come along and revive it and bring it back in to use. (Much like Manx and Cornish in England).\n\n» One issue you raised in your PhD presentation is the question of how to keep sacred cultural knowledge from going global. Could you expand on what is at stake and how you're thinking about this as you develop these languages?\n\nMy primary concern here is protecting sacred or protected Indigenous Knowledge that is primarily limited to community members. The topic of Indigenous Knowledge and Intellectual Property is a huge concern in academia today. The concern is that Western/European cultures (especially in today’s age) are very much about sharing information – think about open source coding for example… the intent is that it is usually free to use, modify, and (re)distribute. This all good and fine, but there is no responsibility attached to it – open source doesn’t say “you have a responsibility to ensure this code is not altered to do something bad”. As Westerners we are always hungry for information and knowledge, but the biggest issues that arise from our Western activities are those of appropriation, ownership, and commodification of almost everything – right down to water and air as purchasable resources. These human behaviours are generally frowned upon in most Indigenous communities, as these knowledges and resources technically do not belong to us and are not ours to give, sell, or profit from. They are given to us by the natural forces and being of the Earth, and especially knowledges that are land based are heavily guarded so they cannot be exploited. As a result, you will often come across knowledge keepers these days that talk about protocol, and most stories are shared in a reciprocity framework. \n\n\n\nSo storytelling is usually received in an honoured reciprocity, for example an Elder who is asked to share the “creation story” with a group (which is a fairly common story) is usually offered a gift of tobacco and/or sacred herbs and medicines first (this is “the protocol”). This is something that can’t happen in a recorded session, in a digital archive, or without the Elder present. The elder ALWAYS has a choice to share or not share – an archive does not have that option. Another issue is that Elders are usually specialists in certain knowledges, so even though they may share stories, sometimes they only have part of a full story, and you actually need another story from another storyteller to complete a story, in cases like this you are only getting a part of a story, which means you usually cannot pass on the story until you have the other piece. These are less common, but with digital archives, it becomes an easier task – which leads me to the last issue, that of “work”. From an Indigenous perspective, you need to “do work” which means being a part of the community, participating in ceremonies, and building yourself as representative of that community. Whereas Western cultures are heavily involved in the “me” and immediate personal satisfaction – and might just use Google and Wikipedia to satisfy certain quests for knowledge. In this case there is no work needed, you can be a lazy member of society and still benefit from all the knowledge that is available thanks to Google. \n\n\n\nNow, that all said, when you have the privilege of listening to Elders tell stories they always remind you that there are aspects of the stories that are not told. These are protected and only passed on at their discretion. But in most cases there is not much that can’t be shared, but there are sacred stories that are delivered only in special cases, or at certain times (like in relation to world events – like COVID) but regardless of the story the audience is always expected to be respectful and only pass on those parts of the story that the teller identifies as being ok – in fact the teller will usually say something along the lines of “you now have the responsibility to pass on this [part of] story”. But with our Elder population diminishing, a lot of these sacred stories are probably going to disappear eventually, which means we need proper systems in place to archive this knowledge so the Elders in a community can have a record of these stories so they are not lost forever. And so I see this digital storytelling apparatus that I am building in to Ancestral Code as shouldering a lot of that responsibility – being able to capture even the most sacred of stories - in writing - but still retain and provide the controls over what is shared with the audience. As longs as someone can read the Indigenous language, then reading the code will obviously reveal the whole story, but from an output perspective, if the audience only sees an interpreted visual output they may not actually see the “sacred” aspects of a story as it was recorded. So this is a way of protecting those sensitive stories while at the same time archiving the whole story, and still allowing a larger community (i.e. globe) to be able to experience the story in some way (even if it is edited) and without fear of it revealing teachings and knowledges that are reserved for those with the experience and respect to (re)tell it to future generations.\n\n» What have we not touched on that you want people to understand about your work?\n\nHmmmmm. Good question! What haven’t we touched on? I think, what I most frequently talk about often overlaps considerably with things that are not typically involved with programming: like belief systems and the axiological concerns of programming as an activity. This introduces a greater emphasis on the “value” that programming has, and not just its function. In an Indigenous context this “value” extends beyond the concept of “making the computer do something” to “making the computer an integrated member of the community” and personifying to an extent that it is imbued with all those traits that a community member has. I think it was in Travers’ thesis (that I mentioned earlier) that mentions our natural human inclination to refer to computers and our interfaces in a very human way – how often have you heard things like “my mouse is being finicky”, “my computer died”, or “my computer just decided to do {something} on its own”, and we can also put our computer “to sleep” or “hibernate”, and “wake it up”. Therefore, as humans, we have already established this human-computer relationship that is in some way viewed more as human-human. So in constructing my language(s) for the computer, I am very conscious about this dynamic.\n\nThe only other thing I’m not sure to what extent we have discussed is the wholism of programming. Though English uses wholism and holism synonymously, Indigenous perspectives often use wholism as a form of learning that interconnects all aspects of being, in Cree this includes the four spirits or bodies of being: mind, body, emotion, and spirit (wholism); and is not merely referring to the “whole” as being a sum of (physical) parts (holism). So when in constructing my language(s) and interfaces I am always trying to be mindful of these 4 things and ensuring that any cultural rules or protocol within each one of these segments is not negatively impacting on another. For example differentiating between “âcimowin” and “âtayôhkan” (regular story vs. sacred story). Furthermore, because Indigenous people view learning and storytelling as medicinal, the digital environments I create have to facilitate that understanding as coding is medicine (In a Western perspective, this is kind of like saying coding is therapeutic AND intrinsic to my identity and wellbeing). So I do anticipate coding in Ancestral Code to become a ceremony of types, that involves physical ceremony and practice that extends beyond just typing characters into the machine. There is a true symbiotic relationship that is going to grow from it and the “tool” that is the computer, is going to become a (an honoured) member of the family and/or community.\n\nAs a quick anecdote, the most recent word for a cell phone or digital device in Cree has become “owîcimosiw” (lover; or girl/boyfriend). Of course this has to be used in context, but if you say something like “What is Jane doing?”, and the answer is “She is with (or is talking to) her lover”, it means she is texting or is on her phone/device. This is because these devices have become so intimately tied to us that they are often viewed as being closer us than even our own family or loved ones. Though this is often used in a somewhat sardonic way, it none-the-less is being used a lot more frequently – so “when you leave home to go out – don’t forget to take your lover with you” is becoming more and more common."
    },
    {
        "link": "https://quora.com/Whats-the-purpose-of-the-esoteric-programming-languages",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/Python/comments/spxim1/notebooks_suck_change_my_mind",
        "document": "Just switched roles from ml engineer at a company that doesn’t use notebooks to a company that uses them heavily. I don’t get it. They’re hard to version, hard to distribute, hard to re-use, hard to test, hard to review. I dont see a single benefit that you don’t get with plain python files with 0 effort.\n\nSo is running scripts in your console. If you really want to go line-by-line use a repl or debugger.\n\nSomeone, please, please tell me what I’m missing, because I feel like we’re making a huge mistake as an industry by pushing this technology.\n\nEdit: So it seems the arguments for notebooks fall in a few categories. The first category is “notebooks are a personal tool, essentially a REPL with a diffferent interface”. If this was true I wouldn’t care if my colleagues used them, just as I don’t care what editor they use. The problem is it’s not true. If I ask someone to share their code with me, nobody in their right mind would send me their ipython history. But people share notebooks with me all the time. So clearly notebooks are not just used as a REPL.\n\nThe second argument is that notebooks are good for exploratory work. Fair enough, I much prefer ipython for this, but to each their own. The problem is that the way people use notebooks in practice is to write end to end modeling code that needs to be tested and rerun on new data continuously. This is production code, not exploratory or prototype code. Most major cloud providers encourage this workflow by providing development and pipeline services centered around notebooks (I’m looking at you AWS, GCP and Databricks).\n\nFinally, many people think that notebooks are great for communicating or reporting ideas. Fair enough I can appreciate that use case. Bus as we’ve already established, they are used for so much more."
    },
    {
        "link": "https://github.com/ChessMax/awesome-programming-languages",
        "document": "The list of 920 programming languages that you might be interested in. If you like exploring programming languages, or you are making your own programming language, then it's place for you. Here you can find interesting programming languages that are not well known or promote your own programming language. Also, it's the place to look for a new ideas and inspiration. Feel free to make a contribution.\n• A+ - A+ is a powerful and efficient programming language. It is freely available under the GNU General Public License. It embodies a rich set of functions and operators, a modern graphical user interface with many widgets and automatic synchronization of widgets and variables, asynchronous execution of functions associated with variables and events, dynamic loading of user compiled subroutines, and many other features. Execution is by a rather efficient interpreter. A+ was created at Morgan Stanley. Primarily used in a computationally-intensive business environment, many critical applications written in A+ have withstood the demands of real world developers over many years. Written in an interpreted language, A+ applications tend to be portable.\n• ABC - ABC is an interactive programming language and environment for personal computing, originally intended as a good replacement for BASIC. It was designed by first doing a task analysis of the programming task.ABC is easy to learn (an hour or so for someone who has already programmed), and yet easy to use. Originally intended as a language for beginners, it has evolved into a powerful tool for beginners and experts alike.\n• ABCL - ABCL: An Object-Oriented Concurrent System. The tenet of our ABCL research project is to exploit both paralle. lism and object orientation. Parallelism is ubiquitous in our problem domains; parallelism is not only the source of computational power, but also promotes structural simplicity/naturalness in design and algorithm. Object-orientation accompanying parallelism, enhances system modularity, flexibility, and safety.\n• ABS - ABS is a programming language that works best when you're scripting on your terminal. It tries to combine the elegance of languages such as Python, or Ruby, to the convenience of Bash.\n• ACCEPT - ACCEPT, an approximate compiler for C and C++ programs based on Clang. Think of it as your assistant in breaking your program in small ways to trade off correctness for performance.\n• Ada - A programming language for readable, correct, and performant software. Get started with Alire, the Ada package manager.\n• Adamant - Adamant was to be a general-purpose language with high performance, deterministic safe resource management, and guaranteed thread safety.\n• Adept3x - A language designed to help maximize developer productivity and safety\n• Agda - Agda is a dependently typed functional programming language. It has inductive families, i.e., data types which depend on values, such as the type of vectors of a given length. It also has parametrised modules, mixfix operators, Unicode characters, and an interactive Emacs interface which can assist the programmer in writing the program.\n• Agena - Agena is an easy-to-learn procedural programming language suited to be used in scientific, mathematical, scripting, networking, and many other applications. Binaries are available for Solaris, Windows, Linux, OS/2, Mac OS X, Raspberry Pi and DOS.\n• Aime - aime is an imperative procedural programming language, with a C inspired syntax. It is a high level programming language, with fully automated memory management, and strong static types.\n• Aith - Low level functional programming language with linear types, Generalized Inline Functions, levity polymorphism and regions. Aith is a perfomant systems programming language with am empathises on type systems. As of now Aith is very early stages and very little is implemented.\n• Alan - Alan is a Autoscalable Programming Language:\n• 🔭 Predictable runtime for all computations - A program is represented as DAG(s) where the running time for all computations can be predicted because there is no unbounded recursion or iteration;\n• ⛓ Automatic IO concurrency and parallelism across events and arrays - Alan exploits opportunities for IO concurrency or CPU parallelization across machines in a cluster via arrays and a static event loop without threads, channels, promises, futures, locks, etc;\n• ✅ Almost no runtime errors - No deadlocks, livelocks, undefined variables, divide-by-zero, integer under/overflow, array out-of-bounds access, etc;\n• ⚡️ No GC pauses - Alan’s runtime manages memory allocation, access, and deallocation for you like Java, Python, or Javascript. However, Alan’s static event system and automatic event-oriented memory model does so without garbage collector pauses.\n• Albatross - Albatross is\n• A Programming Language with Static Verification: You can develop programs and algorithms and prove them to be correct in Albatross.\n• A Proof Assistant: Arbitrary mathematical theories can be expressed and proved in Albatross\n• A Theorem Prover: It has a proof engine which supports you significantly in doing proofs.\n• Alda - Alda is a text-based programming language for music composition. It allows you to compose and play back music using only your text editor and the command line.\n• Alumina - Alumina is an imperative, general-purpose, statically typed, compiled system programming language. Alumina is heavily inspired by Rust, especially in terms of syntax and standard library API. Unlike Rust, however, Alumina is not memory-safe and it requires manual memory management.\n• Amiga E - E is an object-oriented/procedural/unpure functional/whatever language with quite a popular implementation on the amiga. It’s mainly influenced by languages such as C++, Ada, Lisp etc., and features extremely fast compilation, inline assembler, large set of integrated functions, powerful module concept, flexible type-system, quoted expressions, immediate and typed lists, parametric and object polymorphism, exception handling, inheritance, data-hiding, methods, multiple return values, default arguments, register allocation, fast memory management, unification, LISP-Cells, macro-preprocessing, a very powerful source-level debugger, gui-toolkit, library linker, and then some.\n• AMPL - AMPL is the most powerful and intuitive tool for developing and deploying complex optimization solutions in business & scientific applications. AMPL connects to most commercial and open-source solvers and allows you to switch easily between them.\n• AngelScript - AngelScript is an extremely flexible cross-platform scripting library designed to allow applications to extend their functionality through external scripts. It has been designed from the beginning to be an easy to use component.\n• Ante - Ante is a low-level functional language for exploring refinement types, lifetime inference, and other fun features. In general, ante is low-level (no GC, values aren't boxed by default) while also trying to be as readable as possible by encouraging high-level approaches that can be optimized with low-level details later on.\n• Antimony - Antimony is a general-purpose toy language. Its primary goal is to be simple and easy to understand, not to be efficient.\n• Ape - Ape is an easy to use programming language and library written in C. It's an offspring of Monkey language, but it evolved to be more procedural with variables, loops, operator overloading, modules, and more.\n• Apex - Apex is an interface definition language (IDL) for modeling software. Generate source code, documentation, integration, everything automatically.\n• APL - APL (named after the book A Programming Language) is a programming language developed in the 1960s by Kenneth E. Iverson. Its central datatype is the multidimensional array. It uses a large range of special graphic symbols to represent most functions and operators, leading to very concise code. It has been an important influence on the development of concept modeling, spreadsheets, functional programming, and computer math packages. It has also inspired several other programming languages.\n• APLX - is an advanced, second generation implementation of the APL language, closely based on IBM's APL2, but with a number of important enhancements.\n• April - April (Array Programming Re-Imagined in Lisp) - The APL programming language (a subset thereof) compiling to Common Lisp.\n• Arend - Arend is a theorem prover and a programming language based on Homotopy Type Theory.\n• Argon - Argon is an interpreted multi-paradigm dynamically typed programming language. Its syntax is mainly influenced by Python, Go and Rust.\n• Ark - Ark is a tiny, fast, and somewhat useful programming language focused on runtime stability and simple code syntax. Every instruction is a single character, but it is NOT an esolang. (anymore)\n• Ark - Ark is a systems programming language focused on being practical and pragmatic. We want a language that is simple, easy to write, yet powerful enough to create readable, performant and concise code for any problem\n• ArkScript - ArkScript is a small, fast, functional and scripting language for C++ projects ; the syntax is inspired by Lisp. It's a scripting language aiming for high portability and easily embedding in C++ projects, with a few nice features such as tail call optimization and macros.\n• Arturo - Arturo is an independently-developed, modern programming language, vaguely related to various other ones - including but not limited to Logo, Rebol, Forth, Ruby, Haskell, D, SmallTalk, Tcl, and Lisp. The language has been designed following some very simple and straightforward principles: a) Code is just a list of words and symbols, b) Words and symbols within a block are interpreted - when needed - according to the context, c) No reserved words or keywords - look for them as hard as you can; there are absolutely none.\n• ASPL - ASPL is a modern programming language featuring beautiful simplicity, seamless cross-compilation, advanced mobile support, powerful C-interoperability, and so much more. It has been designed to be practical for both beginners and experienced programmers and to help you build better software, quicker.\n• astro - Astro is a fun programming language designed for safe high-performance applications. It is essentially a statically-typed systems language that\n• Atom - is a programmable, register based virtual machine for Win32 computers. The program is a text-base console application. The VM can be programmed using a neo-assembler language called Atom Assembler. This document discusses the VM and explains each opcode in Atom Assembler.\n• Atom - A general purpose programming language that easy to use, read and integrated\n• ATS - ATS is a statically typed programming language that unifies implementation with formal specification. It is equipped with a highly expressive type system rooted in the framework Applied Type System, which gives the language its name. In particular, both dependent types and linear types are available in ATS.\n• Austral - A systems programming language that uses linear types to provide memory safety and capability-secure code. [linear types]\n• AutoIt v3 - is a freeware BASIC-like scripting language designed for automating the Windows GUI and general scripting. It uses a combination of simulated keystrokes, mouse movement and window/control manipulation in order to automate tasks in a way not possible or reliable with other languages (e.g. VBScript and SendKeys). AutoIt is also very small, self-contained and will run on all versions of Windows out-of-the-box with no annoying \"runtimes\" required! AutoIt was initially designed for PC \"roll out\" situations to reliably automate and configure thousands of PCs. Over time it has become a powerful language that supports complex expressions, user functions, loops and everything else that veteran scripters would expect.\n• Avail - Avail is a multi-paradigmatic general purpose programming language whose feature set emphasizes support for articulate programming. Avail is an open-source project that comprises a language virtual machine and a standard library.\n• AWKA - Awka is an open-source implementation of the AWK programming language. Awka is not an interpreter like Gawk, Mawk or Nawk, but instead it converts the program to ANSI-C, then compiles this using gcc or a native C compiler to create a binary executable. This means you must have an ANSI C compiler present on your system for Awka to work.\n• B4X - Simple, powerful and modern development tools. With B4X, anyone who wants to, can develop real-world solutions.\n• BabyCobol - BabyCobol is a project in language design aimed at creating a language that is, on one hand, small enough to be quickly implementable (fully or partially) within any framework that can support its features, and, on the other hand, complex enough to cover typical problems of legacy language processing. If you learn how to compile MiniJava, you stand a good chance of implementing a reasonably good compiler for any contemporary programming language. If you show how your language extension works on Featherweight Java, it has a good chance of being applicable to any reasonable modern object-oriented programming language. If you can handle BabyCobol with your tool and with your skills, you are ready to face the challenges of software modernisation, codebase migration and legacy language processing in general. At this day and age, being future proof means being able to handle software of the past.\n• Backlang - A new Rust, C# inspired Language for .Net\n• BAIK - BAIK is a scripting language which syntax is in Indonesian for Windows and Linux on Server, Desktop, Laptop and Embedded Computer, including IoT. It supports GPIO, Animation, PDF, UTF8, Printer, OOP, GUI, CGI, Databases, Graphics and TCP/IP.\n• Bait - Bait is a compiled general purpose programming language with a simple syntax but still powerful feature set and standard library for building reliable software.\n• Ballerina - Ballerina is an open-source programming language for the cloud that makes it easier to use, combine, and create network services.\n• Barn - Barn is a simple programming language written in GoLang and compiled to C++. Syntax is very simple, and Barn can call C/C++ functions natively so creating new bindings should be easy. Barn was written with the goal of being as fast and easy to use as possible. Barn is just a little project with which I can chill and just code.\n• Battlestar - Subset of assembly with an alternative syntax and with support for inline C, specifically for 64-bit x86 Linux, 32-bit x86 Linux and 16-bit x86 DOS.\n• Bau - Bau is a simple, concise, safe, powerful and fast programming language. Features: Easy to learn; Concise syntax; Memory-safe; Statically typed; Fast compilation and execution (transpiles to C).\n• BCPL - BCPL (\"Basic Combined Programming Language\") is a procedural, imperative, and structured programming language. A stripped down and syntactically changed version of BCPL, called B, was the language on which the C programming language was based. BCPL introduced several features of many modern programming languages, including using curly braces to delimit code blocks.\n• Beads - The Beads project is a daring attempt to generate a new language that will replace the current popular toolchain stack of HTML/CSS/JS/+Frameworks+Database, with a single language.\n• Beanshell - BeanShell is a small, free, embeddable Java source interpreter with object scripting language features, written in Java. BeanShell dynamically executes standard Java syntax and extends it with common scripting conveniences such as loose types, commands, and method closures like those in Perl and JavaScript.\n• Beryl - Beryl is a small, interpreted, embeddable scripting language with value semantics and first class functions. The main feature of Beryl is that the core interpreter can run without any dynamic memory allocation*, and it does not need to parse or compile scripts beforehand. It can also be built without any external dependencies, excluding some typedefines and constants needed from stddef.h and limits.h; however these could be provived from a custom header if needed.\n• BETA - BETA is a modern language in the Simula tradition. The resulting language is smaller than Simula in spite of being considerably more expressive. BETA is a strongly typed language like Simula, Eiffel and C++, with most type checking being carried out at compile-time. It is well known that it is not possible to obtain all type checking at compile time without sacrificing the expressiveness of the language. BETA has optimum balance between compile-time type checking and run-time type checking.\n• Bite - Bite is a dynamically typed, object oriented programming language. Dynamically typed, because the type of the content of a variable can change during runtime of the program. Object-oriented, because you can define classes to encapsulate your code and data. Bite uses modules, classes and functions to separate code.\n• BL - The Biscuit Language (BL) is simple imperative programming language using LLVM backend implemented in C. Biscuit is designed to be simple, fast and explicit. Language syntax is inspired by JAI.\n• Bla - We investigate an (unpure) functional language whose concept of environment is not implicit as in traditional languages, but made available explicitly as a first class value. This results in a semantics for environments that is best known from the object oriented paradigm, and gives us a united function/class concept in a very orthogonal way. We also look at the language as a real-world general purpose language, considering semantics (of type-inference, for example), implementation issues, and practical experience in using the compiler.\n• Blacklight - blacklight is a general-pupose multithreading concatenative stack-based programming language with first-class queues and objects with delegation.\n• Blade - Blade is a simple, clean, and embeddable dynamic programming language created to be simple enough for beginners, yet powerful and expressive for professionals. It has a very small syntax set with a very low learning curve. Blade improves upon the best features of JavaScript, Python, and Ruby to give developers a familiar and powerful system that feels native for developers coming from any of these languages and an easy way to leverage the strength of any.\n• Blue - The Blue Programming Language, A powerful, V E R Y Easy to use language, that can compile to eight of your favourite languages. A compiled, dynamically typed, object oriented programming language. Coming in at only 30 keywords, this is an easy to use language with unseen compiler speed. Blue is extremely powerful thanks to it's small, compact, file size. It was written in only 3200 lines of Haxe code.\n• Bob - Bob is a simple object-oriented scripting language. Bob’s syntax is similar to C or C++ but it is dynamically typed and has automatic memory management.\n• Bob2 - Revised version of Bob derived from the Nuon work at VM Labs\n• Bolin - A general purpose language that is:\n• Has features not found in any other language (See a few on the highlights page)\n• Compiles 2.5 million lines per second on a laptop (MacBook Air with an M2 chip).\n• Boo - Boo is an object-oriented, statically typed, general-purpose programming language that seeks to make use of the Common Language Infrastructure's support for Unicode, internationalization, and web applications, while using a Python-inspired syntax[2] and a special focus on language and compiler extensibility. Some features of note include type inference, generators, multimethods, optional duck typing, macros, true closures, currying, and first-class functions.\n• Borealis - Borealis is a small, elegant and consistent scripting language. Includes a C-like syntax that's easy to implement.\n• Boron - Boron is a scripting language similar to REBOL. The interpreter is a C library which may be copied under the terms of the LGPLv3.\n• Bosque - Bosque is an open-source project focused on developing a new Programming Language and Development Tooling Stack. The foundation of this project is the view that mechanization and automated reasoning, along with human and AI agents that leverage them, are the ideas that will define the next era of software development. The foundation of the Bosque language and stack is a carefully constructed core calculus and computation model that are uniquely amenable to automated reasoning. Building on top of this core calculus the Bosque language, as seen by a developer, is a hybrid of functional programming design, ergonomic block & assignment-based syntax, and a number of new features designed to simplify and support writing high reliability code.\n• Brain - Brain is a high-level, purely object-oriented, prototype based scripting language, mostly similar to the Self language.\n• BRL - The Beautiful Report Language. A language designed for server-side WWW-based applications, particularly database applications. It is based on Scheme, which makes the syntax extremely simple yet powerful. This implementation is a Java Servlet using the Kawa Scheme compiler.\n• Bulfinch - Just a little toy language to learn about register-based VMs.\n• β-Juliet - β-Juliet is a fairly minimal event-oriented language. In β-Juliet, the world is modelled as a set of events which have no inherent organization or order. Each event can be denoted with a symbol, such as DominoFalls, CatMeows, or SunSets, or (in version 2.0) a string of symbols, such as Address Line Six Goes High or Greengrocer Falls Asleep on Subway. Each event can cause other events to occur — these are termed consequences of the event. In addition, this causation may be conditional, but the only condition that is possible to check is: given two events, which one happened more recently?\n• C2 - The C2 project attempts to create a new language, strongly based on C. In a nutshell, the main differences with C are:\n• no more header files (too much typing)\n• packages (needed if we can't have includes)\n• compiled per target (not per file)\n• C3 - C3 is a C-like language trying to be \"an incremental improvement over C\" rather than a whole new language.\n• C3 - C3 is a xBase language compiler for 16, 32 and 64 bit's. It generates OBJs that may be directly linked to create an executable application for Windows.\n• CafeOBJ - CafeOBJ is a language for writing formal (i.e. mathematical) specifications of models for wide varieties of software and systems, and verifying properties of them. CafeOBJ implements equational logic by rewriting and can be used as a powerful interactive theorem proving system. Specifiers can write proof scores also in CafeOBJ and doing proofs by executing the proof scores.\n• CakeML - CakeML is a verified implementation of a significant subset of Standard ML.\n• Calc4 - Calc4 is a programming language where everything in its code is an operator.\n• Calcit - Calcit is an interpreter built with Rust, and also a JavaScript code emitter. It's inspired mostly by ClojureScript. Calcit-js emits JavaScript in ES Modules syntax.\n• Camelot - Camelot is a language of the ML family. It is strict, first-order but allows for use-only higher-order functions. It includes object-oriented extensions, mainly for creating and using objects in an existing class hierarchy. Programmers familiar with ML or Ocaml should have no problems understanding the basic language promitives. `\n• Cant - a programming language descended mainly from E and Scheme.\n• Carbon - Carbon is fundamentally a successor language approach, rather than an attempt to incrementally evolve C++. It is designed around interoperability with C++ as well as large-scale adoption and migration for existing C++ codebases and developers.\n• Carp - A statically typed lisp, without a GC, for real-time applications. Carp is a small programming language designed to work well for interactive and performance sensitive use cases like games, sound synthesis and visualizations.\n• CASL - CASL (Compact Application Solution Language) is an easy to use Windows Integrated Development Environment (IDE) that allows you to build applications for the PalmOS®, PocketPC / Windows Mobile and Windows using a single set of code. You can easily create applications that target multiple operating systems using a high-level programming language (similar to BASIC) that will only take a small investment of your time to learn. Even if you have never created software before, CASL can help make your idea a reality.\n• Cassette - A new evolutionary highlevel and readable tape language (unlike brainf), with pattern matching, arity overloading, modules, lambdas (rather quotes) and much more; All topped on with a simple and aesthetic syntax.\n• Castile - A simple imperative language with union types (and a compiler for same, with multiple targets)\n• Cat - Cat is a functional stack-based programming language inspired by the Joy programming language. The primary differences is that Cat provides a static type system with type inferencing (like ML or Haskell), and a term rewriting macro language extension language called MetaCat. Cat is a high-level intermediate language translation that can also be used as a stand alone language for simple application development. In this way it occupies a similar niche to PostScript. Cat is also an appropriate language for teaching of basic programming concepts.\n• Cat9 - Cat9 is a user shell script for LASH - a command-line shell that discriminates against terminal emulators, written in Lua. You probably have not heard of LASH before. If you really must know, check the Backstory section below. LASH just provides some basic shared infrastructure and a recovery shell. It then runs a user provided script that actually provides most of the rules for how the command line is supposed to look and behave.\n• Cecil - Cecil is a purely object-oriented, type-safe, garbage-collected language intended to support rapid construction of high-quality, extensible software.\n• ChaiScript - ChaiScript is one of the only embedded scripting language designed from the ground up to directly target C++ and take advantage of modern C++ development techniques, working with the developer how they would expect it to work. Being a native C++ application, it has some advantages over existing embedded scripting languages:\n• It uses a header-only approach, which makes it easy to integrate with existing projects.\n• It maintains type safety between your C++ application and the user scripts.\n• It supports a variety of C++ techniques including callbacks, overloaded functions, class methods, and stl containers.\n• Chalice - Chalice is an experimental language that explores specification and verification of concurrency in programs. The language supports dynamic object creation, dynamic thread creation (fork and join), mutual-exclusion and readers-writers locks, monitor invariants, thread pre- and postconditions. The language allows fine-grained locking via specifications that track fractional permissions for memory locations. The research project also includes an automatic static program verifier for Chalice.\n• Chapel - Chapel is a modern programming language designed for productive parallel computing at scale. Chapel's design and implementation have been undertaken with portability in mind, permitting Chapel to run on multicore desktops and laptops, commodity clusters, and the cloud, in addition to the high-end supercomputers for which it was originally undertaken.\n• Ciao - Ciao is a modern Prolog implementation that builds up from a logic-based simple kernel designed to be portable, extensible, and modular.\n• Cicada - Cicada language is a dependently typed programming language and an interactive theorem prover. The aim of cicada project is to help people understand that developing software and developing mathematics are increasingly the same kind of activity, and people who practices these developments, can learn from each other, and help each other in very good ways.\n• Circle - Circle is the richest C++ compiler yet. Circle describes a path for evolving C++ to meet the needs of institutional users. The versioning mechanism that accommodated the development of the features above will also accommodate research into critically important areas like memory safety. Rather than insisting on a one-size-fit's-all approach to language development, project leads can opt into collections of features that best target their projects' needs. Features:\n• a modern declaration syntax with fn and var keywords to make clearer, less ambiguous declarations;\n• a simpler syntax for binary expressions, greatly reducing the likelihood of bugs caused by confusing operator precedences;\n• a forward keyword to take the complexity and bugginess out of forwarding references;\n• safer initializer lists, which address ambiguities when calling constructors and non- constructors;\n• nine kinds of template parameters to make templates far more comprehensive;\n• reflection traits to access packs of information about class types, enum types, function types, class specializations, and so on;\n• pack traits for pack-transforming algorithms, like sort, unique, count, erase, difference, intersection, and so on.\n• Circom - Circom is a circuit programming language and a compiler that allows programmers to design and create their own arithmetic circuits for ZK proofs.\n• Cish - A minimal, performant, strongly-typed, and multi-paradigm programming language focused on being practical and pragmatic, yet powerful enough to create readable, performant and concise code for any problem. While Cish has as much to do with Forth as Javascript has with Java, it shares the same minimalist, performance oriented approach and philosophy.\n• Citrine - The inspiration for the Citrine Programming Language comes from Smalltalk (message-based, pure object oriented programming), JavaScript (prototypal inheritance), and BASIC (dynamic scope). The name Citrine refers to the yellow coloured gem and honours the short lived tradition to name programming languages after shiny minerals like Pe(a)rl and Ruby.\n• CLAIRE4 - Claire is a general-purpose programming language, best suited to application software requiring sophisticated data modeling, rule processing or problem solving. WebClaire adds extensions for fuller integration with the operating system and for programming web applications.\n• clio - Clio is a functional, distributed programming language that compiles to JavaScript. It runs in the browser and on the server and is made to be a suitable language for scientific programming. Clio takes advantage of multiple CPUs and multiple CPU cores (parallelism) by default, is able to use network resources, is easy to run on clusters and on the cloud.\n• Clip - Clip is CA-Clipper 5.3 compatible compiler for Linux-UNIX and Cygwin with new OO-model, FiveWin and GTK compatible GUI and many other useful features.\n• CLIPS - Developed at NASA’s Johnson Space Center from 1985 to 1996, the C Language Integrated Production System (CLIPS) is a rule‑based programming language useful for creating expert systems and other programs where a heuristic solution is easier to implement and maintain than an algorithmic solution. Written in C for portability, CLIPS can be installed and used on a wide variety of platforms. Since 1996, CLIPS has been available as public domain software.\n• Clojure - A dialect of Lisp, and shares with Lisp the code-as-data philosophy and a powerful macro system. Clojure is predominantly a functional programming language, and features a rich set of immutable, persistent data structures. When mutable state is needed, Clojure offers a software transactional memory system and reactive Agent system that ensure clean, correct, multithreaded designs.\n• clprolf - clprolf (CLear PROgramming Language and Framework) has been made for simplify programming, especially OOP. It is a superset of java. The clprolf framework is available for Java, C#, or PHP.\n• Clue - Clue is a programming language that compiles into Lua code with a syntax similar to languages like C or Rust. Clue tries to be almost as simple as Lua (with only a slightly more advanced syntax) but adds many optional features that can make code look better or make some things (like metatables) easier to code. Clue does not compile to a specfic version of Lua: flags can be toggled to alter the output to allow most if not all versions or modifications of Lua to be compiled to with Clue.\n• Cmajor - Cmajor is an experimental programming language strongly influenced by C++ and C#. It is semantically closer to C++ than C# and syntactically closer to C# than C++.\n• Cmajor - Cmajor is a programming language for writing fast, portable audio software. Cmajor specifically designed for writing DSP signal processing code.\n• CMOC - CMOC is a 6809-generating cross-compiler for a large subset of the C language. It generates assembly language code for the Motorola 6809 processor and targets the Tandy Color Computer, the Dragon computer, the Vectrex video game console, the Thomson MO and TO computers, and the OS-9 and FLEX operating systems. It runs under GNU/Linux and other Unix-like environments like Darwin and Cygwin. It requires the LWTOOLS assembler (lwasm) and linker, by William Astle.\n• COBOL - COBOL is a compiled English-like computer programming language designed for business use. It is an imperative, procedural and, since 2002, object-oriented language.\n• Cod - Cod is an opensource concatenative stack-based general purpose programming language. Its transpiled to C and then compiled further to a native executable using external compilers like GCC.\n• Cognate - Cognate is a quasi-concatenative stack oriented language that uses embedded comments to read like English prose. It is a dynamic language (yet compiled) and makes great use of combinators and higher order functions. Cognate aims to make functional programming simple, readable, and maintainable.\n• colm - Colm = COmputer Language Machinery. Colm is a programming language designed for the analysis and transformation of computer languages. Colm is influenced primarily by TXL\n• Common Expression Language - The Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate.\n• Common Lisp - A dialect of the Lisp programming language, published in ANSI standard document ANSI INCITS 226-1994. Common Lisp is not an implementation, but rather a language specification. Several implementations of the Common Lisp standard are available, including free and open-source software and proprietary products. Common Lisp is a general-purpose, multi-paradigm programming language. It supports a combination of procedural, functional, and object-oriented programming paradigms.\n• Compis - Contemporary systems programming language in the spirit of C.\n• Component Pascal - Component Pascal is a programming language in the tradition of Niklaus Wirth's Pascal, Modula-2, Oberon and Oberon-2. It bears the name of the language Pascal and preserves its heritage, but is incompatible with Pascal. Instead, it is a minor variant and refinement of Oberon-2 with a more expressive type system and built-in string support.\n• Concurnas - Concurnas is an open source JVM programming language designed for building reliable, scalable, high performance concurrent, distributed and parallel systems\n• Cone - Cone is a fast, fit, friendly, and safe systems programming language. Ideal for complex, data-rich programs requiring responsive performance (e.g., 3D).\n• Coq - Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs.\n• Core - A modern, minimal programming language. In a world in which languages add features until they collapse under their own weight, build a language that is content with itself.\n• Covariant Script - Covariant Script is an open source, cross-platform programming language. High-performance runtime environment. Self-developed efficient compilation system. Powerful and bloat-free extension system\n• Cowgol - A self-hosted Ada-inspired programming language for very small systems. Cowgol is an experimental, Ada-inspired language for very small systems (6502, Z80, etc). It's different because it's intended to be self-hosted on these devices: the end goal is to be able to rebuild the entire compiler on an 8-bit micro, although we're not there yet.\n• Cppfront - Cppfront is an experimental compiler from a potential C++ 'syntax 2' (Cpp2) to today's 'syntax 1' (Cpp1), to learn some things, prove out some concepts, and share some ideas. This compiler is a work in progress and currently hilariously incomplete... basic functions work, classes will be next, then metaclasses and lightweight exceptions.\n• Creed - A concatenative language for text processing script, inspired by ed and sam\n• Crema - Crema is a LLVM front-end that aims to specifically execute in sub-Turing Complete space. Designed to be simple to learn, and practical for the majority of programming tasks needed, Crema can restrict the computational complexity of the program to the minimum needed to improve security\n• Crow - - Crow programs can be run directly from source.\n• You can also build your program to a standalone executable. In either case, you don't need a build system.\n• You can directly call C functions.\n• Data is garbage collected. Don't worry about what's by-reference or by-value.\n• Crow is statically typed. There's no subtyping or implicit conversion. There are no null references. Overload resolution is unambiguous.\n• I/O is controlled. Normal functions can't do I/O except by invoking a lambda from a parameter.\n• You can launch parallel tasks and get the result as a future.\n• Mutability is controlled. The type system tracks whether a type allows access to mutable data. This ensures that mutable data is not shared across threads.\n• Syntax is expression-based. Function bodies are expressions with no return needed.\n• Even if and for are expressions.\n• Code is flat. Most declarations are not nested inside of anything.\n• Expressions are type-checked with an expected type. The same syntax like (1, 2) could be a list, tuple, vector, etc. This saves you from having to write new Foo().\n• There are templates; these are type-checked abstractly, not at each instantiation.\n• All crow code goes in modules. There are no global declarations.\n• Crumb - Crumb is a high level, functional, interpreted, dynamically typed, general-purpose programming language, with a terse syntax, and a verbose standard library. It features:\n• Strictly no side effects* to help you write functional code\n• The ability to localize the effects of imported Crumb files.\n• Crush - Crush is an attempt to make a traditional command line shell that is also a modern programming language. It has the features one would expect from a modern programming language like a type system, closures and lexical scoping, but with a syntax geared toward both batch and interactive shell usage.\n• Crystal - Crystal is a language with a Ruby like sintax, statically type-checked. It supports compile-time evaluation and code generation. It compiles to efficient native code.\n• CSL - CSL is a simple lisp-like macro language for scripting high-level logic and data structures in a way that interfaces easily to the C programming language\n• CSL - The C Scripting Language (CSL) is a programming language available for Windows, OS/2 and UNIX systems. CSL follows the C syntax very closely. It is used like an interpreter: a program written with an editor can be run directly like any shell script. The CSL scripting engine can be integrated into own applications as a macro language. CSL offers two programming interfaces: A \"C\" API for 32-bit C compilers, and C++ class interface for selected compilers.\n• Cubiml - Cubiml is a simple ML-like programming language with subtyping and full type inference. You can try it out online in your browser here.\n• Curv - Curv is a programming language for creating art using mathematics. It’s a 2D and 3D geometric modelling tool that supports full colour, animation and 3D printing.\n• Cyber - Cyber is a fast, efficient, and concurrent scripting language. You can embed it into your applications, games, or engines on desktop or web. Cyber also comes with a CLI, so you can do scripting on your computer.\n• Cyclone - Cyclone is like C: it has pointers and pointer arithmetic, structs, arrays, goto, manual memory management, and C’s preprocessor and syntax. It adds features such as pattern matching, algebraic datatypes, exceptions, region-based memory management, and optional garbage collection.\n• Cylvre - Cylvre is a strongly typed, programming language with type inference for the JVM.\n• cypher - Cypher is Neo4j’s declarative query language, allowing users to unlock the full potential of property graph databases.\n• Céu - Céu is a reactive language that aims to offer a higher-level and safer alternative to C.\n• C∀ - C? (Cforall) is a language design extending ISO C. The purpose of the project is to engineer modern language features into C in an evolutionary rather than revolutionary way. Java is an example of the revolutionary approach of modernizing C/C++, resulting in a new language rather than an extension of its descendents. C++, Fortran 95 and Cobol 9X are examples of the evolutionary approach where modern language features are added and problems fixed within the framework of an existing language.\n• Dachs - Dachs is a general-purpose programming language designed to be enjoyable, statically-typed and dog-friendly. Dachs is intended to be used for efficient applications and tools development, not for system programming.\n• Dafny - Dafny is a verification-ready programming language. As you type in your program, Dafny's verifier constantly looks over your shoulder, flags any errors, shows you counterexamples, and congratulates you when your code matches your specifications. When you're done, Dafny can compile your code to C#, Java, JavaScript or Go (more to come!), so it can integrate with your existing workflow.\n• Dale - Dale is a system (no GC) programming language that uses S-expressions for syntax and supports syntactic macros. The basic language is similar to C, with the following additional features:\n• Dark - Darklang is an integrated language, framework, and editor for building web backends: REST API endpoints, asynchronous background workers, scheduled jobs, and persistent storage. Darklang's framework is tightly coupled to the infrastructure, and as you write code you're able to develop from real incoming requests/traces.\n• Dark Basic Pro - Dark Basic Pro is an open source BASIC programming language for creating Windows applications and games.\n• Darklang - a combined language, editor, and infrastructure to make it easy to build backends and CLIs.\n• Dart - Dart is a programming language designed for client development, such as for the web and mobile apps. It is developed by Google and can also be used to build server and desktop applications. It is an object-oriented, class-based, garbage-collected language with C-style syntax. It can compile to either native code or JavaScript, and supports interfaces, mixins, abstract classes, reified generics and type inference. Primarally used with the Flutter GUI toolkit.\n• Dashrep - Dashrep™, the text-manipulation programming language that is powerful and fast, yet simple\n• Daybreak - Programming language that compiles to C\n• Derw - An Elm-inspired language that transpiles to TypeScript. Derw is a type-safe language in the ML family designed to replace or augment your TypeScript and JavaScript code - both on the client and the server. If you've never encountered an ML language before, some of the core principles - which Derw follows - is a clean and concise syntax, paired with a powerful type system.\n• DeviceScript - TypeScript for Tiny IoT Devices (ESP32, RP2040, ...). DeviceScript brings a TypeScript developer experience to low-resource microcontroller-based devices. DeviceScript is compiled to a custom VM bytecode, which can run in very constrained environments. [Tiny, IoT]\n• Dhall - Dhall is a programmable configuration language that you can think of as: JSON + functions + types + imports\n• Dialect - Dialect is an interpreted programming language with GUI, networking, and object oriented capabilities. The Dialect language (a.k.a. Aristar Dialect Pro) source code has been released to the public under an Apache style Open Source license. The source code is available on sourceforge.net directly from the CVS repository and also as a separate zip package file.\n• Diesel - Diesel is a purely object-oriented, type-safe, garbage-collected language intended to support rapid construction of high-quality, extensible software. Diesel is an evolutionary successor to Cecil, retaining Cecil's support for multimethods, first-class function objects, uniform access to all instance variables and methods via dynamically dispatched messages, predicate classes, multiple inheritance, open classes where methods and instance variables are declared separately from their classes, and a constraint-based polymorphic static type system.\n• Dino - High-Level scripting object-oriented language:\n• Powerful and safe class composition operation for (multiple) inheritance and traits description\n• First class functions, classes, and fibers with closures, anonymous functions, classes, fibers\n• DML - DML is a simple templating language designed for managing web sites based in static HTML files (no CGI, SSI, etc.). It has been obsoleted by DML2 which has in turn been obsoleted by XSLT.\n• DML2 - DML2 is an object-oriented content storage and document formatting framework. Using a fairly simple, object-oriented language and a few templates, generating different types of media from the same source content is made easy. This tool has been obsoleted by XSLT.\n• Draak - Draak is a Multilanguage Macro compiler. What does that mean? Draak is a compiler that has the ablity to compile any language for any platform by being a generic compiler. It reads in a language description file and uses it to compile a program. It has two parts: parser and macros. The parser replaces Yacc and Lex, and the macros replaces the code generation for traditional compilers.\n• Draco - a new .NET programming language under development. If you want further details on the language itself or want to contribute ideas, head over to the language suggestions repository.\n• Dragon - The Dragon is an innovative and practical general-purpose language. The supported programming paradigms are imperative, object-oriented, declarative using nested structures, functional and natural programming. The language is portable (Windows, Linux, macOS, etc.) and can be used to create Console and GUI. The language is designed to be simple, small, flexible and fast.\n• Dream Maker - The DM (Dream Maker) language uses a syntax similar to C/C++ to build networked multi-user worlds. This reference and the accompanying guide discuss the structure and function of DM.\n• Dusa - a logic programming language that has features of both Datalog and answer set programming.\n• DustyScript - The intent of this project is to write a programming language powerful enough to retain a 8/9-yr old's interest but simple enough... that the syntax can be grasped by them\n• DWScript - DWScript is an object-oriented scripting engine for Delphi based on the Delphi language, with extensions borrowed from other Pascal languages (FreePascal, Prism, etc.). It introduces a few Pascal language extensions of its own as well.\n• Dyalect - Dyalect is a dynamic programming language for .NET platform. It is lightweight, fast and modern. Dyalect (or Dy for short) supports Windows, MacOS and Linux. Dy runs on the top of its own high performance virtual machine. It compiles fast and can be used as an embeddable language or as a scripting language of your choice. It is also a good language to learn programming. Dyalect offers modern syntax, inspired by such languages as C#, Swift, Go and Rust, first class functions, coroutines, expressive modules, a dynamic type system with an ability to extend existing types with new methods and much more.\n• Dylan - Dylan is a multi-paradigm functional and object-oriented programming language. It is dynamic while providing a programming model designed to support efficient machine code generation, including fine-grained control over dynamic and static behaviors.\n• E - E is an object-capability programming language and platform for writing distributed, secure, and robust software.\n• Easylang - An easy programming language that runs in the browser. Easylang is a rather minimalistic simple programming language. Because of the clear syntax and semantics it is well suited as a teaching and learning language. Functions for graphic output and mouse input are built into the language. The language is written in C and is open source. Main target platform is the web browser using WASM. However, it also runs natively in Windows and Linux. The one-pass parser and compiler is quite fast. In the Web IDE, each time the Enter key is pressed, the program is parsed and formatted up to the current line.\n• eC - An Expressive and Intuitive, C Style Object-Oriented Programming Language. eC comes bundled with the Ecere SDK, providing a comprehensive API for building apps ranging from games to business, for desktop, mobile and web platforms.\n• Ecstasy - Ecstasy is a new, general-purpose, programming language, designed for modern cloud architectures, and explicitly for the serverless cloud. Actually, to be completely honest, it's the most amazing programming language ever. No, really, it's that awesome.\n• Edina - Edina - A simple stack-oriented compiled programming language. Edina is a simple multi-paradigm programming language. It currently features a JVM compiler, a REPL and an ever expanding standard library. Edina is mostly a hobby project. Due to its stack-oriented design it's a little restrictive and hard to program in, but that's what makes it fun in my opinion.\n• Edward2 - Edward2 is a simple probabilistic programming language. It provides core utilities in deep learning ecosystems so that one can write models as probabilistic programs and manipulate a model's computation for flexible training and inference.\n• EEL - EEL is a scripting and programming language, designed specifically for hard real time applications. The primary target areas of application are control engineering and audio synthesis, but EEL should also be suitable for game scripting and for adding scripting capabilities to real time multimedia applications. The syntax is C-like, but the language is higher level than C, and \"safe\" in the sense that EEL programs should not be able to crash the virtual machine or the host application. EEL has dynamic typing, automatic memory management, exception handling and built-in high level data types such as vectors, arrays and tables. New such data types can be added at run time by host applications. EEL compiles into byte-code that runs on a virtual machine, which means that no explicit support for specific architectures is needed for portability. The implementation is deliberately very self contained and has few dependencies, so that it can be easily integrated into \"strange\" environments, such as embedded devices running real time operating systems.\n• Egel - Egel is an untyped concurrent functional scripting language based on eager combinator rewriting with a concise but remarkably powerful syntax.\n• egison - Egison is a functional programming language featuring its expressive pattern-matching facility. Egison allows users to define efficient and expressive pattern-matching methods for arbitrary user-defined data types including non-free data types such as lists, multisets, sets, trees, graphs, and mathematical expressions. This is the repository of the interpreter of Egison.\n• Eiffel - Based on a set of principles, including design by contract, command-query separation, the uniform-access principle, the single-choice principle, the open-closed principle, and option-operand separation.\n• ela - Ela is a simple, yet powerful modern functional language with a state-of-art syntax. Ela combines strict and lazy evaluation, dynamic typing and features, which are normally adopted by statically typed languages, such as algebraic data types and Haskell style type classes.\n• elastiC - elastiC is a portable high-level object-oriented interpreted language with a C like syntax.\n• Electra - Electra is an esolang where you code like an electrician. Electra is inspired by AsciiDots. It uses instruction pointers that acts like currents in electricity. [eso]\n• Elena - ELENA is a general-purpose language with late binding. It is multi-paradigm, combining features of functional and object-oriented programming. Rich set of tools are provided to deal with message dispatching : multi-methods, message qualifying, generic message handlers, run-time interfaces.\n• ELFE - ELFE (Extensible Language for Everyday (and the Internet of Things)) is a very simple and small programming language specifcally designed for everyday programming, notably for the Internet of Things. While ELFE is a general-purpose programming language, it is designed to facilitate the configuration and control of swarms of small devices such as sensors or actuators. It can also be used as a powerful, remotely-accessible extension language for larger applications.\n• Elijah - a high-level language suitable for replacement of C/C++ and Java. (And of course any other language in existence or non-existence, except FORTRAN and NULL.)\n• Elixir - A dynamic, functional language for building scalable and maintainable applications. Elixir leverages the Erlang VM, known for running low-latency, distributed, and fault-tolerant systems. Elixir is successfully used in web development, embedded software, data ingestion, and multimedia processing, across a wide range of industries.\n• Elm - Elm is a functional language that compiles to JavaScript. It helps you make websites and web apps. It has a strong emphasis on simplicity and quality tooling.\n• Elvish - Elvish is an expressive programming language and a versatile interactive shell, combined into one seamless package. It runs on Linux, BSDs, macOS and Windows.\n• EML - Extended ML (EML) is a framework for specification and formal development of Standard ML (SML) programs. EML specifications look just like SML programs except that axioms are allowed in signatures and in place of code in structures and functors. Some EML specifications are executable, since SML function definitions are just axioms of a certain special form. This makes EML a \"wide-spectrum\" language which can be used to express every stage in the development of a SML program from the initial high-level specification to the final program itself and including intermediate stages in which specification and program are intermingled.\n• EmojiCode - World's only programming language that's bursting with emojis. Emojicode is an open source, high-level, multi-paradigm programming language consisting of emojis. It features Object-Orientation, Optionals, Generics and Closures.\n• emu - Emu (The EMbeddable Utility Language) is a clean, fast, flexible and free programming language. It is designed to be embedded into other files, such as text documents, web page etc\n• Enchilada - Enchilada is optimized to efficiently and consistently share huge amounts of data (and code) in a distributed environment. Possible use cases:\n• Eolang - EO (stands for Elegant Objects or ISO 639-1 code of Esperanto) is an object-oriented programming language based on 𝜑-calculus. We're aware of popular semi-OOP languages and we don't think they are good enough, including Java, Ruby, C++, Smalltalk, Python, PHP, C#: all of them have something we don't tolerate. EO is not planning to become a mainstream language-this is not what we want. Our main goal is to prove to ourselves that true object-oriented programming is practically possible. Not just in books and abstract examples, but in real code that works. That's why EO is being created-to put all that \"crazy\" pure object-oriented ideas into practice and see whether they can work.\n• Erg - A statically typed language that can deeply improve the Python ecosystem.\n• ErgoAI - Flora-2 (now ErgoAI) is an advanced object-oriented knowledge representation and reasoning system. It is a dialect of F-logic with numerous extensions, including meta-programming in the style of HiLog, logical updates in the style of Transaction Logic, and defeasible reasoning. Applications include intelligent agents, Semantic Web, knowledge-based networking, ontology management, integration of information, security policy analysis, and more.\n• Erlang - A programming language used to build massively scalable soft real-time systems with requirements on high availability. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang's runtime system has built-in support for concurrency, distribution and fault tolerance.\n• Eta - What is Eta? Eta is a pure, lazy, strongly typed functional programming language on the JVM. It brings two big ecosystems, the JVM and Haskell, together. This allows you to harness the best of both ecosystems to build your applications quickly and effectively. Eta's concurrency support helps you to build highly scalable systems.\n• ETAC - ETAC™ (pronounced: E-tack) is a syntactically simple but extremely versatile general purpose dictionary and stack based interpreted script programming language fully capable of traditional high-level block structured language style syntax.\n• Euphoria - Euphoria is a powerful but easy-to-learn and easy-to-use programming language. It has a simple syntax and structure with consistent rules, and is also easy to read. You can quickly, and with little effort, develop applications big and small for Windows and UNIX variants (Linux, FreeBSD, and OS X).\n• Evlan - Evlan is a programming language and a virtual machine, similar to Java/JVM or C#/.NET, but with many advantages. While Java and C# are essentially small extensions to the 35-year-old C/C++ software paradigm, Evlan makes a point of being very different.\n• evolve - Evolve is an interpreted programming language, it has been designed to be easy to use so anyone can quickly learn how to write a PC program. To this end the instruction set has been kept to a minimum and the commands and syntax have been kept as simple as possible.\n• execline - execline is a (non-interactive) scripting language, like sh - but its syntax is quite different from a traditional shell syntax. The execlineb program is meant to be used as an interpreter for a text file; the other commands are essentially useful inside an execlineb script. execline is as powerful as a shell: it features conditional loops, getopt-style option handling, filename globbing, and more. Meanwhile, its syntax is far more logical and predictable than the shell's syntax, and has no security issues.\n• Expr - Expression language and expression evaluation for Go.\n• F - F is a pure functional concatenative language originally designed as an extension of False. F contains the list-operations of K3 and the dip combinator of Joy. Floating-point and symbolic datatypes are supported. One-time assignment is enforced in syntax. A theory of function-valence and -charge is outlined. F also contains a general continuation primitive $, and the pattern sublanguage of XY. G is a variant of F in which the K3 adverbs are implemented as primitives.\n• F# - a functional-first, general purpose, strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. Developed by Microsoft for the .NET platform.\n• F* - F* (pronounced F star) is a general-purpose functional programming language with effects aimed at program verification. It puts together the automation of an SMT-backed deductive verification tool with the expressive power of a proof assistant based on dependent types. After verification, F* programs can be extracted to efficient OCaml, F#, C, WASM, or ASM code. This enables verifying the functional correctness and security of realistic applications. The main ongoing use case of F* is building a verified, drop-in replacement for the whole HTTPS stack in Project Everest. This includes verified implementations of TLS 1.2 and 1.3 and of the underlying cryptographic primitives.\n• Fabric - Fabric is a high-level programming language for building open distributed applications with strong security. Fabric enables securely computing and storing information, and sharing code and data across trust boundaries. It is being developed by the Applied Programming Languages Group at Cornell University.\n• Factor - Factor is a concatenative, stack-based programming language with high-level features including dynamic types, extensible syntax, macros, and garbage collection.\n• Falcon - Falcon is an Open Source, simple, fast and powerful programming language, easy to learn and to feel comfortable with, and a scripting engine ready to empower mission-critical multithreaded applications. Falcon provides six integrated programming paradigms: procedural, object oriented, prototype oriented, functional, tabular and message oriented. And you don't have to master all of them; you just need to pick the ingredients you prefer, and let the code follow your inspiration.\n• FALSE - I designed this language in ‘93 with two particular objectives: confusing everyone with an obfuscated syntax, and designing an as powerful language as possible with a tiny implementation: in this case a compiler executable of just 1024 bytes (!), written in pure 68000 assembler.\n• Fantom - Fantom is a portable language that runs on the JVM and modern web browsers. It features a familiar Java-like syntax, static (and dynamic) typing, elegant system library, closures, immutability, actor concurrency, and much more.\n• Fanx - Fanx is a full-stack programming language base on Fantom. It is an object oriented and static typing language with elegant libraries.\n• FAST - FAST is a new programming language, which combines the advantages of other programming languages:\n• FAST is fully object-oriented and knows multiple inheritance\n• FAST includes library units on its own\n• FAST compiles within tenths of seconds and creates efficient code\n• FAST has lots of useful features such as e.g. the prevention of the Division by Zero error FAST programs are written as plain text and then sent thru the FAST compiler. Small and efficient code is created and a COM-File results. Up to now, FAST only compiles for MS-DOS (I just have not yet found out how to assemble a binary executable for WINDOWS).\n• Faust - Faust (Functional Audio Stream) is a functional programming language specifically designed for real-time signal processing and synthesis. A distinctive characteristic of Faust is to be fully compiled.\n• Fay - A proper subset of Haskell that compiles to JavaScript.\n• fbgc - Small Language and Calculator in C\n• FBSL - Freestyle Basic Script Language (FBSL) is a programming language.\n• It can produce GUI or console-based applications.\n• It's free for non-commercial use.\n• Felix - An advanced, statically typed, high performance scripting language with native C++ embedding.\n• Fennel - Fennel is a lisp that compiles to Lua. It aims to be easy to use, expressive, and has almost zero overhead compared to writing Lua directly.\n• Feral - Feral is a dynamically typed, imperative, interpreted language which revolves (to most extent) around the idea of minimalism.\n• ferite - ferite is a scripting language and engine all in one managable chunk. It is designed to be easily extended in terms of API, and to be used within other applications making them more configurable and useful to the end user. It has a syntax similiar to a number of other langauges but remains clean and it's own language.\n• ferite - ferite is a scripting language and engine all in one managable chunk. It is designed to be easily extended in terms of API, and to be used within other applications making them more configurable and useful to the end user. It has a syntax similiar to a number of other langauges but remains clean and it's own language. It's origins are from one of those \"it seems like a good idea\", the good idea was provoked by finding perl a real pain in the arse to embed (from what I gather it's easier nowadays). It started in the summer of 2000 (with various tries and fails within the pre-ceding two years). It is slowly maturing and should be fit for general consumption by the first quarter of 2003, by which point we start to add more exotic features.\n• FermaT - The FermaT Transformation System is a powerful industrial-strength program transformation system based on the WSL language. FermaT has been used sucessfully in several major assembler to C and assembler to COBOL migration projects involving the conversion of millions of lines of hand-written assembler code to efficient and maintainable C or COBOL code.\n• Fermat - Fermat is a computer algebra system for Macintosh, Windows, Linux, and Unix by me, Robert H. Lewis of Fordham University, that does arithmetic of arbitrarily long integers and fractions, multivariate polynomials, symbolic calculations, matrices over polynomial rings, graphics, and other numerical calculations. It is extremely fast and extremely economical of space.\n• Ficl - Ficl is an acronym for \"Forth Inspired Command Language\". Ficl is a programming language interpreter designed to be embedded into other systems as a command, macro, and development prototyping language.\n• Figaro - Figaro is a probabilistic programming language that supports development of very rich probabilistic models and provides reasoning algorithms that can be applied to models to draw useful conclusions from evidence. Both model representation and reasoning algorithm development can be challenging tasks. Figaro makes it possible to express probabilistic models using the power of programming languages, giving the modeler the expressive tools to create a wide variety of models. Figaro comes with a number of built-in reasoning algorithms that can be applied automatically to new models. In addition, Figaro models are data structures in the Scala programming language, which is interoperable with Java, and can be constructed, manipulated, and used directly within any Scala or Java program.\n• FIJI - FIJI the ForthIsh Java Interpreter is an interactive environment with a procedural syntax similar to the Forth programming language. FIJI can load, introspect, and execute Java classes and methods. FIJI's main use is for unit and component testing of Java, or for an interpreter in an all-Java environment.\n• Finch - Finch is a simple bytecode interpreted, purely object-oriented, prototype-based, dynamically-typed programming language. It's mostly inspired by Smalltalk, Self, and Javascript.\n• Finitio - Finitio is a data language. For now, it is limited to a data definition language (DDL). Think \"JSON/XML schema\", but a slightly different way, that puts the emphasis on precision. Finitio comes with a dedicated type system for defining data and a theory, called information contracts, for interoperability with programming and data exchange languages.\n• FiveTran - Fivetran, a FORTRAN language targeting Mako. Mako is an extremely simple stack-based virtual machine intended for the creation of video games.\n• FixScript - FixScript is an extensible scripting language designed for simple implementation and strong support for both backward and forward compatibility. You can use FixScript both as a standalone and embedded programming language. You can build standalone native executables for any supported platform from every platform. The best results are obtained when combined with the C language to get a very powerful tool. This way you can use the best of the two worlds, using the language for the high-level stuff and C doing the interoperability and fast stuff while having a good integration between both languages.\n• Flavor - Flavor (Formal Language for Audio-Visual Object Representation) is an object-oriented media representation language designed for simplifying the development of applications that involve a significant media processing component (encoding, decoding, editing, manipulation, etc.). It provides a formal way for describing any coded audio-visual or general multimedia bitstream, and it comes with a translator that can automatically generate C++/Java code from the Flavor description. The generated code can readily be used as a bitstream parser, generator or tracing tool.\n• Fleng - This software is an implementation of \"FLENG\", a low level concurrent logic programming language descended from Prolog. A compiler is provided to translate programs written in FLENG into assembly language which can subsequently be compiled and linked into a binary executable.\n• Flix - Next-generation reliable, safe, concise, and functional-first programming language. Flix is a principled functional, imperative, and logic programming language developed at Aarhus University, at the University of Waterloo, and by a community of open source contributors. Flix is inspired by OCaml and Haskell with ideas from Rust and Scala. Flix looks like Scala, but its type system is based on Hindley-Milner. Two unique features of Flix are its polymorphic effect system and its support for first-class Datalog constraints. Flix compiles JVM bytecode, runs on the Java Virtual Machine, and supports full tail call elimination. A VSCode plugin for Flix is available.\n• Florid - FLORID (F-LOgic Reasoning In Databases) is a deductive object-oriented database system employing F-Logic as data definition and query language. The development was supported by the Deutsche Forschungsgemeinschaft (project La 598/3-2). With the increasing interest in semistructured data, Florid has been extended for handling semistructured data in the context of Information Integration from the Semantic Web.\n• Floyd - Floyd is a general-purpose programming language designed for making very large and robust programs that run really fast, while ducking many of the problems of older languages. Floyd wants to become a better choice than C++, Rust, C#, Python and Javascript for any project.\n• Flux - Flux is a lightweight scripting language for querying databases (like InfluxDB) and working with data. It's part of InfluxDB 1.7 and 2.0, but can be run independently of those.\n• Foma - Foma is a compiler, programming language, and C library for constructing finite-state automata and transducers for various uses. It has specific support for many natural language processing applications such as producing morphological analyzers. Although NLP applications are probably the main use of foma, it is sufficiently generic to use for a large number of purposes.\n• Formality - Formality is an efficient proof language. An lightweight proof-gramming language. It aims to be:\n• Formula 2.0 - FORMULA 2.0 is framework for formally specifying domain-specific languages (DSLs) and model transformations. FORMULA specifications are succinct descriptions of DSLs, and specifications can be immediately connected to state-of-the-art analysis engines without additional expertise. FORMULA provides: (1) succinct specifications of DSLs and compilers, (2) efficient compilation and execution of input programs, (3) program synthesis and compiler verification.\n• Forscape - Scientific computing language. Forscape solves engineering problems with an unprecedented level of abstraction so you get reliable results quickly. This high-level approach starts with intuitive syntax. Program with the same notation you use to write equations thanks to our innovative math rendering with semantic formatting. Matrices, fractions, symbols- write code using the same notation you use to think through problems on the whiteboard.\n• Forth - A procedural, stack-oriented programming language and interactive environment. Forth is used in the Open Firmware boot loader, in space applications such as the Philae spacecraft, and in other embedded systems which involve interaction with hardware. Multiple implementaitons, both proprietary and FOSS.\n• Fortran - A general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing. It has been in use for over six decades in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers.\n• FreeBASIC - FreeBASIC is a completely free, open-source, multi-platform BASIC compiler, with syntax similar to MS-QuickBASIC, that adds new features such as pointers, object orientation, unsigned data types, inline assembly, and many others.\n• FreeOberon - Cross-platform IDE for development in Oberon programming language made in the classical FreePascal-like pseudo-graphic style.\n• FreePascal - Free Pascal is a mature, versatile, open source Pascal compiler. It can target many processor architectures: Intel x86 (16 and 32 bit), AMD64/x86-64, PowerPC, PowerPC64, SPARC, SPARC64, ARM, AArch64, MIPS, Motorola 68k, AVR, and the JVM. Supported operating systems include Windows (16/32/64 bit, CE, and native NT), Linux, Mac OS X/iOS/iPhoneSimulator/Darwin, FreeBSD and other BSD flavors, DOS (16 bit, or 32 bit DPMI), OS/2, AIX, Android, Haiku, Nintendo GBA/DS/Wii, AmigaOS, MorphOS, AROS, Atari TOS, and various embedded platforms. Additionally, support for RISC-V (32/64), Xtensa, and Z80 architectures, and for the LLVM compiler infrastructure is available in the development version. Additionally, the Free Pascal team maintains a transpiler for pascal to Javascript called pas2js.\n• Frege - Frege is a Haskell for the JVM. It brings purely functional programing to the Java platform. Like any Haskell, it is purely functional, enjoys a strong static type system with global type inference and non-strict - also known as lazy - evaluation. Frege compiles to Java, runs on the JVM, and uses any Java library you want. It can be used inside any Java project.\n• Frenetic - Frenetic is an open-source Software Defined Network (SDN) controller platform designed to make SDN programming easy, modular, and semantically correct\n• friend - 1)Compiler/interpreter for a simple OO language. The language allows to use networking very easily, including such protocols as TCP, UDP, Raw Sockets 2) Library for reading/manipulating Java bytecode\n• FScript - FScript is an extremely simple scripting language. Its intended use is as an embedded language in other Java programs. It is very simple to embed - it can be as simple as sub-classing one class to add your own functionality. However is not a complete programming language, as it has no library of standard functions (such as IO and string processing). FScript supplies a base functionality (such as flow control, variable handling and basic math operations) that can extended by the host application.\n• Ftwalk - Ftwalk is a general purpose script programming language. It is based on the concepts of Awk, but has been extended to support features such as are found in languages like Perl, Python, and Ruby.\n• FUN - FUN is a simple, structured, imperative, dynamic, object-oriented, functional and high-level programming language. FUN was developed by Wisdom ZHANG in 2010 as a scripting language to reuse resources of Pascal. FUN's syntax is simple and clear, it comes from Ada and was changed for easy to use and input. FUN's exception handling syntax is similar to Delphi. FUN is dynamic typing and supports type conversions automatically when needed. FUN supports class-based object-oriented programming. FUN supports first-class functions functional programming, looks like Lisp and Javascript. FUN implements a simple and lightweight reference counting garbage collector. FUN's regular expressions handling is Perl-Compatible. FUN provides simple and powerful list process, it looks like arrays, associative arrays, hash tables, dictionaries or mappings too.\n• Funnel - Funnel is a programming language based on Functional Nets. Functional Nets combine key ideas of functional programming and Petri nets to yield a simple and general programming notation. They have their theoretical foundation in Join calculus.\n• Fusion - Fusion is a programming language which can be translated automatically to C, C++, C#, D, Java, JavaScript, Python, Swift, TypeScript and OpenCL C. Instead of writing code in all these languages, you can write it once in Fusion. [Transpiler]\n• Futhark - High-performance purely functional data-parallel array programming on the GPU. Futhark is a small programming language designed to be compiled to efficient parallel code. It is a statically typed, data-parallel, and purely functional array language in the ML family, and comes with a heavily optimising ahead-of-time compiler that presently generates GPU code via CUDA and OpenCL, although the language itself is hardware-agnostic and can also run on multicore CPUs.\n• Fux - Flawless Unambiguous Programming - A Modern, Flexible Programming Language for All. Fux is a modern and flexible programming language, perfect for use in a variety of domains by both novice and expert developers. With its efficient use of LLVM, it provides performance similar to C++, while being portable and running on a wide range of platforms.\n• Fuzion - A language with a focus on safety and performance. It unifies concepts found in other programming languages to improve productivity and shall provide tools for performance and correctness.\n• Fuzuli - JFuzuli is the JVM implementation of our programming language Fuzuli which is based on LISP syntax and Algol family programming logic. Fuzuli is a modern collaboration of these two separate family of languages.\n• GALATEA - Glider with Autonomous, Logic-based Agents, TEmporal reasoning and Abduction. GALATEA is software to model and simulate multi-agent systems. It is the product of two lines of research: simulation languages based on Zeigler's theory of simulation and logic-based agents. There is, in GALATEA, a proposal to integrate, in the same simulation platform, conceptual and concrete tools for multi-agent, distributed, interactive, continuous and discrete event simulation.\n• Gambas - Gambas is a full-featured object language and development environment built on a BASIC interpreter.\n• GameMonkey Script - Embedded scripting language for C++ apps, tools and games.\n• GAML - GAML is an agent-oriented language dedicated to the definition of agent-based simulations. It takes its roots in object-oriented languages like Java or Smalltalk, but extends the object-oriented programming approach with powerful concepts (like skills, declarative definitions or agent migration) to allow for a better expressivity in models.\n• Garnet - what if Rust was small?\n• GDScript - Scripting language built into the Godot game engine. GDScript is a high-level, dynamically typed programming language used to create content. It uses a syntax similar to Python (blocks are indent-based and many keywords are similar). Its goal is to be optimized for and tightly integrated with Godot Engine, allowing great flexibility for content creation and integration.\n• Gecho - Simple stack language in C. Has a few basic commands; working to implement a loop and user-defined functions. If statement would be nice.\n• Gene - Gene is a common purpose programming language. It is inspired by languages such as object pascal, C++, sql and EBNF languages such as Coco/R, lex and yacc and is a pure object oriented language. It is therefor ideally suited for applications that process a lot of sequential input and output such as scanners, parsers and data generators. Gene also has build in support for container objects (objects that manage a list of other objects such as arrays, linked lists, queues, sql tables,...).\n• GeneralScript - GeneralScript is a lightweight general purpose scripting engine which provides Scheme like syntax.\n• Genesis - Genesis is an interpreted, procedural, and Turing-complete Paleo-Hebrew programming language. Diacritical signs are forgone for simplification, though maybe Nikud can be used in prospect as a means for more reserved keywords.\n• genyris - Inspired by the Semantic Web, Genyris presents a new programming paradigm. Objects can belong to multiple classes independent from construction. Indentation reduces parentheses yet retains the power of Lisp. External Java libraries can be imported.\n• Classes are assigned to objects after construction\n• GF - GF, Grammatical Framework, is a programming language for multilingual grammar applications. It is\n• a special-purpose language for grammars, like YACC, Bison, Happy, BNFC, but not restricted to programming languages\n• a functional programming language, like Haskell, Lisp, OCaml, SML, Scheme, but specialized to grammar writing\n• a development platform for natural language grammars, like LKB, XLE, Regulus, but based on functional programming and type theory\n• a categorial grammar formalism, like ACG, CCG, but specialized for multilingual grammars,\n• a logical framework, like Agda, Coq, Isabelle, but equipped with concrete syntax in addition to logic\n• a platform for machine translation, like Moses, Apertium, but based on deep structural analysis (and usually applied for limited fragments of language).\n• ghūl - ghūl is a general-purpose, statically-typed, managed programming language. It supports object-oriented programming with functional elements through a quirky syntax reminiscent of ALGOL 68 and Pascal that aims to be both expressive and readable. The language targets .NET and interoperates with the .NET ecosystem. The self-hosting ghūl compiler, written entirely in ghūl, shows the language's capabilities and dogfooding philosophy.\n• GIMI - This is GIMI, the Graphical Interfaced Multitasking Interpreter. One of the few GUIs made in QuickBASIC featuring multitasking. This one has its own script language for making programs, damm fast SVGA modes, lots of programs, and more!\n• Gleam - Gleam is a type safe functional programming language for building scalable concurrent systems. It compiles to Erlang and has straightforward interop with other BEAM languages such as Erlang, Elixir and LFE.\n• Glee - The Glee Programming Language is a new vector oriented interpretive computer programming tool. It is inspired by array oriented languages like APL, J, and K. It attempts to deliver many of the useful and powerful features of those languages for manipulating numeric data. Further, it strives to provide new functionality for consistent and powerful manipulation of character data. It is targeted at applications where languages like PERL, Python, and Java have found secure homes. These are all scalar languages so Glee has something new to bring to the party ... vector processing.\n• Glide - Glide is a statically (and dynamically) typed language designed to make reading and writing data transformations easier. [refinement types]\n• GLMS - A scripting language focused on linear algebra, heavily inspired by GLSL and JavaScript. [algebra, shaders]\n• Gluon - Gluon is a static, type inferred and embeddabble language written in Rust.\n• Go+ - The Go+ programming language is designed for engineering, STEM education, and data science.\n• The simplest engineering language that can be mastered by children (script-like style).\n• Performance: as fast as Go (Go+'s main backend compiles to human-readable Go).\n• Fully compatible with Go and can mix Go/Go+ code in the same package (see Go/Go+ hybrid programming).\n• No DSL (Domain Specific Language) support, but it's Specific Domain Friendly (see DSL vs. SDF).\n• Support Go code generation (main backend) and bytecode backend (REPL: see iGo+).\n• Simplest way to interaction with C (cgo is supported but not recommended).\n• Goal - Goal is an embeddable array programming language with a bytecode interpreter, written in Go. It provides both a command line intepreter (that can be used in the REPL), and a library interface. The core features are mostly there and tested, so Goal is usable both for writing useful short scripts and playing with the REPL. User testing and bug reports are welcome! Like in most array programming languages, Goal's builtins vectorize operations on immutable arrays, and encourage a functional style for control and data transformations, supported by a simple dynamic type system with little abstraction, and mutable variables (but no mutable values).\n• goaldi - Goaldi is a new general-purpose programming language that combines the goal-directed evaluation model of the Icon language with modern features such as concurrency, objects, closures, and Unicode support. While Goaldi will look familiar to Icon programmers, it is not upwards compatible.\n• Goby - Goby is an object-oriented interpreter language deeply inspired by Ruby as well as its core implementation by 100% pure Go. Moreover, it has standard libraries to provide several features such as the Plugin system. Note that we do not intend to reproduce whole of the honorable works of Ruby syntax/implementation/libraries.\n• Gofolio - the programming language for the ATARI portfolio\n• Golo - The world didn’t need another JVM language. So we built yet another one. A simple one.\n• Gosu - Gosu is a pragmatic programming language for the JVM. It has been designed with Java developers in mind by providing a set of features that allow them to be more productive without sacrificing the benefits of Java's simple syntax and type-safety. Gosu is an object oriented language with a sprinkle of functional programming features.\n• GPP - GPP is a general-purpose preprocessor with customizable syntax, suitable for a wide range of preprocessing tasks. Its independence from any one programming language makes it much more versatile than the C preprocessor (cpp), while its syntax is lighter and more flexible than that of GNU m4. There are built-in macros for use with C/C++, LaTeX, HTML, XHTML, and Prolog files.\n• GrADS - The Grid Analysis and Display System (GrADS) is an interactive desktop tool that is used for easy access, manipulation, and visualization of earth science data. GrADS has two data models for handling gridded and station data. GrADS supports many data file formats, including binary (stream or sequential), GRIB (version 1 and 2), NetCDF, HDF (version 4 and 5), and BUFR (for station data). GrADS has been implemented worldwide on a variety of commonly used operating systems and is freely distributed over the Internet.\n• Gravity - Gravity is a powerful, dynamically typed, lightweight, embeddable programming language written in C without any external dependencies (except for stdlib). It is a class-based concurrent scripting language with modern Swift-like syntax.\n• Gremlin - Gremlin is a domain specific language for traversing property graphs. Gremlin makes use of Pipes to perform complex graph traversals. This language has application in the areas of graph query, analysis, and manipulation. Connectors, provided by Blueprints, exist for the following graph management systems:\n• Gren - Gren is a pure functional programming language that is easy to learn, but powerful in use.\n• Gri - Gri is a language for scientific graphics programming. The word \"language\" is important: Gri is command-driven, not point/click. Gri can make x-y graphs, contour graphs, and image graphs, in PostScript and (someday) SVG formats. Control is provided over all aspects of drawing, e.g. line widths, colors, and fonts. A TeX-like syntax provides common mathematical symbols.\n• Groovy - Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities, for the Java platform aimed at improving developer productivity thanks to a concise, familiar and easy to learn syntax. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming.\n• Gui4Cli - Gui4Cli is an interpreted, untyped, procedural programming language for easily creating Windows apps. It has a wide set of commands, it can be easily extended and can create self-standing executables. It is Event-driven, and intuitive and geared to creating stand-alone guis or interfaces for other, console driven programs (as it's name implies). The new version can also handle Unicode.\n• Guile - Guile is designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts. With Guile you can create applications and games for the desktop, the Web, the command-line, and more.\n• gura - A programming language that comes with powerful operation on iterators.\n• GvR - Guido van Robot, or GvR for short, is a programming language and free software application designed to introduce beginners to the fundamentals of programming. GvR runs on Windows, Macintosh, and GNU/Linux, in a variety of languages! It's great in both the classroom and the home as a way of introducing people to the basic concepts of programming.\n• GYS - GYS has built-in lexical and expression analyzer, but during interpretation it calls different user code for executing commands, operators, conversions and value getting. The interpreter is fully runtime - it reads code and interprets it at once. GYS doesn't generate any intermediate code. User doesn't have to use stack to implement his GYS-derived script language. The \"abstract\" GYS interpreter can be called within application to execute the script according to the designed language definition and functionality. The library provides an easy and clear way to define a scipt language interpreter step-by-step: developer can define next language elements:\n• GZigZag - Zzstructure is a way of representing the structure of information. Compared with the previous ways, Zzstructure is very different, for example the concepts of 'file', 'folder' and 'application' are abandoned. Because of this a bit of fantasy, creativity and an ability to forget previous knowledge is needed in order to understand Zzstructure. A Zzstructure structure consists of cells and dimensions. A cell is the basic unit of information of a Zzstructure structure. Cells containing related information can be connected with each other along dimensions, the number of which is unlimited. A Zzstructure structure is separate from its visualisation (= the way the data is presented on the screen), which means that a Zzstructure structure can have many visualisations designed for different purposes.\n• Gödel - Gödel is a declarative, general-purpose programming language in the family of logic programming languages. It is a strongly typed language, the type system being based on many-sorted logic with parametric polymorphism. It has a module system. Gödel supports infinite precision integers, infinite precision rationals, and also floating-point numbers. It can solve constraints over finite domains of integers and also linear rational constraints. It supports processing of finite sets. It also has a flexible computation rule and a pruning operator which generalises the commit of the concurrent logic programming languages. Considerable emphasis is placed on Gödel's meta- logical facilities which provide significant support for meta-programs that do analysis, transformation, compilation, verification, debugging, and so on\n• Hack - Hack is built specifically for HHVM, a high performance runtime for your Hack applications, and reconciles the fast development cycle of a dynamically typed language with the discipline provided by static typing, while adding many features commonly found in other modern programming languages.\n• Halide - Halide is a language for fast, portable data-parallel computation. Also Halide designed to make it easier to write high-performance image and array processing code on modern machines. Rather than being a standalone programming language, Halide is embedded in C++. This means you write C++ code that builds an in-memory representation of a Halide pipeline using Halide's C++ API. You can then compile this representation to an object file, or JIT-compile it and run it in the same process. Halide also provides a Python binding that provides full support for writing Halide embedded in Python without C++.\n• Happy - A scripting language with syntactic sugar for code generation. Happy has the concept of a \"current output.\" The current output is simply a System.IO.TextWriter where all template output is directed. At the moment, the current output must be determined by the host program executing the Happy script. This is usually the command-line application, in which case the current output is directed at the file specified in one of the command-line options. A host program in which Happy has been embedded can specify any TextReader as the current output.\n• Harbour - Harbour is the free software implementation of a multi-platform, multi-threading, object-oriented, scriptable programming language, backward compatible with Clipper/xBase. Harbour consists of a compiler and runtime libraries with multiple UI and database backends, its own make system and a large collection of libraries and interfaces to many popular APIs.\n• Hare - Hare is a systems programming language designed to be simple, stable, and robust. Hare uses a static type system, manual memory management, and a minimal runtime. It is well-suited to writing operating systems, system tools, compilers, networking software, and other low-level, high performance tasks.\n• Harlan - Harlan is a domain specific language for programming GPUs. This project serves primarily as a testbed for implementation and optimization techniques. The language is intentionally small, in order to simplify the process of exploring new analyses and optimizations.\n• Hascal - Hascal is a general purpose and open source programming language designed to build optimal, maintainable, reliable and efficient software.\n• Haskell - A general-purpose, statically-typed, purely functional programming language with type inference and lazy evaluation. Designed for teaching, research and industrial application, Haskell has pioneered a number of programming language features such as type classes, which enable type-safe operator overloading. Haskell's main implementation is the Glasgow Haskell Compiler (GHC).\n• Haxe - High-level and strictly-typed programming language, cross-compiles to many different targets.\n• Hedy - Hedy is a gradual programming language to teach children programming. Gradual languages use different language levels, where each level adds new concepts and syntactic complexity. At the end of the Hedy level sequence, kids master a subset of syntactically valid Python. [children]\n• Heptagon - Heptagon is a synchronous dataflow language whose syntax and semantics is inspired from Lustre, with a syntax allowing the expression of control structures (e.g., switch or mode automata).\n• Heron - Heron is a small cross-platform language that was designed for ease of use, performance, and safety with a JavaScript like syntax. Heron emphasizes pure functional programming code, but looks like a traditional imperative or object-oriented code.\n• Herschel - Herschel is an general-purpose multiparadigm programming language. It is strongly typed, offering type inference and parametric polymorphism (\"generics\"). It is consequently object oriented (everything is a object, even functions), while its consequent multiple dispatch approach keeps a strong functional touch. The object model is class-oriented, supporting multiple inheritance as well as the separation of types (\"protocols\", \"interfaces\") and classes.\n• HGSL - A shading language that can be compiled into GLSL ES 3.0.\n• HicEst - Integrated development environment with graphical user interface designed for immediate results in the development of Windows applications.\n• Hilvi - Hilvl is a programming language that is versatile but with a very small syntax. All code in hilvl are single-argument invocations of actions that belong to services. Services are the fundamental building blocks of a hilvl program. And the name hilvl reflects how this is a higher level of abstraction than objects and functions.\n• Hobbes - Hobbes is built for high performance integration with C/C++ applications.\n• Hook - Hook is an imperative, cross-platform, dynamically typed scripting language that utilizes a mutable value semantics approach.\n• Hop - a multitier JavaScript also supports the Scheme programming language. With Hop.js, JavaScript and Scheme are fully interoperable and applications can mix both languages. This page mostly describes the JavaScript layer. The Scheme layer is described in a dedicated programming manual.\n• Hope - Hope is a lazily evaluated functional programming language developed in 1970's by Ross Paterson. It influenced the design of other lazy languages such as Miranda and Haskell.\n• Hush - Hush is a unix shell based on the Lua programming language. Hush is written in Rust.\n• Hy - A dialect of Lisp that's embedded in Python.\n• Hylo - Hylo (formely Val) is a programming language that leverages mutable value semantics and generic programming for high-level systems programming.\n• HypoLambda - A very compact functional programming language for .NET. Its syntax is based on Python, but whitespaces are ignored. Everything is an expression. The language runtime is embeddable, its AST is accessible, and it compiles to portable pcode. There's a REPL you can play with, and the project includes lots of unit tests.\n• I - I is a programming language designed by the I Project. It has been designed to be efficient to write and run. The system incorporates many major libraries allowing the creation of major projects such as Aciqra. It is an interpreted language and supports CGI scripting through the use of the CGI for Aciv/I extension.\n• IBAL - IBAL is a functional language for specifying probabilistic models. Models in IBAL look like programs in a functional programming language. In the functional approach, a model is a description of a computational process. The process stochastically generates a value, and the meaning of the model is the distribution over the value generated by the process.\n• ICE - ICE: A new BASIC-like programming language for the CE calculators. ICE compiles a TI-BASIC-like language into eZ80 binary, the native machine code of the CE calculators.\n• Idle - Idle is a simple but powerful scripting language, in basically the same vein as the venerable Perl or Python languages. It is, however, an altogether more lightweight application: the basic installation zip weighs in at around 800 KB (and this includes the full documentation and loads of example scripts). At the core of Idle sits a tweaked and significantly enhanced version of Lua. Idle inherits from Lua its elegant and powerful language definition as well as a highly-optimised interpreter kernel (an extremely fast compiler is included as well). Idle, like Lua, is readily extended with additional functions, modules and libraries (which can be written either in C/C++ or in Idle itself).\n• Idris - Idris is a programming language designed to encourage Type-Driven Development. In Idris, types are first-class constructs in the langauge. This means types can be passed as arguments to functions, and returned from functions just like any other value, such as numbers, strings, or lists.\n• IENJINIA - IPL is the IENJINIA Programming Language used in the IENJINIA Devkit to write games for the IENJINIA Virtual Console. It is a very simple interpreted language with dynamic typing, static scoping and automatic garbage collection.\n• ilang - ilang is designed to be a new type of programming lanuage that supports different types of programming paradimes with a focus towards artificial inteligence\n• ILYC - ILYC is an interpreted programming language with a simple and friendly syntax, which is suitable for beginners and hobbyist. The purposes of creating such a language was for the author to practice programming and for others to study how to implement an interpreter in the .NET framework.\n• Imba - Imba is a friendly full-stack programming language for the web that compiles to performant JavaScript. It has language-level support for defining, extending, subclassing, instantiating and rendering DOM nodes.\n• IMP - IMP is an \"ALGOL-like\" high-level language that was originally designed as the implementation language for the Edinburgh Multi-Access System, developed at Edinburgh University. It was widely used at Edinburgh University for implementing systems, teaching programming and as a general purpose programming language on many different machines. Because IMP did not see significant commercial adoption (unlike its contemporary, C and later C++), it is not generally available on current platforms. For the Edinburgh Computing History Project, which aims to collect and publish significant software archives from Edinburgh University, this was a problem, because much of that software heritage is written in IMP. The solution - to produce an IMP compiler for current mainstream Intel x86 machines.\n• Impulse - Impulse is a small, dynamically typed, message based prototypical language written with simplicity in mind. Its syntax and semantics are derived mostly from Ruby, Io, Smalltalk and Dylan, and it's purpose is to be a smarter 'scripting' language, with features such as trait composition, extension methods (wich solves monkey-patching), and constructor field initialization. A core goal is to keep the language, both the implementation and the syntax, small and lightweight.\n• Incanter - Incanter is a Clojure-based, R-like platform for statistical computing and graphics.\n• Inform 6 - The latest version of the Inform 6 compiler, used for generating interactive fiction games.\n• Inform 7 - Inform is a programming language for creating interactive fiction, using natural language syntax. Using natural language and drawing on ideas from linguistics and from literate programming, Inform is widely used as a medium for literary writing, as a prototyping tool in the games industry, and in education, both at school and university level (where Inform is often assigned material for courses on digital narrative). It has several times ranked in the top 100 most influential programming languages according to the TIOBE index. Created in April 2006, it was open-sourced in April 2022.\n• Ink - Ink is a minimal programming language inspired by modern JavaScript and Go, with functional style. Ink can be embedded in Go applications with a simple interpreter API.\n• Insanity - Insanity is a block-based programming language with powerful commands, such as file I/O, cloud variables, and much more. It is based off Scratch 1.4 by MIT.\n• interp - interp is a powerful programming language. Check-out the language features, then take the tour. It is targeted for Linux/Unix-based systems, yet remains adaptable to less powerful embedded systems that were never intended to host a programming language.\n• Io - Io is a pure object-oriented (relying on prototype-based paradigm) programming language focused on expressiveness through simplicity.\n• Ioke - Ioke is a dynamic language targeted at virtual machines, currently the Java Virtual Machine and the Common Language Runtime. It's been designed from scratch to be a highly flexible general purpose language. It is a prototype-based programming language that is inspired by Io, Smalltalk, Lisp and Ruby.\n• ipl - ipl stands for the Invocation (programming) Language, a concurrent programming language described by Karl Fant in his book Computer Science Reconsidered: The Invocation Model of Process Expression (Wiley-Interscience 2007).\n• IronAHK - IronAHK is a rewrite of AutoHotkey, a powerful and easy to use scripting language for automation on the desktop. It is developed in C# for .NET and Mono which brings cross-platform compatibility, increased performance, enhanced security, Unicode, native 64-bit support, smaller file sizes for compiled binaries and much more.\n• ironlua - IronLua currently features a working top-down-operator-precedence Lua 5.2 parser but no compiler for the time being. I do not plan on using the DLR. The solution also includes a C# interpreter, but it's all work-in-progress.\n• IronPython - IronPython is an open-source implementation of the Python programming language which is tightly integrated with .NET. IronPython can use .NET and Python libraries, and other .NET languages can use Python code just as easily.\n• IronRuby - IronRuby is a Open Source implementation of the Ruby programming language for .NET and Silverlight, heavily relying on Microsoft's Dynamic Language Runtime.\n• IronSapphire - Formerly Sapphire.NET, IronSapphire is aimed to be better than Sapphire.NET with its Pros, but none of its Cons. Sapphire is inspired by Conscript, C#, Python, VB.NET and Perl. It's developed in C#. Sapphire.NET is now called IronSapphire and will have improved syntax.\n• ISLISP - The ISLISP programming language is a member of the Lisp family of programming languages. It attempts to bridge the gap between the various incompatible members of the Lisp family of languages (most notably Common Lisp, Eulisp, LeLisp, and Scheme) by focusing on standardizing those areas of widespread agreement. It is a small language, closer to the size of Scheme than to Common Lisp, for example.\n• ISPC - Intel Implicit SPMD Program Compiler is a compiler for a variant of the C programming language, with extensions for single program, multiple data programming. Under the SPMD model, the programmer writes a program that generally appears to be a regular serial program, though the execution model is actually that a number of program instances execute in parallel on the hardware. [C dialect]\n• ispc - ispc is a compiler for a variant of the C programming language, with extensions for \"single program, multiple data\" (SPMD) programming. Under the SPMD model, the programmer writes a program that generally appears to be a regular serial program, though the execution model is actually that a number of program instances execute in parallel on the hardware. ispc compiles a C-based SPMD programming language to run on the SIMD units of CPUs and GPUs; it frequently provides a 3x or more speedup on architectures with 4-wide vector SSE units and 5x-6x on archituctures with 8-wide AVX vector units, without any of the difficulty of writing intrinsics code. Parallelization across multiple cores is also supported by ispc, making it possible to write programs that achieve performance improvement that scales by both number of cores and vector unit size.\n• ivy - Ivy is an interpreter for an APL-like language. It is a plaything and a work in progress.\n• Ivy - Ivy is an extensible, dynamically typed, late binding language intended to be used as an embedded command language. It can also be used stand-alone: it can execute script files from the command line or presents a read-eval-print loop (REPL) to the user if no files are given. Ivy's extensibility is based on the fact that statements are syntactically identical to function calls. Also blocks (surrounded by braces) may be used as function arguments. Thus, new user-defined statements can be added just by defining functions. Function arguments are packaged up as thunks and may have their evaluation delayed and execution environment modified. This allows user defined functions to do many of the things that traditional language statements can do.\n• ivy - Ivy is an open-source machine learning framework that enables you to: 🔥 Autotune your model: Automatically find the optimal framework, compiler infrastructure and hardware for your specific use case using ivy.autotune. 🔄 Convert code into any framework: Use and build on top of any model, library, or device by converting any code from one framework to another using ivy.transpile. ⚒️ Write framework-agnostic code: Write your code once in ivy and then choose the most appropriate ML framework as the backend to leverage all the benefits and tools.\n• Ivy - Ivy is an embeddable byte-code compiled/interpreted language which is useful as both an extension and a command language. Its syntax is designed to be easy to learn and to be fairly good looking. Ivy currently supports four data types: integers, strings, functions and objects. Objects are late-binding storage devices which take the role of arrays, structures and simple look-up tables. Floating point or arbitrary length floating point numbers will be available in a future implementation. Ivy comes packaged as an interactive language like BASIC and LISP. You can either execute language statements immediately from the keyboard or run a program stored in a file. Ivy is also easy to embed into another program. Calls are provided to execute Ivy code and to add C function extensions to Ivy's interpreter.\n• IvyScript - The IvyScript language is used to write business rules, for manipulating process data and to define data mappings for Axon.Ivy. Axon.ivy is a Digital Business Platform that simplifies and automates the interaction of humans with their digital systems. The platform is typically in charge of the most precious business cases where companies produce value.\"\n• ixicl - ixicl is a runtime-mutable language engine capable of running script files or as a persistent daemon, and optionally storing program state in a realtime database. ixicl allows programmers to create the language used to accomplish the desired task, and add sub-languages for functionality such as scriptability. Control over the language itself allows implementation of security and cooperative programming mechanisms. It is written entirely in ANSI compliant C, and will compile on a wide variety of platforms. The developers have a background in ColdC and other persistent databases; ixicl will likely pick up where these less active projects left off.\n• Ixion - Ixion is a compiled programming language for the jvm platform, combining modern OOP and FP. Written in pure java.\n• J - J is a high-level, general-purpose programming language that is particularly suited to the mathematical, statistical, and logical analysis of data. It is a powerful tool for developing algorithms and exploring problems that are not already well understood.\n• J* - J* is a dynamic embeddable scripting language designed to be as easy as possible to embed into another program. It arises from the need of having a modern scripting language with built-in support for OOP whilst mantaning simplicity of use and a low memory footprint. It can be viewed as a middle ground between Python, a more complete scripting language with lots of features and libraries, and Lua, a small and compact language that is simple to embed but doesn't provide OOP functionalities out of the box. J* tries to take the best of both worlds, implementing a fully featured class system while maintaining a small standard library and employing the use of a stack based API for communication among the language and host program, rendering embedding simple.\n• Jabaco - Jabaco is a simple programming language with a Visual Basic like syntax. Jabaco enables you to create powerful software for all Java supported operating systems.\n• Jacinda - Functional, expression-oriented data processing language. APL meets AWK. A command-line tool for summarizing and reporting, powered by Rust's regex library.\n• Jakt - Jakt is a memory-safe systems programming language. It currently transpiles to C++.\n• Jal - Jal is a high-level language for a number of Microchip PIC (16c84, 16f84, 12c508, 12c509, 16F877) and Ubicom SX (SX18 and SX28) microcontrollers. I created Jal because I did not like any of the low-cost (or free) languages for these chips and implementing a high level language looked like a nice project. Implementing an existing HLL seemed more difficult and less fun than creating my own, so I just started writing the compiler and the language evolved on with it.\n• JALv2 - JALv2 is a rewrite of Wouter van Ooijen's famous Just Another Language.\n• JAM - JAM, a cross-platform tool for building client/server applications, has the unique ability to help develop complex applications with small amounts of custom coding. JAM applications can run unmodified on a diverse array of platforms and operating environments including MS Windows, MS DOS, HP HP-UX, Sun Solaris, IBM AIX, DEC UNIX, SCO OpenServer and Compaq/DEC OpenVMS. JAM also integrates seamlessly with the most popular relational databases, while providing transparent access to legacy systems via DRDA and ODBC.\n• Janet - Janet is a functional and imperative programming language and bytecode interpreter. It is a lisp-like language, but lists are replaced by other data structures (arrays, tables (hash table), struct (immutable hash table), tuples). The language also supports bridging to native code written in C, meta-programming with macros, and bytecode assembly.\n• Janino - Janino is a super-small, super-fast Java compiler. Janino can not only compile a set of source files to a set of class files like JAVAC, but also compile a Java expression, a block, a class body, one .java file or a set of .java files in memory, load the bytecode and execute it directly in the running JVM.\n• Jank - Jank is a Clojure dialect which aims to offer the best of both worlds: dynamic and static. For both of these worlds, jank uses a single runtime, so the transition from one to the other is not only seamless, it can be gradual.\n• Jason - Jason is an interpreter for an extended version of AgentSpeak. It implements the operational semantics of that language, and provides a platform for the development of multi-agent systems, with many user-customisable features. Jason is available Open Source, and is distributed under GNU LGPL\n• JASS Tools - JASS Tools are tools for parsing and analyzing the JASS scripting language, which used for scripting Maps and AI files in Blizzard Entertainment's Warcraft III.\n• Javalin - The Javalin Set of Macros (JASM) provdies a universal specification that enables the assembly language programmer to easily develop object oriented applications. JASM is also portable. You can create OOP applications that run on all supported architectures and platforms.\n• Javauto - Javauto is an automation language, unique due to its ability to perform mouse clicks, simulate keyboard input, and perform pixel searches. It compiles to executable code that runs on the JVM, so any program you write will be cross platform.\n• Jazz - Jazz is a high-level programming language for expressing, in a concise and accurate way, large digital synchronous circuits. From a language-designer perspective, Jazz is a declarative, single-assignment, higher-order, lazy, functional, and object-oriented language with parameterized types and multi-methods. Jazz is strongly-typed (with a type-system derived from ML-sub) and supports both the explicit and implicit declaration of variables and methods thanks to a powerful constraint-based type-inference algorithm. The syntax of Jazz and its object model are Java-like and should look familiar to any Java programmer.\n• Jelly - Jelly is a tool for turning XML into executable code. So Jelly is a Java and XML based scripting and processing engine.\n• Jest - Jest is a simple, high-level programming language built around the concept of compile-time code generation - what is often called meta-programming. Focussing on code generation leads to a language that is clean and simple, and yet extremely expressive. For a more in-depth discussion, please see the Introduction, or read some of the blog articles as they are posted.\n• JFLAP - JFLAP is software for experimenting with formal languages topics including nondeterministic finite automata, nondeterministic pushdown automata, multi-tape Turing machines, several types of grammars, parsing, and L-systems. In addition to constructing and testing examples for these, JFLAP allows one to experiment with construction proofs from one form to another, such as converting an NFA to a DFA to a minimal state DFA to a regular expression or regular grammar.\n• Jif - Jif is a security-typed programming language that extends Java with support for information flow control and access control, enforced at both compile time and run time. The source code for the Jif compiler and run-time system is available for download. Jif is written in Java and is built using the Polyglot extensible Java compiler framework.\n• Jim - Jim is an opensource small-footprint implementation of the Tcl programming language. It implements a large subset of Tcl and adds new features like references with garbage collection, closures, built-in Object Oriented Programming system, Functional Programming commands, first-class arrays and UTF-8 support. All this with a binary size of about 100-200kB (depending upon selected options).\n• jl - This is a small, embeddable LISP-like language. The intended use is for configuration files where it is desirable to be able to have complex configurations (JWM, for example).\n• JMatch - The JMatch language extends Java with pattern matching that supports both data abstraction and iteration abstraction. Patterns are not tied to algebraic data constructors as in ML; instead, a single JMatch method may be used in several modes, some of which can serve as patterns. JMatch provides modal abstraction that simplifies the specification and implementation of abstract data types. These modes that may share a common implementation as a boolean formula. Thus, the specification, implementation, and use of iteration abstractions are made convenient, by automatically finding multiple solutions to a formula or pattern.\n• JME - Java Math Expression - a powerful mathematical evaluator in Spanish and a structured script language, JMEScript, that makes use of it.\n• Joe-E - Joe-E is a subset of the Java programming language designed to support secure programming according to object-capability discipline. Joe-E is intended to facilitate construction of secure systems, as well as to facilitate security reviews of systems built in Joe-E.\n• Jolie - Jolie crystallises the programming concepts of service-oriented computing as linguistic constructs. The basic building blocks of software are not objects or functions, but rather services that can be relocated and replicated as needed. A composition of services is a service.\n• Jolt - Jolt is a systems programming language intended to be used anywhere one would use C++. It is as willing to get dirty in the name of performance. It is not willing to compromise in the name of compatibility with legacy languages. It is a language in which everything is an object, inheriting from Object, including the “primitive” types, and yet is capable of implementing many of these same types in itself. It includes features traditionally seen in dynamically-typed object-oriented languages such as Ruby, and even has some LISP features, yet does so in a way that preserves strong static typing and the performance benefits thereof.\n• Joy - The language Joy is a purely functional programming language. Whereas all other functional programming languages are based on the application of functions to arguments, Joy is based on the composition of functions. All such functions take a stack as argument and produce a stack as value. Consequently much of Joy looks like ordinary postfix notation. However, in Joy a function can consume any number of parameters from the stack and leave any number of results on the stack. The concatenation of appropriate programs denotes the composition of the functions which the programs denote. One of the datatypes of Joy is that of quoted programs, of which lists are a special case. Some functions expect quoted programs on top of the stack and execute them in many different ways, effectively by dequoting.\n• JS++ - JS++ is a programming language designed for high-quality web and mobile development.\n• Jsi - Jsi is a C (+/-) embeddable JavaScript interpreter alternative to languages such as Python, Lua, and Tcl\n• Juka - Juka Programming Language - Rapid Prototyping Language built to run on Azure Microsoft Server. Juka's goal is to be a universal programming language that can run on any platform. Juka is being built on top of .NET network and runs on any platform that supports .NET. Juka can also compile programs into executables.\n• Jule - An effective programming language to build efficient, fast, reliable and safe software.\n• Julia - Julia is a high-level, high-performance, dynamic programming language. While it is a general-purpose language and can be used to write any application, many of its features are well suited for numerical analysis and computational science.\n• Juvix - A more elegant language for a more civilized age. Juvix synthesizes a high-level frontend syntax, dependent-linearly-typed core language, whole-program optimisation system, and backend-swappable execution model into a single unified stack for writing formally verifiable, efficiently executable smart contracts which can be deployed to a variety of distributed ledgers.\n• K - A proprietary array processing programming language developed by Arthur Whitney and commercialized by Kx Systems. The language serves as the foundation for kdb+, an in-memory, column-based database, and other related financial products. The language, originally developed in 1993, is a variant of APL and contains elements of Scheme. Advocates of the language emphasize its speed, facility in handling arrays, and expressive syntax.\n• KAGSA - KAGSA is a new Interpreted programming language based on Python, the language will be practical and reliable in your projects.\n• Kal - Kal is a highly readable, easy-to-use language that compiles to JavaScript. It's designed to be asynchronous and can run both on node.js and in the browser. Kal makes asynchronous programming easy and clean by allowing functions to pause and wait for I/O, replacing an awkward callback syntax with a clean, simple syntax.\n• Kalaam - Kalaam is the first-ever programming language in Hindi and has all the basic functionalities of a modern programming language. From for loops to while loops and from functions to conditional statements.\n• kalimat - Kalimat is an educational programming language for Arabic-speaking children. It aims for readability and an easy to understand syntax while providing enough features to allow for complex, interesting and fun programs.\n• Kalyn - Self-hosting compiler from a Haskell-like Lisp directly to x86-64, developed fully from scratch.\n• Kantalo - It is a new programming language, not object-oriented, with the aim of being simpler and having a lower learning curve.\n• kaoscript - kaoscript is programming language combining features from ES7, CoffeeScript, TypeScript, Rust, Swift, C# and more. Currently, kaoscript is transpiled to JavaScript.\n• Karel The Robot - Karel The Robot is a robot simulator that affords a gentle introduction to computer programming. Users write Karel programs and feed them to the simulator to watch them execute. Karel's programming language is similar to Pascal.\n• KaryScript - KaryScript is an experimental language to test the possibilities of a more readable textual language. It compiles to ES6 and can be considered a much better ECMAScript\n• Katahdin - Katahdin is a programming language where the syntax and semantics are mutable at runtime. Katahdin employs the theory of parsing expression grammars and packrat parsing. Unlike other contemporary work, Katahdin applies these techniques at runtime to allow the grammar to be modified by a running program. New constructs such as expressions and statements can be defined, or a new language can be implemented from scratch. It is built as an interpreter on the Mono implementation of the .NET framework.\n• KataScript - KataScript is a simple scripting language with familiar syntax, designed to be easily embedded in C++ applications (In-Browser Demo).\n• Kawa - Kawa is a general-purpose programming language that runs on the Java platform. It aims to combine:\n• the benefits of dynamic scripting languages (non-verbose code with less boiler-plate, fast and easy start-up, a REPL, no required compilation step); with\n• KCL - KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems. [Configuration]\n• Keli - Keli is a general purpose programming language where its semantics are mostly based on the pure functional programming model (as of Haskell's) which includes user-defined algebraic datatypes, case matching and higher-order functions, while its syntactic structure is strongly influenced by Smalltalk's message sending syntax, such as the unary, binary and keywords messages.\n• Kempe - Kempe is a stack-based language and toy compiler for x86_64 and aarch64. It requires the nasm assembler when targeting x86_64.\n• Kernel - Kernel is a conservative, Scheme-like dialect of Lisp in which everything is a first-class object.\n• Kew - Kew is a powerful but small object-oriented programming language that offers many advanced features, including proper closures, first-class variables, relations, continuations, exceptions, dynamic variables, security, transactions, persistence....\n• Key - a dynamic language that allowed both class abstraction and object description.\n• Keysharp - Keysharp is a fork and improvement of the abandoned IronAHK project, which itself was a C# re-write of the C++ AutoHotkey project. The intent is for Keysharp to run on Windows, Linux and eventually Mac. For now, only Windows is supported.\n• Kin - Kin is a straightforward programming language created with the purpose of aiding Kinyarwanda speakers in easily learning programming.\n• Kind - A minimal, efficient and practical programming language that aims to rethink functional programming from the scratch, and make it right. Under the hoods, it is basically Haskell, except without historical mistakes, and with a modern, consistent design. On the surface, it aims to be more practical, and to look more like conventional languages. Kind is statically typed, and its types are so powerful that you can prove mathematical theorems on it.\n• kink - Kink is an object-based programming language, adopting object system without inheritance, and delimited continuation as a building block of control structures.\n• Kite - Kite is a programming language designed to minimize as much of the programmer experience as possible — quick development and running time and low CPU and memory usage. As this is a new project, we're just getting things started. Feel free to poke around and learn more!\n• Kitsune - Kitsune is a simple prototype based programming language. Compiles to C++ for portability. Reasonably Fast. Have fun creating a new programming language. Has a good/complete standard library with a focus on games.\n• Kitten - A statically typed concatenative systems programming language. Kitten is a statically typed, stack-based functional programming language designed for simplicity, speed, and safety. This is an in-progress implementation of that language, including:\n• KiXtart - KiXtart is a free-format scripting language and has rich built-in functionality for easy scripting. It supports COM (providing access to ADSI, ADO, WMI, etc) and thus is easily extensible. Since version 4.50 KiXtart comes with inbuild pre-tokenization system for faster loading and smaller scripts and providing some level of intellectual property protection through obfuscation. 4.60 is the first version with com implementation which allows you to use kixtart from any windows application. 4.70 is the latest version\n• klisp - klisp is an implementation of the Kernel Programming Language, a Scheme-like programming language by John N. Shutt in which all objects are first-class.\n• Klong - Klong is an array language, like K, but without the ambiguity. If you know K or APL, you may be disappointed by Klong. If you don't know any array languages, it might explode your brain. Use at your own risk!\n• Koan - The design of Koan is inspired in three main programming languages: Smalltalk/Perl/Scheme; this selection of language has been an entirely personal preference but that is based on the idea of offering the best of each of these languages paradigms mixed in a clean syntax/semantic language/implementation. As a real general purpose programming language, Koan is also intended to solve real problems in real life. The idea of Koan is to focus in easy interoperability with other programs (scripting/embedded capabilities) and easy interfacing with languages like C.\n• kobol - KOBOL is -- we hope -- an obvious play on words for COBOL, which stands for COmmon Business Oriented Language. We therefore refer to KOBOL as KOmpany Business Oriented Language.\n• Kodu - Kodu is a new visual programming language made specifically for creating games. It is designed to be accessible for children and enjoyable for anyone. The programming environment runs on the Xbox, allowing rapid design iteration using only a game controller for input.\n• Kogut - Kogut is an experimental programming language which supports impurely functional programming and a non-traditional flavor of object-oriented programming. Its semantics is most similar to Scheme or Dylan, but the syntax looks more like ML or Ruby.\n• Koka - Koka: a functional language with effects. Koka is a strongly typed functional-style language with effect types and handlers.\n• KPHP - KPHP takes your PHP source code and converts it to a C++ equivalent, then compiles the generated C++ code and runs it within an embedded HTTP server. You could call KPHP a transpiler, but we call it a compiler.\n• Ksi Scheme - Ksi is a portable, embeddable Scheme implementation written in C.\n• L - L is a high-level, open-source, general-purpose and system programming language which emphasizes readability, simplicity, extensibility, conciseness and performance. The L compiler features native code generation through LLVM, and is fully documented in a literate programming style. The language and compiler are usable, but are under heavy development as new features are being implemented.\n• L - L is both a language and an operating environment, like Smalltalk. It is capability-secure and distributed, like E. The language is a derivative of lambda calculus, hence it is small, block-structured, dynamically-typed, and functional. State is implicitly threaded through all function calls and returns, allowing simulation of dynamic scope and side-effects. Each thread runs in its own transaction, upon completion its state changes are committed. Any concurrent threads that conflict are aborted and re-executed at a higher priority. Each commited state change is an event. Event handlers spawn new threads (repeating the cycle).\n• L+ - The language our compiler takes as input, called L+, supports most constructs from C (variables, branches, loops, functions, recursion and I/O) albeit with some limitations and some additions. The L+ compiler generates Java Bytecode. L+ programs can be run on any platform with a Java VM installed.\n• L++ - L++ is a programming language that transcompiles to C++. It uses Lisp-like syntax.\n• L.B.Stanza - L.B. Stanza (or Stanza for short) is a new optionally-typed general purpose programming language from the University of California, Berkeley. Stanza was designed to help programmers tackle the complexity of architecting large programs and significantly increase the productivity of application programmers across the entire software development life cycle.\n• L.in.oleum - L.in.oleum is an unstructured, untyped, procedural programming language. And more specifically, it's a form of cross-platform assembly language. It is oriented to the developement of general-purpose applications, especially when 100% portability, execution speed and module compactness is requested. This language has an almost 1:1 source-to-CPU instruction ratio, allows direct access to five general-purpose registers (performing basic operations from a theoretical 2 up to a pratical of even 10 times faster than memory-held variables), and if used well, is averagely twice as fast as C in pure computational power.\n• Laby - Your robot ant can be programmed in many languages: OCaml, Python, C, C++, Java, Ruby, Lua, JavaScript, Pascal, Perl, Scheme, Vala, Prolog. Experienced programmers may also add their own favorite language.\n• Lake - The Lake programming language: C but sweeter\n• Lang5 - A Perl based interpreter for a language which is a blend of Forth and APL. The power of lang5 stems from its arrays operations in conjunction with the underlying Forth programming paradigm of bottom up programming.\n• language machine - The language machine is an efficient and usable toolkit for language and grammar. It aims to be directly and immediately useful, and it embodies a powerful model of language. This requires a paradigm shift but it comes with a diagram which explains how it works. In the documentation you will find numerous examples including the metalanguage compiler frontend and the rules that generate these pages. There is also a demonstration that the language machine can very directly represent and evaluate the lambda calculus, and an outline of its place in relation to theory.\n• Language Processor - I did what any real geek would do; I have written a compiler compiler. It is called Language Processor. A software that you can feed in a language definition with its semantic and you get an object that can run your program in your defined language.\n• Larceny - Larceny is a simple and efficient implementation of the Scheme programming language. Created originally as a test vehicle for research on garbage collection and compiler optimizations, Larceny has grown into a major multiplatform system. Larceny supports the four most important standards for Scheme: IEEE/ANSI, R5RS, R6RS, and R7RS. Development of Larceny has been supported by NSF, Sun Microsystems, and Microsoft.\n• Lark - Lark is an experiment in designing a homoiconic language with a syntax inspired by SmallTalk. It's very early, so there isn't much to see yet, but you can play with it.\n• LASIC - LASIC is a language that facilitates creating and managing systems in a cloud environment. It allows you to create scripts that describe a system, its components, and the relationship between those components using a declarative syntax. Various verbs can then be applied to the script such as deploy (create a new system), shutdown, or runAction(run some action on components of the system). LASIC currently supports Amazon's cloud environment (AWS). LASIC stands for Language for Automating Systems in the Cloud.\n• Latte - Latte, the Language for Transforming Text, is a simple and powerful language for including markup in text documents. Documents written in Latte can be converted to high-quality HTML, making it a better language for writing World Wide Web documents.\n• Lava - an experimental object-oriented rapid application development (RAD) language with type parameters (\"virtual types\"), refactoring, and extensive static checks, that prevent inadvertent access to uninitialized variables and null objects already at programming time. The Lava programming environment LavaPE replaces text editors completely by structure editors. It provides an inheritance notion not only for single classes, but also for packages (= collections of related classes, which may have type parameters, too).\n• LC-3 - Version 3.01 of the Windows LC-3 assembler and simulator\n• ldpl - Compiled programming language for Unix systems, inspired by COBOL and designed to be expressive, fast, readable and easy to learn.\n• Leafscript - Leafscript is a lightweight programming language created as a proof of concept by someone with no idea how to write a language. It's written entirely in Golang, and was inspired by the speed and simplicity of Lua.\n• Lean - Lean is an open source theorem prover and programming language being developed at Microsoft Research. Lean aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs.\n• LeekScript - Leek Wars is a programming game in which you have to create the most powerful leek and destroy your enemies! Develop your own artificial intelligence thanks to LeekScript, an easy to learn language and become the best farmer!\n• Lemick - Lemick is a programming language with BASIC syntax, it's a typed and a compiled language, its source is compiled into a platform-independent virtual machine assembler that is later transformed into a platform-dependent representation by the just-in-time compiler. Lemick supports concurrent and distributed programming (multi-threading and distributed multi-threading). Rendezvous are used for message passing; replicas and ultra-weak consistency model implement distributed shared memory simulation. Extension of exception handling mechanism, including distributed version is being developed now. Lemick favors mixed procedural and object-oriented programming style.\n• Leo - Leo is a functional, statically-typed programming language built for writing private applications. Leo provides a high-level language that abstracts low-level cryptographic concepts and makes it easy to integrate private applications into your stack. Leo compiles to circuits making zero-knowledge proofs practical.\n• Leo - a HTML precompiler for static home page generation. It detects special HTML tags in your page and generates HTML code out of it\n• Lever - Lever is a loosely specified general purpose programming language, and a runtime implementation of that language. Many tradeoffs have been made to obtain high plasticity worthy of pride. To make use of this every feature is tried in practice to level out prickly details in the language before a major release.\n• levy - An implementation of Paul Levy's call-by-push-value language. The language has the following constructs:\n• booleans with conditional statements and comparison =, < of integers\n• call-by-push-value features: return, thunk, force, sequencing, and let binding Call-by-push-value is very precise about what gets evaluated when and can express both call-by-value and call-by-name.\n• lfyre - lfyre is a general purpose, compiled programming language. It offers high performance, expressive power and flexibility. It has many features found in other languages, plus extra features as creating new operators, keywords and programming paradigms.\n• LHDL - LHDL - while not a hardware description language, may be seen as the first step in that direction. Check out the README for more information. Also see the ChangeLog. LHDL is Open Source -- released under an MIT-style license. See included LICENSE file for more information.\n• Lhogho - Lhogho is a free version of the programming language Logo and a promoter of its educational philosophy. It is specially designed to be performant, miniature, open-minded and ... artistic.\n• Libra - Libra is a basic stack-based programming language simulated through Haskell. Heavily inspired by Porth and Forth\n• LIL - LIL (stands for Little Interpreted Language) is a small highly dynamic scripting language inspired by Tcl and unix shells. LIL has two implementations, one written in C, which consists of a pair of .c and .h files and one in Free Pascal, which consists of a single pas file (a unit). Also a Lazarus package for the latter is provided.\n• Lily - Lily is statically-typed, with an interpreter as a reference. Lily uses reference counting for memory management with garbage collection as a fallback.\n• Lingo - Lingo makes it easy to learn to program for Windows. If you're new to programming, you can download Lingo and write your first program very easily. And experienced programmers benefit because Lingo is quick to install and simple to use! Lingo includes a Developer Environment for designing forms, managing projects and debugging.\n• lisaac - motivation: focused on expressiveness through simplicity; programming for operating systems; speed execution; no virtual machine; software engineering pure: minimal syntax; all values are objects; prototype-based object model; everything is a message dynamic: all messages are dynamic; code is a runtime modifiable tree; delayed evaluation block; differential inheritance; dynamic and multiple inheritance security: strong type; design by contract; genericity accessible: small; embeddable; open source inspiration: self; smallTalk; Eiffel; C (for hardware support)\n• LispE - A Lisp implementation with Data Structure, Arithmetic Type, Array Instructions, Pattern Matching and many many different instructions and libraries. LispE is a mix of functional and array languages.\n• LITTLE - LITTLE is a new programming language, looking like LISP, but pure Object-Oriented.\n• Little - Little is a statically-typed scripting language that combines C syntax and types with Perl's regexes and associative arrays, and dynamically compiles the whole lot to Tcl byte-codes. All Tcl/Tk facilities are available to Little, and source files can interleave Little and Tcl code that call each other.\n• Little - Little is a statically typed, C-like scripting language.\n• Little Man Computer - The Little Man Computer (LMC) is a simplified example of computer hardware and software which can be used to explain the fundamental principles of computer engineering. The LMC contains all of the components of modern computers: Memory, a Central Processing Unit (CPU), and input/output capability. A small but powerful programming language is used which allows the programmer to define a computation or operation for the Little Man to perform. By writing and executing simple programs, the student is able to understand the function of each component of the hardware. Writing, debugging and executing LMC programs is supported by a color menu-driven software package written in the C programming language for the DOS environment. This paper describes the organization of the LMC, the machine language of the LMC, the LMC assembly language, the LMC Assembler, and the menu-driven user interface for the LMC.\n• Lizard - Lizard is a domain-specific language to define and control hardware behaviour. It is intended to run on embedded systems which are connected to motor controllers, sensors etc. Most of the time it is used in combination with a higher level engine like ROS or RoSys. You can think of the microcontroller as the machine's lizard brain which ensures basic safety and performs all time-critical actions.\n• LMQL - LMQL is a programming language for large language models (LLMs) based on a superset of Python. LMQL offers a novel way of interweaving traditional programming with the ability to call LLMs in your code. It goes beyond traditional templating languages by integrating LLM interaction natively at the level of your program code.\n• Lobster - Lobster is a statically typed programming language with a Python-esque syntax that combines the advantages of an expressive type system and compile-time memory management with a very lightweight, friendly and terse syntax, by doing most of the heavy lifting for you.\n• Loci - Loci is a multi-paradigm systems programming language. Or, to describe it in a slightly more intuitive way, it’s very similar to, and a close competitor of, C++.\n• Logix - Logix is more than a programming language. It is multi-language programming system. With Logix, each part of your program can be developed in a language that is finely tuned to the task. Featuring a procedural macro facility, dynamic syntax extension, and multi-language parsing. A new operator, complete with syntax and semantics, can be added on-the-fly with a single line of code.\n• Logtalk - Logtalk is a declarative object-oriented logic programming language that extends and leverages the Prolog language with modern code encapsulation and code reuse mechanisms while also providing improved predicate semantics.\n• Implemented as a trans-compiler in highly portable, extensively tested, and well documented code, it can use most modern and standards compliant Prolog implementations as a backend compiler.\n• As a multi-paradigm language, it includes support for modules, prototypes, classes, protocols (interfaces), categories (components and hot patching), event-driven programming, and high-level multi-threading programming. Distributed under a commercial friendly license, it includes full documentation, portable libraries, portable developer tools, and a large number of programming examples to help get you started.\n• Loko - Loko is an interactive interpreter for the Logo programming language targeting MakoVM, an extremely simple stack-based virtual machine intended for the creation of video games. Logo is best known for beginner-oriented \"Turtle Graphics\" functionality, but internally the language is actually a dynamically-scoped member of the Lisp family. As such, Logo provides sophisticated list manipulation facilities and support for higher-order functions.\n• LOLCODE - This is a love letter to very clever people who are slightly bored. I had no idea there were so many of us out there. (from the FAQ)\n• Looking Glass - Looking Glass is a programming environment for ages 10 and up. With Looking Glass, you can create and share animated stories, simple games, and even virtual pets.\n• Loop - Our vision of Loop is to provide new infrastructure specialists with a “one-stop shop” for most of the software-defined infrastructure tools that are used in home environments, and cloud services. Think of Load balancers, Infrastructure as Code, monitoring, and containerization. These tools exist individually; However, having one language that handles different aspects of virtual infra all while having your application besides it is new. We like to call it infrastructure with code.\n• LSCRIPT - The Lcomp Scripting Engine is a scripting engine written in Visual BASIC for DOS 1.0 that can be used by a programmer to write automatated scripts to perform routine actions in DOS. It can be used as a simple automation tool or a vast programming language\n• LSTS - LSTS is a proof assistant and maybe a programming language. Proofs in LSTS are built by connecting terms, type definitions, and quantified statements. Terms can be evaluated to obtain Values. Types describe properties of Terms. Statements describe relations between Terms and Types.\n• Lua - Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.\n• Luban - Luban is a component oriented scripting language. Luban is free and open source. Luban is named after a legendary ancient Chinese civil engineer and carpenter two thousand year ago whose constructions are still in use today.\n• Lucid - Lucid is a non-imperative dataflow language, designed over 20 years ago by William W. Wadge and Edward A. Ashcroft. The idea is that nearly all programming languages are based in the idea of �flow of control�. What do we get when we try to orient around �flow of data� instead? One immediate reaction would be, �well, I bet it is like programming with pipes and filters in UNIX\", and sure enough it is, but Lucid goes a little beyond that.\n• Lucid Synchrone - Lucid Synchrone is an experimental language for the implementation of reactive systems. It is based on the synchronous model of time as provided by Lustre combined with some features from ML languages.\n• Lush - Lush is an object-oriented programming language designed for researchers, experimenters, and engineers interested in large-scale numerical and graphic applications. Lush is designed to be used in situations where one would want to combine the flexibility of a high-level, weakly-typed interpreted language, with the efficiency of a strongly-typed, natively-compiled language, and with the easy integration of code written in C, C++, or other languages. Lush is Free Software (under the GPL license) and runs on GNU/Linux, Solaris, Irix, and Windows under Cygwin. Lush can be used advantageously for projects where one would otherwise use a combination of an interpreted language like Matlab, Python, Perl, S+, or even (gasp!) BASIC, and a compiled language like C. Lush brings the best of both worlds by wrapping three languages into one: (1) a weakly-typed, garbage-collected, dynamically scoped, interpreted language with a simple Lisp-like syntax, (2) a strongly-typed, lexically-scoped compiled language that uses the same Lisp-like syntax, and (3) the C language, which can be freely mixed with Lush code within a single program, even within a single function. It sounds complicated, but it is not. In fact, Lush is designed to be very simple to learn and easy to use.\n• Lux - Lux is a new programming language in the making. It's meant to be a functional, statically-typed Lisp that will run on several platforms, such as the Java Virtual Machine and JavaScript, Python, Lua, or Ruby interpreters.\n• LX - LX is a general purpose compiled programming language, like C, C++, Pascal, Ada or Eiffel. Although LX borrowed a lot from these respected ancestors and many others, trying to incrementally improve over each of them, LX still differs from all these other languages\n• Lygon - Lygon is a logic programming language that is based on linear logic. It can be viewed as Prolog extended with features derived from linear logic. These features include a declarative notion of state and the ability to express problems involving concurrency. Also, the availability of use once predicates allows simple solutions to problems such as graph manipulation. Although the design of Lygon relies on a delicate proof-theoretic analysis of linear logic, programmers need have no knowledge of proof theory.\n• m80 - A build-tool independant framework for linking builds for a complete one touch system deployment in multiple environments. Includes a centralized metadata repository, code-generator framework, scripting language, re-usable macro libraries, and more.\n• Macro Lambda Calculus - lambda calculus using interaction nets, providing CLI and API. Its browserified version is available as an online demo.\n• MAD - Music as Data (MAD) is a live programming language/environment based on Processing.org written in Clojure. MAD lets you treat music as data and apply data transformation on the fly so you can experiment with notes and samples.\n• Magda - Magda is based upon the core notion of mixin as the only unit of reuse. The power of modularization of mixins is enhanced by two unique features. The first feature is the modularization of constructors. In Magda, many mixins with independent definitions of constructors can be combined without the need to copy any code and without the risk of clashes. The second distinctive feature modifies the way declarations of new methods, overriding methods, and method calls are done, in order to rule out accidental name clashes, even with respect to future modifications of the code.\n• Magmide - A dependently-typed language intended to make provably correct code possible for working software engineers.\n• Magnet - Magnet is an object-oriented programming language, that is prototype-based to the point of real types being absent in favor of duck types. E.g. every object providing a read method that returns a readable, is considered \"readable\" (meaning it can represent a string). Since this causes a recursion, there must be some \"primal\" readable to end that: Such primal readable is also known as a String Object in Magnet. Furthermore, Magnet is syntax driven. This means: Everything that can be done to reduce code, retain simplicity and to amaze the developer, IS done!\n• Magpie - Magpie is a small dynamically-typed programming language built around patterns, classes, and multimethods. It has a prototype interpreter that runs on the JVM and an in-progress bytecode VM written in C++.\n• Maker - Maker, a Forth-inspired compiled language targeting Mako. Mako is an extremely simple stack-based virtual machine intended for the creation of video games.\n• MakoForth - MakoForth is a small Forth dialect targeting MakoVM, an extremely simple stack-based virtual machine intended for the creation of video games. MakoForth should be moderately familiar to anyone who has been exposed to ANS-Forth. The major notable differences are the use of # as line comments, loop...(break)...again|until|while looping constructs and the inclusion of syntax for inline double-quoted string constants. Cells are always 32-bit two's complement signed integers.\n• Mango - Mango draws on the following langauges: SETL - set operations; ALGOL - imperative block structure and syntax; C - low level ops, low overhead, maps well to machine, syntax; ML - type inference, type syntax; ADA - type inference, fine grained control over primitives; PYTHON - indentation based syntax; JAVA - interfaces; C++ - set of standard collections (STL), operator; overloading, io syntax; CLU - iterators; PASCAL - sets (bit masks); PERL - richness of expressibility; COBOL - readable syntax\n• MANOOL - MANOOL is a programming language designed with an idea to maximize the expressive power / implementation complexity ratio.\n• Manticore - Manticore is a high-level parallel programming language aimed at general-purpose applications running on multi-core processors. Manticore supports parallelism at multiple levels: explicit concurrency and coarse-grain parallelism via CML-style constructs and fine-grain parallelism via various light-weight notations, such as parallel tuple expressions and NESL/Nepal-style parallel array comprehensions.\n• MarkovJunior - MarkovJunior is a probabilistic programming language where programs are combinations of rewrite rules and inference is performed via constraint propagation. MarkovJunior is named after mathematician Andrey Andreyevich Markov, who defined and studied what is now called Markov algorithms.\n• Mars - Mars is a very simple imperative programming language with a catch: all of the functions and expressions are pure. That means when you call a function, it is guaranteed to have no side-effects: it can't mutate its arguments, modify global variables, or perform input/output. But unlike other pure languages, Mars gives you all the nice features of imperative programming, like local variable assignments and loops. The compiler also automatically converts inefficient copy-and-update operations into in-place destructive operations. Mars also has some other nice features borrowed from functional programming: a strong static type system, algebraic data types, pattern-matching switch statements, and higher-order functions. Mars is an experiment, not a full-featured programming language. You can use it for playing with the boundaries between imperative and declarative programming, but we don't recommend you write real software with it.\n• Marten - Draw software code, execute while editing, and build MacOS X applications with a single click of a button with the Marten™ software development environment for the Prograph visual programming language. Marten lets you create software graphically, connecting icons to icons rather than writing text. Gone are syntax errors, compile/link/debug steps, unexplained build failures, and autorelease pools. What's left is what software development should be... fun!\n• MASICA - An educational interactive TinyBASIC interpreter targeting MakoVM, an extremely simple stack-based virtual machine intended for the creation of video games. MASICA is designed to provide an absolute minimum of features and complexity while including what is necessary to illustrate core imperative programming concepts such as variables, iteration and conditional branches. Variable names are single letters. The MASICA interface is similar to that of early 8-bit microcomputers- a prompt which can evaluate commands immediately or store a sequence of commands prefixed with line numbers. Several commands for removing or editing existing lines are also provided.\n• Matita - Matita (that means pencil in italian) is an experimental, interactive theorem prover under development at the Computer Science Department of the University of Bologna.\n• Maude - Maude is a high-performance reflective language and system supporting both equational and rewriting logic specification and programming for a wide range of applications. Maude has been influenced in important ways by the OBJ3 language, which can be regarded as an equational logic sublanguage. Besides supporting equational specification and programming, Maude also supports rewriting logic computation.\n• Mavscript - Mavscript allows the user to do calculations in a text document. Plain text, LaTeX and OpenOffice Writer files (.odt) are supported. The calculation is done by the algebra system Yacas (default), Jasymca or by the Java interpreter BeanShell.\n• mawk - mawk is an interpreter for the AWK Programming Language.\n• Mbeddr - mbeddr is a set of integrated and extensible languages for embedded software engineering, plus an IDE. It supports implementation, testing, verification and process aspects. It integrates with command-line build tools and integration servers, as well as file-based version control systems. mbeddr has support for requirements and product line definition, software documentation, implementation in C and C extensions such as state machines physical units or interfaces and components, as well as testing, mocking, as well as formal verification. mbeddr comes with a state-of-the-art IDE including syntax coloring, code completion, go to definition, realtime type checks, quick fixes, refactorings, customizable find-usages, automated synchronization between related parts of the code, version control integration and debugging.\n• MCPL - MCPL is a simple typeless language which is based on BCPL. It makes extensive use of pattern matching somewhat related to that used in ML and Prolog, and some other features come from C.\n• Mecca - Mecca is a different way of programming batch. We make it a little but more real by using code that looks nothing like batch, but it is! Requires .NET 4 and above! A good knowledge of batch would help too.\n• Mecrisp - Welcome to the Mecrisp family of native code optimising Forth compilers for MSP430, ARM, RISC-V, MIPS, and stack machines on FPGAs.\n• Melody - Melody is a language that compiles to regular expressions and aims to be more easily readable and maintainable.\n• Mercat - Mercat is not really useful for anything much. It is, on the other hand, an excellent example of how to implement a self-hosted recursive-descent-parsed language and virtual machine\n• Mercury - Mercury is a logic/functional programming language which combines the clarity and the expressiveness of declarative programming with advanced static analysis and error detection features.\n• Merlin - Merlin is a new network management framework that allows administrators to express policies in a high-level, declarative language based on regular expressions. The compiler automatically partitions those policies into components that can be placed on a variety of devices including switches, middleboxes, and end hosts. The compiler uses a constraint-solver to determine the optimal placement strategy using paramaterizable heuristics. Sub-policies may be further constrained by network tenants, facilitating management of federated networks. Merlin provides techniques for verifying that both the partitioned program components and the delegated sub-policies conform to the global network policy. Overall, Merlin simplifies the task of network administration by providing high-level abstractions for specifying network policies and scalable infrastructure for enforcing them.\n• Meta - Meta is a simple programming language. Meta is an attempt to create the conceptually simplest programming language that is still practical to use.\n• MetaCall - MetaCall is an extensible, embeddable, and interoperable cross-platform polyglot runtime. It supports NodeJS, Vanilla JavaScript, TypeScript, Python, Ruby, C#, Java, WASM, Go, C, C++, Rust, D, Cobol and more.\n• Metacza - Metacza compiles a functional language to C++ Template Meta Language. It can be used to ease Template Meta Programming in C++.\n• MetaL - MetaL is shorthand for Meta-programming Language. Meta-programming is a method to develop computer programs. It works by generating source code in a target language from a program specification in a higher level language. MetaL programs source code is based on XML. MetaL compiler engine can be used to generate the same program from MetaL source code to potentially any target language. Currently supported target languages are PHP, Java and Perl. The support for other languages can be added any time.\n• Mica - Mica is: An interpreter for a garbage collected, dynamically typed, object-oriented language with prototype-based inheritance, multiple dispatch, strict encapsulation and capabilities for security, optional orthogonal persistence, and functional programming features (anonymous functions, functional lists and dictionaries, map and filter operators).\n• midori - Programming language based off pure type systems, and COQ. Currently aimed at both systems, and application programming. Has a simple syntax, and (planned) C integration.\n• MillScript - MillScript is a full featured, yet easy to use language for the batch production of templated Web sites. The language is a Java-based, early implementation of Spice: an experimental language developed by the OpenSpice group.\n• MiniLang - A type-safe C successor that compiles directly to various platforms. [C-killer]\n• MiniScript - MiniScript is modern, elegant, easy to learn, and easy to embed in your own C#, C++ or Kotlin projects.\n• MiniZinc - MiniZinc is a high-level constraint modelling language that allows you to easily express and solve discrete optimisation problems.\n• Minsk - Minsk, a handwritten compiler in C#. It illustrates basic concepts of compiler construction and how one can tool the language inside of an IDE by exposing APIs for parsing and type checking.\n• Mint - A refreshing programming language for the front-end web, aiming to solve the most common issues of Single Page Applications (SPAs) at a language level:\n• Synchronous and asynchronous computations that might fail\n• Mirah - Mirah is a customizable programming language featuring static types, local type inference and a heavily Ruby-inspired syntax. Mirah currently includes a typer/compiler backend for the JVM which can output JVM bytecode.\n• Mirelle - Mirelle is a programming \\ scripting language for .NET platform, designed for simple prototyping and simulation modelling. It features lightweight syntax and extensibility via .NET assemblies.\n• Mirth - Mirth is a new strongly-typed concatenative programming language. Mirth is inspired by Forth, Joy, Haskell, Lisp, and monoidal category theory.\n• Misc - Misc is a programming language designed especially for performing calculations on large amounts of data. The Misc Engine library is a portable C++ library containing Misc compiler, interpreter and standard built-in functions. The main purpose of Misc is to serve as a base engine for other applications. For example, one could create a GUI front-end for drawing graphs using the data generated by a script written in the Misc language. The functionality of the Misc Engine by itself is limited to calculations, data manipulations and simple I/O operations. However its ability to be extended with additional functions makes it a powerful tool.\n• MIX/MIXAL - MIX is Donald Knuth's mythical computer as described in his monumental work The Art Of Computer Programming. As any of its real counterparts, the MIX features registers, memory cells, an overflow toggle, comparison flags, input-output devices, and a set of binary instructions executable by its virtual CPU. You can program the MIX using an assembly language called MIXAL, the MIX Assembly Language.\n• MLF - We propose a type system MLF that generalizes ML with first-class polymorphism as in System F. Expressions may contain second- order type annotations. Every typable expression admits a principal type, which however depends on type annotations. Principal types capture all other types that can be obtained by implicit type instan- tiation and they can be inferred. All expressions of ML are well- typed without any annotations. All expressions of System F can be mechanically encoded into MLF by dropping all type abstractions and type applications, and injecting types of lambda-abstractions into MLF types. Moreover, only parameters of lambda-abstractions that are used polymorphically need to remain annotated.\n• mLite - a lightweight (and slightly odd) inhabitant of the ML universe. Much like ML, but with dynamic typing, guards, and a Haskell-style apply operator.\n• MMBASIC - MMBasic is a free and open BASIC interpreter for 32 bit microcontrollers. It includes floating point numbers, extensive string handling, multi dimensional arrays and structured programming features like do loops, multiline if statements, user defined subroutines and functions. MMBasic is generally backwards compatible with Microsoft's MBASIC and implements much of the ANSI Standard for Full BASIC (X3.113-1987).\n• Mocha - Mocha is a new programming language that was developed for applications distributed on a small scale. You can make simple applications. Features include: if statements, nested functions, forms, and over 100 functions. To run Mocha you'll need the Visual Basic 6.0 runtime file (msvbvm60.dll), the Microsoft Common Dialog Control, and the Windows Common Controls. For the actual Mocha applications though, you only need msvbvm60.dll.\n• Modula-2 (GNU) - Modula-2 is a programming language developed by Niklaus Wirth at ETH in Zurich, Switzerland in the late 70's. Wirth also developed Algol-W, Pascal, Modula, and Oberon. Modula-2 corrects some of the deficiencies of Pascal. It is suitable for learning programming, for large projects written and maintained in the fashion of professional software engineers, and for real time embedded systems. Modula-2 is small, expressive, easy to learn and to read.\n• Modula-P - Modula-P is a structured programming language for asynchronous parallel programming (MIMD systems), developed by Thomas Bräunl in 1986. The language is based on sequential Modula-2, but extended by machine-independent parallel constructs. Modula-P allows explicit declaration and starting of processes. The language includes the classical synchronization concepts of semaphores, monitors with conditions, and remote procedure calls.\n• Mojo - Mojo is a new programming language that bridges the gap between research and production by combining Python syntax and ecosystem with systems programming and metaprogramming features. Mojo is still young, but it is designed to become a superset of Python over time.\n• Mond - A scripting language for .NET Core. You can try it in a browser here.\n• Monkey 2 - Monkey2 is an easy to use, cross platform, games oriented programming language from Blitz Research.\n• Monte - Monte is a programming language inspired by the E and Python programming languages. Monte aims to be:\n• An example of capability-safe programming language design\n• MoonScript - MoonScript is a dynamic scripting language that compiles into Lua. It gives you the power of one of the fastest scripting languages combined with a rich set of features.\n• Mops - A full featured, stand-alone development environment for programming the Macintosh written by Mike Hore. Inspired by Smalltalk and the commercial language Neon, Mops is based on Forth with extended object-oriented features such as multiple inheritance, early and late binding, persistent objects, and garbage collection.\n• Mosel - Mosel is an environment for modeling and solving problems. To this aim, it provides a language that is both a modeling and a programming language. The originality of the Mosel language is that there is no separation between a modeling statement (e.g. declaring a decision variable or expressing a constraint) and a procedure that actually solves the problem (e.g. call to an optimizing command). Thanks to this synergy, one can program a complex solution algorithm by combining modeling and solving statements.\n• Motion - Motion is a clean, dynamically typed programming language, created in C with no dependencies.\n• Motorway - An esoteric programming language based around the British motorway network.\n• Move - Move is a programming language based on Rust that was created by Facebook for developing customizable transaction logic and smart contracts for the Libra digital currency. Every transaction submitted to the Libra blockchain uses a transaction script written in Move to encode its logic.\n• Move - A simple, functional-biased, prototypal and powerful programming language that runs on any ES3 (or better) JavaScript platform, aimed toward people new to programming\n• Mozart - The Mozart Programming System combines ongoing research in programming language design and implementation, constraint logic programming, distributed computing, and human-computer interfaces. Mozart implements the Oz language and provides both expressive power and advanced functionality.\n• MPSL - MPSL (Minimum Profit Scripting Language) is a programming language concieved as an scripting engine for software/mp [Minimum ProfitText Editor], though it can also be used as a general-purpose programming tool. An MPSL program consists of a sequence of statements which run from top to bottom. Loops, subroutines and other control structures allow you to jump around within the code. It is a free-form language, meaning that you can format and indent it however you like, as whitespace serves to separate tokens.\n• Muesli - Muesli: Multiple Utility, Evaluation and Scripting Language Interface: Muesli is a library to interface an application to multiple programming language evaluators (normally, interpreters). Muesli allows your program to call any one (or more) of a number of programming language interpreters through a consistent interface, such that you can choose the language(s) to use at run-time. It can be used anywhere where you want to use a scripting language but don't want to be restricted to any particular scripting language.\n• MUMPS - Massachusetts General Hospital Utility Multi-Programming System, or M, is a high performance transaction processing key-value database with integrated programming language. It was originally developed at Massachusetts General Hospital for managing hospital laboratory information systems. MUMPS technology has since expanded as the predominant database for health information systems and electronic health records in the United States. MUMPS-based information systems run over 40% of the hospitals in the U.S., run across all of the U.S. federal hospitals and clinics, and provide health information services for over 54% of patients across the U.S.\n• muon - Muon is a modern low-level programming language, inspired by C, C#, Go, Rust and Python.\n• Myia - Myia is a new differentiable programming language. It aims to support large scale high performance computations (e.g. linear algebra) and their gradients. The main application Myia aims to support is research in artificial intelligence, in particular deep learning algorithms.\n• Myrddin - Myrddin is a programming language. It aims for control and simplicity. It features strong type checking, generics, type inference, closures, and traits. It aims to fit into a similar niche as C, but with fewer bullets in your feet. Myrddin does not aim to explore the forefront of type theory or compiler technology. It does not focus on guaranteeing perfect safety. It is satisfied to be a practical, small language.\n• μC++ - The μC++ project extends C++ with new constructs providing advanced control-flow including light-weight concurrency on shared-memory uni- and multi-processor computers running UNIX and Linux operating systems. μC++ accomplishes this by providing new kinds of classes: coroutines, which have independent execution states; tasks, which have their own threads; and monitors, which allow for safe communication among tasks. These new classes can take part in inheritance, overloading, and templates, just like other classes. As well, C++ exception handling is extended, allowing exceptions to propagate among coroutines and tasks. Additional capabilities include: clustering of tasks and processors, object-oriented non-blocking I/O for files and sockets, and support for real-time programming. True parallelism is achieved utilizing operating-system kernel-threads. μC++ clarifies and extends object-oriented concurrency providing generality and functionality that surpasses languages like Ada, Java, and C#.\n• Nature - Nature is the modern systems programming language and compiler, striving for elegant and concise syntax while prioritizing the writing and reading experience for developers. Key features of nature at the language level include:\n• In-house compiler/assembler/linker, not reliant on llvm. Supports compilation for amd64/riscv64/wasm architectures\n• Non-intrusive interaction with C for efficient and high-performance development\n• Neko - Neko is a high-level dynamically typed programming language. It can be used as an embedded scripting language. It has been designed to provide a common runtime for several different languages. Learning and using Neko is very easy. You can easily extend the language with C libraries. You can also write generators from your own language to Neko and then use the Neko Runtime to compile, run, and access existing libraries.\n• Nelua - Nelua (stands for Native Extensible Lua) is a minimal, efficient, statically-typed and meta-programmable systems programming language heavily inspired by Lua, which compiles to C and native code.\n• Neon - to find out whether a useful programming language can avoid some of the common pitfalls that beginners frequently encounter in other languages. Some of these common errors avoided by design are:\n• Writing if (x = 0) when if (x == 0) is intended\n• Forgetting to use the return value of a function\n• Never - Never is a simple functional programming language. Technically it may be classified as syntactically scoped, strongly typed, call by value, functional programming language.\n• NewLang - NewLang is a high-level programming language that combines standard algorithmic constructs with declarative programming and tensor computing for machine learning problems. The main feature of the language is an easy, logical and non-contradictory syntax, which is not based on the use of reserved keywords, but on a strict system of grammatical rules using punctuation marks (which also includes language operators).\n• newRPL - newRPL is a re-implementation of the HP48/49/50 series calculators programming environment. The RPL scripting language is being redesigned and recreated with even more powerful features.\n• Nice - Nice is a new programming language. It extends the ideas behind object-orientation in order to better support modular programming and static type safety. It also incorporates features from functional programming, and puts into practice state-of-the-art results from academic research. This results in more expressivity, modularity and safety.\n• Nickle - Nickle is a programming language based prototyping environment with powerful programming and scripting capabilities. Nickle supports a variety of datatypes, especially arbitrary precision numbers. The programming language vaguely resembles C. Some things in C which do not translate easily are different, some design choices have been made differently, and a very few features are simply missing. Nickle provides the functionality of UNIX bc, dc and expr in much-improved form. It is also an ideal environment for prototyping complex algorithms. Nickle's scripting capabilities make it a nice replacement for spreadsheets in some applications, and its numeric features nicely complement the limited numeric functionality of text-oriented languages such as AWK and PERL.\n• Nim - Nim is a compiled, garbage-collected systems programming language with a design that focuses on efficiency, expressiveness, and elegance (in that order of priority).\n• Nimskull - An in development statically typed systems programming language; with sustainability at its core. We, the community of users, maintain it.\n• Nit - Nit is an expressive language with a script-like syntax, a friendly type-system and aims at elegance, simplicity and intuitiveness.\n• Nix - Expression language for the Nix package manager. The Nix expression language is a pure, lazy, functional language.\n• Noja - Noja is a high level language with dynamic typing inspired from CPython, which features an import system, type assertions, multiple return values and more!\n• North-Hollywood Python - A strongly-typed, memory-safe, compiled dialect of Python, that transpiles to human-readable C.\n• Nosica - Nosica is an Object-Oriented language, with a syntax similar to Java or C++, and with advanced high level features such as a strong type system, automatic memory management, and global code optimisation. Nosica is developped in Java(gcj) and is GPLed. The compiler is not very usable yet even if you can write non trivial programs. For example, the Nosica standard library already contains generic containers like Vector, or Map. The compiler translates Nosica source code into C and calls gcc to compiles the result in an executable.\n• notc - This is a simple interpreter with c-like syntax.\n• Nox - Nox is a programming language written in Rust. Memory and thread safety without compromising performance are the most important goal. Performance is also the most important goal. The language should be as simple as it possibly can given the above goals.\n• NPL - NPL or Neural Parallel Language is an open source, high-performance scripting language.\n• nScript - It is a simple script similar to C language. You can easily create small batch processes. The script has the following characteristics:\n• NScript - NScript is a tool similar to WScript except that it allows scripts to be written in .NET languages such as C#, VB.NET and JScript.NET. NScript automatically compiles the code into an assembly in memory and executes the assembly. The NScript setup application associates NScript with \".ncs\" (for C# scripts), \".nvb\" (for VB.NET scripts) and \".njs\" (for JScript .NET scripts) file extensions. This enables any code written in these files to be executed directly by double clicking on these files in windows explorer. I wrote this tool when I needed to write a script for automating builds. A simple batch file was not sufficient for the task and I preferred to write code in C# as opposed to VBScript or JScript. This tool came in handy as I could modify the scripts easily and execute them by double clicking on the files in windows explorer.\n• Oberon - Oberon is a general-purpose programming language first published in 1987 by Niklaus Wirth and the latest member of the Wirthian family of ALGOL-like languages (Euler, ALGOL W, Pascal, Modula, and Modula-2).\n• Oberon+ - Oberon+ is a general-purpose, procedural and object-oriented programming language in the tradition of Oberon-07 and Oberon-2. The most important features of Oberon+ are block structure, modularity, separate compilation, static typing with strong type checking, generic programming, garbage collection, and type extension with type-bound procedures.\n• Objeck - Objeck is an object-oriented programming language with functional features. Objeck emphasizes, expression, simplicity, portability, and scalability. The programming environment consists of a compiler, virtual machine, and command line debugger with IDE plugins.\n• Objective Lua - Objective Lua is an almost pure superset of Lua that welds the Objective C object orientation system and syntax on top of the classic Lua language. It is written entirely in Lua and works by translating Objective Lua code into Lua code as it is loaded. This means that it's incredibly portable and incredibly fast.\n• Objective-J - Objective-J is a new programming language based on Objective-C. It is a superset of JavaScript, which means that any valid JavaScript code is also valid Objective-J code. Anyone familiar with JavaScript and object-oriented programming concepts, classical inheritance in particular, should have no difficulty learning Objective-J. Familiarity with Objective-C will be helpful, but it is not required.\n• ObjectScript - ObjectScript is a general purpose object-oriented programming language. It is designed to be simple to learn, easy to use, yet still powerful, combining the convenience of an interactive interpreter with many of the features of Java:\n• OCaml - A general-purpose, industrial-strength programming language with an emphasis on expressiveness and safety. OCaml is a multi-paradigm programming language which extends the Caml dialect of ML with object-oriented features.\n• Ode - Ode is a stack-based, concatenative, functional programming language ..., with an interactive online development environment written in JavaScript. Ode is inspired primarily by the Joy programming language, which Ode aims to implement fully. You might even think of this language as an 'Ode to Joy'...\n• Odin - The Odin programming language is designed with the intent of creating an alternative to C.\n• Oil - Oil is a new Unix shell. It's our upgrade path from bash to a better language and runtime.\n• Okta - Okta is a new open source, general-purpose programming language that, although it's still in its childhood, aims to provide a simple platform to create low level, efficient software.\n• One - It is an open source, self-hosted, bootstrapping system programming language which makes it easy to build reliable and efficient software. One is a programming language that makes it easy to build reliable, efficient and performant software. [system]\n• OpenComal - OpenComal is a portable and free implementation of the Comal programming language written by moi. Currently supported platforms are Unix, MsDos and Win32 (95, 98, NT, 2000, XP and whatever they come up with next :-) Comal is a crossover between Basic and Pascal, with the best features of both and none of the drawbacks of either.\n• OpenXION - XION is an xTalk language similar to the ones used by HyperCard, SuperCard, and Runtime Revolution. OpenXION (OH-pen-EK-shun) is the reference implementation of the XION scripting language, an open standard.\n• OpenZz - OpenZz is an interpreted dynamic parser which is well suited to rapid development of parsing solutions, starting from rapid language prototyping to full fledged compilers. OpenZz is a dynamic LALR(1) parser which allows its grammar to be modified and extended by commands written in its own language as well as through functionality provided by external libraries. OpenZz is implemented as a C library and exports C-bindings, so it can be joined with other code libraries both by static linking and runtime module loading. OpenZz is being developed by the INFN for use in the compilation chain of the APE(\"ah-pei\") series of highly parallel processing computers. APE systems are developed for performing LQCD physics research.\n• OverScript - OverScript is a simple and powerful C-like statically-typed language written in C# and is great for both embedding in .NET programs and building standalone applications. The project was developed from scratch without looking back at traditional approaches to creating languages. The unique approach allows the language to go beyond the standard features and have great potential for improvement.\n• Ox - Ox is an object-oriented statistical system. At its core is a powerful matrix language, which is complemented by a comprehensive statistical library. Among the special features of Ox are its speed, well-designed syntax and editor, and graphical facilities. Ox can read and write many data formats, including spreadsheets and OxMetrics files; Ox can run most econometric Gausstm programs. Ox comes in two versions: Ox Professional and Ox Console. Ox is available for Windows, Linux, Mac (macOS), and several Unix platforms.\n• OxygenBasic - BASIC compiler. Run programs directly, or compile to 32/64 bit binary. Supports C headers and assembly code. Supports Unicode source scripts.\n• Oz - Oz is a multiparadigm programming language, developed in the Programming Systems Lab at Université catholique de Louvain, for programming language education. It has a canonical textbook: Concepts, Techniques, and Models of Computer Programming.\n• P - A state machine based programming language for formally modeling and specifying complex distributed systems.\n• PAIP - PAIP (pipe) is a universal filter application. It uses plugins to transmit and convert data. They can be nested, so the inner structures can become quite complex (non-linear). The command-line interface is similar to a programming language and very easy.\n• Parable - Parable is a small language, built over a compact byte coded virtual machine. The language uses a concatenative model with a strictly reverse polish notation, type awareness, and garbage collection. The syntax draws from earlier work on Toka and Retro, making extensive use of anonymous, nestable functions (called quotations) for function definition and control structures. The language also depends heavily on prefixes to help the compiler decide how to handle tokens. (These are a lot like colors in ColorForth, but are represented as single characters rather than color or stylistic elements).\n• Pascal Script - Pascal Script is an Object Pascal/Delphi/Lazarus-compatible interpreter with bytecode compiler that delivers a scripting environment for application programs.\n• PascalABCNet - PascalABC.NET is the new generation Pascal programming language that combines simplicity of classic Pascal, a great number of modern extensions and broad capabilities of Microsoft .NET Framework. It's ree, simple and powerful IDE. Built-in form designer for rapid development of Windows desktop applications.\n• Passerine - A small extensible programming language designed for concise expression with little code. Passerine is a small, concise, extensible functional scripting language, powered by a VM written in Rust.\n• PaxScript - paxScript is an interpreter of 4 object-oriented scripting languages: paxBasic, paxC, paxPascal and paxJavaScript\n• All pax-languages support such concepts of the modern programming as namespaces, nested classes, inheritance, static(shared) members, indexed properties, default parameters, overloaded routines, operator overloading, delegates, exception handling, regular expressions, conditional compilation. If you know VB.NET, C# or Object Pascal, you are already familiar with paxScript. (more...)\n• Cross-language integration. For example, you can use modules written in paxBasic and paxC in your paxPascal scripts and vice versa.\n• Direct calling dll-defined routines. All calling conventions register, pascal, cdecl, stdcall, safecall are supported. (See demo.)\n• Peachpie - PeachPie is a modern PHP compiler based on the Microsoft Roslyn compiler platform and drawing from our popular Phalanger project. It allows PHP to be executed within the .NET framework, thereby opening the door for PHP developers into the world of .NET - and vice versa.\n• Peregrine - You can consider it to be a dialect of python which compiles to clean C++. It will have no garbage collector because it is a system programming language.You can consider it to be a dialect of python which compiles to clean C++. It will have no garbage collector because it is a system programming language.\n• Peridot - An experimental language for exploring the applications of two level type theory to high-performance functional programming\n• Peter - Gemtree Peter is a visual programming tool designed for a simple and fast generation of the programs for Windows 95/98/NT/ME/2000/XP/Vista. Its principal characteristic is the graphical presentation of the program structure. The program sections are assembled using the mouse like a jigsaw puzzle. Thanks to the justification check of the element combinations, carried out already at the time of the program generation, there is no chance of syntactic failure origination. The program presentation by means of a tree structure enables a considerable improvement of the program lucidity. The creation of the program is quickly becoming extraordinary easy and flexible.\n• Pharo - Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).\n• Phix - Phix is a self-hosted hybrid interpreter/compiler, developed by Pete Lomax. It is very easy to use, and similar to Euphoria.\n• Piccola - Piccola is a small, pure language for building applications from software components. Piccola is small in the sense that its syntax is tiny, and it is pure in the sense that it provides only compositional features — computation is performed entirely by components of the host programming language. The semantics of Piccola is defined in terms of a process calculus, an extension of Milner's pi calculus in which values communicated are forms, rather than tuples. A \"form\" is essentially an extensible nested record which also serves as a namespace in which expressions may be evaluated. This simple mechanism is responsible for much of the expressive power of Piccola.\n• Pico - Pico is a tiny but expressive programming language that was especially designed to teach advance computer science concepts to students in other sciences than computer science (such as Physics and Chemistry). In a sense, Pico can be seen as a non-trivial marriage between the power of languages like Scheme, and, the standard infix notation students are used to from ordinary calculus. A.o., Pico features garbage collected tables (i.e. arrays), higher order functions, objects, meta programming and reflection. But above all, Pico is small! Really small!\n• PicoLisp - PicoLisp is a programming language, a dialect of the language Lisp. Its most prominent features are simplicity and minimalism. It is built on one internal data type: a cell. On the language level, a programmer can use three different data types (numbers, symbols, and lists) being represented by cells and differentiated by bits at the end of the cell.\n• Pict - Pict, a concurrent programming language based on the pi-calculus. Pict is a language in the ML tradition, formed by adding a layer of convenient syntactic sugar and a static type system to a tiny core. The current release includes a Pict-to-C compiler, reference manual, language tutorial, numerous libraries, and example programs. The core language - an asynchronous variant of Milner, Parrow, and Walker's pi-calculus - has been used as a theoretical foundation for a broad class of concurrent computations. The goal in Pict is to identify high-level idioms that arise naturally when these primitives are used to build working programs - idioms such as basic data structures, protocols for returning results, higher-order programming, selective communication, and concurrent objects. The type system integrates a number of features found in recent work on theoretical foundations for typed object-oriented languages: higher-order polymorphism, simple recursive types, subtyping, and a powerful partial type inference algorithm.\n• Pihta - a compiled programming language whose purpose is to give the programmer complete control over the environment of his work.\n• Pikt - Pikt is a pixel-based, Turing complete esoteric programming language that generates fast and lightweight programs out of aesthetically pleasant image sources. Indeed, Pikt's most interesting feature is flexibility: every keyword, statement, function, operator and so on is linked to one - or more - color, which can be easily customized via color schemes.\n• PILL - PILL is a scripting language for applications. The syntax (based on functional languages) might look weird but it have some advantages. It contains only a minimal set of functions, applications will have to register new ones via the interpreter's API in order to make it to replay the scripts as wanted. This abstraction offers a flexible way to expand scripts abilities to virtually any domain and to allow various applications to share/re-use foreign scripts.\n• Pinafore - Pinafore is a language that allows you to structure information and create user interfaces for it. Currently it's at the \"proof of concept\" stage. You can build it from source and run it.\n• Pinecone - Pinecone is a brand new, easy to learn, general purpose, multi-paradigm, high performance programming language created by Sophie Winter. Work on the language began on October 4th, 2016. Pinecone can now be interpreted or transpiled to C++. The language is written from scratch (it includes an integrated lexer, parser and interpreter, etc.).\n• Pizza - The Pizza language is an extension to Java with three new features:\n• Class cases and pattern matching (aka Algebraic types) Furthermore you can use the Pizza compiler embedded into other applications.\n• Plato - Plato is an efficient and (hopefully!) fun programming language inspired by JavaScript, TypeScript, C#, and Haskell. Plato is designed to be easy to teach and learn while being efficient and robust enough for professional coding, particularly in the realm of 3D graphics. Plato is a statically typed functional language that looks and behaves in many ways like an object-oriented scripting language, but with a lot less complexity.\n• PLC - PLC is a simple, powerful way to add custom scripting to any program. A basic C parser and interpreter is included, and new scripting languages can be designed easily.\n• Plutus - Plutus Core is the scripting language embedded in the Cardano ledger and forms the basis of the Plutus Platform, an application development platform for developing distributed applications using the Cardano blockchain.\n• Pocketlang - A lightweight, fast embeddable scripting language. Pocketlang is a small (~3000 semicolons) and fast functional language written in C. It's syntactically similar to Ruby and it can be learned within 15 minutes. Including the compiler, bytecode VM and runtime, it's a standalone executable with zero external dependencies just as it's self descriptive name. The pocketlang VM can be embedded in another hosting program very easily.\n• Polyglot - Experiment with PHP+C polyglot snippets and a transpiler written in OCaml.\n• Polyglot - Polyglot is a highly extensible compiler front end for the Java programming language. It is implemented as a Java class framework using design patterns to promote extensibility. Using Polyglot, language extensions can be implemented without duplicating code from the framework itself. Polyglot has been used to implement domain-specific languages, to explore language design ideas, to simplify Java for pedagogical purposes, and for various code transformations such as optimization and fault injection.\n• Polylang - TypeScript-like language that compiles to zero knowledge computation.\n• Pony - Pony is a compiled, actor-model, capabilities-secure, high performance programming language that prevents concurrency mistakes such as data races and deadlocks by design with reasonable syntactic defaults. Its FFI allows Pony to interface with other languages.\n• Power Fx - Microsoft Power Fx is a low-code general purpose programming language based on spreadsheet-like formulas. It is a strongly typed, declarative, and functional language, with imperative logic and state management available as needed.\n• POWER-KI - POWER-KI allows HYBRID PROGRAMMING, i.e. the development of applications with components created with different languages in a single package, making the most of each of them. In fact from POWER-KI it is possible to directly execute PyThon code, C / C ++ code using WRAP and javascript in the Web User Interface. In this way, for example, it is possible to create applications based on Python code that take advantage of the POWER-KI Native Cloud for the user interface or create C / C ++ functions for maximum performance.\n• PowerMops - A full featured, stand-alone development environment for programming the Macintosh written by Mike Hore.\n• Preql - Preql is an interpreted, relational programming language, that specializes in database queries and compiles to SQL.\n• Priml - Priml is a stack-oriented scripting language based on Forth and BASIC.\n• Processing - Processing is a flexible software sketchbook and a language for learning how to code. Since 2001, Processing has promoted software literacy within the visual arts and visual literacy within technology. There are tens of thousands of students, artists, designers, researchers, and hobbyists who use Processing for learning and prototyping.\n• Prompto - The full stack language hosted in the cloud. Prompto frees you from time consuming tasks and lets you focus on making visible differences: creative web pages, meaningful data models and relevant business logic.\n• Prose - In distributed computing environments, getting software components to integrate and communicate with each other can involve large teams of developers, and involve significant amounts of time and money. Such projects can be very difficult to manage. PROSE is designed from the ground-up to address these challenges with a range of innovative features that are unique to the language. It consists of:\n• An execution engine, which interprets the bytecode\n• A hierarchical object tree through which all components are addressed\n• Prowl - The Prowl Language is a statically-typed stack-based programming language that draws from a wide range of inspirations, mainly functional, logic, and stack-based languages. However, the language is unique with its powerful program combinator system. Prowl exploits a homomorphism between string concatenation and concatenative languages that allows regex to be used as a computational and mental model for control flow. This model provides a rigid framework to solve combinatory and constraint problems (in addition to general purpose programming) yet retains performant translations into DFAs due to the regex base. With stacks for data and regex for control flow, Prowl provides a unique but ergonomic way to think about hard problems.\n• Pure - Pure is a modern-style functional programming language based on term rewriting. It offers equational definitions with pattern matching, full symbolic rewriting capabilities, dynamic typing, eager and lazy evaluation, lexical closures, built-in list and matrix support and an easy-to-use C interface.\n• Pure Data - Pure Data (or just \"Pd\") is an open source visual programming language for multimedia. Pure Data is developed by Miller Puckette since 1996 and you can find it on his official website along with the official documentation and other related resources.\n• PureBasic - PureBasic is a modern BASIC programming language. The key features of PureBasic are portability (Windows, Linux, OS X and Raspberry supported with the same source code), the production of very fast and optimized native 32-bit or 64-bit executables and, of course, the very simple BASIC language syntax. PureBasic has been created for the beginner and expert alike. We have put a lot of effort into its conception to produce a fast, reliable system and friendly BASIC compiler.\n• PXP - A superset of PHP with extended syntax and runtime capabilities.\n• Pycopy - Pycopy - a minimalist and memory-efficient Python dialect. Good for desktop, cloud, constrained systems, microcontrollers, and just everything.\n• Pyret - Pyret is a programming language designed to serve as an outstanding choice for programming education while exploring the confluence of scripting and functional programming. It's under active design and development, and free to use or modify.\n• Pyretic - Python + Frenetic = Pyretic. Pyretic is one member of the Frenetic family of SDN programming languages. As such Pyretic enables network programmers and operators to write succinct modular network applications by providing powerful abstractions. Pyretic is both a programmer-friendly domain-specific language embedded in Python and the runtime system that implements programs written in the Pyretic language on network switches.\n• Q - Q is an interpreted, dynamically typed functional programming language based on term rewriting which allows you to define functions using symbolic equations. It works on (32 bit) Linux, OS X, Unix and Windows, and comes with a bunch of useful libraries which turn it into a practical programming tool. The Q programming system is free software distributed under the GPL.\n• Qi - Lightweight and fast programming language designed to be written in Chinese.\n• Qogo - This application was developed to teach 5 to 10 year olds the principles of programming via the venerable \"Turtle Graphics\" paradigm. It is written in TCL so it runs on all computer platforms. It features a full IDE with undo support and interactive construction as well as being able to save newly created commands as new instructions.\n• Quick Macros - Quick Macros - automation software for Windows 7/8/10/11. Some features:\n• Captures, finds and clicks web page objects, other UI objects, on-screen images and text.\n• You can create programs for various purposes. Run in Quick Macros or as exe files.\n• Quorum - Quorum is a general purpose programming language designed for several purposes. First, we regularly run experiments with people at various age and experience ranges, investigating ways to make the language easier to use. Evidence gathered from these studies is filtered back into the design, making quorum an \"evidence-based\" programming language. Second, as our team is interested in issues of equity for all people, perhaps especially people with disabilities, we are careful to design libraries that are friendly to the broad population. This means many internal libraries in the language have support for accessibility.\n• R3 - R3 is a Colorforth like laneguage, a FORTH dialect, R3 is a 64 bits, very small dictionary and simple working, strong typed, many version for windows/linux/mac and raspberry pi.\n• R4 - R4 is a Colorforth like laneguage, a FORTH dialect, R4 is 32bits, very small dictionary and simple working, strong typed, many version for windows/linux/mac and raspberry pi.\n• Racket - A general-purpose, multi-paradigm programming language and a multi-platform distribution that includes the Racket language, compiler, large standard library, IDE, development tools, and a set of additional languages including Typed Racket (a sister language of Racket with a static type-checker), Swindle, FrTime, Lazy Racket, R5RS & R6RS Scheme, Scribble, Datalog, Racklog, Algol 60 and several teaching languages.\n• Radish - Radish is an easy-to-learn, object-oriented programming language written in C#. If you know JavaScript, you know Radish.\n• Ragel - Ragel compiles executable finite state machines from regular languages. Ragel targets C, C++ and ASM. Ragel state machines can not only recognize byte sequences as regular expression machines do, but can also execute code at arbitrary points in the recognition of a regular language. Code embedding is done using inline operators that do not disrupt the regular language syntax.\n• Raku - A member of the Perl family of programming languages. Formerly known as Perl 6, it was renamed in October 2019. Raku introduces elements of many modern and historical languages. Compatibility with Perl was not a goal, though a compatibility mode is part of the specification.\n• RascalMpl - Rascal Metaprogramming Language. Rascal is a programming language; such that meta programs can be created by, understood by, and debugged by programmers. Rascal primitives include immutable data, context-free grammars and algebraic data-types, relations, relational calculus operators, advanced patterns matching, generic type-safe traversal, comprehensions, concrete syntax for objects, lexically scoped backtracking, and string templates for code generation. It has libraries for integrating language front-ends, for reusing analysis algorithms, for getting typed meta-data out of version management systems, for interactive visualization, etc.\n• Ravi - Ravi is a dialect of Lua with limited optional static typing and features a JIT compiler powered by MIR as well as support for AOT compilation to native code.\n• Red - Red is a next-generation programming language strongly inspired by Rebol, but with a broader field of usage thanks to its native-code compiler, from system programming to high-level scripting and cross-platform reactive GUI, while providing modern support for concurrency, all in a zero-install, zero-config, single 1MB file!\n• Renjin - JVM-based interpreter for the R language for the statistical analysis. The primary goals of the project are to provide a modern interpreter that serves as a drop-in replacement for GNU R, but is easier to integrate with other systems, offers better performance, and is more extensible.\n• Req - A simple and opinionated HTTP scripting language. It is designed for easily making HTTP requests, and working with their responses. Below is an example that calls out to the GitHub API and displays the user making the call.\n• ReScript - ReScript compiler and syntax provide the best experience to write JS and React applications. Unifying the tools in one coherent platform and core team allows us to build features that wouldn't be possible in the original BuckleScript + Reason setup.\n• Restructor - Restructor is a system / algorithm to automatically refactor entire code-bases down to their least-redundant form (normal form). It’s a research project I worked on 2005-2010.\n• Retro - RETRO is a clean, elegant, and pragmatic dialect of Forth. It provides a simple alternative for those willing to make a break from legacy systems. The language draws influences from many sources including traditional Forth systems, cmForth, colorForth, Factor, and Parable. It was designed to be easy to grasp and adapt to specific uses. The basic language is very portable. It runs on a tiny virtual machine (Nga), which is written in C. There are multiple interface options, the main one (rre) is buildable with just the standard C compiler and libraries on most systems.\n• Rewrite - Rewrite is estimated to be a Turing complete, s-expression based term rewriting system. Its original intention is operating over s-expressions to expand asserted template occurrences while aiming to be intuitive enough to introduce code templating to non-technical users. To try Rewrite within browser, please refer to Rewrite Playground.\n• Rexx - Rexx is a structured, high-level programming language designed for ease of learning and reading. It was developed at IBM by Mike Cowlishaw. Rexx is a full language that can be used as a scripting, macro language, and application development language. It is often used for processing data and text and generating reports. Rexx is the primary scripting language in some operating systems, e.g. OS/2, MVS, VM, AmigaOS, and is also used as an internal macro language in some other software, such as SPF/PC, KEDIT, THE and the ZOC terminal emulator. Additionally, the Rexx language can be used for scripting and macros in any program that uses Windows Scripting Host ActiveX scripting engines languages (e.g. VBScript and JScript) if one of the Rexx engines is installed.\n• Rhovas - Rhovas is a programming language for API design and enforcement. Using Rhovas, developers can better express the contracts and intention of their code to help create correct, maintainable software.\n• Ribbon - Ribbon is a dynamic interpreted programming language. It's inspired by the likes of Python, Javascript and a little bit of Lua.\n• Rickroll lang - A light meme based, process oriented, dynamic, strong, esoteric programming language. All of the keywords/statements are came from Rick Astley's lyrics. I believe that rick roll is not only a way to promote people's communication, it is also one of the most paramount art in the human history. The purpose of the Rickroll Language is to introduce this art to people in a distinctive way - programming.\n• Ring - Simple and flexible programming language for applications development. Ring is a practical general-purpose multi-paradigm language. The supported programming paradigms are Imperative, Procedural, Object-Oriented, Functional, Metaprogramming, Declarative programming using nested structures, and Natural programming. The language is portable (MS-DOS, Windows, Linux, macOS, Android, WebAssembly, etc.) and can be used to create Console, GUI, Web, Games, and Mobile applications. The language is designed to be Simple, Small, and Flexible.\n• Rio - A script-feeling, safe, naturally compatible replacement for C, with no runtime nor std lib of its own.\n• Robin - Robin is a functional programming language with eager evaluation, latent typing, and a homoiconic syntax (see Scheme), based on a radically simple core semantics (see Pixley) in which both functions and macros are defined in terms of a more basic abstraction, the fexpr. Expressions in Robin are referentially transparent; programs interact with the outside world through an event-oriented framework.\n• Rock - Little language made with Rust and LLVM. Aim to follow the enforced safeness of the Rust model with a borrow checker (SoonT) and achieve high native performances thanks to LLVM. Rock is highly inspired from Livescript and Rust, and will also borrow (pun intended) some features from Crystal, from functional languages like Haskell, and even from Rust itself.\n• Roman II - Roman II is a dynamic programming language with a naive mark and sweep garbage collector, all written from the ground up in about 5000 lines of the GNU11 dialect of C.\n• Rowlang - RowLang is a minimalistic esoteric programming language written as an analogy to rowing.\n• RPL/2 - Reverse Polish Lisp/2 release 4.1.31, half-compiled high-level language using shared libaries and mainly aiming at scientific calculations and complex algorithms\n• Rune - The Rune Language, an embeddable dynamic programming language for Rust.\n• RustScript - RustScript is a functional scripting language with as much relation to Rust as Javascript has to Java.\n• SaC - Single-Assignment C is an array programming language predominantly suited for application areas such as numerically intensive applications and signal processing. Its distinctive feature is that it combines high-level program specifications with runtime efficiency similar to that of hand-optimized low-level specifications. Key to the optimization process that facilitates these runtimes is the underlying functional model which also constitutes the basis for implicit parallelisation. This makes SAC ideally suited for harnessing the full potential of a wide variety of modern architectures ranging from a few symmetric cores with shared memory to massively parallel systems that host heterogeneous components including GPUs and FPGAs.\n• SATySFi - SATySFi (pronounced in the same way as the verb “satisfy” in English) is a new typesetting system equipped with a statically-typed, functional programming language. It consists mainly of two “layers” ― the text layer and the program layer. The former is for writing documents in LaTeX-like syntax. The latter, which has OCaml-like syntax, is for defining functions and commands. SATySFi enables you to write documents markuped with flexible commands of your own making. In addition, its informative type error reporting will be a good help to your writing.\n• Scheme - Scheme is a dialect of the Lisp family of programming languages. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimization, giving stronger support for functional programming and associated techniques such as recursive algorithms. It was also one of the first programming languages to support first-class continuations.\n• Seed7 - Seed7 is a higher level language compared to Ada, C++ and Java.\n• Self - Self is a prototype-based dynamic object-oriented programming language, environment, and virtual machine centered around the principles of simplicity, uniformity, concreteness, and liveness.\n• Senegal - Senegal is a powerful, small-but-fast, concurrent, class-based, and dynamically-typed programming language with a modern syntax.\n• SheerPower - Sheerpower is a next generation database and scripting language for Windows. It is supported on Windows 10, 11, and Windows Server 2016 and above.\n• Shiika - Shiika is a statically-typed programming language that makes me most productive.\n• Easy to write like Ruby or Python;\n• Object-oriented but has enums and pattern-matching;\n• Written in Rust, compiles to single binary via LLVM IR.\n• SimpleScript - SimpleScript is a simple programming tool for scripting languages (Perl, PHP, Python, Ruby, TCL) written in Obj-C/Cocoa. It can be used by experienced developers to write and test on the fly small routines, and is a good solution for educational purposes. Do not use it in production environments or to manage large projects.\n• Simula - This is a new Simula System created by the Open Source Project 'Portable Simula Revisited'. The project was initiated as a response to the lecture held by James Gosling at the 50th anniversary of Simula in Oslo on 27th September, 2017. This Simula System is written in Java and compiles to pure Java code with one exception, the Goto Statement need to be corrected in the byte code, which is done automatically.\n• Sirius - Sirius is a general-purpose programming language which could best be described as a cross between Pascal and BASIC, although that may be misleading. Syntactically, it is similar to Pascal. Functionally, it resembles languages such as VAX BASIC and Borland's Delphi. Conceptually, it is like C in some respects: minimal keywords, access to low-level programming, etc. But the main idea behind Sirius is simply a programming tool which reduces the amount of time required to write applications. For instance, the language has all of the common data types built-in, so that you don't have to reinvent the wheel for linked lists, binary trees, queues, stacks, and the like. It also allows static strings and dynamic strings with automatic garbage collection.\n• SISC - SISC is an extensible Java based interpreter of the algorithmic language Scheme. SISC uses modern interpretation techniques, and handily outperforms all existing JVM interpreters (often by more than an order of magnitude).\n• Slang - Statically typed scripting language... syntax errors should be catched at design time!\n• Slang - S-Lang is a multi-platform programmer's library designed to allow a developer to create robust multi-platform software. It provides facilities required by interactive applications such as display/screen management, keyboard input, keymaps, and so on. The most exciting feature of the library is the slang interpreter that may be easily embedded into a program to make it extensible. While the emphasis has always been on the embedded nature of the interpreter, it may also be used in a stand-alone fashion through the use of slsh, which is part of the S-Lang distribution.\n• SMAL - The machine independant SMAL assembler and linker supports conditional and macro assembly and all linkage editing operations commonly associated with languages such as FORTRAN and C. It comes with a user's manual that also explains how to customize it to support a variety of machine instruction sets.\n• SmallBASIC - SmallBASIC is a fast and easy to learn BASIC language interpreter ideal for everyday calculations, scripts and prototypes. SmallBASIC includes trigonometric, matrices and algebra functions, a built in IDE, a powerful string library, system, sound, and graphic commands along with structured programming syntax.\n• Solidity - Solidity is an object-oriented programming language for implementing smart contracts on various blockchain platforms, most notably, Ethereum.\n• Soul - Soul is an esoteric concatenative one-stack language, a small explorative language with an interpreter written in a day. Most concatenative languages work on a state, often that's another stack. For example, Forth has a data and return stack and Postscript has an extra stack outputting to a page. Soul is a minimalist language that provides one thing, and one thing only, the one sole stack.\n• SOUL - The SOUL language is a small, carefully crafted DSL for writing real-time DSP code. Its design goals are to be fast, secure, safe, and simple for even beginners to learn. The SOUL runtime is a collection of tools and technologies for running SOUL code with very high efficiency, on heterogeneous CPUs and DSPs, both locally and remotely.\n• sparcl - Sparcl: A Language for Partially-Invertible Computation. This is an implementation of a system presented in the paper: Kazutaka Matsuda and Meng Wang: Sparcl: A Language for Partially-Invertible Computation, ICFP 2020.\n• SPARK - SPARK stands for the Scanning, Parsing, and Rewriting Kit. It formerly had no name, and was referred to as the \"little language framework.\" The first version (circa 1998) was described in the paper Little Languages in Python at the 7th International Python Conference.\n• Sphinx - Sphinx is a dynamically typed programming language that is inspired by Lua and Python, and implemented entirely in Rust!\n• SpiderBasic - SpiderBasic is new web client-side programming language based on established BASIC rules. Its allows development of very complex, windowed based web applications, including mobile app for iOS and Android. It provides a large commandset to handle complex and reactive GUI, 2D games, and many more in a coherent manner. Every library and commands behave the same and have similar syntax for easier and faster learning.\n• SpécialK - SpécialK, an anaesthetizing algorithmic language. The SpécialK language is a logical and functionnal language similar to Erlang, and used in 2nd year of CS at the university of Nice in algorithmics course of E.Kounalis. SpécialK is a SpécialK to Scheme compiler.\n• Squilu - A scripting language that accepts a subset of javascript and C/C++.\n• Squirrel - Squirrel is a high level imperative, object-oriented programming language, designed to be a light-weight scripting language that fits in the size, memory bandwidth, and real-time requirements of applications like video games.\n• SR - SR (Synchronizing Resources) is a language for writing concurrent programs. The main language constructs are resources and operations. Resources encapsulate processes and variables they share; operations provide the primary mechanism for process interaction. SR provides a novel integration of the mechanisms for invoking and servicing operations. Consequently, all of local and remote procedure call, rendezvous, message passing, dynamic process creation, multicast, and semaphores are supported. SR also supports shared global variables and operations.\n• Stacksmith - An intuitive software erector kit targeted at people new to programming, but with enough potential to stay useful once they've learned, inspired by HyperCard.\n• Stan - Stan is a state-of-the-art platform for statistical modeling and high-performance statistical computation. Many thousands of users rely on Stan for statistical modeling, data analysis, and prediction in the social, biological, and physical sciences, engineering, and business.\n• Star - An experimental programming language that's made to be powerful, productive, and predictable. One of the most important goals of Star is that it's designed to be completely consistent. In other words, Star has been designed to not have edge cases, footguns, or any sort of \"magic\" that's exclusive to language built-ins.\n• Stark - Stark is a new language and OS with the help of the .NET ecosystem and seL4 micro-kernel.\n• Starlark - Starlark (formerly known as Skylark) is a language intended for use as a configuration language. It was designed for the Bazel build system, but may be useful for other projects as well.\n• STOICAL - STOICAL is vastly different from its predecessors. Primarily because so much has changed since the decades ago that they were developed. Today STOICAL is powerful and general enough to be used as a high performance replacement for semi-compiled and interpreted languages like Perl, Python, SED and Awk. And because of STOICAL's advanced support for networking and concurrent threads of execution, it can be used to write efficient long-running servers and daemons that would normally need to be written in C. The intent here is not to explore the intricacies of archaic systems, but to create a new and modern language, well suited to the world as it exists today. STOICAL might therefore be more accurately represented by the recursive acronym SINS, SINS Is Not STOIC, but this word has a remarkable stigma attached to it ;-)\n• Strand - \"Strand\" is an open-source implementation of the identically named parallel Prolog dialect as described in the book \"Strand: New Concepts for Parallel Programming\" by Ian Foster and Stephen Taylor. Strand represents a very elegant and concise notation for expressing concurrent and distributed algorithms using only a small number of fundamental language constructs and a very simple execution model.\n• Streem - Streem is a stream based concurrent scripting language. It is based on a programming model similar to the shell, with influences from Ruby, Erlang, and other functional programming languages.\n• Strictly False - I have designed an eccentric programming language (Strictly False) an extension of Wouter van Oortmerssen's elegant False programming language. ... to run my interpreter (and my language is definitely more powerful), you need Moscow ML.\n• Stroscot - Stroscot is an imperative programming language designed for modern processors.\n• Stroyent - Stroyent is an infix, procedural systems programming language targeting MakoVM. Stroyent syntax superficially resembles that of C, but there are many important differences in the semantics of these languages.\n• SubC - SubC is a fast and simple public domain compiler for a clean subset of the C programming language. It can compile itself and passes gcc -Wall -pedantic.\n• Suneido - Suneido™ is a complete, integrated application platform – a system for developing and deploying applications without the frustrations of integrating multiple different products. Suneido incorporates an object-oriented programming language, client-server relational database software, and application frameworks and components. It includes the integrated development environment (IDE) used to create applications as well as the client and server required to run applications across networks. Suneido is Open Source – it is provided free, with complete source code.\n• Superx++ - Superx++ is an object-oriented language that is entirely based on XML's syntactical structure. Superx++ conforms with the XML version 1.0 specification as published on the W3C web site. Programming in XML itself has great potential and Superx++ pushes the envelope!\n• Sylvan - A general-purpose programming language that aspires to have support for attribute grammars, managed effects, and efficient pure functional programming.\n• T3X - T3X is a small, portable, procedural, block-structured, recursive, almost typeless, and to some degree object-oriented programming language. Its syntax is similar to Pascal, its semantics resembles BCPL's.\n• T3XFORTH - T3XFORTH is an old-school, plain vanilla FORTH system that is mostly compatible to FORTH-79 with some parts borrowed from FIG FORTH, FORTH-83, and EFORTH, and taking some inspiration from Leo Brodie's (classic, 1983) book, \"Starting FORTH\". T3XFORTH runs on 8086 processors under DOS on an IBM PC, or stand-alone using the PC BIOS. It can also run on 32-bit Unix systems using a T3XFORTH VM emulator.\n• Taichi - Productive & portable high-performance programming in Python. Taichi Lang is an open-source, imperative, parallel programming language for high-performance numerical computation. It is embedded in Python and uses just-in-time (JIT) compiler frameworks, for example LLVM, to offload the compute-intensive Python code to the native GPU or CPU instructions.\n• Tamgu(탐구) - A FIL Language that combines in one language an imperative paradigm, a functional paradigm and a logical paradigm. Mixes in one code A Python-like formalism, a Haskell-like formalism and a Prolog-like formalism.\n• Tamsin - Tamsin is an oddball little language that can't decide if it's a meta-language, a programming language, or a rubbish lister. Its primary goal is to allow the rapid development of parsers, static analyzers, interpreters, and compilers, and to allow them to be expressed compactly. Golf your grammar! (Or write it like a decent human being, if you must.)\n• Tandem - Tandem is an experimental rewriting language where the rewrite rules form a Kleene algebra. The object being rewritten by a Tandem program is a collection of labelled stacks -- a finite mapping from strings to strings. The strings are always rewritten at the left edge, so they are effectively stacks. A Tandem program consists of a single rewrite rule along with zero or more pragmas. The rewrite rule is applied to an initial state to possibly obtain a final state. This rule is applied only once. However, in Tandem, a rule is a composite object which may contain subrules that get applied many times.\n• Tao - A statically-typed functional language with polymorphism, typeclasses, sum types, pattern-matching, first-class functions, currying, good diagnostics, and much more!\n• Tao3D - Tao3D is a dynamic document description language designed specifically for real-time 3D animations. It can be used to present complex information in an entertaining and interactive way.\n• Tcl - Tcl is a high-level, general-purpose, interpreted, dynamic programming language. Tcl supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It is commonly used embedded into C applications for rapid prototyping, scripted applications, GUIs, and testing.\n• Terra - Terra is a low-level system programming language that is embedded in and meta-programmed by the Lua programming language\n• ThinBasic - Very fast \"BASIC like\" programming language useful to Beginners and to Gurus. BASIC interpreter for Windows able to create console and gui applications with most of the user interface controls, automate process, automate data exchange, connect to databases, send mails, connect to ftp sites, rest api, parsing strings, tokenizing, traversing xml, handling files, Windows Registry, OpenGl, graphics, sound, printing ... and much more.\n• Thistle - Thistle is a programming language and compiler, suitable for introductory programming instruction. It creates a single file, compiled executable application. Thistle comes with a code editor, helpfile, sample code, and the FASM assembler. There are two versions of Thistle. Thistle creates a console application. Thistle-Win creates a Windows application.\n• Timid - A small programming language that made to be able to quickly solve problems like tedious math homework in as little time as possible (as in runtime). Also, it's possible to compile code once, and run anywhere using the Timid Runtime.\n• Tint - Tint is a string substition language; it is intended to be used as an extention language. Tint Emacs is an emacs clone for Win32, Mac OS X, Darwin, and Linux. It uses Tint as its extension language.\n• Tinymoe - English-like programming language, for DSL (Domain Specific Language) building and embedding, with dynamic typing, multiple dispatching and build-in continuation.\n• Toka - Toka is a concatenative programming language related to Forth. It should be easy to learn, extend, and use. Development is ongoing, and updates occur almost daily. The language is not compatible with any known existing Forth implementation, although some Forth code can be ported to Toka. Among the provided features are a memory allocator with basic garbage collection, dynamic allocations for functions and data, a decompiler, and a basic FFI. The implementation was designed to be easily portable between Unix-like systems\n• Tokay - Tokay is a programming language to quickly implement solutions for text processing problems. This can either be just simple data extractions, but also parsing entire structures or parts of it, and turning information into structured parse trees or abstract syntax trees for further processing. Therefore, Tokay is both a tool and language for simple one-liners, but can also be used to implement code-analyzers, refactoring tools, interpreters, compilers or transpilers. Actually Tokay's own language parser is implemented in Tokay itself.\n• ToonTalk - ToonTalk is an interpreter for a concurrent constraint programming language. Concurrent constraint programming is a synthesis of concurrent logic programming and constraint logic programming. (See, for example, Saraswat). The class of languages for which programs are roughly interchangeable with ToonTalk programs include Oz, E-Lang, Janus, Flat Guarded Horn Clauses, KL1/KLIC, Flat Concurrent Prolog, Parlog, and Strand. The syntax of all these languages is textual while ToonTalk has an action-oriented video game animation syntax. The programming environment is completely different as well. In ToonTalk, the process of constructing, testing, and debugging programs closely resembles playing a video game. \"From Prolog and Zelda to ToonTalk\" is a paper discussing these ideas in detail.\n• Toy - Refinement types + dependent types = ❤️. A Toy proof-of-concept implementation of a language with refinement types that compiles to Idris.\n• Toy - The Toy programming language interpreter, written in C.\n• TwinBasic - TwinBasic: a modern, BASIC programming language, aiming for 100% backwards compatibility with existing VB6/VBA projects. A complete replacement development environment offering significant new features and improvements over the VB6 IDE.\n• Typst - A new markup-based typesetting system that is powerful and easy to learn.\n• Tyr - Tyr is an experimental minimalistic language. It's meant to be both a programming language and a conlang. Programmers should think of it as a speakable programming language. Conlangers should see it as a logical conlang, which can also be used for programming. To achieve this, this language has clear and simple nesting rules based on the words, but no syntax for nesting. You can write sentences without the need of indentation. Any kind of indent is not even allowed. It's still in an early stage and only supports a few math primitives. Many things will probably be changed. I'll only document the current state here.\n• Tyro - TYRO is a very high level programming language designed mainly for the beginners of the programming, to develop a thorough understanding of the fundamental concepts of languages.\n• uiua - Uiua (wee-wuh ) is a general purpose, stack-based, array-oriented programming language with a focus on simplicity, beauty, and tacit code. Uiua lets you write code that is as short as possible while remaining readable, so you can focus on problems rather than ceremony.\n• Umka - Umka is a statically typed embeddable scripting language. It combines the simplicity and flexibility needed for scripting with a compile-time protection against type errors. Its aim is to follow the Python Zen principle Explicit is better than implicit more consistently than dynamically typed languages generally do.\n• Unicon - Unicon is a very high level programming language. It runs on many operating systems including most Linux distributions, Windows, macOS, and BSD systems. It also supports most modern CPU architectures such as i386, amd64, armhf, arm64, and ppc64el.\n• Unison - Unison is a modern, statically-typed purely functional language, similar to Haskell, but with the ability to describe entire distributed systems with a single program.\n• Unit - Unit is a General Purpose Visual Programming Language and Environment built with a primary focus on Developer Experience. It is heavily inspired by Live, Data Flow, Reactive, Functional and Object Oriented Programming paradigms. Formally, units are Multi Input Multi Output (MIMO) Finite State Machines (FSM). A program in Unit is represented as a Graph.\n• Ur - Ur is a programming language in the tradition of ML and Haskell, but featuring a significantly richer type system. Ur is functional, pure, statically typed, and strict. Ur supports a powerful kind of metaprogramming based on row types.\n• Ü - Experimental programming language that is compilable, statically-typed C++-like language. It is similar to C++ or Rust. Main goal is a safety, but not with cost of verbosity. [C++ killer, Rust killer]\n• V - Simple, fast, safe, compiled language for developing maintainable software. Compiles itself in <1s with zero library dependencies.\n• V1 - V1 is a simple functional interpreter language with syntax from C, PHP and JavaScript. It was developed from the scratch. The focus is on administrative and experimental programming, but it has enhanced benefits like Multithreading, CGI, Web functions and native function calling. The most buildin functions are compatible with PHP, for example fopen().\n• Val - Val is an open source, general-purpose programming language designed around on the concept of (mutable) value semantics. The language aims to be safe and efficient, yet expressive enough to support multiple programming paradigms and implement concurrent algorithms safely and efficiently.\n• Vala - Vala is a programming language that aims to bring modern programming language features to GNOME developers without imposing any additional runtime requirements and without using a different ABI compared to applications and libraries written in C.\n• Vale - Vale is the fast, safe, and easy programming language. It uses single ownership with constraint references for memory safety without garbage collection, and an emphasis on modern, readable syntax.\n• Verona - Project Verona is a research programming language to explore the concept of concurrent ownership. We are providing a new concurrency model that seamlessly integrates ownership.\n• Verse - Verse is a programming language developed by Epic Games that you can use to create your own gameplay in Unreal Editor for Fortnite, including customizing your devices for Fortnite Creative.\n• Victim - Victim is dynamically typed interpreted scripting language written in Haskell. The name is inspired by source code of malloc.\n• Vinegar - Vinegar is a semi-concatenative language where every operation can fail.\n• Virgil - A Fast and Lightweight Programming Language. Its design blends functional and object-oriented programming paradigms for expressiveness without a lot of overhead, either syntactically or at runtime. Its implementation is focused primarily on static compilation to produce native executables that are standalone. It is well-suited to writing small and fast programs. That makes it ideal for building certain kinds of programs like compilers and virtual machines. It is currently being used for virtual machine and programming language research.\n• Visula - Visula is a general-purpose visual programming language (VPL) based on object-orientation. Visula programs are diagrams that are edited in a graphical editor. Programmers don't write software - they draw it!\n• Vortex - Vortex is a language designed to explore links and relationships between entities. It heavily relies on side effects, and as such it would fall under the Dysfunctional Programming paradigm.\n• Vortex - Vortex is a language-independent optimizing compiler infrastructure for object-oriented and other high-level languages, written entirely in Cecil. It primarily operates as a whole-program optimizer, performing aggressive analyses and optimizations given the whole program. It has front-ends for Cecil, Diesel, Smalltalk, Java, C++, and Modula-3. These front-ends translate into the Vortex RTL intermediate language. Vortex produces either portable C++ code or SPARC assembly code.\n• Vox - Vox is a multiparadigm programming language inspired by D (60%), Jai (30%), and Zig (10%). Vox language compiler. AOT / JIT / Linker. Zero dependencies.\n• Wa - Wa is a general-purpose programming language designed for developing robustness and maintainability WebAssembly software. Instead of requiring complex toolchains to set up, you can simply go install it - or run it in a browser.\n• Wasp - Wasp (Web Application Specification) is a Rails-like framework for React, Node.js, and Prisma. Build your app in a day and deploy it with a single CLI command!\n• 🚀 Quick start: Due to its expressiveness, you can create and deploy a production-ready web app from scratch with very few lines of concise, consistent, declarative code.\n• 😌 No boilerplate: By abstracting away complex full-stack features, there is less boilerplate code. That means less code to maintain and understand! It also means easier upgrades.\n• 🔓 No lock-in: You can deploy the Wasp app anywhere you like. There is no lock-in into specific providers; you have full control over the code (and can actually check it out in .wasp/ dir if you are interested ).\n• Wax - A tiny programming language that transpiles to C, C++, Java, TypeScript, Python, C#, Swift, Lua and WebAssembly 🚀.\n• Well - Well lang is somewhat functional kinda stack based language. This language includes your normal things like variables, mathamatics, loops, etc. It compiles directly to assembly (NASM).\n• Wenyan - 文言文編程語言 A programming language for the ancient Chinese.\n• A packages manager wyg(文淵閣) and awesome packages from the community.\n• Whiley - Whiley employs state-of-the-art techniques for ensuring your software is correct. You can specify functions using preconditions and postconditions, and then statically verify your implementation meets its specification.\n• Wing - Winglang is a new open-source programming language designed for the cloud (aka \"cloud-oriented\"). Wing enables developers to build distributed systems that leverage cloud services as first-class citizens by combining infrastructure and application code in a safe and unified programming model (aka \"cloud-oriented\"). Wing programs can be executed locally (yes, no internet required) using a fully-functional simulator, or deployed to any cloud provider (yes, Wing programs are portable across providers).\n• WisniaLang - A compiler for an experimental programming language that produces tiny Linux binaries (ELF x86_64) without LLVM dependency!\n• Wuffs - Wuffs (Wrangling Untrusted File Formats Safely) is a memory-safe programming language (and a standard library written in that language) for wrangling untrusted file formats safely. Wrangling includes parsing, decoding and encoding. Example file formats include images, audio, video, fonts and compressed archives.\n• Wyvern - Wyvern is a new general-purpose programming language designed to support adaptation and assurance. Key features of Wyvern's evolving design include:\n• A simple object model with good support for both object-oriented and functional programming\n• Extensibility with domain-specific syntax via libraries written within the language\n• Support for various aspects of software architecture within the running system\n• X Language - X Language is a new multi-syntax programming including a portable set of APIs to create console or graphical applications runnable on many platforms (UNIX/X11, Win32, ...). X Language comes with an interpreter, a compiler and a debugger.\n• X# - X# is an open source development language for .NET, based on the xBase language. It comes in different flavours, such as Core, Visual Objects, Vulcan.NET, xBase++, Harbour, Foxpro and more. X# has been built on top of Roslyn, the open source architecture behind the current Microsoft C# and Microsoft Visual Basic compilers.\n• X10 - X10 is a statically-typed object-oriented language, extending a sequential core language with places, activities, clocks, (distributed, multi-dimensional) arrays and struct types. All these changes are motivated by the desire to use the new language for high-end, high-performance, high-productivity computing.\n• XIDEK - XIDEK provides technical guidance and source code so that you can readily design and implement an interpreter according to your own requirements. You may need, for example, to create a special interpreter for a domain specific language, script language, or other \"little language\". XIDEK can save you weeks or months of work. It gives you parsers, support modules, explanations, examples, organization and a framework upon which you can build.\n• XPL - The XPL programming language is a derivative of PL/I designed for compiler writing. XPL was first announced at the 1968 FJCC in San Francisco, CA. XPL is the name of both the programming language and the compiler generator system (or TWS: translator writing system) based on the language.\n• XSB - XSB is a Logic Programming and Deductive Database system for Unix and Windows.\n• Xtend - Xtend is a flexible and expressive dialect of Java, which compiles into readable Java 8 compatible source code. You can use any existing Java library seamlessly. The compiled output is readable and pretty-printed, and tends to run as fast as the equivalent handwritten Java code.\n• Yab - Yab | yet another Basic for HAIKU.\n• Yeti - Yeti is ML style functional programming language, that runs on the JVM.\n• Yorick - Yorick is an interpreted programming language for scientific simulations or calculations, postprocessing or steering large simulation codes, interactive scientific graphics, and reading, writing, or translating large files of numbers.\n• Yuescript - Yuescript is a Moonscript dialect. It is derived from Moonscript language 0.5.0 and continuously adopting new features to be more up to date. Moonscript is a language that compiles to Lua. Since original Moonscript has been used to write web framework lapis and run a few business web sites like itch.io and streak.club with some large code bases. The original language is getting too hard to adopt new features for those may break the stablility for existing applications.\n• Z# - Z-Sharp is a custom programming language I made because I don't like c++ very much (Z-Sharp's interpreter is written in c++ though). Z-Sharp scripts have the file extension .ZS. The base syntax and formatting I would say is quite similar to C# or Python, but differs as task complexity increases. It also has support for graphics using SDL2.\n• Zenon - Zenon is a statically typed language that compiles to C++. It offers safe and easy application development thanks to high-level features and fast compile times, while keeping C++'s performance and familiar syntax.\n• Zephir - Zephir - is a high level programming language that eases the creation and maintainability of extensions for PHP. Zephir extensions are exported to C code that can be compiled and optimized by major C compilers such as gcc/clang/vc++. Functionality is exposed to the PHP language.\n• zeptoforth - zeptoforth is a Cortex-M Forth, currently targeted at RP2040 boards such as the Raspberry Pi Pico, the Raspberry Pi Pico W, the Arduino Nano RP2040 Connect, the Cytron Maker Nano RP2040, the SeeedStudio XIAO RP2040, and the WIO RP2040 (which it has been tested with) using 25Q Quad SPI flash compatible with the Winbond Quad SPI flash on the Raspberry Pi Pico, RP2350 boards such as the Raspberry Pi Pico 2 and the Pimoroni Pico Plus 2, the STM32L476, STM32F407, and STM32F746 DISCOVERY boards, and the STM32F411 \"Black Pill\" board. Ports to more platforms are on hold due to the current chip shortage (aside from a possible port to an STM32H7 board I have lying around somewhere). A hack exists for getting zeptoforth to work properly on STM32F411 Nucleo 64 boards using the binaries compiled for STM32F411 \"Black Pill\" boards.\n• ZetScript - ZetScript is a programming language with an API that allows bind C++ code in script side.\n• Zig - General-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.\n• Zngr L Compiler - Zngr L Compiler is the first Compiler for the theoretical language L , in the world , which used in the computation theory that teaches in the computer science departments in any faculty of since , as a basic language for computations .\n• List of languages that compile to JS - List of languages that compile to JavaScript and many other transpilers.\n• Programming Language Design - Programming Language Design is dedicated to the theory, design and implementation of programming languages.\n• GitHub programming languages - A list of programming languages that are actively developed on GitHub.\n• Lox implementations - Lots implementations of Lox language written in many programming languages.\n• Langs written in Rust - A list of programming languages implemented in Rust, for inspiration. This is a (probably incomplete) list of languages implemented in Rust. It is intended as a source of inspiration and comparison, and as a directory of potentially interesting projects in this vein.\n• Esolang Wiki - Esolang is a wiki dedicated to esoteric programming languages and related topics.\n• List of Chinese programming languages - List of production ready and in development stage of programming languages in Chinese."
    },
    {
        "link": "https://twitter.github.io/effectivescala",
        "document": "\n• Functional programming: Case classes as algebraic data types, Options, Pattern matching, Partial functions, Destructuring bindings, Laziness, Call by name,\n\nScala is one of the main application programming languages used at Twitter. Much of our infrastructure is written in Scala and we have several large libraries supporting our use. While highly effective, Scala is also a large language, and our experiences have taught us to practice great care in its application. What are its pitfalls? Which features do we embrace, which do we eschew? When do we employ “purely functional style”, and when do we avoid it? In other words: what have we found to be an effective use of the language? This guide attempts to distill our experience into short essays, providing a set of best practices. Our use of Scala is mainly for creating high volume services that form distributed systems — and our advice is thus biased — but most of the advice herein should translate naturally to other domains. This is not the law, but deviation should be well justified.\n\nScala provides many tools that enable succinct expression. Less typing is less reading, and less reading is often faster reading, and thus brevity enhances clarity. However brevity is a blunt tool that can also deliver the opposite effect: After correctness, think always of the reader.\n\nAbove all, program in Scala. You are not writing Java, nor Haskell, nor Python; a Scala program is unlike one written in any of these. In order to use the language effectively, you must phrase your problems in its terms. There’s no use coercing a Java program into Scala, for it will be inferior in most ways to its original.\n\nThis is not an introduction to Scala; we assume the reader is familiar with the language. Some resources for learning Scala are:\n\nThis is a living document that will change to reflect our current “best practices,” but its core ideas are unlikely to change: Always favor readability; write generic code but not at the expensive of clarity; take advantage of simple language features that afford great power but avoid the esoteric ones (especially in the type system). Above all, be always aware of the trade offs you make. A sophisticated language requires a complex implementation, and complexity begets complexity: of reasoning, of semantics, of interaction between features, and of the understanding of your collaborators. Thus complexity is the tax of sophistication — you must always ensure that its utility exceeds its cost.\n\nThe specifics of code formatting — so long as they are practical — are of little consequence. By definition style cannot be inherently good or bad and almost everybody differs in personal preference. However the consistent application of the same formatting rules will almost always enhance readability. A reader already familiar with a particular style does not have to grasp yet another set of local conventions, or decipher yet another corner of the language grammar.\n\nThis is of particular importance to Scala, as its grammar has a high degree of overlap. One telling example is method invocation: Methods can be invoked with “ ”, with whitespace, without parenthesis for nullary or unary methods, with parenthesis for these, and so on. Furthermore, the different styles of method invocations expose different ambiguities in its grammar! Surely the consistent application of a carefully chosen set of formatting rules will resolve a great deal of ambiguity for both man and machine.\n\nWe adhere to the Scala style guide plus the following rules.\n\nIndent by two spaces. Try to avoid lines greater than 100 columns in length. Use one blank line between method, class, and object definitions.\n\nBraces are used to create compound expressions (they serve other uses in the “module language”), where the value of the compound expression is the last expression in the list. Avoid using braces for simple expressions; write\n\neven though it may be tempting to distinguish the method body syntactically. The first alternative has less clutter and is easier to read. Avoid syntactical ceremony unless it clarifies.\n\nUse pattern matching directly in function definitions whenever applicable; instead of\n\nit's clear that the list items are being mapped over — the extra indirection does not elucidate.\n\nUse ScalaDoc to provide API documentation. Use the following style:\n\nbut not the standard ScalaDoc style:\n\nDo not resort to ASCII art or other visual embellishments. Document APIs but do not add unnecessary comments. If you find yourself adding comments to explain the behavior of your code, ask first if it can be restructured so that it becomes obvious what it does. Prefer “obviously it works” to “it works, obviously” (with apologies to Hoare).\n\nThe primary objective of a type system is to detect programming errors. The type system effectively provides a limited form of static verification, allowing us to express certain kinds of invariants about our code that the compiler can verify. Type systems provide other benefits too of course, but error checking is its Raison dÊtre.\n\nOur use of the type system should reflect this goal, but we must remain mindful of the reader: judicious use of types can serve to enhance clarity, being unduly clever only obfuscates.\n\nScala’s powerful type system is a common source of academic exploration and exercise (eg. Type level programming in Scala). While a fascinating academic topic, these techniques rarely find useful application in production code. They are to be avoided.\n\nWhile Scala allows these to be omitted, such annotations provide good documentation: this is especially important for public methods. Where a method is not exposed and its return type obvious, omit them.\n\nThis is especially important when instantiating objects with mixins as the scala compiler creates singleton types for these. For example, in:\n\ndoes not have a return type of ; the compiler creates the refinement type . Instead use an explicit annotation:\n\nNow the author is free to mix in more traits without changing the public type of , making it easier to manage backwards compatibility.\n\nVariance arises when generics are combined with subtyping. Variance defines how subtyping of the contained type relates to subtyping of the container type. Because Scala has declaration site variance annotations, authors of common libraries — especially collections — must be prolific annotators. Such annotations are important for the usability of shared code, but misapplication can be dangerous.\n\nInvariants are an advanced but necessary aspect of Scala’s typesystem, and should be used widely (and correctly) as it aids the application of subtyping.\n\nImmutable collections should be covariant. Methods that receive the contained type should “downgrade” the collection appropriately:\n\nMutable collections should be invariant. Covariance is typically invalid with mutable collections. Consider\n\nand the following type hierarchy:\n\nIf I now have a hash set of dogs\n\ntreat it as a set of Mammals and add a cat.\n\nThis is no longer a HashSet of dogs!\n\nUse type aliases when they provide convenient naming or clarify purpose, but do not alias types that are self-explanatory.\n\nsince it is both short and uses a common type. However\n\nis helpful since it communicates purpose and enhances brevity.\n\nDon’t use subclassing when an alias will do.\n\na is a function that produces a . Using a type alias\n\nis better. We may now provide function literals for values of type and also use function composition:\n\nType aliases are bound to toplevel names by using package objects:\n\nNote that type aliases are not new types — they are equivalent to the syntactically substituting the aliased name for its type.\n\nImplicits are a powerful type system feature, but they should be used sparingly. They have complicated resolution rules and make it difficult — by simple lexical examination — to grasp what is actually happening. It’s definitely OK to use implicits in the following situations:\n• Adapting or extending an object (“pimp my library” pattern)\n• Use to enhance type safety by providing constraint evidence\n\nIf you do find yourself using implicits, always ask yourself if there is a way to achieve the same thing without their help.\n\nDo not use implicits to do automatic conversions between similar datatypes (for example, converting a list to a stream); these are better done explicitly because the types have different semantics, and the reader should beware of these implications.\n\nScala has a very generic, rich, powerful, and composable collections library; collections are high level and expose a large set of operations. Many collection manipulations and transformations can be expressed succinctly and readably, but careless application of these features can often lead to the opposite result. Every Scala programmer should read the collections design document; it provides great insight and motivation for Scala collections library.\n\nAlways use the simplest collection that meets your needs.\n\nThe collections library is large: in addition to an elaborate hierarchy — the root of which being — there are and variants for most collections. Whatever the complexity, the following diagram contains the important distinctions for both and hierarchies\n\nis any collection that may be iterated over, they provide an method (and thus ). s are collections that are ordered, s are mathematical sets (unordered collections of unique items), and s are associative arrays, also unordered.\n\nPrefer using immutable collections. They are applicable in most circumstances, and make programs easier to reason about since they are referentially transparent and are thus also threadsafe by default.\n\nUse the namespace explicitly. Don’t import and refer to , instead\n\nmakes it clear that the mutable variant is being used.\n\nUse the default constructor for the collection type. Whenever you need an ordered sequence (and not necessarily linked list semantics), use the constructor, and so on:\n\nThis style separates the semantics of the collection from its implementation, letting the collections library use the most appropriate type: you need a , not necessarily a Red-Black Tree. Furthermore, these default constructors will often use specialized representations: for example, will use a 3-field object for maps with 3 keys.\n\nThe corollary to the above is: in your own methods and constructors, receive the most generic collection type appropriate. This typically boils down to one of the above: , , , or . If your method needs a sequence, use , not . (A word of caution: the default , and types in scope – defined in – are the versions, as opposed to and – defined in – which are the versions. This means that, for example, the default type can be both the immutable and mutable implementations. Thus, if your method relies on a collection parameter being immutable, and you are using , or , you must specifically require/import the immutable variant, otherwise someone may pass you the mutable version.)\n\nFunctional programming encourages pipelining transformations of an immutable collection to shape it to its desired result. This often leads to very succinct solutions, but can also be confusing to the reader — it is often difficult to discern the author’s intent, or keep track of all the intermediate results that are only implied. For example, let’s say we wanted to aggregate votes for different programming languages from a sequence of (language, num votes), showing them in order of most votes to least, we could write:\n\nthis is both succinct and correct, but nearly every reader will have a difficult time recovering the original intent of the author. A strategy that often serves to clarify is to name intermediate results and parameters:\n\nthe code is nearly as succinct, but much more clearly expresses both the transformations take place (by naming intermediate values), and the structure of the data being operated on (by naming parameters). If you worry about namespace pollution with this style, group expressions with :\n\nHigh level collections libraries (as with higher level constructs generally) make reasoning about performance more difficult: the further you stray from instructing the computer directly — in other words, imperative style — the harder it is to predict the exact performance implications of a piece of code. Reasoning about correctness however, is typically easier; readability is also enhanced. With Scala the picture is further complicated by the Java runtime; Scala hides boxing/unboxing operations from you, which can incur severe performance or space penalties.\n\nBefore focusing on low level details, make sure you are using a collection appropriate for your use. Make sure your datastructure doesn’t have unexpected asymptotic complexity. The complexities of the various Scala collections are described here.\n\nThe first rule of optimizing for performance is to understand why your application is slow. Do not operate without data; profile[1] your application before proceeding. Focus first on hot loops and large data structures. Excessive focus on optimization is typically wasted effort. Remember Knuth’s maxim: “Premature optimisation is the root of all evil.”\n\nIt is often appropriate to use lower level collections in situations that require better performance or space efficiency. Use arrays instead of lists for large sequences (the immutable collections provides a referentially transparent interface to arrays); and use buffers instead of direct sequence construction when performance matters.\n\nUse to interoperate with Java collections. These are a set of implicits that add and conversion methods. The use of these ensures that such conversions are explicit, aiding the reader:\n\nModern services are highly concurrent — it is common for servers to coordinate 10s–100s of thousands of simultaneous operations — and handling the implied complexity is a central theme in authoring robust systems software.\n\nThreads provide a means of expressing concurrency: they give you independent, heap-sharing execution contexts that are scheduled by the operating system. However, thread creation is expensive in Java and is a resource that must be managed, typically with the use of pools. This creates additional complexity for the programmer, and also a high degree of coupling: it’s difficult to divorce application logic from their use of the underlying resources.\n\nThis complexity is especially apparent when creating services that have a high degree of fan-out: each incoming request results in a multitude of requests to yet another tier of systems. In these systems, thread pools must be managed so that they are balanced according to the ratios of requests in each tier: mismanagement of one thread pool bleeds into another.\n\nRobust systems must also consider timeouts and cancellation, both of which require the introduction of yet more “control” threads, complicating the problem further. Note that if threads were cheap these problems would be diminished: no pooling would be required, timed out threads could be discarded, and no additional resource management would be required.\n\nUse Futures to manage concurrency. They decouple concurrent operations from resource management: for example, Finagle multiplexes concurrent operations onto few threads in an efficient manner. Scala has lightweight closure literal syntax, so Futures introduce little syntactic overhead, and they become second nature to most programmers.\n\nFutures allow the programmer to express concurrent computation in a declarative style, are composable, and have principled handling of failure. These qualities have convinced us that they are especially well suited for use in functional programming languages, where this is the encouraged style.\n\nPrefer transforming futures over creating your own. Future transformations ensure that failures are propagated, that cancellations are signalled, and free the programmer from thinking about the implications of the Java memory model. Even a careful programmer might write the following to issue an RPC 10 times in sequence and then print the results:\n\nThe programmer had to ensure that RPC failures are propagated, interspersing the code with control flow; worse, the code is wrong! Without declaring volatile, we cannot ensure that holds the previous value in each iteration. The Java memory model is a subtle beast, but luckily we can avoid all of these pitfalls by using the declarative style:\n\nWe use to sequence operations and prepend the result onto the list as we proceed. This is a common functional programming idiom translated to Futures. This is correct, requires less boilerplate, is less error prone, and also reads better.\n\nUse the Future combinators. , , and codify common patterns when operating over multiple futures that should be combined.\n\nDo not throw your own exceptions in methods that return Futures. Futures represent both successful and failed computations. Therefore, it’s important that errors involved in that computation are properly encapsulated in the returned Future. Concretely, return instead of throwing that exception:\n\nFatal exceptions should not be represented by Futures. These exceptions include ones that are thrown when resources are exhausted, like OutOfMemoryError, and also JVM-level errors like NoSuchMethodError. These conditions are ones under which the JVM must exit.\n\nThe predicates — or Twitter’s version — should be used to identify exceptions which should be returned as a Future.exception.\n\nThe subject of concurrent collections is fraught with opinions, subtleties, dogma and FUD. In most practical situations they are a nonissue: Always start with the simplest, most boring, and most standard collection that serves the purpose. Don’t reach for a concurrent collection before you know that a synchronized one won’t do: the JVM has sophisticated machinery to make synchronization cheap, so their efficacy may surprise you.\n\nIf an immutable collection will do, use it — they are referentially transparent, so reasoning about them in a concurrent context is simple. Mutations in immutable collections are typically handled by updating a reference to the current value (in a cell or an ). Care must be taken to apply these correctly: atomics must be retried, and must be declared volatile in order for them to be published to other threads.\n\nMutable concurrent collections have complicated semantics, and make use of subtler aspects of the Java memory model, so make sure you understand the implications — especially with respect to publishing updates — before you use them. Synchronized collections also compose better: operations like cannot be implemented correctly by concurrent collections, and creating composite collections is especially error prone.\n\nPrograms in the functional style tend to require fewer traditional control structures, and read better when written in the declarative style. This typically implies breaking your logic up into several small methods or functions, and gluing them together with expressions. Functional programs also tend to be more expression-oriented: branches of conditionals compute values of the same type, computes comprehensions, and recursion is commonplace.\n\nPhrasing your problem in recursive terms often simplifies it, and if the tail call optimization applies (which can be checked by the annotation), the compiler will even translate your code into a regular loop.\n\nEvery time the while loop is entered, we’re working with state dirtied by the previous iteration. The value of each variable is a function of which branches were taken, and it returns in the middle of the loop when the correct position was found (The keen reader will find similar arguments in Dijkstra’s “Go To Statement Considered Harmful”).\n\nhere every iteration starts with a well-defined clean slate, and there are no reference cells: invariants abound. It’s much easier to reason about, and easier to read as well. There is also no performance penalty: since the method is tail-recursive, the compiler translates this into a standard imperative loop.\n\nThis is not to say that imperative structures are not also valuable. In many cases they are well suited to terminate computation early instead of having conditional branches for every possible point of termination: indeed in the above , a is used to terminate early if we’re at the end of the heap.\n\nReturns can be used to cut down on branching and establish invariants. This helps the reader by reducing nesting (how did I get here?) and making it easier to reason about the correctness of subsequent code (the array cannot be accessed out of bounds after this point). This is especially useful in “guard” clauses:\n\nUse s to clarify and enhance readability, but not as you would in an imperative language; avoid using them to return the results of a computation. Instead of\n\nbut using a expression is superior to either:\n\nNote that returns can have hidden costs: when used inside of a closure,\n\nthis is implemented in bytecode as an exception catching/throwing pair which, used in hot code, has performance implications.\n\nprovides both succinct and natural expression for looping and aggregation. It is especially useful when flattening many sequences. The syntax of belies the underlying mechanism as it allocates and dispatches closures. This can lead to both unexpected costs and semantics; for example\n\nmay cause a runtime error if the container delays computation, making the nonlocal!\n\nFor these reasons, it is often preferrable to call , , , and directly — but do use s when they clarify.\n\nand both serve as executable documentation. Both are useful for situations in which the type system cannot express the required invariants. is used for invariants that the code assumes (either internal or external), for example\n\nWhereas is used to express API contracts:\n\nValue oriented programming confers many advantages, especially when used in conjunction with functional programming constructs. This style emphasizes the transformation of values over stateful mutation, yielding code that is referentially transparent, providing stronger invariants and thus also easier to reason about. Case classes, pattern matching, destructuring bindings, type inference, and lightweight closure- and method-creation syntax are the tools of this trade.\n\nCase classes encode ADTs: they are useful for modelling a large number of data structures and provide for succinct code with strong invariants, especially when used in conjunction with pattern matching. The pattern matcher implements exhaustivity analysis providing even stronger static guarantees.\n\nUse the following pattern when encoding ADTs with case classes:\n\nThe type has two constructors: and . Declaring the type allows the compiler to do exhaustivity analysis since constructors cannot be added outside the source file.\n\nTogether with pattern matching, such modelling results in code that is both succinct and “obviously correct”:\n\nWhile recursive structures like trees constitute classic applications of ADTs, their domain of usefulness is much larger. Disjoint unions in particular are readily modelled with ADTs; these occur frequently in state machines.\n\nThe type is a container that is either empty ( ) or full ( ). It provides a safe alternative to the use of , and should be used instead of null whenever possible. Options are collections (of at most one item) and they are embellished with collection operations — use them!\n\nsince the former is safer: the type statically enforces that must be checked for emptyness.\n\nConditional execution on an value should be done with ; instead of\n\nThe style may seem odd, but provides greater safety (we don’t call the exceptional ) and brevity. If both branches are taken, use pattern matching:\n\nbut if all that's missing is a default value, use\n\nDo not overuse : if there is a sensible default — a Null Object — use that instead.\n\nalso comes with a handy constructor for wrapping nullable values:\n\nis an that assumes a value of should return .\n\nPattern matches ( ) are pervasive in well written Scala code: they conflate conditional execution, destructuring, and casting into one construct. Used well they enhance both clarity and safety.\n\nPattern matching works best when also combined with destructuring (for example if you are matching case classes); instead of\n\nWrite custom extractors but only with a dual constructor ( ), otherwise their use may be out of place.\n\nDon’t use pattern matching for conditional execution when defaults make more sense. The collections libraries usually provide methods that return s; avoid\n\nis both shorter and communicates purpose.\n\nand they may be composed with\n\nPartial functions arise in many situations and are effectively encoded with , for example as arguments to methods\n\nor in situations that might otherwise call for returning an :\n\nmight be better expressed with a\n\nDestructuring value bindings are related to pattern matching; they use the same mechanism but are applicable when there is exactly one option (lest you accept the possibility of an exception). Destructuring binds are particularly useful for tuples and case classes.\n\nFields in scala are computed by need when is prefixed with . Because fields and methods are equivalent in Scala (lest the fields are )\n\ni.e., it computes a results and memoizes it. Use lazy fields for this purpose, but avoid using laziness when laziness is required by semantics. In these cases it's better to be explicit since it makes the cost model explicit, and side effects can be controlled more precisely.\n\nMethod parameters may be specified by-name, meaning the parameter is bound not to a value but to a computation that may be repeated. This feature must be applied with care; a caller expecting by-value semantics will be surprised. The motivation for this feature is to construct syntactically natural DSLs — new control constructs in particular can be made to look much like native language features.\n\nOnly use call-by-name for such control constructs, where it is obvious to the caller that what is being passed in is a “block” rather than the result of an unsuspecting computation. Only use call-by-name arguments in the last position of the last argument list. When using call-by-name, ensure that the method is named so that it is obvious to the caller that its argument is call-by-name.\n\nWhen you do want a value to be computed multiple times, and especially when this computation is side effecting, use explicit functions:\n\nThe intent remains obvious and the caller is left without surprises.\n\n— the combination of with — deserves special attention, for it has subtle power and great utility. Like its brethren , it is frequently available in nontraditional collections such as and . Its behavior is revealed by its signature; for some\n\ninvokes the function for the element(s) of the collection producing a new collection, (all of) which are flattened into its result. For example, to get all permutations of two character strings that aren't the same character repeated twice:\n\nwhich is equivalent to the more concise for-comprehension (which is — roughly — syntactical sugar for the above):\n\nis frequently useful when dealing with — it will collapse chains of options down to one,\n\nwhich is also made more succinct with\n\nThe use of in s is discussed in the futures section.\n\nMuch of Scala’s vastness lies in its object system. Scala is a pure language in the sense that all values are objects; there is no distinction between primitive types and composite ones. Scala also features mixins allowing for more orthogonal and piecemeal construction of modules that can be flexibly put together at compile time with all the benefits of static type checking.\n\nA motivation behind the mixin system was to obviate the need for traditional dependency injection. The culmination of this “component style” of programming is the cake pattern.\n\nIn our use, however, we’ve found that Scala itself removes so much of the syntactical overhead of “classic” (constructor) dependency injection that we’d rather just use that: it is clearer, the dependencies are still encoded in the (constructor) type, and class construction is so syntactically trivial that it becomes a breeze. It’s boring and simple and it works. Use dependency injection for program modularization, and in particular, prefer composition over inheritance — for this leads to more modular and testable programs. When encountering a situation requiring inheritance, ask yourself: how would you structure the program if the language lacked support for inheritance? The answer may be compelling.\n\nIt is common to inject factories — objects that produce other objects. In these cases, favor the use of simple functions over specialized factory types.\n\nDependency injection does not at all preclude the use of common interfaces, or the implementation of common code in traits. Quite the contrary — the use of traits are highly encouraged for exactly this reason: multiple interfaces (traits) may be implemented by a concrete class, and common code can be reused across all such classes.\n\nKeep traits short and orthogonal: don’t lump separable functionality into a trait, think of the smallest related ideas that fit together. For example, imagine you have an something that can do IO:\n\nand mix them together to form what was an : … Interface minimalism leads to greater orthogonality and cleaner modularization.\n\nScala has very expressive visibility modifiers. It’s important to use these as they define what constitutes the public API. Public APIs should be limited so users don’t inadvertently rely on implementation details and limit the author’s ability to change them: They are crucial to good modularity. As a rule, it’s much easier to expand public APIs than to contract them. Poor annotations can also compromise backwards binary compatibility of your code.\n\nis visible to all instances of that class (but not their subclasses). In most cases, you want .\n\nwhich limits visibility to the particular instance. The Scala compiler is also able to translate into a simple field access (since access is limited to the statically defined class) which can sometimes aid performance optimizations.\n\nIt’s common in Scala to create singleton class types, for example\n\nIn these situations, visibility can be constrained by declaring the returned type:\n\nwhere callers of will see a restricted view ( ) of the returned instance.\n\nDo not use structural types in normal use. They are a convenient and powerful feature, but unfortunately do not have an efficient implementation on the JVM. However — due to an implementation quirk — they provide a very nice shorthand for doing reflection.\n\nScala provides an exception facility, but do not use it for commonplace errors, when the programmer must handle errors properly for correctness. Instead, encode such errors explicitly: using or are good, idiomatic choices, as they harness the type system to ensure that the user is properly considering error handling.\n\nFor example, when designing a repository, the following API may be tempting:\n\nbut this would require the implementor to throw an exception when the key is absent. A better approach is to use an :\n\nThis interface makes it obvious that the repository may not contain every key, and that the programmer must handle missing keys. Furthermore, has a number of combinators to handle these cases. For example, is used to supply a default value for missing keys:\n\nBecause Scala’s exception mechanism isn’t checked — the compiler cannot statically tell whether the programmer has covered the set of possible exceptions — it is often tempting to cast a wide net when handling exceptions.\n\nHowever, some exceptions are fatal and should never be caught; the code\n\nis almost always wrong, as it would catch fatal errors that need to be propagated. Instead, use the extractor to handle only nonfatal exceptions.\n\nWe spend a lot of time tuning garbage collection in production. The garbage collection concerns are largely similar to those of Java though idiomatic Scala code tends to generate more (short-lived) garbage than idiomatic Java code — a byproduct of the functional style. Hotspot’s generational garbage collection typically makes this a nonissue as short-lived garbage is effectively free in most circumstances.\n\nBefore tackling GC performance issues, watch this presentation by Attila that illustrates some of our experiences with GC tuning.\n\nIn Scala proper, your only tool to mitigate GC problems is to generate less garbage; but do not act without data! Unless you are doing something obviously degenerate, use the various Java profiling tools — our own include heapster and gcprof.\n\nWhen we write code in Scala that is used from Java, we ensure that usage from Java remains idiomatic. Oftentimes this requires no extra effort — classes and pure traits are exactly equivalent to their Java counterpart — but sometimes separate Java APIs need to be provided. A good way to get a feel for your library’s Java API is to write a unittest in Java (just for compilation); this also ensures that the Java-view of your library remains stable over time as the Scala compiler can be volatile in this regard.\n\nTraits that contain implementation are not directly usable from Java: extend an abstract class with the trait instead.\n\nThe most important standard libraries at Twitter are Util and Finagle. Util should be considered an extension to the Scala and Java standard libraries, providing missing functionality or more appropriate implementations. Finagle is our RPC system; the kernel distributed systems components.\n\nFutures have been discussed briefly in the concurrency section. They are the central mechanism for coordination asynchronous processes and are pervasive in our codebase and core to Finagle. Futures allow for the composition of concurrent events, and simplify reasoning about highly concurrent operations. They also lend themselves to a highly efficient implementation on the JVM.\n\nTwitter’s futures are asynchronous, so blocking operations — basically any operation that can suspend the execution of its thread; network IO and disk IO are examples — must be handled by a system that itself provides futures for the results of said operations. Finagle provides such a system for network IO.\n\nFutures are plain and simple: they hold the promise for the result of a computation that is not yet complete. They are a simple container — a placeholder. A computation could fail of course, and this must also be encoded: a Future can be in exactly one of 3 states: pending, failed or completed.\n\nFutures are a type of collection — they are a container of either 0 or 1 elements — and you’ll find they have standard collection methods (eg. , , and ). Since a Future’s value is deferred, the result of applying any of these methods is necessarily also deferred; in\n\nthe function is not invoked until the integer value becomes available, and the transformed collection is also in pending state until that time.\n\nand this makes sense for futures, too:\n\nsince futures are deferred, the implementation of — it returns immediately — has to return a future that is the result of waiting for the completion of the outer future ( ) and after that the inner one ( ). If the outer future fails, the flattened future must also fail.\n\nFutures (like Lists) also define ; defines its signature as\n\nwhich is like the combination of both and , and we could implement it that way:\n\nThis is a powerful combination! With we can define a Future that is the result of two futures sequenced, the second future computed based on the result of the first one. Imagine we needed to do two RPCs in order to authenticate a user (id), we could define the composite operation in the following way:\n\nan additional benefit to this type of composition is that error handling is built-in: the future returned from will fail if either of or does with no extra error handling code.\n\nFuture callback methods ( , , , ) return a new future that is chained to its parent. This future is guaranteed to be completed only after its parent, enabling patterns like\n\nwhere is guaranteed to be executed only after , allowing for emulation of the native pattern.\n\nUse instead of — it is symmetrical to and is a better name for the purpose, and also allows for chaining.\n\nAlways try to avoid creating instances directly: nearly every task can be accomplished via the use of predefined combinators. These combinators ensure errors and cancellations are propagated, and generally encourage dataflow style programming which usually obviates the need for synchronization and volatility declarations.\n\nCode written in tail-recursive style is not subject to stack-space leaks, allowing for efficient implementation of loops in dataflow-style:\n\ndefines many useful methods: Use and to create pre-satisfied futures. , and provide combinators that turn many futures into one (ie. the gather part of a scatter-gather operation).\n\nFutures implement a weak form of cancellation. Invoking does not directly terminate the computation but instead propagates a level triggered signal that may be queried by whichever process ultimately satisfies the future. Cancellation flows in the opposite direction from values: a cancellation signal set by a consumer is propagated to its producer. The producer uses on to listen to this signal and act accordingly.\n\nThis means that the cancellation semantics depend on the producer, and there is no default implementation. Cancellation is but a hint.\n\nUtil’s provides a reference cell that is local to a particular future dispatch tree. Setting the value of a local makes this value available to any computation deferred by a Future in the same thread. They are analogous to thread locals, except their scope is not a Java thread but a tree of “future threads”. In\n\nin the block will refer to the value of the local at the time the callback was added.\n\nAs with thread locals, s can be very convenient, but should almost always be avoided: make sure the problem cannot be sufficiently solved by passing data around explicitly, even if it is somewhat burdensome.\n\nLocals are used effectively by core libraries for very common concerns — threading through RPC traces, propagating monitors, creating “stack traces” for future callbacks — where any other solution would unduly burden the user. Locals are inappropriate in almost any other situation.\n\nConcurrent systems are greatly complicated by the need to coordinate access to shared data and resources. Actors present one strategy of simplification: each actor is a sequential process that maintains its own state and resources, and data is shared by messaging with other actors. Sharing data requires communicating between actors.\n\nOffer/Broker builds on this in three important ways. First, communication channels (Brokers) are first class — that is, you send messages via Brokers, not to an actor directly. Secondly, Offer/Broker is a synchronous mechanism: to communicate is to synchronize. This means we can use Brokers as a coordination mechanism: when process has sent a message to process ; both and agree on the state of the system. Lastly, communication can be performed selectively: a process can propose several different communications, and exactly one of them will obtain.\n\nIn order to support selective communication (as well as other composition) in a general way, we need to decouple the description of a communication from the act of communicating. This is what an does — it is a persistent value that describes a communication; in order to perform that communication (act on the offer), we synchronize via its method\n\nwhich returns a that yields the exchanged value when the communication obtains.\n\nA coordinates the exchange of values through offers — it is the channel of communications:\n\nso that, when creating two offers\n\nand and are both synchronized\n\nboth offers obtain and the value is exchanged.\n\nSelective communication is performed by combining several offers with\n\nwhich yields a new offer that, when synchronized, obtains exactly one of — the first one to become available. When several are available immediately, one is chosen at random to obtain.\n\nThe object has a number of one-off Offers that are used to compose with Offers from a Broker.\n\nis an offer that activates after the given duration. will never obtain, and obtains immediately with the given value. These are useful for composition via selective communication. For example to apply a timeout on a send operation:\n\nIt may be tempting to compare the use of Offer/Broker to SynchronousQueue, but they are different in subtle but important ways. Offers can be composed in ways that such queues simply cannot. For example, consider a set of queues, represented as Brokers:\n\nis an offer that will read from first available queue. Note that is still synchronous — we still have the semantics of the underlying queues. Such composition is simply not possible using queues.\n\nConnection pools are common in network applications, and they’re often tricky to implement — for example, it’s often desirable to have timeouts on acquisition from the pool since various clients have different latency requirements. Pools are simple in principle: we maintain a queue of connections, and we satisfy waiters as they come in. With traditional synchronization primitives this typically involves keeping two queues: one of waiters (when there are no connections), and one of connections (when there are no waiters).\n\nUsing Offer/Brokers, we can express this quite naturally:\n\nwill always offer to have a connection returned, but only offer to send one when the queue is nonempty. Using a persistent queue simplifies reasoning further. The interface to the pool is also through an Offer, so if a caller wishes to apply a timeout, they can do so through the use of combinators:\n\nNo extra bookkeeping was required to implement timeouts; this is due to the semantics of Offers: if is selected, there is no longer an offer to receive from the pool — the pool and its caller never simultaneously agreed to receive and send, respectively, on the broker.\n\nIt is often useful — and sometimes vastly simplifying — to structure concurrent programs as a set of sequential processes that communicate synchronously. Offers and Brokers provide a set of tools to make this simple and uniform. Indeed, their application transcends what one might think of as “classic” concurrency problems — concurrent programming (with the aid of Offer/Broker) is a useful structuring tool, just as subroutines, classes, and modules are — another important idea from CSP.\n\nOne example of this is the Sieve of Eratosthenes, which can be structured as a successive application of filters to a stream of integers. First, we’ll need a source of integers:\n\nis simply the offer of all consecutive integers starting at . Then we need a filter:\n\nreturns the offer that removes multiples of the prime from . Finally, we define our sieve:\n\nworks simply: it reads the next (prime) number from , and then applies a filter to that excludes this prime. As recurses, successive primes are filtered, and we have a Sieve. We can now print out the first 10000 primes:\n\nBesides being structured into simple, orthogonal components, this approach gives you a streaming Sieve: you do not a priori need to compute the set of primes you are interested in, further enhancing modularity.\n\nThe lessons herein are those of Twitter’s Scala community — I hope I’ve been a faithful chronicler.\n\nBlake Matheny, Nick Kallen, Steve Gury, and Raghavendra Prabhu provided much helpful guidance and many excellent suggestions."
    }
]