[
    {
        "link": "https://docs.python.org/3/library/itertools.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/23833780/how-to-use-itertools-to-compute-all-combinations-with-repeating-elements",
        "document": "I have tried to use itertools to compute all combinations of a list using with repeating elements. The problem is in the fact that the indices seem to be used to distinguish the elements:\n\nReturn r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once. Combinations are emitted in lexicographic sort order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order. Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique.\n\nAnd what I need is the combination set to contain elements like: which seem to be missing. How to compute the complete combination set?"
    },
    {
        "link": "https://geeksforgeeks.org/python-itertools-combinations_with_replacement",
        "document": "Itertools in Python refers to module provided in Python for the creation of iterators which helps in efficient looping, time and space efficiency as well. Itertools helps us to solve complex problems easily and efficiently. There are in general 3 types of iterators.\n\nDifferent types of iterators provided by this module are: \n\n\n\nNote: For more information, refer to Python Itertools\n\n\n\nItertools.Combinations_with_replacement() lies in the Combinatoric Generator subtype of itertools. Combinatoric generators refer to those iterators which deal with the different arrangements possible for an iterator. Here the elements are referred with there index value and not by their value or type.\n\nHow to use Itertools.Combinations_with_replacement() function? \n\nAs understood by name “combinations” means all the possible subsets or arrangements of the iterator and the word “combinations_with_replacement” means all the possible arrangements or subsets that allow an element to repeat in a subset. This function takes ‘r’ as input here ‘r’ represents the size of different combinations that are possible. All the combinations with repetition of elements are emitted and are of length ‘r’ and ‘r’ is a necessary argument here.\n\nExample 1:-"
    },
    {
        "link": "https://inventwithpython.com/blog/2021/07/03/combinations-and-permutations-in-python-with-itertools",
        "document": "If you a list, dictionary, or other iterable object of values you need to generate combinations and permutations from, Python has the built-in module as part of its standard library. The permutations of an iterable are every possible ordering of all of the values, while the combinations are every possible selection of some, none, or all of the values. For example, the permutations and combinations of the set are:\n\nYou can also reuse the values multiple times, which is called permutations with repetition and combinations with repetition (also called replacement):\n\nThe number of permutations and combinations quickly grows when more values are added to the iterable object. The total number of permutations and combinations is given in the following:\n\nBut to have Python generate permutations, you can use :\n\nTo have Python generate combinations, you can use :\n\nNote that the function takes a second argument for the number of values to select. To get all combinations (also called the power set), you'll need to make multiple calls to :\n\nTo get permutations with repetition/replacement, call and pass the size of the iterable object for its argument:\n\nTo get combinations with repetition/replacement, call :\n\nIf you're like me and you had trouble remembering the differences between permutations and combinations, with and without repetition, and which Python functions implement them, bookmark this page to have easy access in the future."
    },
    {
        "link": "https://stackoverflow.com/questions/35822627/combinations-with-repetition-in-python-where-order-matters",
        "document": "is definitely the method you're looking for here. As the documentation states, it is effectively a compact for loop; is equivalent to\n\nwill return every combination of elements that it can, order-specific, so will get you . If you want to include repetition, you set the optional variable. is equivalent to . Similarly, is the same as .\n\nIn short: to get the result you're looking for, call . This will get you tuples , in order."
    },
    {
        "link": "https://geeksforgeeks.org/python-itertools-product",
        "document": "In the terms of Mathematics Cartesian Product of two sets is defined as the set of all ordered pairs (a, b) where a belongs to A and b belongs to B. Consider the below example for better understanding.\n\nExamples:\n\n\n\nThe above solution can be done by looping but we will use a special Python library itertools.product() for finding the Cartesian Product. Let’s go through the working and use cases of this Python library.\n\n\n\nWhat are Itertools in Python?\n\n\n\nPython Itertools is a library in Python which consists of multiple methods that are used in various iterators to compute a fast and code efficient solution.\n\n\n\n\n\nNote: For more information, refer to Python Itertools\n\n\n\nWhat does itertools.product() do?\n\nitertools.product() is used to find the cartesian product from the given iterator, output is lexicographic ordered. The itertools.product() can used in two different ways:\n• itertools.product(*iterables, repeat=1):\n\n It returns the cartesian product of the provided iterable with itself for the number of times specified by the optional keyword “repeat”. For example, product(arr, repeat=3) means the same as product(arr, arr, arr).\n• itertools.product(*iterables):\n\n It returns the cartesian product of all the iterable provided as the argument. For example, product(arr1, arr2, arr3)."
    },
    {
        "link": "https://docs.python.org/3/library/itertools.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/61685177/how-to-get-cartesian-product-in-python-using-a-generator",
        "document": "Bottom line, is already an iterator. You don't need to write your own. (A generator is a kind of iterator.) For example:\n\nNow, to explain, it seems like you're misunderstanding something fundamental. A generator function returns a generator iterator. That's what you're seeing from the print:\n\nUse to cast an iterator to a list.\n\nNote how it's a nested list. That's because your yields one list then nothing else. On that note, that part makes no sense because casting to a list defeats the whole purpose of an iterator - lazy evaluation. If you actually wanted to yield the values from an iterator, you would use :\n\nIn this case is pointless, but if your actual is more complex, this might be what you actually want.\n• what's the difference between yield from and yield in python 3.3.2+\n• How to Use Generators and yield in Python - Real Python\n\nThis answer is partly based on juanpa.arrivillaga's comment"
    },
    {
        "link": "https://note.nkmk.me/en/python-itertools-product",
        "document": "In Python, you can generate a Cartesian product of multiple lists using .\n\nAll sample code in this article assumes that the and modules have been imported. The module is used to make the results easier to read.\n\nWhat is the Cartesian product?\n\nThe Cartesian product is the set of all combinations of elements from multiple sets.\n\nWhen you pass two lists as arguments, returns an object of type , which is an iterator. Therefore, the contents are not directly output by .\n\nYou can obtain the combination of elements from each list as a tuple using a loop. Note that if an iterator has reached the end and is iterated over again in the loop, nothing will be output.\n• Python for loop (with range, enumerate, zip, etc.)\n\nIt is also possible to get each element separately instead of a tuple.\n\nThe result is the same as when using nested loops (multiple loops).\n\nYou can also use to convert the result into a list of tuples.\n\nYou can pass multiple types of iterables (like , , , etc.) to .\n\nAs you can see from the result above, iterating over a dictionary returns the keys. If you need the values, use the method. See the following article for details.\n• Iterate dictionary (key and value) with for loop in Python\n\nSee the following article for more information about .\n• How to use range() in Python\n\nUse the same list (iterable) repeatedly:\n\nYou can specify the number of repetitions in the keyword argument, . The same iterable is used repeatedly to generate a Cartesian product.\n\nSame as the following example without .\n\nIf multiple iterables are specified:\n\nSame as the following example. Note that with , the order of arguments is instead of .\n\nAs mentioned above, multiple loops (nested loops) give the same result as .\n\nAs you can see below, is actually slower than nested loops.\n\nThe results may differ depending on the number of elements in the iterable and the number of loops, but following Q&A on Stack Overflow also answers that is slower.\n\nThe following examples use the Jupyter Notebook magic command . Note that these will not work if run as Python scripts.\n\nExample using a double loop with 1000 elements\n\nThe result of is faster to unpack.\n\nNested loops are about the same (slightly faster) as when unpacked.\n\nIt's faster not to unpack when using a generator expression, which is the generator version of list comprehension. However, it's still slower than using or nested loops.\n\nExample of calculating the sum of the products of each combination. Again, it's faster to use nested loops than .\n\nIn this example, passing the generator expression to is slightly faster.\n\nExample using a triple loop with 100 elements\n\nAgain, using nested loops is the fastest.\n\n# 31.6 ms ± 725 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) # 26.2 ms ± 490 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) # 12.9 ms ± 176 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) # 80.9 ms ± 1.27 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) # 93.8 ms ± 3.22 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nAs mentioned above, the time difference between using a double loop with 1000 elements and a triple loop with 100 elements is just a few tens of milliseconds."
    },
    {
        "link": "https://docs.python.org/3.9/library/itertools.html",
        "document": ""
    }
]