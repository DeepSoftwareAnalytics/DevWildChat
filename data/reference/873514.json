[
    {
        "link": "https://docs.python.org/3/library/argparse.html",
        "document": "The module makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and will figure out how to parse those out of . The module also automatically generates help and usage messages. The module will also issue errors when users give the program invalid arguments.\n\nThe module’s support for command-line interfaces is built around an instance of . It is a container for argument specifications and has options that apply to the parser as whole:\n\nThe method attaches individual argument specifications to the parser. It supports positional arguments, options that accept values, and on/off flags:\n\nThe method runs the parser and places the extracted data in a object:\n\nCreate a new object. All parameters should be passed as keyword arguments. Each parameter has its own more detailed description below, but in short they are:\n• None prog - The name of the program (default: )\n• None usage - The string describing the program usage (default: generated from arguments added to parser)\n• None description - Text to display before the argument help (by default, no text)\n• None epilog - Text to display after the argument help (by default, no text)\n• None parents - A list of objects whose arguments should also be included\n• None formatter_class - A class for customizing the help output\n• None prefix_chars - The set of characters that prefix optional arguments (default: ‘-‘)\n• None fromfile_prefix_chars - The set of characters that prefix files from which additional arguments should be read (default: )\n• None argument_default - The global default value for arguments (default: )\n• None conflict_handler - The strategy for resolving conflicting optionals (usually unnecessary)\n• None allow_abbrev - Allows long options to be abbreviated if the abbreviation is unambiguous. (default: )\n• None exit_on_error - Determines whether or not exits with error info when an error occurs. (default: ) Changed in version 3.8: In previous versions, allow_abbrev also disabled grouping of short flags such as to mean . The following sections describe how each of these are used. By default, calculates the name of the program to display in help messages depending on the way the Python interpreter was run:\n• None The of if a file was passed as argument.\n• None The Python interpreter name followed by if a directory or a zipfile was passed as argument.\n• None The Python interpreter name followed by followed by the module or package name if the option was used. This default is almost always desirable because it will make the help messages match the string that was used to invoke the program on the command line. However, to change this default behavior, another value can be supplied using the argument to : -h, --help show this help message and exit Note that the program name, whether determined from or from the argument, is available to help messages using the format specifier. -h, --help show this help message and exit By default, calculates the usage message from the arguments it contains. The default message can be overridden with the keyword argument: -h, --help show this help message and exit The format specifier is available to fill in the program name in your usage messages. Most calls to the constructor will use the keyword argument. This argument gives a brief description of what the program does and how it works. In help messages, the description is displayed between the command-line usage string and the help messages for the various arguments. By default, the description will be line-wrapped so that it fits within the given space. To change this behavior, see the formatter_class argument. Some programs like to display additional description of the program after the description of the arguments. Such text can be specified using the argument to : \"And that's how you'd foo a bar\" -h, --help show this help message and exit And that's how you'd foo a bar As with the description argument, the text is by default line-wrapped, but this behavior can be adjusted with the formatter_class argument to . Sometimes, several parsers share a common set of arguments. Rather than repeating the definitions of these arguments, a single parser with all the shared arguments and passed to argument to can be used. The argument takes a list of objects, collects all the positional and optional actions from them, and adds these actions to the object being constructed: Note that most parent parsers will specify . Otherwise, the will see two options (one in the parent and one in the child) and raise an error. You must fully initialize the parsers before passing them via . If you change the parent parsers after the child parser, those changes will not be reflected in the child. objects allow the help formatting to be customized by specifying an alternate formatting class. Currently, there are four such classes: and give more control over how textual descriptions are displayed. By default, objects line-wrap the description and epilog texts in command-line help messages: likewise for this epilog whose whitespace will be cleaned up and whose words will be wrapped this description was indented weird but that is okay -h, --help show this help message and exit likewise for this epilog whose whitespace will be cleaned up and whose words will be wrapped across a couple lines Passing as indicates that description and epilog are already correctly formatted and should not be line-wrapped: Please do not mess up this text! Please do not mess up this text! -h, --help show this help message and exit maintains whitespace for all sorts of help text, including argument descriptions. However, multiple newlines are replaced with one. If you wish to preserve multiple blank lines, add spaces between the newlines. automatically adds information about default values to each of the argument help messages: -h, --help show this help message and exit uses the name of the type argument for each argument as the display name for its values (rather than using the dest as the regular formatter does): -h, --help show this help message and exit Most command-line options will use as the prefix, e.g. . Parsers that need to support different or additional prefix characters, e.g. for options like or , may specify them using the argument to the constructor: The argument defaults to . Supplying a set of characters that does not include will cause options to be disallowed. Sometimes, when dealing with a particularly long argument list, it may make sense to keep the list of arguments in a file rather than typing it out at the command line. If the argument is given to the constructor, then arguments that start with any of the specified characters will be treated as files, and will be replaced by the arguments they contain. For example: Arguments read from a file must by default be one per line (but see also ) and are treated as if they were in the same place as the original file referencing argument on the command line. So in the example above, the expression is considered equivalent to the expression . uses filesystem encoding and error handler to read the file containing arguments. The argument defaults to , meaning that arguments will never be treated as file references. Changed in version 3.12: changed encoding and errors to read arguments files from default (e.g. and ) to the filesystem encoding and error handler. Arguments file should be encoded in UTF-8 instead of ANSI Codepage on Windows. Generally, argument defaults are specified either by passing a default to or by calling the methods with a specific set of name-value pairs. Sometimes however, it may be useful to specify a single parser-wide default for arguments. This can be accomplished by passing the keyword argument to . For example, to globally suppress attribute creation on calls, we supply : Normally, when you pass an argument list to the method of an , it recognizes abbreviations of long options. This feature can be disabled by setting to : objects do not allow two actions with the same option string. By default, objects raise an exception if an attempt is made to create an argument with an option string that is already in use: Sometimes (e.g. when using parents) it may be useful to simply override any older arguments with the same option string. To get this behavior, the value can be supplied to the argument of : -h, --help show this help message and exit Note that objects only remove an action if all of its option strings are overridden. So, in the example above, the old action is retained as the action, because only the option string was overridden. By default, objects add an option which simply displays the parser’s help message. If or is supplied at the command line, the help will be printed. Occasionally, it may be useful to disable the addition of this help option. This can be achieved by passing as the argument to : The help option is typically . The exception to this is if the is specified and does not include , in which case and are not valid options. In this case, the first character in is used to prefix the help options: +h, ++help show this help message and exit Normally, when you pass an invalid argument list to the method of an , it will print a message to and exit with a status code of 2. If the user would like to catch errors manually, the feature can be enabled by setting to :\n\nDefine how a single command-line argument should be parsed. Each parameter has its own more detailed description below, but in short they are:\n• None name or flags - Either a name or a list of option strings, e.g. or .\n• None action - The basic type of action to be taken when this argument is encountered at the command line.\n• None nargs - The number of command-line arguments that should be consumed.\n• None const - A constant value required by some action and nargs selections.\n• None default - The value produced if the argument is absent from the command line and if it is absent from the namespace object.\n• None type - The type to which the command-line argument should be converted.\n• None choices - A sequence of the allowable values for the argument.\n• None required - Whether or not the command-line option may be omitted (optionals only).\n• None help - A brief description of what the argument does.\n• None metavar - A name for the argument in usage messages.\n• None dest - The name of the attribute to be added to the object returned by .\n• None deprecated - Whether or not use of the argument is deprecated. The following sections describe how each of these are used. The method must know whether an optional argument, like or , or a positional argument, like a list of filenames, is expected. The first arguments passed to must therefore be either a series of flags, or a simple argument name. For example, an optional argument could be created like: while a positional argument could be created like: When is called, optional arguments will be identified by the prefix, and the remaining arguments will be assumed to be positional: PROG: error: the following arguments are required: bar objects associate command-line arguments with actions. These actions can do just about anything with the command-line arguments associated with them, though most actions simply add an attribute to the object returned by . The keyword argument specifies how the command-line arguments should be handled. The supplied actions are:\n• None - This just stores the argument’s value. This is the default action.\n• None - This stores the value specified by the const keyword argument; note that the const keyword argument defaults to . The action is most commonly used with optional arguments that specify some sort of flag. For example:\n• None and - These are special cases of used for storing the values and respectively. In addition, they create default values of and respectively:\n• None - This stores a list, and appends each argument value to the list. It is useful to allow an option to be specified multiple times. If the default value is non-empty, the default elements will be present in the parsed value for the option, with any values from the command line appended after those default values. Example usage:\n• None - This stores a list, and appends the value specified by the const keyword argument to the list; note that the const keyword argument defaults to . The action is typically useful when multiple arguments need to store constants to the same list. For example:\n• None - This stores a list and appends each item from the multi-value argument list to it. The action is typically used with the nargs keyword argument value or . Note that when nargs is (the default) or , each character of the argument string will be appended to the list. Example usage:\n• None - This counts the number of times a keyword argument occurs. For example, this is useful for increasing verbosity levels: Note, the default will be unless explicitly set to 0.\n• None - This prints a complete help message for all the options in the current parser and then exits. By default a help action is automatically added to the parser. See for details of how the output is created.\n• None - This expects a keyword argument in the call, and prints version information and exits when invoked: Only actions that consume command-line arguments (e.g. , or ) can be used with positional arguments. You may also specify an arbitrary action by passing an subclass or other object that implements the same interface. The is available in and adds support for boolean actions such as and : The recommended way to create a custom action is to extend , overriding the method and optionally the and methods. You can also register custom actions using the method and reference them by their registered name. An example of a custom action: For more details, see . objects usually associate a single command-line argument with a single action to be taken. The keyword argument associates a different number of command-line arguments with a single action. See also Specifying ambiguous arguments. The supported values are:\n• None (an integer). arguments from the command line will be gathered together into a list. For example: Note that produces a list of one item. This is different from the default, in which the item is produced by itself.\n• None . One argument will be consumed from the command line if possible, and produced as a single item. If no command-line argument is present, the value from default will be produced. Note that for optional arguments, there is an additional case - the option string is present but not followed by a command-line argument. In this case the value from const will be produced. Some examples to illustrate this: One of the more common uses of is to allow optional input and output files:\n• None . All command-line arguments present are gathered into a list. Note that it generally doesn’t make much sense to have more than one positional argument with , but multiple optional arguments with is possible. For example:\n• None . Just like , all command-line args present are gathered into a list. Additionally, an error message will be generated if there wasn’t at least one command-line argument present. For example: PROG: error: the following arguments are required: foo If the keyword argument is not provided, the number of arguments consumed is determined by the action. Generally this means a single command-line argument will be consumed and a single item (not a list) will be produced. Actions that do not consume command-line arguments (e.g. ) set . The argument of is used to hold constant values that are not read from the command line but are required for the various actions. The two most common uses of it are:\n• None When is called with or . These actions add the value to one of the attributes of the object returned by . See the action description for examples. If is not provided to , it will receive a default value of .\n• None When is called with option strings (like or ) and . This creates an optional argument that can be followed by zero or one command-line arguments. When parsing the command line, if the option string is encountered with no command-line argument following it, the value of will be assumed to be instead. See the nargs description for examples. Changed in version 3.11: by default, including when or . All optional arguments and some positional arguments may be omitted at the command line. The keyword argument of , whose value defaults to , specifies what value should be used if the command-line argument is not present. For optional arguments, the value is used when the option string was not present at the command line: If the target namespace already has an attribute set, the action default will not overwrite it: If the value is a string, the parser parses the value as if it were a command-line argument. In particular, the parser applies any type conversion argument, if provided, before setting the attribute on the return value. Otherwise, the parser uses the value as is: For positional arguments with nargs equal to or , the value is used when no command-line argument was present: For required arguments, the value is ignored. For example, this applies to positional arguments with nargs values other than or , or optional arguments marked as . Providing causes no attribute to be added if the command-line argument was not present: By default, the parser reads command-line arguments in as simple strings. However, quite often the command-line string should instead be interpreted as another type, such as a or . The keyword for allows any necessary type-checking and type conversions to be performed. If the type keyword is used with the default keyword, the type converter is only applied if the default is a string. The argument to can be a callable that accepts a single string or the name of a registered type (see ) If the function raises , , or , the exception is caught and a nicely formatted error message is displayed. Other exception types are not handled. Common built-in types and functions can be used as type converters: User defined functions can be used as well: '\"The Tale of Two Cities\"' The function is not recommended as a type converter. All it does is convert empty strings to and non-empty strings to . This is usually not what is desired. In general, the keyword is a convenience that should only be used for simple conversions that can only raise one of the three supported exceptions. Anything with more interesting error-handling or resource management should be done downstream after the arguments are parsed. For example, JSON or YAML conversions have complex error cases that require better reporting than can be given by the keyword. A would not be well formatted and a exception would not be handled at all. Even has its limitations for use with the keyword. If one argument uses and then a subsequent argument fails, an error is reported but the file is not automatically closed. In this case, it would be better to wait until after the parser has run and then use the -statement to manage the files. For type checkers that simply check against a fixed set of values, consider using the choices keyword instead. Some command-line arguments should be selected from a restricted set of values. These can be handled by passing a sequence object as the choices keyword argument to . When the command line is parsed, argument values will be checked, and an error message will be displayed if the argument was not one of the acceptable values: Note that inclusion in the choices sequence is checked after any type conversions have been performed, so the type of the objects in the choices sequence should match the type specified. Any sequence can be passed as the choices value, so objects, objects, and custom sequences are all supported. Use of is not recommended because it is difficult to control its appearance in usage, help, and error messages. Formatted choices override the default metavar which is normally derived from dest. This is usually what you want because the user never sees the dest parameter. If this display isn’t desirable (perhaps because there are many choices), just specify an explicit metavar. In general, the module assumes that flags like and indicate optional arguments, which can always be omitted at the command line. To make an option required, can be specified for the keyword argument to : : error: the following arguments are required: --foo As the example shows, if an option is marked as , will report an error if that option is not present at the command line. Required options are generally considered bad form because users expect options to be optional, and thus they should be avoided when possible. The value is a string containing a brief description of the argument. When a user requests help (usually by using or at the command line), these descriptions will be displayed with each argument. The strings can include various format specifiers to avoid repetition of things like the program name or the argument default. The available specifiers include the program name, and most keyword arguments to , e.g. , , etc.: -h, --help show this help message and exit As the help string supports %-formatting, if you want a literal to appear in the help string, you must escape it as . supports silencing the help entry for certain options, by setting the value to : -h, --help show this help message and exit When generates help messages, it needs some way to refer to each expected argument. By default, objects use the dest value as the “name” of each object. By default, for positional argument actions, the dest value is used directly, and for optional argument actions, the dest value is uppercased. So, a single positional argument with will be referred to as . A single optional argument that should be followed by a single command-line argument will be referred to as . An example: -h, --help show this help message and exit An alternative name can be specified with : -h, --help show this help message and exit Note that only changes the displayed name - the name of the attribute on the object is still determined by the dest value. Different values of may cause the metavar to be used multiple times. Providing a tuple to specifies a different display for each of the arguments: -h, --help show this help message and exit Most actions add some value as an attribute of the object returned by . The name of this attribute is determined by the keyword argument of . For positional argument actions, is normally supplied as the first argument to : For optional argument actions, the value of is normally inferred from the option strings. generates the value of by taking the first long option string and stripping away the initial string. If no long option strings were supplied, will be derived from the first short option string by stripping the initial character. Any internal characters will be converted to characters to make sure the string is a valid attribute name. The examples below illustrate this behavior: allows a custom attribute name to be provided: During a project’s lifetime, some arguments may need to be removed from the command line. Before removing them, you should inform your users that the arguments are deprecated and will be removed. The keyword argument of , which defaults to , specifies if the argument is deprecated and will be removed in the future. For arguments, if is , then a warning will be printed to when the argument is used: classes implement the Action API, a callable which returns a callable which processes arguments from the command-line. Any object which follows this API may be passed as the parameter to . objects are used by an to represent the information needed to parse a single argument from one or more strings from the command line. The class must accept the two positional arguments plus any keyword arguments passed to except for the itself. Instances of (or return value of any callable to the parameter) should have attributes , , , , , , etc. defined. The easiest way to ensure these attributes are defined is to call . instances should be callable, so subclasses must override the method, which should accept four parameters:\n• None parser - The object which contains this action.\n• None namespace - The object that will be returned by . Most actions add an attribute to this object using .\n• None values - The associated command-line arguments, with any type conversions applied. Type conversions are specified with the type keyword argument to .\n• None option_string - The option string that was used to invoke this action. The argument is optional, and will be absent if the action is associated with a positional argument. The method may perform arbitrary actions, but will typically set attributes on the based on and . subclasses can define a method that takes no argument and return a string which will be used when printing the usage of the program. If such method is not provided, a sensible default will be used.\n\nConvert argument strings to objects and assign them as attributes of the namespace. Return the populated namespace. Previous calls to determine exactly what objects are created and how they are assigned. See the documentation for for details.\n• None args - List of strings to parse. The default is taken from .\n• None namespace - An object to take the attributes. The default is a new empty object. The method supports several ways of specifying the value of an option (if it takes one). In the simplest case, the option and its value are passed as two separate arguments: For long options (options with names longer than a single character), the option and value can also be passed as a single command-line argument, using to separate them: For short options (options only one character long), the option and its value can be concatenated: Several short options can be joined together, using only a single prefix, as long as only the last option (or none of them) requires a value: While parsing the command line, checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc. When it encounters such an error, it exits and prints the error along with a usage message: The method attempts to give errors whenever the user has clearly made a mistake, but some situations are inherently ambiguous. For example, the command-line argument could either be an attempt to specify an option or an attempt to provide a positional argument. The method is cautious here: positional arguments may only begin with if they look like negative numbers and there are no options in the parser that look like negative numbers: # no negative number options, so -1 is a positional argument # no negative number options, so -1 and -5 are positional arguments # negative number options present, so -1 is an option # negative number options present, so -2 is an option # negative number options present, so both -1s are options If you have positional arguments that must begin with and don’t look like negative numbers, you can insert the pseudo-argument which tells that everything after that is a positional argument: See also the argparse howto on ambiguous arguments for more details. The method by default allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option): An error is produced for arguments that could produce more than one options. This feature can be disabled by setting allow_abbrev to . Sometimes it may be useful to have an parse arguments other than those of . This can be accomplished by passing a list of strings to . This is useful for testing at the interactive prompt: 'an integer in the range 0..9' Simple class used by default by to create an object holding attributes and return it. This class is deliberately simple, just an subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, : It may also be useful to have an assign attributes to an already existing object, rather than a new object. This can be achieved by specifying the keyword argument:\n\nMany programs split up their functionality into a number of subcommands, for example, the program can invoke subcommands like , , and . Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. supports the creation of such subcommands with the method. The method is normally called with no arguments and returns a special action object. This object has a single method, , which takes a command name and any constructor arguments, and returns an object that can be modified as usual.\n• None title - title for the sub-parser group in help output; by default “subcommands” if description is provided, otherwise uses title for positional arguments\n• None description - description for the sub-parser group in help output, by default\n• None prog - usage information that will be displayed with sub-command help, by default the name of the program and any positional arguments before the subparser argument\n• None parser_class - class which will be used to create sub-parser instances, by default the class of the current parser (e.g. )\n• None action - the basic type of action to be taken when this argument is encountered at the command line\n• None dest - name of the attribute under which sub-command name will be stored; by default and no value is stored\n• None required - Whether or not a subcommand must be provided, by default (added in 3.7)\n• None help - help for sub-parser group in help output, by default\n• None metavar - string presenting available subcommands in help; by default it is and presents subcommands in form {cmd1, cmd2, ..} # create the parser for the \"a\" command # create the parser for the \"b\" command Note that the object returned by will only contain attributes for the main parser and the subparser that was selected by the command line (and not any other subparsers). So in the example above, when the command is specified, only the and attributes are present, and when the command is specified, only the and attributes are present. Similarly, when a help message is requested from a subparser, only the help for that particular parser will be printed. The help message will not include parent parser or sibling parser messages. (A help message for each subparser command, however, can be given by supplying the argument to as above.) -h, --help show this help message and exit -h, --help show this help message and exit -h, --help show this help message and exit The method also supports and keyword arguments. When either is present, the subparser’s commands will appear in their own group in the help output. For example: -h, --help show this help message and exit Furthermore, supports an additional aliases argument, which allows multiple strings to refer to the same subparser. This example, like , aliases as a shorthand for : supports also an additional deprecated argument, which allows to deprecate the subparser. One particularly effective way of handling subcommands is to combine the use of the method with calls to so that each subparser knows which Python function it should execute. For example: # create the parser for the \"foo\" command # create the parser for the \"bar\" command # parse the args and call whatever function was selected # parse the args and call whatever function was selected This way, you can let do the job of calling the appropriate function after argument parsing is complete. Associating functions with actions like this is typically the easiest way to handle the different actions for each of your subparsers. However, if it is necessary to check the name of the subparser that was invoked, the keyword argument to the call will work: The factory creates objects that can be passed to the type argument of . Arguments that have objects as their type will open command-line arguments as files with the requested modes, buffer sizes, encodings and error handling (see the function for more details): FileType objects understand the pseudo-argument and automatically convert this into for readable objects and for writable objects: Changed in version 3.4: Added the encodings and errors parameters. By default, groups command-line arguments into “positional arguments” and “options” when displaying help messages. When there is a better conceptual grouping of arguments than this default one, appropriate groups can be created using the method: The method returns an argument group object which has an method just like a regular . When an argument is added to the group, the parser treats it just like a normal argument, but displays the argument in a separate group for help messages. The method accepts title and description arguments which can be used to customize this display: The optional, keyword-only parameters argument_default and conflict_handler allow for finer-grained control of the behavior of the argument group. These parameters have the same meaning as in the constructor, but apply specifically to the argument group rather than the entire parser. Note that any arguments not in your user-defined groups will end up back in the usual “positional arguments” and “optional arguments” sections. Changed in version 3.11: Calling on an argument group is deprecated. This feature was never supported and does not always work correctly. The function exists on the API by accident through inheritance and will be removed in the future. Create a mutually exclusive group. will make sure that only one of the arguments in the mutually exclusive group was present on the command line: The method also accepts a required argument, to indicate that at least one of the mutually exclusive arguments is required: PROG: error: one of the arguments --foo --bar is required Note that currently mutually exclusive argument groups do not support the title and description arguments of . However, a mutually exclusive group can be added to an argument group that has a title and description. For example: -h, --help show this help message and exit Changed in version 3.11: Calling or on a mutually exclusive group is deprecated. These features were never supported and do not always work correctly. The functions exist on the API by accident through inheritance and will be removed in the future. Most of the time, the attributes of the object returned by will be fully determined by inspecting the command-line arguments and the argument actions. allows some additional attributes that are determined without any inspection of the command line to be added: Parser-level defaults can be particularly useful when working with multiple parsers. See the method for an example of this type. Get the default value for a namespace attribute, as set by either or by : In most typical applications, will take care of formatting and printing any usage or error messages. However, several formatting methods are available: Print a brief description of how the should be invoked on the command line. If file is , is assumed. Print a help message, including the program usage and information about the arguments registered with the . If file is , is assumed. There are also variants of these methods that simply return a string instead of printing it: Return a string containing a brief description of how the should be invoked on the command line. Return a string containing a help message, including the program usage and information about the arguments registered with the . Sometimes a script may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the method can be useful. It works much like except that it does not produce an error when extra arguments are present. Instead, it returns a two item tuple containing the populated namespace and the list of remaining argument strings. Prefix matching rules apply to . The parser may consume an option even if it’s just a prefix of one of its known options, instead of leaving it in the remaining arguments list. Arguments that are read from a file (see the fromfile_prefix_chars keyword argument to the constructor) are read one argument per line. can be overridden for fancier reading. This method takes a single argument arg_line which is a string read from the argument file. It returns a list of arguments parsed from this string. The method is called once per line read from the argument file, in order. A useful override of this method is one that treats each space-separated word as an argument. The following example demonstrates how to do this: This method terminates the program, exiting with the specified status and, if given, it prints a message to before that. The user can override this method to handle these steps differently: 'Exiting because of an error: This method prints a usage message, including the message, to and terminates the program with a status code of 2. A number of Unix commands allow the user to intermix optional arguments with positional arguments. The and methods support this parsing style. These parsers do not support all the features, and will raise exceptions if unsupported features are used. In particular, subparsers, and mutually exclusive groups that include both optionals and positionals are not supported. The following example shows the difference between and : the former returns as unparsed arguments, while the latter collects all the positionals into . returns a two item tuple containing the populated namespace and the list of remaining argument strings. raises an error if there are any remaining unparsed argument strings. Sometimes it’s desirable to use a custom string in error messages to provide more user-friendly output. In these cases, can be used to register custom actions or types with a parser and allow you to reference the type by their registered name instead of their callable name. The method accepts three arguments - a registry_name, specifying the internal registry where the object will be stored (e.g., , ), value, which is the key under which the object will be registered, and object, the callable to be registered. The following example shows how to register a custom type with a parser:"
    },
    {
        "link": "https://docs.python.org/3/howto/argparse.html",
        "document": "This tutorial is intended to be a gentle introduction to , the recommended command-line parsing module in the Python standard library.\n\nLet’s show the sort of functionality that we are going to explore in this introductory tutorial by making use of the ls command: ls ls pypy ls -l ls --help List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. A few concepts we can learn from the four commands:\n• None The ls command is useful when run without any options at all. It defaults to displaying the contents of the current directory.\n• None If we want beyond what it provides by default, we tell it a bit more. In this case, we want it to display a different directory, . What we did is specify what is known as a positional argument. It’s named so because the program should know what to do with the value, solely based on where it appears on the command line. This concept is more relevant to a command like cp, whose most basic usage is . The first position is what you want copied, and the second position is where you want it copied to.\n• None Now, say we want to change behaviour of the program. In our example, we display more info for each file instead of just showing the file names. The in that case is known as an optional argument.\n• None That’s a snippet of the help text. It’s very useful in that you can come across a program you have never used before, and can figure out how it works simply by reading its help text.\n\nLet us start with a very simple example which does (almost) nothing: Following is a result of running the code: python prog.py python prog.py --help -h, --help show this help message and exit python prog.py --verbose python prog.py foo Here is what is happening:\n• None Running the script without any options results in nothing displayed to stdout. Not so useful.\n• None The second one starts to display the usefulness of the module. We have done almost nothing, but already we get a nice help message.\n• None The option, which can also be shortened to , is the only option we get for free (i.e. no need to specify it). Specifying anything else results in an error. But even then, we do get a useful usage message, also for free.\n\npython prog.py prog.py: error: the following arguments are required: echo python prog.py --help -h, --help show this help message and exit python prog.py foo\n• None We’ve added the method, which is what we use to specify which command-line options the program is willing to accept. In this case, I’ve named it so that it’s in line with its function.\n• None Calling our program now requires us to specify an option.\n• None The method actually returns some data from the options specified, in this case, .\n• None The variable is some form of ‘magic’ that performs for free (i.e. no need to specify which variable that value is stored in). You will also notice that its name matches the string argument given to the method, . Note however that, although the help display looks nice and all, it currently is not as helpful as it can be. For example we see that we got as a positional argument, but we don’t know what it does, other than by guessing or by reading the source code. So, let’s make it a bit more useful: \"echo the string you use here\" python prog.py -h echo echo the string you use here -h, --help show this help message and exit Now, how about doing something even more useful: Following is a result of running the code: python prog.py TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int' That didn’t go so well. That’s because treats the options we give it as strings, unless we tell it otherwise. So, let’s tell to treat that input as an integer: Following is a result of running the code: That went well. The program now even helpfully quits on bad illegal input before proceeding.\n\nSo far we have been playing with positional arguments. Let us have a look on how to add optional ones: python prog.py --verbosity python prog.py python prog.py --help -h, --help show this help message and exit python prog.py --verbosity Here is what is happening:\n• None The program is written so as to display something when is specified and display nothing when not.\n• None To show that the option is actually optional, there is no error when running the program without it. Note that by default, if an optional argument isn’t used, the relevant variable, in this case , is given as a value, which is the reason it fails the truth test of the statement.\n• None The help message is a bit different.\n• None When using the option, one must also specify some value, any value. The above example accepts arbitrary integer values for , but for our simple program, only two values are actually useful, or . Let’s modify the code accordingly: python prog.py --verbose python prog.py --verbose python prog.py --help -h, --help show this help message and exit Here is what is happening:\n• None The option is now more of a flag than something that requires a value. We even changed the name of the option to match that idea. Note that we now specify a new keyword, , and give it the value . This means that, if the option is specified, assign the value to . Not specifying it implies .\n• None It complains when you specify a value, in true spirit of what flags actually are.\n• None Notice the different help text. If you are familiar with command line usage, you will notice that I haven’t yet touched on the topic of short versions of the options. It’s quite simple: python prog.py -v python prog.py --help -h, --help show this help message and exit Note that the new ability is also reflected in the help text.\n\nOur program keeps growing in complexity: python prog.py prog.py: error: the following arguments are required: square python prog.py python prog.py --verbose python prog.py --verbose\n• None Note that the order does not matter. How about we give this program of ours back the ability to have multiple verbosity values, and actually get to use them: These all look good except the last one, which exposes a bug in our program. Let’s fix it by restricting the values the option can accept: python prog.py -v python prog.py -h -h, --help show this help message and exit Note that the change also reflects both in the error message as well as the help string. Now, let’s use a different approach of playing with verbosity, which is pretty common. It also matches the way the CPython executable handles its own verbosity argument (check the output of ): \"display the square of a given number\" We have introduced another action, “count”, to count the number of occurrences of specific options. python prog.py python prog.py -v python prog.py -vv python prog.py --verbosity --verbosity python prog.py -v python prog.py -h -h, --help show this help message and exit python prog.py -vvv\n• None Yes, it’s now more of a flag (similar to ) in the previous version of our script. That should explain the complaint.\n• None It also behaves similar to “store_true” action.\n• None Now here’s a demonstration of what the “count” action gives. You’ve probably seen this sort of usage before.\n• None And if you don’t specify the flag, that flag is considered to have value.\n• None As should be expected, specifying the long form of the flag, we should get the same output.\n• None Sadly, our help output isn’t very informative on the new ability our script has acquired, but that can always be fixed by improving the documentation for our script (e.g. via the keyword argument).\n• None That last output exposes a bug in our program. And this is what it gives: python prog.py -vvv python prog.py -vvvv python prog.py TypeError: '>=' not supported between instances of 'NoneType' and 'int'\n• None First output went well, and fixes the bug we had before. That is, we want any value >= 2 to be as verbose as possible.\n• None Third output not so good. We’ve just introduced yet another keyword, . We’ve set it to in order to make it comparable to the other int values. Remember that by default, if an optional argument isn’t specified, it gets the value, and that cannot be compared to an int value (hence the exception). You can go quite far just with what we’ve learned so far, and we have only scratched the surface. The module is very powerful, and we’ll explore a bit more of it before we end this tutorial.\n\nGetting a little more advanced¶ What if we wanted to expand our tiny program to perform other powers, not just squares: python prog.py prog.py: error: the following arguments are required: x, y python prog.py -h -h, --help show this help message and exit python prog.py -v Notice that so far we’ve been using verbosity level to change the text that gets displayed. The following example instead uses verbosity level to display more text instead: When there is ambiguity in deciding whether an argument is positional or for an argument, can be used to tell that everything after that is a positional argument: # ambiguous, so parse_args assumes it's an option So far, we have been working with two methods of an instance. Let’s introduce a third one, . It allows for us to specify options that conflict with each other. Let’s also change the rest of the program so that the new functionality makes more sense: we’ll introduce the option, which will be the opposite of the one: Our program is now simpler, and we’ve lost some functionality for the sake of demonstration. Anyways, here’s the output: That should be easy to follow. I’ve added that last output so you can see the sort of flexibility you get, i.e. mixing long form options with short form ones. Before we conclude, you probably want to tell your users the main purpose of your program, just in case they don’t know: \"calculate X to the power of Y\" Note that slight difference in the usage text. Note the , which tells us that we can either use or , but not both at the same time: python prog.py --help calculate X to the power of Y -h, --help show this help message and exit\n\nHow to translate the argparse output¶ The output of the module such as its help text and error messages are all made translatable using the module. This allows applications to easily localize messages produced by . See also Internationalizing your programs and modules. For instance, in this output: python prog.py --help calculate X to the power of Y -h, --help show this help message and exit The strings , , and show this help message and exit are all translatable. In order to translate these strings, they must first be extracted into a file. For example, using Babel, run this command: This command will extract all translatable strings from the module and output them into a file named . This command assumes that your Python installation is in . You can find out the location of the module on your system using this script: Once the messages in the file are translated and the translations are installed using , will be able to display the translated messages. To translate your own strings in the output, use .\n\nThe module allows you to specify custom type converters for your command-line arguments. This allows you to modify user input before it’s stored in the . This can be useful when you need to pre-process the input before it is used in your program. When using a custom type converter, you can use any callable that takes a single string argument (the argument value) and returns the converted value. However, if you need to handle more complex scenarios, you can use a custom action class with the action parameter instead. For example, let’s say you want to handle arguments with different prefixes and process them accordingly:\n• None Created a parser with custom prefix characters using the parameter.\n• None Defined two arguments, and , which used the parameter to create custom type converters to store the value in a tuple with the prefix. Without the custom type converters, the arguments would have treated the and as the same argument, which would have been undesirable. By using custom type converters, we were able to differentiate between the two arguments."
    },
    {
        "link": "https://docs.python.org/ko/3.13/library/argparse.html",
        "document": "를 로 전달하는 것은 description 과 epilog 가 이미 올바르게 포맷되어 있어서 줄 바꿈 되어서는 안 된다는 것을 가리킵니다: 파일에서 읽은 인자는 기본적으로 한 줄에 하나씩 있어야 하고 (하지만 도 참조하십시오), 명령행에서 원래 파일을 참조하는 인자와 같은 위치에 있는 것처럼 처리됩니다. 위의 예에서 표현식 는 와 동등하게 취급됩니다. 일반적으로 인자의 기본값은 에 기본값을 전달하거나 특정 이름-값 쌍 집합을 사용하여 메서드를 호출하여 지정됩니다. 그러나 때로는, 파서 전체에 적용되는 단일 기본값을 지정하는 것이 유용 할 수 있습니다. 이것은 키워드 인자를 에 전달함으로써 이루어질 수 있습니다. 예를 들어, 호출에서 어트리뷰트 생성을 전역적으로 억제하려면, 를 제공합니다: 를 로 설정하면 이 기능을 비활성화 할 수 있습니다: 때로는 (예를 들어 parents 를 사용하는 경우) 같은 옵션 문자열을 갖는 예전의 인자들을 간단히 대체하는 것이 유용 할 수 있습니다. 이 동작을 얻으려면, 의 인자에 값을 제공합니다: 때에 따라, 이 도움말 옵션을 추가하지 않도록 설정하는 것이 유용 할 수 있습니다. 인자를 로 에 전달하면 됩니다: 도움말 옵션은 일반적으로 입니다. 예외는 가 지정되고 을 포함하지 않는 경우입니다. 이 경우 와 는 유효한 옵션이 아닙니다. 이 경우, 의 첫 번째 문자가 도움말 옵션 접두어로 사용됩니다:\n• None . 가능하다면 한 인자가 명령행에서 소비되고 단일 항목으로 생성됩니다. 명령행 인자가 없으면 default 의 값이 생성됩니다. 선택 인자의 경우 추가적인 경우가 있습니다 - 옵션 문자열은 있지만, 명령행 인자가 따라붙지 않는 경우입니다. 이 경우 const 의 값이 생성됩니다. 이것을 보여주기 위해 몇 가지 예를 듭니다: 기본적으로, 파서는 명령행 인자를 간단한 문자열로 읽습니다. 그러나 꽤 자주 명령행 문자열은 나 와 같은 다른 형으로 해석되어야 합니다. 의 키워드는 필요한 형 검사와 형 변환이 수행되도록 합니다. 문자열은 프로그램 이름이나 인자 default 와 같은 것들의 반복을 피하고자 다양한 포맷 지정자를 포함 할 수 있습니다. 사용할 수 있는 지정자는 프로그램 이름, 와 의 대부분의 키워드 인자, , 등을 포함합니다.: 대부분 액션은 에 의해 반환된 객체의 어트리뷰트로 어떤 값을 추가합니다. 이 어트리뷰트의 이름은 의 키워드 인자에 의해 결정됩니다. 위치 인자 액션의 경우, 는 일반적으로 에 첫 번째 인자로 제공됩니다.: 선택 인자 액션의 경우, 의 값은 보통 옵션 문자열에서 유추됩니다. 는 첫 번째 긴 옵션 문자열을 취하고 앞의 문자열을 제거하여 의 값을 만듭니다. 긴 옵션 문자열이 제공되지 않았다면 는 첫 번째 짧은 옵션 문자열에서 앞의 문자를 제거하여 만듭니다. 문자열이 항상 유효한 어트리뷰트 이름이 되도록 만들기 위해 중간에 나오는 문자는 문자로 변환됩니다. 아래 예제는 이 동작을 보여줍니다:\n\n로 시작해야 하고, 음수처럼 보이지 않는 위치 인자가 있는 경우, 에 다음과 같은 의사 인자 를 삽입 할 수 있습니다. 그 이후의 모든 것은 위치 인자입니다:"
    },
    {
        "link": "https://pypi.org/project/argparse",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://cs.unb.ca/~bremner/teaching/cs2613/books/python3-doc/library/argparse.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse",
        "document": "I would like to use argparse to parse boolean command-line arguments written as \"--foo True\" or \"--foo False\". For example: However, the following test code does not do what I would like: Sadly, evaluates to . This is the case even when I change to be , which is surprising, since evalutates to . How can I get argparse to parse , , and their lower-case variants to be ?"
    },
    {
        "link": "https://docs.python.org/3/library/argparse.html",
        "document": "The module makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and will figure out how to parse those out of . The module also automatically generates help and usage messages. The module will also issue errors when users give the program invalid arguments.\n\nThe module’s support for command-line interfaces is built around an instance of . It is a container for argument specifications and has options that apply to the parser as whole:\n\nThe method attaches individual argument specifications to the parser. It supports positional arguments, options that accept values, and on/off flags:\n\nThe method runs the parser and places the extracted data in a object:\n\nCreate a new object. All parameters should be passed as keyword arguments. Each parameter has its own more detailed description below, but in short they are:\n• None prog - The name of the program (default: )\n• None usage - The string describing the program usage (default: generated from arguments added to parser)\n• None description - Text to display before the argument help (by default, no text)\n• None epilog - Text to display after the argument help (by default, no text)\n• None parents - A list of objects whose arguments should also be included\n• None formatter_class - A class for customizing the help output\n• None prefix_chars - The set of characters that prefix optional arguments (default: ‘-‘)\n• None fromfile_prefix_chars - The set of characters that prefix files from which additional arguments should be read (default: )\n• None argument_default - The global default value for arguments (default: )\n• None conflict_handler - The strategy for resolving conflicting optionals (usually unnecessary)\n• None allow_abbrev - Allows long options to be abbreviated if the abbreviation is unambiguous. (default: )\n• None exit_on_error - Determines whether or not exits with error info when an error occurs. (default: ) Changed in version 3.8: In previous versions, allow_abbrev also disabled grouping of short flags such as to mean . The following sections describe how each of these are used. By default, calculates the name of the program to display in help messages depending on the way the Python interpreter was run:\n• None The of if a file was passed as argument.\n• None The Python interpreter name followed by if a directory or a zipfile was passed as argument.\n• None The Python interpreter name followed by followed by the module or package name if the option was used. This default is almost always desirable because it will make the help messages match the string that was used to invoke the program on the command line. However, to change this default behavior, another value can be supplied using the argument to : -h, --help show this help message and exit Note that the program name, whether determined from or from the argument, is available to help messages using the format specifier. -h, --help show this help message and exit By default, calculates the usage message from the arguments it contains. The default message can be overridden with the keyword argument: -h, --help show this help message and exit The format specifier is available to fill in the program name in your usage messages. Most calls to the constructor will use the keyword argument. This argument gives a brief description of what the program does and how it works. In help messages, the description is displayed between the command-line usage string and the help messages for the various arguments. By default, the description will be line-wrapped so that it fits within the given space. To change this behavior, see the formatter_class argument. Some programs like to display additional description of the program after the description of the arguments. Such text can be specified using the argument to : \"And that's how you'd foo a bar\" -h, --help show this help message and exit And that's how you'd foo a bar As with the description argument, the text is by default line-wrapped, but this behavior can be adjusted with the formatter_class argument to . Sometimes, several parsers share a common set of arguments. Rather than repeating the definitions of these arguments, a single parser with all the shared arguments and passed to argument to can be used. The argument takes a list of objects, collects all the positional and optional actions from them, and adds these actions to the object being constructed: Note that most parent parsers will specify . Otherwise, the will see two options (one in the parent and one in the child) and raise an error. You must fully initialize the parsers before passing them via . If you change the parent parsers after the child parser, those changes will not be reflected in the child. objects allow the help formatting to be customized by specifying an alternate formatting class. Currently, there are four such classes: and give more control over how textual descriptions are displayed. By default, objects line-wrap the description and epilog texts in command-line help messages: likewise for this epilog whose whitespace will be cleaned up and whose words will be wrapped this description was indented weird but that is okay -h, --help show this help message and exit likewise for this epilog whose whitespace will be cleaned up and whose words will be wrapped across a couple lines Passing as indicates that description and epilog are already correctly formatted and should not be line-wrapped: Please do not mess up this text! Please do not mess up this text! -h, --help show this help message and exit maintains whitespace for all sorts of help text, including argument descriptions. However, multiple newlines are replaced with one. If you wish to preserve multiple blank lines, add spaces between the newlines. automatically adds information about default values to each of the argument help messages: -h, --help show this help message and exit uses the name of the type argument for each argument as the display name for its values (rather than using the dest as the regular formatter does): -h, --help show this help message and exit Most command-line options will use as the prefix, e.g. . Parsers that need to support different or additional prefix characters, e.g. for options like or , may specify them using the argument to the constructor: The argument defaults to . Supplying a set of characters that does not include will cause options to be disallowed. Sometimes, when dealing with a particularly long argument list, it may make sense to keep the list of arguments in a file rather than typing it out at the command line. If the argument is given to the constructor, then arguments that start with any of the specified characters will be treated as files, and will be replaced by the arguments they contain. For example: Arguments read from a file must by default be one per line (but see also ) and are treated as if they were in the same place as the original file referencing argument on the command line. So in the example above, the expression is considered equivalent to the expression . uses filesystem encoding and error handler to read the file containing arguments. The argument defaults to , meaning that arguments will never be treated as file references. Changed in version 3.12: changed encoding and errors to read arguments files from default (e.g. and ) to the filesystem encoding and error handler. Arguments file should be encoded in UTF-8 instead of ANSI Codepage on Windows. Generally, argument defaults are specified either by passing a default to or by calling the methods with a specific set of name-value pairs. Sometimes however, it may be useful to specify a single parser-wide default for arguments. This can be accomplished by passing the keyword argument to . For example, to globally suppress attribute creation on calls, we supply : Normally, when you pass an argument list to the method of an , it recognizes abbreviations of long options. This feature can be disabled by setting to : objects do not allow two actions with the same option string. By default, objects raise an exception if an attempt is made to create an argument with an option string that is already in use: Sometimes (e.g. when using parents) it may be useful to simply override any older arguments with the same option string. To get this behavior, the value can be supplied to the argument of : -h, --help show this help message and exit Note that objects only remove an action if all of its option strings are overridden. So, in the example above, the old action is retained as the action, because only the option string was overridden. By default, objects add an option which simply displays the parser’s help message. If or is supplied at the command line, the help will be printed. Occasionally, it may be useful to disable the addition of this help option. This can be achieved by passing as the argument to : The help option is typically . The exception to this is if the is specified and does not include , in which case and are not valid options. In this case, the first character in is used to prefix the help options: +h, ++help show this help message and exit Normally, when you pass an invalid argument list to the method of an , it will print a message to and exit with a status code of 2. If the user would like to catch errors manually, the feature can be enabled by setting to :\n\nDefine how a single command-line argument should be parsed. Each parameter has its own more detailed description below, but in short they are:\n• None name or flags - Either a name or a list of option strings, e.g. or .\n• None action - The basic type of action to be taken when this argument is encountered at the command line.\n• None nargs - The number of command-line arguments that should be consumed.\n• None const - A constant value required by some action and nargs selections.\n• None default - The value produced if the argument is absent from the command line and if it is absent from the namespace object.\n• None type - The type to which the command-line argument should be converted.\n• None choices - A sequence of the allowable values for the argument.\n• None required - Whether or not the command-line option may be omitted (optionals only).\n• None help - A brief description of what the argument does.\n• None metavar - A name for the argument in usage messages.\n• None dest - The name of the attribute to be added to the object returned by .\n• None deprecated - Whether or not use of the argument is deprecated. The following sections describe how each of these are used. The method must know whether an optional argument, like or , or a positional argument, like a list of filenames, is expected. The first arguments passed to must therefore be either a series of flags, or a simple argument name. For example, an optional argument could be created like: while a positional argument could be created like: When is called, optional arguments will be identified by the prefix, and the remaining arguments will be assumed to be positional: PROG: error: the following arguments are required: bar objects associate command-line arguments with actions. These actions can do just about anything with the command-line arguments associated with them, though most actions simply add an attribute to the object returned by . The keyword argument specifies how the command-line arguments should be handled. The supplied actions are:\n• None - This just stores the argument’s value. This is the default action.\n• None - This stores the value specified by the const keyword argument; note that the const keyword argument defaults to . The action is most commonly used with optional arguments that specify some sort of flag. For example:\n• None and - These are special cases of used for storing the values and respectively. In addition, they create default values of and respectively:\n• None - This stores a list, and appends each argument value to the list. It is useful to allow an option to be specified multiple times. If the default value is non-empty, the default elements will be present in the parsed value for the option, with any values from the command line appended after those default values. Example usage:\n• None - This stores a list, and appends the value specified by the const keyword argument to the list; note that the const keyword argument defaults to . The action is typically useful when multiple arguments need to store constants to the same list. For example:\n• None - This stores a list and appends each item from the multi-value argument list to it. The action is typically used with the nargs keyword argument value or . Note that when nargs is (the default) or , each character of the argument string will be appended to the list. Example usage:\n• None - This counts the number of times a keyword argument occurs. For example, this is useful for increasing verbosity levels: Note, the default will be unless explicitly set to 0.\n• None - This prints a complete help message for all the options in the current parser and then exits. By default a help action is automatically added to the parser. See for details of how the output is created.\n• None - This expects a keyword argument in the call, and prints version information and exits when invoked: Only actions that consume command-line arguments (e.g. , or ) can be used with positional arguments. You may also specify an arbitrary action by passing an subclass or other object that implements the same interface. The is available in and adds support for boolean actions such as and : The recommended way to create a custom action is to extend , overriding the method and optionally the and methods. You can also register custom actions using the method and reference them by their registered name. An example of a custom action: For more details, see . objects usually associate a single command-line argument with a single action to be taken. The keyword argument associates a different number of command-line arguments with a single action. See also Specifying ambiguous arguments. The supported values are:\n• None (an integer). arguments from the command line will be gathered together into a list. For example: Note that produces a list of one item. This is different from the default, in which the item is produced by itself.\n• None . One argument will be consumed from the command line if possible, and produced as a single item. If no command-line argument is present, the value from default will be produced. Note that for optional arguments, there is an additional case - the option string is present but not followed by a command-line argument. In this case the value from const will be produced. Some examples to illustrate this: One of the more common uses of is to allow optional input and output files:\n• None . All command-line arguments present are gathered into a list. Note that it generally doesn’t make much sense to have more than one positional argument with , but multiple optional arguments with is possible. For example:\n• None . Just like , all command-line args present are gathered into a list. Additionally, an error message will be generated if there wasn’t at least one command-line argument present. For example: PROG: error: the following arguments are required: foo If the keyword argument is not provided, the number of arguments consumed is determined by the action. Generally this means a single command-line argument will be consumed and a single item (not a list) will be produced. Actions that do not consume command-line arguments (e.g. ) set . The argument of is used to hold constant values that are not read from the command line but are required for the various actions. The two most common uses of it are:\n• None When is called with or . These actions add the value to one of the attributes of the object returned by . See the action description for examples. If is not provided to , it will receive a default value of .\n• None When is called with option strings (like or ) and . This creates an optional argument that can be followed by zero or one command-line arguments. When parsing the command line, if the option string is encountered with no command-line argument following it, the value of will be assumed to be instead. See the nargs description for examples. Changed in version 3.11: by default, including when or . All optional arguments and some positional arguments may be omitted at the command line. The keyword argument of , whose value defaults to , specifies what value should be used if the command-line argument is not present. For optional arguments, the value is used when the option string was not present at the command line: If the target namespace already has an attribute set, the action default will not overwrite it: If the value is a string, the parser parses the value as if it were a command-line argument. In particular, the parser applies any type conversion argument, if provided, before setting the attribute on the return value. Otherwise, the parser uses the value as is: For positional arguments with nargs equal to or , the value is used when no command-line argument was present: For required arguments, the value is ignored. For example, this applies to positional arguments with nargs values other than or , or optional arguments marked as . Providing causes no attribute to be added if the command-line argument was not present: By default, the parser reads command-line arguments in as simple strings. However, quite often the command-line string should instead be interpreted as another type, such as a or . The keyword for allows any necessary type-checking and type conversions to be performed. If the type keyword is used with the default keyword, the type converter is only applied if the default is a string. The argument to can be a callable that accepts a single string or the name of a registered type (see ) If the function raises , , or , the exception is caught and a nicely formatted error message is displayed. Other exception types are not handled. Common built-in types and functions can be used as type converters: User defined functions can be used as well: '\"The Tale of Two Cities\"' The function is not recommended as a type converter. All it does is convert empty strings to and non-empty strings to . This is usually not what is desired. In general, the keyword is a convenience that should only be used for simple conversions that can only raise one of the three supported exceptions. Anything with more interesting error-handling or resource management should be done downstream after the arguments are parsed. For example, JSON or YAML conversions have complex error cases that require better reporting than can be given by the keyword. A would not be well formatted and a exception would not be handled at all. Even has its limitations for use with the keyword. If one argument uses and then a subsequent argument fails, an error is reported but the file is not automatically closed. In this case, it would be better to wait until after the parser has run and then use the -statement to manage the files. For type checkers that simply check against a fixed set of values, consider using the choices keyword instead. Some command-line arguments should be selected from a restricted set of values. These can be handled by passing a sequence object as the choices keyword argument to . When the command line is parsed, argument values will be checked, and an error message will be displayed if the argument was not one of the acceptable values: Note that inclusion in the choices sequence is checked after any type conversions have been performed, so the type of the objects in the choices sequence should match the type specified. Any sequence can be passed as the choices value, so objects, objects, and custom sequences are all supported. Use of is not recommended because it is difficult to control its appearance in usage, help, and error messages. Formatted choices override the default metavar which is normally derived from dest. This is usually what you want because the user never sees the dest parameter. If this display isn’t desirable (perhaps because there are many choices), just specify an explicit metavar. In general, the module assumes that flags like and indicate optional arguments, which can always be omitted at the command line. To make an option required, can be specified for the keyword argument to : : error: the following arguments are required: --foo As the example shows, if an option is marked as , will report an error if that option is not present at the command line. Required options are generally considered bad form because users expect options to be optional, and thus they should be avoided when possible. The value is a string containing a brief description of the argument. When a user requests help (usually by using or at the command line), these descriptions will be displayed with each argument. The strings can include various format specifiers to avoid repetition of things like the program name or the argument default. The available specifiers include the program name, and most keyword arguments to , e.g. , , etc.: -h, --help show this help message and exit As the help string supports %-formatting, if you want a literal to appear in the help string, you must escape it as . supports silencing the help entry for certain options, by setting the value to : -h, --help show this help message and exit When generates help messages, it needs some way to refer to each expected argument. By default, objects use the dest value as the “name” of each object. By default, for positional argument actions, the dest value is used directly, and for optional argument actions, the dest value is uppercased. So, a single positional argument with will be referred to as . A single optional argument that should be followed by a single command-line argument will be referred to as . An example: -h, --help show this help message and exit An alternative name can be specified with : -h, --help show this help message and exit Note that only changes the displayed name - the name of the attribute on the object is still determined by the dest value. Different values of may cause the metavar to be used multiple times. Providing a tuple to specifies a different display for each of the arguments: -h, --help show this help message and exit Most actions add some value as an attribute of the object returned by . The name of this attribute is determined by the keyword argument of . For positional argument actions, is normally supplied as the first argument to : For optional argument actions, the value of is normally inferred from the option strings. generates the value of by taking the first long option string and stripping away the initial string. If no long option strings were supplied, will be derived from the first short option string by stripping the initial character. Any internal characters will be converted to characters to make sure the string is a valid attribute name. The examples below illustrate this behavior: allows a custom attribute name to be provided: During a project’s lifetime, some arguments may need to be removed from the command line. Before removing them, you should inform your users that the arguments are deprecated and will be removed. The keyword argument of , which defaults to , specifies if the argument is deprecated and will be removed in the future. For arguments, if is , then a warning will be printed to when the argument is used: classes implement the Action API, a callable which returns a callable which processes arguments from the command-line. Any object which follows this API may be passed as the parameter to . objects are used by an to represent the information needed to parse a single argument from one or more strings from the command line. The class must accept the two positional arguments plus any keyword arguments passed to except for the itself. Instances of (or return value of any callable to the parameter) should have attributes , , , , , , etc. defined. The easiest way to ensure these attributes are defined is to call . instances should be callable, so subclasses must override the method, which should accept four parameters:\n• None parser - The object which contains this action.\n• None namespace - The object that will be returned by . Most actions add an attribute to this object using .\n• None values - The associated command-line arguments, with any type conversions applied. Type conversions are specified with the type keyword argument to .\n• None option_string - The option string that was used to invoke this action. The argument is optional, and will be absent if the action is associated with a positional argument. The method may perform arbitrary actions, but will typically set attributes on the based on and . subclasses can define a method that takes no argument and return a string which will be used when printing the usage of the program. If such method is not provided, a sensible default will be used.\n\nConvert argument strings to objects and assign them as attributes of the namespace. Return the populated namespace. Previous calls to determine exactly what objects are created and how they are assigned. See the documentation for for details.\n• None args - List of strings to parse. The default is taken from .\n• None namespace - An object to take the attributes. The default is a new empty object. The method supports several ways of specifying the value of an option (if it takes one). In the simplest case, the option and its value are passed as two separate arguments: For long options (options with names longer than a single character), the option and value can also be passed as a single command-line argument, using to separate them: For short options (options only one character long), the option and its value can be concatenated: Several short options can be joined together, using only a single prefix, as long as only the last option (or none of them) requires a value: While parsing the command line, checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc. When it encounters such an error, it exits and prints the error along with a usage message: The method attempts to give errors whenever the user has clearly made a mistake, but some situations are inherently ambiguous. For example, the command-line argument could either be an attempt to specify an option or an attempt to provide a positional argument. The method is cautious here: positional arguments may only begin with if they look like negative numbers and there are no options in the parser that look like negative numbers: # no negative number options, so -1 is a positional argument # no negative number options, so -1 and -5 are positional arguments # negative number options present, so -1 is an option # negative number options present, so -2 is an option # negative number options present, so both -1s are options If you have positional arguments that must begin with and don’t look like negative numbers, you can insert the pseudo-argument which tells that everything after that is a positional argument: See also the argparse howto on ambiguous arguments for more details. The method by default allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option): An error is produced for arguments that could produce more than one options. This feature can be disabled by setting allow_abbrev to . Sometimes it may be useful to have an parse arguments other than those of . This can be accomplished by passing a list of strings to . This is useful for testing at the interactive prompt: 'an integer in the range 0..9' Simple class used by default by to create an object holding attributes and return it. This class is deliberately simple, just an subclass with a readable string representation. If you prefer to have dict-like view of the attributes, you can use the standard Python idiom, : It may also be useful to have an assign attributes to an already existing object, rather than a new object. This can be achieved by specifying the keyword argument:\n\nMany programs split up their functionality into a number of subcommands, for example, the program can invoke subcommands like , , and . Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. supports the creation of such subcommands with the method. The method is normally called with no arguments and returns a special action object. This object has a single method, , which takes a command name and any constructor arguments, and returns an object that can be modified as usual.\n• None title - title for the sub-parser group in help output; by default “subcommands” if description is provided, otherwise uses title for positional arguments\n• None description - description for the sub-parser group in help output, by default\n• None prog - usage information that will be displayed with sub-command help, by default the name of the program and any positional arguments before the subparser argument\n• None parser_class - class which will be used to create sub-parser instances, by default the class of the current parser (e.g. )\n• None action - the basic type of action to be taken when this argument is encountered at the command line\n• None dest - name of the attribute under which sub-command name will be stored; by default and no value is stored\n• None required - Whether or not a subcommand must be provided, by default (added in 3.7)\n• None help - help for sub-parser group in help output, by default\n• None metavar - string presenting available subcommands in help; by default it is and presents subcommands in form {cmd1, cmd2, ..} # create the parser for the \"a\" command # create the parser for the \"b\" command Note that the object returned by will only contain attributes for the main parser and the subparser that was selected by the command line (and not any other subparsers). So in the example above, when the command is specified, only the and attributes are present, and when the command is specified, only the and attributes are present. Similarly, when a help message is requested from a subparser, only the help for that particular parser will be printed. The help message will not include parent parser or sibling parser messages. (A help message for each subparser command, however, can be given by supplying the argument to as above.) -h, --help show this help message and exit -h, --help show this help message and exit -h, --help show this help message and exit The method also supports and keyword arguments. When either is present, the subparser’s commands will appear in their own group in the help output. For example: -h, --help show this help message and exit Furthermore, supports an additional aliases argument, which allows multiple strings to refer to the same subparser. This example, like , aliases as a shorthand for : supports also an additional deprecated argument, which allows to deprecate the subparser. One particularly effective way of handling subcommands is to combine the use of the method with calls to so that each subparser knows which Python function it should execute. For example: # create the parser for the \"foo\" command # create the parser for the \"bar\" command # parse the args and call whatever function was selected # parse the args and call whatever function was selected This way, you can let do the job of calling the appropriate function after argument parsing is complete. Associating functions with actions like this is typically the easiest way to handle the different actions for each of your subparsers. However, if it is necessary to check the name of the subparser that was invoked, the keyword argument to the call will work: The factory creates objects that can be passed to the type argument of . Arguments that have objects as their type will open command-line arguments as files with the requested modes, buffer sizes, encodings and error handling (see the function for more details): FileType objects understand the pseudo-argument and automatically convert this into for readable objects and for writable objects: Changed in version 3.4: Added the encodings and errors parameters. By default, groups command-line arguments into “positional arguments” and “options” when displaying help messages. When there is a better conceptual grouping of arguments than this default one, appropriate groups can be created using the method: The method returns an argument group object which has an method just like a regular . When an argument is added to the group, the parser treats it just like a normal argument, but displays the argument in a separate group for help messages. The method accepts title and description arguments which can be used to customize this display: The optional, keyword-only parameters argument_default and conflict_handler allow for finer-grained control of the behavior of the argument group. These parameters have the same meaning as in the constructor, but apply specifically to the argument group rather than the entire parser. Note that any arguments not in your user-defined groups will end up back in the usual “positional arguments” and “optional arguments” sections. Changed in version 3.11: Calling on an argument group is deprecated. This feature was never supported and does not always work correctly. The function exists on the API by accident through inheritance and will be removed in the future. Create a mutually exclusive group. will make sure that only one of the arguments in the mutually exclusive group was present on the command line: The method also accepts a required argument, to indicate that at least one of the mutually exclusive arguments is required: PROG: error: one of the arguments --foo --bar is required Note that currently mutually exclusive argument groups do not support the title and description arguments of . However, a mutually exclusive group can be added to an argument group that has a title and description. For example: -h, --help show this help message and exit Changed in version 3.11: Calling or on a mutually exclusive group is deprecated. These features were never supported and do not always work correctly. The functions exist on the API by accident through inheritance and will be removed in the future. Most of the time, the attributes of the object returned by will be fully determined by inspecting the command-line arguments and the argument actions. allows some additional attributes that are determined without any inspection of the command line to be added: Parser-level defaults can be particularly useful when working with multiple parsers. See the method for an example of this type. Get the default value for a namespace attribute, as set by either or by : In most typical applications, will take care of formatting and printing any usage or error messages. However, several formatting methods are available: Print a brief description of how the should be invoked on the command line. If file is , is assumed. Print a help message, including the program usage and information about the arguments registered with the . If file is , is assumed. There are also variants of these methods that simply return a string instead of printing it: Return a string containing a brief description of how the should be invoked on the command line. Return a string containing a help message, including the program usage and information about the arguments registered with the . Sometimes a script may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the method can be useful. It works much like except that it does not produce an error when extra arguments are present. Instead, it returns a two item tuple containing the populated namespace and the list of remaining argument strings. Prefix matching rules apply to . The parser may consume an option even if it’s just a prefix of one of its known options, instead of leaving it in the remaining arguments list. Arguments that are read from a file (see the fromfile_prefix_chars keyword argument to the constructor) are read one argument per line. can be overridden for fancier reading. This method takes a single argument arg_line which is a string read from the argument file. It returns a list of arguments parsed from this string. The method is called once per line read from the argument file, in order. A useful override of this method is one that treats each space-separated word as an argument. The following example demonstrates how to do this: This method terminates the program, exiting with the specified status and, if given, it prints a message to before that. The user can override this method to handle these steps differently: 'Exiting because of an error: This method prints a usage message, including the message, to and terminates the program with a status code of 2. A number of Unix commands allow the user to intermix optional arguments with positional arguments. The and methods support this parsing style. These parsers do not support all the features, and will raise exceptions if unsupported features are used. In particular, subparsers, and mutually exclusive groups that include both optionals and positionals are not supported. The following example shows the difference between and : the former returns as unparsed arguments, while the latter collects all the positionals into . returns a two item tuple containing the populated namespace and the list of remaining argument strings. raises an error if there are any remaining unparsed argument strings. Sometimes it’s desirable to use a custom string in error messages to provide more user-friendly output. In these cases, can be used to register custom actions or types with a parser and allow you to reference the type by their registered name instead of their callable name. The method accepts three arguments - a registry_name, specifying the internal registry where the object will be stored (e.g., , ), value, which is the key under which the object will be registered, and object, the callable to be registered. The following example shows how to register a custom type with a parser:"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-parse-boolean-values-with-argparse-in-python",
        "document": "Command-line arguments are a powerful feature of many programming languages, including Python. They allow developers to specify options or parameters when running a script, making it more flexible and customizable. However, the process of parsing these arguments can be a tedious and error-prone task if done manually. The ‘argparse’ module in Python provides an easy and elegant way to parse command-line arguments, making it a popular choice among developers.\n\nThe argparse is a built-in Python library for parsing command-line arguments. As mentioned above it allows users to certain options and arguments for a script in a more organized and user-friendly way.\n\nOne common type of argument that you may want to accept is a boolean value, which can be either True or False. In this tutorial, we’ll show you how to use ‘argparse’ to parse boolean values.\n\nFor the process of parsing boolean values with argparse, you can use the add_argument() method and set the action parameter to “store_true” or “store_false“. The store_true option has a default value of False. Whereas, store_false has a default value of True.\n• Command-line arguments: These are options or parameters that can be passed to a script when it is run from the command-line. They allow users to modify the behavior of the script and can include things like file paths, settings, and flags.\n• Parsing: This refers to the process of analyzing and interpreting the command-line arguments passed to a script. It involves breaking down the arguments into individual components and extracting the relevant information.\n• Boolean values: These are data types that can have one of two possible values: True or False. They are often used to represent yes/no or on/off options in command-line scripts.\n• argparse module: This is a built-in Python library that provides a convenient way to parse command-line arguments. It allows users to specify options and arguments in a user-friendly way and also provides features like automatic help messages and error handling.\n• add_argument() method: This is a method provided by the argparse module that allows users to add command-line arguments to a script. It takes various parameters, such as the name of the argument, its type, and whether or not it is required.\n• parse_args() method: This method is used to parse the command-line arguments passed to a script. It takes the arguments provided to the script and returns an object containing the values of the arguments.\n\nHere are the steps needed to parse boolean values with argparse:\n\nTo use the module first we need to import it, before importing the module you need to verify that the module is installed using the pip command.\n\nTo use the imported module we need to create a parser object first.\n\n‘ArgumentParser’ object will be used to specify the arguments that our script should accept.\n\nStep 3: Use the add_argument() method to add a boolean option or argument.\n\nTo add a boolean argument to our script, we can use the add_argument() method of the ArgumentParser object. This method accepts various arguments that can be used to specify how the argument should be parsed. In this example, we’re adding an argument called “–verbose” which is a boolean value with that we’ll use the action argument to specify that we want to accept a boolean value and the help argument can be used to specify a string that should be displayed when the user runs the script with the -h or –help option. This can be useful for providing additional information about the purpose of an argument and also how to use it.\n\nStep 4: Use the parse_args() method to parse the command-line arguments\n\nFollow is the implementation for it :\n\nWe can use the parse_args() method to parse the command-line arguments. This method returns an object that contains the values of the arguments that were provided on the command line.\n\nStep 5) Use the .dest variable of the returned namespace object to access the value of the boolean\n\nhere we can now access the value by using\n\nRun this code by typing the following command:\n\nHere are some examples for a better understanding, you can follow similar steps as given above for these examples.\n\nVerbose mode: A common use case for boolean values is to enable verbose mode in a script. This might print extra information to the console, such as debugging messages or changing the level of detail in the output.\n\nQuiet mode: Similar to verbose mode, you can use boolean values to turn off the output of a script.\n\nEnabling/Disabling a feature: You can also use boolean values to turn on/off a specific feature of a script.\n\nHope this article fulfills your needs and that you will get an overview of how to parse boolean values with `argparse` in Python. Try more examples with it by yourself too. Thank you."
    },
    {
        "link": "https://codemia.io/knowledge-hub/path/parsing_boolean_values_with_argparse",
        "document": "Enhance your system design skills with over 120 practice problems, detailed solutions, and hands-on exercises."
    },
    {
        "link": "https://light-tree.tistory.com/290",
        "document": ""
    }
]