[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html",
        "document": "A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a object that can match arbitrary character sequences against the regular expression. All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.\n\nA method is defined by this class as a convenience for when a regular expression is used just once. This method compiles an expression and matches an input sequence against it in a single invocation. The statement\n\nis equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.\n\nInstances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the class are not safe for such use.\n\nThe backslash character ( ) serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs. Thus the expression matches a single backslash and matches a left brace.\n\nIt is an error to use a backslash prior to any alphabetic character that does not denote an escaped construct; these are reserved for future extensions to the regular-expression language. A backslash may be used prior to a non-alphabetic character regardless of whether that character is part of an unescaped construct.\n\nBackslashes within string literals in Java source code are interpreted as required by as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6) It is therefore necessary to double backslashes in string literals that represent regular expressions to protect them from interpretation by the Java bytecode compiler. The string literal , for example, matches a single backspace character when interpreted as a regular expression, while matches a word boundary. The string literal is illegal and leads to a compile-time error; in order to match the string the string literal must be used.\n\nCharacter classes may appear within other character classes, and may be composed by the union operator (implicit) and the intersection operator ( ). The union operator denotes a class that contains every character that is in at least one of its operand classes. The intersection operator denotes a class that contains every character that is in both of its operand classes.\n\nThe precedence of character-class operators is as follows, from highest to lowest:\n\nNote that a different set of metacharacters are in effect inside a character class than outside a character class. For instance, the regular expression loses its special meaning inside a character class, while the expression becomes a range forming metacharacter.\n\nA line terminator is a one- or two-character sequence that marks the end of a line of the input character sequence. The following are recognized as line terminators:\n\nIf mode is activated, then the only line terminators recognized are newline characters.\n\nThe regular expression matches any character except a line terminator unless the flag is specified.\n\nBy default, the regular expressions and ignore line terminators and only match at the beginning and the end, respectively, of the entire input sequence. If mode is activated then matches at the beginning of input and after any line terminator except at the end of input. When in mode matches just before a line terminator or the end of the input sequence.\n\nCapturing groups are numbered by counting their opening parentheses from left to right. In the expression , for example, there are four such groups:\n\nGroup zero always stands for the entire expression.\n\nCapturing groups are so named because, during a match, each subsequence of the input sequence that matches such a group is saved. The captured subsequence may be used later in the expression, via a back reference, and may also be retrieved from the matcher once the match operation is complete.\n\nA capturing group can also be assigned a \"name\", a , and then be back-referenced later by the \"name\". Group names are composed of the following characters. The first character must be a .\n• The uppercase letters through ( through ),\n• The lowercase letters through ( through ),\n• The digits through ( through ),\n\nA is still numbered as described in Group number.\n\nThe captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string against the expression , for example, leaves group two set to . All captured input is discarded at the beginning of each match.\n\nGroups beginning with are either pure, non-capturing groups that do not capture text and do not count towards the group total, or named-capturing group.\n\nThis class is in conformance with Level 1 of Unicode Technical Standard #18: Unicode Regular Expression, plus RL2.1 Canonical Equivalents.\n\nUnicode escape sequences such as in Java source code are processed as described in section 3.3 of . Such escape sequences are also implemented directly by the regular-expression parser so that Unicode escapes can be used in expressions that are read from files or from the keyboard. Thus the strings and , while not equal, compile into the same pattern, which matches the character with hexadecimal value .\n\nA Unicode character can also be represented in a regular-expression by using its Hex notation(hexadecimal code point value) directly as described in construct , for example a supplementary character U+2011F can be specified as , instead of two consecutive Unicode escape sequences of the surrogate pair .\n\nUnicode scripts, blocks, categories and binary properties are written with the and constructs as in Perl. prop matches if the input has the property prop, while prop does not match if the input has that property.\n\nScripts, blocks, categories and binary properties can be used both inside and outside of a character class.\n\nScripts are specified either with the prefix , as in , or by using the keyword (or its short form )as in or .\n\nThe script names supported by are the valid script names accepted and defined by .\n\nBlocks are specified with the prefix , as in , or by using the keyword (or its short form ) as in or .\n\nThe block names supported by are the valid block names accepted and defined by .\n\nCategories may be specified with the optional prefix : Both and denote the category of Unicode letters. Same as scripts and blocks, categories can also be specified by using the keyword (or its short form ) as in or .\n\nThe supported categories are those of The Unicode Standard in the version specified by the class. The category names are those defined in the Standard, both normative and informative.\n\nBinary properties are specified with the prefix , as in . The supported binary properties by are\n\nThe following Predefined Character classes and POSIX character classes are in conformance with the recommendation of Annex C: Compatibility Properties of Unicode Regular Expression , when flag is specified.\n\nCategories that behave like the java.lang.Character boolean ismethodname methods (except for the deprecated ones) are available through the same prop syntax where the specified property has the name .\n\nThe engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5.\n\nPerl constructs not supported by this class:\n• None The backreference constructs, n for the nthcapturing group and name for named-capturing group.\n• None The named character construct, name for a Unicode character by its name.\n\nConstructs supported by this class but not by Perl:\n• None Character-class union and intersection as described above.\n• None In Perl, through are always interpreted as back references; a backslash-escaped number greater than is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, through are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.\n• None Perl uses the flag to request a match that resumes where the last match left off. This functionality is provided implicitly by the class: Repeated invocations of the method will resume where the last match left off, unless the matcher is reset.\n• None In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl.\n\nFor a more precise description of the behavior of regular expression constructs, please see Mastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006."
    },
    {
        "link": "https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html",
        "document": "A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a object that can match arbitrary character sequences against the regular expression. All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.\n\nA method is defined by this class as a convenience for when a regular expression is used just once. This method compiles an expression and matches an input sequence against it in a single invocation. The statement\n\nis equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.\n\nInstances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the class are not safe for such use.\n\nCategories that behave like the java.lang.Character boolean ismethodname methods (except for the deprecated ones) are available through the same prop syntax where the specified property has the name . The engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5. Perl constructs not supported by this class:\n• None The backreference constructs, n for the nthcapturing group and name for named-capturing group.\n• None The named character construct, name for a Unicode character by its name. Constructs supported by this class but not by Perl:\n• None Character-class union and intersection as described above.\n• None In Perl, through are always interpreted as back references; a backslash-escaped number greater than is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, through are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.\n• None Perl uses the flag to request a match that resumes where the last match left off. This functionality is provided implicitly by the class: Repeated invocations of the method will resume where the last match left off, unless the matcher is reset.\n• None In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl. For a more precise description of the behavior of regular expression constructs, please see Mastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006."
    },
    {
        "link": "https://w3schools.com/java/java_regex.asp",
        "document": "A regular expression is a sequence of characters that forms a search pattern. When you search for data in a text, you can use this search pattern to describe what you are searching for.\n\nA regular expression can be a single character, or a more complicated pattern.\n\nRegular expressions can be used to perform all types of text search and text replace operations.\n\nJava does not have a built-in Regular Expression class, but we can import the package to work with regular expressions. The package includes the following classes:\n• Class - Defines a pattern (to be used in a search)\n• Class - Used to search for the pattern\n\nIn this example, The word \"w3schools\" is being searched for in a sentence.\n\nFirst, the pattern is created using the method. The first parameter indicates which pattern is being searched for and the second parameter has a flag to indicates that the search should be case-insensitive. The second parameter is optional.\n\nThe method is used to search for the pattern in a string. It returns a Matcher object which contains information about the search that was performed.\n\nThe method returns true if the pattern was found in the string and false if it was not found.\n\nFlags in the method change how the search is performed. Here are a few of them:\n• - The case of letters will be ignored when performing a search.\n• - Special characters in the pattern will not have any special meaning and will be treated as ordinary characters when performing a search.\n• - Use it together with the flag to also ignore the case of letters outside of the English alphabet\n\nThe first parameter of the method is the pattern. It describes what is being searched for.\n\nBrackets are used to find a range of characters:"
    },
    {
        "link": "https://jrebel.com/blog/java-regular-expressions-cheat-sheet",
        "document": ""
    },
    {
        "link": "https://download.java.net/java/early_access/panama/docs/api/java.base/java/util/regex/package-summary.html",
        "document": "Classes for matching character sequences against patterns specified by regular expressions.\n\nAn instance of the class represents a regular expression that is specified in string form in a syntax similar to that used by Perl.\n\nInstances of the class are used to match character sequences against a given pattern. Input is provided to matchers via the interface in order to support matching against characters from a wide variety of input sources.\n\nUnless otherwise noted, passing a argument to a method in any class or interface in this package will cause a to be thrown.\n\nAn excellent tutorial and overview of regular expressions is Mastering Regular Expressions, Jeffrey E. F. Friedl, O'Reilly and Associates, 1997."
    },
    {
        "link": "https://stackoverflow.com/questions/6939526/java-regex-repeating-capturing-groups",
        "document": "An item is a comma delimited list of one or more strings of numbers or characters e.g.\n\nI'm trying to match a bracketed list of zero or more items in Java e.g.\n\nwhich should return the following matching groups respectively for the last example\n\nI've come up with the following (incorrect)pattern\n\nwhich matches only the following for the last example"
    },
    {
        "link": "https://stackoverflow.com/questions/61547593/java-regex-repeating-capture-groups",
        "document": "Considering the following string: \"${test.one}${test.two}\" I would like my regex to return two matches, namely \"test.one\" and \"test.two\". To do that I have the following snippet:\n\nI have some other stuff in there as well, because I want this to also be a valid match ${test.one}${\"hello\"}.\n\nSo, basically, I just want it to match on anything inside of ${} as long as it either follows the format: (alphanumeric only there) or or (alphanumeric plus some other characters). I have the main regex working, or so I think, but when I run the code, it finds two groups,\n\nI want the output to be"
    },
    {
        "link": "https://jrebel.com/blog/java-regular-expressions-cheat-sheet",
        "document": ""
    },
    {
        "link": "https://medium.com/@NALSengineering/regex-for-dummies-part-4-capturing-groups-and-backreferences-50c338a3b6f6",
        "document": "See Part 2 here: Flavors, Flags, and Assertions\n\nSee Part 3 here: Character Set, Or condition, and Word Boundary Assertion\n\nIn this part, we will find out the advanced concept in Regex: Capturing Groups and Backreferences\n\nCapturing groups allow you to treat a part of your regex pattern as a single unit. This is especially useful when you want to apply quantifiers or modifiers to multiple characters or subpatterns. For example, matches one or more repetitions of \"abc\" as a whole.\n\nSuppose you have a set of IDs like , , , , , , , , , , and you want to find out which of them follow the pattern . There are two ways to do that:\n• Using grouping, you can make the pattern shorter by grouping the sequence and applying an exact quantifier of to it:\n\nCapturing groups are very useful for extracting data.\n\nLet’s say we want to extract the day, month, and year from birthday dates in the format , we can use this regex:\n\nWe have three capturing groups: the 1st group captures the day, the 2nd group captures the month, and the 3rd group captures the year (LINK).\n\nI’ll teach you how to extract them by coding in the next part.\n\nBackreferences are a feature that allows you to reference and reuse the text captured by a capturing group within the same regex pattern. They provide a powerful way to search for repeated patterns and validate complex text structures.\n\nIn a regex pattern, you can reference a capturing group by using a backslash followed by the group number. Group numbers are assigned based on the order of opening parentheses in the regex pattern, starting from 1. For example, refers to the text captured by the first capturing group, to the second, and so on.\n\nLet’s explore backreferences with an example:\n• matches . In which, is a capturing group, and is a backreference that matches the same text as captured by the capturing group, so, matches too.\n\nYou can also easily check the captured texts of the groups on the regex101.\n\nCapturing groups and backreferences are very useful in many scenarios, such as the “finding of duplicated words” problem.\n\nSuppose we need to search for duplicated words in this article, such as “the the regex” or “hello hello world”. Imagine how challenging this task would be if you were to use the regular search. However, we can easily accomplish it with the regex (LINK).\n• : This is the first capturing group. It captures one or more alphabetical characters (both uppercase and lowercase).\n• : This part matches one or more spaces. It allows for the possibility of spaces between the duplicated words.\n• : This is a backreference to the first capturing group. It checks that the same word captured by the first group appears again immediately after the spaces.\n\nIt is also possible to make a group non-capturing. That way, you won’t be able to refer to it in the pattern. To create a non-capturing group, you use a question mark and a colon right after the opening parenthesis.\n\nThe syntax for that looks like this:\n\nFor instance, in the example “extracting the day, month, and year from birthday dates” above, if we don’t want to capture the first two groups, then we would modify the regex as follows:\n\nI added the backreference to test the 1st capturing group.\n\nFor nested capturing groups, the order of the groups is the same as the order of the left parentheses. For example, in this regex ,\n• is the first capturing group and is numbered 1.\n• is the second capturing group and is numbered 2.\n• is the first inner capturing group of the second group and is numbered 3.\n• is the second inner capturing group of the second group and is numbered 4.\n\nNamed capturing groups allow you to assign names to your capturing groups, making it easier to reference and work with specific matched portions of text. Instead of referring to capturing groups by their numerical indices, you can use descriptive names, which enhances the readability and maintainability of your regex patterns.\n\nTo define a named capturing group, you use the syntax, where is the name you want to assign to the group. Here's an example:\n\n6. Find and Replace with Regex in Text Editors\n\nMost Text Editors such as Google Docs, Google Sheets, Google Slides, and IDEs like VSCode and Android Studio support the Find and Replace with Regex feature.\n\nLet’s say we need to find and replace dates in the format with . We can easily do this using the regex:\n\nPlease note that we need to enable the “Search using regular expressions” mode.\n\nLet’s say we want to search for duplicated words in the Google Docs document. We could use the regex . However, according to the official documentation, capture groups only work with Google Sheets. That means we cannot use replacement backreferences in Google Docs but have to do it manually.\n\nLet’s get back to the problem introduced in the first part.\n\n“Have you ever been involved in a project with over 500 code files and realized there are a lot of hard-coded dimensions? Your task is to find and fix them like this”\n\nThis is a big problem if we don’t know how to use Regex. But now we can deal with it with just one click.\n\nLooking into the regex:\n• : This is the first capturing group. It captures the property name, such as width, height,…\n• represents zero or more whitespace characters.\n• : This is the second capturing group. It captures the dimension value.\n• : This is the backreference of the first capturing group.\n• : This is the backreference of the second capturing group.\n\nWe have been able to apply regex to our work so far. In the next part, I will introduce you to an advanced feature in regex: Lookaround Groups, which include Lookaheads and Lookbehinds."
    },
    {
        "link": "https://baeldung.com/regular-expressions-java",
        "document": "In this tutorial, we’ll discuss the Java Regex API, and how we can use regular expressions in the Java programming language.\n\nIn the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk, and much more.\n\nThis means that a regular expression that works in one programming language, may not work in another. The regular expression syntax in Java is most similar to that found in Perl.\n\nTo use regular expressions in Java, we don’t need any special setup. The JDK contains a special package, java.util.regex, totally dedicated to regex operations. We only need to import it into our code.\n\nMoreover, the java.lang.String class also has inbuilt regex support that we commonly use in our code.\n\nThe java.util.regex package consists of three classes: Pattern, Matcher, and PatternSyntaxException:\n• Pattern object is a compiled regex. The Pattern class provides no public constructors. To create a pattern, we must first invoke one of its public static compile methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.\n• Matcher object interprets the pattern and performs match operations against an input String. It also defines no public constructors. We obtain a Matcher object by invoking the matcher method on a Pattern object.\n• PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.\n\nWe’ll explore these classes in detail; however, we must first understand how to construct a regex in Java.\n\nIf we’re already familiar with regex from a different environment, we may find certain differences, but they’re minimal.\n\nLet’s start with the simplest use case for a regex. As we noted earlier, when we apply a regex to a String, it may match zero or more times.\n\nThe most basic form of pattern matching supported by the java.util.regex API is the match of a String literal. For example, if the regular expression is foo and the input String is foo, the match will succeed because the Strings are identical:\n\nWe’ll first create a Pattern object by calling its static compile method and passing it a pattern we want to use.\n\nThen we’ll create a Matcher object be calling the Pattern object’s matcher method and passing it the text we want to check for matches.\n\nFinally, we’ll call the method find in the Matcher object.\n\nThe find method keeps advancing through the input text and returns true for every match, so we can use it to find the match count as well:\n\nSince we’ll be running more tests, we can abstract the logic for finding the number of matches in a method called runTest:\n\nWhen we get 0 matches, the test should fail; otherwise, it should pass.\n\nMeta characters affect the way a pattern is matched; in a way, they add logic to the search pattern. The Java API supports several meta characters, the most straightforward being the dot “.”, which matches any character:\n\nLet’s consider the previous example, where the regex foo matched the text foo, as well as foofoo, two times. If we use the dot meta character in the regex, we won’t get two matches in the second case:\n\nNotice the dot after the foo in the regex. The matcher matches every text that’s preceded by foo, since the last dot part means any character after. So after finding the first foo, the rest is seen as any character. That’s why there’s only a single match.\n\nThe API supports several other meta characters, <([{\\^-=$!|]})?*+.>, which we’ll explore further in this article.\n\nBrowsing through the official Pattern class specification, we’ll discover summaries of supported regex constructs. Under character classes, we have about 6 constructs.\n\nWe construct this as [abc]. This matches any of the elements in the set:\n\nIf they all appear in the text, it’ll match each element separately with no regard to the order:\n\nThey can also be alternated as part of a String. In the following example, when we create different words by alternating the first letter with each element of the set, they’re all matched:\n\nThe above set is negated by adding a caret as the first element:\n\nWe can define a class that specifies the range that the matched text should fall within by using a hyphen(-). Likewise, we can also negate a range.\n\nA union character class is the result of combining two or more character classes:\n\nThe above test will only match six out of the nine integers because the union set skips 4, 5, and 6.\n\nSimilar to the union class, this class results from picking common elements between two or more sets. To apply intersection, we use the &&:\n\nWe’ll get four matches because the intersection of the two sets has only four elements.\n\nWe can use subtraction to negate one or more character classes. For example, we can match a set of odd decimal numbers:\n\nOnly 1, 3, 5, 7, 9 will be matched.\n\nThe Java regex API also accepts predefined character classes. Some of the above character classes can be expressed in shorter form, although this makes the code less intuitive. One special aspect of the Java version of this regex is the escape character.\n\nAs we’ll see, most characters will start with a backslash, which has a special meaning in Java. For these to be compiled by the Pattern class, the leading backslash must be escaped, i.e. \\d becomes \\\\d.\n\nThe Java regex API also allows us to use quantifiers. These enable us to further tweak the match’s behavior by specifying the number of occurrences to match against.\n\nTo match a text zero or one time, we use the ? quantifier:\n\nAlternatively, we can use the brace syntax, which is also supported by the Java regex API:\n\nThis example introduces the concept of zero-length matches. It so happens that if a quantifier’s threshold for matching is zero, it always matches everything in the text, including an empty String at the end of every input. This means that even if the input is empty, it’ll return one zero-length match.\n\nThis explains why we get three matches in the above example, despite having a String of length two. The third match is zero-length empty String.\n\nTo match a text zero or limitless times, we us the * quantifier, which is similar to ?:\n\nThe quantifier with a difference is +, which has a matching threshold of one. If the required String doesn’t occur at all, there will be no match, not even a zero-length String:\n\nAs in Perl and other languages, we can use the brace syntax to match a given text a number of times:\n\nIn the above example, we get two matches, since a match occurs only if a appears three times in a row. However, in the next test, we won’t get a match because the text only appears two times in a row:\n\nWhen we use a range in the brace, the match will be greedy, matching from the higher end of the range:\n\nHere we specified at least two occurrences, but not exceeding three, so we get a single match where the matcher sees a single aaa and a lone a, which can’t be matched.\n\nHowever, the API allows us to specify a lazy or reluctant approach such that the matcher can start from the lower end of the range, matching two occurrences as aa and aa:\n\nThe API also allows us to treat multiple characters as a single unit through capturing groups. It will attach numbers to the capturing groups, and allow back referencing using these numbers.\n\nIn this section, we’ll see a few examples of how to use capturing groups in the Java regex API.\n\nLet’s use a capturing group that matches only when an input text contains two digits next to each other:\n\nThe number attached to the above match is 1, using a back reference to tell the matcher that we want to match another occurrence of the matched portion of the text. This way, instead of having two separate matches for the input:\n\nWe can have one match, but propagating the same regex match to span the entire length of the input using back referencing:\n\nWe would have to repeat the regex without back referencing to achieve the same result:\n\nSimilarly, for any other number of repetitions, back referencing can make the matcher see the input as a single match:\n\nBut if we change even the last digit, the match will fail:\n\nIt’s important not to forget the escape backslashes, which are crucial in Java syntax.\n\nThe Java regex API also supports boundary matching. If we care about where exactly in the input text the match should occur, then this is what we’re looking for. With the previous examples, all we cared about was whether or not a match was found.\n\nTo match only when the required regex is true at the beginning of the text, we use the caret ^.\n\nThis test will pass, since the text dog can be found at the beginning:\n\nThe following test will fail:\n\nTo match only when the required regex is true at the end of the text, we use the dollar character $. We’ll find a match in the following case:\n\nAnd we won’t find a match here:\n\nIf we want a match only when the required text is found at a word boundary, we use the \\\\b regex at the beginning and end of the regex:\n\nThe empty string at the beginning of a line is also a word boundary:\n\nThese tests pass because the beginning of a String, as well as the space between one text and another, marks a word boundary. However, the following test shows the opposite:\n\nTwo-word characters appearing in a row doesn’t mark a word boundary, but we can make it pass by changing the end of the regex to look for a non-word boundary:\n\nPreviously, we only created Pattern objects in a basic way. However, this class has another variant of the compile method that accepts a set of flags alongside the regex argument, which affects the way we match the pattern.\n\nThese flags are simply abstracted integer values. Let’s overload the runTest method in the test class, so that it can take a flag as the third argument:\n\nIn this section, we’ll look at the different supported flags and how to use them.\n\nThis flag enables canonical equivalence. When specified, two characters will be considered to match if, and only if, their full canonical decompositions match.\n\nConsider the accented Unicode character é. Its composite code point is u00E9. However, Unicode also has a separate code point for its component characters e, u0065, and the acute accent, u0301. In this case, composite character u is indistinguishable from the two character sequence u u\n\nBy default, matching doesn’t take canonical equivalence into account:\n\nBut if we add the flag, then the test will pass:\n\nThis flag enables matching regardless of case. By default, matching takes case into account:\n\nSo using this flag, we can change the default behavior:\n\nWe can also use the equivalent, embedded flag expression to achieve the same result:\n\nThe Java API allows us to include comments using # in the regex. This can help in documenting complex regex that may not be immediately obvious to another programmer.\n\nThe comments flag makes the matcher ignore any white space or comments in the regex, and only consider the pattern. In the default matching mode, the following test would fail:\n\nThis is because the matcher will look for the entire regex in the input text, including the spaces and the # character. But when we use the flag, it’ll ignore the extra spaces, and all text starting with # will be seen as a comment to be ignored for each line:\n\nThere’s also an alternative embedded flag expression for this:\n\nBy default, when we use the dot “.” expression in regex, we’re matching every character in the input String until we encounter a new line character.\n\nUsing this flag, the match will include the line terminator as well. We’ll understand this better with the following examples. These examples will be a little different. Since we want to assert against the matched String, we’ll use matcher‘s group method, which returns the previous match.\n\nFirst, let’s see the default behavior:\n\nAs we can see, only the first part of the input before the line terminator is matched.\n\nNow in dotall mode, the entire text, including the line terminator, will be matched:\n\nWe can also use an embedded flag expression to enable dotall mode:\n\nWhen in this mode, the matcher gives no special meaning to any meta characters, escape characters, or regex syntax. Without this flag, the matcher will match the following regex against any input String:\n\nThis is the default behavior we’ve seen in all the examples. However, with this flag, we won’t find a match, since the matcher will be looking for (.*) instead of interpreting it:\n\nNow if we add the required string, the test will pass:\n\nBy default, the ^ and $ meta characters match absolutely at the beginning and end, respectively, of the entire input String. The matcher disregards any line terminators:\n\nThis match will fail because the matcher searches for dog at the end of the entire String, but the dog is present at the end of the first line of the string.\n\nHowever, with the flag, the same test will pass, since the matcher now takes into account line terminators. So the String dog is found just before the line terminates, meaning success:\n\nIn this section, we’ll learn about the useful methods of the Matcher class. We’ll group them according to functionality for clarity.\n\nIndex methods provide useful index values that show us precisely where to find the match in the input String. In the following test, we’ll confirm the start and end indices of the match for dog in the input String:\n\nStudy methods go through the input String and return a boolean indicating whether or not the pattern was found. Commonly used are the matches and lookingAt methods.\n\nThe matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference is that matches requires the entire input sequence to be matched, while lookingAt doesn’t.\n\nBoth methods start at the beginning of the input String :\n\nThe matches method will return true in a case like this:\n\nReplacement methods are useful to replace text in an input string. The common ones are replaceFirst and replaceAll.\n\nThe replaceFirst and replaceAll methods replace the text that matches a given regular expression. As their names indicates, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences:\n\nThe replaceAll method allows us to substitute all matches with the same replacement. If we want to replace matches on a case by basis, we’d need a token replacement technique.\n\nIn this article, we learned how to use regular expressions in Java. We also explored the most important features of the java.util.regex package."
    }
]