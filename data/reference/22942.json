[
    {
        "link": "https://stackoverflow.com/questions/111155/how-do-i-handle-the-window-close-event-in-tkinter",
        "document": "I'd like to thank the answer by Apostolos for bringing this to my attention. Here's a much more detailed example for Python 3 in the year 2019, with a clearer description and example code.\n\nBeware of the fact that (or not having a custom window closing handler at all) will destroy the window and all of its running callbacks instantly when the user closes it.\n\nThis can be bad for you, depending on your current Tkinter activity, and especially when using (periodic callbacks). You might be using a callback which processes some data and writes to disk... in that case, you obviously want the data writing to finish without being abruptly killed.\n\nThe best solution for that is to use a flag. So when the user requests window closing, you mark that as a flag, and then react to it.\n\nThis code will show you that the handler runs even while our custom is busy in the middle of work/loops!\n\nWe use some pretty exaggerated values: 500 milliseconds. This is just meant to make it very easy for you to see the difference between closing while the periodic call is busy, or not... If you close while the numbers are updating, you will see that the happened while your periodic call \"was busy processing: True\". If you close while the numbers are paused (meaning that the periodic callback isn't processing at that moment), you see that the close happened while it's \"not busy\".\n\nIn real-world usage, your would use something like 30-100 milliseconds, to have a responsive GUI. This is just a demonstration to help you understand how to protect yourself against Tk's default \"instantly interrupt all work when closing\" behavior.\n\nIn summary: Make the handler set a flag, and then check that flag periodically and manually the window when it's safe (when your app is done with all work).\n\nPS: You can also use to ask the user if they REALLY want to close the window; and if they answer no, you don't set the flag. It's very simple. You just show a messagebox in your and set the flag based on the user's answer."
    },
    {
        "link": "https://docs.python.org/3/library/tkinter.html",
        "document": "The package (“Tk interface”) is the standard Python interface to the Tcl/Tk GUI toolkit. Both Tk and are available on most Unix platforms, including macOS, as well as on Windows systems.\n\nRunning from the command line should open a window demonstrating a simple Tk interface, letting you know that is properly installed on your system, and also showing what version of Tcl/Tk is installed, so you can read the Tcl/Tk documentation specific to that version.\n\nTkinter supports a range of Tcl/Tk versions, built either with or without thread support. The official Python binary release bundles Tcl/Tk 8.6 threaded. See the source code for the module for more information about supported versions.\n\nTkinter is not a thin wrapper, but adds a fair amount of its own logic to make the experience more pythonic. This documentation will concentrate on these additions and changes, and refer to the official Tcl/Tk documentation for details that are unchanged.\n\nTcl/Tk is not a single library but rather consists of a few distinct modules, each with separate functionality and its own official documentation. Python’s binary releases also ship an add-on module together with it. Tcl is a dynamic interpreted programming language, just like Python. Though it can be used on its own as a general-purpose programming language, it is most commonly embedded into C applications as a scripting engine or an interface to the Tk toolkit. The Tcl library has a C interface to create and manage one or more instances of a Tcl interpreter, run Tcl commands and scripts in those instances, and add custom commands implemented in either Tcl or C. Each interpreter has an event queue, and there are facilities to send events to it and process them. Unlike Python, Tcl’s execution model is designed around cooperative multitasking, and Tkinter bridges this difference (see Threading model for details). Tk is a Tcl package implemented in C that adds custom commands to create and manipulate GUI widgets. Each object embeds its own Tcl interpreter instance with Tk loaded into it. Tk’s widgets are very customizable, though at the cost of a dated appearance. Tk uses Tcl’s event queue to generate and process GUI events. Themed Tk (Ttk) is a newer family of Tk widgets that provide a much better appearance on different platforms than many of the classic Tk widgets. Ttk is distributed as part of Tk, starting with Tk version 8.5. Python bindings are provided in a separate module, . Internally, Tk and Ttk use facilities of the underlying operating system, i.e., Xlib on Unix/X11, Cocoa on macOS, GDI on Windows. When your Python application uses a class in Tkinter, e.g., to create a widget, the module first assembles a Tcl/Tk command string. It passes that Tcl command string to an internal binary module, which then calls the Tcl interpreter to evaluate it. The Tcl interpreter will then call into the Tk and/or Ttk packages, which will in turn make calls to Xlib, Cocoa, or GDI.\n\nSupport for Tkinter is spread across several modules. Most applications will need the main module, as well as the module, which provides the modern themed widget set and API: Construct a toplevel Tk widget, which is usually the main window of an application, and initialize a Tcl interpreter for this widget. Each instance has its own associated Tcl interpreter. The class is typically instantiated using all default values. However, the following keyword arguments are currently recognized: When given (as a string), sets the environment variable. (X11 only) Name of the profile file. By default, baseName is derived from the program name ( ). Name of the widget class. Used as a profile file and also as the name with which Tcl is invoked (argv0 in interp). If , initialize the Tk subsystem. The function sets this to . If , execute all X server commands synchronously, so that errors are reported immediately. Can be used for debugging. (X11 only) Specifies the id of the window in which to embed the application, instead of it being created as an independent toplevel window. id must be specified in the same way as the value for the -use option for toplevel widgets (that is, it has a form like that returned by ). Note that on some platforms this will only work correctly if id refers to a Tk frame or toplevel that has its -container option enabled. reads and interprets profile files, named and , into the Tcl interpreter and calls on the contents of and . The path for the profile files is the environment variable or, if that isn’t defined, then . The Tk application object created by instantiating . This provides access to the Tcl interpreter. Each widget that is attached the same instance of has the same value for its attribute. The widget object that contains this widget. For , the master is because it is the main window. The terms master and parent are similar and sometimes used interchangeably as argument names; however, calling returns a string of the widget name whereas returns the object. parent/child reflects the tree-like relationship while master/slave reflects the container structure. The immediate descendants of this widget as a with the child widget names as the keys and the child instance objects as the values. The function is a factory function which creates an object much like that created by the class, except that it does not initialize the Tk subsystem. This is most often useful when driving the Tcl interpreter in an environment where one doesn’t want to create extraneous toplevel windows, or where one cannot (such as Unix/Linux systems without an X server). An object created by the object can have a Toplevel window created (and the Tk subsystem initialized) by calling its method. Dialog to let the user choose a color. Base class for the dialogs defined in the other modules listed here. Common dialogs to allow the user to specify a file to open or save. Utilities to help work with fonts. Themed widget set introduced in Tk 8.5, providing modern alternatives for many of the classic widgets in the main module. A binary module that contains the low-level interface to Tcl/Tk. It is automatically imported by the main module, and should never be used directly by application programmers. It is usually a shared library (or DLL), but might in some cases be statically linked with the Python interpreter. Symbolic constants that can be used in place of strings when passing various parameters to Tkinter calls. Automatically imported by the main module. (experimental) Drag-and-drop support for . This will become deprecated when it is replaced with the Tk DND.\n\nThis section is not designed to be an exhaustive tutorial on either Tk or Tkinter. For that, refer to one of the external resources noted earlier. Instead, this section provides a very quick orientation to what a Tkinter application looks like, identifies foundational Tk concepts, and explains how the Tkinter wrapper is structured. The remainder of this section will help you to identify the classes, methods, and options you’ll need in your Tkinter application, and where to find more detailed documentation on them, including in the official Tcl/Tk reference manual. We’ll start by walking through a “Hello World” application in Tkinter. This isn’t the smallest one we could write, but has enough to illustrate some key concepts you’ll need to know. After the imports, the next line creates an instance of the class, which initializes Tk and creates its associated Tcl interpreter. It also creates a toplevel window, known as the root window, which serves as the main window of the application. The following line creates a frame widget, which in this case will contain a label and a button we’ll create next. The frame is fit inside the root window. The next line creates a label widget holding a static text string. The method is used to specify the relative layout (position) of the label within its containing frame widget, similar to how tables in HTML work. A button widget is then created, and placed to the right of the label. When pressed, it will call the method of the root window. Finally, the method puts everything on the display, and responds to user input until the program terminates. Even this simple program illustrates the following key Tk concepts: A Tkinter user interface is made up of individual widgets. Each widget is represented as a Python object, instantiated from classes like , , and . Widgets are arranged in a hierarchy. The label and button were contained within a frame, which in turn was contained within the root window. When creating each child widget, its parent widget is passed as the first argument to the widget constructor. Widgets have configuration options, which modify their appearance and behavior, such as the text to display in a label or button. Different classes of widgets will have different sets of options. Widgets aren’t automatically added to the user interface when they are created. A geometry manager like controls where in the user interface they are placed. Tkinter reacts to user input, changes from your program, and even refreshes the display only when actively running an event loop. If your program isn’t running the event loop, your user interface won’t update. When your application uses Tkinter’s classes and methods, internally Tkinter is assembling strings representing Tcl/Tk commands, and executing those commands in the Tcl interpreter attached to your application’s instance. Whether it’s trying to navigate reference documentation, trying to find the right method or option, adapting some existing code, or debugging your Tkinter application, there are times that it will be useful to understand what those underlying Tcl/Tk commands look like. To illustrate, here is the Tcl/Tk equivalent of the main part of the Tkinter script above. Tcl’s syntax is similar to many shell languages, where the first word is the command to be executed, with arguments to that command following it, separated by spaces. Without getting into too many details, notice the following:\n• None The commands used to create widgets (like ) correspond to widget classes in Tkinter.\n• None Tcl widget options (like ) correspond to keyword arguments in Tkinter.\n• None Widgets are referred to by a pathname in Tcl (like ), whereas Tkinter doesn’t use names but object references.\n• None A widget’s place in the widget hierarchy is encoded in its (hierarchical) pathname, which uses a (dot) as a path separator. The pathname for the root window is just (dot). In Tkinter, the hierarchy is defined not by pathname but by specifying the parent widget when creating each child widget.\n• None Operations which are implemented as separate commands in Tcl (like or ) are represented as methods on Tkinter widget objects. As you’ll see shortly, at other times Tcl uses what appear to be method calls on widget objects, which more closely mirror what would is used in Tkinter. How do I…? What option does…?¶ If you’re not sure how to do something in Tkinter, and you can’t immediately find it in the tutorial or reference documentation you’re using, there are a few strategies that can be helpful. First, remember that the details of how individual widgets work may vary across different versions of both Tkinter and Tcl/Tk. If you’re searching documentation, make sure it corresponds to the Python and Tcl/Tk versions installed on your system. When searching for how to use an API, it helps to know the exact name of the class, option, or method that you’re using. Introspection, either in an interactive Python shell or with , can help you identify what you need. To find out what configuration options are available on any widget, call its method, which returns a dictionary containing a variety of information about each object, including its default and current values. Use to get just the names of each option. As most widgets have many configuration options in common, it can be useful to find out which are specific to a particular widget class. Comparing the list of options to that of a simpler widget, like a frame, is one way to do that. Similarly, you can find the available methods for a widget object using the standard function. If you try it, you’ll see there are over 200 common widget methods, so again identifying those specific to a widget class is helpful. As noted, the official Tk commands reference manual (man pages) is often the most accurate description of what specific operations on widgets do. Even when you know the name of the option or method that you need, you may still have a few places to look. While all operations in Tkinter are implemented as method calls on widget objects, you’ve seen that many Tcl/Tk operations appear as commands that take a widget pathname as its first parameter, followed by optional parameters, e.g. Others, however, look more like methods called on a widget object (in fact, when you create a widget in Tcl/Tk, it creates a Tcl command with the name of the widget pathname, with the first parameter to that command being the name of a method to call). In the official Tcl/Tk reference documentation, you’ll find most operations that look like method calls on the man page for a specific widget (e.g., you’ll find the method on the ttk::button man page), while functions that take a widget as a parameter often have their own man page (e.g., grid). You’ll find many common options and methods in the options or ttk::widget man pages, while others are found in the man page for a specific widget class. You’ll also find that many Tkinter methods have compound names, e.g., , , . You’d find documentation for all of these in the winfo man page. Somewhat confusingly, there are also methods on all Tkinter widgets that don’t actually operate on the widget, but operate at a global scope, independent of any widget. Examples are methods for accessing the clipboard or the system bell. (They happen to be implemented as methods in the base class that all Tkinter widgets inherit from).\n\nPython and Tcl/Tk have very different threading models, which tries to bridge. If you use threads, you may need to be aware of this. A Python interpreter may have many threads associated with it. In Tcl, multiple threads can be created, but each thread has a separate Tcl interpreter instance associated with it. Threads can also create more than one interpreter instance, though each interpreter instance can be used only by the one thread that created it. Each object created by contains a Tcl interpreter. It also keeps track of which thread created that interpreter. Calls to can be made from any Python thread. Internally, if a call comes from a thread other than the one that created the object, an event is posted to the interpreter’s event queue, and when executed, the result is returned to the calling Python thread. Tcl/Tk applications are normally event-driven, meaning that after initialization, the interpreter runs an event loop (i.e. ) and responds to events. Because it is single-threaded, event handlers must respond quickly, otherwise they will block other events from being processed. To avoid this, any long-running computations should not run in an event handler, but are either broken into smaller pieces using timers, or run in another thread. This is different from many GUI toolkits where the GUI runs in a completely separate thread from all application code including event handlers. If the Tcl interpreter is not running the event loop and processing events, any calls made from threads other than the one running the Tcl interpreter will fail.\n• None Tcl/Tk libraries can be built so they are not thread-aware. In this case, calls the library from the originating Python thread, even if this is different than the thread that created the Tcl interpreter. A global lock ensures only one call occurs at a time.\n• None While allows you to create more than one instance of a object (with its own interpreter), all interpreters that are part of the same thread share a common event queue, which gets ugly fast. In practice, don’t create more than one instance of at a time. Otherwise, it’s best to create them in separate threads and ensure you’re running a thread-aware Tcl/Tk build.\n• None Blocking event handlers are not the only way to prevent the Tcl interpreter from reentering the event loop. It is even possible to run multiple nested event loops or abandon the event loop entirely. If you’re doing anything tricky when it comes to events or threads, be aware of these possibilities.\n• None There are a few select functions that presently work only when called from the thread that created the Tcl interpreter.\n\nOptions control things like the color and border width of a widget. Options can be set in three ways: After object creation, treating the option name like a dictionary index Use the config() method to update multiple attrs subsequent to object creation For a complete explanation of a given option and its behavior, see the Tk man pages for the widget in question. Note that the man pages list “STANDARD OPTIONS” and “WIDGET SPECIFIC OPTIONS” for each widget. The former is a list of options that are common to many widgets, the latter are the options that are idiosyncratic to that particular widget. The Standard Options are documented on the options(3) man page. No distinction between standard and widget-specific options is made in this document. Some options don’t apply to some kinds of widgets. Whether a given widget responds to a particular option depends on the class of the widget; buttons have a option, labels do not. The options supported by a given widget are listed in that widget’s man page, or can be queried at runtime by calling the method without arguments, or by calling the method on that widget. The return value of these calls is a dictionary whose key is the name of the option as a string (for example, ) and whose values are 5-tuples. Some options, like are synonyms for common options with long names ( is shorthand for “background”). Passing the method the name of a shorthand option will return a 2-tuple, not 5-tuple. The 2-tuple passed back will contain the name of the synonym and the “real” option (such as ). Of course, the dictionary printed will include all the options available and their values. This is meant only as an example. The packer is one of Tk’s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual master. In contrast to the more cumbersome placer (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - above, to the left of, filling, etc - and works everything out to determine the exact placement coordinates for you. The size of any master widget is determined by the size of the “slave widgets” inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed. Note that widgets do not appear until they have had their geometry specified with a geometry manager. It’s a common early mistake to leave out the geometry specification, and then be surprised when the widget is created but nothing appears. A widget will appear only after it has had, for example, the packer’s method applied to it. The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples: For more extensive information on the packer and the options that it can take, see the man pages and page 183 of John Ousterhout’s book. Anchor type. Denotes where the packer is to place each slave in its parcel. A distance - designating internal padding on each side of the slave widget. A distance - designating external padding on each side of the slave widget. The current-value setting of some widgets (like text entry widgets) can be connected directly to application variables by using special options. These options are , , , , and . This connection works both ways: if the variable changes for any reason, the widget it’s connected to will be updated to reflect the new value. Unfortunately, in the current implementation of it is not possible to hand over an arbitrary Python variable to a widget through a or option. The only kinds of variables for which this works are variables that are subclassed from a class called Variable, defined in . There are many useful subclasses of Variable already defined: , , , and . To read the current value of such a variable, call the method on it, and to change its value you call the method. If you follow this protocol, the widget will always track the value of the variable, with no further intervention on your part. # Tell the entry widget to watch this variable. # Define a callback for when the user hits return. # It prints the current value of the variable. \"Hi. The current entry content is:\" In Tk, there is a utility command, , for interacting with the window manager. Options to the command allow you to control things like titles, placement, icon bitmaps, and the like. In , these commands have been implemented as methods on the class. Toplevel widgets are subclassed from the class, and so can call the methods directly. To get at the toplevel window that contains a given widget, you can often just refer to the widget’s master. Of course if the widget has been packed inside of a frame, the master won’t represent a toplevel window. To get at the toplevel window that contains an arbitrary widget, you can call the method. This method begins with an underscore to denote the fact that this function is part of the implementation, and not an interface to Tk functionality. Here are some examples of typical usage: # here are method calls to the window manager class Legal values are points of the compass: , , , , , , , , and also . There are eight built-in, named bitmaps: , , , , , , , . To specify an X bitmap filename, give the full path to the file, preceded with an , as in . You can pass integers 0 or 1 or the strings or . This is any Python function that takes no arguments. For example: Colors can be given as the names of X colors in the rgb.txt file, or as strings representing RGB values in 4 bit: , 8 bit: , 12 bit: , or 16 bit: ranges, where R,G,B here represent any legal hex digit. See page 160 of Ousterhout’s book for details. The standard X cursor names from can be used, without the prefix. For example to get a hand cursor ( ), use the string . You can also specify a bitmap and mask file of your own. See page 179 of Ousterhout’s book. Screen distances can be specified in either pixels or absolute distances. Pixels are given as numbers and absolute distances as strings, with the trailing character denoting units: for centimetres, for inches, for millimetres, for printer’s points. For example, 3.5 inches is expressed as . Tk uses a list font name format, such as . Font sizes with positive numbers are measured in points; sizes with negative numbers are measured in pixels. This is a string of the form , where width and height are measured in pixels for most widgets (in characters for widgets displaying text). For example: . Legal values are the strings: , , , and . This is a string with four space-delimited elements, each of which is a legal distance (see above). For example: and and are all legal regions. Determines what the border style of a widget will be. Legal values are: , , , , and . This is almost always the method of some scrollbar widget, but can be any widget method that takes a single argument. Must be one of: , , or . The bind method from the widget command allows you to watch for certain events and to have a callback function trigger when that event type occurs. The form of the bind method is: is a string that denotes the target kind of event. (See the bind(3tk) man page, and page 201 of John Ousterhout’s book, , for details). is a Python function, taking one argument, to be invoked when the event occurs. An Event instance will be passed as the argument. (Functions deployed this way are commonly known as callbacks.) is optional, either or . Passing an empty string denotes that this binding is to replace any other bindings that this event is associated with. Passing a means that this function is to be added to the list of functions bound to this event type. Notice how the widget field of the event is being accessed in the callback. This field contains the widget that caught the X event. The following table lists the other event fields you can access, and how they are denoted in Tk, which can be useful when referring to the Tk man pages. A number of widgets require “index” parameters to be passed. These are used to point at a specific place in a Text widget, or to particular characters in an Entry widget, or to particular menu items in a Menu widget. Entry widgets have options that refer to character positions in the text being displayed. You can use these functions to access these special points in text widgets: The index notation for Text widgets is very rich and is best described in the Tk man pages. Some options and methods for menus manipulate specific menu entries. Anytime a menu index is needed for an option or a parameter, you may pass in:\n• None an integer which refers to the numeric position of the entry in the widget, counted from the top, starting with 0;\n• None the string , which refers to the menu position that is currently under the cursor;\n• None the string which refers to the last menu item;\n• None An integer preceded by , as in , where the integer is interpreted as a y pixel coordinate in the menu’s coordinate system;\n• None the string , which indicates no menu entry at all, most often used with menu.activate() to deactivate all entries, and finally,\n• None a text string that is pattern matched against the label of the menu entry, as scanned from the top of the menu to the bottom. Note that this index type is considered after all the others, which means that matches for menu items labelled , , or may be interpreted as the above literals, instead. Images of different formats can be created through the corresponding subclass of :\n• None for images in PGM, PPM, GIF and PNG formats. The latter is supported starting with Tk 8.6. Either type of image is created through either the or the option (other options are available as well). Changed in version 3.13: Added the method to copy a region from one image to other image, possibly with pixel zooming and/or subsampling. Add from_coords parameter to methods , and . Add zoom and subsample parameters to method . The image object can then be used wherever an option is supported by some widget (e.g. labels, buttons, menus). In these cases, Tk will not keep a reference to the image. When the last Python reference to the image object is deleted, the image data is deleted as well, and Tk will display an empty box wherever the image was used. The Pillow package adds support for formats such as BMP, JPEG, TIFF, and WebP, among others."
    },
    {
        "link": "https://stackoverflow.com/questions/110923/how-do-i-close-a-tkinter-window",
        "document": "You should use to close a Tkinter window.\n\nThe above line just bypasses the , i.e., will still be running in the background if command is executed.\n\nWhile command vanishes out , i.e., stops. completely destroys and closes the window.\n\nSo, if you want to exit and close the program completely, you should use , as it stops the and destroys the window and all its widgets.\n\nBut if you want to run some infinite loop and don't want to destroy your Tkinter window and want to execute some code after the line, you should use . Example:\n\nSee What is the difference between root.destroy() and root.quit()?."
    },
    {
        "link": "https://tkdocs.com/tutorial/windows.html",
        "document": "Everything we've done up until now has been in a single window. In this chapter, we'll cover how to use multiple windows, change various attributes of windows, and use some of the standard dialog boxes available in Tk.\n\nWe've seen that all Tk programs start out with a root toplevel window, and then widgets are created as children of that root window. Creating new toplevel windows works almost exactly the same as creating new widgets.\n\nNote: Toplevels are part of the classic Tk widgets, not the themed widgets.\n\nUnlike regular widgets, we don't have to a toplevel for it to appear onscreen. Once we've created a new toplevel, we can create other widgets as children of that toplevel and them inside the toplevel. The new toplevel behaves exactly like the automatically created root window.\n\nNote that you can use on any widget, not just a toplevel window. When you destroy a window, all windows (widgets) that are children of that window are also destroyed. Be careful! If you destroy the root window (that all other widgets are descended from), that will terminate your application.\n\nThere are lots of things about how windows behave and how they look that can be changed.\n\nTo examine or change the title of the window:\n\nIn Tk, a window's position and size on the screen are known as its geometry. A full geometry specification looks like this: .\n\nWidth and height (usually in pixels) are pretty self-explanatory. The (horizontal position) is specified with a leading plus or minus, so means the left edge of the window should be 25 pixels from the left edge of the screen, while means the right edge of the window should be 50 pixels from the right edge of the screen. Similarly, a (vertical) position of means the top edge of the window should be ten pixels below the top of the screen, while means the bottom edge of the window should be 100 pixels above the bottom of the screen.\n\nHere is an example of changing the size and position. It places the window towards the top righthand corner of the screen:\n\nYou can retrieve the current geometry the same way; just don't provide a new geometry value. However, if you try it immediately after changing the geometry, you'll find it doesn't match. Remember that all drawing effectively occurs in the background in response to idle times via the event loop. Until that drawing occurs, the internal geometry of the window won't be updated. If you do want to force things to update immediately, you can.\n\nBy default, toplevel windows, including the root window, can be resized by users. However, sometimes you may want to prevent users from resizing the window. You can do this via the method. Its first parameter controls whether users can change the width, and the second if they can change the height. So to disable all resizing:\n\nIf a window is resizable, you can specify a minimum and/or maximum size that you'd like the window's size constrained to (again, parameters are width and height):\n\nYou saw earlier how to obtain the current size of the window via its geometry. Wondering how large it would be if you didn't specify its geometry, or a user didn't resize it? You can retrieve the window's requested size, i.e., how much space it requests from the geometry manager. Like with drawing, geometry calculations are only done at idle time in the event loop, so you won't get a useful response until the widget has appeared onscreen.\n\nMost windows have a close button in their title bar. By default, Tk will destroy the window if users click on that button. You can, however, provide a callback that will be run instead. A common use is to prompt the user to save an open file if modifications have been made.\n\nWindows can be made partially transparent by specifying an alpha channel, ranging from (fully transparent) to (fully opaque).\n\nOn macOS, you can additionally specify a attribute (using the same mechanism as with ), which makes the window background transparent and removes its shadow. You should also set the configuration option for the window and any frames to the color .\n\nYou can make a window expand to take up the full screen:\n\nIn addition to the attribute described above, macOS windows boast some additional attributes.\n\nThe (red) close widget in the title bar can indicate that the content inside the window has been modified (e.g., the file needs to be saved). Set the attribute to to indicate this or to remove the modified indicator.\n\nYou can draw users' attention to the window by bouncing its icon in the macOS dock. To do so, set the window's attribute.\n\nIf a window contains the contents of a document, you can place an icon in the title bar specifying the file the document refers to. Users can drag this icon as a proxy for dragging the file in the Finder. Set the window's attribute to the full path of the file. Note that this does not change the title of the window (you'll need to change that separately) but just provides the icon.\n\nOn macOS, windows can also take a variety of appearances for different purposes, e.g., utility windows, modal dialogs, floating windows, and so on. An unsupported command in Tk called lets you assign one of these appearances to a window. Unlike many options in Tk that can be changed later, these appearances must be assigned after creating the window but before it appears onscreen.\n\nBesides , other useful appearance styles include , , and .\n\nOn most systems, you can temporarily remove the window from the screen by iconifying it. In Tk, whether or not a window is iconified is referred to as the window's state. The possible states for a window include and (for an iconified window), and several others: , , or .\n\nYou can query or set the current window state directly. There are also methods , , and ; these are shortcuts for setting the , , and states, respectively.\n\nStacking order refers to the order that windows are \"placed\" on the screen, from bottom to top. When the positions of two windows overlap each other, the one closer to the top of the stacking order will obscure or overlap the one lower in the stacking order.\n\nYou can ensure that a window is always at the top of the stacking order (or at least above all others where this attribute isn't set):\n\nYou can find the current stacking order, listed from lowest to highest:\n\nYou can also just check if one window is above or below another:\n\nYou can also raise or lower windows, either to the very top (bottom) of the stacking order, or just above (below) a designated window:\n\nWhy do you need to pass a window to get the stacking order? Stacking order applies not only for toplevel windows, but for any sibling widgets (those with the same parent). If you have several widgets gridded together but overlapping, you can raise and lower them relative to each other:\n\nWe've previously used the command to find out information about specific widgets. It can also provide information about the entire display or screen. As usual, see the command reference for full details.\n\nFor example, you can determine the screen's color depth (how many bits per pixel) and color model (usually on modern displays), its pixel density, and resolution.\n\nWhile normally you shouldn't have to pay attention to it, if you have multiple monitors on your system and want to customize things a bit, there are some tools in Tk to help.\n\nFirst, there are two ways that multiple monitors can be represented. The first is with logically separate displays. This is often the case on X11 systems, though it can be changed, e.g., using the system utility. A downside of this model is that once a window is created on a screen, it can't be moved to a different one. You can determine the screen that a Tk window is running on, which looks something like (an X11-formatted display name).\n\nWhen first creating a , you can specify the screen it should be created on using the configuration option.\n\nAlternatively, multiple monitors can also be represented as one big virtual display, which is the case on macOS and Windows. When you ask for information about the screen, Tk will return information on the primary monitor. For example, if you have two Full HD monitors side-by-side, the screen resolution will be reported as 1920 x 1080, not 3840 x 1080. This is probably a good thing; it means that if we're positioning or sizing windows, we don't need to worry about multiple monitors, and everything will just show up correctly on the primary monitor.\n\nWhat if a user moves a window from the primary monitor to a different one? If you ask for its position, it will be relative to the primary monitor. So in our side-by-side FHD monitor setup, if you call the method on a window positioned near the left edge of a monitor, it might return (if it's on the primary monitor), (if it's on a monitor to the left of the primary monitor), or (if it's on a monitor to the right of the primary monitor). You can still use the method we saw a bit earlier to position the window on a different monitor, even though the geometry specification may look a bit odd, e.g., .\n\nYou can find out approximately how large the entire display is, spanning multiple monitors. To do so, check a toplevel widget's maximum size, i.e., how large the user can resize it (you can't do this after you've already changed it, of course). This may be a bit smaller than the full size of the display. For example, on macOS, it will be reduced by the size of the menubar at the top of the screen.\n\nDialog boxes are a type of window used in applications to get information from users, inform them that some event has occurred, confirm an action, and more. The appearance and usage of dialog boxes are usually quite specifically detailed in a platform's style guide. Tk comes with several dialog boxes built-in for common tasks. These help you conform to platform-specific style guidelines.\n\nTk provides several dialogs to let users select files or directories. On Windows and macOS, these invoke the underlying operating system dialogs directly. The \"open\" variant on the dialog is used when you want users to select an existing file (like in a menu command), while the \"save\" variant is used to choose a file to save into (usually used by the menu command).\n\nAll of these commands produce modal dialogs. This means that the commands will not complete until a user submits the dialog. These commands return the full pathname of the file or directory a user has chosen or an empty string if a user cancels out of the dialog.\n\nVarious options can be passed to these dialogs, allowing you to set the allowable file types, initial directory, default filename, and many more. These are detailed in the getOpenFile (includes ) and chooseDirectory reference manual pages.\n\nAnother modal dialog lets users select a color. It will return a color value, e.g. . The dialog takes an optional option to specify an existing color, i.e., that users might want to replace. More information is available in the chooseColor reference manual pages.\n\nTk 8.6 added support for another system dialog: a font chooser. While the file dialogs and color chooser were modal dialogs that block until the dialog is dismissed and then return a result, the font chooser doesn't work like that.\n\nWhile the system font dialog is modal on some platforms, e.g., Windows, that's not the case everywhere. On macOS, the system font chooser works more like a floating tool palette in a drawing program, remaining available to change the font for whatever text is selected in your main application window. The Tk font dialog API has to accommodate both models. To do so, it uses callbacks (and virtual events) to notify your application of font changes. Additional details can be found in the fontchooser reference manual pages.\n\nTo use the font dialog, first, provide it with an initial font and a callback which will be invoked when a font is chosen. For illustration, we'll have the callback change the font on a label.\n\nNext, put the dialog onscreen via the method. On platforms where the font dialog is modal, your program will block at this point until the dialog is dismissed. On other platforms, returns immediately; the dialog remains onscreen while your program continues. At this point, a font has not been chosen. There's also a method to remove it from the screen (not terribly useful when the font dialog is modal).\n\nIf the font dialog was modal, and the user chose a font, the dialog would have invoked your callback, passing it a font specification. If they canceled out of the dialog, there'd be no callback. When the dialog isn't modal and the user chooses a font, it will invoke your callback. A <<TkFontchooserFontChanged>> virtual event is also generated; you can retrieve the current font via the dialog's configuration option. If the font dialog is closed, a <<TkFontchooserVisibility>> virtual event is generated. You can also find out if the font dialog is currently visible onscreen via the configuration option (though changing it is an error; use the and methods instead).\n\nMany applications use various simple modal alerts or dialogs to notify users of an event, ask them to confirm an action, or make another similar choice via clicking on a button. Tk provides a versatile \"message box\" that encapsulates all these different types of dialogs.\n\nLike the previous dialogs we've seen, these are modal and return the result of a user's action to the caller. The exact return value will depend on the option passed to the command, as shown here:\n\nThe full list of possible options is shown here:\n\nAdditional details can be found in the reference manual.\n\nIf you need to create your own modal dialogs, there are a few things you'll need to take care of. We've covered most of them earlier in the chapter, e.g., setting up window styles, positioning the window, etc.\n\nFirst, you need to ensure that users can only interact with your dialog. You can use to do this.\n\nIf you want your dialog function to block your application (i.e., the call to create the dialog shouldn't return until the dialog is dismissed), this is also possible. There's no reason you'd need to do this, as you can respond to callbacks, event bindings, etc., while running the normal event loop, destroy the dialog and move on.\n\nThis somewhat cryptic example includes the main steps needed to create a modal dialog.\n\nSpotted a mistake? Couldn't find what you were looking for? Suggestions? Let me know!\n\nIf you've found this tutorial useful, please check out Modern Tkinter."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-close-a-window-in-tkinter",
        "document": "Python offers multiple options for developing GUI (Graphical User Interface). Out of all the GUI methods, tkinter is the most commonly used method. It is a standard Python interface to the Tk GUI toolkit shipped with Python. Python with tkinter is the fastest and easiest way to create GUI applications. Creating a GUI using tkinter is an easy task.\n\nTo close a tkinter window, we can use the destroy() method. The destroy() is a universal widget method i.e we can use this method with any of the available widgets as well as with the main tkinter window.\n\nIn the below example, we are going to implement the destroy() method using a button.\n\nIn the above example, on clicking the button the destroy() method is called and the tkinter window is closed."
    },
    {
        "link": "https://stackoverflow.com/questions/111155/how-do-i-handle-the-window-close-event-in-tkinter",
        "document": "I'd like to thank the answer by Apostolos for bringing this to my attention. Here's a much more detailed example for Python 3 in the year 2019, with a clearer description and example code.\n\nBeware of the fact that (or not having a custom window closing handler at all) will destroy the window and all of its running callbacks instantly when the user closes it.\n\nThis can be bad for you, depending on your current Tkinter activity, and especially when using (periodic callbacks). You might be using a callback which processes some data and writes to disk... in that case, you obviously want the data writing to finish without being abruptly killed.\n\nThe best solution for that is to use a flag. So when the user requests window closing, you mark that as a flag, and then react to it.\n\nThis code will show you that the handler runs even while our custom is busy in the middle of work/loops!\n\nWe use some pretty exaggerated values: 500 milliseconds. This is just meant to make it very easy for you to see the difference between closing while the periodic call is busy, or not... If you close while the numbers are updating, you will see that the happened while your periodic call \"was busy processing: True\". If you close while the numbers are paused (meaning that the periodic callback isn't processing at that moment), you see that the close happened while it's \"not busy\".\n\nIn real-world usage, your would use something like 30-100 milliseconds, to have a responsive GUI. This is just a demonstration to help you understand how to protect yourself against Tk's default \"instantly interrupt all work when closing\" behavior.\n\nIn summary: Make the handler set a flag, and then check that flag periodically and manually the window when it's safe (when your app is done with all work).\n\nPS: You can also use to ask the user if they REALLY want to close the window; and if they answer no, you don't set the flag. It's very simple. You just show a messagebox in your and set the flag based on the user's answer."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-close-a-window-in-tkinter",
        "document": "Python offers multiple options for developing GUI (Graphical User Interface). Out of all the GUI methods, tkinter is the most commonly used method. It is a standard Python interface to the Tk GUI toolkit shipped with Python. Python with tkinter is the fastest and easiest way to create GUI applications. Creating a GUI using tkinter is an easy task.\n\nTo close a tkinter window, we can use the destroy() method. The destroy() is a universal widget method i.e we can use this method with any of the available widgets as well as with the main tkinter window.\n\nIn the below example, we are going to implement the destroy() method using a button.\n\nIn the above example, on clicking the button the destroy() method is called and the tkinter window is closed."
    },
    {
        "link": "https://stackoverflow.com/questions/110923/how-do-i-close-a-tkinter-window",
        "document": "You should use to close a Tkinter window.\n\nThe above line just bypasses the , i.e., will still be running in the background if command is executed.\n\nWhile command vanishes out , i.e., stops. completely destroys and closes the window.\n\nSo, if you want to exit and close the program completely, you should use , as it stops the and destroys the window and all its widgets.\n\nBut if you want to run some infinite loop and don't want to destroy your Tkinter window and want to execute some code after the line, you should use . Example:\n\nSee What is the difference between root.destroy() and root.quit()?."
    },
    {
        "link": "https://tkinterexamples.com/events/window",
        "document": "There are a few events that occur at the window level - namely moving, resizing and closing.\n\nWe can create a handler for when the window is moved and resized by binding to the event.\n\nNow every time we move the window we get output with the new location information for our window:\n\nNote that widgets can also bind to the event to get information aboutwhen their size and shape changes.\n\nThe application window closing is not an proper but rather a . This is an event-adjacent concept which uses slightly different syntax. We can bind to it using . Note that protocols are intercepted (not propagated) so we must be sure to destroy the object manually to ensure our window works as expected. We can use this protocol to prompt the user to confirm they want to exit. This can be used in case the user has unsaved work or something similar."
    },
    {
        "link": "https://tutorialspoint.com/how-do-i-handle-the-window-close-event-in-tkinter",
        "document": "How do I handle the window close event in Tkinter?\n\nTkinter provides a custom handler to close the window. It acts as a callback function that the user can run in order to close the window.\n\nTo close the window using the handler, we can use the destroy() method. It closes the window abruptly after calling it in any function or any widget. Let us invoke the close event handler by defining a method.\n\nBy using as an argument in Widget\n\nRunning the above code will create a button “X” and by clicking over that, we can close the main window."
    }
]