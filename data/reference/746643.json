[
    {
        "link": "https://support.sas.com/documentation/onlinedoc/sasc/doc700/html/lr1/zblesigs.htm",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/6970224/providing-passing-argument-to-signal-handler",
        "document": "You can't have data of your own passed to the signal handler as parameters. Instead you'll have to store your parameters in global variables. (And be really, really careful if you ever need to change those data after installing the the signal handler).\n\nResponse to edit 0: Historical reasons. Signals are a really old and really low-level design. Basically you're just given the kernel a single address to some machine code and asking it to go to this specific address if such and such happens. We're back in the \"portable assembler\" mindset here, where the kernels provide a no-frills baseline service, and whatever the user process can reasonably be expected to to for itself, it must do itself.\n\nAlso, the usual arguments against global variables don't really apply here. The signal handler itself is a global setting, so there is no relevant possibility of having several different sets of user-specified parameters for it around. (Well, actually it is not entirely global but only thread-global. But the threading API will include some mechanism for thread-local storage, which is just what you need in this case)."
    },
    {
        "link": "https://beej.us/guide/bgc/html/split/signal-handling.html",
        "document": "Before we start, I’m just going to advise you to generally ignore this entire chapter and use your OS’s (very likely) superior signal handling functions. Unix-likes have the family of functions, and Windows has… whatever it does .\n\nWith that out of the way, what are signals?\n\nA signal is raised on a variety of external events. Your program can be configured to be interrupted to handle the signal, and, optionally, continue where it left off once the signal has been handled.\n\nThink of it like a function that’s automatically called when one of these external events occurs.\n\nWhat are these events? On your system, there are probably a lot of them, but in the C spec there are just a few:\n\nYou can set up your program to ignore, handle, or allow the default action for each of these by using the function.\n\nThe call takes two parameters: the signal in question, and an action to take when that signal is raised.\n\nThe action can be one of three things:\n• to restore the default handler for the signal.\n\nLet’s write a program that you can’t out of. (Don’t fret—in the following program, you can also hit and it’ll exit.)\n\nCheck out line 8—we tell the program to ignore , the interrupt signal that’s raised when is hit. No matter how much you hit it, the signal remains ignored. If you comment out line 8, you’ll see you can with impunity and quit the program on the spot.\n\nI mentioned you could also write a handler function that gets called when the signal is raised.\n\nThese are pretty straightforward, are also very capability-limited when it comes to the spec.\n\nBefore we start, let’s look at the function prototype for the call:\n\nLet’s take a moment to take it apart for practice.\n\ntakes two arguments: an integer representing the signal, and a pointer to the handler (the handler returns and takes an as an argument), highlighted below:\n\nBasically, we’re going to pass in the signal number we’re interested in catching, and we’re going to pass a pointer to a function of the form:\n\nthat will do the actual catching.\n\nNow—what about the rest of that prototype? It’s basically all the return type. See, will return whatever you passed as on success… so that means it’s returning a pointer to a function that returns and takes an as an argument.\n\nAlso, it can return in case of an error.\n\nLet’s do an example where we make it so you have to hit twice to exit.\n\nI want to be clear that this program engages in undefined behavior in a couple ways. But it’ll probably work for you, and it’s hard to come up with portable non-trivial demos.\n\nOne of the things you’ll notice is that on line 14 we reset the signal handler. This is because C has the option of resetting the signal handler to its behavior before running your custom handler. In other words, it could be a one-off. So we reset it first thing so that we handle it again for the next one.\n\nWe’re ignoring the return value from in this case. If we’d set it to a different handler earlier, it would return a pointer to that handler, which we could get like this:\n\nThat said, I’m not sure of a common use case for this. But if you need the old handler for some reason, you can get it that way.\n\nQuick note on line 16—that’s just to tell the compiler to not warn that we’re not using this variable. It’s like saying, “I know I’m not using it; you don’t have to warn me.”\n\nAnd lastly you’ll see that I’ve marked undefined behavior in a couple places. More on that in the next section.\n\nWhat Can We Actually Do?\n\nTurns out we’re pretty limited in what we can and can’t do in our signal handlers. This is one of the reasons why I say you shouldn’t even bother with this and instead use your OS’s signal handling instead (e.g. for Unix-like systems).\n\nWikipedia goes so far as to say the only really portable thing you can do is call with or and that’s it.\n\nHere’s what we can’t portably do:\n• Call any standard library function.\n• Like , for example.\n• I think it’s probably safe to call restartable/reentrant functions, but the spec doesn’t allow that liberty.\n• Get or set values from a local , file scope, or thread-local variable.\n\nThat last bit– –is your ticket to getting data out of a signal handler. (Unless you want to use lock-free atomic objects, which is outside the scope of this section .) It’s an integer type that might or might not be signed. And it’s bounded by what you can put in there.\n\nYou can look at the minimum and maximum allowable values in the macros and .\n\nConfusingly, the spec also says you can’t refer “to any object with static or thread storage duration that is not a lock-free atomic object other than by assigning a value to an object declared as […]”\n\nMy read on this is that you can’t read or write anything that’s not a lock-free atomic object. Also you can assign to an object that’s .\n\nBut can you read from it? I honestly don’t see why not, except that the spec is very pointed about mentioning assigning into. But if you have to read it and make any kind of decision based on it, you might be opening up room for some kind of race conditions.\n\nWith that in mind, we can rewrite our “hit twice to exit” code to be a little more portable, albeit less verbose on the output.\n\nLet’s change our handler to do nothing except increment a value that’s of type . So it’ll count the number of s that have been hit.\n\nThen in our main loop, we’ll check to see if that counter is over , then bail out if it is.\n\nUndefined behavior again? It’s my read that this is, because we have to read the value in order to increment and store it.\n\nIf we only want to postpone the exit by one hitting of , we can do that without too much trouble. But any more postponement would require some ridiculous function chaining.\n\nWhat we’ll do is handle it once, and the handler will reset the signal to its default behavior (that is, to exit):\n\nLater when we look at lock-free atomic variables, we’ll see a way to fix the version (assuming lock-free atomic variables are available on your particular system).\n\nThis is why at the beginning, I was suggesting checking out your OS’s built-in signal system as a probably-superior alternative.\n\nAgain, use your OS’s built-in signal handling or the equivalent. It’s not in the spec, not as portable, but probably is far more capable. Plus your OS probably has a number of signals defined that aren’t in the C spec. And it’s difficult to write portable code using anyway."
    },
    {
        "link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers",
        "document": "Accessing or modifying shared objects in signal handlers can result in race conditions that can leave data in an inconsistent state. The two exceptions (C Standard, 5.1.2.3, paragraph 5) to this rule are the ability to read from and write to lock-free atomic objects and variables of type . Accessing any other type of object from a signal handler is undefined behavior. (See undefined behavior 131.)\n\nThe need for the keyword is described in DCL22-C. Use volatile for data that cannot be cached.\n\nThe type is the integer type of an object that can be accessed as an atomic entity even in the presence of asynchronous interrupts. The type of is implementation-defined, though it provides some guarantees. Integer values ranging from through , inclusive, may be safely stored to a variable of the type. In addition, when is a signed integer type, must be no greater than and no less than . Otherwise, must be and must be no less than . The macros and are defined in the header .\n\nAccording to the C99 Rationale [C99 Rationale 2003], other than calling a limited, prescribed set of library functions,\n\nHowever, this issue was discussed at the April 2008 meeting of ISO/IEC WG14, and it was agreed that there are no known implementations in which it would be an error to read a value from a variable, and the original intent of the committee was that both reading and writing variables of would be strictly conforming.\n\nThe signal handler may also call a handful of functions, including (See SIG30-C. Call only asynchronous-safe functions within signal handlers for more information.)\n\nIn this noncompliant code example, is updated to indicate that the signal was delivered. The variable is a character pointer and not a variable of type .\n\nFor maximum portability, signal handlers should only unconditionally set a variable of type and return, as in this compliant solution:\n\nSignal handlers can refer to objects with static or thread storage durations that are lock-free atomic objects, as in this compliant solution:\n\nSIG31-C-EX1: The C Standard, 7.14.1.1 paragraph 5 [ISO/IEC 9899:2024], makes a special exception for when a valid call to the function results in a return, allowing to take an indeterminate value. (See ERR32-C. Do not rely on indeterminate values of errno.)\n\nAccessing or modifying shared objects in signal handlers can result in accessing data in an inconsistent state. Michal Zalewski's paper \"Delivering Signals for Fun and Profit\" [Zalewski 2001] provides some examples of vulnerabilities that can result from violating this and other signal-handling rules.\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website."
    },
    {
        "link": "https://stackoverflow.com/questions/42182435/volatile-for-signal-handler-and-multi-threading",
        "document": "is used to make sure that the contents of the variable is read from its actual location (memory, in our case) rather than from a CPU register.\n\nIn other words, whenever an \"outside\" event might change the value of a variable, you should consider using (\"outside\" - as in, outside the relevant code block).\n\nIn both your examples, you are using the variable as a flag to signal a change in behavior. This flag, in both examples, is controlled by events \"outside\" the loop that that is reviewing the flag. For this reason, both examples require the use of the keyword.\n\nIt should be noted does not provide thread safety for a number of reasons. To make sure an object is thread safe, read/write operations must be either protected or atomic."
    },
    {
        "link": "https://geeksforgeeks.org/pipe-system-call",
        "document": "Conceptually, a pipe is a connection between two processes, such that the standard output from one process becomes the standard input of the other process. In UNIX Operating System, Pipes are useful for communication between related processes(inter-process communication).\n• None Pipe is one-way communication only i.e we can use a pipe such that One process write to the pipe, and the other process reads from the pipe. It opens a pipe, which is an area of main memory that is treated as a “virtual file”\n• None The pipe can be used by the creating process, as well as all its child processes, for reading and writing. One process can write to this “virtual file” or pipe and another related process can read from it.\n• None If a process tries to read before something is written to the pipe, the process is suspended until something is written.\n• None The pipe system call finds the first two available positions in the process’s open file table and allocates them for the read and write ends of the pipe.\n\nint pipe(int fds[2]);Parameters :fd[0] will be the fd(file descriptor) for the read end of pipe. fd[1] will be the fd for the write end of pipe. Returns :-1\n\nPipes behave FIFO(First in First out), Pipe behave like a queue data structure. Size of read and write don’t have to match here. We can write 512 bytes at a time, but we can read only 1 byte at a time in a pipe.\n\nWhen we use fork in any process, file descriptors remain open across child process and also parent process. If we call fork after creating a pipe, then the parent and child can communicate via the pipe.\n\nOutput of the following program.\n\nHere, In this code After finishing reading/writing, both parent and child block instead of terminating the process and that’s why program hangs. This happens because read system call gets as much data it requests or as much data as the pipe has, whichever is less.\n• None If pipe is empty and we call read system call then Reads on the pipe will return EOF (return value -1) if no process has the write end open.\n• None If some other process has the pipe open for writing, read will block in anticipation of new data so this code output hangs because here write ends parent process and also child process doesn’t close.\n\nFor more details about parent and child sharing pipe, please refer C program to demonstrate fork() and pipe()"
    },
    {
        "link": "https://tutorialspoint.com/inter_process_communication/inter_process_communication_pipes.htm",
        "document": "Pipe is a communication medium between two or more related or interrelated processes. It can be either within one process or a communication between the child and the parent processes. Communication can also be multi-level such as communication between the parent, the child and the grand-child, etc. Communication is achieved by one process writing into the pipe and other reading from the pipe. To achieve the pipe system call, create two files, one to write into the file and another to read from the file.\n\nPipe mechanism can be viewed with a real-time scenario such as filling water with the pipe into some container, say a bucket, and someone retrieving it, say with a mug. The filling process is nothing but writing into the pipe and the reading process is nothing but retrieving from the pipe. This implies that one output (water) is input for the other (bucket).\n\nThis system call would create a pipe for one-way communication i.e., it creates two descriptors, first one is connected to read from the pipe and other one is connected to write into the pipe.\n\nDescriptor pipedes[0] is for reading and pipedes[1] is for writing. Whatever is written into pipedes[1] can be read from pipedes[0].\n\nThis call would return zero on success and -1 in case of failure. To know the cause of failure, check with errno variable or perror() function.\n\nEven though the basic operations for file are read and write, it is essential to open the file before performing the operations and closing the file after completion of the required operations. Usually, by default, 3 descriptors opened for every process, which are used for input (standard input stdin), output (standard output stdout) and error (standard error stderr) having file descriptors 0, 1 and 2 respectively.\n\nThis system call would return a file descriptor used for further file operations of read/write/seek (lseek). Usually file descriptors start from 3 and increase by one number as the number of files open.\n\nThe arguments passed to open system call are pathname (relative or absolute path), flags mentioning the purpose of opening file (say, opening for read, O_RDONLY, to write, O_WRONLY, to read and write, O_RDWR, to append to the existing file O_APPEND, to create file, if not exists with O_CREAT and so on) and the required mode providing permissions of read/write/execute for user or owner/group/others. Mode can be mentioned with symbols.\n\nFor example: Octal value (starts with 0), 0764 implies owner has read, write and execute permissions, group has read and write permissions, other has read permissions. This can also be represented as S_IRWXU | S_IRGRP | S_IWGRP | S_IROTH, which implies or operation of 0700|0040|0020|0004 → 0764.\n\nThis system call, on success, returns the new file descriptor id and -1 in case of error. The cause of error can be identified with errno variable or perror() function.\n\nThe above system call closing already opened file descriptor. This implies the file is no longer in use and resources associated can be reused by any other process. This system call returns zero on success and -1 in case of error. The cause of error can be identified with errno variable or perror() function.\n\nThe above system call is to read from the specified file with arguments of file descriptor fd, proper buffer with allocated memory (either static or dynamic) and the size of buffer.\n\nThe file descriptor id is to identify the respective file, which is returned after calling open() or pipe() system call. The file needs to be opened before reading from the file. It automatically opens in case of calling pipe() system call.\n\nThis call would return the number of bytes read (or zero in case of encountering the end of the file) on success and -1 in case of failure. The return bytes can be smaller than the number of bytes requested, just in case no data is available or file is closed. Proper error number is set in case of failure.\n\nTo know the cause of failure, check with errno variable or perror() function.\n\nThe above system call is to write to the specified file with arguments of the file descriptor fd, a proper buffer with allocated memory (either static or dynamic) and the size of buffer.\n\nThe file descriptor id is to identify the respective file, which is returned after calling open() or pipe() system call.\n\nThe file needs to be opened before writing to the file. It automatically opens in case of calling pipe() system call.\n\nThis call would return the number of bytes written (or zero in case nothing is written) on success and -1 in case of failure. Proper error number is set in case of failure.\n\nTo know the cause of failure, check with errno variable or perror() function.\n\nFollowing are some example programs.\n\nExample program 1 − Program to write and read two messages using pipe.\n\nStep 3 − Retrieve the message from the pipe and write it to the standard output.\n\nStep 4 − Send another message to the pipe.\n\nStep 5 − Retrieve the message from the pipe and write it to the standard output.\n\nNote − Retrieving messages can also be done after sending all messages.\n\nNote − Ideally, return status needs to be checked for every system call. To simplify the process, checks are not done for all the calls.\n\nExample program 2 − Program to write and read two messages through the pipe using the parent and the child processes.\n\nStep 4 − Child process retrieves the message from the pipe and writes it to the standard output.\n\nStep 5 − Repeat step 3 and step 4 once again.\n\nPipe communication is viewed as only one-way communication i.e., either the parent process writes and the child process reads or vice-versa but not both. However, what if both the parent and the child needs to write and read from the pipes simultaneously, the solution is a two-way communication using pipes. Two pipes are required to establish two-way communication.\n\nFollowing are the steps to achieve two-way communication −\n\nStep 1 − Create two pipes. First one is for the parent to write and child to read, say as pipe1. Second one is for the child to write and parent to read, say as pipe2.\n\nStep 3 − Close unwanted ends as only one end is needed for each communication.\n\nStep 4 − Close unwanted ends in the parent process, read end of pipe1 and write end of pipe2.\n\nStep 5 − Close the unwanted ends in the child process, write end of pipe1 and read end of pipe2.\n\nStep 1 − Create pipe1 for the parent process to write and the child process to read.\n\nStep 2 − Create pipe2 for the child process to write and the parent process to read.\n\nStep 3 − Close the unwanted ends of the pipe from the parent and child side.\n\nStep 4 − Parent process to write a message and child process to read and display on the screen.\n\nStep 5 − Child process to write a message and parent process to read and display on the screen."
    },
    {
        "link": "https://opensource.com/article/19/4/interprocess-communication-linux-channels",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/named-pipe-fifo-example-c-program",
        "document": "Named Pipe or FIFO with example C program\n\nIn computing, a named pipe, also known as a FIFO (First In, First Out), is a powerful mechanism for inter-process communication (IPC). Unlike unnamed pipes, which are temporary and exist only as long as the process that created them is running, named pipes provide a persistent communication channel between processes, surviving beyond the life of the process that created them. This makes named pipes an essential tool for developers who need processes to exchange data reliably and efficiently.\n\nA named pipe is an extension of the traditional pipe concept in Unix. While a traditional pipe is “unnamed” and exists only temporarily, a named pipe can persist as long as the system is up or until it is explicitly deleted. Named pipes appear as special files in the filesystem, and multiple processes can attach to them for reading and writing, facilitating inter-process communication.\n\nA FIFO file allows two or more processes to communicate by reading from and writing to the same file. This file type is created using the ‘mkfifo()’ system call in C. Once created, any process can open the named pipe for reading or writing, similar to how it would handle an ordinary file. However, it is important to note that a named pipe must be opened simultaneously at both ends (for reading and writing) before any input or output operations can occur.\n\nHow to Create a Named Pipe (FIFO) in Unix\n\nTo create a FIFO special file, you use the ‘mkfifo()’ function in C. The function creates a named pipe with the specified pathname and permissions.\n\n\n\n‘mkfifo()’ makes a FIFO special file with name pathname. Here ‘mode’ specifies the FIFO’s permissions. It is modified by the process’s umask in the usual way: the permissions of the created file are (mode & ~umask).\n\nUsing FIFO: As named pipe(FIFO) is a kind of file, we can use all the system calls associated with it i.e. open, read, write, close.\n\nExample Programs to illustrate the named pipe: There are two programs that use the same FIFO. Program 1 writes first, then reads. The program 2 reads first, then writes. They both keep doing it until terminated.\n\n\n\nOutput: Run the two programs simultaneously on two terminals.\n\n\n\nThe Named pipes (FIFOs) are a robust method for the inter-process communication allowing data to be passed between the processes using a named file. This mechanism is useful in the scenarios where processes need to exchange data without direct knowledge of the each other. The example demonstrates a simple producer-consumer model where one process writes data to a FIFO and another reads it showcasing the basic usage of the named pipes in C.\n\nNamed Pipe or FIFO with Example C Program – FAQs\n\nWhat is the primary difference between a named pipe and an unnamed pipe?\n\nHow do I handle errors when working with FIFOs?\n\nCan multiple processes write to or read from the same FIFO?"
    },
    {
        "link": "https://softprayog.in/programming/interprocess-communication-using-pipes-in-linux",
        "document": "A process is an active operating system entity which executes programs. Normally, a process, like a specialist, does one particular job (well). In real life, there are complex workflows and we, often, have multiple processes collaborating to accomplish certain objectives. In order to work together, processes need to exchange data. So we have various interprocess communication (IPC) mechanisms. One of the most fundamental IPC mechanism is the pipe, which symbolizes data flowing sequentially between processes in a pipeline.\n\nTwo processes can be joined by the pipe symbol (|) on the shell command line. The standard output of the first process becomes the standard input for the second process. For example,\n\nThe standard output of ls becomes the standard input for more. Individually, both ls and more are oblivious of the fact that the respective standard output or standard input is not to or from the default device but is going to or coming from another process. Conceptually, two processes connected with a pipe look like this,\n\ntitle = “Two processes connected with a pipe”\n\n Both P1 and P2 execute concurrently and P1 passes data to P2 as it executes. The pipe system call returns two file descriptors (int pfd [2]), the one for writing to the pipe (pfd [1]) and the another (pfd [0]) for reading from the pipe. Using the respective file descriptor, one can use the read or write system call for reading from or writing to a pipe just like a file.\n\nThere are two system calls which are relevant here – the pipe system call and the dup system call.\n\nAfter the pipe system call executes, the array pipefd [2] contains two file descriptors, pipefd [0] is for reading from the pipe and pipefd [1] is for writing to the pipe. It is theoretically possible to both read and write from the same pipe end. But, generally, one would either read from or write to a pipe end only and not do both. So, if the pipe is being used for reading, the write file descriptor is closed, and vice-versa.\n\ndup system calls duplicate file descriptors. You pass a file descriptor and dup finds a file descriptor which is currently closed, makes it open to the same file or pipe) and returns it to the caller.\n\ndup returns the lowest numbered file descriptor. So if you close file descriptor 1 (standard output), and assume file descriptor 0 is still open, and have another file descriptor (fd) open to a file and call dup with fd as argument, dup would return 1 and further writes to standard output would result in writing to file originally opened with the fd file descriptor. It is somewhat simpler to use the dup2 system call, which takes oldfd and newfd file descriptors as parameters. dup2 makes newfd a copy of the oldfd, closing newfd if it were already open.\n\nIn this example, we will write code for a process which creates the pipeline,\n\nIt is worth noting that any two arbitrary processes cannot communicate using a pipe. The pipe has to be set by the parent process and the children can just use it (often, without knowing about it).\n\nWe can compile and run the above program.\n\nThe parent process creates a pipe. Now, we must remember that a process's system data comprising of open file descriptors and other items like the current directory, the accumulated CPU time, etc. is inherited by the child process and is preserved across the exec system calls. So, when a parent makes a pipe and forks a child and, then, execs the child program, the child gets the pipe file descriptors. Actually, the parent duplicates the pipe file descriptor to be used by the child from the standard input or output file descriptor and closes the pipe file descriptors. The child reads from the standard input or writes to the standard output as per its program, but actually, courtesy parent, it is reading from or writing to the pipe."
    },
    {
        "link": "https://stackoverflow.com/questions/40498681/program-with-fork-and-signal-handling-in-c",
        "document": "Your naming confused me. It appears that your problem is your variable named . That isn't the son aka child process. That's the parent.\n\nThe call returns twice. Once in the parent and once in the child. In the parent it returns the child's PID. It returns 0 in the child. You have them reversed!\n\nYou are using instead of . I recommend using . It is much more complicated but gives many more options as well.\n\nThe problem you're having with is that after the handler is called it resets the signal to default behavior. But that isn't guaranteed either. The GNU C library has it behave differently depending on if , or nothing is defined. That is to simulate how it behaved on BSD UNIX or SYSV UNIX. And that's why is a better choice, it acts the same on every POSIX system."
    },
    {
        "link": "https://stackoverflow.com/questions/13710650/c-fork-and-signals",
        "document": "What I want to do is create a parent process that lasts for 5 seconds. I also want it to send a signal every second. On this signal I want the child to do something.\n\nThe code that I put together so far is:\n\nWhat I get is:"
    },
    {
        "link": "https://geeksforgeeks.org/signals-c-set-2",
        "document": "Communication between two process using signals in C\n\nPrerequisite : C signal handling In this post, the communication between child and parent processes is done using kill() and signal(), fork() system call.\n• fork() creates the child process from the parent. The pid can be checked to decide whether it is the child (if pid == 0) or the parent (pid = child process id).\n• None The parent can then send messages to child using the pid and kill().\n• None The child picks up these signals with signal() and calls appropriate functions.\n\nExample of how 2 processes can talk to each other using kill() and signal():\n\nWhat is signal handling in C?\n\nSignal handling is a way of dealing with interrupts, exceptions, and signals sent to a process by the operating system or another process. In C, we can use the signal() function to register signal handlers to handle specific signals.\n\nWhat is the purpose of fork() system call in the program?\n\nThe fork() system call creates a new child process by duplicating the calling process. The child process is an exact copy of the parent process, including all its memory and open file descriptors.\n\nHow does the parent process communicate with the child process in this program?\n\nThe parent process sends signals to the child process using the kill() function, passing the child process ID and the signal number as arguments.\n\nHow does the child process handle signals sent by the parent process?\n\nThe child process sets up signal handlers for the signals it expects to receive using the signal() function. When a signal is received, the corresponding signal handler function is called.\n\nWhat is the purpose of the for(;;) loop in the child process?\n\nThe for(;;) loop is an infinite loop that keeps the child process running and waiting for signals to be received. Without this loop, the child process would exit immediately after setting up its signal handlers."
    },
    {
        "link": "https://devzery.com/post/your-ultimate-guide-to-c-handlers",
        "document": "In C programming, handlers are a fundamental concept, especially when dealing with signals and events that require immediate attention. Signal handling in C allows programs to capture asynchronous events and execute specific functions in response. This guide will explore the intricacies of C handlers, focusing on signal handling, and provide comprehensive insights into their implementation, usage, and best practices.\n\nA handler in C is a function designed to manage specific events or signals. When an event occurs, the system interrupts the normal flow of execution and invokes the appropriate handler function to address the event.\n\nSignal handling is a mechanism by which a program can intercept and respond to specific signals. Signals are notifications sent to a process to notify it of various events such as segmentation faults, interrupts, or termination requests.\n\nBest Practices for Signal Handling in C\n\nSignal handling in C is a powerful mechanism that allows programs to interact with asynchronous events efficiently. By understanding and implementing proper signal handlers, you can create robust and responsive applications. Remember to follow best practices and be mindful of common issues to ensure your signal handling is effective and reliable.\n\nEnsure the correct signal number is used, the handler is properly registered, and there are no conflicts with other handlers."
    },
    {
        "link": "https://reddit.com/r/cprogramming/comments/12o3438/fork_and_its_practical_use_cases",
        "document": "I was just looking at some documentation and came across . In the examples, there was some pretty complex dance happening between parent and child process, sending signals to each other and stuff. It seemed rather complex.\n\nIs and resulting process doing something special that can not be achieved by threads? What are some practical use cases of ? Is it a relic from past or is it still being used today?"
    }
]