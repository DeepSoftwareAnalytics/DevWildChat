[
    {
        "link": "https://forums.unrealengine.com/t/knowledge-base-primer-loading-content-and-pak-files-at-runtime/536669",
        "document": "The PakDemo project demonstrates a standalone application created by an Unreal Engine Project that can load assets from a .pak file from the local files..."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/packaging-unreal-engine-projects",
        "document": "Several steps are performed during the packaging process. Project-specific source code will be compiled first. Once the code is compiled, all required content will be converted, or \"cooked,\" into a format that can be used by the target platform. Following that, the compiled code and cooked content will be bundled into a distributable set of files, such as an installer.\n\nUnder the main File menu, there is an option called Package Project, with a submenu. This submenu provides a list of all supported platforms for which you can package your project.\n\nThere are also some Advanced options you can set before packaging.\n\nBefore packaging your game, you will first need to set a Game Default Map, which will load when your packaged game starts. If you do not set a map and are using a blank project, you will only see a black screen when the packaged game starts. If you have used one of the template maps, like the First Person template or Third Person template, the starting map will be loaded.\n\nTo set the Game Default Map, click on Edit > Project Settings > Maps & Modes in the Editor's main menu:\n\nTo package a project for a specific platform, click on File > Package Project > [PlatformName] in the Editor's main menu:\n\nYou will be presented with a dialog for selecting the target directory. If packaging completes successfully, this directory will then contain the packaged project.\n\nConfirming the target directory will then initiate the actual process that packages the project for the selected platform. Because packaging can be very time consuming, this process is executed in the background, and you can continue to use the Editor. A status indicator will be displayed in the bottom right corner of the Editor to indicate the progress:\n\nThe status indicator also provides a Cancel button to stop the packaging process. In addition, the Show Log link can be used to display extended output log information, which is useful for figuring out what went wrong if the packaging process fails, or for catching warnings that could reveal potential bugs in the product:\n\nThe most important log messages, such as errors and warnings, are logged to the regular Message Log window:\n\nTo submit an iOS or Android game to the App Store or Google Play Store, you need to create your package in Distribution mode. To do this, go to the Packaging Settings option in the Packaging menu, and check the Distribution check box.\n\nOn iOS, you will need to create a Distribution Certificate and MobileProvision on Apple's developer website. Install the Distribution Certificate the same way as your Development certificate, and name your distribution provision with a \"Distro_\" prefix, next to your other one (so you would have both and ).\n\nOn Android, you will need to create a key to sign the file, and give some information to our build tools with a file called . This file exists in the installed Engine directory ( ). If you edit this file, it will apply to all your projects. However, you can copy this file to your project's directory (without the subdirectory), and it will be used for just that project. Directions for how to generate the key and fill out the file are found in the file itself.\n\nClicking File > Package Project > Packaging Settings... or Edit > Project Settings > Packaging in the main menu will present you with some advanced configuration options for the packaging feature.\n\nWhen distributed in a shipped product, files can be signed or encrypted, usually to hinder data extraction or tampering. To activate, deactivate, or adjust the cryptographic settings on your project, go to the Project Settings menu and find the Crypto section.\n\nThe cryptographic options within the Project Settings menu.\n\nThe following settings are available from this menu:\n\nIn addition, keys for signing or encryption can be set or cleared.\n\nAs a developer, when iterating over new or modified game content, you may not always want to go through the lengthy process of packaging everything into the staging directory and then running it from there. It is, therefore, possible to only cook the content for a particular target platform without packaging it by clicking File > Cook Content > [PlatformName].\n\nShort loading times are essential for open-world games but are valuable in every type of game. The Unreal Engine provides several methods to optimize your project's loading time during the packaging process. Here are some recommended practices to decrease the loading time in your games. For information on how to package your project, see the Packaging and Cooking Games section.\n\nUsing the Event Driven Loader (EDL) and the Asynchronous Loading Thread (ALT)\n• The Asynchronous Loading Thread (ALT) is turned off by default but can be turned on in the Project Settings menu under the Engine > Streaming section. For modified engines, some tweaks may be needed, but in general, ALT should double the speed of loading, including games with \"up-front\" loading times and games that constantly stream data. The ALT works by running serialization and post-loading code concurrently on two separate threads, and as a result, it adds the requirement that class constructors, functions, and functions in your game code must be thread-safe. When activated, ALT doubles loading speed. For further information about using asynchronous loading methods (in C++), see the Asynchronous Asset Loading page.\n• The Event-Driven Loader is activated by default, but can be deactivated in the Project Settings menu under the Engine > Streaming section. For most projects, the EDL will cut load times in half. The EDL is stable and can be back-ported to older versions of the Unreal Engine, or can be tweaked for modified or customized engine versions.\n• To use file compression in your project, open Project Settings and find the Packaging section. In that section, open the advanced part of the Packaging heading and check the box labeled \"Create compressed cooked packages\" that appears.\n• Most platforms don't provide automatic compression, and compressing your files will decrease loading times, but there are a few special cases to consider:\n\nCheck this box to enable compression in your .pak files.\n\nA well-ordered file is critical to reducing load times. To assist with ordering your file optimally, UE4 provides a set of tools to discover the order in which your data assets are needed, and build faster-loading packages. Conceptually, this process is similar to profile-guided optimization. Follow this method to order our file:\n• Build and run the packaged game with the command-line option, which causes the engine to log the order in which it opens files.\n• Exercise all major areas of the game. Load every level, every playable character, every weapon, every vehicle, and so on. Once everything has been loaded, quit the game.\n• There will be a file in your deployed game called that contains the information needed to optimize your .pak file order. For example, on Windows builds, the file will be found in . Copy this file to your development directory under the path. There will be a file in your deployed game called that contains the information needed to optimize your .pak file order. For example, on Mac builds, the file will be found in . Copy this file to your development directory under the path.\n• With the log file in place, rebuild the file. This and all future files produced will use the file order indicated in the log file.\n\nIn a production environment, the log file should be checked into source control and updated periodically with the results of new runs, including a final run when the game is ready to ship."
    },
    {
        "link": "https://forums.unrealengine.com/t/package-async-load-vs-openlevel-vs-travel/355703",
        "document": "How to open level asynchronously, without visible after load?\n\nI have tryed Streaming Levels, but this is not what i need. Because if i make level - Steamable and then use UGameplayStatics::LoadStreamLevel, then level is loaded, but GameMode, PlayerController and HUD is not changed. I need it to be changed, like..."
    },
    {
        "link": "https://forums.unrealengine.com/t/loadpackageasync-always-fails-if-file-string-not-correctly-formated/350702",
        "document": "I was looking into loading asset elements using LoadPackageAsync and get it crashed every time I passed a filename even if this file exists. If I the log file I have the corresponding massage : “LoadPackageAsync failed to begin to load a package because the supplied package name was neither a valid long package name nor a filename of a map within a content folder: ’ '”. When I investigating why this problem happens, I think I discover where the problem comes from. In the file AsyncLoading.cpp, in the function the line always failed because PackageName is never initialised and this error will never recover. I don’t know if this is actually the right behaviour but its strange to make some test that always fails. I set up a workaround so it don’t have to call the previous test.\n\nThe problem (for me) was that the test FPackageName::IsValidLongPackageName() always fail because the file has format that is incompatbible , because it contains ‘.’ and the path isn’t one of the path the engine is looking for. So to solve it I add this line of code before calling the RequestAsyncLoad of the streamable manage : if the UnrealProject directory is in your document directory. [ProjectName] is the name of your project.\n\n If you are looking for engine file replace with and “/Game” by “/Engine”.\n\n Hope it helps\n\nI apologize for the delayed response and I’m glad you were able to find a solution to the issue. Unfortunately I am not familiar with using LoadPackageAsync and have not been able to setup a reproduction case for investigation. You supplied a sample project when I found does not package successfully but I don’t believe this is what you’re referring to. Can you provide any further information that would help me understand exactly what you’re attempting to do and what is failing for you?\n\nIndeed there is a problem when packaging a file.\n\n If you want to create from a new project here is the step :\n• In the Project.Build.cs add in public dependency the string “PakFile”, “StreamingFile”;link text\n• In the project settings>General settings seleect the Singleton class for Game Singleton Class;\n• Create a blueprint class from the ImportPakFile and place the actor in the world;\n• Create a package and move it to your project directory/Paks/ExternalContent (path to create) [Optoinally] To change the loading path, you need to change it in the ImportPakFile in the function RunLoad(). It should take each package in the directory.\n• To run the crash you have to run th RunLoad() function You will find attached the c++ and cs file defined (there are the same as in the testlevel. I try to load a dynamically a 3D object. The problem is that I can’t load in game FBX file and because the file loaded are numerous and very big. In addition as the game will evolve in time, we don’t want to repackage each time the game, we choose to load the package file generated by the UnrealPak.exe. Maybe there is another solution but I am not aware of this.\n\nI was able to reproduce the crash that you’re getting, but I wanted to try to clarify some things before reporting this issue, so that I’m sure that we have the correct information. From reading over the previous comments, it seems as though your issue was that the output from FPackageName::IsValidLongPackageName() is not able to be used with RequestAsyncLoad due to the format that it’s in. Trying to do this results in this crash, correct? If I’ve missed anything, please let me know and I’ll add it to the report. Thank you for your cooperation in this matter as well.\n\nMaybe I misunderstand your reply but the function FPackageName::IsValidLongPackageName() itself won’t crash. As it is use for testing the package name, if the function return false, a second set of test will be done. It they also fails then there is a call to a UE_LOG(Fatal) which crash the game.\n\n The reason the test fails are due to the filename is empty. That’s why I sugest to remove the first “…/…” in my answer\n\nThe program goal is to load elements contained from a pakage generated by Unreal Engine. After mounting it I look for the files containing it and try, if it is a uasset, to load it (function FAssetStreamer::StreamPackage). The uasset name and path is given when I call the function on IterateDirectoryRecursively (function FindAllPakFiles). Dependgin on the the mounting path the path may be different but in my case it is something like …/…/…/…/…/…/Users/[UserName]/Documents/Unreal Projects/[ProjectName]/Content. When I call StreamableManager::RequestAsyncLoad with this path the program crash and when I investigate further I get a empty string before calling FPackageName::IsValidLongPackageName(). That is why I suggest to remove …/… because without it I get a valid package name and no crash"
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/assets-and-packages?application_version=4.27",
        "document": "An Asset is a piece of content for an Unreal Engine project, and can be thought of as a serialized to a file. In the Content Browser's Sources Panel, you can display the Asset Tree by clicking the Show/Hide Sources and Collections button.\n• The Asset Tree displays a list of folders in your content directories where .uasset files reside.\n• Clicking on a folder in the Asset Tree shows you all the Assets found in that folder and its subfolders.\n• Right-clicking on a folder shows you a list of actions you can do to that folder and Assets in the folder or its subfolders. You can add new folders to the Asset Tree via this context menu.\n\nIt is recommended that you move Assets from within the Content Browser. This is because references to Assets include the full directory path to the Asset. If you move an Asset, its path will change. You can move Asset files between folders outside of the Unreal Editor, but do not expect references to remain intact. Level (.umap) files are not affected by this restriction.\n\nFor more information on using the Content Browser to move, rename, add, and delete Assets, see Working with Assets.\n\nThe user names an Asset when importing or creating it. The Asset's path is directly associated with the Asset's location on disk. The folder in which the Asset is created or imported automatically sets this path. For example, a path of Content/Characters/MyCharacter would save to /UE4/MyProject/Content/Characters/MyCharacter.MyCharacter.uasset.\n\nAn Asset can be renamed in the Editor by selecting it in the Content Browser, then left-clicking on its name or pressing the F2 key. Assets can be moved or copied to different folders by being selected and dragged in the Content Browser. When renamed or moved in this way, other Assets that refer to the renamed or moved Asset will be updated appropriately, and an invisible Redirector will be left in place of the original Asset. Redirectors can be cleaned up by right-clicking in the Content Browser and selecting Fix Up Redirectors in Folder. All Assets that referenced a Redirector will point to the Asset in its new location, then remove the Redirector. Note that you need to resave the Assets. You can delete Assets within the Content Browser, either by using the option in the context menu on the Asset, or by selecting the Asset and pressing the Delete key. If an Asset is referenced by other Assets, a menu displays asking which existing Asset (if any) should be used in place of the deleted one.\n\nRight-clicking on a folder or anywhere in the Sources Panel of the Content Browser provides access to the Fix Up Redirectors in Folder option.\n\nReferences to Assets contain the path in the reference. For example: Blueprint'/MyProject/Content/Characters/MyCharacter.MyCharacter'.\n\nUnreal Engine generally loads and unloads Assets automatically by Unreal Engine. However, there are cases where taking more direct control over the process can result in significant performance improvements, such as reduction or elimination of redundant load times, and removal of hitches during gameplay. For detailed information about managing Asset loading and unloading, see the Asset Management page. When deploying a project, Assets are \"cooked\" (converted to final, binary formats dependent on the Asset type and target platform) and can be separated into multiple .pak files for distribution. For information on these processes, see Cooking and Chunking.\n\nWhen a workflow includes package files that each contain several Assets, source-control contention can be an issue. A workflow that instead supports and encourages creating many individual Asset files means that each Asset can be checked out individually. This reduces source-control contention and bottlenecks in workflow.\n\nAdditionally, sync time in content management systems is faster with individual Asset files than with packages containing multiple Assets, because a change to a single Asset requires only one file update.\n\nIn Unreal Editor, Assets are stored in .uasset files, each of which typically contains only a single Asset. Each Asset reference contains a directory-style path that uniquely identifies any Asset in the game.\n\nAssets are created (or imported) in the Content Browser. For information about creating Assets, see Working with Content. For information about working with the Content Browser, see Content Browser.\n\nYou can use the Migrate Tool in the Content Browser to create a copy of an Asset (and any dependent Assets) for use in another project.\n\nFor more information about the Migrate Tool, see Migrating Assets.\n\nIf you have downloaded Asset packs through the Launcher, you can add the entire contents of the pack to your project (whether it is open or closed) without needing to open it or migrate specific Assets.\n\nTo add an Asset pack to your project:\n• Find the Asset pack in your Vault which is located at the bottom of the Library tab.\n• Select your project in the list that appears.\n\nAll of the content will be inside a folder named after the Asset pack you added."
    },
    {
        "link": "https://forums.unrealengine.com/t/asynchronous-loading-and-unloading-constantly-is-this-a-good-idea/2347042/11",
        "document": "I would also just add to this that actor components are pretty finicky when it comes to keeping them any where out of the actors themselves. Moving them from actor to actor also costs performance.\n\nThis thread also tackles the problem of if you are driving logic in actor components with tick enabled inside of them you will pay the penalty of a single actor constantly evaluating multiple ticks.\n\nI would make a uobject (object) derived class that would get it’s tick update from a central ai manager. Guess it all depends on how complex you want the logic inside of the ai building blocks.\n\nPersonally I’d probably start off with state trees as their logic seems a bit more straightforward than behavior trees and already look like an ok system. They are internally optimized."
    },
    {
        "link": "https://forums.unrealengine.com/t/async-load-asset-is-really-unstable/1944700",
        "document": "I am trying to replace hard references with soft references for in-game information exchange.\n\n However, inconsistent results of Async Load Asset loading made everything a mess.\n\n It’s actually more complicated but rough explanation of the process is, Press the button, send soft references to UI and SaveGame and Model Spawner, Load and Cast if the destination uses a hard reference. SaveGame uses soft references, the UI and spawners use hard references.\n\n It worked fine when I was running everything with hard references.\n\n However, after replacing soft reference, assets may not load completely, result in inaccurate UI display and models not spawning.\n\n It may take a couple of reloads to get it to work as intended, but it’s pointless if it doesn’t work correctly the first time.\n\n Can someone help me?\n\nAsync loading node has two outputs, upper one continues/leaves node in same frame that it was called (before asset is ready), bottom one continues when the asset finished loading. Make sure you don’t try to use the asset before it finished loading and that’s pretty much it. Don’t rely on delay nodes with this approach as loading times can vary.\n\nApparently there’s something wrong with your code, when you say that after couple of reloads it’s working as intended it only means that all the assets are finally in memory so the ‘async load’ completion is instant. My guess is that you are using casts somewhere in code that expect variables to be set but they aren’t yet, due to assets loading.\n\n For example ui widget is async loading icons before creating compass widget and you try to access compass widget from player pawn’s begin play, without actually waiting for it being created.\n\nI’ve tried several times but it still doesn’t work.\n\n Obviously the Completed output is being executed without completing the load.\n\n \n\n This is the macro I’m using.\n\n After confirming that the load is complete, execute the next load.\n\n This macro is used in one place only and is called only once.\n\n Although this is wired directly to SpawnActor, there is a low probability that all actors spawned in the array. This is the macro I’m using.After confirming that the load is complete, execute the next load.This macro is used in one place only and is called only once.Although this is wired directly to SpawnActor, there is a low probability that all actors spawned in the array.\n\nFrom what I can see there are several fail scenarios there.\n\n Try to make it as an event, debug step by step and when it’s working convert it to macro (if you really need it) and check if it’s still working. Macros can be difficult to debug.\n\nMaybe this is the problem I’m facing… I have an event which gets a soft reference for skeletal mesh and animation blueprints, and then assigns these to a new actor after it has been spawned. It uses the Async Load Asset node, seen here: [image] [image] If I call this event from input during play, it works correctly. However, if I call this event from a for loop, the first skeletal mesh and animBlueprint are loaded, but subsequent iterations are not. Debug tells me that the correct classes are identified, however for some reason… That macro was created to accommodate multiple key types.\n\n I tried running the same thing in an event, but the result was the same.\n\n I knew that async loading and loops are a bad combination. And maybe that’s the problem.\n\n This is too difficult for me. I thought I understood it, but something is missing.\n\n I would like to know how others have solved this problem, but apparently no one else is facing the problem except me.\n\nwhat you do is have an array of pending assets, and you only load the next item when the first is completed. the possible difference with your marco is what if the macro is called twice? it’ll break the previous load order. so whenever the event is called to load something it just adds to the pending array if you need to return a loaded object you can bind to an event\n\nwhat you can do instead of using for loop is have an array with items to load\n\n async load last item from array\n\n when it’s completed, remove last array item\n\n go from the start until array has zero items why last item? maybe memory for whole array doesn’t have to be relocated when doing that, like in c++ but it’s only my assumption. you can as well work on first item instead and it will be the same."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/asynchronous-asset-loading-in-unreal-engine",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/13452zr/when_to_async_load_asset",
        "document": "I was wondering how often should Async Load Asset and Async Load Class Asset be used? I began using the nodes to avoid hard references but I found myself using them a ton so I began to wonder are there certain instances where it's really unnecessary like maybe for widgets or something? Are there cases where it matters more than others?"
    },
    {
        "link": "https://forums.unrealengine.com/t/asynchronous-loading-and-unloading-constantly-is-this-a-good-idea/2347042",
        "document": "Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out (LIFO) manner. In most modern computer systems, each thread has a reserved region of memory referred to as its stack. When a function executes, it may add some of its local state data to the top of the stack; when the function exits it is responsible for removing that data from the stack. At a minimum, a thread's stack is used to store the location of a return address provided by the ca..."
    }
]