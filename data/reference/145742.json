[
    {
        "link": "https://geeksforgeeks.org/io-bufferedwriter-class-methods-java",
        "document": "Bufferreader class writes text to character-output stream, buffering characters.Thus, providing efficient writing of single array, character and strings. A buffer size needs to be specified, if not it takes Default value. \n\nAn output is immediately set to the underlying character or byte stream by the Writer.\n\nClass Declaration\n• BufferedWriter(Writer out): Creates a buffered character-output stream that uses a default-sized output buffer.\n• BufferedWriter(Writer out, int size): Creates a new buffered character-output stream that uses an output buffer of the given size.\n• write() : java.io.BufferedWriter.write(int arg) writes a single character that is specified by an integer argument. \n\nSyntax :\n• Note : In the given output, you can’t see it’s action on file. Run this code on any compiler in your device. It creates a new file ‘ABC’ and write “E 1 ” in it.\n• write() : java.io.BufferedWriter.write(String arg, int offset, int length) writes String in the file according to its arguments as mentioned in the Java Code. \n\nSyntax :\n• Note : In the given output, you can’t see it’s action on file. Run this code on any compiler in your device. It creates a new file ‘ABC’ and write “Geeks” in it.Here,\n• Note :In the given output, you can’t see it’s action on file. Run this code on any compiler in your device. It creates a new file ‘ABC’ and write \n\n| GEEKS | \n\n| FOR | \n\n| GEEKS | Here, newLine() method breaks line after GEEKS and FOR is written in next line \n\nOutput :\n• close() : java.io.BufferedWriter.close() flushes character from write buffer and then close it. \n\nSyntax :\n• Note : You can’t see it’s action on file. Run this code on any compiler in your device.It creates a new file ‘ABC’ and write \n\n| E | \n\n| 1 | \n\nin it.Here, flush() method flushes the stream and close() method closes the writer."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/essential/io/file.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis page discusses the details of reading, writing, creating, and opening files. There are a wide array of file I/O methods to choose from. To help make sense of the API, the following diagram arranges the file I/O methods by complexity.\n\nOn the far left of the diagram are the utility methods , , and the methods, designed for simple, common cases. To the right of those are the methods used to iterate over a stream or lines of text, such as , , then and . These methods are interoperable with the package. To the right of those are the methods for dealing with , , and , such as the method. Finally, on the far right are the methods that use for advanced applications needing file locking or memory-mapped I/O.\n\nThis page has the following topics:\n• Methods for Unbuffered Streams and Interoperable with APIs\n\nSeveral of the methods in this section take an optional parameter. This parameter is optional and the API tells you what the default behavior is for the method when none is specified.\n\nThe following enums are supported:\n• – Appends the new data to the end of the file. This option is used with the or options.\n• – Truncates the file to zero bytes. This option is used with the option.\n• – Creates a new file and throws an exception if the file already exists.\n• – Opens the file if it exists or creates a new file if it does not.\n• – Deletes the file when the stream is closed. This option is useful for temporary files.\n• – Hints that a newly created file will be sparse. This advanced option is honored on some file systems, such as NTFS, where large files with data \"gaps\" can be stored in a more efficient manner where those empty gaps do not consume disk space.\n• – Keeps the file (both content and metadata) synchronized with the underlying storage device.\n• – Keeps the file content synchronized with the underlying storage device.\n\nReading All Bytes or Lines from a File\n\nIf you have a small-ish file and you would like to read its entire contents in one pass, you can use the or method. These methods take care of most of the work for you, such as opening and closing the stream, but are not intended for handling large files. The following code shows how to use the method:\n\nWriting All Bytes or Lines to a File\n\nYou can use one of the write methods to write bytes, or lines, to a file.\n\nThe following code snippet shows how to use a method.\n\nThe package supports channel I/O, which moves data in buffers, bypassing some of the layers that can bottleneck stream I/O.\n\nThe method opens a file for reading, returning a that can be used to read text from a file in an efficient manner.\n\nThe following code snippet shows how to use the method to read from a file. The file is encoded in \"US-ASCII.\"\n\nYou can use the method to write to a file using a .\n\nThe following code snippet shows how to create a file encoded in \"US-ASCII\" using this method:\n\nMethods for Unbuffered Streams and Interoperable with APIs\n\nTo open a file for reading, you can use the method. This method returns an unbuffered input stream for reading bytes from the file.\n\nCreating and Writing a File by Using Stream I/O\n\nYou can create a file, append to a file, or write to a file by using the method. This method opens or creates a file for writing bytes and returns an unbuffered output stream.\n\nThe method takes an optional parameter. If no open options are specified, and the file does not exist, a new file is created. If the file exists, it is truncated. This option is equivalent to invoking the method with the and options.\n\nThe following example opens a log file. If the file does not exist, it is created. If the file exists, it is opened for appending.\n\nReading and Writing Files by Using Channel I/O\n\nWhile stream I/O reads a character at a time, channel I/O reads a buffer at a time. The interface provides basic and functionality. A is a that has the capability to maintain a position in the channel and to change that position. A also supports truncating the file associated with the channel and querying the file for its size.\n\nThe capability to move to different points in the file and then read from or write to that location makes random access of a file possible. See Random Access Files for more information.\n\nThere are two methods for reading and writing channel I/O.\n\nBoth methods enable you to specify a list of options. The same open options used by the methods are supported, in addition to one more option: is required because the supports both reading and writing.\n\nSpecifying opens the channel for reading. Specifying or opens the channel for writing. If none of these options are specified, then the channel is opened for reading.\n\nThe following code snippet reads a file and prints it to standard output:\n\nThe following example, written for UNIX and other POSIX file systems, creates a log file with a specific set of file permissions. This code creates a log file or appends to the log file if it already exists. The log file is created with read/write permissions for owner and read only permissions for group.\n\nYou can create an empty file with an initial set of attributes by using the method. For example, if, at the time of creation, you want a file to have a particular set of file permissions, use the method to do so. If you do not specify any attributes, the file is created with default attributes. If the file already exists, throws an exception.\n\nIn a single atomic operation, the method checks for the existence of the file and creates that file with the specified attributes, which makes the process more secure against malicious code.\n\nThe following code snippet creates a file with default attributes:\n\nPOSIX File Permissions has an example that uses to create a file with pre-set permissions.\n\nYou can also create a new file by using the methods, as described in Creating and Writing a File using Stream I/O. If you open a new output stream and close it immediately, an empty file is created.\n\nYou can create a temporary file using one of the following methods:\n\nThe first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default temporary-file directory. Both methods allow you to specify a suffix for the filename and the first method allows you to also specify a prefix. The following code snippet gives an example of the second method:\n\nThe result of running this file would be something like the following:\n\nThe specific format of the temporary file name is platform specific."
    },
    {
        "link": "https://owlcation.com/stem/Java-BufferedReader-and-BufferedWriter-Example",
        "document": ""
    },
    {
        "link": "https://programiz.com/java-programming/bufferedwriter",
        "document": "The class of the package can be used with other writers to write data (in characters) more efficiently.\n\nThe maintains an internal buffer of 8192 characters.\n\nDuring the write operation, the characters are written to the internal buffer instead of the disk. Once the buffer is filled or the writer is closed, the whole characters in the buffer are written to the disk.\n\nHence, the number of communication to the disk is reduced. This is why writing characters is faster using .\n\nIn order to create a , we must import the package first. Once we import the package here is how we can create the buffered writer.\n\nIn the above example, we have created a named with the named .\n\nHere, the internal buffer of the has the default size of 8192 characters. However, we can specify the size of the internal buffer as well.\n\nThe buffer will help to write characters to the files more efficiently.\n\nThe class provides implementations for different methods present in .\n• - writes a single character to the internal buffer of the writer\n• - writes the characters from the specified array to the writer\n• - writes the specified string to the writer\n\nExample: BufferedWriter to write data to a File\n\nIn the above example, we have created a buffered writer named along with . The buffered writer is linked with the output.txt file.\n\nTo write data to the file, we have used the method.\n\nHere when we run the program, the output.txt file is filled with the following content.\n\nTo clear the internal buffer, we can use the method. This method forces the writer to write all data present in the buffer to the destination file.\n\nFor example, suppose we have an empty file named output.txt.\n\nWhen we run the program, the file output.txt is filled with the text represented by the string .\n\nTo close the buffered writer, we can use the method. Once the method is called, we cannot use the writer to write the data.\n\nTo learn more, visit Java BufferedWriter (official Java documentation)."
    },
    {
        "link": "https://beginnersbook.com/2014/01/how-to-write-to-file-in-java-using-bufferedwriter",
        "document": "Earlier we discussed how to write to a file using FileOutputStream. In this tutorial we will see how to write to a file using . We will be using method of to write the text into a file. The advantage of using is that it writes text to a character-output stream, buffering characters so as to provide for the efficient writing (better performance) of single characters, arrays, and strings.\n\nComplete example: Write to file using BufferedWriter\n\nIn this example we have a String and a file in C drive. We are writing the to the with the help of FileWriter and BufferedWriter."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html",
        "document": "A simple text scanner which can parse primitive types and strings using regular expressions.\n\nA breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various methods.\n\nFor example, this code allows a user to read a number from :\n\nAs another example, this code allows types to be assigned from entries in a file :\n\nThe scanner can also use delimiters other than whitespace. This example reads several items in from a string:\n\nThe same output can be generated with this code, which uses a regular expression to parse all four tokens at once:\n\nThe default whitespace delimiter used by a scanner is as recognized by . . The method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed.\n\nThe and methods and their primitive-type companion methods (such as and ) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both and methods may block waiting for further input. Whether a method blocks has no connection to whether or not its associated method will block.\n\nThe , , and methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input.\n\nWhen a scanner throws an , the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.\n\nDepending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern could return empty tokens since it only passes one space at a time.\n\nA scanner can read text from any object which implements the interface. If an invocation of the underlying readable's method throws an then the scanner assumes that the end of the input has been reached. The most recent thrown by the underlying readable can be retrieved via the method.\n\nWhen a is closed, it will close its input source if the source implements the interface.\n\nA is not safe for multithreaded use without external synchronization.\n\nUnless otherwise mentioned, passing a parameter into any method of a will cause a to be thrown.\n\nA scanner will default to interpreting numbers as decimal unless a different radix has been set by using the method. The method will reset the value of the scanner's radix to regardless of whether it was previously changed.\n\nAn instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the method; it may be changed via the method. The method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed.\n\nThe localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's object, , and its and object, .\n\nThe strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\nWhitespace is not significant in the above regular expressions."
    },
    {
        "link": "https://w3schools.com/java/java_user_input.asp",
        "document": "The class is used to get user input, and it is found in the package.\n\nTo use the class, create an object of the class and use any of the available methods found in the class documentation. In our example, we will use the method, which is used to read Strings:\n\nIn the example above, we used the method, which is used to read Strings. To read other types, look at the table below:\n\nIn the example below, we use different methods to read data of various types:\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\"). You can read more about exceptions and how to handle errors in the Exceptions chapter."
    },
    {
        "link": "https://docs.oracle.com/javase%2F8%2Fdocs%2Fapi%2F%2F/index.html?java/util/Scanner.html",
        "document": "Looking for a different release? Other releases"
    },
    {
        "link": "https://stackoverflow.com/questions/13185727/reading-a-txt-file-using-scanner-class-in-java",
        "document": "I am working on a Java program that reads a text file line-by-line, each with a number, takes each number throws it into an array, then tries and use insertion sort to sort the array. I need help with getting the program to read the text file.\n\nI am getting the following error messages:\n\nI have a copy of the .txt file in my \"src\" \"bin\" and main project folder but it still cannot find the file. I am using Eclipse by the way."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/scanner-class-in-java",
        "document": "Java Scanner class is part of the java.util package. It was introduced in Java 1.5 release. The Scanner is mostly used to receive user input and parse them into primitive data types such as int, double or default String. It’s a utility class to parse data using regular expressions by generating tokens.\n\nIf you look at the Scanner class, there are many constructors.\n\nMost of the constructors are using one of the three objects:\n• InputStream - the most common where we pass System.in to receive user input.\n• File or Path - We can scan file data too and work with the values from the file.\n• String - We can create a scanner for a string source too and parse values from it.\n\nIf you look at the second argument, it’s to specify a character set if you don’t want to use the default character set for parsing.\n\nLet’s look at some of the most commonly used Scanner class methods.\n• useDelimiter(String pattern) - the delimiter to be used for the scanner. The default delimiter is whitespace.\n• hasNext() - returns true if there is another token in the input. It’s a blocking method and it will keep waiting for user input.\n• next() - returns the next token from the scanner. It’s used in conjunction with the hasNext() method.\n• close() - scanner is resource heavy, so once you are done with it, use this method to close it and release system resources.\n\nThere are many utility methods to check and directly parse the input token in int, short, long, byte, BigDecimal, etc.\n\nSteps to Initialize and Use Scanner\n• The first step is to initialize the scanner class by using the appropriate constructor based on the input type such as InputStream, File, or String. If needed, set the delimiter and character set to use.\n• The second step is to wait for the input token using hasNext() method.\n• Then use the next() method to read the token and process them one by one.\n• The Scanner class breaks its input into tokens using the specified delimiter pattern.\n• The next() methods is used to read the tokens one by one and process them.\n• Finally, close the Scanner instance to release the system resources.\n\nLet’s look at some of the common usages of the Scanner class with sample code snippets.\n\nThis is the most common use of the Scanner class. We can instantiate with System.in as input source and read the user input.\n\nWell, it looks easy and working fine. But, the above code has an issue. Without reading the next section, can you check the code and try to identify it?\n\nLet’s see what happens when I write my full name in the input.\n\nNow you must have got it, it’s happening because whitespace is the delimiter. The scanner is breaking the input into two tokens - Pankaj and Kumar. But, we are calling the next() method just once, so only “Hello Pankaj” is printed.\n\nHow do we fix this?\n\nIt’s simple. We can change the delimiter to a newline character using the useDelimiter() method.\n\nLet’s look at a simple example to read and parse CSV files using the scanner class. Let’s say, I have an employees.csv file with the following content.\n\nLet’s read the file and get a list of Employees in our Java program.\n• The first step is to create the scanner for the CSV file and set newline as delimiter.\n• Then for each line that contains employee record in CSV format, parse it using another scanner and comma as delimiter. The parseEmployeeData() is parsing each line and creating Employee object.\n• Finally, we are adding the employee object to the list and printing it.\n\nLet’s say we have a string source and we want to process only integers present in that. We can use the scanner with the non-digit regex to get only integers as tokens to process them.\n\nJava Scanner is a utility class to read user input or process simple regex-based parsing of file or string source. But, for real-world applications, it’s better to use CSV parsers to parse CSV data rather than using the Scanner class for better performance."
    }
]