[
    {
        "link": "https://stackoverflow.com/questions/6726636/splitting-and-concatenating-a-string",
        "document": "I was wondering if python had a built in function similar to\n\nSo for example I would like to turn 'abc' into and vice versa using a built in function."
    },
    {
        "link": "https://geeksforgeeks.org/python-program-split-join-string",
        "document": "In Python, we can use the function split() to split a string and join() to join a string. These functions allow us to easily break a string into smaller parts and then reassemble those parts into a new string. This article will explore ways to split and join a string.\n\nSplit the string into a list of strings\n\nSplitting a string can be quite useful sometimes, especially when we need only certain parts of strings. We can do this by using below mentioned methods.\n\nsplit() method splits a string into a list of substrings based on a specified delimiter (by default, it splits by whitespace).\n\nThe splitlines() method splits the string at line breaks and returns a list of lines. This is useful while using multiple strings.\n\nJoin the list of strings into a string\n\nAfter splitting a string into smaller parts, we might want to join those parts back together. This is commonly done with a delimiter between the parts.\n\nThe most common and efficient way to join a list of strings with a delimiter is using the join() method. This method is available for strings and allows we to specify the delimiter we want to use between elements.\n\nUsing for loop [Less Efficient]\n\nAlthough less efficient, we can manually join the strings in a list using a for loop. This method allows we to apply more complex transformations during the joining process."
    },
    {
        "link": "https://freecodecamp.org/news/python-string-split-and-join-methods-explained-with-examples",
        "document": "When working with strings in Python, you may have to split a string into substrings. Or you might need to join together smaller chunks to form a string. Python's and string methods help you do these tasks easily.\n\nIn this tutorial, you'll learn about the and string methods with plenty of example code.\n\nAs strings in Python are immutable, you can call methods on them without modifying the original strings. Let's get started.\n\nWhen you need to split a string into substrings, you can use the method.\n\nThe method acts on a string and returns a list of substrings. The syntax is:\n\nIn the above syntax:\n• is the separator that you'd like to split on. It should be specified as a string.\n• is an optional argument. By default, this method splits strings on whitespaces.\n• is an optional argument indicating the number of times you'd like to split .\n• has a default value of , which splits the string on all occurrences of .\n\nAnd setting will leave you with two chunks – one with the section of before the first comma, and another with the section of after the first comma.\n\nWhen you split a string once, you'll get 2 chunks. When you split a string twice, you'll get 3 chunks. When you split a string times, you'll get chunks.\n\n▶ Let's take a few examples to see the method in action.\n\nNow, call the method on , without the arguments and .\n\nYou can see that has been split on all whitespaces and the list of substrings is returned, as shown above.\n\n▶ Let's now consider the following example. Here, has names of fruits, separated by commas.\n\nLet's now split on commas – set or only specify in the method call.\n\nAs expected, the method returns a list of fruits, where each fruit in is now a list item.\n\n▶ Let's now use the optional argument as well by setting it equal to 2.\n\nLet's try to parse the returned list.\n\nRecall that is , and we decided to split on commas ( ).\n• The first comma is after , and after the first split you'll have 2 items, and .\n• The second comma is after . And you'll have 3 items, , , and after the second split.\n• At this point, you've reached the count of 2, and no further splits can be made.\n• This is why the portion of the string after the second comma is lumped together as a single item in the returned list.\n\nI hope you understand how the method and the arguments and work.\n\nNow that you know how to split a string into substrings, it's time to learn how to use the method to form a string from substrings.\n\nThe syntax of Python's method is:\n• is any Python iterable containing the substrings, say, a list or a tuple, and\n• is the separator that you'd like to join the substrings on.\n\n▶ And it's time for examples.\n\nIn the previous section on the method, you split into a list on the occurrences of commas. Let's call the list .\n\nNow, you'll form a string using the method to put together items in the returned list. The items in are all names of fruits.\n\n📑 Note that the separator to join on should be specified as a string. You'll run into syntax errors if you don't do so, as shown below.\n\n▶ To join the items in using a comma as the separator, use not . This is shown in the code snippet below.\n\nThe above line of code joins items in using a comma followed by a space as the separator.\n\nYou can specify any separator of your choice. This time, you'll use 3 underscores ( ) to join items in .\n\nThe items in have now been joined into a single string, and have all been separated from each other by a .\n\nAnd you now know how you can form a Python string by putting together substrings using the method.\n\nIn this tutorial, you've learned the following:\n• splits on the occurrence of , number of times,\n• joins substrings in using as the separator."
    },
    {
        "link": "https://geeksforgeeks.org/splitting-concatenated-strings-in-python",
        "document": "List in Python are versatile data structures that can hold a collection of items, including strings. Text processing and natural language processing (NLP), are common tasks to split a concatenated string into its constituent words. This task can be particularly challenging when the string contains no delimiters or spaces.\n\nIn this article, we will explore various methods to split the word into a list of separate words.\n\nThe string \"ActionAction-AdventureShooterStealth\" is a concatenation of multiple words without clear delimiters. Our goal is to split this string into a list of meaningful words:\n• No Delimiters : The string lacks spaces or punctuation marks to indicate word boundaries.\n• Compound Words : The string contains compound words like \"Action-Adventure\".\n• Repetition : The word \"Action\" appears twice, which can complicate the splitting process.\n\nBelow are the possible approaches for splitting the word \"ActionAction-AdventureShooterStealth\" into List of Separate Words.\n\nRegular expressions (regex) are powerful tools for pattern matching and text manipulation. However, they may not be the best fit for this problem due to the complexity of the string. Nonetheless, we can use regex to identify potential word boundaries.\n\nIn this approach, we are using a regular expression pattern [A-Z][a-z]+(?:-[A-Z][a-z]+)* to match sequences of words starting with an uppercase letter followed by lowercase letters, optionally separated by a hyphen and another sequence of uppercase and lowercase letters.\n\nThis pattern captures words like \"Action\", \"Action-Adventure\", \"Shooter\", and \"Stealth\" from the given input string \"ActionAction-AdventureShooterStealth\". The findall method of the compiled pattern then extracts all matching substrings, resulting in the list of separate words.\n\nIn this approach, we are using a loop to iterate through each character in the input word. We check if the character is uppercase and if there's a current word being formed. If so, and the last character in the current word is not a hyphen, we append the current word to the result list and start a new word with the current uppercase character. This makes sure that hyphenated words are merged, resulting in a list of separate words such as 'Action', 'Action-Adventure', 'Shooter', and 'Stealth'.\n\nA dictionary-based method involves using a predefined list of words to identify and split the string. This approach is more flexible and can handle compound words effectively.\n\nBy iterating through the string and checking substrings against a predefined dictionary, we can accurately identify and split words. This method handles compound words and repetitions effectively, provided the dictionary is comprehensive.\n\nMachine learning models, particularly those used in NLP, can be trained to recognize word boundaries in concatenated strings. This approach requires a labeled dataset for training.\n\nThis approach is powerful but requires a labeled dataset for training. Models like Conditional Random Fields (CRF) or Recurrent Neural Networks (RNN) can be used for this task.\n• Regular Expressions : Best for simple patterns and when the string structure is predictable.\n• Dictionary-Based Method : Ideal for complex strings with compound words and repetitions. Requires a comprehensive dictionary.\n• Machine Learning : Suitable for large-scale applications and when a labeled dataset is available. Offers high accuracy but requires significant resources for training.\n• Unknown Words : Ensure the dictionary is comprehensive to handle all possible words.\n\nIn conclusion, to split the word \"ActionAction-AdventureShooterStealth\" into a list of separate words, you can use techniques like regular expressions for pattern matching or string manipulation with iterative checks. These methods effectively extract individual words, including hyphenated ones, resulting in a comprehensive and accurate list of separate words from the input string."
    },
    {
        "link": "https://w3schools.com/python/ref_string_split.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/57676447/condition-statement-without-loops",
        "document": "I'm writing a small function to check if all elements in a list are less than or equal to a limit. This is just for practice, and should be done without using any loops.\n\nBeen on this for a while but I can not find any substituting code to replace the loop.This code works perfectly fine as it is - however, I am trying to get the results without using loops. Trying to write something a bit more 'pythonic'."
    },
    {
        "link": "https://w3schools.com/python/python_ref_string.asp",
        "document": "Python has a set of built-in methods that you can use on strings.\n\nLearn more about strings in our Python Strings Tutorial."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    }
]