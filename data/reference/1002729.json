[
    {
        "link": "https://docs.spring.io/spring-boot/docs/2.5.0/reference/htmlsingle",
        "document": ""
    },
    {
        "link": "https://docs.spring.io/spring-boot/docs/2.5.x/reference/htmlsingle",
        "document": ""
    },
    {
        "link": "https://docs.spring.io/spring-boot/docs/2.5.5/reference/htmlsingle",
        "document": ""
    },
    {
        "link": "https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes",
        "document": "The underlying method used to support and scripts has been redesigned in Spring Boot 2.5. properties related to initialization have been deprecated in favor of new properties. These properties can also be used to initialize an SQL database accessed via R2DBC. With Spring Boot 2.5.1 and above, the new SQL initialization properties support detection of embedded datasources for JDBC and R2DBC. By default, SQL database initialization is only performed when using an embedded in-memory database. To always initialize a SQL database, irrespective of its type, set to . Similarly, to disable initialization, set to . The new script-based SQL database initialization does not support using separate credentials for schema (DDL) and data (DML) changes. This reduces complexity and aligns its capabilities with Flyway and Liquibase. If you require separate credentials for schema and data initialization, define your own beans. By default, scripts are now run before Hibernate is initialized. This aligns the behavior of basic script-based initialization with that of Flyway and Liquibase. If you want to use to populate a schema created by Hibernate, set to . While mixing database initialization technologies is not recommended, this will also allow you to use a script to build upon a Hibernate-created schema before it’s populated via . Beans of certain well-known types, such as , will be ordered so that they are initialized after the database has been initialized. If you have a bean that works with the directly, annotate its class or method with to ensure that it too is initialized after the database has been initialized. If you currently define a or you may need to provide additional and properties. In earlier versions of Spring Boot, these settings were derived from properties but this turned out to be problematic for people that provided their own DataSource beans. Spring Data JPA introduces a new method which replaces . If you find your application is now throwing a please rename any existing method to (where is an arbitrary string). For more details, please read the updated Spring Data JPA reference documentation. Following its removal from Spring Data in 2021.0.0, auto-configuration for Spring Data Solr has been removed in this release. The actuator endpoint is no longer exposed over the web by default. Additionally, if Spring Security is on the classpath and your application doesn’t have a custom security configuration, the endpoint requires authenticated access by default. Refer to the documentation on exposing and securing actuator endpoints to change these new defaults. Spring Integration now reuses an available rather that configuring its own. In a typical application setup relying on the auto-configuration, this means that Spring Integration uses the auto-configured task scheduler that has a pool size of 1. To restore Spring Integration’s default of 10 threads, use the property. The EL implementation that is included in Spring Boot’s web and validation starters has changed. Tomcat’s implementation ( ) is now used in place of the reference implementation from Glassfish ( ). The attribute in the default error view is now removed rather than blanked when it is not shown. If you parse the error response JSON, you may need to deal with the missing item. You can still use the property if you want messages to be included. We now register a logging shutdown hook by default for jar based applications to ensure that logging resources are released when the JVM exits. If your application is deployed as a war then the shutdown hook is not registered since the servlet container usually handles logging concerns. Most applications will want the shutdown hook. However, if your application has complex context hierarchies, then you may need to disable it. You can use the property to do that. The Spring Boot Gradle Plugin no longer automatically disables the standard Gradle and tasks. Instead we now apply a to those tasks. If you prefer to disable those tasks, the reference documentation includes updated examples. Spring Boot no longer provides default values for properties. If you rely on , , or you should set values that make sense for your application. To streamline the customization of jOOQ’s , a bean that implements can now be defined. This customiser callback should be used in favour of defining one or more beans, the support for which has now been deprecated. The default version of Groovy has been upgraded to 3.x. If you are using Groovy and also using Spock, you should also upgrade to the latest Groovy 3.0-compatible release of Spock 2.0. Alternatively, use the to downgrade back to Groovy 2.5. Projects built with Gradle now require Gradle 6.8 or later. The default version of Hibernate Validate has been upgraded to 6.2.x. Hibernate Validator 6.2 changes how the expression language is used to interpolate constraint messages. Please see this blog post from the Hibernate Validator team for further details. Reflecting the Spring Boot release compatibility policy, code deprecated in Spring Boot 2.3 has been removed in Spring Boot 2.5. Code deprecated in Spring Boot 2.4 remains in place, and is scheduled for removal in Spring Boot 2.6."
    },
    {
        "link": "https://spring.io/guides/tutorials/rest",
        "document": "The Story so Far This tutorial starts by building up the code in the module. We start off with the simplest thing we can construct. In fact, to make it as simple as possible, we can even leave out the concepts of REST. (Later on, we add REST, to understand the difference.) Big picture: We are going to create a simple payroll service that manages the employees of a company. We store employee objects in a (H2 in-memory) database, and access them (through something called ). Then we wrap that with something that allows access over the internet (called the Spring layer). The following code defines an in our system. package payroll; import java.util.Objects; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.Id; @Entity class Employee { private @Id @GeneratedValue Long id; private String name; private String role; Employee() {} Employee(String name, String role) { this.name = name; this.role = role; } public Long getId() { return this.id; } public String getName() { return this.name; } public String getRole() { return this.role; } public void setId(Long id) { this.id = id; } public void setName(String name) { this.name = name; } public void setRole(String role) { this.role = role; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Employee)) return false; Employee employee = (Employee) o; return Objects.equals(this.id, employee.id) && Objects.equals(this.name, employee.name) && Objects.equals(this.role, employee.role); } @Override public int hashCode() { return Objects.hash(this.id, this.name, this.role); } @Override public String toString() { return \"Employee{\" + \"id=\" + this.id + \", name='\" + this.name + '\\'' + \", role='\" + this.role + '\\'' + '}'; } } Despite being small, this Java class contains much:\n• is a JPA annotation to make this object ready for storage in a JPA-based data store.\n• , , and are attributes of our domain object. is marked with more JPA annotations to indicate that it is the primary key and is automatically populated by the JPA provider.\n• A custom constructor is created when we need to create a new instance but do not yet have an . With this domain object definition, we can now turn to Spring Data JPA to handle the tedious database interactions. Spring Data JPA repositories are interfaces with methods that support creating, reading, updating, and deleting records against a back end data store. Some repositories also support data paging and sorting, where appropriate. Spring Data synthesizes implementations based on conventions found in the naming of the methods in the interface. There are multiple repository implementations besides JPA. You can use Spring Data MongoDB, Spring Data Cassandra, and others. This tutorial sticks with JPA. Spring makes accessing data easy. By declaring the following interface, we can automatically:\n• Find employees (one, all, or search by simple or complex properties) To get all this free functionality, all we have to do is declare an interface that extends Spring Data JPA’s , specifying the domain type as and the type as . Spring Data’s repository solution makes it possible to sidestep data store specifics and, instead, solve a majority of problems by using domain-specific terminology. Believe it or not, this is enough to launch an application! A Spring Boot application is, at a minimum, a entry-point and the annotation. This tells Spring Boot to help out wherever possible. is a meta-annotation that pulls in component scanning, auto-configuration, and property support. We do not dive into the details of Spring Boot in this tutorial. However, in essence, it starts a servlet container and serves up our service. An application with no data is not very interesting, so we preload that it has data. The following class gets loaded automatically by Spring: What happens when it gets loaded?\n• Spring Boot runs ALL beans once the application context is loaded.\n• This runner requests a copy of the you just created.\n• The runner creates two entities and stores them. Right-click and Run , and you get: This is not the whole log, but only the key bits of preloading data.\n\nTo wrap your repository with a web layer, you must turn to Spring MVC. Thanks to Spring Boot, you need add only a little code. Instead, we can focus on actions:\n• indicates that the data returned by each method is written straight into the response body instead of rendering a template.\n• An is injected by constructor into the controller.\n• We have routes for each operation ( , , and , corresponding to HTTP , , , and calls). (We recommend reading each method and understanding what they do.)\n• is an exception used to indicate when an employee is looked up but not found. When an is thrown, this extra tidbit of Spring MVC configuration is used to render an HTTP 404 error:\n• signals that this advice is rendered straight into the response body.\n• configures the advice to only respond when an is thrown.\n• says to issue an — that is, an HTTP 404 error.\n• The body of the advice generates the content. In this case, it gives the message of the exception. To launch the application, you can right-click the in and select Run from your IDE. Alternatively, Spring Initializr creates a Maven wrapper, so you can run the following command: Alternatively, you can use your installed Maven version, as follows: When the app starts, you can immediately interrogate it, as follows: Doing so yields the following: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /employees HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 < Content-Type: application/json;charset=UTF-8 < Transfer-Encoding: chunked < Date: Thu, 09 Aug 20yy 17:58:00 GMT < * Connection #0 to host localhost left intact [{\"id\":1,\"name\":\"Bilbo Baggins\",\"role\":\"burglar\"},{\"id\":2,\"name\":\"Frodo Baggins\",\"role\":\"thief\"}] You can see the pre-loaded data in a compacted format. Now try to query a user that doesn’t exist, as follows: When you do so, you get the following output: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > GET /employees/99 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 404 < Content-Type: text/plain;charset=UTF-8 < Content-Length: 26 < Date: Thu, 09 Aug 20yy 18:00:56 GMT < * Connection #0 to host localhost left intact Could not find employee 99 This message nicely shows an HTTP 404 error with the custom message: . It is not hard to show the currently coded interactions. If you use Windows command prompt to issue cURL commands, the following command probably does not work properly. You must either pick a terminal that support single-quoted arguments, or use double quotation marks and then escape the quotation marks inside the JSON. To create a new record, use the following command in a terminal (the at the beginning signifies that what follows it is a terminal command): Then it stores the newly created employee and sends it back to us: You can update the user. For example, you can change the role: Now we can see the change reflected in the output: The way you construct your service can have significant impacts. In this situation, we said update, but replace is a better description. For example, if the name was NOT provided, it would instead get nulled out. Finally, you can delete users, as follows: $ curl -X DELETE localhost:8080/employees/3 # Now if we look again, it's gone $ curl localhost:8080/employees/3 Could not find employee 3 This is all well and good, but do we have a RESTful service yet? (The answer is no.)\n\nNow we can introduce Spring HATEOAS, a Spring project aimed at helping you write hypermedia-driven outputs. To upgrade your service to being RESTful, add the following to your build: If you are following along in the solution repository, the next section switches to the rest module. This tiny library gives us the constructs that define a RESTful service and then render it in an acceptable format for client consumption. A critical ingredient to any RESTful service is adding links to relevant operations. To make your controller more RESTful, add links like the following to the existing method in : You also need to include new imports: This tutorial is based on Spring MVC and uses the static helper methods from to build these links. If you are using Spring WebFlux in your project, you must instead use . This is very similar to what we had before, but a few things have changed:\n• The return type of the method has changed from to . is a generic container from Spring HATEOAS that includes not only the data but a collection of links.\n• asks that Spring HATEOAS build a link to the method of and flag it as a self link.\n• asks Spring HATEOAS to build a link to the aggregate root, , and call it \"employees\". What do we mean by \"build a link?\" One of Spring HATEOAS’s core types is . It includes a URI and a rel (relation). Links are what empower the web. Before the World Wide Web, other document systems would render information or links, but it was the linking of documents WITH this kind of relationship metadata that stitched the web together. Roy Fielding encourages building APIs with the same techniques that made the web successful, and links are one of them. If you restart the application and query the employee record of Bilbo, you get a slightly different response than earlier: When your curl output gets more complex it can become hard to read. Use this or other tips to prettify the json returned by curl: # The indicated part pipes the output to json_pp and asks it to make your JSON pretty. (Or use whatever tool you like!) # v------------------v curl -v localhost:8080/employees/1 | json_pp This decompressed output shows not only the data elements you saw earlier ( , , and ) but also a entry that contains two URIs. This entire document is formatted using HAL. HAL is a lightweight mediatype that allows encoding not only data but also hypermedia controls, alerting consumers to other parts of the API to which they can navigate. In this case, there is a \"self\" link (kind of like a statement in code) along with a link back to the aggregate root. To make the aggregate root also be more RESTful, you want to include top level links while also including any RESTful components within. So we modify the following (located in the module of the completed code): We want the following (located in the module of the completed code): That method, which used to be merely , is \"all grown up.\"\" Not to worry. Now we can unpack it. is another Spring HATEOAS container. It is aimed at encapsulating collections of resources instead of a single resource entity, such as from earlier. , too, lets you include links. Do not let that first statement slip by. What does \"encapsulating collections\" mean? Collections of employees? Since we are talking REST, it should encapsulate collections of employee resources. That is why you fetch all the employees but then transform them into a list of objects. (Thanks Java Streams!) If you restart the application and fetch the aggregate root, you can see what it looks like now: { \"_embedded\": { \"employeeList\": [ { \"id\": 1, \"name\": \"Bilbo Baggins\", \"role\": \"burglar\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/employees/1\" }, \"employees\": { \"href\": \"http://localhost:8080/employees\" } } }, { \"id\": 2, \"name\": \"Frodo Baggins\", \"role\": \"thief\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/employees/2\" }, \"employees\": { \"href\": \"http://localhost:8080/employees\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/employees\" } } } For this aggregate root, which serves up a collection of employee resources, there is a top-level \"self\" link. The \"collection\" is listed underneath the \"_embedded\" section. This is how HAL represents collections. Each individual member of the collection has their information as well as related links. What is the point of adding all these links? It makes it possible to evolve REST services over time. Existing links can be maintained while new links can be added in the future. Newer clients may take advantage of the new links, while legacy clients can sustain themselves on the old links. This is especially helpful if services get relocated and moved around. As long as the link structure is maintained, clients can still find and interact with things.\n\nIf you are following along in the solution repository, the next section switches to the evolution module. In the code earlier, did you notice the repetition in single employee link creation? The code to provide a single link to an employee, as well as to create an \"employees\" link to the aggregate root, was shown twice. If that raised a concern, good! There’s a solution. You need to define a function that converts objects to objects. While you could easily code this method yourself, Spring HATEOAS’s interface does the work for you. Create a new class : This simple interface has one method: . It is based on converting a non-model object ( ) into a model-based object ( ). All the code you saw earlier in the controller can be moved into this class. Also, by applying Spring Framework’s annotation, the assembler is automatically created when the app starts. Spring HATEOAS’s abstract base class for all models is . However, for simplicity, we recommend using as your mechanism to easily wrap all POJOs as models. To leverage this assembler, you have only to alter the by injecting the assembler in the constructor: From here, you can use that assembler in the single-item employee method that already exists in : Getting single item resource using the assembler This code is almost the same, except that, instead of creating the instance here, you delegate it to the assembler. Maybe that is not impressive. Applying the same thing in the aggregate root controller method is more impressive. This change is also to the class: Getting aggregate root resource using the assembler The code is, again, almost the same. However, you get to replace all that creation logic with . Thanks to Java method references, it is super easy to plug in and simplify your controller. A key design goal of Spring HATEOAS is to make it easier to do The Right Thing™. In this scenario, that means adding hypermedia to your service without hard coding a thing. At this stage, you have created a Spring MVC REST controller that actually produces hypermedia-powered content. Clients that do not speak HAL can ignore the extra bits while consuming the pure data. Clients that do speak HAL can navigate your empowered API. But that is not the only thing needed to build a truly RESTful service with Spring.\n\nWith one additional library and a few lines of extra code, you have added hypermedia to your application. But that is not the only thing needed to make your service RESTful. An important facet of REST is the fact that it is neither a technology stack nor a single standard. REST is a collection of architectural constraints that, when adopted, make your application much more resilient. A key factor of resilience is that when you make upgrades to your services, your clients do not suffer downtime. In the \"olden\" days, upgrades were notorious for breaking clients. In other words, an upgrade to the server required an update to the client. In this day and age, hours or even minutes of downtime spent doing an upgrade can cost millions in lost revenue. Some companies require that you present management with a plan to minimize downtime. In the past, you could get away with upgrading at 2:00 a.m. on a Sunday when load was at a minimum. But in today’s Internet-based e-commerce with international customers in other time zones, such strategies are not as effective. SOAP-based services and CORBA-based services were incredibly brittle. It was hard to roll out a server that could support both old and new clients. With REST-based practices, it is much easier, especially using the Spring stack. Supporting Changes to the API Imagine this design problem: You have rolled out a system with this -based record. The system is a major hit. You have sold your system to countless enterprises. Suddenly, the need for an employee’s name to be split into and arises. Uh oh. You did not think of that. Before you open up the class and replace the single field with and , stop and think. Does that break any clients? How long will it take to upgrade them? Do you even control all the clients accessing your services? Downtime = lost money. Is management ready for that? There is an old strategy that precedes REST by years. You can always add columns (fields) to a database table. But do not take one away. The principle in RESTful services is the same. Add new fields to your JSON representations, but do not take any away. Like this: This format shows , , and . While it sports duplication of information, the purpose is to support both old and new clients. That means you can upgrade the server without requiring clients to upgrade at the same time. This is good move that should reduce downtime. Not only should you show this information in both the \"old way\" and the \"new way\", but you should also process incoming data both ways. Employee record that handles both \"old\" and \"new\" clients package payroll; import java.util.Objects; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.Id; @Entity class Employee { private @Id @GeneratedValue Long id; private String firstName; private String lastName; private String role; Employee() {} Employee(String firstName, String lastName, String role) { this.firstName = firstName; this.lastName = lastName; this.role = role; } public String getName() { return this.firstName + \" \" + this.lastName; } public void setName(String name) { String[] parts = name.split(\" \"); this.firstName = parts[0]; this.lastName = parts[1]; } public Long getId() { return this.id; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; } public String getRole() { return this.role; } public void setId(Long id) { this.id = id; } public void setFirstName(String firstName) { this.firstName = firstName; } public void setLastName(String lastName) { this.lastName = lastName; } public void setRole(String role) { this.role = role; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Employee)) return false; Employee employee = (Employee) o; return Objects.equals(this.id, employee.id) && Objects.equals(this.firstName, employee.firstName) && Objects.equals(this.lastName, employee.lastName) && Objects.equals(this.role, employee.role); } @Override public int hashCode() { return Objects.hash(this.id, this.firstName, this.lastName, this.role); } @Override public String toString() { return \"Employee{\" + \"id=\" + this.id + \", firstName='\" + this.firstName + '\\'' + \", lastName='\" + this.lastName + '\\'' + \", role='\" + this.role + '\\'' + '}'; } } This class is similar to the previous version of , with a few changes:\n• Field has been replaced by and .\n• A \"virtual\" getter for the old property, , is defined. It uses the and fields to produce a value.\n• A \"virtual\" setter for the old property, , is also defined. It parses an incoming string and stores it into the proper fields. Of course, not change to your API is as simple as splitting a string or merging two strings. But itis surely not impossible to come up with a set of transforms for most scenarios, right? Do not forget to change how you preload your database (in ) to use this new constructor. Another step in the right direction involves ensuring that each of your REST methods returns a proper response. Update the POST method ( ) in the : POST that handles \"old\" and \"new\" client requests You also need to add the imports:\n• The new object is saved, as before. However, the resulting object is wrapped in the .\n• Spring MVC’s is used to create an HTTP 201 Created status message. This type of response typically includes a Location response header, and we use the URI derived from the model’s self-related link.\n• Additionally, the model-based version of the saved object is returned. With these tweaks in place, you can use the same endpoint to create a new employee resource and use the legacy field: The output is as follows: This not only has the resulting object rendered in HAL (both as well as and ), but also the Location header populated with . A hypermedia-powered client could opt to \"surf\" to this new resource and proceed to interact with it. The PUT controller method ( ) in needs similar tweaks: The object built by the operation is then wrapped in the to create an object. Using the method, you can retrieve the created by the with a rel. This method returns a , which must be turned into a with the method. Since we want a more detailed HTTP response code than 200 OK, we use Spring MVC’s wrapper. It has a handy static method ( ) where we can plug in the resource’s URI. It is debatable whether HTTP 201 Created carries the right semantics, since we do not necessarily \"create\" a new resource. However, it comes pre-loaded with a Location response header, so we use it. Restart your application, run the following command, and observe the results: * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > PUT /employees/3 HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > Content-Type:application/json > Content-Length: 49 > < HTTP/1.1 201 < Location: http://localhost:8080/employees/3 < Content-Type: application/hal+json;charset=UTF-8 < Transfer-Encoding: chunked < Date: Fri, 10 Aug 20yy 19:52:56 GMT { \"id\": 3, \"firstName\": \"Samwise\", \"lastName\": \"Gamgee\", \"role\": \"ring bearer\", \"name\": \"Samwise Gamgee\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/employees/3\" }, \"employees\": { \"href\": \"http://localhost:8080/employees\" } } } That employee resource has now been updated and the location URI has been sent back. Finally, update the DELETE operation ( ) in : This returns an HTTP 204 No Content response. Restart your application, run the following command, and observe the results: Making changes to the fields in the class requires coordination with your database team, so that they can properly migrate existing content into the new columns. You are now ready for an upgrade that does not disturb existing clients while newer clients can take advantage of the enhancements. By the way, are you worried about sending too much information over the wire? In some systems where every byte counts, evolution of APIs may need to take a backseat. However, you should not pursue such premature optimization until you measure the impact of your changes.\n\nIf you are following along in the solution repository, the next section switches to the links module. So far, you have built an evolvable API with bare bones links. To grow your API and better serve your clients, you need to embrace the concept of Hypermedia as the Engine of Application State. What does that mean? This section explores it in detail. Business logic inevitably builds up rules that involve processes. The risk of such systems is we often carry such server-side logic into clients and build up strong coupling. REST is about breaking down such connections and minimizing such coupling. To show how to cope with state changes without triggering breaking changes in clients, imagine adding a system that fulfills orders. As a first step, define a new record: package payroll; import java.util.Objects; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.Id; import jakarta.persistence.Table; @Entity @Table(name = \"CUSTOMER_ORDER\") class Order { private @Id @GeneratedValue Long id; private String description; private Status status; Order() {} Order(String description, Status status) { this.description = description; this.status = status; } public Long getId() { return this.id; } public String getDescription() { return this.description; } public Status getStatus() { return this.status; } public void setId(Long id) { this.id = id; } public void setDescription(String description) { this.description = description; } public void setStatus(Status status) { this.status = status; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Order)) return false; Order order = (Order) o; return Objects.equals(this.id, order.id) && Objects.equals(this.description, order.description) && this.status == order.status; } @Override public int hashCode() { return Objects.hash(this.id, this.description, this.status); } @Override public String toString() { return \"Order{\" + \"id=\" + this.id + \", description='\" + this.description + '\\'' + \", status=\" + this.status + '}'; } }\n• The class requires a JPA annotation that changes the table’s name to because is not a valid name for table.\n• It includes a field as well as a field. Orders must go through a certain series of state transitions from the time a customer submits an order and it is either fulfilled or cancelled. This can be captured as a Java called : This captures the various states an can occupy. For this tutorial, we keep it simple. To support interacting with orders in the database, you must define a corresponding Spring Data repository called : We also need to create a new exception class called : With this in place, you can now define a basic with the required imports:\n• It contains the same REST controller setup as the controllers you have built so far.\n• It injects both an and a (not yet built) .\n• The first two Spring MVC routes handle the aggregate root as well as a single item resource request.\n• The third Spring MVC route handles creating new orders, by starting them in the state.\n• All the controller methods return one of Spring HATEOAS’s subclasses to properly render hypermedia (or a wrapper around such a type). Before building the , we should discuss what needs to happen. You are modeling the flow of states between , , and . A natural thing when serving up such data to clients is to let the clients make the decision about what they can do, based on this payload. What happens when you introduce a new state in this flow? The placement of various buttons on the UI would probably be erroneous. What if you changed the name of each state, perhaps while coding international support and showing locale-specific text for each state? That would most likely break all the clients. Enter HATEOAS or Hypermedia as the Engine of Application State. Instead of clients parsing the payload, give them links to signal valid actions. Decouple state-based actions from the payload of data. In other words, when CANCEL and COMPLETE are valid actions, you should dynamically add them to the list of links. Clients need to show users the corresponding buttons only when the links exist. This decouples clients from having to know when such actions are valid, reducing the risk of the server and its clients getting out of sync on the logic of state transitions. Having already embraced the concept of Spring HATEOAS components, the is the perfect place to capture the logic for this business rule: package payroll; import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*; import org.springframework.hateoas.EntityModel; import org.springframework.hateoas.server.RepresentationModelAssembler; import org.springframework.stereotype.Component; @Component class OrderModelAssembler implements RepresentationModelAssembler<Order, EntityModel<Order>> { @Override public EntityModel<Order> toModel(Order order) { // Unconditional links to single-item resource and aggregate root EntityModel<Order> orderModel = EntityModel.of(order, linkTo(methodOn(OrderController.class).one(order.getId())).withSelfRel(), linkTo(methodOn(OrderController.class).all()).withRel(\"orders\")); // Conditional links based on state of the order if (order.getStatus() == Status.IN_PROGRESS) { orderModel.add(linkTo(methodOn(OrderController.class).cancel(order.getId())).withRel(\"cancel\")); orderModel.add(linkTo(methodOn(OrderController.class).complete(order.getId())).withRel(\"complete\")); } return orderModel; } } This resource assembler always includes the self link to the single-item resource as well as a link back to the aggregate root. However, it also includes two conditional links to as well as (not yet defined). These links are shown only when the order’s status is . If clients can adopt HAL and the ability to read links instead of simply reading the data of plain old JSON, they can trade in the need for domain knowledge about the order system. This naturally reduces coupling between client and server. It also opens the door to tuning the flow of order fulfillment without breaking clients in the process. To round out order fulfillment, add the following to the for the operation: @DeleteMapping(\"/orders/{id}/cancel\") ResponseEntity<?> cancel(@PathVariable Long id) { Order order = orderRepository.findById(id) // .orElseThrow(() -> new OrderNotFoundException(id)); if (order.getStatus() == Status.IN_PROGRESS) { order.setStatus(Status.CANCELLED); return ResponseEntity.ok(assembler.toModel(orderRepository.save(order))); } return ResponseEntity // .status(HttpStatus.METHOD_NOT_ALLOWED) // .header(HttpHeaders.CONTENT_TYPE, MediaTypes.HTTP_PROBLEM_DETAILS_JSON_VALUE) // .body(Problem.create() // .withTitle(\"Method not allowed\") // .withDetail(\"You can't cancel an order that is in the \" + order.getStatus() + \" status\")); } It checks the status before letting it be cancelled. If it is not a valid state, it returns an RFC-7807 , a hypermedia-supporting error container. If the transition is indeed valid, it transitions the to . Now we need to add this to the as well for order completion: @PutMapping(\"/orders/{id}/complete\") ResponseEntity<?> complete(@PathVariable Long id) { Order order = orderRepository.findById(id) // .orElseThrow(() -> new OrderNotFoundException(id)); if (order.getStatus() == Status.IN_PROGRESS) { order.setStatus(Status.COMPLETED); return ResponseEntity.ok(assembler.toModel(orderRepository.save(order))); } return ResponseEntity // .status(HttpStatus.METHOD_NOT_ALLOWED) // .header(HttpHeaders.CONTENT_TYPE, MediaTypes.HTTP_PROBLEM_DETAILS_JSON_VALUE) // .body(Problem.create() // .withTitle(\"Method not allowed\") // .withDetail(\"You can't complete an order that is in the \" + order.getStatus() + \" status\")); } This implements similar logic to prevent an status from being completed unless in the proper state. Let’s update to pre-load some objectss along with the objects it was loading before. Now you can test. Restart your application to make sure you are running the latest code changes. To use the newly minted order service, you can perform a few operations: { \"_embedded\": { \"orderList\": [ { \"id\": 3, \"description\": \"MacBook Pro\", \"status\": \"COMPLETED\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/orders/3\" }, \"orders\": { \"href\": \"http://localhost:8080/orders\" } } }, { \"id\": 4, \"description\": \"iPhone\", \"status\": \"IN_PROGRESS\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/orders/4\" }, \"orders\": { \"href\": \"http://localhost:8080/orders\" }, \"cancel\": { \"href\": \"http://localhost:8080/orders/4/cancel\" }, \"complete\": { \"href\": \"http://localhost:8080/orders/4/complete\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/orders\" } } } This HAL document immediately shows different links for each order, based upon its present state.\n• The first order, being COMPLETED, only has the navigational links. The state transition links are not shown.\n• The second order, being IN_PROGRESS, additionally has the cancel link as well as the complete link. Now try cancelling an order: You may need to replace the number 4 in the preceding URL, based on the specific IDs in your database. That information can be found from the previous call. This response shows an HTTP 200 status code, indicating that it was successful. The response HAL document shows that order in its new state ( ). Also, the state-altering links gone. Now try the same operation again: * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > DELETE /orders/4/cancel HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 405 < Content-Type: application/problem+json < Transfer-Encoding: chunked < Date: Mon, 27 Aug 20yy 15:03:24 GMT < { \"title\": \"Method not allowed\", \"detail\": \"You can't cancel an order that is in the CANCELLED status\" } You can see an HTTP 405 Method Not Allowed response. DELETE has become an invalid operation. The response object clearly indicates that you are not allowed to \"cancel\" an order already in the \"CANCELLED\" status. Additionally, trying to complete the same order also fails: * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) > PUT /orders/4/complete HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 405 < Content-Type: application/problem+json < Transfer-Encoding: chunked < Date: Mon, 27 Aug 20yy 15:05:40 GMT < { \"title\": \"Method not allowed\", \"detail\": \"You can't complete an order that is in the CANCELLED status\" } With all this in place, your order fulfillment service is capable of conditionally showing what operations are available. It also guards against invalid operations. By using the protocol of hypermedia and links, clients can be made sturdier and be less likely to break simply because of a change in the data. Spring HATEOAS eases building the hypermedia you need to serve to your clients.\n\nThroughout this tutorial, you have engaged in various tactics to build REST APIs. As it turns out, REST is not just about pretty URIs and returning JSON instead of XML. Instead, the following tactics help make your services less likely to break existing clients you may or may not control:\n• Do not remove old fields. Instead, support them.\n• Use rel-based links so clients need not hard code URIs.\n• Retain old links as long as possible. Even if you have to change the URI, keep the rels so that older clients have a path to the newer features.\n• Use links, not payload data, to instruct clients when various state-driving operations are available. It may appear to be a bit of effort to build up implementations for each resource type and to use these components in all of your controllers. However, this extra bit of server-side setup (made easy thanks to Spring HATEOAS) can ensure the clients you control (and more importantly, those you do not control) can upgrade with ease as you evolve your API. This concludes our tutorial on how to build RESTful services using Spring. Each section of this tutorial is managed as a separate subproject in a single github repo:\n• rest — Spring MVC + Spring HATEOAS app with HAL representations of each resource\n• evolution — REST app where a field is evolved but old data is retained for backward compatibility\n• links — REST app where conditional links are used to signal valid state changes to clients To view more examples of using Spring HATEOAS, see https://github.com/spring-projects/spring-hateoas-examples. To do some more exploring, check out the following video by Spring teammate Oliver Drotbohm: Want to write a new guide or contribute to an existing one? Check out our contribution guidelines. All guides are released with an ASLv2 license for the code, and an Attribution, NoDerivatives creative commons license for the writing."
    },
    {
        "link": "https://spring.io/guides/gs/accessing-data-jpa",
        "document": "How to complete this guide Like most Spring Getting Started guides, you can start from scratch and complete each step or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Starting with Spring Initializr. To skip the basics, do the following:\n• Download and unzip the source repository for this guide, or clone it using Git: When you finish, you can check your results against the code in .\n\nIn this example, you store objects, each annotated as a JPA entity. The following listing shows the Customer class (in ): Here you have a class with three attributes: , , and . You also have two constructors. The default constructor exists only for the sake of JPA. You do not use it directly, so it is designated as . The other constructor is the one you use to create instances of to be saved to the database. The class is annotated with , indicating that it is a JPA entity. (Because no annotation exists, it is assumed that this entity is mapped to a table named .) The object’s property is annotated with so that JPA recognizes it as the object’s ID. The property is also annotated with to indicate that the ID should be generated automatically. The other two properties, and , are left unannotated. It is assumed that they are mapped to columns that share the same names as the properties themselves.\n\nSpring Data JPA focuses on using JPA to store data in a relational database. Its most compelling feature is the ability to create repository implementations automatically, at runtime, from a repository interface. To see how this works, create a repository interface that works with entities as the following listing (in ) shows: extends the interface. The type of entity and ID that it works with, and , are specified in the generic parameters on . By extending , inherits several methods for working with persistence, including methods for saving, deleting, and finding entities. Spring Data JPA also lets you define other query methods by declaring their method signature. For example, includes the method. In a typical Java application, you might expect to write a class that implements . However, that is what makes Spring Data JPA so powerful: You need not write an implementation of the repository interface. Spring Data JPA creates an implementation when you run the application. Now you can wire up this example and see what it looks like!\n\nSpring Initializr creates a simple class for the application. The following listing shows the class that Initializr created for this example (in ): is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a .\n• : Tells Spring to look for other components, configurations, and services in the package, letting it find the controllers. The method uses Spring Boot’s method to launch an application. Did you notice that there was not a single line of XML? There is no file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure. Now you need to modify the simple class that the Initializr created for you. To get output (to the console, in this example), you need to set up a logger. Then you need to set up some data and use it to generate output. The following listing shows the finished class (in ): package com.example.accessingdatajpa; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; @SpringBootApplication public class AccessingDataJpaApplication { private static final Logger log = LoggerFactory.getLogger(AccessingDataJpaApplication.class); public static void main(String[] args) { SpringApplication.run(AccessingDataJpaApplication.class); } @Bean public CommandLineRunner demo(CustomerRepository repository) { return (args) -> { // save a few customers repository.save(new Customer(\"Jack\", \"Bauer\")); repository.save(new Customer(\"Chloe\", \"O'Brian\")); repository.save(new Customer(\"Kim\", \"Bauer\")); repository.save(new Customer(\"David\", \"Palmer\")); repository.save(new Customer(\"Michelle\", \"Dessler\")); // fetch all customers log.info(\"Customers found with findAll():\"); log.info(\"-------------------------------\"); repository.findAll().forEach(customer -> { log.info(customer.toString()); }); log.info(\"\"); // fetch an individual customer by ID Customer customer = repository.findById(1L); log.info(\"Customer found with findById(1L):\"); log.info(\"--------------------------------\"); log.info(customer.toString()); log.info(\"\"); // fetch customers by last name log.info(\"Customer found with findByLastName('Bauer'):\"); log.info(\"--------------------------------------------\"); repository.findByLastName(\"Bauer\").forEach(bauer -> { log.info(bauer.toString()); }); log.info(\"\"); }; } } The class includes a method that puts the through a few tests. First, it fetches the from the Spring application context. Then it saves a handful of objects, demonstrating the method and setting up some data to work with. Next, it calls to fetch all objects from the database. Then it calls to fetch a single by its ID. Finally, it calls to find all customers whose last name is \"Bauer\". The method returns a bean that automatically runs the code when the application launches. By default, Spring Boot enables JPA repository support and looks in the package (and its subpackages) where is located. If your configuration has JPA repository interface definitions located in a package that is not visible, you can point out alternate packages by using and its type-safe parameter.\n\nYou can run the application from the command line with Gradle or Maven. You can also build a single executable JAR file that contains all the necessary dependencies, classes, and resources and run that. Building an executable jar makes it easy to ship, version, and deploy the service as an application throughout the development lifecycle, across different environments, and so forth. If you use Gradle, you can run the application by using . Alternatively, you can build the JAR file by using and then run the JAR file, as follows: If you use Maven, you can run the application by using . Alternatively, you can build the JAR file with and then run the JAR file, as follows: The steps described here create a runnable JAR. You can also build a classic WAR file. When you run your application, you should see output similar to the following: == Customers found with findAll(): Customer[id=1, firstName='Jack', lastName='Bauer'] Customer[id=2, firstName='Chloe', lastName='O'Brian'] Customer[id=3, firstName='Kim', lastName='Bauer'] Customer[id=4, firstName='David', lastName='Palmer'] Customer[id=5, firstName='Michelle', lastName='Dessler'] == Customer found with findById(1L): Customer[id=1, firstName='Jack', lastName='Bauer'] == Customer found with findByLastName('Bauer'): Customer[id=1, firstName='Jack', lastName='Bauer'] Customer[id=3, firstName='Kim', lastName='Bauer']"
    },
    {
        "link": "https://geeksforgeeks.org/spring-boot-jparepository-with-example",
        "document": "Spring Boot is built on the top of the spring and contains all the features of spring. And is becoming a favorite of developers these days because of its rapid production-ready environment which enables the developers to directly focus on the logic instead of struggling with the configuration and setup. Spring Boot is a microservice-based framework and making a production-ready application in it takes very little time. Following are some of the features of Spring Boot:\n• None It allows for avoiding the heavy configuration of XML that is present in the spring.\n• None It provides easy maintenance and creation of REST endpoints.\n• None Deployment is straightforward, war and jar files can be easily deployed in the Tomcat server.\n\nFor more information please refer to this article: Introduction to Spring Boot . In this article, we are going to discuss how to use JpaRepository to manage data in a Spring Boot application.\n\nBut beyond just the basics, Spring Boot opens the door to streamlined development processes, enabling faster iteration and innovation. If you’re looking to elevate your skills and truly harness what Spring Boot has to offer, consider diving deeper into the ecosystem through a comprehensive Java Backend Development course . Not only will it help you master the nuances of Spring Boot, but it will also empower you to build scalable, maintainable applications that can stand the test of time in a rapidly changing tech landscape.\n\nJpaRepository is a JPA (Java Persistence API) specific extension of Repository. It contains the full API of CrudRepository and PagingAndSortingRepository . So it contains API for basic CRUD operations and also API for pagination and sorting.\n• T: Domain type that repository manages (Generally the Entity/Model class name)\n• ID: Type of the id of the entity that repository manages (Generally the wrapper class of your @Id that is created inside the Entity/Model class)\n\nSome of the most important methods that are available inside the JpaRepository are given below\n\nParameters : Entities, keeping note that they must not be null nor must it contain null.\n\nReturn Type : the saved entities; will never be null. The returned Iterable will have the same size as the Iterable passed as an argument.\n\nException Thrown: It throws IllegalArgumentException in case the given entities or one of its entities is null.\n\nMethod 2: getById(): Returns a reference to the entity with the given identifier. Depending on how the JPA persistence provider is implemented this is very likely to always return an instance and throw an EntityNotFoundException on first access. Some of them will reject invalid identifiers immediately.\n\nParameters : id – must not be null.\n\nReturn Type: a reference to the entity with the given identifier.\n\nMethod 3: flush(): Flushes all pending changes to the database.\n\nMethod 4: saveAndFlush(): Saves an entity and flushes changes instantly.\n\nParameters: The entity to be saved. Must not be null.\n\nMethod 5: deleteAllInBatch(): Deletes the given entities in a batch which means it will create a single query. This kind of operation leaves JPAs first-level cache and the database out of sync. Consider flushing the EntityManager before calling this method.\n\nParameters : The e ntities to be deleted, must not be null.\n\nImplementation: Let us consider a Spring Boot application that manages a Department entity with JpaRepository. The data is saved in the H2 database. We use a RESTful controller.\n\nExample: Here is the complete code for the pom.xml file.\n\nStep 3 : Create 4 packages as listed below and create some classes and interfaces inside these packages as seen in the below image\n\nCreate a simple interface and name the interface as DepartmentRepository. This interface is going to extend the JpaRepository as we have discussed above.\n\nInside the package create one interface named as DepartmentService and one class named as DepartmentServiceImpl .\n\nInside the package create one class named as DepartmentController .\n\nStep 8: Below is the code for the application.properties file\n\nNow run your application and let’s test the endpoints in Postman and also refer to our H2 Database.\n\nH2 Database is as follows :"
    },
    {
        "link": "https://medium.com/@bubu.tripathy/best-practices-entity-class-design-with-jpa-and-spring-boot-6f703339ab3d",
        "document": "In the world of modern software development, efficient design and implementation of entity classes play a crucial role in building robust and maintainable applications. JPA, coupled with the power of Spring Boot, empowers developers to streamline database operations and create highly functional applications. This guide delves into essential best practices for designing entity classes while utilizing JPA within a Spring Boot framework. By adhering to these best practices, developers can ensure the integrity, performance, and scalability of their applications.\n• Annotate your entity classes with to indicate they are JPA entities.\n• Use to specify the table name if it's different from the class name.\n• Consider using for common attributes that should be inherited by multiple entities.\n\nIn this example, the class is annotated with . It contains the common fields that you want to share across multiple entity classes. The class inherits from , effectively inheriting the field from the superclass.\n\nBy using , you're able to create a common base class for your entity hierarchy while allowing each subclass to include additional fields and annotations specific to their needs. This promotes code reusability and maintains a clean and structured entity hierarchy.\n• Use with appropriate strategy for generating primary key values (e.g., , ).\n• Use , , , and to define relationships between entities.\n• Use attribute to control loading behavior (e.g., or ).\n• Utilize to define the owning side of bidirectional relationships.\n• Use attribute to specify cascading operations (e.g., , ).\n• Be cautious with cascading to avoid unintentional data loss.\n\nIn this example, we have two entities: and . The entity has a one-to-many relationship with the entity.\n• CascadeType.ALL: This option specifies that all operations (e.g., persist, merge, remove) should be cascaded from the parent entity ( ) to the child entity ( ).\n• orphanRemoval = true: This option specifies that when an entity's reference to a entity is removed from the collection, the orphaned entity should also be removed from the database.\n\nWhen you perform a cascading operation on the entity, the corresponding operation will cascade to the associated entities. For instance:\n\nLikewise, cascading operations work for merge, remove, and other entity operations, reducing the need for explicitly managing related entities persistence.\n• Use validation annotations ( , , etc.) to enforce data integrity constraints directly in the entity class.\n• Implement entity auditing by adding fields like , , , and for tracking who created or modified an entity and when.\n\nIn this example, we’re creating an abstract class that serves as the base class for other entities that require auditing. Let's break down the annotations and their purposes:\n• @EntityListeners(AuditingEntityListener.class): This annotation specifies that this entity should be audited using the provided entity listener class. Spring Data JPA will automatically update the auditing fields before persisting or updating the entity.\n• @MappedSuperclass: This annotation indicates that this class is not an entity itself but serves as a base class for other entities. It allows attributes and behaviors to be inherited by other entities.\n• @CreatedBy: This annotation specifies the field to store the username of the user who created the entity.\n• @CreatedDate: This annotation marks the field to store the timestamp when the entity was created. The and properties are set to to ensure that this field is populated during creation and not updated afterwards.\n• @LastModifiedBy: This annotation specifies the field to store the username of the user who last modified the entity.\n• @LastModifiedDate: This annotation marks the field to store the timestamp when the entity was last modified.\n\nNow, when you create an entity that extends the class, Spring Data JPA will automatically populate the auditing fields during the relevant operations:\n\nBy implementing auditing, you can track who created or modified entities and when those actions occurred. This information can be invaluable for monitoring and maintaining your application’s data.\n• Use Java enums for fields with predefined values.\n• Annotate enum fields with to store enum values as strings in the database.\n• When retrieving data from the database, consider using DTO projections to fetch only the necessary fields, improving performance.\n• Use Spring Data JPA’s annotation or query methods to create custom projections.\n\nLet’s consider an example where we have an entity and we want to project a subset of its data into a DTO called .\n\nIn this example:\n• We have an entity with a one-to-many relationship to entities (not shown here).\n• We define a Spring Data JPA repository that extends . Within this repository, we declare a custom query method using the annotation.\n• The custom query retrieves a list of objects. The query projects a subset of data: the author's name and the count of books they have written.\n• is an interface that defines the subset of data we want to project from the entity. The getter methods in this interface correspond to the projected fields.\n\nWith this setup, when you call the method from the , it will execute the custom query and return a list of objects containing the projected data.\n• Define indexes on fields that are commonly queried for better database performance.\n• Use or annotations to specify indexes on columns or collections.\n\nIn this example, we have two entities: and . We'll define indexes on fields within the entity using the annotation from the package.\n• @Indexes: This annotation allows you to define one or more indexes on columns of a table. The annotation is used within the annotation to specify the columns that should be indexed.\n• @Index: This annotation specifies a single index on the given column(s). You can use the attribute to specify one or more columns for indexing.\n\nIn the entity, we're defining two indexes:\n• An index on the column to optimize queries that involve joining or filtering by category.\n• A composite index on the and columns to optimize queries that sort or filter products based on name and price together.\n\nIncorporating robust entity class design, validation, auditing, DTO projection, and index optimization within a Spring Boot application using JPA not only ensures efficient data management but also contributes to the foundation of a reliable and maintainable software system."
    },
    {
        "link": "https://springboottutorial.com/hibernate-jpa-tutorial-with-spring-boot-starter-jpa",
        "document": "This post will show you how to establish a simple Spring Boot project and connect to a database using Hibernate/JPA. Spring Boot Starter JPA and the in-memory database H2 will be used.\n• How to create a project using Spring Boot, Spring Boot Starter JPA and H2?\n• How to use Spring Boot Starter JPA?\n• How to connect a Spring Boot project to database using JPA/Hibernate?\n• How to create a simple JPA Entity with a primary key?\n• What are the basics of an in memory database?\n\nThe screenshot below depicts the framework of the project we will be creating.\n• - We use data.sql to populate the initial student data.\n• SpringBoot2JPAWithHibernateAndH2Application.java - The main Spring Boot Application class which is used to launch up the application. We will extend interface and implement method to launch the spring jpa repository methods when the server launches up.\n• - Contains all the dependencies needed to build this project. We will use Spring Boot Starter JPA and Web other than Developer Tools and H2 as in memory database.\n• Your favorite IDE. We use Eclipse or IntelliJ.\n\nTables/Relations are used to design databases. OOPS is used to develop Java objects. We’d want to save data from objects to tables and vice versa.\n\nPrevious techniques required the creation of SQL Queries. Popular techniques included JDBC, Spring JDBC, and myBatis.\n\nJPA, on the other hand, arose as a result of a different conceptual process.\n\nORM - Object Relational Mapping - is another name for this mapping. Prior to JPA, these frameworks were more generally referred to as ORM. It is one of the reasons Hibernate is referred to as an ORM framework.\n\nJPA allows to map application classes to tables in database.\n• - Entity manager may manage your entities after the mappings are defined. Entity Manager manages all database interactions.\n• - Offers methods for writing queries to do entity searches. It is critical to recognise that these are not SQL queries. JPQL queries are already aware of the mappings that exist between entities. More criteria can be added as needed.\n\nOne of the most popular ORM frameworks is Hibernate.\n\nThe specification is defined by JPA. It is a programming interface.\n• How do you define entities?\n• How do you map attributes?\n• How do you map relationships between entities?\n• Hibernate recognises the mappings we create between objects and tables. It guarantees that data is stored and retrieved from the database in accordance with the mappings.\n• Hibernate extends JPA with extra functionality. But, relying on them would bind you to Hibernate. You cannot switch to another JPA implementation, such as Toplink.\n\nSpring Initializr is used to create a project.\n\nSpring Initializr http://start.spring.io/ is great tool to bootstrap your Spring Boot projects.\n\nAs shown in the image above, following steps have to be done\n• Launch Spring Initializr and choose the following\n\nBelow is the list of starter projects in pom.xml.\n\nBelow picture highlights some of the dependencies that are part of the imported JPA project.\n\nSpring-boot-starter-jpa defines all of these dependencies. We obtain the following functionalities from a wide range of dependencies as soon as we include Spring Boot Starter JPA in our project (pom.xml).\n\nExtract below shows some code from pom.xml of spring-boot-starter-jpa.\n\nWe will use H2 as the database.\n\nH2 provides a web interface called H2 Console to see the data. Let’s enable h2 console in the application.properties.\n\nWhen you reload the application, you can launch up H2 Console at http://localhost:8080/h2-console.\n\nWhen you use the right JDBC URL given above, you should see an empty schema when you click button.\n\nMake Your Very First JPA Entity\n\nThe first thing to do is to build a JPA Entity. Let’s start with a basic Student Entity with a primary key id.\n• : Specifies that the class is an entity. This annotation is applied to the entity class.\n• : Specifies the primary key of an entity.\n• : Provides for the specification of generation strategies for the values of primary keys.\n\nYou may launch H2 console when the programme reloads. http://localhost:8080/h2-console.\n\nOn H2 Console, you will notice that a new table called is generated.\n\nIts because of Spring Boot Auto Configuration. We will talk about this a little later.\n\nLet’s now add some information to the student table.\n\nAfter you refresh the application, you should see the following messages in the log showing that the sql files have been picked up.\n\nWhen you connect to H2 Console (http://localhost:8080/h2-console) after reloading the app, you will notice that the student table has been created and the data has been loaded.\n• We’ll go over all of the methods in the JpaRepository later.\n• - JpaRepository is being extended with two generics: Student and Long. The entity being handled is Student, and the main key of Student is Long.\n\nJpaRepository (Defined in Spring Data JPA) is the JPA specific Repository interface.\n\nBefore we go any further, let’s enable logging for all queries generated by Hibernate. We also enable statistics and format generated sql statements.\n\nSome of the log that is generated (later when we execute queries) when we turn statistics on is shown below.\n\nThe code below extends the SpringBoot2JPAWithHibernateAndH2Application class to perform some StudentRepository methods.\n• - Implementing CommandLineRunner helps to execute the repository methods at start of the application.\n• - Implement the run method defined in the CommandLineRunner interface. This method is executed as soon as the application is launched up.\n\nLet’s extend the method to execute a few methods on the student repository.\n• `save’ method is used for both insertion and updates. If the entity is already present in the database, it is updated. Else, it is inserted.\n\nOutput from above statements when the code is run is shown below:\n\nLets look at a few more examples to understand how JPA can be used to map objects to tables.\n\nRelationships between objects are expressed in a different way compared to relationship between tables.\n\nEach Employee can have multiple Tasks. Each Task can be shared by multiple Employees. There is a Many to Many relationship between them. We use @ManyToMany annotation to establish the relationship.\n\nSeveral classes are sometimes mapped to a single table, and vice versa. In these cases, we devise an inheritance approach. In this example, we employ an InheritanceType technique. SINGLE TABLE.\n\nGithub repository has all the code examples - https://github.com/in28minutes/spring-boot-examples/tree/master/spring-boot-2-jpa-with-hibernate-and-h2"
    },
    {
        "link": "https://baeldung.com/the-persistence-layer-with-spring-data-jpa",
        "document": "This tutorial will focus on introducing Spring Data JPA into a Spring project, and fully configuring the persistence layer. For a step-by-step introduction to setting up the Spring context using Java-based configuration and the basic Maven pom for the project, see this article.\n\n2. The Spring Data Generated DAO – No More DAO Implementations\n\nAs we discussed in an earlier article, the DAO layer usually consists of a lot of boilerplate code that can and should be simplified. The advantages of such a simplification are many: a decrease in the number of artifacts that we need to define and maintain, consistency of data access patterns, and consistency of configuration.\n\nSpring Data takes this simplification one step further and makes it possible to remove the DAO implementations entirely. The interface of the DAO is now the only artifact that we need to explicitly define.\n\nTo start leveraging the Spring Data programming model with JPA, a DAO interface needs to extend the JPA specific Repository interface, JpaRepository. This will enable Spring Data to find this interface and automatically create an implementation for it.\n\nBy extending the interface, we get the most relevant CRUD methods for standard data access available in a standard DAO.\n\nAs discussed, by implementing one of the Repository interfaces, the DAO will already have some basic CRUD methods (and queries) defined and implemented.\n\nTo define more specific access methods, Spring JPA supports quite a few options:\n• simply define a new method in the interface\n• provide the actual JPQL query by using the @Query annotation\n• use the more advanced Specification and Querydsl support in Spring Data\n\nThe third option, Specifications, and Querydsl support, is similar to JPA Criteria but uses a more flexible and convenient API. This makes the whole operation much more readable and reusable. The advantages of this API will become more pronounced when dealing with a large number of fixed queries, as we could potentially express these more concisely through a smaller number of reusable blocks.\n\nThe last option has the disadvantage that it either involves XML or burdening the domain class with the queries.\n\nWhen Spring Data creates a new Repository implementation, it analyses all the methods defined by the interfaces and tries to automatically generate queries from the method names. While this has some limitations, it’s a very powerful and elegant way of defining new custom access methods with very little effort.\n\nLet’s look at an example. If the entity has a name field (and the Java Bean standard getName and setName methods), we’ll define the findByName method in the DAO interface. This will automatically generate the correct query:\n\nThis is a relatively simple example. The query creation mechanism supports a much larger set of keywords.\n\nIn case the parser can’t match the property with the domain object field, we’ll see the following exception:\n\nNow let’s look at a custom query that we’ll define via the @Query annotation:\n\nFor even more fine-grained control over the creation of queries, such as using named parameters or modifying existing queries, the reference is a good place to start.\n\nThe actual implementation of the Spring-managed DAO is indeed hidden since we don’t work with it directly. However, it’s a simple enough implementation, the SimpleJpaRepository, which defines transaction semantics using annotations.\n\nMore explicitly, this uses a read-only @Transactional annotation at the class level, which is then overridden for the non-read-only methods. The rest of the transaction semantics are default, but these can be easily overridden manually per method.\n\n4.1. Exception Translation Is Alive and Well\n\nThe question now becomes: since Spring Data JPA doesn’t depend on the old ORM templates (JpaTemplate, HibernateTemplate), and they have been removed since Spring 5, are we still going to get our JPA exceptions translated to Spring’s DataAccessException hierarchy?\n\nThe answer is, of course, we are. Exception translation is still enabled by the use of the @Repository annotation on the DAO. This annotation enables a Spring bean postprocessor to advise all @Repository beans with all the PersistenceExceptionTranslator instances found in the container and provide exception translation just as before.\n\nKeep in mind that exception translation is done through proxies. For Spring to be able to create proxies around the DAO classes, these must not be declared final.\n\nTo activate the Spring JPA repository support, we can use the @EnableJpaRepositories annotation and specify the package that contains the DAO interfaces:\n\nWe can do the same with an XML configuration:\n\nWe already discussed in great detail how to configure JPA in Spring in a previous article. Spring Data also takes advantage of Spring’s support for the JPA @PersistenceContext annotation. It uses this to wire the EntityManager into the Spring factory bean responsible for creating the actual DAO implementations, JpaRepositoryFactoryBean.\n\nIn addition to the already discussed configuration, we also need to include the Spring Data XML Config if we are using XML:\n\nIn addition to the Maven configuration for JPA, like in a previous article, we’ll add the spring-data-jpa dependency:\n\nWe can also use the Spring Boot Starter Data JPA dependency that will automatically configure the DataSource for us.\n\nWe need to make sure that the database we want to use is present in the classpath. In our example, we’ve added the H2 in-memory database:\n\nAs a result, just by doing these dependencies, our application is up and running and we can use it for other database operations.\n\nThe explicit configuration for a standard Spring application is now included as part of Spring Boot auto-configuration.\n\nWe can, of course, modify the auto-configuration by adding our customized explicit configuration.\n\nSpring Boot provides an easy way to do this using properties in the application.properties file. Let’s see an example of changing the connection URL and credentials:\n\nSpring Data JPA is supported in all major Java IDEs. Let’s see what useful tools are available for Eclipse and IntelliJ IDEA.\n\nIf you use Eclipse as your IDE, you can install the Dali Java Persistence Tools plugin. This provides ER diagrams for JPA entities, DDL generation to initialize schema and basic reverse engineering capabilities. Also, you can use Eclipse Spring Tool Suite (STS). It will help to validate query method names in Spring Data JPA repositories.\n\nIn case you use IntelliJ IDEA, there are two options.\n\nIntelliJ IDEA Ultimate enables ER diagrams, a JPA console for testing JPQL statements, and valuable inspections. However, these features are not available in the Community Edition.\n\nTo boost productivity in IntelliJ, you can install the JPA Buddy plugin, which provides many features, including generation of JPA entities, Spring Data JPA repositories, DTOs, initialization DDL scripts, Flyway versioned migrations, Liquibase changelogs, etc. Also, JPA Buddy provides an advanced tool for reverse engineering.\n\nFinally, the JPA Buddy plugin works with both Community and Ultimate editions.\n\nIn this article, we covered the configuration and implementation of the persistence layer with Spring 5, JPA 2, and Spring Data JPA (part of the Spring Data umbrella project) using both XML and Java-based configuration.\n\nWe discussed ways to define more advanced custom queries, as well as transactional semantics, and a configuration with the new jpa namespace. The final result is a new and elegant take on data access with Spring, with almost no actual implementation work."
    }
]