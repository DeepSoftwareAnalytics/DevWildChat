[
    {
        "link": "https://stackoverflow.com/questions/47244689/pyqt4-load-large-data-sets-in-qstandarditemmodel",
        "document": "Well, in my current project, the records are loaded from a database directly into and then view via . Everything works fine too. But I thought about the ram-memory. I think that the , including records, will be loaded into ram-memory. Similar to the data structure (for instance ), right? But what happens when I have large data sets? I read in Qt Documentation: Fetch More Example that I have to add items to the model in batches and preferably only when the items are needed by the view. It sounds good, but I have no idea how to do that. Does anyone of you know a few examples in python codes? Unfortunately, I do not understand the C ++ examples. Or does anyone know a better solution?\n\nDon't get me wrong. I don't want a ready solution because I'm too lazy. No! I want to learn and work on it."
    },
    {
        "link": "https://stackoverflow.com/questions/4229081/pyqt-qtreeview-found-an-example-for-drag-and-drop-but-need-help-deciphering",
        "document": "I am looking for just the tinyest bit of help deciphering the following code ( it was an example taken from - http://www.mail-archive.com/[email protected]/msg17197.html ). I assume it is ok to repost here based on the contents of that post. Please don't be put off by the length of the code I am including, I only need clarification on a small portion of it:\n\nThe code snippet I am wondering about is listed below (I also post the entire example after that for completeness). My questions are two:\n\n1) When does removeRows ever get called?\n\n2) Why does the author actually copy the node being moved (using deep copy)? I would have assumed that it is ok to simply reparent the node in question using appendChild and removeChild (two methods of the nodes in his data store).\n\nI am also including all of the code below for completeness:"
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtCore/QAbstractItemModel.html",
        "document": "To sort the model, you can use sort() .\n\nThe items available through the model can be searched for particular data using the match() function.\n\nThe model emits signals to indicate changes. For example, dataChanged() is emitted whenever items of data made available by the model are changed. Changes to the headers supplied by the model cause headerDataChanged() to be emitted. If the structure of the underlying data changes, the model can emit layoutChanged() to indicate to any attached views that they should redisplay any items shown, taking the new structure into account.\n\nThe model has a rowCount() and a columnCount() for each level of the hierarchy. Rows and columns can be inserted and removed with insertRows() , insertColumns() , removeRows() , and removeColumns() .\n\nIf an item has child objects, hasChildren() returns true for the corresponding index.\n\nItems can be queried with flags() (see ItemFlag ) to see if they can be selected, dragged, or manipulated in other ways.\n\nData for each role is set using a particular ItemDataRole . Data for individual roles are set individually with setData() , or they can be set for all roles with setItemData() .\n\nEach item has a number of data elements associated with it and they can be retrieved by specifying a role (see ItemDataRole ) to the model’s data() function. Data for all available roles can be obtained at the same time using the itemData() function.\n\nEvery item of data that can be accessed via a model has an associated model index. You can obtain this model index using the index() function. Each index may have a sibling() index; child items have a parent() index.\n\nThe underlying data model is exposed to views and delegates as a hierarchy of tables. If you do not make use of the hierarchy, then the model is a simple table of rows and columns. Each item has a unique index specified by a QModelIndex .\n\nIf you need a model to use with an item view such as QML’s List View element or the C++ widgets QListView or QTableView , you should consider subclassing QAbstractListModel or QAbstractTableModel instead of this class.\n\nThe QAbstractItemModel class is one of the Model/View Classes and is part of Qt’s model/view framework . It can be used as the underlying data model for the item view elements in QML or the item view classes in the Qt Widgets module.\n\nThe QAbstractItemModel class defines the standard interface that item models must use to be able to interoperate with other components in the model/view architecture. It is not supposed to be instantiated directly. Instead, you should subclass it to create new models.\n\nWhen reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using and is an alternative to emitting and directly along with . The index corresponds to the parent from which the columns are moved; and are the first and last column numbers of the columns to be moved. The index corresponds to the parent into which those columns are moved. The is the column to which the columns will be moved. That is, the index at column in will become column in , followed by all other columns up to . However, when moving columns down in the same parent ( and are equal), the columns will be placed before the index. That is, if you wish to move columns 0 and 1 so they will become columns 1 and 2, should be 3. In this case, the new index for the source column (which is between and ) is equal to . Note that if and are the same, you must ensure that the is not within the range of and + 1. You must also ensure that you do not attempt to move a column to one of its own children or ancestors. This method returns if either condition is true, in which case you should abort your move operation.\n\nWhen reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using and is an alternative to emitting and directly along with . The index corresponds to the parent from which the rows are moved; and are the first and last row numbers of the rows to be moved. The index corresponds to the parent into which those rows are moved. The is the row to which the rows will be moved. That is, the index at row in will become row in , followed by all other rows up to . However, when moving rows down in the same parent ( and are equal), the rows will be placed before the index. That is, if you wish to move rows 0 and 1 so they will become rows 1 and 2, should be 3. In this case, the new index for the source row (which is between and ) is equal to . Note that if and are the same, you must ensure that the is not within the range of and + 1. You must also ensure that you do not attempt to move a row to one of its own children or ancestors. This method returns if either condition is true, in which case you should abort your move operation. Specify the first and last row numbers for the span of rows in the source parent you want to move in the model. Also specify the row in the destination parent to move the span to. For example, as shown in the diagram, we move three rows from row 2 to 4 in the source, so is 2 and is 4. We move those items to above row 2 in the destination, so is 2. This moves the three rows rows 2, 3, and 4 in the source to become 2, 3 and 4 in the destination. Other affected siblings are displaced accordingly. To append rows to another parent, move them to after the last row. For example, as shown in the diagram, we move three rows to a collection of 6 existing rows (ending in row 5), so is 6: This moves the target rows to the end of the target parent as 6, 7 and 8. To move rows within the same parent, specify the row to move them to. For example, as shown in the diagram, we move one item from row 2 to row 0, so and are 2 and is 0. Note that other rows may be displaced accordingly. Note also that when moving items within the same parent you should not attempt invalid or no-op moves. In the above example, item 2 is at row 2 before the move, so it cannot be moved to row 2 (where it is already) or row 3 (no-op as row 3 means above row 3, where it is already) To move rows within the same parent, specify the row to move them to. For example, as shown in the diagram, we move one item from row 2 to row 4, so and are 2 and is 4. Note that other rows may be displaced accordingly."
    },
    {
        "link": "https://qtcentre.org/threads/51876-PyQt4-QTreeView-performance-issue",
        "document": ""
    },
    {
        "link": "https://realpython.com/python-pyqt-database",
        "document": "Building applications that use an SQL database is a fairly common programming task. SQL databases are everywhere and have great support in Python. In GUI programming, PyQt provides robust and cross-platform SQL database support that allows you to create, connect to, and manage your databases consistently.\n\nPyQt’s SQL support fully integrates with its Model-View architecture to help you in the process of building database applications.\n\nIn this tutorial, you’ll learn how to:\n• Use PyQt’s SQL support to reliably connect to a database\n• Display and edit data using different PyQt widgets\n\nThe examples in this tutorial require a basic knowledge of the SQL language, especially of the SQLite database management system. Some previous knowledge of GUI programming with Python and PyQt will also be helpful.\n\nWith a fully functional database connection, you’re ready to start working with your database. To do that, you can use string-based SQL queries and objects. allows you to run any kind of SQL query in your database. With , you can execute data manipulation language (DML) statements, such as , , , and , as well as data definition language (DDL) statements, such as and so on. The constructor of has several variations, but in this tutorial, you’re going to learn about two of them:\n• constructs a query object using a string-based SQL and a database . If you don’t specify a connection, or if the specified connection is invalid, then the default database connection is used. If isn’t an empty string, then it will be executed right away.\n• constructs a query object using . If is invalid, then the default connection is used. You can also create objects without passing any arguments to the constructor. In that case, the query will use the default database connection, if any. To execute a query, you need to call on the query object. You can use in two different ways:\n• executes the string-based SQL query contained in . It returns if the query was successful and otherwise returns .\n• executes a previously prepared SQL query. It returns if the query was successful and otherwise returns . Note: PyQt also implements variations of with the name . These provide backward compatibility with older versions of Python in which was a keyword of the language. Now that you know the basics of using to create and execute SQL queries, you’re ready to learn how to put your knowledge into practice. To start creating and executing queries with PyQt, you’re going to fire up your favorite code editor or IDE and create a Python script called . Save the script and add the following code to it: # Create a query and execute it right away using .exec() In this script, you start by importing the modules and classes that you’re going to work with. Then you create a database connection using with the SQLite driver. You set the database name to and open the connection. To create your first query, you instantiate without any arguments. With the query object in place, you call , passing a string-based SQL query as an argument. This kind of query is known as a static query because it doesn’t get any parameters from outside the query. The above SQL query creates a new table called in your database. That table will have the following four columns: An integer with the table’s primary key A string with the name of a contact A string with the job title of a contact A string with the email of a contact The last line in the above script prints the list of tables contained in your database. If you run the script, then you’ll note that a new database file called is created in your current directory. You’ll also get something like printed on your screen. This list contains the names of the tables in your database. Note: A string-based SQL query must use an appropriate syntax according to the specific SQL database that you’re querying. If the syntax is wrong, then ignores the query and returns . In the case of SQLite, the query can contain only one statement at a time. Calling on a object is a common way of immediately executing string-based SQL queries on your databases, but what if you want to prepare your queries beforehand for later execution? That’s the topic of the next section. So far, you’ve learned how to execute static queries on a database. Static queries are those that don’t accept parameters, so the query runs as it is. Even though these queries are fairly useful, sometimes you need to create queries that retrieve data in response to certain input parameters. Queries that accept parameters at execution time are known as dynamic queries. Using parameters allows you to fine-tune the query and retrieve data in response to specific parameter values. Different values will produce different results. You can take input parameters in a query by using one of the following two approaches:\n• Build the query dynamically, using string formatting to interpolate parameter values.\n• Prepare the query using placeholder parameters and then bind specific values to parameters. The first approach allows you to create dynamic queries quickly. However, to safely use this approach, you need to be sure that your parameter values come from a trusted source. Otherwise, you might face SQL injection attacks. Here’s an example of how to use string formatting to create dynamic queries in PyQt: In this example, you use an f-string to create a dynamic query by interpolating specific values into a string-based SQL query. The final query inserts data into your table, which now contains data about . Note: Later on in this tutorial, you’ll see how to retrieve and navigate the data stored in a database. Note that for this kind of dynamic query to work, you need to make sure that the values to be inserted have the right data type. So, you use single quotes around the placeholder in the f-string because those values need to be strings. The second approach for executing dynamic queries requires you to prepare your queries beforehand using a template with placeholders for parameters. PyQt supports two parameter placeholder styles:\n• Oracle style uses named placeholders such as or . Note that these styles can’t be mixed in the same query. You can check out Approaches to Binding Values for extra examples on how to use placeholders. To create this kind of dynamic query in PyQt, you first create a template with a placeholder for each query parameter and then pass that template as an argument to , which parses, compiles, and prepares the query template for execution. If the template has any problems, such as an SQL syntax error, then fails to compile the template and returns . If the preparation process succeeds, then returns . After that, you can pass a specific value to each parameter using with named or positional parameters or using with positional parameters. has the following two variations: In the first variation, represents an Oracle-style placeholder. In the second variation, represents a zero-based integer number with the position of a parameter in the query. In both variations, holds the value to be bound to a specific parameter. adds a value to the list of placeholders using positional binding. This means that the order of the calls to determines which value will be bound to each placeholder parameter in the prepared query. To start using prepared queries, you can prepare an SQL statement to populate your database with some sample data. Go back to the script that you created in the section Executing Static SQL Queries and add the following code right after the call to : # Creating a query for later execution using .prepare() The first step is to create a object. Then you call on the query object. In this case, you use the ODBC style for the placeholders. Your query will take values for your contact’s , , and , so you need three placeholders. Since the column is an autoincremented integer number, you don’t need to supply values for it. Then you create some sample data to populate the database. holds a list of tuples, and each tuple contains three items: the name, job, and email of each contact. The final step is to bind the values that you want to pass to each placeholder and then call to execute the query. To do that, you use a loop. The loop header unpacks each tuple in into three separate variables with convenient names. Then you call on the query object to bind the values to the placeholders. Note that you’re using positional placeholders, so the order in which you call will define the order in which each value is passed to the corresponding placeholder. This approach for creating dynamic queries is handy when you want to customize your queries using values that come from your user’s input. Anytime you take the user’s input to complete a query on a database, you face the security risk of SQL injection. In PyQt, combining , , and fully protects you against SQL injection attacks, so this is the way to go when you’re taking untrusted input to complete your queries. If you execute a statement, then your object will retrieve zero or more records from one or more tables in your database. The query will hold records containing data that matches the query’s criteria. If no data matches the criteria, then your query will be empty. provides a set of navigation methods that you can use to move throughout the records in a query result: All these methods position the query object on the retrieved record if that record is available. Most of these methods have specific rules that apply when using them. With these methods, you can move forward, backward, or arbitrarily through the records in a query result. Since they all return either or , you can use them in a loop to navigate all the records in one go. These methods work with active queries. A query is active when you’ve successfully run on it, but the query isn’t finished yet. Once an active query is on a valid record, you can retrieve data from that record using . This method takes a zero-based integer number, , and returns the value at that index (column) in the current record. Note: If you execute a type of query, then the columns in the result won’t follow a known order. This might cause problems when you use to retrieve the value at a given column because there’s no way of knowing if you’re using the right column index. You’ll look at a few examples of how to use some of the navigation methods to move throughout a query below. But first, you need to create a connection to your database: Here, you create and open a new connection to . If you’ve been following along with this tutorial so far, then this database already contains some sample data. Now you can create a object and execute it on that data: This query retrieves data about the , , and of all the contacts stored in the table. Since returned , the query was successful and is now an active query. You can navigate the records in this query using any of the navigation methods you saw before. You can also retrieve the data at any column in a record using : # Retrieve data from the first record With the navigation methods, you can move around the query result. With , you can retrieve the data at any column in a given record. You can also iterate through all the records in your query using a loop along with : With , you navigate all the records in a query result. works similar to the iterator protocol in Python. Once you’ve iterated over the records in a query result, starts returning until you run again. A call to retrieves data from a database and places the query object’s internal pointer one position before the first record, so when you call , you get the first record again. You can also loop in reverse order using : works similar to , but the iteration is done in reverse order. In other words, the loop goes from the query pointer’s position back to the first record. Sometimes you might want to get the index that identifies a given column in a table by using the name of that column. To do that, you can call on the return value of : The call to on the result of returns the index of the column. If doesn’t exist, then returns . This is handy when you use a statement in which the order of columns is unknown. Finally, if you’re done with a query object, then you can turn it inactive by calling . This will free the system memory associated with the query object at hand.\n\nIn practice, some of your PyQt applications will depend on a database, and others won’t. An application that depends on a database often creates and opens a database connection just before creating any window or graphical component and keeps the connection open until the application is closed. On the other hand, applications that don’t depend on a database but use a database to provide some of their functionalities typically connect to that database only when needed, if at all. In these cases, you can close the connection after use and free the resources associated with that connection, such as system memory. To close a connection in PyQt, you call on the connection. This method closes the connection and frees any acquired resources. It also invalidates any associated objects because they can’t work properly without an active connection. Here’s an example of how to close an active database connection using : You can call on a connection to close it and free all its associated resources. To make sure that a connection is closed, you call . Note that objects remain in memory after closing their associated connection, so you must make your queries inactive by calling or , or by deleting the object before closing the connection. Otherwise, residual memory is left out in your query object. You can reopen and reuse any previously closed connection. That’s because doesn’t remove connections from the list of available connections, so they remain usable. You can also completely remove your database connections using . To do this safely, first finish your queries using , then close the database using , and finally remove the connection. You can use to remove the database connection called from the list of available connections. Removed connections are no longer available for use in the application at hand. To remove the default database connection, you can call on the object returned by and pass the result to : # The connection is closed but still in the list of connections # The connection is no longer in the list of connections Here, the call to returns the list of available connections. In this case, you have only one connection, the default. Then you remove the connection using . Note: Before closing and removing a database connection, you need to make sure that everything that uses the connection is deleted or set to use a different data source. Otherwise, you can have a resource leak. Since you need a connection name to use , you call on the result of to get the name of the default connection. Finally, you call again to make sure that the connection is no longer in the list of available connections. Trying to open a removed connection will return because the connection no longer exists.\n\nA common requirement in GUI applications that use databases is the ability to load, display, and edit data from the database using different widgets. Table, list, and tree widgets are commonly used in GUIs to manage data. PyQt provides two different kind of widgets for managing data:\n• View widgets don’t maintain internal data containers but use models to access data. For small GUI applications that manage small databases, you can use the first approach. The second approach is handy when you’re building complex GUI applications that manage large databases. The second approach takes advantage of PyQt’s Model-View programming. With this approach, you have widgets that represent views such as tables, lists, and trees on one hand and model classes that communicate with your data on the other hand. The Model-View-Controller (MVC) design pattern is a general software pattern intended to divide an application’s code into three general layers, each with a different role. The model takes care of the business logic of the application, the view provides on-screen representations, and the controller connects the model and the view to make the application work. Qt provides a custom variation of MVC. They call it the Model-View architecture, and it’s available for PyQt as well. The pattern also separates the logic into three components:\n• Models communicate with and access the data. They also define an interface that’s used by views and delegates to access the data. All models are based on . Some commonly used models include , , and SQL-related models.\n• Views are responsible for displaying the data to the user. They also have similar functionality to the controller in the MVC pattern. All views are based on . Some commonly used views are , , and .\n• Delegates paint view items and provide editor widgets for modifying items. They also communicate back with the model if an item has been modified. The base class is . Separating classes into these three components implies that changes on models will be reflected on associated views or widgets automatically, and changes on views or widgets through delegates will update the underlying model automatically. In addition, you can display the same data in different views without the need for multiple models. PyQt provides a bunch of standard widgets for displaying and editing data in your GUI applications. These standard widgets provide views such as tables, trees, and lists. They also provide an internal container for storing data and convenient delegates for editing the data. All these features are grouped into a single class. Here are three of these standard classes: is arguably the most popular widget when it comes to displaying and editing data. It creates a 2D array of objects. Each item holds an individual value as a string. All these values are displayed and organized in a table of rows and columns. You can perform at least the following operations on a object:\n• Editing the content of its items using delegate objects\n• Setting the number of rows and columns using and\n• Adding vertical and horizontal header labels using and Here’s a sample application that shows how to use a object to display data in a GUI. The application uses the database you created and populated in previous sections, so if you want to run it, then you need to save the code into the same directory in which you have the database: If you double-click any cell of the table, then you’ll be able to edit the content of the cell. However, your changes won’t be saved to your database. Here’s the code for your application: # Set up the view and load the data Here’s what’s happening in this example:\n• Lines 18 to 20 create a object, set the number of columns to , and set user-friendly labels for each column’s header.\n• Line 21 creates and executes a SQL query on your database to get all the data in the table.\n• Line 22 starts a loop to navigate the records in the query result using .\n• Line 24 increments the number of rows in the table by using .\n• Lines 25 to 28 add items of data to your table using . Note that since the values in the columns are integer numbers, you need to convert them into strings to be able to store them in a object.\n• holds a zero-based integer that represents the index of a given row in the table.\n• holds a zero-based integer that represents the index of a given column in the table.\n• holds the object that you need to place at a given cell in the table. Finally, you call on your view to adjust the size of the columns to their content and provide a better rendering of the data. Displaying and editing database tables using standard widgets can become a challenging task. That’s because you’ll have two copies of the same data. In other words you’ll have a copy of the data in two locations:\n• Outside the widget, in your database\n• Inside the widget, in the widget’s internal containers You’re responsible for synchronizing both copies of your data manually, which can be an annoying and error-prone operation. Luckily, you can use PyQt’s Model-View architecture to avoid most of these problems, as you’ll see in the following section. PyQt’s Model-View classes eliminate the problems of data duplication and synchronization that may occur when you use standard widget classes to build database applications. The Model-View architecture allows you to use several views to display the same data because you can pass one model to many views. Model classes provide an application programming interface (API) that you can use to manipulate data. View classes provide convenient delegate objects that you can use to edit data in the view directly. To connect a view with a given module, you need to call on the view object. PyQt offers a set of view classes that support the Model-View architecture: A list of items that take values directly from a model class A hierarchical tree of items that take values directly from a model class A table of items that take values directly from a model class You can use these view classes along with model classes to create your database applications. This will make your applications more robust, faster to code, and less error-prone. Here are some of the model classes that PyQt provides for working with SQL databases: An editable data model for reading and writing records in a single table An editable data model for reading and writing records in a relational table Once you’ve connected one of these models to a physical database table or query, you can use them to populate your views. Views provide delegate objects that allow you to modify the data directly in the view. The model connected to the view will update the data in your database to reflect any change in the view. Note that you don’t have to update the data in the database manually. The model will do that for you. Here’s an example that shows the basics of how to use a object and a object together to build a database application using PyQt’s Model-View architecture: To edit the data in a cell of the table, you can double-click the cell. A convenient delegate widget will show in the cell, allowing you to edit its content. Then you can hit to save the changes. The ability to automatically handle and save changes in the data is one of the more important advantages of using PyQt’s Model-View classes. The Model-View architecture will improve your productivity and reduce the errors that can appear when you have to write data manipulation code by yourself. Here’s the code to create the application:\n• Line 19 connects your model with the table in your database using .\n• Line 20 sets the edit strategy of the model to . This strategy allows the model to automatically update the data in your database if the user modifies any of the data directly in the view.\n• Lines 21 to 24 set some user-friendly labels to the horizontal headers of the model using .\n• Line 25 loads the data from your database and populates the model by calling .\n• Line 27 creates the table view object to display the data contained in the model.\n• Line 28 connects the view with the model by calling on the view with your data model as an argument.\n• Line 29 calls on the view object to adjust the table to its content. That’s it! You now have a fully-functional database application."
    },
    {
        "link": "https://stackoverflow.com/questions/35033116/in-pyqt-how-to-print-ctrlkey-in-qlineedit-when-pressed-ctrl-anykey",
        "document": "here my kode where I generated event for QLineEdit to put pressed key combination in textline it Ok for Shift key and Alt key but not for key why ?\n\nin textline it is Ok for Shift key and Alt key I can put by variable self.myText value in textline, but not for key why ?"
    },
    {
        "link": "https://stackoverflow.com/questions/28204043/how-to-handle-keyboard-shortcuts-using-keypressevent-and-should-it-be-used-fo",
        "document": "If you look at the signature of you will see that the argument you describe in your question is of type .\n\ninstances have a method which returns an integer that can be matched against constants in the enum .\n\nSimilarly, has a method . Because there can be multiple keyboard modifiers pressed at once, you need to use this a little differently. The result from is the binary OR of one or more of the constants in the enum. To test if a given modifier is pressed, you need to perform the binary AND. For example:\n\nNote: In the example above, if both ctrl+shift were pressed, then all three if statements execute, in sequence."
    },
    {
        "link": "https://qtcentre.org/threads/47619-simultaneous-use-of-ctrl-key-along-with-mouse-press-event",
        "document": ""
    },
    {
        "link": "https://realpython.com/python-menus-toolbars",
        "document": "When it comes to developing graphical user interface (GUI) applications with Python and PyQt, some of the most useful and versatile graphical elements that you’ll ever use are menus, toolbars, and status bars.\n\nMenus and toolbars can make your applications look polished and professional, presenting users with an accessible set of options, while status bars allow you to display relevant information about the application’s status.\n• What menus, toolbars, and status bars are\n• How to create menus, toolbars, and status bars programmatically\n• How to populate Python menu and toolbar using PyQt actions\n• How to use status bars to display status information\n\nIn addition, you’ll learn some programming best practices that you can apply when creating menus, toolbars, and status bars with Python and PyQt. If you’re new to GUI programming with PyQt, then you can check out Python and PyQt: Building a GUI Desktop Calculator.\n\nYou can download the code and resources for the sample application that you’ll build in this tutorial by clicking on the box below:\n\nA menu bar is a region of a GUI application’s main window that holds menus. Menus are pull-down lists of options that provide convenient access to your application’s options. For example, if you were creating a text editor, then you might have some of the following menus in your menu bar:\n• A File menu that provides some of the following menu options:\n• New for creating a new document\n• An Edit menu that provides some of the following menu options:\n• A Help menu that provides some of the following menu options:\n• Help Content for launching to user’s manual and help content\n• About for launching an About dialog You can also add some of these options to a toolbar. A toolbar is a panel of buttons with meaningful icons that provide fast access to the most commonly used options in an application. In your text editor example, you could add options like New, Open, Save, Copy, and Paste to a toolbar. Note: In this tutorial, you’ll develop a sample application that implements all the above menus and options. You can use this sample application as a starting point to create a text editor project. In this section, you’ll learn the basics of how to add menu bars, menus, and toolbars to your GUI applications with Python and PyQt. Before going any further, you’ll create a sample PyQt application that you’ll use throughout this tutorial. In each section, you’ll add new features and functionalities to this sample application. The application will be a main window–style application. This means that it’ll have a menu bar, a toolbar, a status bar, and a central widget. Open your favorite code editor or IDE and create a Python file called . Then add the following code to it: Now contains all the code that you need for creating your sample PyQt application. In this case, inherits from . So, you’re building a main window–style application. Note: Unfortunately, PyQt5’s official documentation has some incomplete sections. To work around this, you can check out either the PyQt4 documentation or the original Qt documentation. In the class initializer , you first call the parent class’s initializer using . Then you set the title of the window using and resize the window using . Note: If you aren’t familiar with PyQt applications and how to create them, then you can check out Python and PyQt: Building a GUI Desktop Calculator. The window’s central widget is a object that you’ll use to show messages in response to certain user actions. These messages will display at the center of the window. To do this, you call on the object with a couple of alignment flags. If you run the application from your command line, then you’ll see the following window on your screen: That’s it! You’ve created a main window–style application with Python and PyQt. You’ll use this sample application for all the upcoming examples in this tutorial. In a PyQt main window–style application, provides an empty object by default. To get access to this menu bar, you need to call on your object. This method will return an empty menu bar. The parent for this menu bar will be your main window object. Now go back to your sample application and add the following method in the definition of : This is the preferred way of creating a menu bar in PyQt. Here, the variable will hold an empty menu bar, which will be your main window’s menu bar. Note: A common practice in PyQt programming is to use local variables for objects that you won’t use or need from outside their definition method. Python garbage-collects all objects that get out of scope, so you might think that in the above example will disappear once returns. The truth is that PyQt keeps a reference to local objects such as using their ownership, or parent-child relationship. In other words, since is owned by your main window object, Python won’t be able to garbage-collect it. Another way of adding a menu bar to your PyQt applications is to create a object and then set it as the main window’s menu bar using . With this in mind, you can also write in the following way: In the above example, holds a object with the parent set to , which is the application’s main window. Once you have the menu bar object, you can use to add it to your main window. Finally, note that for this example to work, you first need to import from . In a GUI application, the menu bar will be displayed in different positions depending on the underlying operating system:\n• Windows: At the top of the application’s main window, under the title bar\n• macOS: At the top of the screen\n• Linux: Either at the top of the main window or at the top of the screen, depending on your desktop environment The final step to create a menu bar for your application is to call from the main window’s initializer : If you run your sample application with these new changes, then you won’t see the menu bar shown on the application’s main window. That’s because your menu bar is still empty. To see the menu bar on your application’s main window, you need to create some menus. That’s what you’ll learn next. Menus are pull-down lists of menu options that you can trigger by clicking them or by hitting a keyboard shortcut. There are at least three ways for adding menus to a menu bar object in PyQt:\n• appends a object ( ) to a menu bar object. It returns the action associated with this menu.\n• creates and appends a new object with the string ( ) as its title to a menu bar. The menu bar takes the ownership of the menu and the method returns the new object.\n• creates and appends a new object with an and a to a menu bar object. The menu bar takes the ownership of the menu and the method returns the new object. If you use the first option, then you need to create your custom objects first. To do that, you can use one of the following constructors: In both cases, is the that will hold the ownership of the object. You’ll typically set to the window in which you’ll use the menu. In the second constructor, will hold a string with a text that describes the menu option. Here’s how you can add File, Edit, and Help menus to the menu bar of your sample application: First, you import from . Then in , you add three menus to your menu bar using the first two variations of . The third variation requires an icon object, but you haven’t learned how to create and use icons yet. You’ll learn about how to use icons in the section Using Icons and Resources in PyQt. If you run the sample application, then you’ll see that you now have a menu bar like this: The application’s menu bar has the menus File, Edit, and Help. When you click these menus, they don’t show a pull-down list of menu options. That’s because you haven’t added menu options yet. You’ll learn how to add menu options to a menu in the section Populating Menus With Actions. Finally, note that the ampersand character ( ) that you include in the title of each menu creates underlined letters in the menu bar display. This is discussed in more detail in the section Defining Keyboard Shortcuts for Menu and Toolbar Options. A toolbar is a movable panel that holds buttons and other widgets to provide fast access to the most common options of a GUI application. Toolbar buttons can display icons, text, or both to represent the task that they perform. The base class for toolbars in PyQt is . This class will allow you to create custom toolbars for your GUI applications. When you add a toolbar to a main window–style application, the default position is at the top of the window. However, you can place a toolbar in any one of the following four toolbar areas: Toolbar areas are defined as constants in PyQt. If you need to use them, then you have to import from and then use fully qualified names just like in . There are three ways to add toolbars to your main window application in PyQt:\n• creates a new and empty object and sets its window title to . This method inserts the toolbar into the top toolbar area and returns the newly created toolbar.\n• inserts a object ( ) into the specified toolbar area ( ). If the main window already has toolbars, then is placed after the last existing toolbar. If already exists in the main window, then it will only be moved to . If you use one of the last two options, then you need to create the toolbar by yourself. To do this, you can use one of the following constructors: In both cases, represents the object that will hold the ownership of the toolbar. You’ll commonly set the toolbar ownership to the window in which you’re going to use the toolbar. In the second constructor, will be a string with the toolbar’s window title. PyQt uses this window title to build a default context menu that allows you to hide and show your toolbars. Now you can go back to your sample application and add the following method to : First, you import from . Then, in , you first create the File toolbar using with a title. Next, you create a object with the title and add it to the toolbar using without passing a toolbar area. In this case, the Edit toolbar is placed at the top toolbar area. Finally, you create the Help toolbar and place it in the left toolbar area using . The final step to make this work is to call from the initializer of : The call to inside the initializer of will create three toolbars and add them to your main window. Here’s how your application looks now: Now you have two toolbars right below the menu bar and one toolbar along the left side of the window. Each toolbar has a double dotted line. When you move the mouse over the dotted lines, the pointer changes to a hand. If you click and hold on the dotted line, then you can move the toolbar to any other position or toolbar area on the window. If you right-click a toolbar, then PyQt will show a context menu that will allow you to hide and show existing toolbars according to your needs. So far, you have three toolbars on your application’s window. These toolbars are still empty—you’ll need to add some toolbar buttons to make them functional. To do that, you can use PyQt actions, which are instances of . You’ll learn how to create actions in PyQt in a later section. For now, you’ll learn how to use icons and other resources in your PyQt applications.\n\nUsing Icons and Resources in PyQt The Qt library includes the Qt resource system, which is a convenient way of adding binary files such as icons, images, translation files, and other resources to your applications. To use the resource system, you need to list your resources in a resource collection file, or a file. A file is an file that contains the location, or path, of each resource in your file system. Suppose that your sample application has a directory containing the icons that you want to use in the application’s GUI. You have icons for options like New, Open, and so on. You can create a file containing the path to each icon: Each entry must contain the path to a resource in your file system. The specified paths are relative to the directory containing the file. In the above example, the directory needs to be in the same directory as the file. is an optional attribute that defines a short alternative name that you can use in your code to get access to each resource. Once you have the resources for your application, you can run the command-line tool targeting your file. is shipped with PyQt and must be fully functional on your Python environment once you have PyQt installed. reads a file and produces a Python module that contains the binary code for all your resources: This command will read and generate containing the binary code for each resource. You’ll be able to use those resources in your Python code by importing . Note: If something goes wrong when running , then make sure that you’re using the right Python environment. If you install PyQt in a Python virtual environment, then you won’t be able to use from outside that environment. Here’s a fragment of the code in that corresponds to your : # Created by: The Resource Compiler for PyQt5 (Qt v5.9.5) # WARNING! All changes made in this file will be lost! With in place, you can import it into your application and refer to each resource by typing a colon (:) and then either its or its path. For example, to access with its alias, you would use the access string . If you didn’t have an , you would access it by its path with the access string . If you have aliases, but for some reason you want to access a given resource by its path instead, then you might have to remove the colon from the access string in order to make this work properly. To use the icons in your actions, you first need to import your resources module: Once you’ve imported the module that contains your resources, you can use the resources in your application’s GUI. Note: Linters, editors, and IDEs may flag the above import statement as unused because your code won’t include any explicit use of it. Some IDEs may go even further and remove that line automatically. In these situations, you must override the suggestions of your linter, editor, or IDE and keep that import in your code. Otherwise, your application won’t be able to display your resources. To create an icon using the resources system, you need to instantiate , passing the alias or the path to the class constructor: In this example, you create a object with the file , which is in your resources module. This provides a convenient way of using icons and resources throughout your GUI application. Now go back to your sample application and update the last line of : # Using an icon and a title For this code to work, you first need to import from . You also need to import . In the last highlighted line, you add an icon to using from your resources module. If you run your sample application with this update, then you’ll get the following output: The application’s main window now shows an icon on its Help menu. When you click the icon, the menu shows the text . Using icons in a menu bar isn’t a common practice, but PyQt allows you to do it anyway.\n\nCreating Actions for Python Menus and Toolbars in PyQt PyQt actions are objects that represent a given command, operation, or action in an application. They’re useful when you need to provide the same functionality for different GUI components such as menu options, toolbar buttons, and keyboard shortcuts. You can create actions by instantiating . Once you’ve created an action, you need to add it to a widget to be able to use it in practice. You also need to connect your actions to some functionality. In other words, you need to connect them to the function or method that you want to run when the action is triggered. This will allow your application to perform operations in response to user actions in the GUI. Actions are quite versatile. They allow you to reuse and keep in sync the same functionality across menu options, toolbar buttons, and keyboard shortcuts. This provides a consistent behavior throughout the application. For example, users might expect the application to perform the same action when they click the Open… menu option, click the Open toolbar button, or press + on their keyboard. provides an abstraction that allows you to track the following elements:\n• The help tip on a toolbar option (tooltip)\n• The What’s This help tip\n• The help tip on a status bar (status tip)\n• The keyboard shortcut associated with options\n• The icon associated with menu and toolbar options To create actions, you need to instantiate . There are at least three general ways to do that: In all three cases, represents the object that holds the ownership of the action. This argument can be any . A best practice is to create actions as children of the window in which you’re going to use them. In the second and third constructors, holds the text that the action will display on a menu option or a toolbar button. The text of an action displays differently on menu options and toolbar buttons. For example, the text displays as Open… in a menu option and as Open in a toolbar button. In the third constructor, is a object that holds the action’s icon. This icon will be displayed on the left side of the text in a menu option. The position of the icon in a toolbar button depends on the toolbar’s property, which can take one of the following values: Follows the general style of the underlying platform You can also set the action’s text and icon using their respective setter methods, and . Note: For a complete list of properties, you can check out the documentation. Here’s how you can create some actions for your sample application using the different constructors of : # Creating action using the first constructor # Creating actions using the second constructor In , you create a few actions for your sample application. These actions will allow you to add options to the application’s menus and toolbars. Note that you’re creating actions as instance attributes, so you can access them from outside using . This way, you’ll be able to use these actions on both your menus and your toolbars. Note: In , you don’t use the third constructor of because it doesn’t make sense to use icons if you can’t see the actions yet. You’ll learn how to add icons to actions in the section Populating Toolbars With Actions. The next step is to call form the initializer of : If you run the application now, then you won’t see any change on the GUI. That’s because actions don’t get displayed until they’re added to a menu or toolbar. Note that you call before you call and because you’ll be using these actions on your menus and toolbars. If you add an action to a menu, then the action becomes a menu option. If you add an action to a toolbar, then the action becomes a toolbar button. That’s the topic for the next few sections.\n\nToolbars are a quite useful component when it comes to building GUI applications with Python and PyQt. You can use a toolbar to present your users with a quick way to get access to the most commonly used options in your application. You can also add widgets like spin boxes and combo boxes to a toolbar for allowing the user to directly modify some properties and variables from the application’s GUI. In the following few sections, you’ll learn how to add options or buttons to your toolbars using actions and also how to add widgets to a toolbar with . To add options or buttons to a toolbar, you need to call . In this section, you’ll rely on the variation of that inherits from . So, you’ll call with an action as an argument. This will allow you to share your actions between menus and toolbars. When you’re creating toolbars, you’ll commonly face the problem of deciding what options to add to them. Typically, you’ll want to add only the most frequently used actions to your toolbars. If you return to your sample application, then you’ll remember that you added three toolbars: In the File toolbar, you can add options like the following: In the Edit toolbar, you can add the following options: Normally, when you want to add buttons to a toolbar, you first select the icons that you want to use on each button. This isn’t mandatory, but it’s a best practice. Once you’ve selected the icons, you need to add them to their corresponding actions. Here’s how you can add icons to the actions of your sample application: To add icons to your actions, you update the highlighted lines. In the case of , you use . In the rest of the actions, you use the constructor with an , a , and a object as arguments. Once your selected actions have icons, you can add these actions to their corresponding toolbar by calling on the toolbar object: With this update to , you add buttons for the New, Open, and Save options to the File toolbar. You also add buttons for the Copy, Paste, and Cut options to the Edit toolbar. Note: The order in which buttons are displayed on a toolbar from left to right corresponds to the order in which you add the buttons in your code. If you run your sample application now, then you’ll get the following window on your screen: The sample application now shows two toolbars with a few buttons each. Your users can click these buttons to get quick access to the application’s most commonly used options. Note: When you first wrote back in the section Creating Toolbars, you created a Help toolbar. This toolbar was intended to show how to add a toolbar using a different variation of . In the above update of , you get rid of the Help toolbar just to keep the example short and clear. Note that, since you share the same actions between your menus and toolbars, the menu options will also display the icons on their left side, which is a big win in terms of productivity and resource use. This is one of the advantages of using PyQt actions to create menus and toolbars with Python. In some situations, you’ll find it useful to add specific widgets like spin boxes, combo boxes, or others to a toolbar. A common example of this is the combo boxes that most word processors use to allow the user to change the font of a document or the size of a selected text. To add widgets to a toolbar, you first need to create the widget, setup its properties and then call on the toolbar object passing the widget as an argument. Suppose you want to add a object to the Edit toolbar of your sample application to allow the user to change the size of something, which could be the font size. You need to update : Here, you first import the spin box class. Then you create a object, set its to , and finally add it to your Edit toolbar. Note: In the above code, you set the property of the spin box to because if this widget gets the focus, then the application’s keyboard shortcuts won’t work properly. Now, if you run the application, then you’ll get the following output: Here, the Edit toolbar shows a object that your users can use to set the size of the font or any other numeric property on your application. PyQt toolbars are quite flexible and customizable. You can set a bunch of properties on a toolbar object. Some of the most useful properties are shown in the following table: The toolbar areas in which you can place a given toolbar Whether you can drag and drop the toolbar as an independent window Whether the toolbar is an independent window The size of the icons displayed on the toolbar buttons Whether you can move the toolbar within the toolbar area or between toolbar areas The orientation of the toolbar All these properties have an associated setter method. For example, you can use to set , to set , and so on. Now, suppose you don’t want your users to move the File toolbar around the window. In this case, you can set to using : The highlighted line makes the magic here. Now your users can’t move the toolbar around the application’s window: The File toolbar doesn’t show the double dotted line anymore, so your users won’t be able to move it. Note that the Edit toolbar is still movable. You can change other properties on your toolbars using this same approach and customize them according to your needs.\n\nContext menus, also known as pop-up menus, are a special type of menu that appears in response to certain user actions, like a right-click on a given widget or window. These menus offer a small list of options that are available in a given context of the operating system or application that you’re using. For example, if you right-click the desktop of a Windows machine, then you’ll get a menu with options that corresponds to that specific context or space of the operating system. If you right-click the workspace of a text editor, then you’ll get a totally different context menu that will depend on the editor you’re using. In PyQt, you have several options for creating context menus. In this tutorial, you’ll learn about two of those options:\n• Setting the property on specific widgets to\n• Handling the context menu event on the application’s window through The first option is the most common and user-friendly of the two, so you’ll learn about it first. The second option is a little bit more complex and relies on handling user events. In GUI programming, an event is any user action on the application, like clicking a button or a menu, selecting an item from a combo box, entering or updating the text in a text field, pressing a key on the keyboard, and so on. All PyQt graphical components or widgets that derive from inherit a property called . This property controls how the widget displays a context menu. One of the most commonly used values for this property is . This makes the widget display its internal list of actions as a context menu. To make a widget display a context menu based on its internal actions, you need to run two steps:\n• Add some actions to the widget using .\n• Set to on the widget using . Setting to causes widgets that have actions to show them in a context menu. This is a really quick way to create a context menu with Python and PyQt. With this technique, you can add a context menu to the central widget of your sample application and provide your users with a way to quickly access to some of the application’s options. To do that, you can add the following method to : In , you first set to using the setter method . Then you add actions to the widget using as usual. The final step is to call from the initializer of : If you run your sample application after these additions, then you’ll see that the application’s central widget shows a context menu when you right-click on it: Now your sample application has a context menu that pops up whenever you right-click the application’s central widget. The central widget stretches to occupy all the available space in the window, so you’re not limited to right-clicking on the label text to see the context menu. Finally, since you use the same actions throughout this application, the options on the context menu show the same set of icons. An alternative way of creating context menus in PyQt is to handle the context menu event of the application’s main window. To do this, you need to run the following steps:\n• Override the event handler method, , on the object.\n• Launch the menu object using with the event’s as an argument. This way of managing context menus is a bit more complex. However, it gives you fine control over what happens when the context menu is invoked. For example, you can enable or disable menus options according to the application’s state and so on. Note: Before you go any further in this section, you need to disable the code you wrote in the previous section. To do that, just go to the initializer of and comment out the line that calls . Here’s how you can reimplement the context menu of your sample application, overriding the event handler method on the main window object: # Creating a menu object with the central widget as parent In , you first create a object ( ) with as its parent widget. Next you populate the menu with actions using . Finally, you call on the object to show it on the screen. The second argument of represents the event that the method catches. In this case, will be a right-click on the application’s central widget. In the call to , you use as an argument. This method returns the global position of the mouse pointer when the user clicks a PyQt window or a widget. The mouse position will tell where on the window to show the context menu. If you run your sample application with these new changes, then you’ll get the same result that you got in the previous section. Unlike in menus and toolbars, in context menus, you can’t use to add a separator and visually separate your menu options according to the relationship between them. When it comes to organizing context menus, you need to create a separator action: The call to on an action object will turn that action into a separator. Once you have the separator action, you need to insert it in the right place in the context menu using . If you look back to your sample application, then you might want to visually separate the options that come from the File menu from the options that come from the Edit menu. To do that, you can update : # Adding the separator to the menu In the first two highlighted lines, you create the separator action. In the third highlighted line, you add the separator action to the menu using . This will add a horizontal line between the File options and the Edit options. Here’s how your context menu looks with this addition: Now your context menu includes a horizontal line that visually separates the options that come from File from the options that come from Edit. With this, you’ve improved the visual quality of the menu and provided a better user experience.\n\nConnecting Signals and Slots in Menus and Toolbars In PyQt, you use signals and slots to provide functionality to your GUI applications. PyQt widgets emit signals every time an event such as a mouse click, a keypress, or a window resizing, occurs on them. A slot is a Python callable that you can connect to a widget’s signal to perform some actions in response to user events. If a signal and a slot are connected, then the slot will be called automatically every time the signal is emitted. If a given signal isn’t connected to a slot, then nothing will happen when the signal is emitted. To make your menu options and toolbar buttons launch some operations when the user clicks on them, you need to connect the signals of the underlying actions with some custom or built-in slots. objects can emit a variety of signals. However, the most commonly used signal in menus and toolbars is . This signal is emitted every time the user clicks a menu option or a toolbar button. To connect with a slot, you can use the following syntax: In this example, is a Python callable. In other words, can be a function, a method, a class, or an instance of a class that implements . You already have a set of actions in your sample application. Now you need to code the slots that you’ll call every time the user clicks a menu option or a toolbar button. Go to the definition of and add the following methods: # Logic for creating a new file goes here... # Logic for opening an existing file goes here... # Logic for saving a file goes here... # Logic for copying content goes here... # Logic for pasting content goes here... # Logic for cutting content goes here... # Logic for launching help goes here... # Logic for showing an about dialog content goes here... These methods will play the role of the slots of your sample application. They’ll be called every time the user clicks the corresponding menu option or toolbar button. Once you have the slots that provide the functionality, you need to connect them with the action’s signal. This way, the application will perform actions in response to the user events. To make these connections, go to the sample application and add the following method to : This method will connect all your actions’ signals with their respective slots or callbacks. With this update, your sample application will display a message on the object that you set as a central widget telling you what menu option or toolbar button was clicked. In the case of , you connect its signal with the built-in slot . This way, if you select File → Exit, then your application will close. Finally, go to the initializer of and add a call to : With this final update, you can run the application again. Here’s how all these changes work: If you click a menu option, a toolbar button, or a context menu option, then the label at the center of the application’s window shows a message indicating the action that was executed. This functionality isn’t very useful outside of a learning context, but it gives you an idea of how to make your applications perform real-world actions when the user interacts with the GUI. Finally, when you select File → Exit, the application closes because the signal of is connected to the built-in slot . As an exercise, you can try to create custom slots for the Find… and Replace… options in the Find and Replace submenu and then connect their signals to those slots to make them live. You can also experiment with the slots that you coded in this section and try to do new things with them.\n\nWhen creating menus for an application, you’ll sometimes need to populate those menus with options that are unknown at the time you create the application’s GUI. For example, the Open Recent menu in a text editor shows a list of recently opened documents. You can’t populate this menu at the time of creating the application’s GUI because every user will open different documents and there’s no way to know this information in advance. In this case, you need to populate the menus dynamically in response to user actions or the application’s state. has a signal called that you can connect to a custom slot to dynamically populate the menu object before it’s shown on the screen. To continue developing your sample application, suppose you need to create an Open Recent submenu under File and dynamically populate it with recently opened files or documents. To do this, you need to run the following steps:\n• Code a custom slot that dynamically generates the actions to populate the menu.\n• Connect the signal of the menu with the custom slot. Here’s the code for creating the submenu: In the highlighted line, you add a submenu under the File menu with the title . This submenu doesn’t have menu options yet. You need to create the actions dynamically to populate it. You can do this by coding a method to create the actions dynamically and add them to the submenu. Here’s an example that shows the general logic that you can use: # Step 1. Remove the old options from the menu # Step 3. Add the actions to the menu In , you first remove the old options, if any, from the menu using . Then you add the logic for dynamically creating and connecting the actions. Finally, you add the actions to the menu using . In the loop, you use to connect the signal with because you want to pass as an argument to . This is a quite useful technique when it comes to connecting a signal with a slot that takes extra arguments. For it to work, you need to import from . Note: The logic in the second step of this example doesn’t really load a list of recently opened files. It just creates a of five hypothetical files with the only purpose of showing a way to implement this technique. The next step is to connect the signal of to . To do that, add the following line at the end of : In the highlighted line, you connect the signal with . This ensures that your menu gets populated right before it’s shown. Now you need to code . This is the method that your application will call when your users click any of the dynamically created actions: # Logic for opening a recent file goes here... This method will update the text of the object that you use as the central widget of your sample application. Here’s how your dynamically created submenu works in practice: When your mouse pointer hovers over the Open Recent menu, the menu emits the signal. This results in a call to , which creates and connects the actions. If you click a file name, then you’ll see that the central label changes accordingly to show a message.\n\nA status bar is a horizontal panel that is usually placed at the bottom of the main window in a GUI application. Its primary purpose is to display information about the current status of the application. The status bar can also be divided into sections to show different information on each section. According to the Qt documentation, there are three types of status indicators:\n• Temporary indicators take up almost the entire status bar for a short time to display tooltip texts, menu entries, and other time-sensitive information.\n• Normal indicators take up a part of the status bar and display information that users may want to reference periodically, such as word counts in a word processor. These may be briefly hidden by temporary indicators.\n• Permanent indicators are always displayed in the status bar, even when a temporary indicator is activated. They’re used to show important information about the current mode of the application, such as when the Caps Lock key has been pressed. You can add a status bar to your main window–style application using one of the following options:\n• Call on your object. creates and returns an empty status bar for the main window.\n• Create a object, then call on your main window with the status bar object as an argument. That way, will set your status bar object as the main window’s status bar. Here you have two alternative implementations for adding a status bar to your sample application: Both implementations produce the same result. However, most of the time you’ll use the first implementation for creating your status bars. Note that for the second implementation to work, you need to import from . Add one of the above implementations to your application’s and then call in the class initializer. With these additions, when you run your application again, you’ll see a window like this: Your application now has a status bar at the bottom of its main window. The status bar is almost invisible, but if you look closely, then you’ll notice a small dotted triangle on the bottom-right corner of the window. The main purpose of a status bar is to present status information to the users of your application. To show temporary status messages in a status bar, you need to use . This method takes the following two arguments:\n• holds the number of milliseconds that the message will be shown on the status bar. If is , which is its default value, then the message remains on the status bar until you call or on the status bar. If there’s an active message on your status bar and you call with a new message, then the new message will obscure or replace the old one. Go to your sample application and add the following line to : The final line in will make your application show a message on the application’s status bar for milliseconds: When you run the application, the status bar shows the message . After milliseconds, the message disappears and the status bar gets cleared and ready to show a new status message. You can also show permanent messages on your application’s status bar. A permanent message keeps the user informed about some general state of the application. For example, in a text editor, you might want to show a permanent message with information about the text encoding of the currently opened file. To add permanent messages to your status bars, you use a object to hold the message. Then you add the label to the status bar by calling . This method permanently adds the given widget to the current status bar. The widget’s parent is set to the status bar. takes the following two arguments:\n• holds the widget object that you want to add to the status bar. Some commonly used widgets on this role are , , and .\n• is used to compute a suitable size for the widget as the status bar grows and shrinks. It defaults to , which means that the widget is going to take the minimum amount of space. Keep in mind that a permanent widget won’t be obscured or replaced by temporary messages. locates widgets at the right side of the status bar. Note: You can use not only to show permanent messages on your status bars but also to present the user with a progress bar to monitor the duration of a given operation. You can also provide buttons on the status bar to allow the user to change properties like the file encoding on a text editor. When you use these kinds of widgets on a status bar, try to stick to the most commonly used widget for the type of application that you’re developing. This way, your users will feel right at home. Say you want to turn your sample application into a text editor, and you want to add a message to the status bar that shows information about the word count of the current file. To do that, you can create a method called and then add a permanent message using and a object: # Logic for computing the word count goes here... This method adds the logic for computing the word count in the currently opened document. Now, you can show this information as a permanent message: In the last two lines, you first create a object ( ) to hold the message about the word count. To create the message, you use an f-string, in which you insert a call to to get the word count information. Then you add the label to the status bar using . In this case, you create the object as an instance attribute because the word count needs to be updated according to the changes that the user makes to the current file. If you run the application with this update, then you’ll see the word count message on the right side of the status bar: The status bar shows a message that informs the user about the word count in a hypothetical current file. The ability to present the user with permanent information or other options in the status bar is quite useful and can help you to greatly improve the user experience for your applications."
    },
    {
        "link": "https://pythonhosted.org/pyglet/programming_guide/handling_mouse_and_keyboard_events.html",
        "document": "So far the only event used is the on_draw event. To react to keyboard and mouse events, it's necessary to write and attach event handlers for these events as well:\n\nKeyboard events have two parameters: the virtual key that was pressed, and a bitwise combination of any modifiers that are present (for example, the and keys).\n\nThe key symbols are defined in pyglet.window.key:\n\nSee the documentation for a complete list of key symbols.\n\nMouse events are handled in a similar way:\n\nThe and parameters give the position of the mouse when the button was pressed, relative to the lower-left corner of the window.\n\nThere are more than 20 event types that you can handle on a window. The easiest way to find the event name and parameters you need is to add the following line to your program:\n\nThis will cause all events received on the window to be printed to the console.\n\nAn example program using keyboard and mouse events is in examples/programming_guide/events.py"
    }
]