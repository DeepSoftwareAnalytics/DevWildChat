[
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://stackoverflow.com/questions/66188304/how-do-i-graph-data-in-c",
        "document": "According to your issue and exit-code, the return value in hex is 0xC0000005 or STATUS_ACCESS_VIOLATION. But most developers didn't even bother to learn out-dated legacy API and I can not help you to find the exact line (use debugger, it shows you the exact line, still not the reason).\n\nBut to answer your question in the title, well, according to what free framework one uses (Qt or XWidget), the method differs, for Qt (which I would recommend) simply override paint-event and use QPainter renderer to show your QPath data.\n\nDon't reinvent the wheel (or render-system in this case), your course and/or book may soon introduce you to one of the mentioned frameworks."
    },
    {
        "link": "https://stackoverflow.com/questions/62638349/input-output-operations-on-characters",
        "document": "will not create a new file if does not exist, but result in an error. Most likely this file does not exist, so you get an error and any subsequent input and output operations on the stream are ignored. You could use\n\nto destroy the contents of an existing file or create a new one if the file does not exist.\n\nFor further information please consult the table on https://en.cppreference.com/w/cpp/io/basic_filebuf/open where all the different combinations of openmode are detailed.\n\nLastly, it's always good practice to check if the file was opened:"
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-and-output-in-c",
        "document": "In C programming, input and output operations refer to reading data from external sources and writing data to external destinations outside the program. C provides a standard set of functions to handle input from the user and output to the screen or to files. These functions are part of the standard input/output library <stdio.h>.\n\nIn C, there are many functions used for input and output in different situations but the most commonly used functions for Input/Output are scanf() and printf() respectively.\n\nThe printf() function is used to print formatted output to the standard output stdout (which is generally the console screen). It is one of the most commonly used functions in C.\n\nExplanation: The printf() function sends the string “First Print” to the output stream, displaying it on the screen.\n\nVariable values and direct values(literals) can also be printed by printf().\n\nHere, the value of variable age is printed. You may have noticed %d in the formatted string. It is actually called format specifier which are used as placeholders for the value in the formatted string.\n\nYou may have also noticed ‘\n\n’ character. This character is an escape sequence and is used to enter a newline.\n\nscanf() is used to read user input from the console. It takes the format string and the addresses of the variables where the input will be stored.\n\nRemember that this function takes the address of the arguments where the read value is to be stored.\n\nExplanation: %d is used to read an integer; and &age provides the address of the variable where the input will be stored."
    },
    {
        "link": "https://w3schools.com/c/c_ref_stdio.php",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/implementation-of-dfs-using-adjacency-matrix",
        "document": "Depth First Search (DFS) has been discussed in this article which uses adjacency list for the graph representation. In this article, adjacency matrix will be used to represent the graph.\n\nAdjacency matrix representation: In adjacency matrix representation of a graph, the matrix mat[][] of size n*n (where n is the number of vertices) will represent the edges of the graph where mat[i][j] = 1 represents that there is an edge between the vertices i and j while mat[i][j] = 0 represents that there is no edge between the vertices i and j.\n\n\n\nBelow is the adjacency matrix representation of the graph shown in the above image:\n• Create a matrix of size n*n where every element is 0 representing there is no edge in the graph.\n• Now, for every edge of the graph between the vertices i and j set mat[i][j] = 1.\n• After the adjacency matrix has been created and filled, call the recursive function for the source i.e. vertex 0 that will recursively call the same function for all the vertices adjacent to it.\n• Also, keep an array to keep track of the visited vertices i.e. visited[i] = true represents that vertex i has been visited before and the DFS function for some already visited node need not be called.\n\nBelow is the implementation of the above approach: \n\n\n\nThe time complexity of the above implementation of DFS on an adjacency matrix is O(V^2), where V is the number of vertices in the graph. This is because for each vertex, we need to iterate through all the other vertices to check if they are adjacent or not.\n\nThe space complexity of this implementation is also O(V^2) because we are using an adjacency matrix to represent the graph, which requires V^2 space."
    },
    {
        "link": "https://geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph",
        "document": "Depth First Search or DFS for a Graph\n\nIn Depth First Search (or DFS) for a graph, we traverse all adjacent vertices one by one. When we traverse an adjacent vertex, we completely finish the traversal of all vertices reachable through that adjacent vertex. This is similar to a tree, where we first completely traverse the left subtree and then move to the right subtree. The key difference is that, unlike trees, graphs may contain cycles (a node may be visited more than once). To avoid processing a node multiple times, we use a boolean visited array.\n\nNote : There can be multiple DFS traversals of a graph according to the order in which we pick adjacent vertices. Here we pick vertices as per the insertion order. Output: 1 0 2 3 4\n\nExplanation: The source vertex s is 1. We visit it first, then we visit an adjacent. \n\nStart at 1: Mark as visited. Output: 1\n\nMove to 0: Mark as visited. Output: 0 (backtrack to 1)\n\nMove to 2: Mark as visited. Output: 2 (backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 2)\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2) Not that there can be more than one DFS Traversals of a Graph. For example, after 1, we may pick adjacent 2 instead of 0 and get a different DFS. Here we pick in the insertion order. Start at 0: Mark as visited. Output: 0\n\nMove to 2: Mark as visited. Output: 2\n\nMove to 4: Mark as visited. Output: 4 (backtrack to 2, then backtrack to 0)\n\nMove to 3: Mark as visited. Output: 3 (backtrack to 0)\n\nMove to 1: Mark as visited. Output: 1\n\nDFS from a Given Source of Undirected Graph:\n\nThe algorithm starts from a given source and explores all reachable vertices from the given source. It is similar to Preorder Tree Traversal where we visit the root, then recur for its children. In a graph, there might be loops. So we use an extra visited array to make sure that we do not process a vertex again.\n\nLet us understand the working of Depth First Search with the help of the following illustration: for the source as 0.\n\nBelow is the implementation of the above approach:\n\n// that are not visited yet // To add an edge in an undirected graph // Traverse all adjacent vertices that are not visited yet // Function to add an edge to the adjacency list // Define the edges of the graph // Recursively visit all adjacent vertices that are // Function to add an edge to the adjacency list // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Create an adjacency list for the graph # Define the edges of the graph // that are not visited yet // Create an adjacency list for the graph // Define the edges of the graph // Recursively visit all adjacent vertices that are not // Number of vertices in the graph // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n\nPlease refer Complexity Analysis of Depth First Search: for details.\n\nThe above implementation takes a source as an input and prints only those vertices that are reachable from the source and would not print all vertices in case of disconnected graph. Let us now talk about the algorithm that prints all vertices without any source and the graph maybe disconnected.\n\nThe idea is simple, instead of calling DFS for a single vertex, we call the above implemented DFS for all all non-visited vertices one by one.\n\n// Recursively visit all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph // Function to add an edge to the adjacency list // Add edge from t to s (for undirected graph) // Traverse all adjacent vertices that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected graph // If vertex i has not been visited, // Define the edges of the graph // Function to add an edge to the adjacency list // Recursively visit all adjacent vertices that are // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph # that are not visited yet # Loop through all vertices to handle disconnected # Define the edges of the graph // Function to add an edge to the adjacency list // that are not visited yet // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle // If vertex i has not been visited, // Create an adjacency list for the graph // Define the edges of the graph using tuples // Recursively visit all adjacent vertices that are not // Main DFS function to perform DFS for the entire graph // Loop through all vertices to handle disconnected // Create an adjacency list for the graph // Define the edges of the graph\n\nTime complexity: O(V + E). Note that the time complexity is same here because we visit every vertex at most once and every edge is traversed at most once (in directed) and twice in undirected.\n\nAuxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to DFSRec function.\n• None Depth First Search or DFS on Directed Graph\n• None Breadth First Search or BFS for a Graph"
    },
    {
        "link": "https://stackoverflow.com/questions/14090644/implementing-depth-first-traversal-for-a-graph-using-adjacency-matrix-c",
        "document": "You'll want to use a last-in first-out queue, otherwise known as a stack. You could also use recursion, but you risk having a stack overflow if you graph is too large.\n\nFor each node, loop through all the nodes that node is connected to, adding them to the stack.\n\nPop the first node off of the stack, do whatever operation you wanted to do, and then repeat the process.\n\nThis could look like\n\nNote that if you have a cycle in your graph there will be problems."
    },
    {
        "link": "https://programiz.com/dsa/graph-dfs",
        "document": "Depth first Search or Depth first traversal is a recursive algorithm for searching all the vertices of a graph or tree data structure. Traversal means visiting all the nodes of a graph.\n\nA standard DFS implementation puts each vertex of the graph into one of two categories:\n\nThe purpose of the algorithm is to mark each vertex as visited while avoiding cycles.\n\nThe DFS algorithm works as follows:\n• Start by putting any one of the graph's vertices on top of a stack.\n• Take the top item of the stack and add it to the visited list.\n• Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.\n• Keep repeating steps 2 and 3 until the stack is empty.\n\nLet's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices.\n\nWe start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.\n\nNext, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.\n\nVertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.\n\nAfter we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.\n\nThe pseudocode for DFS is shown below. In the init() function, notice that we run the DFS function on every node. This is because the graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the DFS algorithm on every node.\n\nThe code for the Depth First Search Algorithm with an example is shown below. The code has been simplified so that we can focus on the algorithm rather than other details.\n\nThe time complexity of the DFS algorithm is represented in the form of , where is the number of nodes and is the number of edges.\n\nThe space complexity of the algorithm is .\n• To test if the graph is bipartite\n• For finding the strongly connected components of a graph"
    },
    {
        "link": "https://naukri.com/code360/library/dfs-using-adjacency-matrix",
        "document": ""
    }
]