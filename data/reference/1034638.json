[
    {
        "link": "https://tradingview.com/pine-script-reference/v5",
        "document": ""
    },
    {
        "link": "https://tradingview.com/pine-script-docs/migration-guides/to-pine-version-5",
        "document": "This guide documents the changes made to Pine Script from v4 to v5. It will guide you in the adaptation of existing Pine scripts to Pine Script v5. See our Release notes for a list of the new features in Pine Script v5.\n\nThe most frequent adaptations required to convert older scripts to v5 are:\n• Changing study() for indicator() (the function’s signature has not changed).\n• Renaming built-in function calls to include their new namespace (e.g., highest() in v4 becomes ta.highest() in v5).\n• Restructuring inputs to use the more specialized functions.\n• Eliminating uses of the deprecated parameter by using color.new() to simultaneously define color and transparency for use with the parameter.\n• If you used the and parameters in v4’s study(), they will require changing to and in v5’s indicator().\n\nThe Pine Editor can automatically convert v4 indicators and strategies to v5. The Pine converter is described in the Overview page.\n\nNot all scripts can be automatically converted from v4 to v5. If you want to convert the script manually or if your indicator returns a compilation error after conversion, use the following sections to determine how to complete the conversion. A list of some errors you can encounter during the automatic conversion and how to fix them can be found in the Common script conversion errors section of this guide.\n\nFor clarity and consistency, many built-in functions and variables were renamed in v5. The inclusion of v4 function names in a new namespace is the cause of most changes. For example, the sma() function in v4 is moved to the namespace in v5: ta.sma(). Remembering the new namespaces is not necessary; if you type the older name of a function without its namespace in the Editor and press the ‘Auto-complete’ hotkey ( + , or on MacOS), a popup showing matching suggestions appears:\n\nNot counting functions moved to new namespaces, only two functions have been renamed:\n\nThe full list of renamed functions and variables can be found in the All variable, function, and parameter name changes section of this guide.\n\nThe parameter names of some built-in functions were changed to improve the nomenclature. This has no bearing on most scripts, but if you used these parameter names when calling functions, they will require adaptation. For example, we have standardized all mentions:\n\n// Valid in v4. Not valid in v5. timev4 = time(resolution = \"1D\") // Valid in v5. timev5 = time(timeframe = \"1D\") // Valid in v4 and v5. timeBoth = time(\"1D\")\n\nThe full list of renamed function parameters can be found in the All variable, function, and parameter name changes section of this guide.\n\nIn v4, the rsi() function had two different overloads:\n• for the normal RSI calculation, and\n• for an overload used in the MFI indicator, which did a calculation equivalent to .\n\nThis caused a single built-in function to behave in two very different ways, and it was difficult to distinguish which one applied because it depended on the type of the second argument. As a result, a number of indicators misused the function and were displaying incorrect results. To avoid this, the second overload was removed in v5.\n\nThe ta.rsi() function in v5 only accepts a “simple int” argument for its parameter. If your v4 code used the now deprecated overload of the function with a second argument, you can replace the whole call with the following formula, which is equivalent:\n\nNote that when your v4 code used a “series int” value as the second argument to rsi(), it was automatically cast to “series float” and the second overload of the function was used. While this was syntactically correct, it most probably did not yield the result you expected. In v5, ta.rsi() requires a “simple int” for the argument to , which precludes dynamic (or “series”) lengths. The reason for this is that RSI calculations use the ta.rma() moving average, which is similar to ta.ema() in that it relies on a length-dependent recursive process using the values of previous bars. This makes it impossible to achieve correct results with a “series” length that could vary bar to bar.\n\nIf your v4 code used a length that was “const int”, “input int” or “simple int”, no changes are required.\n\nA number of words are reserved and cannot be used for variable or function names. They are: , , , , , , , , , , , , . If your v4 indicator uses any of these, rename your variable or function for the script to work in v5.\n\nThe iff() and offset() functions have been removed. Code using the iff() function can be rewritten using the ternary operator:\n\n// iff(<condition>, <return_when_true>, <return_when_false>) // Valid in v4, not valid in v5 barColorIff = iff(close >= open, color.green, color.red) // <condition> ? <return_when_true> : <return_when_false> // Valid in v4 and v5 barColorTernary = close >= open ? color.green : color.red\n\nNote that the ternary operator is evaluated “lazily”; only the required value is calculated (depending on the condition’s evaluation to or ). This is different from iff(), which always evaluated both values but returned only the relevant one.\n\nSome functions require evaluation on every bar to correctly calculate, so you will need to make special provisions for these by pre-evaluating them before the ternary:\n\n// `iff()` in v4: `highest()` and `lowest()` are calculated on every bar v1 = iff(close > open, highest(10), lowest(10)) plot(v1) // In v5: forced evaluation on every bar prior to the ternary statement. h1 = ta.highest(10) l1 = ta.lowest(10) v1 = close > open ? h1 : l1 plot(v1)\n\nThe offset() function was deprecated because the more readable [] operator is equivalent:\n\n// Valid in v4. Not valid in v5. prevClosev4 = offset(close, 1) // Valid in v4 and v5. prevClosev5 = close[1]\n\nSplit of `input()` into several functions\n\nThe v4 input() function was becoming crowded with a plethora of overloads and parameters. We split its functionality into different functions to clear that space and provide a more robust structure to accommodate the additions planned for inputs. Each new function uses the name of the type of the v4 call it replaces. E.g., there is now a specialized input.float() function replacing the v4 call. Note that you can still use in v5, but because only input.float() allows for parameters such as , , etc., it is more powerful. Also note that input.int() is the only specialized input function that does not use its equivalent v4 name. The constants have been removed because they were used as arguments for the parameter, which was deprecated.\n\nTo convert, for example, a v4 script using an input of type , the input.symbol() function must be used in v5:\n\n// Valid in v4. Not valid in v5. aaplTicker = input(\"AAPL\", type = input.symbol) // Valid in v5 aaplTicker = input.symbol(\"AAPL\")\n\nThe input() function persists in v5, but in a simpler form, with less parameters. It has the advantage of automatically detecting input types “bool/color/int/float/string/source” from the argument used for :\n\n// Valid in v4 and v5. // While \"AAPL\" is a valid symbol, it is only a string here because `input.symbol()` is not used. tickerString = input(\"AAPL\", title = \"Ticker string\")\n\nIn v4, built-in constants such as used as arguments when calling Pine Script functions corresponded to pre-defined values of a specific type. For example, the value of was , so you could use instead of the named constant when supplying an argument to the parameter in a security() function call. We found this to be a common source of confusion, which caused unsuspecting programmers to produce code yielding unintended results.\n\nIn v5, the use of correct built-in named constants as arguments to function parameters requiring them is mandatory:\n\n// Not valid in v5: `true` is used as an argument for `lookahead`. request.security(syminfo.tickerid, \"1D\", close, lookahead = true) // Valid in v5: uses a named constant instead of `true`. request.security(syminfo.tickerid, \"1D\", close, lookahead = barmerge.lookahead_on) // Would compile in v4 because `plot.style_columns` was equal to 5. // Won't compile in v5. a = 2 * plot.style_columns plot(a)\n\nTo convert your script from v4 to v5, make sure you use the correct named built-in constants as function arguments.\n\nThe parameter used in the signature of many v4 plotting functions was deprecated because it interfered with RGB functionality. Transparency must now be specified along with the color as an argument to parameters such as , , etc. The color.new() or color.rgb() functions will be needed in those cases to join a color and its transparency.\n\nNote that in v4, the bgcolor() and fill() functions had an optional parameter that used a default value of 90. This meant that the code below could display Bollinger Bands with a semi-transparent fill between two bands and a semi-transparent backround color where bands cross price, even though no argument is used for the parameter in its bgcolor() and fill() calls:\n\n//@version=4 study(\"Bollinger Bands\", overlay = true) [middle, upper, lower] = bb(close, 5, 4) plot(middle, color=color.blue) p1PlotID = plot(upper, color=color.green) p2PlotID = plot(lower, color=color.green) crossUp = crossover(high, upper) crossDn = crossunder(low, lower) // Both `fill()` and `bgcolor()` have a default `transp` of 90 fill(p1PlotID, p2PlotID, color = color.green) bgcolor(crossUp ? color.green : crossDn ? color.red : na)\n\nIn v5 we need to explictly mention the 90 transparency with the color, yielding:\n\n//@version=5 indicator(\"Bollinger Bands\", overlay = true) [middle, upper, lower] = ta.bb(close, 5, 4) plot(middle, color=color.blue) p1PlotID = plot(upper, color=color.green) p2PlotID = plot(lower, color=color.green) crossUp = ta.crossover(high, upper) crossDn = ta.crossunder(low, lower) var TRANSP = 90 // We use `color.new()` to explicitly pass transparency to both functions fill(p1PlotID, p2PlotID, color = color.new(color.green, TRANSP)) bgcolor(crossUp ? color.new(color.green, TRANSP) : crossDn ? color.new(color.red, TRANSP) : na)\n\nChanged the default session days for `time()` and `time_close()`\n\nThe default set of days for strings used in the time() and time_close() functions, and returned by input.session(), has changed from (Monday to Friday) to (Sunday to Saturday):\n\n// On symbols that are traded during weekends, this will behave differently in v4 and v5. t0 = time(\"1D\", \"1000-1200\") // v5 equivalent of the behavior of `t0` in v4. t1 = time(\"1D\", \"1000-1200:23456\") // v5 equivalent of the behavior of `t0` in v5. t2 = time(\"1D\", \"1000-1200:1234567\")\n\nThis change in behavior should not have much impact on scripts running on conventional markets that are closed during weekends. If it is important for you to ensure your session definitions preserve their v4 behavior in v5 code, add to your session strings. See this manual’s page on Sessions for more information.\n\n`strategy.exit()` now must do something\n\nGone are the days when the strategy.exit() function was allowed to loiter. Now it must actually have an effect on the strategy by using at least one of the following parameters: , , , , or one of the following pairs: combined with either or . When uses of strategy.exit() not meeting these criteria trigger an error while converting a strategy to v5, you can safely eliminate these lines, as they didn’t do anything in your code anyway.\n\nTo make this work, you need to change the “int” arguments used for the and arguments in plot() and hline() for built-in constants:\n\n// Will cause an error during conversion plotStyle = input(1) hlineStyle = input(1) plot(close, style = plotStyle) hline(100, linestyle = hlineStyle) // Will work in v5 //@version=5 indicator(\"\") plotStyleInput = input.string(\"Line\", options = [\"Line\", \"Stepline\", \"Histogram\", \"Cross\", \"Area\", \"Columns\", \"Circles\"]) hlineStyleInput = input.string(\"Solid\", options = [\"Solid\", \"Dashed\", \"Dotted\"]) plotStyle = plotStyleInput == \"Line\" ? plot.style_line : plotStyleInput == \"Stepline\" ? plot.style_stepline : plotStyleInput == \"Histogram\" ? plot.style_histogram : plotStyleInput == \"Cross\" ? plot.style_cross : plotStyleInput == \"Area\" ? plot.style_area : plotStyleInput == \"Columns\" ? plot.style_columns : plot.style_circles hlineStyle = hlineStyleInput == \"Solid\" ? hline.style_solid : hlineStyleInput == \"Dashed\" ? hline.style_dashed : hline.style_dotted plot(close, style = plotStyle) hline(100, linestyle = hlineStyle)\n\nSee the Some function parameters now require built-in arguments section of this guide for more information.\n\nTo fix this issue, remove the constants from your code:\n\n// Will cause an error during conversion _integer = input.integer _bool = input.bool i1 = input(1, \"Integer\", _integer) i2 = input(true, \"Boolean\", _bool) // Will work in v5 i1 = input.int(1, \"Integer\") i2 = input.bool(true, \"Boolean\")\n\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\n\nThis is caused by a confusion between strategy.entry() and strategy.close().\n\nThe second parameter of strategy.close() is , which expects a “bool” argument. In v4, it was allowed to use an argument because it was a “bool”. With v5, however, named built-in constants must be used as arguments, so is no longer allowed as an argument to the parameter.\n\nThe call in this code is equivalent to , which is what must be used in v5:\n\n// Will cause an error during conversion if (longCondition) strategy.close(\"Short\", strategy.long) strategy.entry(\"Long\", strategy.long) // Will work in v5: if (longCondition) strategy.close(\"Short\") strategy.entry(\"Long\", strategy.long)\n\nSee the Some function parameters now require built-in arguments section of this guide for more information.\n\nCannot call ‘input.int’ with argument ‘minval’=‘%value%‘. An argument of ‘literal float’ type was used but a ‘const int’ is expected\n\nIn v4, it was possible to pass a “float” argument to when an “int” value was being input. This is no longer possible in v5; “int” values are required for “int” inputs:\n\n// Works in v4, will break on conversion because minval is a 'float' value int_input = input(1, \"Integer\", input.integer, minval = 1.0) // Works in v5 int_input = input.int(1, \"Integer\", minval = 1)\n\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\n\nAll variable, function, and parameter name changes\n\n”ticker” namespace for functions that help create tickers"
    },
    {
        "link": "https://tradingview.com/pine-script-docs",
        "document": "Everything you need to know about Pine Script™.\n\nIntroduction to the Pine Script️™ language and how to write scripts in the Pine Editor.\n\nExplore the building blocks and features of Pine Script️™.\n\nLearn various things you can do with Pine Script️™, by theme.\n\nStay updated on the latest improvements to the Pine Script️™ experience."
    },
    {
        "link": "https://pineify.app/resources/blog/how-to-combine-two-indicators-in-tradingview-pine-script",
        "document": "TradingView's Pine Script is a powerful tool for creating custom trading indicators and strategies. Combining two indicators in Pine Script can enhance your analysis by providing more reliable signals and reducing false positives. This article will guide you through the process of combining indicators in Pine Script, explain the benefits of this approach, and offer practical examples to implement your own scripts.\n\nCombining technical indicators can significantly improve your trading strategy by:\n• Filtering False Signals: Using multiple indicators together can confirm or invalidate signals, reducing the risk of acting on false positives.\n• Providing a Broader Perspective: Different indicators analyze different aspects of market conditions, such as trend direction, momentum, or volatility.\n• Enhancing Timing: Aligning signals from multiple indicators can help pinpoint better entry and exit points.\n• Reducing Risk: A multi-indicator approach minimizes the chances of making impulsive decisions based on a single indicator.\n• Log in to your TradingView account.\n• Open any chart and navigate to the Pine Editor tab at the bottom of the screen.\n\nFor this example, we'll combine the Relative Strength Index (RSI) and Exponential Moving Average (EMA):\n\nYou can use logical conditions to combine these indicators. For instance:\n• A buy signal occurs when RSI is below 30 (oversold) and the price crosses above the EMA.\n• A sell signal occurs when RSI is above 70 (overbought) and the price crosses below the EMA.\n\nVisualize these signals on the chart:\n\nYou can set alerts for these signals:\n• Limit your combination to two or three indicators to avoid analysis paralysis.\n• Use historical data to validate your combined indicator's effectiveness before applying it in live trading.\n• Learn how each indicator works to ensure they complement each other rather than duplicate information.\n\nHere’s an example script that combines MACD and RSI:\n• Simplifies your chart by merging multiple tools into one indicator.\n• Avoid combining indicators that measure similar aspects of market behavior (e.g., RSI and Stochastic Oscillator).\n• Be cautious not to over-optimize settings during backtesting as this might not perform well in live markets.\n• Indicators work differently in trending vs. ranging markets; adapt accordingly.\n\nWhen integrating multiple indicators into your TradingView scripts, Pineify offers an innovative and user-friendly solution to streamline the process. This AI-powered Pine Script generator eliminates the need for complex coding, allowing traders to visually combine multiple indicators into a single script easily.\n\nWith Pineify, you can bypass TradingView's default limit of two indicators per chart, enabling the addition of unlimited indicators on one chart, even with a free TradingView plan. The platform also supports customizing inputs and plots, offering flexibility for different ticker symbols and timeframes. Pineify’s powerful condition editor makes it possible to merge various technical indicators, price data, and custom rules into precise trading strategies. Whether you’re backtesting strategies or enhancing your technical analysis, Pineify is a game-changer, saving time, money, and the frustration of manual coding. Try its free plan or explore the Pro and Lifetime options for advanced features.\n\nCombining two indicators in TradingView Pine Script is an effective way to refine your trading strategy. By leveraging complementary tools like RSI and EMA or MACD and DMI, you can filter out noise and make more informed decisions. Remember to backtest thoroughly and keep your approach simple yet effective."
    },
    {
        "link": "https://tradingview.com/pine-script-docs/concepts/inputs",
        "document": "Inputs receive values that users can change from a script’s “Settings/Inputs” tab. By utilizing inputs, programmers can write scripts that users can more easily adapt to their preferences.\n\nThe following script plots a 20-period simple moving average (SMA) using ta.sma(close, 20). While it is straightforward to write, the code is not very flexible because the function call uses specific and arguments that users cannot change without modifying the code:\n\nIf we write our script this way instead, it becomes much more flexible, as users can select the and the values they want to use from the “Settings/Inputs” tab without changing the source code:\n\nInputs are only accessible while a script runs on a chart. Users can access script inputs from the “Settings” dialog box. To open this dialog, users can:\n• Double-click on the name of an on-chart indicator\n• Right-click on the script’s name and choose the “Settings” item from the dropdown menu\n• Choose the “Settings” item from the “More” menu icon (three dots) that appears when hovering over the indicator’s name on the chart\n• Double-click on the indicator’s name from the Data Window (fourth icon down to the right of the chart)\n\nThe “Settings” dialog always contains the “Style” and “Visibility” tabs, which allow users to specify their preferences about the script’s visuals and the chart timeframes that can display its outputs.\n\nWhen a script contains calls to functions, an “Inputs” tab also appears in the “Settings” dialog box.\n\nScripts process inputs when users add them to the chart or change the values in the script’s “Settings/Inputs” tab. Any changes to a script’s inputs prompt it to re-execute across all available data using the new specified values.\n\nScripts create input widgets in the “Inputs” tab that accept different types of inputs based on their function calls. By default, each input appears on a new line of the “Inputs” tab in the order of the calls. Programmers can also organize inputs in different ways by using the functions’ and parameters. See this section below for more information.\n\nOur Style guide recommends placing calls at the beginning of the script.\n\nInput functions typically contain several parameters that allow programmers to define their default values, value limits, their organization in the “Inputs” tab, and other properties.\n\nSince an call is simply another function call in Pine Script™, programmers can combine them with arithmetic, comparison, logical, and ternary operators to assign expressions to variables. This simple script compares the result from a call to input.string() to the “On” string and assigns the result to the variable. This variable is of the “input bool” type because the == operator returns a “bool” value:\n\n//@version=6 indicator(\"Input in an expression`\", \"\", true) bool plotDisplayInput = input.string(\"On\", \"Plot Display\", options = [\"On\", \"Off\"]) == \"On\" plot(plotDisplayInput ? close : na)\n\nAll values returned by functions except “source” ones are “input” qualified values. See our User Manual’s section on type qualifiers for more information.\n\nThe parameters common to all input functions are: , , , , , and . Some input functions also include other parameters: , , , and .\n\nAll these parameters expect “const” arguments. The only exceptions are for the and parameters of the source and enum inputs, as input.source() uses “series float” value, and input.enum() uses members of an enum type.\n\nSince parameters accept “const” arguments in most cases and the “input” and other qualifiers are stronger than “const”, it follows that one cannot use the result from one call as an argument in another call.\n\nLet’s go over each parameter:\n• is the first parameter of all input functions. It is the default value that appears in the input widget. It requires an argument of the type of input value that the function applies to.\n• requires a “const string” argument. It is the field’s label.\n• requires a “const string” argument. When the parameter is used, a question mark icon will appear to the right of the field. When users hover over it, the tooltip’s text will appear. Note that if multiple input fields are grouped on one line using , the tooltip will always appear to the right of the rightmost field, and display the text of the last argument used in the line. Newlines ( ) are supported in the argument string.\n• requires a “const string” argument. Using the same argument for the parameter in multiple calls will group their input widgets on the same line. There is a limit to the width the “Inputs” tab will expand, so a limited quantity of input fields can be fitted on one line. Using one call with a unique argument for has the effect of bringing the input field left, immediately after the label, foregoing the default left-alignment of all input fields used when no argument is used.\n• requires a “const string” argument. Use it to group any number of inputs in an organized section. The string used as the argument becomes the section’s heading. All calls to be grouped together must use the same string for their argument.\n• requires a comma-separated list of elements enclosed in square brackets (e.g., , , ). The input uses the specified elements as menu selections in its resulting dropdown widget. Users can only select one menu item at a time. When supplying an list, the value must be one of the list’s elements. Inputs that allow , , or parameters cannot use those parameters and the parameter simultaneously.\n• requires a “const int/float” argument, depending on the type of the value. It is the minimum valid value for the input field.\n• requires a “const int/float” argument, depending on the type of the value. It is the maximum valid value for the input field.\n• is the increment by which the field’s value will move when the widget’s up/down arrows are used.\n• requires a “const bool” ( or ) argument. This parameter affects the behavior of the script when it is added to a chart. calls using will cause the “Settings/Inputs” tab to popup when the script is added to the chart. is useful to ensure that users configure a particular field.\n\nThe , and parameters are only present in the signature of the input.int() and input.float() functions.\n\nThe next sections explain what each input function does. As we proceed, we will explore the different ways you can use input functions and organize their display.\n\ninput() is a simple, generic function that supports the fundamental Pine Script™ types: “int”, “float”, “bool”, “color” and “string”. It also supports “source” inputs, which are price-related values such as close, hl2, hlc3, and hlcc4, or which can be used to receive the output value of another script.\n\nThe function automatically detects the type of input by analyzing the type of the argument used in the function call. This script shows all the supported types and the qualified type returned by the function when used with arguments of different types:\n\nTwo signatures exist for the input.int() function; one when is not used, the other when it is:\n\nThis call uses the parameter to propose a pre-defined list of lengths for the MA:\n\nThis one uses the parameter to limit the length:\n\nThe version with the list uses a dropdown menu for its widget. When the parameter is not used, a simple input widget is used to enter the value:\n\nTwo signatures exist for the input.float() function; one when is not used, the other when it is:\n\nHere, we use a “float” input for the factor used to multiple the standard deviation, to calculate Bollinger Bands:\n\nThe input widgets for floats are similar to the ones used for integer inputs:\n\nLet’s continue to develop our script further, this time by adding a boolean input to allow users to toggle the display of the BBs:\n• We have added an input using input.bool() to set the value of .\n• We use the parameter in that input and in the one for to bring them on the same line. We use for its argument in both cases. That is how the Pine Script™ compiler recognizes that they belong on the same line. The particular string used as an argument is unimportant and does not appear anywhere in the “Inputs” tab; it is only used to identify which inputs go on the same line.\n• We have vertically aligned the arguments of our calls to make them easier to read.\n• We use the variable in our two plot() calls to plot conditionally. When the user unchecks the checkbox of the input, the variable’s value becomes . When that happens, our plot() calls plot the na value, which displays nothing. We use as the default value of the input, so the BBs plot by default.\n• Because we use the parameter for the variable, its input field in the “Inputs” tab does not align vertically with that of , which doesn’t use .\n\nAs explained in this section of the Colors page, selecting the colors of a script’s outputs via the “Settings/Style” tab is not always possible. In the case where one cannot choose colors from the “Style” tab, programmers can create color inputs with the input.color() function to allow color customization from the “Settings/Inputs” tab.\n\nSuppose we wanted to plot our BBs with a ligther transparency when the high and low values are higher/lower than the BBs. We can use a code like this to create the colors:\n\nWhen using dynamic (“series”) color components like the arguments in the above code, the color widgets in the “Settings/Style” tab will no longer appear. Let’s create our own input for color selection, which will appear in the “Settings/Inputs” tab:\n• We have added two calls to input.color() to gather the values of the and variables. We use directly in the call, and we use to build the and variables, which modulate the transparency using the position of price relative to the BBs. We use a conditional value for the value we call color.new() with, to generate different transparencies of the same base color.\n• We do not use a argument for our new color inputs because they are on the same line as other inputs allowing users to understand to which plots they apply.\n• We have reorganized our arguments so they reflect the fact we have inputs grouped on two distinct lines.\n\nThe input.timeframe() function creates a dropdown input containing timeframe choices. It returns a “string” value representing the selected timeframe in our specification format, which scripts can use in calls to retrieve data from user-selected timeframes.\n\nThe following script uses request.security() on each bar to fetch the value of a ta.sma() call from a user-specified higher timeframe, then plots the result on the chart:\n\n//@version=6 indicator(\"Timeframe input demo\", \"MA\", true) //@variable The timeframe of the requested data. string tfInput = input.timeframe(\"1D\", \"Timeframe\") // Get the typical number of seconds in the chart's timeframe and the `tfInput` timeframe. int chartSeconds = timeframe.in_seconds() int tfSeconds = timeframe.in_seconds(tfInput) // Raise an error if the `tfInput` is a lower timeframe. if tfSeconds < chartSeconds runtime.error(\"The 'Timeframe' input must represent a timeframe higher than or equal to the chart's.\") //@variable The offset of the requested expression. 1 when `tfInput` is a higher timeframe, 0 otherwise. int offset = chartSeconds == tfSeconds ? 0 : 1 //@variable The 20-bar SMA of `close` prices for the current symbol from the `tfInput` timeframe. float maHTF = request.security(syminfo.tickerid, tfInput, ta.sma(close, 20)[offset], lookahead = barmerge.lookahead_on) // Plot the `maHTF` value. plot(maHTF, \"MA\", color.aqua)\n• By default, the input.timeframe() call’s dropdown contains options for the chart’s timeframe and all timeframes listed in the chart’s “Time interval” menu. To restrict the available options to specific preset timeframes, pass a tuple of timeframe strings to the function’s parameter.\n• This script raises a runtime error if the estimated number of seconds in the timeframe is less than the number of seconds in the main timeframe, preventing it from requesting lower-timeframe data. See this section of the Other timeframes and data page to learn more.\n• The request.security() call uses barmerge.lookahead_on as its argument, and it offsets the argument by one bar when the represents a higher timeframe to avoid repainting.\n\nThe input.symbol() function creates an input widget that mirrors the chart’s “Symbol Search” widget. It returns a “string” ticker identifier representing the chosen symbol and exchange, which scripts can use in calls to retrieve data from other contexts.\n\nThe script below uses request.security() to retrieve the value of a ta.rsi() call evaluated on a user-specified symbol’s prices. It plots the requested result on the chart in a separate pane:\n\n//@version=6 indicator(\"Symbol input demo\", \"RSI\") //@variable The ticker ID of the requested data. By default, it is an empty \"string\", which specifies the main symbol. string symbolInput = input.symbol(\"\", \"Symbol\") //@variable The 14-bar RSI of `close` prices for the `symbolInput` symbol on the script's main timeframe. float symbolRSI = request.security(symbolInput, timeframe.period, ta.rsi(close, 14)) // Plot the `symbolRSI` value. plot(symbolRSI, \"RSI\", color.aqua)\n• The argument in the input.symbol() call is an empty “string”. When the request.security() call in this example uses this default value as the argument, it calculates the RSI using the chart symbol’s data. If the user wants to revert to the chart’s symbol after choosing another symbol, they can select “Reset settings” from the “Defaults” dropdown at the bottom of the “Settings” menu.\n\nSession inputs are useful to gather start-stop values for periods of time. The input.session() built-in function creates an input widget allowing users to specify the beginning and end time of a session. Selections can be made using a dropdown menu, or by entering time values in “hh:mm” format.\n\nThe value returned by input.session() is a valid string in session format. See the manual’s page on sessions for more information.\n\nSession information can also contain information on the days where the session is valid. We use an input.string() function call here to input that day information:\n• The input.string() call uses a tooltip to provide users with help on the format to use to enter day information.\n• A complete session string is built by concatenating the two strings the script receives as inputs.\n• We explicitly declare the type of our two inputs with the string keyword to make it clear those variables will contain a string.\n• We detect if the chart bar is in the user-defined session by calling time() with the session string. If the current bar’s time value (the time at the bar’s open) is not in the session, time() returns na, so will be whenever time() returns a value that is not na.\n\nSource inputs are useful to provide a selection of two types of sources:\n• The values plotted by other scripts on the chart. This can be useful to “link” two or more scripts together by sending the output of one as an input to another script.\n\nThis script simply plots the user’s selection of source. We propose the high as the default value:\n\nThis shows a chart where, in addition to our script, we have loaded an “Arnaud Legoux Moving Average” indicator. See here how we use our script’s source input widget to select the output of the ALMA script as an input into our script. Because our script plots that source in a light-purple thick line, you see the plots from the two scripts overlap because they plot the same value:\n\nTime inputs use the input.time() function. The function returns a Unix time in milliseconds (see the Time page for more information). This type of data also contains date information, so the input.time() function returns a time and a date. That is the reason why its widget allows for the selection of both.\n\nHere, we test the bar’s time against an input value, and we plot an arrow when it is greater:\n\nNote that the value we use is a call to the timestamp() function.\n\nThe input.enum() function creates a dropdown input that displays field titles corresponding to distinct members (possible values) of an enum type. The function returns one of the unique, named values from a declared enum, which scripts can use in calculations and logic requiring more strict control over allowed values and operations. Supply a list of enum members to the parameter to specify the members users can select from the dropdown. If one does not specify an enum field’s title, its title is the “string” representation of its name.\n\nThis example declares a enum with four fields representing named signal display modes: , , , and . The script uses a member of this enum type as the argument in the input.enum() call to generate a dropdown in the “Inputs” tab, allowing users to select one of the enum’s titles to control which signals it displays on the chart:\n\n//@version=6 indicator(\"Enum input demo\", overlay = true) //@enum An enumeration of named values representing signal display modes. //@field long Named value to specify that only long signals are allowed. //@field short Named value to specify that only short signals are allowed. //@field both Named value to specify that either signal type is allowed. //@field none Named value to specify that no signals are allowed. enum SignalType long = \"Only long signals\" short = \"Only short signals\" both = \"Long and short signals\" none //@variable An enumerator (member) of the `SignalType` enum. Controls the script's signals. SignalType sigInput = input.enum(SignalType.long, \"Signal type\") // Calculate moving averages. float ma1 = ta.sma(ohlc4, 10) float ma2 = ta.sma(ohlc4, 200) // Calculate cross signals. bool longCross = ta.crossover(close, math.max(ma1, ma2)) bool shortCross = ta.crossunder(close, math.min(ma1, ma2)) // Calculate long and short signals based on the selected `sigInput` value. bool longSignal = (sigInput == SignalType.long or sigInput == SignalType.both) and longCross bool shortSignal = (sigInput == SignalType.short or sigInput == SignalType.both) and shortCross // Plot shapes for the `longSignal` and `shortSignal`. plotshape(longSignal, \"Long signal\", shape.triangleup, location.belowbar, color.teal, size = size.normal) plotshape(shortSignal, \"Short signal\", shape.triangledown, location.abovebar, color.maroon, size = size.normal) // Plot the moving averages. plot(ma1, \"Fast MA\") plot(ma2, \"Slow MA\")\n• The value is the member whose field contains the selected title.\n• Since we did not specify a title for the field of the enum, its title is the “string” representation of its name (“none”), as we see in the above image of the enum input’s dropdown.\n\nBy default, an enum input displays the titles of all an enum’s members within its dropdown. If we supply an argument to the input.enum() call, it will only allow users to select the members included in that list, e.g.:\n\nThe above argument specifies that users can only view and select the titles of the and fields from the enum. No other options are allowed:\n\nSome parameters of the indicator() and strategy() functions populate a script’s “Settings/Inputs” tab with additional inputs. These parameters are , , and . For example:\n\nThe design of your script’s inputs has an important impact on the usability of your scripts. Well-designed inputs are more intuitively usable and make for a better user experience:\n• Provide and values that will prevent your code from producing unexpected results, e.g., limit the minimal value of lengths to 1 or 2, depending on the type of MA you are using.\n• Provide a value that is congruent with the value you are capturing. Steps of 5 can be more useful on a 0-200 range, for example, or steps of 0.05 on a 0.0-1.0 scale.\n• Group related inputs on the same line using ; bull and bear colors for example, or the width and color of a line.\n• When you have many inputs, group them into meaningful sections using . Place the most important sections at the top.\n• Do the same for individual inputs within sections.\n\nIt can be advantageous to vertically align different arguments of multliple calls in your code. When you need to make global changes, this will allow you to use the Editor’s multi-cursor feature to operate on all the lines at once.\n\nBecause It is sometimes necessary to use Unicode spaces to In order to achieve optimal alignment in inputs. This is an example:\n\n//@version=6 indicator(\"Aligned inputs\", \"\", true) var GRP1 = \"Not aligned\" ma1SourceInput = input(close, \"MA source\", inline = \"11\", group = GRP1) ma1LengthInput = input(close, \"Length\", inline = \"11\", group = GRP1) long1SourceInput = input(close, \"Signal source\", inline = \"12\", group = GRP1) long1LengthInput = input(close, \"Length\", inline = \"12\", group = GRP1) var GRP2 = \"Aligned\" // The three spaces after \"MA source\" are Unicode EN spaces (U+2002). ma2SourceInput = input(close, \"MA source \", inline = \"21\", group = GRP2) ma2LengthInput = input(close, \"Length\", inline = \"21\", group = GRP2) long2SourceInput = input(close, \"Signal source\", inline = \"22\", group = GRP2) long2LengthInput = input(close, \"Length\", inline = \"22\", group = GRP2) plot(ta.vwma(close, 10))\n• We use the parameter to distinguish between the two sections of inputs. We use a constant to hold the name of the groups. This way, if we decide to change the name of the group, we only need to change it in one place.\n• The first sections inputs widgets do not align vertically. We are using , which places the input widgets immediately to the right of the label. Because the labels for the and inputs are of different lengths the labels are in different y positions.\n• To make up for the misalignment, we pad the argument in the line with three Unicode EN spaces (U+2002). Unicode spaces are necessary because ordinary spaces would be stripped from the label. You can achieve precise alignment by combining different quantities and types of Unicode spaces. See here for a list of Unicode spaces of different widths."
    },
    {
        "link": "https://reddit.com/r/TradingView/comments/1bca4ap/how_can_i_merge_three_different_indicators_with",
        "document": "Currently, I am using three different indicators for my trading strategy. One of them is moving average line, another is give me buy/ sell markers and the last one is modified type of rsi where a small circle pop-up at the over sold or over bought zone as described in that indicator. What I want now in to add these three in one in such a way that resultant indicator give me option to add alerts on coins when that coin fulfill all of the above conditions as from these three indicators. E.g. when a coin current price increases above moving average, modified rsi give buying circle mark in over sold zone and the third indicator give buy marker then alert get adtivated\n\nIs there any possible way out for it?"
    },
    {
        "link": "https://pineify.app/resources/blog/how-to-combine-two-indicators-in-tradingview-pine-script",
        "document": "TradingView's Pine Script is a powerful tool for creating custom trading indicators and strategies. Combining two indicators in Pine Script can enhance your analysis by providing more reliable signals and reducing false positives. This article will guide you through the process of combining indicators in Pine Script, explain the benefits of this approach, and offer practical examples to implement your own scripts.\n\nCombining technical indicators can significantly improve your trading strategy by:\n• Filtering False Signals: Using multiple indicators together can confirm or invalidate signals, reducing the risk of acting on false positives.\n• Providing a Broader Perspective: Different indicators analyze different aspects of market conditions, such as trend direction, momentum, or volatility.\n• Enhancing Timing: Aligning signals from multiple indicators can help pinpoint better entry and exit points.\n• Reducing Risk: A multi-indicator approach minimizes the chances of making impulsive decisions based on a single indicator.\n• Log in to your TradingView account.\n• Open any chart and navigate to the Pine Editor tab at the bottom of the screen.\n\nFor this example, we'll combine the Relative Strength Index (RSI) and Exponential Moving Average (EMA):\n\nYou can use logical conditions to combine these indicators. For instance:\n• A buy signal occurs when RSI is below 30 (oversold) and the price crosses above the EMA.\n• A sell signal occurs when RSI is above 70 (overbought) and the price crosses below the EMA.\n\nVisualize these signals on the chart:\n\nYou can set alerts for these signals:\n• Limit your combination to two or three indicators to avoid analysis paralysis.\n• Use historical data to validate your combined indicator's effectiveness before applying it in live trading.\n• Learn how each indicator works to ensure they complement each other rather than duplicate information.\n\nHere’s an example script that combines MACD and RSI:\n• Simplifies your chart by merging multiple tools into one indicator.\n• Avoid combining indicators that measure similar aspects of market behavior (e.g., RSI and Stochastic Oscillator).\n• Be cautious not to over-optimize settings during backtesting as this might not perform well in live markets.\n• Indicators work differently in trending vs. ranging markets; adapt accordingly.\n\nWhen integrating multiple indicators into your TradingView scripts, Pineify offers an innovative and user-friendly solution to streamline the process. This AI-powered Pine Script generator eliminates the need for complex coding, allowing traders to visually combine multiple indicators into a single script easily.\n\nWith Pineify, you can bypass TradingView's default limit of two indicators per chart, enabling the addition of unlimited indicators on one chart, even with a free TradingView plan. The platform also supports customizing inputs and plots, offering flexibility for different ticker symbols and timeframes. Pineify’s powerful condition editor makes it possible to merge various technical indicators, price data, and custom rules into precise trading strategies. Whether you’re backtesting strategies or enhancing your technical analysis, Pineify is a game-changer, saving time, money, and the frustration of manual coding. Try its free plan or explore the Pro and Lifetime options for advanced features.\n\nCombining two indicators in TradingView Pine Script is an effective way to refine your trading strategy. By leveraging complementary tools like RSI and EMA or MACD and DMI, you can filter out noise and make more informed decisions. Remember to backtest thoroughly and keep your approach simple yet effective."
    },
    {
        "link": "https://reddit.com/r/TradingView/comments/lyto4s/make_a_feature_on_pine_script_to_combine_multiple",
        "document": "To combine multiple custom indicators/strategies. This would allow people to make a proper algorithm that has different things build into it from their previously developed script. It would also allow you to have more that one type of thing to plot on the charts. This would also allow them to be backtested together and to see how the overall trading strategy performs."
    },
    {
        "link": "https://stackoverflow.com/questions/70737902/is-there-a-way-i-can-combine-two-indicators-in-trading-view-pine-script",
        "document": "You can copy and paste two indicators back to back. Just remember that, there can only be one or call in a script.\n\nThe problem with your example is the scaling. When you have the RSI on price chart, it messes up with the scaling."
    },
    {
        "link": "https://tradingview.com/pine-script-reference/v6",
        "document": ""
    }
]