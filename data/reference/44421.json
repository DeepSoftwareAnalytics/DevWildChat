[
    {
        "link": "https://php.net/manual/en/language.types.object.php",
        "document": "To create a new object, use the statement to instantiate a class: For a full discussion, see the Classes and Objects chapter. If an object is converted to an object, it is not modified. If a value of any other type is converted to an object, a new instance of the stdClass built-in class is created. If the value was , the new instance will be empty. An array converts to an object with properties named by keys and corresponding values. Note that in this case before PHP 7.2.0 numeric keys have been inaccessible unless iterated. For any other value, a member variable named will contain the value.\n\nhelpful at stranger dot com ¶ By far the easiest and correct way to instantiate an empty generic php object that you can then modify for whatever purpose you choose: \n\n \n\n \n\nI had the most difficult time finding this, hopefully it will help someone else! Anthony ¶ In PHP 7 there are a few ways to create an empty object:\n\n\n\n\n\n$obj1 and $obj3 are the same type, but $obj1 !== $obj3. Also, all three will json_encode() to a simple JS object {}:\n\n\n\n \n\nOutputs: [{},{},{}] twitter/matt2000 ¶ As of PHP 5.4, we can create stdClass objects with some properties and values using the more beautiful form:\n\n\n\n Ashley Dambra ¶ Here a new updated version of 'stdObject' class. It's very useful when extends to controller on MVC design pattern, user can create it's own class.\n\n\n\nHope it help you.\n\n\n\n developer dot amankr at gmail dot com (Aman Kuma) ¶ <!--Example shows how to convert array to stdClass Object and how to access its value for display -->\n\n qeremy [atta] gmail [dotta] com ¶ Do you remember some JavaScript implementations?\n\n\n\n// var timestamp = (new Date).getTime();\n\n\n\nNow it's possible with PHP 5.4.*;\n\n\n\n\n\nor\n\n\n\n mailto dot aurelian at gmail dot com ¶ You can create [recursive] objects with something like:\n\n Mithras ¶ In response to harmor: if an array contains another array as a value, you can recursively convert all arrays with:"
    },
    {
        "link": "https://php.net/manual/en/language.oop5.basic.php",
        "document": "Basic class definitions begin with the keyword , followed by a class name, followed by a pair of curly braces which enclose the definitions of the properties and methods belonging to the class. The class name can be any valid label, provided it is not a PHP reserved word. As of PHP 8.4.0, using a single underscore as a class name is deprecated. A valid class name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus: . A class may contain its own constants, variables (called \"properties\"), and functions (called \"methods\"). The pseudo-variable is available when a method is called from within an object context. is the value of the calling object. Warning Calling a non-static method statically throws an Error. Prior to PHP 8.0.0, this would generate a deprecation notice, and would be undefined. Example #2 Some examples of the pseudo-variable \"\\$this is not defined.\n\n\" Output of the above example in PHP 7: $this is defined (A) Deprecated: Non-static method A::foo() should not be called statically in %s on line 27 $this is not defined. Deprecated: Non-static method A::foo() should not be called statically in %s on line 20 $this is not defined. Deprecated: Non-static method B::bar() should not be called statically in %s on line 32 Deprecated: Non-static method A::foo() should not be called statically in %s on line 20 $this is not defined. Output of the above example in PHP 8: $this is defined (A) Fatal error: Uncaught Error: Non-static method A::foo() cannot be called statically in %s :27 Stack trace: #0 {main} thrown in %s on line 27 As of PHP 8.2.0, a class can be marked with the readonly modifier. Marking a class as readonly will add the readonly modifier to every declared property, and prevent the creation of dynamic properties. Moreover, it is impossible to add support for them by using the AllowDynamicProperties attribute. Attempting to do so will trigger a compile-time error. As neither untyped nor static properties can be marked with the modifier, readonly classes cannot declare them either: A readonly class can be extended if, and only if, the child class is also a readonly class. To create an instance of a class, the keyword must be used. An object will always be created unless the object has a constructor defined that throws an exception on error. Classes should be defined before instantiation (and in some cases this is a requirement). If a variable containing a string with the name of a class is used with , a new instance of that class will be created. If the class is in a namespace, its fully qualified name must be used when doing this. If there are no arguments to be passed to the class's constructor, parentheses after the class name may be omitted. // This can also be done with a variable:\n\n As of PHP 8.0.0, using with arbitrary expressions is supported. This allows more complex instantiation if the expression produces a string. The expressions must be wrapped in parentheses. Example #4 Creating an instance using an arbitrary expression In the given example we show multiple examples of valid arbitrary expressions that produce a class name. This shows a call to a function, string concatenation, and the constant. Output of the above example in PHP 8: In the class context, it is possible to create a new object by and . When assigning an already created instance of a class to a new variable, the new variable will access the same instance as the object that was assigned. This behaviour is the same when passing instances to a function. A copy of an already created object can be made by cloning it. '$assigned will have this value' The above example will output: NULL NULL object(SimpleClass)#1 (1) { [\"var\"]=> string(30) \"$assigned will have this value\" } It's possible to create instances of an object in a couple of ways: // Through the variable containing an object\n\n The above example will output: It is possible to access a member of a newly created object in a single expression: // surrounding parentheses are optional as of PHP 8.4.0\n\n The above example will output something similar to: Note: Prior to PHP 7.1, the arguments are not evaluated if there is no constructor function defined. Class properties and methods live in separate \"namespaces\", so it is possible to have a property and a method with the same name. Referring to both a property and a method has the same notation, and whether a property will be accessed or a method will be called, solely depends on the context, i.e. whether the usage is a variable access or a function call. The above example will output: That means that calling an anonymous function which has been assigned to a property is not directly possible. Instead the property has to be assigned to a variable first, for instance. It is possible to call such a property directly by enclosing it in parentheses. Example #9 Calling an anonymous function stored in a property The above example will output: A class can inherit the constants, methods, and properties of another class by using the keyword in the class declaration. It is not possible to extend multiple classes; a class can only inherit from one base class. The inherited constants, methods, and properties can be overridden by redeclaring them with the same name defined in the parent class. However, if the parent class has defined a method or constant as final, they may not be overridden. It is possible to access the overridden methods or static properties by referencing them with parent::. Note: As of PHP 8.1.0, constants may be declared as final. The above example will output: When overriding a method, its signature must be compatible with the parent method. Otherwise, a fatal error is emitted, or, prior to PHP 8.0.0, an level error is generated. A signature is compatible if it respects the variance rules, makes a mandatory parameter optional, adds only optional new parameters and doesn't restrict but only relaxes the visibility. This is known as the Liskov Substitution Principle, or LSP for short. The constructor, and methods are exempt from these signature compatibility rules, and thus won't emit a fatal error in case of a signature mismatch. The above example will output: The following examples demonstrate that a child method which removes a parameter, or makes an optional parameter mandatory, is not compatible with the parent method. Output of the above example in PHP 8 is similar to: Fatal error: Declaration of Extend::foo() must be compatible with Base::foo(int $a = 5) in /in/evtlq on line 13 Example #13 Fatal error when a child method makes an optional parameter mandatory Output of the above example in PHP 8 is similar to: Fatal error: Declaration of Extend::foo(int $a) must be compatible with Base::foo(int $a = 5) in /in/qJXVC on line 13 Warning Renaming a method's parameter in a child class is not a signature incompatibility. However, this is discouraged as it will result in a runtime Error if named arguments are used. Example #14 Error when using named arguments and parameters were renamed in a child class The above example will output something similar to: Fatal error: Uncaught Error: Unknown named parameter $foo in /in/XaaeN:14 Stack trace: #0 {main} thrown in /in/XaaeN on line 14 The keyword is also used for class name resolution. To obtain the fully qualified name of a class use . This is particularly useful with namespaced classes. The above example will output: The class name resolution using is a compile time transformation. That means at the time the class name string is created no autoloading has happened yet. As a consequence, class names are expanded even if the class does not exist. No error is issued in that case. The above example will output: As of PHP 8.0.0, may also be used on objects. This resolution happens at runtime, not compile time. Its effect is the same as calling get_class() on the object. The above example will output: As of PHP 8.0.0, properties and methods may also be accessed with the \"nullsafe\" operator instead: . The nullsafe operator works the same as property or method access as above, except that if the object being dereferenced is then will be returned rather than an exception thrown. If the dereference is part of a chain, the rest of the chain is skipped. The effect is similar to wrapping each access in an is_null() check first, but more compact. // As of PHP 8.0.0, this line:\n\n // Is equivalent to the following code block:\n\n The nullsafe operator is best used when null is considered a valid and expected possible value for a property or method return. For indicating an error, a thrown exception is preferable.\n\naaron at thatone dot com ¶ I was confused at first about object assignment, because it's not quite the same as normal assignment or assignment by reference. But I think I've figured out what's going on.\n\n\n\nFirst, think of variables in PHP as data slots. Each one is a name that points to a data slot that can hold a value that is one of the basic data types: a number, a string, a boolean, etc. When you create a reference, you are making a second name that points at the same data slot. When you assign one variable to another, you are copying the contents of one data slot to another data slot.\n\n\n\nNow, the trick is that object instances are not like the basic data types. They cannot be held in the data slots directly. Instead, an object's \"handle\" goes in the data slot. This is an identifier that points at one particular instance of an obect. So, the object handle, although not directly visible to the programmer, is one of the basic datatypes. \n\n\n\nWhat makes this tricky is that when you take a variable which holds an object handle, and you assign it to another variable, that other variable gets a copy of the same object handle. This means that both variables can change the state of the same object instance. But they are not references, so if one of the variables is assigned a new value, it does not affect the other variable.\n\n\n\n\n\n$assignment has a different data slot from $objectVar, but its data slot holds a handle to the same object. This makes it behave in some ways like a reference. If you use the variable $objectVar to change the state of the Object instance, those changes also show up under $assignment, because it is pointing at that same Object instance.\n\n\n\n\n\nBut it is not exactly the same as a reference. If you null out $objectVar, you replace the handle in its data slot with NULL. This means that $reference, which points at the same data slot, will also be NULL. But $assignment, which is a different data slot, will still hold its copy of the handle to the Object instance, so it will not be NULL.\n\n\n\n kStarbe at gmail point com ¶ You start using :: in second example although the static concept has not been explained. This is not easy to discover when you are starting from the basics. Doug ¶ What is the difference between $this and self ?\n\n\n\nInside a class definition, $this refers to the current object, while self refers to the current class.\n\n\n\nIt is necessary to refer to a class element using self ,\n\nand refer to an object element using $this .\n\nNote also how an object variable must be preceded by a keyword in its definition.\n\n\n\nThe following example illustrates a few cases:\n\n\n\n Hayley Watson ¶ Class names are case-insensitive:\n\n\n\nAny casing can be used to refer to the class\n\n\n\nBut the case used when the class was defined is preserved as \"canonical\":\n\n\n\nAnd, as always, \"case-insensitivity\" only applies to ASCII.\n\n pawel dot zimnowodzki at gmail dot com ¶ Although there is no null-safe operator for not existed array keys I found workaround for it: ($array['not_existed_key'] ?? null)?->methodName() wbcarts at juno dot com ¶ CLASSES and OBJECTS that represent the \"Ideal World\"\n\n\n\nWouldn't it be great to get the lawn mowed by saying $son->mowLawn()? Assuming the function mowLawn() is defined, and you have a son that doesn't throw errors, the lawn will be mowed. \n\n\n\nIn the following example; let objects of type Line3D measure their own length in 3-dimensional space. Why should I or PHP have to provide another method from outside this class to calculate length, when the class itself holds all the neccessary data and has the education to make the calculation for itself?\n\n\n\n\n\n <-- The results look like this -->\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=1, y=1, z=1), length=1.73205080757]\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=100, y=100, z=0), length=141.421356237]\n\n\n\nLine3D[start=Point3D(x=0, y=0, z=0), end=Point3D(x=100, y=100, z=100), length=173.205080757]\n\n\n\nMy absolute favorite thing about OOP is that \"good\" objects keep themselves in check. I mean really, it's the exact same thing in reality... like, if you hire a plumber to fix your kitchen sink, wouldn't you expect him to figure out the best plan of attack? Wouldn't he dislike the fact that you want to control the whole job? Wouldn't you expect him to not give you additional problems? And for god's sake, it is too much to ask that he cleans up before he leaves?\n\n\n\nI say, design your classes well, so they can do their jobs uninterrupted... who like bad news? And, if your classes and objects are well defined, educated, and have all the necessary data to work on (like the examples above do), you won't have to micro-manage the whole program from outside of the class. In other words... create an object, and LET IT RIP! johannes dot kingma at gmail dot com ¶ BEWARE! \n\n\n\nLike Hayley Watson pointed out class names are not case sensitive. \n\n\n\n As well as\n\n \n\n\n\nIs perfectly fine and will return 'BAR'.\n\n\n\nThis has implications on autoloading classes though. The standard spl_autoload function will strtolower the class name to cope with case in-sensitiveness and thus the class BAR can only be found if the file name is bar.php (or another variety if an extension was registered with spl_autoload_extensions(); ) not BAR.php for a case sensitive file and operating system like linux. Windows file system is case sensitive but the OS is not and there for autoloading BAR.php will work. moty66 at gmail dot com ¶ I hope that this will help to understand how to work with static variables inside a class\n\n\n\n \n\nRegards\n\nMotaz Abuthiab Notes on stdClass ¶ stdClass is the default PHP object. stdClass has no properties, methods or parent. It does not support magic methods, and implements no interfaces.\n\n\n\nWhen you cast a scalar or array as Object, you get an instance of stdClass. You can use stdClass whenever you need a generic object instance.\n\n\n\nstdClass is NOT a base class! PHP classes do not automatically inherit from any class. All classes are standalone, unless they explicitly extend another class. PHP differs from many object-oriented languages in this respect.\n\n\n\nYou cannot define a class named 'stdClass' in your code. That name is already used by the system. You can define a class named 'Object'.\n\n\n\nYou could define a class that extends stdClass, but you would get no benefit, as stdClass does nothing.\n\n\n\n(tested on PHP 5.2.8) Jeffrey ¶ A PHP Class can be used for several things, but at the most basic level, you'll use classes to \"organize and deal with like-minded data\". Here's what I mean by \"organizing like-minded data\". First, start with unorganized data.\n\n\n\n\n\nNow to organize the data into PHP classes:\n\n\n\n\n\nNow here's what I mean by \"dealing\" with the data. Note: The data is already organized, so that in itself makes writing new functions extremely easy.\n\n\n\n\n\nImagination that each function you write only calls the bits of data in that class. Some functions may access all the data, while other functions may only access one piece of data. If each function revolves around the data inside, then you have created a good class. Anonymous ¶ At first I was also confused by the assignment vs referencing but here's how I was finally able to get my head around it. This is another example which is somewhat similar to one of the comments but can be helpful to those who did not understand the first example. Imagine object instances as rooms where you can store and manipulate your properties and functions. The variable that contains the object simply holds 'a key' to this room and thus access to the object. When you assign this variable to another new variable, what you are doing is you're making a copy of the key and giving it to this new variable. That means these two variable now have access to the same 'room' (object) and can thus get in and manipulate the values. However, when you create a reference, what you doing is you're making the variables SHARE the same key. They both have access to the room. If one of the variable is given a new key, then the key that they are sharing is replaced and they now share a new different key. This does not affect the other variable with a copy of the old key...that variable still has access to the first room"
    },
    {
        "link": "https://stackoverflow.com/questions/16797283/php-best-way-to-call-an-object-method-from-another-object",
        "document": "I am searching for the best way to call a class method from another class, without having to use Global to fetch the class instance, cus as i understand now that \"Global is evil\" !\n\nHere is some code to explain it more:\n\nNow i wanna call the Assets/call method from with in here ..\n\nIs using Global in such scenario is THAT bad ? If so, what other way is considered to be the best ?\n\nPS: I need to work with only one instance of the class; means that i don't want to create a new instance inside of the second class."
    },
    {
        "link": "https://w3schools.com/php/php_oop_classes_objects.asp",
        "document": "A class is a template for objects, and an object is an instance of class.\n\nLet's assume we have a class named Fruit. A Fruit can have properties like name, color, weight, etc. We can define variables like $name, $color, and $weight to hold the values of these properties.\n\nWhen the individual objects (apple, banana, etc.) are created, they inherit all the properties and behaviors from the class, but each object will have different values for the properties.\n\nA class is defined by using the keyword, followed by the name of the class and a pair of curly braces ({}). All its properties and methods go inside the braces:\n\nBelow we declare a class named Fruit consisting of two properties ($name and $color) and two methods set_name() and get_name() for setting and getting the $name property:\n\nClasses are nothing without objects! We can create multiple objects from a class. Each object has all the properties and methods defined in the class, but they will have different property values.\n\nObjects of a class are created using the keyword.\n\nIn the example below, $apple and $banana are instances of the class Fruit:\n\nIn the example below, we add two more methods to class Fruit, for setting and getting the $color property:\n\nThe $this keyword refers to the current object, and is only available inside methods.\n\nLook at the following example:\n\nSo, where can we change the value of the $name property? There are two ways:\n\n1. Inside the class (by adding a set_name() method and use $this):\n\n2. Outside the class (by directly changing the property value):\n\nYou can use the keyword to check if an object belongs to a specific class:"
    },
    {
        "link": "https://php.net/manual/en/language.oop5.references.php",
        "document": "Anonymous ¶ There seems to be some confusion here. The distinction between pointers and references is not particularly helpful.\n\nThe behavior in some of the \"comprehensive\" examples already posted can be explained in simpler unifying terms. Hayley's code, for example, is doing EXACTLY what you should expect it should. (Using >= 5.3)\n\n\n\nFirst principle:\n\nA pointer stores a memory address to access an object. Any time an object is assigned, a pointer is generated. (I haven't delved TOO deeply into the Zend engine yet, but as far as I can see, this applies)\n\n\n\n2nd principle, and source of the most confusion:\n\nPassing a variable to a function is done by default as a value pass, ie, you are working with a copy. \"But objects are passed by reference!\" A common misconception both here and in the Java world. I never said a copy OF WHAT. The default passing is done by value. Always. WHAT is being copied and passed, however, is the pointer. When using the \"->\", you will of course be accessing the same internals as the original variable in the caller function. Just using \"=\" will only play with copies.\n\n\n\n3rd principle:\n\n\"&\" automatically and permanently sets another variable name/pointer to the same memory address as something else until you decouple them. It is correct to use the term \"alias\" here. Think of it as joining two pointers at the hip until forcibly separated with \"unset()\". This functionality exists both in the same scope and when an argument is passed to a function. Often the passed argument is called a \"reference,\" due to certain distinctions between \"passing by value\" and \"passing by reference\" that were clearer in C and C++.\n\n\n\nJust remember: pointers to objects, not objects themselves, are passed to functions. These pointers are COPIES of the original unless you use \"&\" in your parameter list to actually pass the originals. Only when you dig into the internals of an object will the originals change.\n\n\n\nExample:\n\n\n\n\n\nAaron Bond ¶ I've bumped into a behavior that helped clarify the difference between objects and identifiers for me.\n\n\n\nWhen we hand off an object variable, we get an identifier to that object's value. This means that if I were to mutate the object from a passed variable, ALL variables originating from that instance of the object will change. \n\n\n\nHOWEVER, if I set that object variable to new instance, it replaces the identifier itself with a new identifier and leaves the old instance in tact.\n\n\n\nTake the following example:\n\n\n\n\n\nIf object variables were always references, we'd expect the following output:\n\n1\n\n42\n\n1\n\n\n\nHowever, we get:\n\n1\n\n42\n\n42\n\n\n\nThe reason for this is simple. In the bar function of the B class, we replace the identifier you passed in, which identified the same instance of the A class as your $f variable, with a brand new A class identifier. Creating a new instance of A doesn't mutate $f because $f wasn't passed as a reference.\n\n\n\nTo get the reference behavior, one would have to enter the following for class B:\n\n\n\n\n\nThe foo function doesn't require a reference, because it is MUTATING an object instance that $bar identifies. But bar will be REPLACING the object instance. If only an identifier is passed, the variable identifier will be overwritten but the object instance will be left in place.\n\nwbcarts at juno dot com ¶ A BIT DILUTED... but it's alright!\n\n\n\nIn the PHP example above, the function foo($obj), will actually create a $foo property to \"any object\" passed to it - which brings some confusion to me:\n\n $obj = new stdClass();\n\n foo($obj); // tags on a $foo property to the object\n\n // why is this method here?\n\nFurthermore, in OOP, it is not a good idea for \"global functions\" to operate on an object's properties... and it is not a good idea for your class objects to let them. To illustrate the point, the example should be:\n\n\n\n - - -\n\n 2\n\n A [foo=2]\n\n A [foo=1]\n\n - - -\n\nBecause the global function foo() has been deleted, class A is more defined, robust and will handle all foo operations... and only for objects of type A. I can now take it for granted and see clearly that your are talking about \"A\" objects and their references. But it still reminds me too much of cloning and object comparisons, which to me borders on machine-like programming and not object-oriented programming, which is a totally different way to think.\n\nIvan Bertona ¶ A point that in my opinion is not stressed enough in the manual page is that in PHP5, passing an object as an argument of a function call with no use of the & operator means passing BY VALUE an unique identifier for that object (intended as instance of a class), which will be stored in another variable that has function scope.\n\n\n\nThis behaviour is the same used in Java, where indeed there is no notion of passing arguments by reference. On the other hand, in PHP you can pass a value by reference (in PHP we refer to references as \"aliases\"), and this poses a threat if you are not aware of what you are really doing. Please consider these two classes:\n\n\n\n\n\nIn the first test case we make two objects out of the classes A and B, then swap the variables using a temp one and the normal assignment operator (=).\n\n\n\n\n\nAs expected the script will output:\n\n\n\n$a: Class B\n\n$b: Class A\n\n\n\nNow consider the following snippet. It is similar to the former but the assignment $a = &$b makes $a an ALIAS of $b.\n\n\n\n\n\nThis script will output:\n\n\n\n$a: Class A\n\n$b: Class A\n\n\n\nThat is, modifying $b reflects the same assignment on $a... The two variables end pointing to the same object, and the other one is lost. To sum up is a good practice NOT using aliasing when handling PHP5 objects, unless your are really really sure of what you are doing.\n\nHayley Watson ¶ Using &$this can result in some weird and counter-intuitive behaviour - it starts lying to you.\n\n\n\n \"\\$bar is an alias of \\$this, a Foo.\n\n\" \"Are they the same object? \" '$this says its prop value is ' \"\\$bar has been made into a new Bar.\n\n\" \"Are they the same object? \" '$this says its prop value is ' In the above $this claims to be a Bar (in fact it claims to be the very same object that $bar is), while still having all the properties and methods of a Foo.\n\n\n\nFortunately it doesn't persist beyond the method where you committed the faux pas.\n\n\n\nJoe F ¶ I am planning to serialize and unserialize objects as a means of storage, and my application can conveniently group large numbers of objects inside of a single object to serialize. However, this presented some questions that I needed to answer:\n\n\n\nLet's say the parent object I plan to serialize is \"A\" and the objects I store in it will be A(a-z). If I pass A(b) to A(c), this happens by reference. So if A(c) takes actions that effect the values of A(b), this will also update the original A(b) stored in A. Great!\n\n\n\nHowever, what happens when I serialize A, where A(c) has a reference to A(b), and then I unserialize? Will A(c) have a new unique copy of A(b), or will it still reference the A(b) stored in A?\n\n\n\nThe answer is, PHP 5.5 and PHP 7 both track whether something is a reference to an object it's already \"recreated\" during the unserialize process, see this example:\n\n\n\n\n\nPer the last line, A(b)'s \"copy\" of A(c) is still a reference to the original A(b) as stored in A, even after unserializing."
    },
    {
        "link": "https://php.net/manual/en/language.oop5.static.php",
        "document": "Anonymous ¶ You misunderstand the meaning of inheritance : there is no duplication of members when you inherit from a base class. Members are shared through inheritance, and can be accessed by derived classes according to visibility (public, protected, private).\n\n\n\nThe difference between static and non static members is only that a non static member is tied to an instance of a class although a static member is tied to the class, and not to a particular instance.\n\nThat is, a static member is shared by all instances of a class although a non static member exists for each instance of class.\n\n\n\nThus, in your example, the static property has the correct value, according to principles of object oriented conception.\n\nclass Base\n\n{\n\n public $a;\n\n public static $b;\n\n}\n\n\n\nclass Derived extends Base\n\n{\n\n public function __construct()\n\n {\n\n $this->a = 0;\n\n parent::$b = 0;\n\n }\n\n public function f()\n\n {\n\n $this->a++;\n\n parent::$b++;\n\n }\n\n}\n\n\n\n$i1 = new Derived;\n\n$i2 = new Derived;\n\n\n\n$i1->f();\n\necho $i1->a, ' ', Derived::$b, \"\n\n\";\n\n$i2->f();\n\necho $i2->a, ' ', Derived::$b, \"\n\n\";\n\n\n\noutputs\n\n1 1\n\n1 2\n\nsideshowAnthony at googlemail dot com ¶ The static keyword can still be used (in a non-oop way) inside a function. So if you need a value stored with your class, but it is very function specific, you can use this:\n\n\n\nclass aclass {\n\n public static function b(){\n\n static $d=12; // Set to 12 on first function call only\n\n $d+=12;\n\n return \"$d\n\n\";\n\n }\n\n}\n\n\n\necho aclass::b(); //24\n\necho aclass::b(); //36\n\necho aclass::b(); //48\n\necho aclass::$d; //fatal error\n\nASchmidt at Anamera dot net ¶ It is important to understand the behavior of static properties in the context of class inheritance:\n\n\n\n- Static properties defined in both parent and child classes will hold DISTINCT values for each class. Proper use of self:: vs. static:: are crucial inside of child methods to reference the intended static property.\n\n\n\n- Static properties defined ONLY in the parent class will share a COMMON value.\n\n\n\n\n\nwill output:\n\nParent: parent_only=fromchild, both_distinct=fromparent\n\nChild: parent_only=fromchild, both_distinct=fromchild, child_only=fromchild\n\nwebmaster at removethis dot weird-webdesign dot de ¶ On PHP 5.2.x or previous you might run into problems initializing static variables in subclasses due to the lack of late static binding:\n\n\n\n \n\nThis will output:\n\nA::$a = lala; B::$a = \n\n\n\nIf the init() method looks the same for (almost) all subclasses there should be no need to implement init() in every subclass and by that producing redundant code.\n\n\n\nSolution 1:\n\nTurn everything into non-static. BUT: This would produce redundant data on every object of the class.\n\n\n\nSolution 2:\n\nTurn static $a on class A into an array, use classnames of subclasses as indeces. By doing so you also don't have to redefine $a for the subclasses and the superclass' $a can be private.\n\n\n\nShort example on a DataRecord class without error checking:\n\n\n\n \n\nI hope this helps some people who need to operate on PHP 5.2.x servers for some reason. Late static binding, of course, makes this workaround obsolete.\n\nssj dot narutovash at gmail dot com ¶ It's come to my attention that you cannot use a static member in an HEREDOC string. The following code\n\n\n\nclass A\n\n{\n\n public static $BLAH = \"user\";\n\n\n\n function __construct()\n\n {\n\n echo <<<EOD\n\n<h1>Hello {self::$BLAH}</h1>\n\nEOD;\n\n }\n\n}\n\n\n\n$blah = new A();\n\n\n\nproduces this in the source code:\n\n\n\n<h1>Hello {self::}</h1>\n\n\n\nSolution:\n\n\n\nbefore using a static member, store it in a local variable, like so:\n\n\n\nclass B\n\n{\n\n public static $BLAH = \"user\";\n\n\n\n function __construct()\n\n {\n\n $blah = self::$BLAH;\n\n echo <<<EOD\n\n<h1>Hello {$blah}</h1>\n\nEOD;\n\n }\n\n}\n\n\n\nand the output's source code will be:\n\n\n\n<h1>Hello user</h1>\n\nzerocool at gameinsde dot ru ¶ Hi, here's my simple Singleton example, i think it can be useful for someone. You can use this pattern to connect to the database for example.\n\n\n\n\n\nmichalf at ncac dot torun dot pl ¶ Inheritance with the static elements is a nightmare in php. Consider the following code:\n\n\n\n\n\nWhat would you expect as an output? \"foo\"? wrong. It is \"bar\"!!! Static variables are not inherited, they point to the BaseClass::$property.\n\n\n\nAt this point I think it is a big pity inheritance does not work in case of static variables/methods. Keep this in mind and save your time when debugging.\n\n\n\nbest regards - michal"
    },
    {
        "link": "https://stackoverflow.com/questions/33705976/when-should-i-use-static-methods",
        "document": "It is an interesting subject. I'm gonna give you a design oriented answer.\n\nIn my opinion, you should never use a static class/function in a good OOP architecture.\n\nWhen you use static, this is to call a function without an instance of the class. The main reason is often to represent a service class which should not be instantiated many times.\n\nI will give you 3 solutions (from the worst to the best) to achieve that:\n\nA static class (with only static functions) prevent you from using many OOP features like inheritance, interface implementation. If you really think of what is a static function, it is a function namespaced by the name of its class. You already have namespaces in PHP, so why add another layer?\n\nAnother big disadvantage is that you cannot define clear dependencies with your static class and the classes using it which is a bad thing for maintenability and scalability of your application.\n\nA singleton is a way to force a class to have only one instance:\n\nIt is a better way because you can use inheritance, interfaces and your method will be called on an instanciated object. This means you can define contracts and use low coupling with the classes using it. However some people consider the singleton as an anti pattern especially because if you want to have 2 or more instances of your class with different input properties (like the classic example of the connection to 2 different databases) you cannot without a big refactoring of all your code using the singleton.\n\nA service is an instance of a standard class. It is a way to rationalize your code. This kind of architecture is called SOA (service oriented architecture). I give you an example:\n\nIf you want to add a method to sell a product in a store to a consumer and you have classes , and . Where should you instantiate this method? I can guarantee that if you think it is more logical in one of these three class today it could be anything else tomorrow. This leads to lots of duplications and a difficulty to find where is the code you are looking for. Instead, you can use a service class like a for example which will know how to manipulate your data classes.\n\nIt is a good idea to use a framework helping you to inject them into each others (dependency injection) in order to use them at their full potential. In the PHP community, you have a nice example of implementation of this in Symfony for instance.\n• None If you do not have a framework, singletons are certainly an option even if I personally prefer a simple file where I make manual dependency injection.\n• None If you have a framework, use its dependency injection feature to do that kind of thing.\n• None You should not use static method (in OOP). If you need a static method in one of your class, this means you can create a new singleton/service containing this method and inject it to the instance of classes needing it."
    },
    {
        "link": "https://stackoverflow.com/questions/73255219/is-any-change-in-static-class-scope-at-php-8-1",
        "document": "The change is not to static properties themselves, but to the function. The documented purpose of that function has always been to return the default values of all properties, so returning the current value for static properties in previous versions was technically a bug.\n\nTo get the current values of static properties, you can instead use the method ReflectionClass::getStaticProperties, e.g.\n\nRunning this across lots of PHP versions shows that for PHP versions back to 5.5 (and probably beyond, if the syntax of the example is tweaked) the output is (incorrectly):\n\nFor PHP 8.1, it is (correctly):\n\nAlternatively, you could use to get the names of the variables, and then \"variable variable\" syntax to get their current value.\n\nNote that returns both static and instance variables, so you need to first check that the static property exists before trying to fetch its value.\n\nThe above could easily be extended to emulate the old buggy (which showed defaults for instance properties, but current values for static properties); or to show the current value of instance properties given a particular instance."
    },
    {
        "link": "https://reddit.com/r/PHP/comments/9gcm57/are_static_methods_evil",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://infoq.com/articles/php8-functions-methods",
        "document": "PHP 8.0 adds support for several functions- and methods-related features, some of which are an improvement of existing features, while others are completely new features. The enhanced callable syntax in PHP 8.1 can be used to create anonymous functions from a callable. Named function arguments may be used along with positional arguments with the added benefit that named arguments are not ordered and can convey meaning by their name. Fibers are interruptible functions that add support for multitasking.\n\nObject inheritance is a programming paradigm that is used by most object-oriented languages including PHP. It makes it possible to override public and protected methods, and class properties and constants defined in a class from any class that extends it. In PHP, public methods cannot be reimplemented with a more restrictive access such as by making a method . To demonstrate this, consider a class B that extends class A and reimplements a public method from A.\n\nWhen run, the script generates an error message:\n\nOn the contrary, private methods defined in a class are not inherited and can be reimplemented in a class that extends it. As an example, class B extends class A in the following script and reimplements a private method from A.\n\nPrior to PHP 8.0, two restrictions applied to private method redeclaration in an extending class: the and modifiers were not allowed to be changed. If a method was declared , an extending class was not allowed to redeclare the method. If a private method was declared static, it was to be kept static in an extending class. And, if a private method did not have the static modifier, an extending class was not allowed to add a static modifier. Both restrictions have been lifted in PHP 8. The following script runs ok in PHP 8.\n\nThe only private method restriction in PHP 8 is to enforce constructors, which are sometimes used to disable the constructor when using static factory methods as a substitute.\n\nA variadic argument may replace any number of function arguments\n\nIn PHP 8, a single variadic argument may replace any number of function arguments. Consider the following script in which class B extends class A and replaces the three-argument function with a single variadic argument.\n\nThe function in class B may be called using multiple arguments.\n\nThe output is as follows:\n\nA callable is a PHP expression that can be called, such as an instance method, a static method, or an invocable object. A callable can be used to create a short-form expression for a method call, for example. In PHP 8.1, there is new callable syntax available:\n\nThe AVariableCallableExpression represents a variable callable expression. The ellipses … is included in the syntax.\n\nWhy a new callable syntax? Let’s recall what the traditional callable syntax looks like with some examples:\n\nThis has two issues:\n• The scope is not maintained at the point at which the callable is created.\n\nTo demonstrate this, consider the following script for sorting an array in which the method returns a callable for the method with .\n\nUsing instead of would fix the scope issue, but using the method makes the call verbose. The new callable syntax fixes both the scope and syntax verbosity issues. With the new callable syntax, the function becomes:\n\nThe array gets sorted with output:\n\nThe new syntax can be combined with the traditional syntax involving strings and arrays to fix the scope issue. The scope at which the callable is created is kept unchanged.\n\nThe new callable syntax may be used with static methods as well, as demonstrated by the following script that includes a static function.\n\nThe output is the same as before:\n\nThe following are equivalent ways for calling a method:\n\nThe following are equivalent ways for calling a static method:\n\nThe new callable syntax may be used even if a function declares parameters.\n\nA callable must be called with its arguments if the method declares any.\n\nSimplified Syntax can be used with any PHP Callable expression\n\nThe simplified callable syntax may be used with any PHP callable expression. The callable syntax is not supported with the new operator for object creation because the callable syntax AVariableCallableExpression(...) does not have provision to specify constructor args, which could be required. The following is an example that is not supported:\n\nFatal error: Cannot create Closure for new expression\n\nThe following script demonstrates the full range of callable expressions that are supported.\n\nAnother new feature in PHP 8.0 is support for adding a trailing comma at the end of the list of parameters to a function to improve readability. Any trailing comma is ignored. A trailing comma may not always be useful, but could be useful if the parameters list is long or if parameter names are long, making it suitable to list them vertically. A trailing comma is also supported in closure use lists.\n\nPHP 8.0 deprecates declaring optional arguments before required arguments. Optional arguments declared before required arguments are implicitly required.\n\nThe following script demonstrates the required parameters implicit order in addition to the use of trailing comma.\n\nThe output is as follows:\n\nNullable parameters are not considered optional parameters and may be declared before required parameters using the form or the explicit nullable type, as in the following script:\n\nPHP 8.0 adds support for named function parameters and arguments besides already supported positional parameters and arguments. Named arguments are passed in a function call with the following syntax:\n\nSome of the benefits of named arguments are the following:\n• Function parameters may be given a meaningful name to make them self-documenting\n• Arguments are order-independent when passed by name\n\nIn the following script, the function declares named parameters. The function may be passed argument values with or without argument names. When positional arguments are passed, the function parameters declaration order is used. When named arguments are passed, any arbitrary order may be used.\n\nNamed arguments and positional arguments may be used in the same function call. The mixed arguments call is used with the same example function .\n\nNotice that named arguments are used only after positional arguments. The following script reverses the order and uses positional arguments after named arguments:\n\nDeclaring optional arguments before required arguments is deprecated even with named arguments, as demonstrated by the following script:\n\nWhen using optional named parameters after required named parameters, named arguments may be used to skip over one or more optional parameters in a function call, as in the script:\n\nYou may call a function with only a subset of its optional arguments, regardless of their order.\n\nOutput is as follows:\n\nEven when calling a function with a subset of its optional arguments, positional arguments cannot be used after named arguments, as demonstrated by script:\n\nThe following error message is produced:\n\nFatal error: Cannot use positional argument after named argument\n\nPHP 8.1 improves on the named arguments feature by supporting named arguments after unpacking the arguments, as in the script:\n\nThe output is as follows:\n\nHowever, a named argument must not overwrite an earlier argument as demonstrated by script:\n\nOutput is as follows:\n\nPrior to PHP 8.0, if you called a non-static method in a static context, or statically, you only got a deprecation message. With 8.0 you now get an error message. Also, is undefined in a static context. To demonstrate this, consider the following script in which a non-static method is called with static syntax .\n\nIf you run the script, you would get an error message:\n\nPHP 8.1 adds support for multi-tasking with Fibers. A Fiber is an interruptible function with a stack of its own. A Fiber may be suspended from anywhere in the call stack, and resumed later. The new Fiber class is a final class that supports the following public methods:\n\nConstructor to create a new Fiber instance. The parameter is the callable to invoke when starting the fiber. Arguments given to will be provided as arguments to the given callable. The callable need not call at all, or if called need not call directly. The call to may be deeply nested down the call stack. Starts the fiber. The method returns when the fiber suspends or terminates. A variadic list of arguments is provided to the callable used when constructing the fiber. A mixed value is returned from the first suspension point or if the fiber returns. A is thrown if the fiber has already been started when this method is called. Resumes the fiber, returning the given mixed value from Fiber::suspend(). Returns when the fiber suspends or terminates. The returned mixed value is actually returned from the next suspension point or NULL if the fiber returns. Throws a FiberError if the fiber has not started, is running, or has terminated. Throws the given exception into the fiber from . Returns when the fiber suspends or terminates. The param is the Throwable $exception. The returned mixed Value is actually returned from the next suspension point or if the fiber returns. Throws a if the fiber has not started, is running, or has terminated. Gets the mixed return value of the fiber callback. is returned if the fiber does not have a return statement. Throws a if the fiber has not terminated or the fiber threw an exception. Returns bool if the fiber has been started. Returns bool if the fiber has been suspended. Returns bool if the fiber is currently running. Returns bool if the fiber has been terminated. Suspends the fiber. Returns execution to the call to , , or . The fiber may be resumed with or . Cannot be called from the main thread outside the fiber. The param is a to return from or . The return mixed value is provided to . Throws FiberError if not within a fiber (i.e., if called from the main thread). Returns the currently executing fiber instance or if in main.\n\nA Fiber may be started only once, but may be suspended and resumed multiple times. The following script demonstrates multitasking by using a Fiber to perform different types of sorts on an array. The Fiber is suspended after each sort, and resumed later to perform a different type of sort.\n\nThe output is as follows:\n\nIf the Fiber is not resumed after first suspension, only one type of sort is made, which could be implemented by commenting out the two calls to resume().\n\nOutput is the result from the first sort:\n\nPHP 8.0 introduces a new interface called e that provides only one method . The method if provided in a class would implicitly implement the interface. Consider the class A that provides a method.\n\nThe script returns 1 from the type check for .\n\nThe reverse is however not true. If a class implements the Stringable interface, it must explicitly provide the __toString() method as the method is not added automatically, as in:\n\nPHP 8 introduces a number of new functions belonging to its standard library.\n\nThe function returns a to indicate if the string given as the first argument contains the string given as the second argument. The following script returns :\n\nAnd the following script returns 1, or true:\n\nThe str_starts_with function returns a bool to indicate if the string given as the first argument starts with the string given as the second argument. The following script returns false.\n\nAnd the following script returns 1, or true.\n\nThe function returns a to indicate if the string given as the first argument ends with the string given as the second argument. The following script returns .\n\nAnd the following script returns , or .\n\nThe function divides two numbers and returns a value, as demonstrated by the script:\n\nThe function, aliased to on Windows, synchronizes data to a stream on a file. To demonstrate its use, create an empty file directory that contains PHP scripts to run. Run the script:\n\nSubsequently, open the test.txt file to find the text:\n\nThe function returns a bool to indicate whether a given array is a list. The array must start at 0, the keys must be all consecutive integer keys and in the correct order. The following script demonstrates the function:\n\nMagic methods are special methods in PHP to override default actions They include the following methods, of which the constructor method may be the most familiar:\n\nAs of PHP 8.0 the signature of the magic method definitions must be correct, which implies that if type declarations are used in method parameters or return type, they must be identical to that in the documentation. The new method must declare as return type. To demonstrate declare return type as :\n\nHowever, functions that don’t declare a return type by definition such as the constructor function must not declare a return type, not even a return type. The following script is an example:\n\nAll magic methods with a few exceptions, e.g. , must be declared with public visibility. To demonstrate this, declare with visibility.\n\nEven though it is ok to omit mixed return types, the method signature must be the same. For example, in the following script, declares without specifying its return type, while the defines its first parameter as an\n\nWith PHP 8.1 most internal methods, which are the methods in internal classes, have “tentatively” started to declare a return type. Tentatively implies that while in 8.1 only a Deprecation notice is raised, in version 9.0 an error condition message shall be output. Thus, any extending class must declare a return type that is compatible with the internal class, or a deprecation notice is issued. To demonstrate this, extend the internal class Directory and redeclare the function read() without a return type:\n\nThe following script, however is OK:\n\nWhile stack traces for exceptions that include detailed information about method parameters are quite useful for debugging, you may not want to output parameter values for some sensitive parameters such as those associated with passwords and credentials. PHP 8.2 introduces a new attribute called \\SensitiveParameter so that, if a method parameter is annotated with the attribute, the parameter’s value is not output in an exception stack trace.\n\nTo demonstrate this, consider the following script in which the function has the parameter associated with the attribute.\n\nThe function throws an just to demonstrate the feature. Call the function:\n\nNotice that the exception stack trace does not include the value for the parameter, and instead has listed.\n\nThe built-in functions and have often been misunderstood because their names imply encoding/decoding just about any string. Actually the functions are for encoding/decoding only ISO8859-1, aka “Latin-1”, strings. Additionally, the error messages they generate are not descriptive enough for debugging. PHP 8.2 has deprecated these functions. The following script makes use of them:\n\nIn PHP 8.2, the functions and accept all iterables. The function copies the elements of an iterator into an array. The function counts the elements of an array. These functions accept an as the first argument. In PHP 8.2, the type of the parameter has been widened from to so that any arbitrary iterable value is accepted.\n\nThe following script demonstrates their use with both and .\n\nThe output is as follows:\n\nIn this article in the PHP 8 series, we discussed the new features related to functions and methods, the most salient being named function parameters/arguments, a simplified callable syntax, and interruptible functions called Fibers.\n\nIn the next article in the series, we will cover new features for PHP’s type system."
    }
]