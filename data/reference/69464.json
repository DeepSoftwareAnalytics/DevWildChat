[
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.DataFrame.html",
        "document": ""
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html",
        "document": ""
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5/user_guide/index.html",
        "document": "The User Guide covers all of pandas by topic area. Each of the subsections introduces a topic (such as “working with missing data”), and discusses how pandas approaches the problem, with many examples throughout.\n\nUsers brand-new to pandas should start with 10 minutes to pandas.\n\nFor a high level summary of the pandas fundamentals, see Intro to data structures and Essential basic functionality.\n\nFurther information on any specific method can be obtained in the API reference.\n\nHow to read these guides# In these guides you will see input code inside code blocks such as: The first block is a standard python input, while in the second the indicates the input is inside a notebook. In Jupyter Notebooks the last line is printed and plots are shown inline."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5.1/reference/frame.html",
        "document": "Access a single value for a row/column pair by integer position. Access a group of rows and columns by label(s) or a boolean array. Insert column into DataFrame at specified location. Get the 'info axis' (see Indexing for more). Get item from object for given key (ex: DataFrame column). Whether each element in the DataFrame is contained in values. Replace values where the condition is False. Replace values where the condition is True. Query the columns of a DataFrame with a boolean expression. For more information on , , , and , see the indexing documentation.\n\nGet Addition of dataframe and other, element-wise (binary operator ). Get Subtraction of dataframe and other, element-wise (binary operator ). Get Multiplication of dataframe and other, element-wise (binary operator ). Get Floating division of dataframe and other, element-wise (binary operator ). Get Floating division of dataframe and other, element-wise (binary operator ). Get Integer division of dataframe and other, element-wise (binary operator ). Get Modulo of dataframe and other, element-wise (binary operator ). Get Exponential power of dataframe and other, element-wise (binary operator ). Compute the matrix multiplication between the DataFrame and other. Get Addition of dataframe and other, element-wise (binary operator ). Get Subtraction of dataframe and other, element-wise (binary operator ). Get Multiplication of dataframe and other, element-wise (binary operator ). Get Floating division of dataframe and other, element-wise (binary operator ). Get Floating division of dataframe and other, element-wise (binary operator ). Get Integer division of dataframe and other, element-wise (binary operator ). Get Modulo of dataframe and other, element-wise (binary operator ). Get Exponential power of dataframe and other, element-wise (binary operator ). Get Less than of dataframe and other, element-wise (binary operator ). Get Greater than of dataframe and other, element-wise (binary operator ). Get Less than or equal to of dataframe and other, element-wise (binary operator ). Get Greater than or equal to of dataframe and other, element-wise (binary operator ). Get Not equal to of dataframe and other, element-wise (binary operator ). Get Equal to of dataframe and other, element-wise (binary operator ). Update null elements with value in the same location in .\n\nReturn a Series/DataFrame with absolute numeric value of each element. Return whether all elements are True, potentially over an axis. Return whether any element is True, potentially over an axis. Count non-NA cells for each column or row. (DEPRECATED) Return the mean absolute deviation of the values over the requested axis. Return the maximum of the values over the requested axis. Return the mean of the values over the requested axis. Return the median of the values over the requested axis. Return the minimum of the values over the requested axis. Get the mode(s) of each element along the selected axis. Percentage change between the current and a prior element. Return the product of the values over the requested axis. Return the product of the values over the requested axis. Return values at the given quantile over requested axis. Return unbiased standard error of the mean over requested axis. Return the sum of the values over the requested axis. Count number of distinct elements in specified axis. Return a Series containing counts of unique rows in the DataFrame.\n\nAlign two objects on their axes with the specified join method. Select values at particular time of day (e.g., 9:30AM). Select values between particular times of the day (e.g., 9:00-9:30 AM). Drop specified labels from rows or columns. Test whether two objects contain the same elements. Subset the dataframe rows or columns according to the specified index labels. Return index of first occurrence of maximum over requested axis. Return index of first occurrence of minimum over requested axis. Conform Series/DataFrame to new index with optional filling logic. Return an object with matching indices as other object. Set the name of the axis for the index or columns. Reset the index, or a level of it. Return a random sample of items from an axis of object. Return the elements in the given positional indices along an axis. Truncate a Series or DataFrame before and after some index value.\n\nSort by the values along either axis. Sort object by labels (along an axis). Return the first rows ordered by in descending order. Return the first rows ordered by in ascending order. Stack the prescribed level(s) from columns to index. Transform each element of a list-like to a row, replicating index values. Return an xarray object from the pandas object.\n\nReturn the last row(s) without any NaNs before . Shift index by desired number of periods with an optional time . (DEPRECATED) Shift the time index, using the index's frequency if available. Return index for first non-NA value or None, if no non-NA value is found. Return index for last non-NA value or None, if no non-NA value is found. Cast to DatetimeIndex of timestamps, at beginning of period. Localize tz-naive index of a Series or DataFrame to target time zone.\n\nFlags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in ."
    },
    {
        "link": "https://pandas.pydata.org/docs",
        "document": "The reference guide contains a detailed description of the pandas API. The reference describes how the methods work and which parameters can be used. It assumes that you have an understanding of the key concepts."
    },
    {
        "link": "https://zyte.com/blog/json-parsing-with-python",
        "document": "JSON (JavaScript Object Notation) is a text-based data format used for exchanging and storing data between web applications. It simplifies the data transmission process between different programming languages and platforms.\n\nThe has become increasingly popular in recent years. It’s a simple and flexible way of representing data that can be easily understood and parsed by both humans and machines. JSON consists of key-value pairs enclosed in curly braces, separated by a colon.\n\nPython provides various and manipulating JSON data, making it a popular choice for data analysts, web developers, and data scientists.\n\nIn this guide, we’ll explore the syntax and data types of JSON, as well as the Python libraries and methods used for parsing JSON data, including more advanced options like JMESPath and ChompJS, which are very useful for web scraping data."
    },
    {
        "link": "https://medium.com/@datajournal/how-to-parse-json-data-with-python-99069a405e2b",
        "document": "JSON has become very popular in recent years. It’s simple and flexible, making it easy for both humans and machines to understand and parse. JSON data consists of key-value pairs enclosed in curly braces, with keys and values separated by a colon.\n\nPython has many tools, libraries, and methods for working with JSON data. This makes Python a popular choice for data analysts, web developers, and data scientists.\n\nIn this guide, I’ll go over the basics of JSON syntax and data types. I’ll also discuss the Python libraries and methods we can use to parse JSON data. We’ll look at some advanced options which are great for web scraping data.\n\nJSON is a text-based data format that is used to represent structured data. It is derived from JavaScript but is language-independent, making it an ideal choice for data interchange between applications written in different languages. JSON data consists of key-value pairs, similar to a dictionary in Python, and supports nested data structures, arrays, and more.\n\nJSON is popular for several reasons:\n\n1. Human-Readable: JSON’s format is easy to read and understand.\n\n3. Language-Independent: JSON can be parsed and generated by almost any programming language.\n\n4. Flexible: JSON supports nested structures and arrays, making it versatile for representing complex data.\n\nNow, before we jump into the actual guide, I want to mention an alternative option (I don’t receive a commission if you register, don’t worry) — Bright Data. My company uses Bright Data’s web scraping APIs to scrape LinkedIn, and the results have been exceptional.\n\nPython’s standard library includes a module called `json` that makes it easy to work with JSON data. This module provides methods for parsing JSON data into Python objects and converting Python objects into JSON strings.\n\nThe `json` module provides the `json.loads()` method for parsing JSON strings and `json.load()` for parsing JSON data from a file.\n\nTo parse a JSON string, use the `json.loads()` method:\n\nTo parse JSON data from a file, use the `json.load()` method:\n\nThe `json` module also provides methods for converting Python objects into JSON strings and writing JSON data to a file.\n\nTo convert a Python object into a JSON string, use the `json.dumps()` method:\n\nTo write JSON data to a file, use the `json.dump()` method:\n\nJSON data can be complex, with nested objects and arrays. Python’s `json` module handles these complexities well.\n\nConsider the following nested JSON data:\n\nTo access nested data, use the appropriate keys:\n\nJSON also supports arrays, which can contain multiple objects or values:\n\nTo access data in a JSON array, use indexing:\n\nWhen working with JSON data, it’s important to handle potential errors that might occur during parsing. The `json` module raises specific exceptions for different types of errors.\n\n- `json.JSONDecodeError`: Raised when the JSON data is malformed.\n\nTo handle these exceptions, use a try-except block:\n\nMany web APIs return data in JSON format (like Bright Data’s API that I am using). Python’s `requests` library is commonly used to interact with APIs. Let’s see how to fetch and parse JSON data from an API.\n\nExample: Fetching Data from an API\n\nIn this example, the `response.json()` method directly parses the JSON data from the API response.\n\nJSON (JavaScript Object Notation) is a string format used for data interchange that shares a similar syntax with Python’s dictionary object literal syntax. However, JSON is not the same as a Python dictionary. When JSON data is loaded into Python, it is converted into a Python object, typically a dictionary or list. This allows for manipulation using standard Python methods. To save data back to JSON format, the `json.dumps()` function is used. It’s crucial to remember this difference between the two formats.\n\nWhen working with JSON in Python, you can modify the data by adding, updating, or deleting elements. We’ll use the built-in `json` package, which provides the basic functions required to accomplish these tasks.\n\nTo add an element to a JSON object, you can use standard dictionary syntax:\n\nUpdating an element involves replacing the value of an existing key:\n\nAnother approach to adding or updating values in a dictionary is using the `update()` method. This method adds or updates elements using values from another dictionary or an iterable containing key-value pairs:\n\nTo remove an element from a JSON object, use the `del` keyword:\n\nAlternatively, you can use the `pop()` method, which retrieves the value and removes it simultaneously:\n\nIf the element is not present, using `del` will raise a `KeyError` exception. The `pop()` method will return `None` if the key is not found. To use `del` safely, check if the key exists or wrap the operation in a try-except block:\n\nIn Python, error handling can be done using two methods: “check before you leap” and “ask for forgiveness.” The former checks the program state before executing each operation, while the latter tries an operation and catches any exceptions if it fails. The “ask for forgiveness” approach is more common in Python, assuming that errors are a regular part of program flow. It provides a graceful way of handling errors, making the code easier to read and write.\n\nAfter modifying JSON data, you may want to save it back to a JSON file or export it as a JSON string. The `json.dump()` method saves a JSON object to a file, while `json.dumps()` returns a JSON string representation of an object.\n\nUsing `json.dump()` with the `open()` context manager in write mode:\n\nUsing `json.dumps()` to convert a dictionary to a JSON string representation:\n\nFor more advanced JSON parsing, you might need to work with custom decoders or handle complex data structures.\n\nYou can define custom decoding behavior by subclassing `json.JSONDecoder`:\n\nFor very large JSON files, consider using the `ijson` library, which parses JSON data incrementally:\n\nParsing JSON data with Python is simple because of the json module. Whether you’re dealing with basic JSON strings or complex nested structures, Python has the tools you need to effectively parse, manipulate, and write JSON data. By learning the basics and exploring advanced techniques, you can manage data exchange in your Python applications efficiently.\n\nIn this guide, I’ve covered the basics of reading and parsing JSON data with Python. I’ve shown you how to access and modify JSON data using Python’s built-in json package. We’ve also looked at more advanced parsing options, which are useful for web scraping.\n\nGot any questions? Comment below!"
    },
    {
        "link": "https://w3schools.com/python/python_json.asp",
        "document": "JSON is a syntax for storing and exchanging data.\n\nPython has a built-in package called , which can be used to work with JSON data.\n\nIf you have a JSON string, you can parse it by using the method.\n\nIf you have a Python object, you can convert it into a JSON string by using the method.\n\nYou can convert Python objects of the following types, into JSON strings:\n\nWhen you convert from Python to JSON, Python objects are converted into the JSON (JavaScript) equivalent:\n\nThe example above prints a JSON string, but it is not very easy to read, with no indentations and line breaks.\n\nThe method has parameters to make it easier to read the result:\n\nYou can also define the separators, default value is (\", \", \": \"), which means using a comma and a space to separate each object, and a colon and a space to separate keys from values:\n\nThe method has parameters to order the keys in the result:\n\nUse the parameter to specify if the result should be sorted or not: Try it Yourself »"
    },
    {
        "link": "https://realpython.com/python-json",
        "document": "Python’s module provides you with the tools you need to effectively handle JSON data. You can convert Python data types to a JSON-formatted string with or write them to files using . Similarly, you can read JSON data from files with and parse JSON strings with .\n\nJSON, or JavaScript Object Notation, is a widely-used text-based format for data interchange. Its syntax resembles Python dictionaries but with some differences, such as using only double quotes for strings and lowercase for Boolean values. With built-in tools for validating syntax and manipulating JSON files, Python makes it straightforward to work with JSON data.\n\nBy the end of this tutorial, you’ll understand that:\n• JSON in Python is handled using the standard-library module, which allows for data interchange between JSON and Python data types.\n• JSON is a good data format to use with Python as it’s human-readable and straightforward to serialize and deserialize, which makes it ideal for use in APIs and data storage.\n• You write JSON with Python using to serialize data to a file.\n• You can minify and prettify JSON using Python’s module.\n\nSince its introduction, JSON has rapidly emerged as the predominant standard for the exchange of information. Whether you want to transfer data with an API or store information in a document database, it’s likely you’ll encounter JSON. Fortunately, Python provides robust tools to facilitate this process and help you manage JSON data efficiently.\n\nWhile JSON is the most common format for data distribution, it’s not the only option for such tasks. Both XML and YAML serve similar purposes. If you’re interested in how the formats differ, then you can check out the tutorial on how to serialize your data with Python.\n\nThe acronym JSON stands for JavaScript Object Notation. As the name suggests, JSON originated from JavaScript. However, JSON has transcended its origins to become language-agnostic and is now recognized as the standard for data interchange. The popularity of JSON can be attributed to native support by the JavaScript language, resulting in excellent parsing performance in web browsers. On top of that, JSON’s straightforward syntax allows both humans and computers to read and write JSON data effortlessly. To get a first impression of JSON, have a look at this example code: You’ll learn more about the JSON syntax later in this tutorial. For now, recognize that the JSON format is text-based. In other words, you can create JSON files using the code editor of your choice. Once you set the file extension to , most code editors display your JSON data with syntax highlighting out of the box: The screenshot above shows how VS Code displays JSON data using the Bearded color theme. You’ll have a closer look at the syntax of the JSON format next! In the previous section, you got a first impression of how JSON data looks. And as a Python developer, the JSON structure probably reminds you of common Python data structures, like a dictionary that contains a string as a key and a value. If you understand the syntax of a dictionary in Python, you already know the general syntax of a JSON object. Note: Later in this tutorial, you’ll learn that you’re free to use lists and other data types at the top level of a JSON document. The similarity between Python dictionaries and JSON objects is no surprise. One idea behind establishing JSON as the go-to data interchange format was to make working with JSON as convenient as possible, independently of which programming language you use: [A collection of key-value pairs and arrays] are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages is also based on these structures. (Source) To explore the JSON syntax further, create a new file named and add a more complex JSON structure as the content of the file: In the code above, you see data about a dog named Frieda, which is formatted as JSON. The top-level value is a JSON object. Just like Python dictionaries, you wrap JSON objects inside curly braces ( ). In line 1, you start the JSON object with an opening curly brace ( ), and then you close the object at the end of line 20 with a closing curly brace ( ). Note: Although whitespace doesn’t matter in JSON, it’s customary for JSON documents to be formatted with two or four spaces to indicate indentation. If the file size of the JSON document is important, then you may consider minifying the JSON file by removing the whitespace. You’ll learn more about minifying JSON data later in the tutorial. Inside the JSON object, you can define zero, one, or more key-value pairs. If you add multiple key-value pairs, then you must separate them with a comma ( ). A key-value pair in a JSON object is separated by a colon ( ). On the left side of the colon, you define a key. A key is a string you must wrap in double quotes ( ). Unlike Python, JSON strings don’t support single quotes ( ). The values in a JSON document are limited to the following data types: Either or without quotes Just like in dictionaries and lists, you’re able to nest data in JSON objects and arrays. For example, you can include an object as the value of an object. Also, you’re free to use any other allowed value as an item in a JSON array. As a Python developer, you may need to pay extra attention to the Boolean values. Instead of using or in title case, you must use the lowercase JavaScript-style Booleans or . Unfortunately, there are some other details in the JSON syntax that you may stumble over as a developer. You’ll have a look at them next. The JSON standard doesn’t allow any comments, trailing commas, or single quotes for strings. This can be confusing to developers who are used to Python dictionaries or JavaScript objects. Here’s a smaller version of the JSON file from before with invalid syntax:\n• Line 5 has a trailing comma after the final key-value pair.\n• Line 10 contains a trailing comma in the array. Using double quotes is something you can get used to as a Python developer. Comments can be helpful in explaining your code, and trailing commas can make moving lines around in your code less fragile. This is why some developers like to use Human JSON (Hjson) or JSON with comments (JSONC). Hjson gives you the freedom to use comments, ditch commas between properties, or create quoteless strings. Apart from the curly braces ( ), the Hjson syntax look like a mix of YAML and JSON. JSONC is a bit stricter than Hjson. Compared to regular JSON, JSONC allows you to use comments and trailing commas. You may have encountered JSONC when editing the file of VS Code. Inside its configuration files, VS Code works in a JSONC mode. For common JSON files, VS Code is more strict and points out JSON syntax errors. If you want to make sure you write valid JSON, then your coding editor can be of great help. The invalid JSON document above contains marks for each occurrence of incorrect JSON syntax: When you don’t want to rely on your code editor, you can also use online tools to verify that the JSON syntax you write is correct. Popular online tools for validating JSON are JSON Lint and JSON Formatter. Later in the tutorial, you’ll learn how to validate JSON documents from the comfort of your terminal. But before that, it’s time to find out how you can work with JSON data in Python.\n\nPython supports the JSON format through the built-in module named . The module is specifically designed for reading and writing strings formatted as JSON. That means you can conveniently convert Python data types into JSON data and the other way around. The act of converting data into the JSON format is referred to as serialization. This process involves transforming data into a series of bytes for storage or transmission over a network. The opposite process, deserialization, involves decoding data from the JSON format back into a usable form within Python. You’ll start with the serialization of Python code into JSON data with the help of the module. One of the most common actions when working with JSON in Python is to convert a Python dictionary into a JSON object. To get an impression of how this works, hop over to your Python REPL and follow along with the code below: After importing the module, you can use to convert a Python dictionary to a JSON-formatted string, which represents a JSON object. It’s important to understand that when you use , you get a Python string in return. In other words, you don’t create any kind of JSON data type. The result is similar to what you’d get if you used Python’s built-in function: Using gets more interesting when your Python dictionary doesn’t contain strings as keys or when values don’t directly translate to a JSON format: In the dictionary, the keys , , and are numbers. Once you use , the dictionary keys become strings in the JSON-formatted string. Note: When you convert a dictionary to JSON, the dictionary keys will always be strings in JSON. The Boolean Python values of your dictionary become JSON Booleans. As mentioned before, the tiny but significant difference between JSON Booleans and Python Booleans is that JSON Booleans are lowercase. The cool thing about Python’s module is that it takes care of the conversion for you. This can come in handy when you’re using variables as dictionary keys: When converting Python data types into JSON, the module receives the evaluated values. While doing so, sticks tightly to the JSON standard. For example, when converting integer keys like to the string . The module allows you to convert common Python data types to JSON. Here’s an overview of all Python data types and values that you can convert to JSON values: Note that different Python data types like lists and tuples serialize to the same JSON data type. This can cause problems when you convert JSON data back to Python, as the data type may not be the same as before. You’ll explore this pitfall later in this tutorial when you learn how to read JSON. Dictionaries are probably the most common Python data type that you’ll use as a top-level value in JSON. But you can convert the data types listed above just as smoothly as dictionaries using . Take a Boolean or a list, for example: A JSON document may contain a single scalar value, like a number, at the top level. That’s still valid JSON. But more often than not, you want to work with a collection of key-value pairs. Similar to how not every data type can be used as a dictionary key in Python, not all keys can be converted into JSON key strings: You can’t use dictionaries, lists, or tuples as JSON keys. For dictionaries and lists, this rule makes sense as they’re not hashable. But even when a tuple is hashable and allowed as a key in a dictionary, you’ll get a when you try to use a tuple as a JSON key: : keys must be str, int, float, bool or None, not tuple By providing the argument, you can prevent getting a when creating JSON data with unsupported Python keys: When you set in to , then Python skips the keys that are not supported and would otherwise raise a . The result is a JSON-formatted string that only contains a subset of the input dictionary. In practice, you usually want your JSON data to resemble the input object as close as possible. So, you must use with caution to not lose information when calling . Note: If you’re ever in a situation where you need to convert an unsupported object into JSON, then you can consider creating a subclass of the and implementing a method. When you use , you can use additional arguments to control the look of the resulting JSON-formatted string. For example, you can sort the dictionary keys by setting the parameter to : When you set to , then Python sorts the keys alphabetically for you when serializing a dictionary. Sorting the keys of a JSON object can come in handy when your dictionary keys formerly represented the column names of a database, and you want to display them in an organized fashion to the user. Another notable parameter of is , which you’ll probably use the most when serializing JSON data. You’ll explore later in this tutorial in the prettify JSON section. When you convert Python data types into the JSON format, you usually have a goal in mind. Most commonly, you’ll use JSON to persist and exchange data. To do so, you need to save your JSON data outside of your running Python program. Conveniently, you’ll explore saving JSON data to a file next. The JSON format can come in handy when you want to save data outside of your Python program. Instead of spinning up a database, you may decide to use a JSON file to store data for your workflows. Again, Python has got you covered. To write Python data into an external JSON file, you use . This is a similar function to the one you saw earlier, but without the s at the end of its name: In lines 3 to 22, you define a dictionary that you write to a JSON file in line 25 using a context manager. To properly indicate that the file contains JSON data, you set the file extension to . When you use , then it’s good practice to define the encoding. For JSON, you commonly want to use as the encoding when reading and writing files: The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. (Source) The function has two required arguments:\n• The object you want to write\n• The file you want to write into Other than that, there are a bunch of optional parameters for . The optional parameters of are the same as for . You’ll investigate some of them later in this tutorial when you prettify and minify JSON files.\n\nIn the former sections, you learned how to serialize Python data into JSON-formatted strings and JSON files. Now, you’ll see what happens when you load JSON data back into your Python program. In parallel to and , the library provides two functions to deserialize JSON data into a Python object: As a rule of thumb, you work with when your data is already present in your Python program. You use with external files that are saved on your disk. The conversion from JSON data types and values to Python follows a similar mapping as before when you converted Python objects into the JSON format: When you compare this table to the one in the previous section, you may recognize that Python offers a matching data type for all JSON types. That’s very convenient because this way, you can be sure you won’t lose any information when deserializing JSON data to Python. Note: Deserialization is not the exact reverse of the serialization process. The reason for this is that JSON keys are always strings, and not all Python data types can be converted to JSON data types. This discrepancy means that certain Python objects may not retain their original type when serialized and then deserialized. To get a better feeling for the conversion of data types, you’ll start with serializing a Python object to JSON and then convert the JSON data back to Python. That way, you can spot differences between the Python object you serialize and the Python object you end up with after deserializing the JSON data. To investigate how to load a Python dictionary from a JSON object, revisit the example from before. Start by creating a dictionary and then serialize the Python dictionary to a JSON string using : By passing into , you’re creating a string with a JSON object that you save in . If you want to convert back to a Python dictionary, then you can use : By using , you can convert JSON data back into Python objects. With the knowledge about JSON that you’ve gained so far, you may already suspect that the content of the dictionary is not identical to the content of : The difference between and is subtle but can be impactful in your Python programs. In JSON, the keys must always be strings. When you converted to using , the integer key became the string . When you used , there was no way for Python to know that the string key should be an integer again. That’s why your dictionary key remained a string after deserialization. You’ll investigate a similar behavior by doing another conversion roundtrip with other Python data types! To explore how different data types behave in a roundtrip from Python to JSON and back, take a portion of the dictionary from a former section. Note how the dictionary contains different data types as values: The dictionary contains a bunch of common Python data types as values. For example, a string in line 2, a Boolean in line 3, a in line 7, and a tuple in line 8, just to name a few. Next, convert to a JSON-formatted string and back to Python again. Afterward, have a look at the newly created dictionary: You can convert every JSON data type perfectly into a matching Python data type. The JSON Boolean deserializes into , converts back into , and objects and arrays become dictionaries and lists. Still, there’s one exception that you may encounter in roundtrips: When you serialize a Python tuple, it becomes a JSON array. When you load JSON, a JSON array correctly deserializes into a list because Python has no way of knowing that you want the array to be a tuple. Problems like the one described above can always be an issue when you’re doing data roundtrips. When the roundtrip happens in the same program, you may be more aware of the expected data types. Data type conversions may be even more obfuscated when you’re dealing with external JSON files that originated in another program. You’ll investigate a situation like this next! In a previous section, you created a file that saved a file. If you need to refresh your memory, you can expand the collapsible section below that shows the code again: Take a look at the data types of the dictionary. Is there a data type in a value that the JSON format doesn’t support? When you want to write content to a JSON file, you use . The counterpart to is . As the name suggests, you can use to load a JSON file into your Python program. Jump back into the Python REPL and load the JSON file from before: Just like when writing files, it’s a good idea to use a context manager when reading a file in Python. That way, you don’t need to bother with closing the file again. When you want to read a JSON file, then you use inside the statement’s block. The argument for the function must be either a text file or a binary file. The Python object that you get from depends on the top-level data type of your JSON file. In this case, the JSON file contains an object at the top level, which deserializes into a dictionary. When you deserialize a JSON file as a Python object, then you can interact with it natively—for example, by accessing the value of the key with square bracket notation ( ). Still, there’s a word of caution here. Import the original dictionary from before and compare it to : When you load a JSON file as a Python object, then any JSON data type happily deserializes into Python. That’s because Python knows about all data types that the JSON format supports. Unfortunately, it’s not the same the other way around. As you learned before, there are Python data types like that you can convert into JSON, but you’ll end up with an data type in the JSON file. Once you convert the JSON data back to Python, then an array deserializes into the Python data type. Generally, being cautious about data type conversions should be the concern of the Python program that writes the JSON. With the knowledge you have about JSON files, you can always anticipate which Python data types you’ll end up with as long as the JSON file is valid. If you use , then the content of the file you load must contain valid JSON syntax. Otherwise, you’ll receive a . Luckily, Python caters to you with more tools you can use to interact with JSON. For example, it allows you to check a JSON file’s validity from the convenience of the terminal.\n\nSo far, you’ve explored the JSON syntax and have already spotted some common JSON pitfalls like trailing commas and single quotes for strings. When writing JSON, you may have also spotted some annoying details. For example, neatly indented Python dictionaries end up being a blob of JSON data. In the last section of this tutorial, you’ll try out some techniques to make your life easier as you work with JSON data in Python. To start, you’ll give your JSON object a well-deserved glow-up. One huge advantage of the JSON format is that JSON data is human-readable. Even more so, JSON data is human-writable. This means you can open a JSON file in your favorite text editor and change the content to your liking. Well, that’s the idea, at least! Editing JSON data by hand is not particularly easy when your JSON data looks like this in the text editor: Even with word wrapping and syntax highlighting turned on, JSON data is hard to read when it’s a single line of code. And as a Python developer, you probably miss some whitespace. But worry not, Python has got you covered! When you call or to serialize a Python object, then you can provide the argument. Start by trying out with different indentation levels: The default value for is . When you call without or with as a value, you’ll end up with one line of a compact JSON-formatted string. If you want linebreaks in your JSON string, then you can set to or provide an empty string. Although probably less useful, you can even provide a negative number as the indentation or any other string. More commonly, you’ll provide values like or for : When you use positive integers as the value for when calling , then you’ll indent every level of the JSON object with the given count as spaces. Also, you’ll have newlines for each key-value pair. Note: To actually see the whitespace in the REPL, you can wrap the calls in function calls. The parameter works exactly the same for as it does for . Go ahead and write the dictionary into a JSON file with an indentation of spaces: When you set the indentation level when serializing JSON data, then you end up with prettified JSON data. Have a look at how the file looks in your editor: Python can work with JSON files no matter how they’re indented. As a human, you probably prefer a JSON file that contains newlines and is neatly indented. A JSON file that looks like this is way more convenient to edit. The convenience of being able to edit JSON data in the editor comes with a risk. When you move key-value pairs around or add strings with one quote instead of two, you end up with an invalid JSON. To swiftly check if a JSON file is valid, you can leverage Python’s . You can run the module as an executable in the terminal using the switch. To see in action, also provide as the positional argument: When you run only with an option, then Python validates the JSON file and outputs the JSON file’s content in the terminal if the JSON is valid. Running in the example above means that contains valid JSON syntax. Note: The prints the JSON data with an indentation of 4 by default. You’ll explore this behavior in the next section. To make complain, you need to invalidate your JSON document. You can make the JSON data of invalid by removing the comma ( ) between the key-value pairs: After saving , run again to validate the file: The module successfully stumbles over the missing comma in . Python notices that there’s a delimiter missing once the property name enclosed in double quotes starts in line 3 at position 5. Go ahead and try fixing the JSON file again. You can also be creative with invalidating and check how reports your error. But keep in mind that only reports the first error. So you may need to go back and forth between fixing a JSON file and running . Once is valid, you may notice that the output always looks the same. Of course, like any well-made command-line interface, offers you some options to control the program. In the previous section, you used to validate a JSON file. When the JSON syntax was valid, showed the content with newlines and an indentation of four spaces. To control how prints the JSON, you can set the option. If you followed along with the tutorial, then you’ve got a file that doesn’t contain newlines or indentation. Alternatively, you can download in the materials by clicking the link below: Free Bonus: Click here to download the free sample code that shows you how to work with JSON data in Python. When you pass in to , then you can pretty print the content of the JSON file in your terminal. When you set , then you can control which indentation level uses to display the code: Seeing the prettified JSON data in the terminal is nifty. But you can step up your game even more by providing another option to the run! By default, writes the output to , just like you commonly do when calling the function. But you can also redirect the output of into a file by providing a positional argument: With as the value of the option, you write the output into the JSON file instead of showing the content in the terminal. If the file doesn’t exist yet, then Python creates the file on the way. If the target file already exists, then you overwrite the file with the new content. Note: You can prettify a JSON file in place by using the same file as and arguments. You can verify that the file exists by running the terminal command: The whitespace you added to comes with a price. Compared to the original, unindented file, the file size of is now around double that. Here, the 308-byte increase may not be significant. But when you’re dealing with big JSON data, then a good-looking JSON file will take up quite a bit of space. Having a small data footprint is especially useful when serving data over the web. Since the JSON format is the de facto standard for exchanging data over the web, it’s worth keeping the file size as small as possible. And again, Python’s has got your back! As you know by now, Python is a great helper when working with JSON. You can minify JSON data with Python in two ways:\n• Use the module in your Python code Before, you used with the option to add whitespace. Instead of using here, you can use provide to do the opposite and remove any whitespace between the key-value pairs of your JSON: After calling the module, you provide a JSON file as the and another JSON file as the . If the target JSON file exists, then you overwrite its contents. Otherwise, you create a new file with the filename you provide. Just like with , you provide the same file as a source and target file to minify the file in-place. In the example above, you minify into . Run the command to see how many bytes you squeezed out of the original JSON file: Compared to , the file size of is 337 bytes smaller. That’s even 29 bytes less than the original file that didn’t contain any indentation. To investigate where Python managed to remove even more whitespace from the original JSON, open the Python REPL again and minify the content of the original file with Python’s module: In the code above, you use Python’s to get the content of as text. Then, you use to deserialize to , which is a Python dictionary. You could use to get a Python dictionary right away, but you need the JSON data as a string first to compare it properly. That’s also why you use to create and then use instead of leveraging directly to save the minified JSON data in . As you learned before, needs JSON data as the first argument and then accepts a value for the indentation. The default value for is , so you could skip setting the argument explicitly like you do above. But with , you’re making your intention clear that you don’t want any indentation, which will be a good thing for others who read your code later. The parameter for allows you to define a tuple with two values:\n• The separator between the key-value pairs or list items. By default, this separator is a comma followed by a space ( ).\n• The separator between the key and the value. By default, this separator is a colon followed by a space ( ). By setting to , you continue to use valid JSON separators. But you tell Python not to add any spaces after the comma ( ) and the colon ( ). That means that the only whitespace left in your JSON data can be whitespace appearing in key names and values. That’s pretty tight! With both and containing your JSON strings, it’s time to compare them: You can already spot the difference between and when you look at the output. You then use the function to verify that the size of is indeed smaller. If you’re curious about why the length of the JSON strings almost exactly matches the file size of the written files, then looking into Unicode & character encodings in Python is a great idea. Both and are excellent helpers when you want to make JSON data look prettier, or if you want to minify JSON data to save some bytes. With the module, you can conveniently interact with JSON data in your Python programs. That’s great when you need to have more control over the way you interact with JSON. The module comes in handy when you want to work with JSON data directly in your terminal."
    },
    {
        "link": "https://geeksforgeeks.org/read-json-file-using-python",
        "document": "The full form of JSON is JavaScript Object Notation. It means that a script (executable) file which is made of text in a programming language, is used to store and transfer the data. Python supports JSON through a built-in package called JSON. To use this feature, we import the JSON package in Python script. The text in JSON is done through quoted-string which contains the value in key-value mapping within { }.\n\nIt’s pretty easy to load a JSON object in Python. Python has a built-in package called JSON, which can be used to work with JSON data. It’s done by using the JSON module, which provides us with a lot of methods which among loads() and load() methods are gonna help us to read the JSON file.\n\nHere we are going to read a JSON file named data.json the screenshot of the file is given below.\n\nDeserialize a JSON String to an Object in Python\n\nThe Deserialization of JSON means the conversion of JSON objects into their respective Python objects. The load()/loads() method is used for it. If you have used JSON data from another program or obtained it as a string format of JSON, then it can easily be deserialized with load()/loads(), which is usually used to load from string, otherwise, the root object is in list or dict. See the following table given below.\n\nIn the below code, firstly we import the JSON module, open the file using the file handling open() function, and then store the data into the variable ‘data’ using the json.load() function. After that, we iterate over the data and print it.\n\nThis example shows reading from both string and JSON file using json.loads() method. Firstly, we have a JSON string stored in a variable ‘j_string’ and convert this JSON string into a Python dictionary using json.loads() method that is stored in the variable ‘y’ after that we print it. Secondly, we read JSON String stored in a file using json.loads() for that we first convert the JSON file into a string using the file handling same as in the above example and then convert it into the string using read() function and rest of the procedure is same as we follow before using json.loads() method.\n\nExample: Here in the output we can see both the output of the reading string and file using json.loads() method\n\nHow to convert the JSON data into Python objects?\n\nWhat is the best Python library for reading JSON files?\n\nHow to read nested JSON in Python?"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-iterate-through-a-nested-list-in-python",
        "document": "A nested list is a list that contains other lists. Working with nested lists can seem tricky at first but it becomes easy once we understand how to iterate through them. This is the easiest way to loop through a nested list. We can use a for loop to access each sublist in the main list, and then use another for loop to access items within each sublist.\n\nOther methods that can use to iterate through a nested list are:\n\nitertools.chain() is a method in Python that can combine multiple iterables (lists, tuples, etc.) into a single iterable. We can use it to flatten a nested list and then iterate over it.\n\nList comprehension is a compact way to create lists. It’s very useful for simple tasks. We can combine it with loops to access nested lists in a single line.\n\nIf we are working with lists of numbers and want to convert a nested list into a flat list for easier iteration, numpy.flatten() can be useful. This method flattens multi-dimensional arrays into one long array.\n\nFor more complex nested lists (where the number of sublists may vary), we can use recursion. Recursion means that a function calls itself to solve smaller parts of the problem.\n\nIf we want to avoid recursion and still handle deeply nested lists, we can use a stack. A stack is a data structure that stores elements in a way that the last element added is the first to be processed (Last In First Out or LIFO). We can push sublists onto the stack and process each one iteratively."
    },
    {
        "link": "https://stackoverflow.com/questions/62619434/nested-for-loop-in-lists-and-iterators",
        "document": "I have these two lists\n\nI use this nested for loop to access all possible pairs:\n\nI get the following expected result:\n\nBut if I convert l1 and l2 to iterators, I get a different result and I can't access to all of the pairs:\n\nI can't understand the difference between these two code snippets. Why the iterators generate this result?"
    },
    {
        "link": "https://stackoverflow.com/questions/17014211/iterate-python-nested-lists-efficiently",
        "document": "I am working on a network traffic monitor project in Python. Not that familiar with Python, so I am seeking help here.\n\nIn short, I am checking both in and out traffic, I wrote it this way:\n\nnetdata is a list consisting of nested lists, its format is like this:\n\nHere represents the moment and is the flow. However I just want to keep these f at this moment for both in and out, I wonder any way to get an efficient code.\n\nAfter some search, I think I need to use create a list of traffic(2 elements), then use zip function to iterate both lists at the same time, but I have difficulty writing a correct one. Since my netdata is a very long list, efficiency is also very important.\n\nIf there is anything confusing, let me know, I will try to clarify. Thanks for help"
    },
    {
        "link": "https://geeksforgeeks.org/iterate-over-a-list-in-python",
        "document": "Python provides several ways to iterate over list. The simplest and the most common way to iterate over a list is to use a for loop. This method allows us to access each element in the list directly.\n\nExample: Print all elements in the list one by one using for loop.\n\nLet’s see other different ways to iterate over a list in Python.\n\nWe can use the range() method with for loop to traverse the list. This method allow us to access elements by their index, which is useful if we need to know the position of an element or modify the list in place.\n\nThis method is similar to the above method. Here we are using a while loop to iterate through a list. We first need to find the length of list using len(), then start at index 0 and access each item by its index then incrementing the index by 1 after each iteration.\n\nWe can also use the enumerate() function to iterate through the list. This method provides both the index (i) and the value (val) of each element during the loop.\n\nList comprehension is similar to for loop. It provides the shortest syntax for looping through list.\n\nNote: This method is not a recommended way to iterate through lists as it creates a new list (extra space).\n• None Iterate Over a List of Lists in Python\n• None Iterate through list without using the increment variable"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/ic7s4b/traversing_an_arbitrarily_nested_list",
        "document": "Was reading through a Python textbook and the author posted a problem about taking a list that potentially is very deeply nested (e.g. [[[[[[[[[[[[[[[[[[[[[[[1,3,4,5],[4]....) and writing a script to sum up all those numbers (I don’t believe built-in sum works on nested lists). I made the problem a bit more general — how do you take an arbitrarily nested list and strip out all the extra structure to get a list of minimal depth? (E.g., the above would be [1,3,4,5,4...]\n\nI came up with this.\n\nidea is that it gets top-level elements of a list, then tries to iterate over those elements (which works if they’re lists themselves). It spits out an error it tries to loop over a single element, like “4” in the above list, which is caught by and taken out of the nested loop function calls. Essentially each call to reduces the depth (if possible) of all list elements by 1.\n• I glanced at the sample code after I did the above, and the author has an explicit type test (testing if each is a type, then going deeper into the recursion). Aren’t type tests frowned upon in Python? It didn’t seem to simplify the code at all and maybe costs some flexibility?\n• This code also works if there’s, say, a string somewhere in my list, and I don’t fully understand why. Eventually (after nesting some amount of for loops with repeated calls, it seems like is going to hit a string, split it into single-character strings, and then loop endlessly over those (a single-character string is still iterable?) Why does the loop terminate if , for instance?"
    }
]