[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing.image?view=windowsdesktop-9.0",
        "document": "The following code example is designed for use with Windows Forms. It is a handler for the Paint event. A Graphics object is passed to the event and is used to draw the image on the form. The code performs the following actions:\n• None Creates an image from a file named SampImag.jpg. This file must be located in the same folder as the application executable file.\n• None Creates a point at which to draw the upper-left corner of the image.\n• None Draws the unscaled image on the form.\n\nTo draw an Image on a Windows Form, use one of the DrawImage methods."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.drawing?view=net-9.0",
        "document": "Encapsulates a GDI+ bitmap, which consists of the pixel data for a graphics image and its attributes. A Bitmap is an object used to work with images defined by pixel data. Specifies that, when interpreting ToolboxBitmapAttribute declarations, the assembly should look for the indicated resources in the same assembly, but with the BitmapSuffix configuration value appended to the declared file name. Specifies that, when interpreting ToolboxBitmapAttribute declarations, the assembly should look for the indicated resources in a satellite assembly, but with the BitmapSuffix configuration value appended to the declared file name. Defines objects used to fill the interiors of graphical shapes such as rectangles, ellipses, pies, polygons, and paths. Brushes for all the standard colors. This class cannot be inherited. Provides methods for creating graphics buffers that can be used for double buffering. Provides access to the main buffered graphics context object for the application domain. Converts colors from one data type to another. Access this class through the TypeDescriptor. Translates colors to and from GDI+ Color structures. This class cannot be inherited. Defines a particular format for text, including font face, size, and style attributes. This class cannot be inherited. Converts Font objects from one data type to another. FontConverter.FontNameConverter is a type converter that is used to convert a font name to and from various other representations. Converts font units to and from other unit types. Defines a group of type faces having a similar basic design and certain variations in styles. This class cannot be inherited. Encapsulates a GDI+ drawing surface. This class cannot be inherited. Represents a Windows icon, which is a small bitmap image that is used to represent an object. Icons can be thought of as transparent bitmaps, although their size is determined by the system. Converts an Icon object from one data type to another. Access this class through the TypeDescriptor object. An abstract base class that provides functionality for the Bitmap and Metafile descended classes. Animates an image that has time-based frames. ImageConverter is a class that can be used to convert Image objects from one data type to another. Access this class through the TypeDescriptor object. ImageFormatConverter is a class that can be used to convert ImageFormat objects from one data type to another. Access this class through the TypeDescriptor object. Defines an object used to draw lines and curves. This class cannot be inherited. Pens for all the standard colors. This class cannot be inherited. Converts a Point object from one data type to another. Converts rectangles from one data type to another. Access this class through the TypeDescriptor. Describes the interior of a graphics shape composed of rectangles and paths. This class cannot be inherited. The SizeConverter class is used to convert from one data type to another. Access this class through the TypeDescriptor object. Converts SizeF objects from one type to another. Defines a brush of a single color. Brushes are used to fill graphics shapes, such as rectangles, ellipses, pies, polygons, and paths. This class cannot be inherited. Encapsulates text layout information (such as alignment, orientation and tab stops) display manipulations (such as ellipsis insertion and national digit substitution) and OpenType features. This class cannot be inherited. Each property of the SystemBrushes class is a SolidBrush that is the color of a Windows display element. Each property of the SystemColors class is a Color structure that is the color of a Windows display element. Specifies the fonts used to display text in Windows display elements. Each property of the SystemIcons class is an Icon object for Windows system-wide icons. This class cannot be inherited. Each property of the SystemPens class is a Pen that is the color of a Windows display element and that has a width of 1 pixel. Each property of the TextureBrush class is a Brush object that uses an image to fill the interior of a shape. This class cannot be inherited. Allows you to specify an icon to represent a control in a container, such as the Microsoft Visual Studio Form Designer.\n\nRepresents an ordered pair of integer x- and y-coordinates that defines a point in a two-dimensional plane. Represents an ordered pair of floating-point x- and y-coordinates that defines a point in a two-dimensional plane. Stores a set of four integers that represent the location and size of a rectangle. Stores a set of four floating-point numbers that represent the location and size of a rectangle. For more advanced region functions, use a Region object. Stores an ordered pair of integers, which specify a Height and Width. Stores an ordered pair of floating-point numbers, typically the width and height of a rectangle.\n\nSpecifies alignment of content on the drawing surface. Determines how the source color in a copy pixel operation is combined with the destination color to result in a final color. Specifies the unit of measure for the given data. Specifies how much an image is rotated and the axis used to flip the image. Provides icon identifiers for use with GetStockIcon(StockIconId, StockIconOptions). Provides options for use with GetStockIcon(StockIconId, StockIconOptions). Specifies the alignment of a text string relative to its layout rectangle. The StringDigitSubstitute enumeration specifies how to substitute digits in a string according to a user's locale or language. Specifies the display and layout information for text strings. Specifies how to trim characters from a string that does not completely fit into a layout shape. Specifies the units of measure for a text string.\n\nThe namespace has some limitations for certain operating systems and application types.\n• None On Windows, depends on the GDI+ native library, which is shipped as part of the OS. Some Windows SKUs, like Windows Server Core or Windows Nano, don't include this native library as part of the OS. If you use this namespace and the library can't be loaded, exceptions will be thrown at run time.\n• None Some types in the namespace rely on GDI+, which is not supported in Windows services and ASP.NET Core and ASP.NET apps. These types are in the System.Drawing.Common NuGet package and include System.Drawing.Bitmap and System.Drawing.Font. However, primitive types in the namespace, such as System.Drawing.Color, System.Drawing.Size, System.Drawing.Point, and System.Drawing.Rectangle, can be used in any application.\n• None In .NET 5 and previous versions, the System.Drawing.Common NuGet package works on Windows, Linux, and macOS. However, there are some platform differences. On Linux and macOS, the GDI+ functionality is implemented by the libgdiplus) library. This library is not installed by default in most Linux distributions and doesn't support all the functionality of GDI+ on Windows and macOS. There are also platforms where libgdiplus is not available at all. To use types from the System.Drawing.Common package on Linux and macOS, you must install libgdiplus separately. For more information, see Install .NET on Linux or Install .NET on macOS.\n• None In .NET 6 and later versions, the System.Drawing.Common NuGet package is only supported on Windows operating systems. For more information, see System.Drawing.Common only supported on Windows. If you can't use with your application, recommended alternatives include ImageSharp, SkiaSharp, Windows Imaging Components, and Microsoft.Maui.Graphics.\n\nThe Graphics class provides methods for drawing to the display device. Classes such as Rectangle and Point encapsulate GDI+ primitives. The Pen class is used to draw lines and curves, while classes derived from the abstract class Brush are used to fill the interiors of shapes."
    },
    {
        "link": "https://stackoverflow.com/questions/32739331/image-coloring-in-c-sharp",
        "document": "What you are doing is just creating a second image with the same size of the original one. This second image is filled with a green color (but no alpha - so it's just transparent). I suspect that you hoped for the method to recolor the original image but this is not the case. This method will just make pixels of a certain color transparent. This is not the image's opacity.\n\nSo these are two images - one beside the other, they have nothing to do with each other (besides of the same size).\n\nSo you could manipulate the image in the variable directly (you may copy it to preserve the original one) by creating a object from your with which you can draw a semi-transparent color over the image.\n\nBut I would heavily insist that you use a image processing library for the image manipulation you want to achieve. So please check the free imageprocessor.org. Their hue filter might be what you want to have."
    },
    {
        "link": "https://stackoverflow.com/questions/58849290/manipulate-a-system-drawing-image-and-save-with-same-imageformat",
        "document": "Let's say I want a method that does some manipulation on an image by messing with its pixel values and then returns an image which is otherwise the \"same\" (equal , , , etc.).\n\nI've been finding this remarkably difficult to do because to manipulate its pixels I want to use and I can't find a way to create a which has the same .\n\nand while each of them works some of the time for my test on my 1,000 random files (PNGs, JPGs, etc.), all of them fail\n\nsome of the time and I can't figure out why that is.\n\nIs there any solution that doesn't involve one of\n• Serializing and deserializing (Yes, I've seen this)\n• If is a local file, creating copy in storage or something like that"
    },
    {
        "link": "https://hanselman.com/blog/how-do-you-use-systemdrawing-in-net-core",
        "document": "I've been doing .NET image processing since the beginning. In fact I wrote about it over 13 years ago on this blog when I talked about Compositing two images into one from the ASP.NET Server Side and in it I used System.Drawing to do the work. For over a decade folks using System.Drawing were just using it as a thin wrapper over GDI (Graphics Device Interface) which were very old Win32 (Windows) unmanaged drawing APIs. We use them because they work fine.\n\nFor a while there was a package called CoreCompat.System.Drawing that was a .NET Core port of a Mono version of System.Drawing.\n\nHowever, since then Microsoft has released System.Drawing.Common to provide access to GDI+ graphics functionality cross-platform.\n\nThere is a lot of existing code - mine included - that makes assumptions that .NET would only ever run on Windows. Using System.Drawing was one of those things. The \"Windows Compatibility Pack\" is a package meant for developers that need to port existing .NET Framework code to .NET Core. Some of the APIs remain Windows only but others will allow you to take existing code and make it cross-platform with a minimum of trouble.\n\nHere's a super simple app that resizes a PNG to 128x128. However, it's a .NET Core app and it runs in both Windows and Linux (Ubuntu!)\n\nHere it is running on Ubuntu:\n\nNOTE that on Ubuntu (and other Linuxes) you may need to install some native dependencies as System.Drawing sits on top of native libraries\n\nThere's lots of great options for image processing on .NET Core now! It's important to understand that this System.Drawing layer is great for existing System.Drawing code, but you probably shouldn't write NEW image management code with it. Instead, consider one of the great other open source options.\n• ImageSharp - A cross-platform library for the processing of image files; written in C#\n• Compared to ImageSharp has been able to develop something much more flexible, easier to code against, and much, much less prone to memory leaks. Gone are system-wide process-locks; ImageSharp images are thread-safe and fully supported in web environments.\n\nHere's how you'd resize something with ImageSharp:\n\nIt's awesome that there are so many choices with .NET Core now!\n\nSponsor: Rider 2018.2 is here! Publishing to IIS, Docker support in the debugger, built-in spell checking, MacBook Touch Bar support, full C# 7.3 support, advanced Unity support, and more."
    },
    {
        "link": "https://codeproject.com/Tips/635715/Steganography-Simple-Implementation-in-Csharp",
        "document": "Steganography is the art and science of hiding information by embedding messages within others. Steganography works by replacing bits of useless or unused data in regular computer files with bits of different, invisible information. This hidden information can be plain text, cipher text, or even images [*] .\n\nI've implemented two main methods for that purpose: and . You can find the full and documented code with a running example attached to this tip.\n\nIf you download the attached sample project, it allows you to open an image, write your text or import a text file, optionally encrypt your text before starting processing, embed the text in the image, and finally, save the result image in either PNG or BMP formats. Then you can reopen that image and extract the text from it.\n\nCaution: Don't save the result image in a lossy format (like JPEG); your data will be lost. Saving it as PNG is pretty good.\n\nAs mentioned before, Steganography works by replacing bits of useless or unused data in regular computer files with bits of our important data. In our case, our data will be the plain text that we need to hide, and the unused data is the least significant bits (LSBs) in the image pixels.\n\nWhat is the LSB?\n\nIn order to find the decimal value of a binary value, we sum all 1s in the binary value but multiplied by 2n, where n is the position/index of the 1 from the right, starting from zero. For example, to convert 01100101 to decimal, then starting from the right, the equivalent decimal value is 1x20 + 1x22 + 1x25 + 1x26 = 1 + 4 + 32 + 64 = 101\n\nThe least significant bit (LSB) is the bit that when flipped from 0 to 1 or from 1 to 0, then no significant change will occur on the total value. It's the bit on the rightmost, that when flipped, the value will be only affected by 1 to be 100 instead of 101. This means that the image will not be significantly affected when we reserve this bit for our purpose. Where the most significant bit (MSB) is bit on the leftmost, that when flipped, the value will be affected by 128 (1x27) to be 229 instead of 101.\n\nWhen we try to hide our data in an image (as in our case), then we need enough budget of LSBs to hide our data in. These bits are located in the image pixels. Since each pixel has three elements (R, G, and B that represent the Red, Green, and Blue elements of the pixel consecutively, assuming non-transparent image), each of these elements can have a value between 0 and 255. Now, assume that the image was 300 pixels width by 400 pixels height, then we'll have 300 x 400 x 3 = 360000 LSBs. And as each character can be represented by 8 bits, then that image can hide 360000 / 8 = 45000 characters!\n• None\n• Loop through the pixels of the image. In each iteration, get the RGB values separated each in a separate integer.\n• For each of R, G, and B, make the LSB equals to 0. These bits will be used in hiding characters.\n• Get the current character and convert it to integer. Then hide its 8 bits in R1, G1, B1, R2, G2, B2, R3, G3, where the numbers refer to the numbers of the pixels. In each LSB of these elements (from R1 to G3), hide the bits of the character consecutively.\n• When the 8 bits of the character are processed, jump to the next character, and repeat the process until the whole text is processed.\n• The text can be hidden in a small part of the image according to the length of that text. So, there must be something to indicate that here we reached the end of the text. The indicator is simply 8 consecutive zeros. This will be needed when extracting the text from the image.\n• None Extracting the text from the image It's more simple than hiding. Just pass through the pixels of the image until you find 8 consecutive zeros. As you are passing, pick the LSB from each pixel element (R, G, B) and attach it into an empty value. When the 8 bits of this value are done, convert it back to character, then add that character to the result text you are seeking."
    },
    {
        "link": "https://linkedin.com/pulse/least-significant-bit-lsb-technique-steganography-explained-raj-saha-4kdoc",
        "document": "Let's walk through the complete process of hiding the word \"cat\" in an image using LSB (Least Significant Bit) steganography. I'll break it down step by step, including an example, so it's easy to understand. We'll use Steghide for this example, which is a popular tool, but the process can be similar in other software.\n\nSteps to Hide the Word \"cat\" in an Image:\n\n2. Word \"cat\" is converted to Binary using ASCII Encoding\n• First, you need to convert the characters in \"cat\" to their binary form using ASCII encoding. The ASCII of 'c' is '99', 'a' is '97' and 't' is '116'\n• So, the binary representation of ASCII values of the word \"cat\" is shown below:\n\n3. Pixel Value is Extracted from the image\n• The cover image is made up of pixels, and each pixel has RGB (Red, Green, Blue) values. Each RGB value is an 8-bit number (ranging from 0 to 255).\n• Example of one pixel’s RGB values in binary: Red: 10100101, Green: 11001010, Blue: 11101000\n• The last bit in each of these values is the Least Significant Bit (LSB).\n\n4. The Binary Data is Embedded in the Pixels\n• For each bit of the binary message, replace the LSB of the RGB values of the image pixels with the bits of the message.\n• Take the first 8 bits of the binary message (01100011), which corresponds to the letter 'c'. Start embedding these bits into the least significant bits of the image’s pixels.\n\nHere each of the LSB of the RGB values is getting replaced by the corresponding bits of the letter 'c'. Then the process will be continued until all the letter's i.e. 'c', 'a', and 't' LSB are replaced.\n• Once you have embedded the entire binary message, the modified image (called the stego image) is saved. This image will appear almost identical to the original cover image, but it contains the hidden message in its least significant bits.\n• To retrieve the hidden message from the stego image: Read the least significant bits of the image’s pixels. Combine the bits into groups of 8 to recreate the original binary message. Convert the binary message back to text (ASCII) to get the word \"cat\".\n\nStep-by-Step Instructions for Using Steghide on Windows:\n• Once downloaded, extract the contents of the ZIP file to a folder on your computer (e.g., C:\\steghide). You don’t need to install anything; Steghide is a standalone executable.\n• Select an image in BMP, JPG, or another format that Steghide supports. For example, let’s assume the image is called cover.jpg and keep the image in the same folder where you extract the steghide zip file.\n• Open a text editor like Notepad and type your secret message (e.g., \"cat\"). Save this file as secret.txt in the same folder as your cover image.\n• Open cmd in the same folder where you extracted the steghide files. For that open the folder where you extracted the steghide and click on the address bar, type cmd and hit enter.\n• -ef: Specifies the file to embed (your secret message).\n• Set a Passphrase: Steghide will prompt you to enter a passphrase. This passphrase is optional but provides additional security. If you want to skip it, just press Enter.\n• Check the Output: If successful, you’ll see a message like below:"
    },
    {
        "link": "https://stackoverflow.com/questions/19744326/set-least-significant-bit-in-c",
        "document": "I write a simple steganography tool in C with bmp images.\n\nI read the image to memory and the text to hide in char bytes[8] one character at a time.\n\nThen i 'll go to the first image byte( it every time) to put the bytes[0] to LSB, then the next one etc.\n\nIf the i have to set the last 1 to 0. This can be with\n\nbut if the or the xor doesent work because\n\nI 'm confused how to set the case. I need a operator to make the last bit every time 0 and not touch the others in case LSB is 1 or 0."
    },
    {
        "link": "https://medium.com/@renantkn/lsb-steganography-hiding-a-message-in-the-pixels-of-an-image-4722a8567046",
        "document": "In this article you will learn how the LSB (Least Significant Bit) method works and how to use the PyLSB software to read and write secret messages in the pixels of an image.\n\nSteganography is the practice of concealing a file, message, image, or video within another file, message, image, or video. The word steganography comes from Greek steganographia, which combines the words steganós, meaning “covered or concealed”, and -graphia meaning “writing”.\n\nLet’s start with a picture. This is the original image:\n\nThis is the modified image with the hidden message:\n\nBut wait, they look exactly the same, right? That is good, it means the changes made in the image were not perceptible by human eyes.\n\nIf you want to understand better how the LSB works check the following explanation."
    },
    {
        "link": "https://stackoverflow.com/questions/49638628/understanding-image-steganography-by-lsb-substitution-method",
        "document": "Your confusion stems from the fact that all 3 sources you're looking at talk about something different.\n\nThis describes the most basic form of LSB pixel substitution steganography. Each pixel is described by 8 bits. For each pixel we clear out the LSB and substitute it with one bit of the secret message. For example,\n\nWhere , , , and are bits and we don't care what is.\n\nThis is the generalised form of LSB pixel substitution steganography. Instead of embedding the secret in the LSB, you embed it in the k-most LSBs. If , then we have the simple form described above. The mathematical equations is this section mean the following:\n• We have an image of size MxN, with each pixel having a value between 0 and 255 (8 bits).\n• We have an n-bit message, with each bit being either 0 or 1. For example, for 12 bits it'd be .\n• Since we'll be embedding k bits per pixel, we group our message bits in groups of k. Assume that , then, . Obviously, each group can have a value between 0 and 2^k - 1. Furthermore, the number of groups in cannot exceed the size of our image, or we won't be able to embed the whole message.\n• We clear out the last k bits from each pixel and we substitute them with one group of . When you take the modulo of a number with 2^k, the remainder you get is the last k bits of the original number. So by subtracting them, we clear out the last k bits.\n• Similar to the previous step, if we want to extract the message, we take the modulo of each pixel with 2^k to get the last k bits, where we have embedded our message. It's trivial to stitch these bit groups and obtain the original message, , back.\n\nThis code hides an image of size MxN to a cover image of the same size. The idea here is the MSB holds the most information about the image and the LSB the least. For example, this is the bit plane decomposition of this image.\n\nIf we decide to hide k bits from the secret image, we want those to be the k most significant bits. Similarly, we can hide them in the k least significant bits of the cover image. The larger the k value, the more bits you'll hide from the secret for a more faithful reconstruction, but the more distortion you'll introduce to the cover.\n\nLet's break down the nested functions in the code to see what they do. I'll use instead of to maintain consistency with the above sections.\n\ncreates the complement of 2^k - 1 for 8 bits. For example, if k = 3, then 2^k - 1 is like having the bits and obviously its complement is . We're going to use this number as a mask, so .\n\nzeroes out the last k bits of the cover image, . This is the bitwise AND operation and the reason we called the second part a mask is because anywhere we have a 1, we keep the original bit and anywhere we have a 0, we get a 0. Let's call .\n\nkeeps only the k most significant bits of the secret. For example, for k = 3 we achieve . This is done by shifting the number 5 places to the right. This is a logical shift operation. We'll call this result .\n\nFinally, simply combines the two together. The cleared pixels have the last k bits cleared and the secret is at most k bits, so the two parts don't interact; we get a pure combination."
    }
]