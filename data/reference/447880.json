[
    {
        "link": "https://stackoverflow.com/questions/1637807/modifying-list-while-iterating",
        "document": "Never alter the container you're looping on, because iterators on that container are not going to be informed of your alterations and, as you've noticed, that's quite likely to produce a very different loop and/or an incorrect one. In normal cases, looping on a copy of the container helps, but in your case it's clear that you don't want that, as the container will be empty after 50 legs of the loop and if you then try popping again you'll get an exception.\n\nWhat's anything BUT clear is, what behavior are you trying to achieve, if any?! Maybe you can express your desires with a ...?"
    },
    {
        "link": "https://stackoverflow.com/questions/4081217/how-to-modify-list-entries-during-for-loop",
        "document": "Since the loop below only modifies elements already seen, it would be considered acceptable:\n\nWhich is different from:\n\nin that it doesn't require the creation of a temporary list and an assignment of it to replace the original, although it does require more indexing operations.\n\nCaution: Although you can modify entries this way, you can't change the number of items in the without risking the chance of encountering problems.\n\nHere's an example of what I mean—deleting an entry messes-up the indexing from that point on:\n\nSince this is a fairly popular answer, here's how to effectively delete entries \"in-place\" (even though that's not exactly the question):\n\nSee How to remove items from a list while iterating?."
    },
    {
        "link": "https://geeksforgeeks.org/iterate-over-a-list-in-python",
        "document": "Python provides several ways to iterate over list. The simplest and the most common way to iterate over a list is to use a for loop. This method allows us to access each element in the list directly.\n\nExample: Print all elements in the list one by one using for loop.\n\nLet’s see other different ways to iterate over a list in Python.\n\nWe can use the range() method with for loop to traverse the list. This method allow us to access elements by their index, which is useful if we need to know the position of an element or modify the list in place.\n\nThis method is similar to the above method. Here we are using a while loop to iterate through a list. We first need to find the length of list using len(), then start at index 0 and access each item by its index then incrementing the index by 1 after each iteration.\n\nWe can also use the enumerate() function to iterate through the list. This method provides both the index (i) and the value (val) of each element during the loop.\n\nList comprehension is similar to for loop. It provides the shortest syntax for looping through list.\n\nNote: This method is not a recommended way to iterate through lists as it creates a new list (extra space).\n• None Iterate Over a List of Lists in Python\n• None Iterate through list without using the increment variable"
    },
    {
        "link": "https://realpython.com/python-for-loop",
        "document": "Python’s loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak loops further with features like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• Python’s loop iterates over items in a data collection, allowing you to execute code for each item.\n• To iterate from to , you use the construct.\n• To repeat code a number of times without processing the data of an iterable, use the construct.\n• To do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\n\nIn this tutorial, you’ll gain practical knowledge of using loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\n\nGetting Started With the Python Loop In programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection. In Python, loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a loop is shown below: In this syntax, is the loop variable. In each iteration, this variable takes the value of the current item in , which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is a variable that holds the current item in the input iterable.\n• is a keyword that connects the loop variable with the iterable.\n• is a data collection that can be iterated over.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a list: In this example, is the loop variable, while the list is the target collection. Each time through the loop, takes on a successive item from . In this loop, the body consists of a call to that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it. However, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration. Note: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the special method. Similarly, iterators support the iterator protocol that’s based on the and special methods. Both iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in loops because they drive the iteration process. A deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial. You can also have a loop with multiple loop variables: In this loop, you have two loop variables, and . Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration. Sometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body: In this example, the target iterable is an empty list. The loop checks whether the iterable has items. If that’s the case, then the loop runs once for each item. If the iterable has no items, then the loop body doesn’t run, and the program’s execution flow jumps onto the statement after the loop. Now that you know the basic syntax of loops, it’s time to dive into some practical examples. In the following section, you’ll learn how to use loops with the most common built-in data collections in Python.\n\nWhen writing Python code, you’ll often need to iterate over built-in data types such as lists, tuples, strings, numeric ranges, dictionaries, and sets. All of them support iteration, and you can feed them into a loop. In the next sections, you’ll learn how to tackle this requirement in a Pythonic way. When it comes to iterating over sequence data types like lists, tuples, strings, and ranges, the iteration happens in the same order that the items appear in the sequence. Consider the following example where you iterate over the numbers in a list: In this example, the iteration goes through the list in the definition order, starting with and ending with . Note that to iterate over a sequence in Python, you don’t need to be aware of the index of each item as in other languages where loops often rely on indices. Often, you use plural nouns to name lists. This naming practice allows you to use singular nouns as the loop variable, making your code descriptive and readable. Note: To learn more about using lists, check out Python’s Data Type: A Deep Dive With Examples. You’ll note the same behavior with other built-in sequences: In these examples, you iterate over a tuple, string, and numeric range. Again, the loop traverses the sequence in the order of definition. Note: For more information about tuples, strings, and ranges, you can check out the following tutorials: Tuples are often used to represent rows of data. In the example above, the tuple holds data about a person. You can iterate over each field using a readable loop. When it comes to iterating over string objects, the loop lets you process the string on a character-by-character basis. Finally, iterating over a numeric range is sometimes a requirement, especially when you need to iterate a given number of times and need control over the consecutive index. When traversing dictionaries with a loop, you’ll find that you can iterate over the keys, values, and items of the dictionary at hand. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. You’ll have two different ways to iterate over the keys of a dictionary. You can either use: The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. While both approaches are equivalent, the first one is more commonly used, whereas the second might be more readable and explicit. In both loops, you can access the dictionary values using the keys: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. You can use the method to feed the loop when you need to iterate over the values of a dictionary: The method lets you traverse the values in the target dictionary. In this example, you iterate over team names one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, iterating over both keys and values in a Python dictionary is a common requirement. In this case, the recommended and most Pythonic approach is to use the method in a loop like the following: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable. When it comes to iterating over sets, you only have to keep in mind that sets are unordered data types. This means that looping in order isn’t guaranteed: As you can see, the loop goes through the elements of your set in a different order than they were inserted. So, you can’t rely on the order of the elements when traversing sets in Python.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. These features include the and statements and the clause, which you’ll learn about in the following sections. You’ll also learn that loops can be nested inside one another. This feature can be pretty useful in situations where you need to iterate over nested data structures like lists of lists. The statement immediately exits the loop and jumps to the first statement after the loop. For example, say that you want to write a loop to determine whether a number is in a list. To avoid unnecessary work, the loop should terminate once it finds the target value. You can do this with the statement: In this example, the statement jumps out of the loop as soon as the target number is found. The remaining values, and , aren’t processed. You can think of the statement as a way to short-circuit the loop execution once you’ve gotten the desired result. It’s important to note that it makes little sense to have statements outside conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The statement terminates the current iteration and proceeds to the next one. For example, if you have a list of numbers and only want to process the even ones, you can use a statement to skip the odd numbers: In this example, the code that processes the numbers is only reached if the number is even. Otherwise, the statement skips that code and jumps right into the next iteration. Again, it doesn’t make much sense to have a statement without wrapping it in a conditional. If you do so, the code after the statement will be unreachable and never run. In Python, loops can have an clause at the end. The clause will only run if the loop terminates because of the exhaustion of the input iterable. This feature is useful when you have a statement that can terminate the loop in certain situations. If the loop doesn’t break, then you can run additional code in the clause. To illustrate, say that you want to continue improving the loop that determines whether a number is in a list. You’d like to explicitly inform the user if the number isn’t in the list. You can do this with the clause: The clause won’t run if the loop breaks out with the statement. It only runs if the loop terminates normally, allowing you to inform the user that the target number wasn’t found. It doesn’t make sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. You can also have nested loops. In the example below, you create a multiplication table that shows the products of all combinations of integers up to ten using nested loops. The outer loop iterates over the numbers between and , and the inner loop calculates and prints the products: In this example, you use two nested loops. Together, they create a two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These represent the rows in the table, and you can see those numbers at the beginning of each row. In the inner loop, you calculate the products for the current by iterating from the itself up to its tenth multiple. Then, you format each product using the format specifier. This ensures the table is nicely aligned. By setting to an empty string, you skip the newline until the products on the current row are printed. After printing all products for a row, you use without arguments to move to the next row.\n\nWhen people switch from other programming languages to Python, they often write loops like they did in their previous language. This practice makes Python code look odd and hard to read. In the following sections, you’ll explore some looping techniques, practices, and tips that are considered Pythonic. These techniques can make your Python code look clearer, more elegant, and more efficient. Iterating With Indices: The Pythonic Way Sometimes, you need to use the indices of items when you iterate over a sequence with a Python loop. Up to this point, you’ve seen examples where you can access the items but don’t know their corresponding indices. To get both the item and its index, you can end up writing a loop like the one shown in the following example: This loop gets the job done, but it’s not as clean or readable as you’d expect from Python code. Fortunately, there’s a better way—the built-in function: The function takes an iterable as an argument and generates tuples of the form . Note that the loop reads almost like plain English, which makes your code way more Pythonic than the previous version using . Note: To learn more about working with , check out the Python : Simplify Loops That Need Counters tutorial. The function also takes an optional argument called that lets you tweak the initial value. This feature is useful when you need to create counts. Consider the following example that mimics an option menu for a command-line application: In this example, instead of using to produce zero-based indices, you start the count at . From the end user’s perspective, starting the menu at is the natural way to go. Looping Over Several Iterables in Parallel Looping through two or more iterables in parallel may be another common task you encounter in Python programming. To do this, you can use the built-in function, which takes two or more iterables and yields tuples that combine items from each iterable. Note: To learn more about , check out the Using the Python zip() Function for Parallel Iteration tutorial. Consider the following toy example: In this example, you use to create an iterator that produces tuples of the form . In this case, the values are taken from , and the values are taken from . There may be times when you need to iterate over multiple iterables sequentially in a single loop. In such cases, you can use the function from Python’s module. Note: To learn more about the module and the tools it provides, check out the Python By Example tutorial. For example, say that you have several lists of numbers and want to calculate the square of each number in all lists. You can use as follows: This loops over all three lists in sequence and prints the square of each value. You can also use to work through a list of lists. Say that you, again, need to process each value in a sequence and calculate its square: In this example, you use to iterate over the rows of the matrix. To feed the rows into , you use the unpacking operator ( ). Inside the loop, you calculate and print the square of each value. Using , like in this example, essentially flattens the matrix into a single iterable, helping you avoid a nested loop, which can be difficult to read and understand in some contexts. Iteration is all about repeating some fragment of code multiple times. As you’ve learned so far, loops are designed to repeat a given set of actions on the items of an iterable. However, you can also use this type of loop to quickly iterate a specific number of times. This is useful when you need to repeat a bunch of statements, but they don’t operate on the items of an iterable. Here’s a fun example about Penny and Sheldon to illustrate this: This loop runs three times and repeats a series of statements that don’t operate on any iterable. Note that the loop variable is a single underscore character in this example. This variable name communicates that you don’t need to use the loop variable inside the loop. It’s a throwaway variable. With this looping construct that takes advantage of , you have full control over the number of times your code runs. Iterating over the items of an iterable in reverse or sorted order is also a common requirement in programming. To achieve this, you can combine a loop with the built-in or function, respectively. Note: To learn more about and , check out the following tutorials:\n• Reverse Strings in Python: , Slicing, and More\n• How to Use and in Python For example, say that you’re working on a text editor and want to implement a basic Undo option. You can implement it with the function and a loop like the following: In this example, you have a list of hypothetical user actions in a text editor. The actions are stored in a list from oldest to newest. To implement the Undo operation, you need to reverse the actions, which you do with . To iterate in sorted order, say that you have a dictionary that maps student names to their corresponding average grades. You need to create a quick report and want to sort the data from highest to lowest grades. For this, you can do something like the following: The function returns a list of sorted values. In this example, you sort the dictionary by its values in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . You also set the argument to so that the function stores the data in reverse order. In this case, this means that the grades are ordered in descending order. The loop iterates over the sorted data and generates a nicely formatted report using an f-string with a custom format specifier.\n\nWhen working with loops in your Python code, you may encounter some issues related to incorrect ways to use this tool. Some of the most common bad practices and incorrect assumptions include:\n• Modifying the loop collection or iterable during iteration\n• Changing the loop variable to affect the underlying collection\n• Ignoring possible exceptions that may occur In the following sections, you’ll explore these pitfalls and how to avoid them in your loops. Python has mutable collections, such as lists and dictionaries, that you can modify in place. You may want to change a list while looping over it. In this situation, you need to distinguish between safe and unsafe changes. For example, say that you have a list of names and want to convert them into uppercase. You may think of doing something like the following: In this example, you only change the existing items in the list without adding or removing any. This operation is safe. However, modifying a mutable iterable like a list while iterating over it always raises a warning. Issues may appear when you add or remove items from a list while iterating over it. To understand why this is best avoided, say that you want to remove all the even numbers from a list. You might write the following code: After running the loop, some even numbers remain, even though you expected the list to be empty. On the first iteration, is removed, and the list shifts left, becoming . The loop then jumps to the next item, skipping and processing instead. Then is removed, and the list shifts again, becoming . The iteration ends before reaching . When you need to resize a list during iteration like in the example above, it’s recommended to create a copy of the list: The slicing operator ( ) with no indices creates a copy of the original list for iteration purposes. The loop traverses the copy while removing values from the original list. In some cases, creating a copy of the input list isn’t enough. Say that on top of removing even numbers, you want to calculate the square of odd numbers. You might modify the previous loop as shown in the following code: This time, you use to generate index-item pairs. Then, you think of using the index to update the value of a given item. However, the code fails with a exception. Creating a copy of the input list isn’t enough in this case. You’d have to make a separate list to store the result: In this new loop implementation, you’re using a new list to store the result. Because of this, you don’t have to remove items anymore. You add the square values to the end of the new list using the method. Python doesn’t allow you to add or remove items from a dictionary while you’re iterating through it: If you try to expand or shrink a dictionary during iteration, you get a exception. Again, you can work around this by creating a copy of the dictionary using the method or by building a new dictionary with the resulting data. Changing the loop variable in the loop body doesn’t have an effect on the original data: In this example, the highlighted line changes the loop variable, . This change doesn’t affect the original data in your list of names. The loop variable is just a temporary reference to the current item in the iterable, and reassigning it doesn’t affect the loop iterable. If an exception occurs in a loop body and isn’t handled, the loop will terminate prematurely, skipping subsequent iterations. This result can generate unexpected issues, especially when you rely on the loop to process data, perform logging, or run cleanup actions in each iteration. As an example, say that you want to process some text files in a loop: : [Errno 2] No such file or directory: 'file1.txt' In this example, none of the files exist in your working directory. The loop tries to process the first file and fails with a exception. Because the exception wasn’t handled properly, the loop terminates in the first iteration, skipping the rest of the files in the list. To avoid this behavior, you need to catch and handle the exception: In this new implementation, the loop catches any exception and prints an error message to the screen. The loop runs entirely without abrupt interruptions."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/u11seo/trying_to_learn_to_modify_a_list_with_a_for_loop",
        "document": "I have a list and would like to for loop to change all of the 0s to 1s\n\nbut no changes happen\n\nthe if statement is catching the 0s but not changing them to 1s\n\nidk why \"i = 1\" is not working"
    },
    {
        "link": "https://realpython.com/python-append",
        "document": "Adding items to a list is a fairly common task in Python, so the language provides a bunch of methods and operators that can help you out with this operation. One of those methods is . With , you can add items to the end of an existing list object. You can also use in a loop to populate lists programmatically.\n\nIn this tutorial, you’ll learn how to:\n• Work with in and\n\nYou’ll also code some examples of how to use in practice. With this knowledge, you’ll be able to effectively use in your programs.\n\nPython’s takes an object as an argument and adds it to the end of an existing list, right after its last element: Every time you call on an existing list, the method adds a new item to the end, or right side, of the list. The following diagram illustrates the process: Python lists reserve extra space for new items at the end of the list. A call to will place new items in the available space. In practice, you can use to add any kind of object to a given list: Lists are sequences that can hold different data types and Python objects, so you can use to add any object to a given list. In this example, you first add an integer number, then a string, and finally a floating-point number. However, you can also add another list, a dictionary, a tuple, a user-defined object, and so on. Using is equivalent to the following operation: In the highlighted line, you perform two operations at the same time:\n• You take a slice from using the expression .\n• You assign an iterable to that slice. The slicing operation takes the space after the last item in . Meanwhile, the assignment operation unpacks the items in the list to the right of the assignment operator and adds them to . However, there’s an important difference between using this kind of assignment and using . With the assignment, you can add several items to the end of your list at once: In this example, the highlighted line takes a slice from the end of , unpacks the items in the list on the right side, and adds them to the slice as individual items. With , you can add a number, list, tuple, dictionary, user-defined object, or any other object to an existing list. However, you need to keep in mind that adds only a single item or object at a time: What happens here is that adds the tuple object to the end of your target list, . What if you want to add each item in to the end of as an individual item and get ? In that case, you can use : takes an iterable as an argument, unpacks its items, and adds them to the end of your target list. This operation is equivalent to , which is the same technique you saw in the previous section. In practice, does its work in place by modifying and growing the underlying list. This means that doesn’t return a new list with an additional new item at the end. It returns : Like with several similar methods, changes the underlying list in place. Trying to use the return value of is a common mistake when it comes to learning how mutable sequence types work. Keeping this behavior of in mind will help you prevent errors in your code.\n\nA common problem that you might face when working with lists in Python is how to populate them with several items for further processing. There are two ways to do this: In the next few sections, you’ll learn how and when to use these techniques to create and populate Python lists from scratch. One common use case of is to completely populate an empty list using a loop. Inside the loop, you can manipulate the data and use to add successive results to the list. Say you need to create a function that takes a sequence of numbers and returns a list containing the square root of each number: Here, you define , which takes a list of as an argument. Inside , you create an empty list called and start a loop that iterates over the items in . In each iteration, you use to calculate the square root of the current number and then use to add the result to . Once the loop finishes, you return the resulting list. Note: In the above example, you use from . Python’s module ships in the standard library and provides math-related functionalities. If you want to dive deeper into , then check out The Python math Module: Everything You Need to Know. This way of populating lists is fairly common in Python. However, the language provides some convenient constructs that can make the process a lot more efficient and Pythonic. One of these constructs is a list comprehension, which you’ll see in action in the next section. In practice, you often replace with a list comprehension when creating a list from scratch and populating it. With a list comprehension, you can reimplement like this: The list comprehension inside creates a list containing the square root of for each in . This reads almost like plain English. Also, this new implementation will be more efficient in terms of processing time than the implementation that uses along with a loop. Note: Python also offers other kinds of comprehensions, such as set comprehensions, dictionary comprehensions, and generator expressions. To turn into a list comprehension, you just need to put its argument followed by the loop header (without the colon) inside a pair of square brackets. Even though list comprehensions can be more readable and efficient than for populating lists, there might be situations where is a better choice. Suppose you need to provide your users with detailed information about the progress of calculating the square root of the input list of numbers. To report the operation progress, you can use : Now think of how you can turn the body of into a list comprehension. Using inside a list comprehension doesn’t seem coherent or even possible unless you wrap part of the code in a helper function. So, in this example, using is the right choice. The moral behind the above example is that there are some situations in which you can’t replace with a list comprehension or with any other construct.\n\nSo far, you’ve learned how to use to add a single item to a list or to populate lists from scratch. Now it’s time for a different and more specific kind of example. In this section, you’ll learn how to use a Python list to create stack and queue data structures with the minimal required functionality using and . A stack is a data structure that stores items on top of each other. Items come in and out of the stack in a Last-In/First-Out (LIFO) fashion. Typically, a stack implements two main operations:\n• adds an item to the top, or end, of the stack.\n• removes and returns the item at the top of the stack. In a list, is equivalent to a operation, so you can use it to push items onto the stack. Lists also provide , which optionally takes an integer index as an argument. It returns the item at that index in the underlying list and also removes the item: If you supply an integer index as an argument to , then the method returns and removes the item at that index in the list. Calling without an argument returns the last item in the list. Note that also removes the item from the underlying list. Finally, if you call on an empty list, then you’ll get an . With this knowledge, you’re ready to implement a stack using and . Here’s a class that defines a stack. The class provides and operations: In , you first initialize the instance attribute . This attribute holds an empty list that you’ll use to store the items in the stack. Then you code , which implements the operation using on . You also implement the operation by calling on the underlying list, . In this case, you use a and block to handle the that occurs when you call on an empty list. Note: In Python, using exceptions to control the flow of a program is a common pattern. Python developers favor this coding style, known as EAFP (Easier to Ask for Forgiveness than Permission), over the coding style known as LBYL (Look Before You Leap). To learn more about these two coding styles, check out LBYL vs EAFP: Preventing or Handling Errors in Python. EAFP can help you prevent race conditions, improve the general performance of a program or a code fragment, and prevent errors from passing silently. You take advantage of a couple of special methods here. The special method provides the required functionality for retrieving the length of the internal list . The special method allows you to provide a user-friendly string representation of the stack when printing the data structure to the screen. Here are some examples of how you can use in practice: # Push items onto the top of the stack # Retrieve the length of the stack # Pop items from the top of the stack That’s it! You’ve coded a stack data structure that implements the and operations. It also provides functionality to get the length of the underlying list and to print the entire stack in a user-friendly manner. Queues are data structures that commonly manage their items in a First-In/First-Out (FIFO) fashion. Queues work like a pipe in which you push in new items at one end, and old items pop out from the other end. Adding an item to the end of a queue is known as an operation, and removing an item from the front, or beginning, of a queue is known as a operation. You can enqueue items using and dequeue them using . This time, you need to provide as an argument to just to make it retrieve the first item in the list instead of the last item. Here’s a class that implements a queue data structure using a list to store its items: This class is quite similar to your . The main difference is that takes as an argument to return and removes the first item in the underlying list, , rather than the last. Note: Using on a Python list isn’t the most efficient way of consuming list items. Luckily, Python’s module provides a data structure called , which implements as an efficient way of consuming items from the beginning of the . You’ll learn more about using deques a little later in the tutorial. The rest of the implementation is almost identical but uses appropriate names, such as for adding items and for removing them. You can use the same way you used in the above section: just call to add items and to retrieve and remove them.\n\nUsing in Other Data Structures Other Python data structures also implement . The operating principle is the same as the traditional in a list. The method adds a single item to the end of the underlying data structure. However, there are some subtle differences. In the next two sections, you’ll learn how works in other data structures, such as and . Python’s provides a sequence-like data structure that can compactly represent an array of values. These values must be of the same data type, which is limited to C-style data types, such as characters, integer numbers, and floating-point numbers. takes the following two arguments: A single-character code that identifies the data type that the array can store A list, bytes-like object, or iterable that serves as an initializer The documentation of provides complete information about all the allowed type codes that you can use when creating arrays. The following example uses the type code to create an array of integer numbers: To create an array, you need to provide a single-character code to define the data type of the values in the array. You can also provide an optional list of values with the appropriate type to initialize the array. Arrays support most list operations, such as slicing and indexing. Like lists, also provides a method called . This method works similarly to its list counterpart, adding a single value to the end of the underlying array. However, the value must have a data type that’s compatible with the existing values in the array. Otherwise, you’ll get a . For example, if you have an array with integer numbers, then you can’t use to add a floating-point number to that array: If you try to add a floating-point number to , then fails with a . That’s because Python can’t automatically convert a floating-point number into an integer number without losing information. In contrast, if you have an array with floating-point numbers and try to add integer numbers to it, then your operation will succeed: Here, you use to add an integer number to an array of floating-point numbers. That’s possible because Python can automatically convert integer numbers into floating-point numbers without losing information in the process. is another data structure that implements a variation of . A is a generalization of a stack and a queue specially designed to support fast and memory-efficient and operations on both of its sides. So if you need to create a data structure with these features, then consider using a deque instead of a list. Note: The name deque is pronounced “deck” and stands for double-ended queue. takes the following two optional arguments: An iterable that serves as an initializer An integer number that specifies the maximum length of the deque If you provide a value to , then your deque will only store up to items. Once the deque is full, adding a new item will automatically cause the item at the opposite end of the deque to be discarded. On the other hand, if you don’t supply a value to , then the deque can grow to an arbitrary number of items. In deques, also adds a single item to the end, or right side, of the underlying data structure: Like lists, deques can hold different types of items, so adds arbitrary items to the end of the deque. In other words, with , you can add any object to a deque. Besides , deques also provide , which adds a single item to the beginning, or left side, of a deque. Similarly, deques provide and to remove items from the right and left side of the deque, respectively: The call to adds to the left side of . On the other hand, returns and removes the last item in , and returns and removes the first item. As an exercise, you can try to implement your own stack or queue using a deque instead of a list. To do this, you can take advantage of the examples you saw in the section Creating Stacks and Queues With Python’s .append()."
    },
    {
        "link": "https://stackoverflow.com/questions/4081217/how-to-modify-list-entries-during-for-loop",
        "document": "Since the loop below only modifies elements already seen, it would be considered acceptable:\n\nWhich is different from:\n\nin that it doesn't require the creation of a temporary list and an assignment of it to replace the original, although it does require more indexing operations.\n\nCaution: Although you can modify entries this way, you can't change the number of items in the without risking the chance of encountering problems.\n\nHere's an example of what I mean—deleting an entry messes-up the indexing from that point on:\n\nSince this is a fairly popular answer, here's how to effectively delete entries \"in-place\" (even though that's not exactly the question):\n\nSee How to remove items from a list while iterating?."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://stackoverflow.com/questions/52668183/how-to-use-append-to-store-values-within-a-loop-in-python",
        "document": "I'm defining a function ( ) that contains a for loop whose result is a random number ( ). So, if the loop runs 10 times, for example, it will generate 10 different numbers. I would like to store those numbers in a list within the loop that I could then print to see what numbers were generated.\n\nI thought of using append, though I don't know how to do this. This is my code so far, though the print statement doesn't work (I get an error saying I didn't use append correctly)."
    },
    {
        "link": "https://geeksforgeeks.org/python-list-append-method",
        "document": "append() method in Python is used to add a single item to the end of list. This method modifies the original list and does not return a new list. Let’s look at an example to better understand this.\n\nExplanation: append(8) adds 8 to the end of the list a, modifying it in place.\n• element: The item to be appended to the list. This can be of any data type (integer, string, list, object, etc.). This parameter is mandatory, and omitting it will cause an error.\n• None append() does not return any value. It modifies the original list in place.\n\nHere are some examples and use-cases of list append() function in Python.\n\nThe append() method allows adding elements of different data types (integers, strings, lists or objects) to a list. Python lists are heterogeneous meaning they can hold a mix of data types.\n\nExplanation: In this list “a” contains elements of different data types (integer, string, float) and append(True) adds a boolean True to the end of the list.\n\nWhen appending one list to another, the entire list is added as a single element, creating a nested list.\n\nExplanation: append() method adds the list [4, 5] as a single element to the end of the list a, resulting in a nested list.\n\nExample demonstrating the difference between append and extend:\n\nCan append() add multiple elements at once?\n\nWhat is the time complexity of the append() method?\n\nCan the append() method add an element at a specific index in the list?\n\nCan the append() method add another list to an existing list without creating a nested list?"
    }
]