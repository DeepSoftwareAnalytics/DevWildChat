[
    {
        "link": "https://javadoc.io/doc/com.github.javaparser/javaparser-core/3.14.0/com/github/javaparser/ast/CompilationUnit.html",
        "document": ""
    },
    {
        "link": "https://javaparser.org",
        "document": "Explore the most common use cases for the JavaParser library\n\nWrite code that can traverse Java source and look for the patterns you are interested in. Build tools that can not just identify code patterns, but also has the ability to change them.\n\nThe most popular parser for the Java language When choosing open source technologies it is important to know your choice will be rewarded by continuous support. The JavaParser community is vibrant and active, with a weekly release cadence that supports language features up to Java 12.\n\nAvailable either under either the terms of the LGPL or Apache Licenses. An awesome community of approachable developers over on Gitter Our goal is to build a simple and lightweight set of tools to analyze, transform and generate Java code.\n\nThe JavaParser library provides you with an Abstract Syntax Tree of your Java code. The AST structure then allows you to work with your Java code in an easy programmatic way. <!-- Add the following dependency to your pom.xml, --> <!-- replacing LATEST with specific version as required --> <dependency> <groupId>com.github.javaparser</groupId> <artifactId>javaparser-symbol-solver-core</artifactId> <version>LATEST</version> </dependency> // Look for fields which are public and not static compilationUnit.findAll(FieldDeclaration.class).stream() .filter(f -> f.isPublic() && !f.isStatic()) .forEach(f -> System.out.println(\"Check field at line \" + f.getRange().map(r -> r.begin.line).orElse(-1))); // Ensure all abstract classes have a name starting with Abstract compilationUnit.findAll(ClassOrInterfaceDeclaration.class).stream() .filter(c -> !c.isInterface() && c.isAbstract() && !c.getNameAsString().startsWith(\"Abstract\")) .forEach(c -> { String from = c.getNameAsString(); String to = \"Abstract\" + from; System.out.println(\"Renaming class \" + from + \" into \" + to); c.setName(to); }); // Create source code on the fly CompilationUnit compilationUnit = new CompilationUnit(); ClassOrInterfaceDeclaration myClass = compilationUnit .addClass(\"MyClass\") .setPublic(true); myClass.addField(int.class, \"A_CONSTANT\", PUBLIC, STATIC); myClass.addField(String.class, \"name\", PRIVATE); String code = myClass.toString();\n\nJavaParser is an open-source project built by amazing volunteers. We are always looking for new contributors and will support you throughout the process. The best way to help the JavaParser community is to become a contributor; however if you would like to show your support in another way, please consider a purchase of our book."
    },
    {
        "link": "https://javadoc.io/doc/com.github.javaparser/javaparser-core/3.3.2/com/github/javaparser/ast/CompilationUnit.html",
        "document": ""
    },
    {
        "link": "https://javacodegeeks.com/introduction-to-javaparser.html",
        "document": "JavaParser is a powerful library that provides an easy way to parse, analyze, and manipulate Java source code. It can be used for a variety of purposes, including static code analysis, code generation, and refactoring tools. Let us delve into understanding JavaParser and understand the basic functionalities.\n\nJavaParser is a Java library that allows you to parse Java source code into an Abstract Syntax Tree (AST). Once parsed, you can traverse the AST to analyze and manipulate the code programmatically. JavaParser is useful for tasks such as code analysis, creating custom refactoring tools, and generating code based on certain patterns.\n• Can be integrated with other tools and libraries for enhanced functionality.\n• May have a steep learning curve for beginners.\n• Performance can be an issue with large codebases.\n• Not all Java language features may be fully supported in certain versions.\n\nTo use JavaParser, you need to add the following dependency to your project.\n\nMake sure to replace the version number with the latest version available.\n\nLet’s start by parsing a simple Java class. Here is a code example:\n\nThe code defines a Java class named that contains a method. Within this method, a string variable named is initialized with the source code of another Java class called . This inner class has a method named , which prints to the console.\n\nThe JavaParser library is used to parse the string representation of the class. The method of the class takes the string as input and returns a object representing the parsed structure of the provided code. Finally, the parsed object is printed to the console using , which outputs the structure of the parsed Java code.\n\nThe output will be the parsed structure of the provided Java class:\n\nOnce you have the parsed , you can traverse and analyze the AST. Here is an example:\n\nThe code defines a Java class named that contains a method. Within this method, a string variable named is initialized with the source code of another Java class called . This inner class has a method named , which prints to the console.\n\nThe JavaParser library is used to parse the string representation of the class. The method of the class takes the string as input and returns a object representing the parsed structure of the provided code.\n\nThe code then finds all method declarations within the parsed object using the method with as the parameter. For each method found, it prints the method’s name, return type, and parameters to the console.\n\nSpecifically, the method is used to iterate through all the method declarations, and for each method, it prints:\n• The method name using\n\nThe output will be the details of the method declarations found in the provided Java class:\n\nJavaParser allows you to convert the AST back to source code. Here is an example:\n\nThe code defines a Java class named that contains a method. Within this method, a string variable named is initialized with the source code of another Java class called . This inner class has a method named , which prints to the console.\n\nThe JavaParser library is used to parse the string representation of the class. The method of the class takes the string as input and returns a object representing the parsed structure of the provided code.\n\nA object is instantiated to configure the pretty printer. A object is then created using this configuration. The object is used to generate a pretty-printed version of the parsed object. This is done by calling the method on the object with the as the parameter. The result is stored in the variable. Finally, the pretty-printed code is printed to the console using .\n\nThe output will be the details of the method declarations found in the provided Java class:\n\nJavaParser allows you to manipulate the parsed code. Here is an example of adding a new method to the parsed class:\n\nThe code defines a Java class named that contains a method. Within this method, a string variable named is initialized with the source code of another Java class called . This inner class has a method named , which prints to the console.\n\nThe JavaParser library is used to parse the string representation of the class. The method of the class takes the string as input and returns a object representing the parsed structure of the provided code.\n\nThe code retrieves the class from the object using the method. This method returns an , from which the class is obtained using .\n\nA new method named is added to the class using the method. This new method is declared as public using . The body of the new method is set to print to the console. This is done by parsing a string representation of the method body using and setting it as the body of the . Finally, the modified object, which now includes the new method, is printed to the console using .\n\nThe output will be the modified version of the provided Java class with the new method added:\n\nJavaParser is a versatile library that simplifies the process of parsing, analyzing, and manipulating Java source code. With its powerful API, you can easily create tools for static code analysis, code generation, and refactoring. This article provided an introduction to JavaParser and demonstrated its core functionalities through code examples. Explore JavaParser further to unlock its full potential in your projects."
    },
    {
        "link": "https://stackoverflow.com/questions/2333866/editing-modifying-a-java-file-programmatically-not-the-class-file",
        "document": "JavaParser is an API that allows you to read in Java files, modify them, and get the results as a String.\n\nMore specifically, JavaParser parses the file and builds an AST (abstract syntax tree). You can then modify the JavaParser AST representing your source code using the API and retrieve the String representation of the AST.\n\nHere's an example of using JavaParser to add a line onto the end of a method body and print the result:\n\nCompilationUnit - From JavaParser's javadoc, \"This class represents the entire compilation unit. Each java file denotes a compilation unit.\"\n\nIn your code, replace calls with proper handling.\n\nAn example to add method logging to a class name given on the command line:\n\nThis will write the changed source file to standard output. If you put the file inside the project's main package, then you can build the project's JAR file (e.g., ). Renaming the JAR file to and then run the over all the JAR files:\n\nOf course, it would be much more efficient to have Java iterate over a directory tree. Once the files are present and look okay, you can rename them en masse using:\n\nThis will destroy the original formatting, making it fairly unsuitable for checking into a repository. Some Java 14 statements might not translate into a file that can be compiled. YMMV."
    },
    {
        "link": "https://stackoverflow.com/questions/33077890/java-i-need-to-parse-modfiy-and-write-back-java-source-files-programmatically",
        "document": "I need to parse, modify and write back Java source files. I investigated some options but it seams that I miss the point.\n\nThe output of the parsed AST when written back to file always screwed up the formatting using a standard format but not the original one.\n\nBasically I want something that can do: content(write(parse(sourceFile))).equals(content(sourceFile)).\n\nI tried the JavaParser but failed. I might use the Eclipse JDT's parser as a stand alone parser but this feels heavy. I also would like to avoid doing my own stuff. The Java parser for instance has information about column and line already but writing it back seams to ignore these information.\n\nI would like to know how I can achieve parsing and writing back while the output looks the same as the input (intents, lines, everything). Basically a solution that is preserving the original formatting.\n\nThe modifications I want to do is basically everything that is possible with the AST like adding, removing implemented interfaces, remove / add final to local variables but also generate source methods and constructors.\n\nThe idea is to add/remove anything but the rest needs to remain untouched especially the formatting of methods and expressions if the resulting line is larger than the page margin."
    },
    {
        "link": "https://github.com/javaparser/javaparser/issues/2005",
        "document": "How to use JP to inspect/modify the AST - please close your question once answered!\n\nHow to use JP to inspect/modify the AST - please close your question once answered!"
    },
    {
        "link": "https://javacodegeeks.com/2017/12/javaparser-generate-analyze-modify-java-code.html",
        "document": "As developers we frequently look in contempt to people doing repetitive work manually.\n\nThey should automate that, we think.\n\nStill, we do all activities related to coding by hand. Sure, we use fancy IDEs that can perform some little refactoring for us but that is basically the end of it. We do not taste our own medicine.\n\nLet’s change that. Let’s see how we can write code to:\n• Generate the boring, repetitive Java code we have to write\n• Analyze our code to answer some questions about it\n\nThe good thing is that we are going to achieve all of this with one set of libraries: JavaParser and its little brother called JavaSymbolSolver.\n\nWell, that is an easy one: just add JavaSymbolSolver to your dependencies.\n\nWhat is JavaSymbolSolver? It is a library that complements JavaParser giving to it some pretty powerful features which are necessary to answer more complex questions about code.\n\nJavaSymbolSolver depends on JavaParser so you just need to add JavaSymbolSolver and Maven or Gradle will get also JavaParser for you.\n\nI assume you know how to use Maven or Gradle. If you don’t, stop reading this and go learn that first!\n\nThere are several situations in which you may want to generate Java code. For example, you could want to generate code based on some external data, like a database schema or a REST API.\n\nYou may also want to translate some other language into Java. For example, I design DSLs for a living and while the users get to see only the DSLs I build for them I frequently generate Java behind the scenes and compile that.\n\nSometimes you want just to generate boilerplate code, like I used to dp when working with JavaEE and all those layers (who can remember how boring was to write EJB?).\n\nWhatever is your reason for generating code you can use JavaParser. JavaParser does not ask question, it is just there to help you.\n\nLet’s see how we can generate a class with two fields, a constructor and two getters. Nothing terribly advanced but it should give you a feeling of what it means to use JavaParser for code generation.\n\nThat last instruction print your code, fresh and ready to be compiled. You may want to save the code into a file instead of printing it but you get the idea.\n\nThere are many different questions you could ask about your code, many different ways to analyze it.\n\nFirst of all let’s parse all source files of our project:\n\nLet’s also create a method to get all nodes of a certain type among all our compilation units:\n\nThen let’s start asking questions, like:\n\nHow many methods take more than 3 parameters?\n\nWhat are the three top classes with most methods?\n\nOk, you get the idea. Now go examine your code. You do not have anything to hide, right?\n\nSuppose you are the happy user of a certain library. You have added it to your dependencies years ago and used it happily ever after. Time has passed and you have used it more and more, basically all over your project.\n\nOne day a new version of that useful library comes up and you decide you want to update your dependencies. Now, in the new library they have removed one of the methods you were using. Sure it was deprecated and it was named oldMethod (which could have told you something…).\n\nNow oldMethod has been replaced by newMethod. The newMethod takes 3 parameters: the first two are the same as oldMethod, they are just inverted the third one is a boolean, which should be set to true to get the same behavior we were getting with oldMethod.\n\nYou have hundreds of calls to oldMethod… are you going to change them one by one? Well, maybe, if you are charging by the hour. Or you could just use JavaParser instead.\n\nFirst let’s find all the calls to the old method in a certain file, a.k.a. CompilationUnit in JavaParser parlanse:\n\nAnd then let’s transform the old calls in the new ones:\n\nCool, now we just need to get the code for our modified CompilationUnit and just save it into the Java file.\n\nWhere to find out more about javaparser\n\nThere are tons of features of JavaParser we have not seen:\n• JavaParser can handle comments, figuring out to which elements they refer to\n• JavaParser can do lexical preservation or pretty printing: your choice\n• It can find out to which method declaration a method call refers to, which ancestors a certain class has, and much more thanks to the integration with JavaSymbolSolver\n• It can export the AST to JSON, XML, YAML, and even generate diagrams using Graphviz!\n\nWhere can you learn about all this stuff?\n\nHere there are a few resources:\n• We wrote a book on JavaParser & JavaSymbolSolver, available for free. It is named JavaParser: Visited\n• The blog of the great Matozoid: he is the glorious maintainer of JavaParser, the unstoppable force that push a new release out every-single-week. Who knows better about JavaParser?\n• My humble blog on Language Engineering. I am the maintainer of JavaSymbolSolver and I try to help as the second in command at JavaParser. A distant second ��\n• The website of the project: not very rich in content at the moment but we are working on it\n• The gitter channel: do you have questions? Asked them there\n\nIt is hardly the case that you can learn how to use one tool to do three different things. By learning how to use JavaParser you can analyze, generate, and modify Java code.\n\nWell, it feels like Christmas, doesn’t it?"
    },
    {
        "link": "https://baeldung.com/javaparser",
        "document": "In this article, we’re going to have a look at the JavaParser library. We’ll see what it is, what we can do with it, and how to use it.\n\nJavaParser is an open-source library for working with Java sources. It allows us to parse Java source code into an abstract syntax tree (AST). Once we’ve done this, we can analyze the parsed code, manipulate it, and even write new code.\n\nUsing JavaParser, we can parse source code written in Java up to Java 18. This includes all stable language features but may not include any preview features.\n\nBefore we can use JavaParser, we need to include the latest version in our build, which is 3.25.10 at the time of writing.\n\nThe main dependency that we need to include is javaparser-core. If we’re using Maven, we can include this dependency in our pom.xml file:\n\nOr if we’re using Gradle, we can include it in our build.gradle file:\n\nAt this point, we’re ready to start using it in our application.\n\nTwo additional dependencies are available as well. The dependency com.github.javaparser:javaparser-symbol-solver-core provides a means to analyze the parsed AST to find the relationships between Java elements and their declarations. The dependency com.github.javaparser:javaparser-core-serialization provides a means to serialize the parsed AST to and from JSON.\n\nOnce we have the dependencies set up in our application, we’re ready to go. Parsing of Java code always starts with the StaticJavaParser class. This gives us several different mechanisms for parsing code, depending on what we’re parsing and where it’s coming from.\n\nThe first thing we’ll look at parsing is the entire source files. We can do this with the StaticJavaParser.parse() method. Several overloaded alternatives allow us to provide the source code in different ways – directly as a string, as a File on the local filesystem, or as an InputStream or Reader for some resource. All of these work the same way and are simply convenient ways to provide the code to be parsed.\n\nLet’s see it in action. Here, we’ll attempt to parse the provided source code and generate a CompilationUnit as a result:\n\nThis represents our AST and lets us inspect and manipulate the parsed code.\n\nIndividual statements are at the other end of the spectrum of the code that we can parse. We do this using the StaticJavaParser.parseStatement() method. Unlike with source files, there’s only a single version of this that takes a single string containing the statement to parse.\n\nThis method returns a Statement object that represents the parsed statement:\n\nJavaParser can also parse many other constructs, covering the entire Java language up to Java 18. Each construct has a separate, dedicated parse method and returns an appropriate type representing the parsed code. For example, we can use parseAnnotation() for parsing annotations, parseImport() for import statements, parseBlock() for parsing blocks of statements, and many more.\n\nInternally, JavaParser will use the exact same code for parsing the various parts of our code. For example, when parsing a block using parseBlock(), JavaParser will ultimately end up in the same code as is called directly by parseStatement(). This means we can rely on these different parsing methods working the same for the same subsets of code.\n\nWe do need to know exactly what type of code we’re parsing in order to select the correct parsing method. For example, using the parseStatement() method to parse a class definition will fail.\n\nIf parsing fails, the JavaParser will throw a ParseProblemException indicating exactly what was wrong with the code. For example, if we attempt to parse a malformed class definition, then we’ll get something like:\n\nWe can see from this error message that the problem is that the class definition is wrong. In Java, such a statement must be followed by either a “<“ – for a generic definition, the extends or implements keyword, or else a “{“ to start the actual body of the class.\n\nOnce we’ve parsed some code, we can start analyzing it to learn from it. This is similar to reflection within a running application, only on the parsed source code instead of the currently running code.\n\nOnce we’ve parsed some source code, we can query the AST to access individual elements. Exactly how we do this varies depending on the elements we want to access and what we’ve parsed.\n\nFor example, if we’ve parsed a source file into a CompilationUnit, then we can access a class that we expect to be present using getClassByName():\n\nNote that this returns an Optional<ClassOrInterfaceDeclaration>. Optional is used because we can’t guarantee the type is present in this compilation unit. In other cases, we might be able to guarantee the presence of elements. For example, a class will always have a name, so ClassOrInterfaceDeclaration.getName() doesn’t need to return an Optional.\n\nAt every stage, we can only directly access elements that are at the outermost level of what we’re currently working with. For example, if we’ve got a CompilationUnit from parsing a source file, then we can access the package declaration, the import statements, and the top-level types, but we can’t access the members within those types. However, once we access one of these types, we can then access the members within it.\n\nIn some cases, we may not know exactly what elements are present in our parsed code, or else we simply want to work with all of a certain type of element instead of only one.\n\nEach of our AST types can access an entire range of appropriate nested elements. Exactly how this works depends on what we want to work with. For example, we can extract all of the import statements out of a CompilationUnit using:\n\nNo Optional is needed, as this is guaranteed to return a result. However, if no imports were present, this result might be an empty list.\n\nOnce we’ve done this, we can treat this as any collection. The NodeList type implements java.util.List correctly so we can work with it exactly as any other list.\n\nIn addition to extracting exactly one type of element from our parsed code, we can also iterate over the entire parsed tree. All AST types from JavaParser implement the visitor pattern, allowing us to visit every element in our parsed source code with a custom visitor:\n\nThere are then two standard types of visitors that we can use with this. Both of these have a visit() method for each possible AST type, which takes a state argument that’s passed into the accept() call.\n\nThe simplest of these is VoidVisitor<A>. This has one method for every AST type and no return values. We then have an adapter type – VoidVisitorAdapter – that gives us a standard implementation to help ensure that the entire tree is correctly called.\n\nWe then only need to implement the methods that we’re interested in – for example:\n\nThis will output a log message for every method name in the source file, regardless of where they are. The fact that this recurses over the entire tree structure means that these methods can be in top-level classes, inner classes, or even anonymous classes within other methods.\n\nThe alternative is GenericVisitor<R, A>. This works similarly to VoidVisitor, except that its visit() methods have a return value. We also have adapter classes here, depending on how we want to collect the return values from each method. For example, GenericListVisitorAdaptor will force us to have our return type from each method be a List<R> instead and merge all of these lists together:\n\nThis will return a list that contains the names of every method in the entire tree.\n\nIn addition to parsing and analyzing our code, we can also output it again as a string. This can be useful for many reasons – for example, if we want to extract and output only specific sections of the code.\n\nThe easiest way to achieve this is to simply use the standard toString() method. All of our AST types correctly implement this and will produce formatted code. Note that this might not be formatted exactly as it was when we parsed the code, but it’ll still follow relatively standard conventions.\n\nFor example, if we parse the following code:\n\nWhen we format it, we’ll get this as the output:\n\nThe other method we can use for formatting code is using the DefaultPrettyPrinterVisitor. This is a standard visitor class that will handle formatting. This gives us the advantage of configuring some aspects of how the output is formatted. For example, if we wanted to indent with two spaces instead of four, we could write:\n\nOnce we’ve parsed some code into an AST, we’re also able to make changes to it. Since this is now just a Java object model, we can treat it as any other object model, and JavaParser gives us the ability to change most aspects of it freely.\n\nCombining this with the ability to output our AST back as working source code means that we can then manipulate parsed code, make changes to it, and provide the output in some form. This could be useful for IDE plugins, code compilation steps, and much more.\n\nThis can be used in any way that we have access to the appropriate AST elements – whether that’s from directly accessing them, iterating with a visitor, or whatever makes sense.\n\nFor example, if we wanted to uppercase every single method name in a piece of code, then we could do something like:\n\nThis uses a simple visitor to visit every method declaration in our source tree and uses the setName() method to give each method a new name. The new name is then simply the old name in uppercase.\n\nOnce this is done, the AST is updated in place. We can then format it however we wish, and the newly formatted code will reflect our changes.\n\nWe’ve seen here a quick introduction to JavaParser. We’ve shown how to get started with it and some of the things we can achieve using it. Next time you need to manipulate some Java code, why not try it out?\n\nAll of the examples are available over on GitHub."
    },
    {
        "link": "https://tomassetti.me/getting-started-with-javaparser-analyzing-java-code-programmatically",
        "document": "One of the things I like the most is to parse code and to perform automatic operations on it. For this reason I started contributing to JavaParser and created a couple of related projects: java-symbol-solver and effectivejava.\n\nAs a contributor of JavaParser I read over and over some very similar questions about extracting information from Java source code. For this reason I thought that I could help providing some simple examples, just to get started with parsing Java code.\n\nAll the source code is available on Github: analyze-java-code-examples\n\nWhen using JavaParser there are a bunch of operations we want typically to do every time. Often we want to operate on a whole project, so given a directory we would explore all the Java files. This class should help doing this:\n\nFor each Java file we want first to build an Abstract Syntax Tree (AST) for each Java file and then to navigate it. There are two main strategies to do so:\n• use a visitor: this is the right strategy when you want to operate on specific types of AST nodes\n• use a recursive iterator: this permits to process all sort of nodes\n\nVisitors can be written extending classes included in JavaParser, while this is a simple node iterator:\n\nNow let’s see how to use this code to solve some questions found on Stack Overflow.\n\nHow to extract the name of all classes in a normal String from java class?\n\nThis solution can be solved looking for the ClassOrInterfaceDeclaration nodes. Given we want a specific kind of node we can use a Visitor. Note that the VoidVisitorAdapter permits to pass an arbitrary argument. In this case we do not need that, so we specify the type Object and we just ignore it in our visit method.\n\nWe run the example on the source code of JUnit and we got this output:\n\nIs there any parser for Java code that could return the line numbers that compose a statement?\n\nIn this case I need to find all sort of statements. Now, there are several classes extending the Statement base class so I could use a visitor but I would need to write the same code in several visit methods, one for each subclass of Statement. In addition I want only to get the top level statements, not the statements inside it. For example, a for statement could contain several other statements. With our custom NodeIterator we can easily implement this logic.\n\nAnd this is a portion of the output obtained running the program on the source code of JUnit.\n\nYou could notice that the statement reported spans across 5, not 6 as reported (12..17 are 6 lines). This is because we are printing a cleaned version of the statement, removing whitelines, comments and formatting the code.\n\nFor extract method calls we can use again a Visitor, so this is pretty straightforward and fairly similar to the first example we have seen.\n\nAs you can see the solution is very similar to the one for listing classes.\n\nYou can answer a lot of questions with the approaches presented here: you navigate the AST, find the nodes you are interested into and get whatever information you are looking for. There are however a couple of other things we should look at: first of all how to transform the code. While extract information is great, refactoring is even more useful. Then for more advanced questions we need to resolve symbols using java-symbol-solver. For example:\n• looking at the AST we can find the name of a class, but not the list of interfaces it implements indirectly\n• when looking at a method invokation we can not easily find the declaration of that method. In which class or interface was it declared? Which of the different overloaded variants are we invoking?\n\nWe will look into that in the future. Hopefully these examples should help you getting started!"
    }
]