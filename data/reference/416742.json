[
    {
        "link": "https://developer.chrome.com/docs/extensions/mv2/manifest",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nEvery extension has a JSON-formatted manifest file, named , that provides important information.\n\nThe following code shows the supported manifest fields for Extensions, with links to the page that discusses each field."
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/manifest",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nEvery extension must have a file in its root directory that lists important information about the structure and behavior of that extension. This page explains the structure of extension manifests and the features they can include.\n\nThe following example manifests show the basic manifest structure and some commonly used features as a starting point for creating your own manifest:\n\nThe following is a list of all supported manifest keys."
    },
    {
        "link": "https://learn.microsoft.com/en-us/microsoft-edge/extensions-chromium/getting-started/manifest-format",
        "document": "Every extension for Microsoft Edge has a JSON-formatted manifest file, named . The manifest file is the blueprint of your extension. The manifest file includes information such as:\n• The version number of the extension.\n• The title of the extension.\n• The permissions that are needed for the extension to run.\n\nUse Manifest V3 for new code. The format for for extensions is moving from Manifest V2 to Manifest V3. Both formats are shown here. To migrate a Manifest V2 extension to Manifest V3, see Migrate an extension from Manifest V2 to V3.\n\nThe following code shows the fields that are supported in for extensions, for a Manifest V3 or V2 package.\n\nFor reference information about each field, see Manifest file format in Chrome Extensions > Reference, and then click the links on the fields. { // Required \"manifest_version\": 3, \"name\": \"My V3 Extension\", \"version\": \"versionString\", // Recommended \"action\": {...}, \"default_locale\": \"en\", \"description\": \"A plain-text description\", \"icons\": {...}, // Optional \"action\": ..., \"author\": ..., \"automation\": ..., \"background\": { // If `background` is included, `service_ worker` is required \"service_worker\": ... }, \"chrome_settings_overrides\": {...}, \"chrome_url_overrides\": {...}, \"commands\": {...}, \"content_capabilities\": ..., \"content_scripts\": [{...}], \"content_security_policy\": \"policyString\", \"converted_from_user_script\": ..., \"current_locale\": ..., \"declarative_net_request\": ..., \"devtools_page\": \"devtools.html\", \"differential_fingerprint\": ..., \"event_rules\": [{...}], \"externally_connectable\": { \"matches\": [\"*://*.contoso.com/*\"] }, \"file_browser_handlers\": [...], \"file_system_provider_capabilities\": { \"configurable\": true, \"multiple_mounts\": true, \"source\": \"network\" }, \"homepage_url\": \"http://path/to/homepage\", \"host_permissions\": [...], \"import\": [{\"id\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}], \"incognito\": \"spanning, split, or not_allowed\", \"input_components\": ..., \"key\": \"publicKey\", \"minimum_chrome_version\": \"versionString\", \"nacl_modules\": [...], \"natively_connectable\": ..., \"oauth2\": ..., \"offline_enabled\": true, \"omnibox\": { \"keyword\": \"aString\" }, \"optional_permissions\": [\"tabs\"], \"options_page\": \"options.html\", \"options_ui\": { \"chrome_style\": true, \"page\": \"options.html\" }, \"permissions\": [\"...\"], \"platforms\": ..., \"replacement_web_app\": ..., \"requirements\": {...}, \"sandbox\": [...], \"short_name\": \"Short Name\", \"side_panel\": {...}, \"storage\": { \"managed_schema\": \"schema.json\" }, \"system_indicator\": ..., \"tts_engine\": {...}, \"update_url\": \"http://path/to/updateInfo.xml\", \"version_name\": \"aString\", \"web_accessible_resources\": [...] } For reference information about each field, see Manifest file format (V2) and then select the links on the fields. { // Required \"manifest_version\": 2, \"name\": \"My V2 Extension\", \"version\": \"versionString\", // Recommended \"default_locale\": \"en\", \"description\": \"A plain-text description\", \"icons\": {...}, // Pick one or none \"browser_action\": {...}, \"page_action\": {...}, // Optional \"action\": ..., \"author\": ..., \"automation\": ..., \"background\": { // If `background` is included, `persistent` is recommended \"persistent\": false, // If `background` is included, `service_worker` is optional \"service_worker\": ... }, \"chrome_settings_overrides\": {...}, \"chrome_url_overrides\": {...}, \"commands\": {...}, \"content_capabilities\": ..., \"content_scripts\": [{...}], \"content_security_policy\": \"policyString\", \"converted_from_user_script\": ..., \"current_locale\": ..., \"declarative_net_request\": ..., \"devtools_page\": \"devtools.html\", \"differential_fingerprint\": ..., \"event_rules\": [{...}], \"externally_connectable\": { \"matches\": [\"*://*.contoso.com/*\"] }, \"file_browser_handlers\": [...], \"file_system_provider_capabilities\": { \"configurable\": true, \"multiple_mounts\": true, \"source\": \"network\" }, \"homepage_url\": \"http://path/to/homepage\", \"host_permissions\": ..., \"import\": [{\"id\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}], \"incognito\": \"spanning, split, or not_allowed\", \"input_components\": ..., \"key\": \"publicKey\", \"minimum_chrome_version\": \"versionString\", \"nacl_modules\": [...], \"natively_connectable\": ..., \"oauth2\": ..., \"offline_enabled\": true, \"omnibox\": { \"keyword\": \"aString\" }, \"optional_permissions\": [\"tabs\"], \"options_page\": \"options.html\", \"options_ui\": { \"chrome_style\": true, \"page\": \"options.html\" }, \"permissions\": [\"tabs\"], \"platforms\": ..., \"replacement_web_app\": ..., \"requirements\": {...}, \"sandbox\": [...], \"short_name\": \"Short Name\", \"storage\": { \"managed_schema\": \"schema.json\" }, \"system_indicator\": ..., \"tts_engine\": {...}, \"update_url\": \"http://path/to/updateInfo.xml\", \"version_name\": ..., \"web_accessible_resources\": [...] }\n\nChanges in manifest.json V3 vs. V2\n• Migrate an extension from Manifest V2 to V3\n\nPortions of this page are modifications based on work created and shared by Google and used according to terms described in the Creative Commons Attribution 4.0 International License. The original page is found here.\n\nThis work is licensed under a Creative Commons Attribution 4.0 International License."
    },
    {
        "link": "https://blog.chromium.org/2024/05/manifest-v2-phase-out-begins.html",
        "document": "Update (10/10/2024): We’ve started disabling extensions still using Manifest V2 in Chrome stable. Read more details in the MV2 support timeline documentation.\n\nIn November 2023, we shared a timeline for the phasing out of Manifest V2 extensions in Chrome. Based on the progress and feedback we’ve seen from the community, we’re now ready to roll out these changes as scheduled.\n\nWe’ve always been clear that the goal of Manifest V3 is to protect existing functionality while improving the security, privacy, performance and trustworthiness of the extension ecosystem as a whole. We appreciate the collaboration and feedback from the community that has allowed us - and continues to allow us - to constantly improve the extensions platform.\n\nWe understand migrations of this magnitude can be challenging, which is why we’ve listened to developer feedback and spent years refining Manifest V3 to support the innovation happening across the extensions community. This included adding support for user scripts and introducing offscreen documents to allow extensions to use DOM APIs from a background context. Based on input from the extension community, we also increased the number of rulesets for declarativeNetRequest, allowing extensions to bundle up to 330,000 static rules and dynamically add a further 30,000. You can find more detail in our content filtering guide.\n\nThis month, we made the transition even easier for extensions using declarativeNetRequest with the launch of review skipping for safe rule updates. If the only changes are for safe modifications to an extension’s static rule list for declarativeNetRequest, Chrome will approve the update in minutes. Coupled with the launch of version roll back last month, developers now have greater control over how their updates are deployed.\n\nAfter we addressed the top issues and feature gaps blocking migration last year, we saw an acceleration of extensions migrating successfully to Manifest V3. Over the past year, we’ve even been able to invite some developers - such as Eyeo, the makers of Adblock Plus - and GDE members like Matt Frisbie to share their experiences and insights with the community through guest posts and YouTube videos.\n\nNow, over 85% of actively maintained extensions in the Chrome Web Store are running Manifest V3, and the top content filtering extensions all have Manifest V3 versions available - with options for users of AdBlock, Adblock Plus, uBlock Origin and AdGuard.\n\nWhat to expect next\n\nStarting on June 3 on the Chrome Beta, Dev and Canary channels, if users still have Manifest V2 extensions installed, some will start to see a warning banner when visiting their extension management page - chrome://extensions - informing them that some (Manifest V2) extensions they have installed will soon no longer be supported. At the same time, extensions with the Featured badge that are still using Manifest V2 will lose their badge.\n\nThis will be followed gradually in the coming months by the disabling of those extensions. Users will be directed to the Chrome Web Store, where they will be recommended Manifest V3 alternatives for their disabled extension. For a short time after the extensions are disabled, users will still be able to turn their Manifest V2 extensions back on, but over time, this toggle will go away as well.\n\nLike any big launches, all these changes will begin in pre-stable channel builds of Chrome first – Chrome Beta, Dev, and Canary. The changes will be rolled out over the coming months to Chrome Stable, with the goal of completing the transition by the beginning of next year. Enterprises using the ExtensionManifestV2Availability policy will be exempt from any browser changes until June 2025.\n\nWe’ve shared more information about the process in our recent Chrome extensions Google I/O talk. If you have any additional questions, don’t hesitate to reach out via the Chromium extensions mailing list."
    },
    {
        "link": "https://stackoverflow.com/questions/11814270/chrome-extension-manifest-version-2",
        "document": "I have a chrome extension that has a reference to the jquery file.\n\n this is my popup html (only the head tag):\n\nso in \"MyExtensionScript.js\" i thought i could use jquery but apparently the $ function is not defined.\n\n This is my manifest.json file:\n\nin version 1 of the manifest it worked, but now it doesn't. I tried to use the \"web_accessible_resources\" and add to them \"http://www.MySite.com/Resources/JS/JQuery/jquery-1.7.2.min.js\" but that didn't work also. any ideas?\n\n also, i have a script injected to the current page and returning me a message (in my case some html source of the current page), will this behavior be affected by the transition to manifest version 2? Thanks all :)\n\nEDIT: I have a web application that enables cross domain scripting (using JSONP). In my extension i had a script calling a web service in my site with $.getJSON. now it doesn't work. i'm pretty sure that it has to do with the new manifest version but how can i enable again the cross domain scripting?"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/api/runtime",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nMost members of this API do not require any permissions. This permission is needed for , and .\n\nThe following example shows how to declare the permission in the manifest:\n\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the event will fire with the reason. This includes when the extension is reloaded with .\n\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL (e.g. ). The same is true to include an extension asset on a web page. The two differences are that the extension's assets must be exposed as web accessible resources and that typically content scripts are responsible for injecting extension assets.\n\nIn this example, the extension will add to the page that the content script is being injected into by using to create a fully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\n\nSend data from a content script to the service worker\n\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\n\nIn this example, the content script needs some data from the extension's service worker to initialize its UI. To get this data, it passes the developer-defined message to the service worker, and it responds with a copy of the user's information.\n\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\n\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\n\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts. \"POPUP\" \n\n Specifies the context type as an extension popup window \"OFFSCREEN_DOCUMENT\" \n\n Specifies the context type as an offscreen document.\n• The type of context this corresponds to.\n• A UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n• The origin of the document associated with this context, or undefined if the context is not hosted in a document.\n• The URL of the document associated with this context, or undefined if the context is not hosted in a document.\n• The ID of the frame for this context, or -1 if this context is not hosted in a frame.\n• Whether the context is associated with an incognito profile.\n• The ID of the tab for this context, or -1 if this context is not hosted in a tab.\n• The ID of the window for this context, or -1 if this context is not hosted in a window. An object containing information about the script context that sent a message or request.\n• A UUID of the document that opened the connection.\n• The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n• The frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when is set.\n• The ID of the extension that opened the connection, if any.\n• The name of the native application that opened the connection, if any.\n• The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n• The which opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app.\n• The TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n• The URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it. The reason that this event is being dispatched. \"install\" \n\n Specifies the event reason as an installation. \"update\" \n\n Specifies the event reason as an extension update. \"shared_module_update\" \n\n Specifies the event reason as an update to a shared module. The reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy. \"app_update\" \n\n Specifies the event reason as an update to the app. \"os_update\" \n\n Specifies the event reason as an update to the operating system. \"periodic\" \n\n Specifies the event reason as a periodic restart of the app. An object containing information about the current platform.\n• The native client architecture. This may be different from arch on some platforms.\n• The operating system Chrome is running on. The native client architecture. This may be different from arch on some platforms. The operating system Chrome is running on. An object which allows two way communication with other pages. See Long-lived connections for more information.\n• The name of the port, as specified in the call to .\n• Fired when the port is disconnected from the other end(s). may be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime). The function looks like:\n• The parameter looks like:\n• This event is fired when postMessage is called by the other end of the port. The function looks like:\n• The parameter looks like:\n• This property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n• Immediately disconnect the port. Calling on an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port. The function looks like:\n• Send a message to the other end of the port. If the port is disconnected, an error is thrown. The function looks like:\n• The message to send. This object should be JSON-ifiable. \"throttled\" \n\n Specifies that the status check has been throttled. This can occur after repeated checks within a short amount of time. \"no_update\" \n\n Specifies that there are no available updates to install. \"update_available\" \n\n Specifies that there is an available update to install. The ID of the extension/app. Populated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but is not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\n• Details about the error which occurred. Attempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via .\n• The ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n• \n• Whether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n• Will be passed into onConnect for processes that are listening for the connection event.\n• Port through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist. Connects to a native application in the host machine. This method requires the permission. See Native Messaging for more information.\n• The name of the registered application to connect to.\n• Port through which messages can be sent and received with the application Background pages do not exist in MV3 extensions. Retrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\n• The parameter looks like:\n• The JavaScript 'window' object for the background page.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Fetches information about active contexts associated with this extension\n• A filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n• The parameter looks like:\n• The matching contexts, if any.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Returns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Converts a relative path within an app/extension install directory to a fully-qualified URL.\n• A path to a resource within an app/extension expressed relative to its install directory.\n• The fully-qualified URL to the resource. Open your Extension's options page, if possible. The precise behavior may depend on your manifest's or key, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload. If your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set .\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Reloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method. Requests an immediate update check be done for this app/extension. Important: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the event without needing to call requestUpdateCheck. This method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources. Note: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\n• The parameter looks like:\n• RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n• If an update is available, this contains the version of the available update.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Restart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op. Restart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\n• Time to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Sends a single message to event listeners within your extension or a different extension/app. Similar to but only sends a single message, with an optional response. If sending to your extension, the event will be fired in every frame of your extension (except for the sender's frame), or , if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use .\n• The ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n• The message to send. This message should be a JSON-ifiable object.\n• \n• Whether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n• The parameter looks like:\n• The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and will be set to the error message.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Send a single message to a native application. This method requires the permission.\n• The name of the native messaging host.\n• The message that will be passed to the native messaging host.\n• The parameter looks like:\n• The response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and will be set to the error message.\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Sets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\n• URL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n• The parameter looks like:\n• Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback. Fired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\n• The parameter looks like: Fired when a connection is made from either an extension process or a content script (by ).\n• The parameter looks like: Fired when a connection is made from another extension (by ), or from an externally connectable web site.\n• The parameter looks like: Fired when a connection is made from a native application. This event requires the permission. It is only supported on Chrome OS.\n• The parameter looks like: Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\n• The parameter looks like:\n• \n• Indicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n• Indicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n• The reason that this event is being dispatched. Fired when a message is sent from either an extension process (by ) or a content script (by ).\n• The parameter looks like:\n• The parameter looks like: Fired when a message is sent from another extension (by ). Cannot be used in a content script.\n• The parameter looks like:\n• The parameter looks like: Fired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\n• The parameter looks like: Fired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\n• The parameter looks like: Sent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\n• The parameter looks like: Sent after onSuspend to indicate that the app won't be unloaded after all.\n• The parameter looks like: Fired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\n• The parameter looks like:\n• \n• The version number of the available update. Fired when a connection is made from a user script from this extension.\n• The parameter looks like: Fired when a message is sent from a user script associated with the same extension.\n• The parameter looks like:\n• The parameter looks like:"
    },
    {
        "link": "https://developer.chrome.com/docs/extensions/reference/api",
        "document": "Most extensions need access to one or more Chrome Extensions APIs to function. This API reference describes the APIs available for use in extensions and presents example use cases.\n\nAn Extensions API consists of a namespace containing methods and properties for doing extensions work, and usually, but not always, manifest fields for the file. For example, the namespace requires an object in the manifest. Many APIs also require permissions in the manifest.\n\nMethods in extension APIs are asynchronous unless stated otherwise. Asynchronous methods return immediately, without waiting for the operation that calls them to finish. Use promises to get the results of these asynchronous methods.\n\nUse the API to implement a text-to-speech(TTS) engine using an extension. If your extension registers using this API, it will receive events containing an utterance to be spoken and other parameters when any extension or Chrome App uses the API to generate speech. Your extension can then use any available web technology to synthesize and output the speech, and send events back to the calling function to report the status."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage",
        "document": "Sends a single message to event listeners within your extension or a different extension. If sending to your extension, omit the argument. The event will be fired in each page in your extension, except for the frame that called . If sending to a different extension, include the argument set to the other extension's ID. will be fired in the other extension. By default, your extension can exchange messages with itself and any other extension (defined by ). However, the manifest key can be used to limit communication to specific extensions. Extensions cannot send messages to content scripts using this method. To send messages to content scripts, use . This is an asynchronous function that returns a . Note: You can also use a connection-based approach to exchange messages.\n\n. The ID of the extension to send the message to. Include this to send the message to a different extension. If the intended recipient has set an ID explicitly using the browser_specific_settings key in manifest.json, then should have that value. Otherwise it should have the ID that was generated for the intended recipient. If is omitted, the message is sent to your extension. . An object that can be structured clone serialized (see Data cloning algorithm). . Whether the TLS channel ID will be passed into for processes that are listening for the connection event. This option is only supported in Chromium-based browsers. Depending on the arguments it is given, this API is sometimes ambiguous. The following rules are used:\n• if one argument is given, it is the message to send, and the message will be sent internally.\n• if two arguments are given:\n• the arguments are interpreted as , and the message is sent internally, if the second argument is any of the following:\n• a valid object (meaning, it is an object which contains only the properties of that the browser supports)\n• otherwise, the arguments are interpreted as . The message will be sent to the extension identified by .\n• if three arguments are given, the arguments are interpreted as . The message will be sent to the extension identified by . Note that before Firefox 55, the rules were different in the 2-argument case. Under the old rules, if the first argument was a string, it was treated as the , with the message as the second argument. This meant that if you called with arguments like , then it would send an empty message to the extension identified by \"my-message\". Under the new rules, with these arguments you would send the message \"my-message\" internally, with an empty options object.\n\nA . If the receiver sent a response, this will be fulfilled with the response. Otherwise it will be fulfilled with no arguments. If an error occurs while connecting to the extension, the promise will be rejected with an error message."
    },
    {
        "link": "https://stackoverflow.com/questions/47827364/message-passing-chrome-api",
        "document": "I know this has been asked before on here. Unfortunately I can't seem to figure out the chrome.runtime.onMessage.addListener.\n\nHere is what I'm sending from my content script (gpa is a variable):\n\nHow would I receive that in my background.js file? The google documents I was looking at were only talking about sending responses, I want to save gpa as a variable in background.js."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendNativeMessage",
        "document": "Sends a single message from an extension to a native application.\n\nThis takes two mandatory parameters: the name of the native application and a JSON object which is the message to send it. The browser will launch the native application and deliver the message.\n\nThis is an asynchronous function that returns a . The first message sent by the native application is treated as a response to the call, and the promise will be fulfilled with this message as a parameter. Note that you can't use to get responses from the application: you must use the callback function instead.\n\nA new instance of the application is launched for call to . The browser will terminate the native application after getting a reply. To terminate a native application, the browser will close the pipe, give the process a few seconds to exit gracefully, and then kill it if it has not exited.\n\nFor more information, see Native messaging."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://stackoverflow.com/questions/29775797/fetch-post-json-data",
        "document": "When using jsfiddle's JSON echo I'd expect to see the object I've sent ( {a: 1, b: 2} ) back, but this does not happen - chrome devtools doesn't even show the JSON as part of the request, which means that it's not being sent.\n\nFrom what I can understand, I need to attach a stringified object to the body of the request, e.g.:\n\nI'm trying to POST a JSON object using fetch .\n\nWith ES2017 support, this is how to a JSON payload: Can't use ES2017? See @vp_art's answer using promises The question however is asking for an issue caused by a long since fixed chrome bug.\n\n Original answer follows. chrome devtools doesn't even show the JSON as part of the request This is the real issue here, and it's a bug with chrome devtools, fixed in Chrome 46. That code works fine - it is POSTing the JSON correctly, it just cannot be seen. I'd expect to see the object I've sent back that's not working because that is not the correct format for JSfiddle's echo. For endpoints accepting JSON payloads, the original code is correct\n\n2021 answer: just in case you land here looking for how to make GET and POST Fetch api requests using async/await or promises as compared to axios. const asyncGetCall = async () => { try { const response = await fetch('https://jsonplaceholder.typicode.com/posts'); const data = await response.json(); // enter you logic when the fetch is successful console.log(data); } catch(error) { // enter your logic for when there is an error (ex. error toast) console.log(error) } } asyncGetCall() const asyncPostCall = async () => { try { const response = await fetch('https://jsonplaceholder.typicode.com/posts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ // your expected POST request payload goes here title: \"My post title\", body: \"My post content.\" }) }); const data = await response.json(); // enter you logic when the fetch is successful console.log(data); } catch(error) { // enter your logic for when there is an error (ex. error toast) console.log(error) } } asyncPostCall() fetch('https://jsonplaceholder.typicode.com/posts') .then(res => res.json()) .then(data => { // enter you logic when the fetch is successful console.log(data) }) .catch(error => { // enter your logic for when there is an error (ex. error toast) console.log(error) }) fetch('https://jsonplaceholder.typicode.com/posts', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ // your expected POST request payload goes here title: \"My post title\", body: \"My post content.\" }) }) .then(res => res.json()) .then(data => { // enter you logic when the fetch is successful console.log(data) }) .catch(error => { // enter your logic for when there is an error (ex. error toast) console.log(error) }) const axiosGetCall = async () => { try { const { data } = await axios.get('https://jsonplaceholder.typicode.com/posts') // enter you logic when the fetch is successful console.log(`data: `, data) } catch (error) { // enter your logic for when there is an error (ex. error toast) console.log(`error: `, error) } } axiosGetCall() const axiosPostCall = async () => { try { const { data } = await axios.post('https://jsonplaceholder.typicode.com/posts', { // your expected POST request payload goes here title: \"My post title\", body: \"My post content.\" }) // enter you logic when the fetch is successful console.log(`data: `, data) } catch (error) { // enter your logic for when there is an error (ex. error toast) console.log(`error: `, error) } } axiosPostCall()\n\nI have created a thin wrapper around fetch() with many improvements if you are using a purely json REST API: // Small library to improve on fetch() usage const api = function(method, url, data, headers = {}){ return fetch(url, { method: method.toUpperCase(), body: JSON.stringify(data), // send it as stringified json credentials: api.credentials, // to keep the session on the request headers: Object.assign({}, api.headers, headers) // extend the headers }).then(res => res.ok ? res.json() : Promise.reject(res)); }; // Defaults that can be globally overwritten api.credentials = 'include'; api.headers = { 'csrf-token': window.csrf || '', // only if globally set, otherwise ignored 'Accept': 'application/json', // receive json 'Content-Type': 'application/json' // send json }; // Convenient methods ['get', 'post', 'put', 'delete'].forEach(method => { api[method] = api.bind(null, method); }); To use it you have the variable and 4 methods: And within an function: $('.like').on('click', async e => { const id = 123; // Get it however it is better suited await api.put(`/like/${id}`, { like: true }); // Whatever: $(e.target).addClass('active dislike').removeClass('like'); });\n\nThis is related to . As you might have noticed from other discussions and answers to this question some people were able to solve it by setting . Unfortunately in my case it didn't work, my POST request was still empty on the server side. However, if you try with jQuery's and it's working, the reason is probably because of jQuery using instead of .\n\nIt might be useful to somebody: I was having the issue that formdata was not being sent for my request In my case it was a combination of following headers that were also causing the issue and the wrong Content-Type. So I was sending these two headers with the request and it wasn't sending the formdata when I removed the headers that worked. Also as other answers suggest that the Content-Type header needs to be correct. For my request the correct Content-Type header was: So bottom line if your formdata is not being attached to the Request then it could potentially be your headers. Try bringing your headers to a minimum and then try adding them one by one to see if your problem is resolved.\n\nThe fetch API is a JavaScript function that allows devs to make HTTP requests. You can fetch (or retrieve) data, submit data, update existing data, and more. And all of this comes in a more powerful, flexible, and cleaner package than . When making these requests, we primarily deal with four types of HTTP methods, although there are several more:\n• GET: For retrieving data from the server. It doesn't change the server state.\n• POST: For sending data to the server, typically resulting in a change on the server.\n• PUT: For replacing a current resource with a new one. Note that the code samples below use for simplicity. If you don't want to use , you can change these examples to use the pattern. For a GET request, try this: In this block, we're retrieving data and making it available under the variable . For POSTing JSON data, use this: This block POSTs JSON data to a resource. You can capture the response JSON as ."
    },
    {
        "link": "https://topcoder.com/thrive/articles/fetch-api-javascript-how-to-make-get-and-post-requests",
        "document": "The Fetch API is a promise-based interface for fetching resources by making HTTP requests to servers from web browsers. It is similar to XML HTTP requests but better and more powerful.\n\nFetch API comes with a fetch () method that allows you to fetch data from all sorts of different places and work with the data fetched. It allows you to make an HTTP request, i.e., either a GET request (for getting data) or POST request (for posting data).\n\nThe basic fetch request can be explained by the following code:\n\nThe fetch() method has two parameters. The path to the resource is the first parameter and is required all the time, whereas the init parameter is optional. It then returns a promise that resolves into a response object. The response object further contains the data that needs to be converted into the required format in order to work with it. However, we must handle the HTTP errors as the promise only rejects network errors.\n\nconst response=fetch( URL [, init])\n\nURL: a URL object that represents the path of the resource to be fetched\n\nInit (optional): Any further options such as:\n• None Method: The request method is either GET or POST.\n• None Body: The body can be any of the following: Body.array.Buffer(), Body.Blob(), Body.formData(), Body.json(), Body.text().\n\nAs discussed, we know that HTTP errors must be handled by using the response object properties Response.ok and Response.status. Response.ok is a Boolean value that lets us know if the response was successful or not, whereas Response.status represents the HTTP status codes, such as 200 for success and 404 if the resource is not found. Have a look at the following response object:\n\nLet us look at a simple example of fetching an image which makes it easier to understand the concept. The steps involved will be:\n\nExplanation:\n\nIn the above example, we are using the async/await keyword that allows us to deal with promises in a readable and clean way. We are then using a method that creates a DOMString containing a URL representing the object. Finally, we create an IMG element and place the data fetched into the <img> element.\n\nExample 2: Fetching JSON data and displaying in an HTML table\n\nIn this example, we are extracting the JSON data fetched from a live API (https://www.thecocktaildb.com/) which is an open crowd-sourced database of drinks and cocktails from around the world. Let us look at the JSON data we have received in the console.\n\nThe dataset has many properties and in this example I am displaying two properties, the drink name(strDrink) and instructions(strInstructions), in an HTML table as shown in the output. We are adding a table element in our HTML and then iterating through the JSON data and adding them to the table (i.e., data.drinks[i].strDrink and data.drinks[i].strInstructions).\n\nSo far, we have discussed two examples for fetching data. The Fetch API not only provides us with a GET request, but it also provides us with POST, PUT and DELETE requests. Let us now look at a simple example of posting JSON data. For doing so, we are using an endpoint https://jsonplaceholder.typicode.com/guide/. Let us look at the JSON data in this endpoint:\n\nWe are creating a simple form for getting the title and body from the user in the HTML part. Note that the ID is automatically generated. Coming to the script, we are adding an event listener function and then calling the fetch method. In the fetch method, we are providing the URL of the endpoint and a configuration object. Finally we are displaying the data we have posted in our HTML elements <h4> and <h5>.\n\nOutput:\n\nThe JSON response as observed in the console:"
    },
    {
        "link": "https://geeksforgeeks.org/get-and-post-method-using-fetch-api",
        "document": "The fetch() method is used to send HTTP requests to the server without refreshing the page, providing an efficient alternative to the older XMLHttpRequest object. One of the main advantages of fetch() is that it uses Promises, which allow for better management of asynchronous operations compared to callbacks. Promises help avoid “callback hell,” where nested callbacks can become difficult to read and maintain.\n\nHowever, it’s worth noting that not all browsers support fetch() natively. For older browsers, you may still need to rely on the XMLHttpRequest object or use polyfills to ensure compatibility.\n\nThe fetch() method can handle different types of HTTP requests, such as GET, POST, PUT, and DELETE. In this article, we’ll explore how to use the fetch() API with practical examples.\n\nThe basic syntax for a fetch() request looks like this:\n• Promises in fetch(): Unlike XMLHttpRequest, fetch() is based on Promises, which makes it easier to manage multiple asynchronous operations.\n• Readable code: fetch() leads to more readable and maintainable code compared to callbacks in XMLHttpRequest.\n• Browser compatibility: While fetch() is widely supported, some older browsers may not support it. In such cases, XMLHttpRequest may still be necessary.\n\nUsing fetch() with Different HTTP Methods\n\nExample 1: GET Request using fetch()\n\nA GET request is used to retrieve data from a server. Let’s use https://jsonplaceholder.typicode.com/, a free REST API that returns sample data such as posts and users.\n\nFirst, create a basic HTML file that includes a JavaScript script where we’ll make our fetch requests.\n\nIn the JavaScript file (e.g., script.js), write the following code to fetch user data from the API:\n\nNow, when you open the HTML file you’ll see the result as follows: \n\n\n\n\n\nWhen you open DevTools in Chrome (Press F12) you’ll see that a fetch request has been made to the route users. \n\n\n\n\n\nYou can get more data from the request, refer to the https://jsonplaceholder.typicode.com/guide/documentation.\n\nA POST request is used to send data to the server, commonly for submitting forms or adding new data. In this example, we’ll send a POST request to add a new post to the posts endpoint of the JSONPlaceholder API. The server will return the created post with a unique ID.\n\nAdd the following code to your script.js file to perform a POST request:\n\nNow if you open your javascript console and refresh the page you’ll see a result like below:\n\n\n\nThe API returns a status of 201 which is a HTTP status code for Created.\n\nIt’s important to note that fetch() will only reject a Promise if there’s a network failure. It does not automatically reject responses with a status code outside the 2xx range (such as 404 or 500 errors). Therefore, you must manually check the response status using response.ok."
    },
    {
        "link": "https://stackoverflow.com/questions/41707032/making-post-request-using-fetch",
        "document": "If not using vanilla js I have always used jQuery to make requests. Now since React has been taking over, to make requests there is no need to use the whole library to make these requests so we are encouraged to use either js' built in method, axios or many others.\n\nI have been trying to make a request using . I am able to make it using but not fetch.\n\nThe axios code looks like this, but when I try what I believe to be the same thing using it doesn't work. Can anyone see what I am missing? The values are being posted, but the API is returning an error, so I must be doing something wrong."
    }
]