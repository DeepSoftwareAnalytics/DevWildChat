[
    {
        "link": "https://github.com/uuidjs/uuid",
        "document": "For the creation of RFC9562 (formerly RFC4122) UUIDs\n\nFor timestamp UUIDs, namespace UUIDs, and other options read on ...\n\nThe max UUID string (all ones).\n\nAPI is identical to , but uses \"v3\" instead.\n\nThis method takes the same arguments as uuid.v1().\n\nTest a string to see if it is a valid UUID\n\nUsing and together it is possible to do per-version validation, e.g. validate for only v4 UUIds.\n\nUUIDs can be generated from the command line using .\n\nThe default is to generate version 4 UUIDS, however the other versions are supported. Type for details:\n\nPrior to , it was possible for state to interfere with the internal state used to ensure uniqueness of timestamp-based UUIDs (the , , and methods). Starting with , this issue has been addressed by using the presence of the argument as a flag to select between two possible behaviors:\n• Without : Internal state is utilized to improve UUID uniqueness.\n• With : Internal state is NOT used and, instead, appropriate defaults are applied as needed.\n\nBrowsers: builds are tested against the latest version of desktop Chrome, Safari, Firefox, and Edge. Mobile versions of these same browsers are expected to work but aren't currently tested.\n\nNode: builds are tested against node (LTS releases), plus one prior. E.g. is in maintainence mode, and is the current LTS release. So supports - .\n\nTypescript: TS versions released within the past two years are supported. source\n\nThis error occurs in environments where the standard API is not supported. This issue can be resolved by adding an appropriate polyfill:\n• Import it before . Since might also appear as a transitive dependency of some other imports it's safest to just import as the very first thing in your entry point:"
    },
    {
        "link": "https://npmjs.com/package/uuid",
        "document": "For the creation of RFC9562 (formerly RFC4122) UUIDs\n\nFor timestamp UUIDs, namespace UUIDs, and other options read on ...\n\nThe max UUID string (all ones).\n\nAPI is identical to , but uses \"v3\" instead.\n\nThis method takes the same arguments as uuid.v1().\n\nTest a string to see if it is a valid UUID\n\nUsing and together it is possible to do per-version validation, e.g. validate for only v4 UUIds.\n\nUUIDs can be generated from the command line using .\n\nThe default is to generate version 4 UUIDS, however the other versions are supported. Type for details:\n\nPrior to , it was possible for state to interfere with the internal state used to ensure uniqueness of timestamp-based UUIDs (the , , and methods). Starting with , this issue has been addressed by using the presence of the argument as a flag to select between two possible behaviors:\n• Without : Internal state is utilized to improve UUID uniqueness.\n• With : Internal state is NOT used and, instead, appropriate defaults are applied as needed.\n\nBrowsers: builds are tested against the latest version of desktop Chrome, Safari, Firefox, and Edge. Mobile versions of these same browsers are expected to work but aren't currently tested.\n\nNode: builds are tested against node (LTS releases), plus one prior. E.g. is in maintainence mode, and is the current LTS release. So supports - .\n\nTypescript: TS versions released within the past two years are supported. source\n\nThis error occurs in environments where the standard API is not supported. This issue can be resolved by adding an appropriate polyfill:\n• Import it before . Since might also appear as a transitive dependency of some other imports it's safest to just import as the very first thing in your entry point:"
    },
    {
        "link": "https://github.com/LiosK/UUID.js/blob/master/README.md",
        "document": "UUID.js is a JavaScript/ECMAScript library to generate RFC 9562 compliant Universally Unique IDentifiers (UUIDs). This library supports UUIDv4 (random number-based UUIDs), UUIDv1 (Gregorian time-based UUIDs), and UUIDv6 (Reordered Gregorian time-based UUIDs). It also provides an object-oriented interface to print a generated or parsed UUID in a variety of forms.\n• Provides an object-oriented interface to print various string representations of a generated or parsed UUID\n• Utilizes a cryptographically secure pseudo-random number generator if available, whereas falling back to otherwise\n• Appends extra random bits to compensate for the lower timestamp resolution of JavaScript than that required for UUIDv1 and UUIDv6\n• Comes with a lot of test cases including format checks and statistical tests to maintain a high-quality code base\n\n, , , and return a UUID object that has various fields and methods.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    },
    {
        "link": "https://npmjs.com/package/uuidjs",
        "document": "UUID.js is a JavaScript/ECMAScript library to generate RFC 9562 compliant Universally Unique IDentifiers (UUIDs). This library supports UUIDv4 (random number-based UUIDs), UUIDv1 (Gregorian time-based UUIDs), and UUIDv6 (Reordered Gregorian time-based UUIDs). It also provides an object-oriented interface to print a generated or parsed UUID in a variety of forms.\n• Provides an object-oriented interface to print various string representations of a generated or parsed UUID\n• Utilizes a cryptographically secure pseudo-random number generator if available, whereas falling back to otherwise\n• Appends extra random bits to compensate for the lower timestamp resolution of JavaScript than that required for UUIDv1 and UUIDv6\n• Comes with a lot of test cases including format checks and statistical tests to maintain a high-quality code base\n\n, , , and return a UUID object that has various fields and methods.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    },
    {
        "link": "https://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid",
        "document": "Currently, UUID's are as specified in RFC4122. An often neglected edge case is the NIL UUID, noted here. The following regex takes this into account and will return a match for a NIL UUID. See below for a UUID which only accepts non-NIL UUIDs. Both of these solutions are for versions 1 to 5 (see the first character of the third block).\n\n...ensures you have a canonically formatted UUID that is Version 1 through 5 and is the appropriate Variant as per RFC4122.\n\nNOTE: Braces and are not canonical. They are an artifact of some systems and usages.\n\nEasy to modify the above regex to meet the requirements of the original question."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "document": "The WebSocket API makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive responses without having to poll the server for a reply.\n\nThe WebSocket API provides two alternative mechanisms for creating and using web socket connections: the interface and the interface.\n• The interface is stable and has good browser and server support. However it doesn't support backpressure. As a result, when messages arrive faster than the application can process them it will either fill up the device's memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\n• The interface is a -based alternative to . It uses the Streams API to handle receiving and sending messages, meaning that socket connections can take advantage of stream backpressure automatically, regulating the speed of reading or writing to avoid bottlenecks in the application. However, is non-standard and currently only supported in one rendering engine.\n\nAdditionally, the WebTransport API is expected to replace the WebSocket API for many applications. WebTransport is a versatile, low-level API that provides backpressure and many other features not supported by either or , such as unidirectional streams, out-of-order delivery, and unreliable data transmission via datagrams. WebTransport is more complex to use than WebSockets and its cross-browser support is not as wide, but it enables the implementation of sophisticated solutions. If standard WebSocket connections are a good fit for your use case and you need wide browser compatibility, you should employ the WebSockets API to get up and running quickly. However, if your application requires a non-standard custom solution, then you should use the WebTransport API."
    },
    {
        "link": "https://developer.chrome.com/docs/capabilities/web-apis/websocketstream",
        "document": "Prevent your app from getting drowned in WebSocket messages or flooding a WebSocket server with messages by applying backpressure.\n\nThe WebSocket API provides a JavaScript interface to the WebSocket protocol, which makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without polling the server for a reply.\n\nThe Streams API allows JavaScript to programmatically access streams of data chunks received over the network and process them as desired. An important concept in the context of streams is backpressure. This is the process by which a single stream or a pipe chain regulates the speed of reading or writing. When the stream itself or a stream later in the pipe chain is still busy and isn't yet ready to accept more chunks, it sends a signal backwards through the chain to slow delivery as appropriate.\n\nThe Problem with the current WebSocket API\n\nWith the current WebSocket API, reacting to a message happens in , an called when a message is received from the server.\n\nLet's assume you had an application that needs to perform heavy data crunching operations whenever a new message is received. You would probably set up the flow similar to the code below, and since you the result of the call, you should be good, right?\n\nWrong! The problem with the current WebSocket API is that there is no way to apply backpressure. When messages arrive faster than the method can handle them, the render process will either fill up memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\n\nApplying backpressure to sent messages is non-ergonomic\n\nApplying backpressure to sent messages is possible, but involves polling the property, which is inefficient and non-ergonomic. This read-only property returns the number of bytes of data that have been queued using calls to , but not yet transmitted to the network. This value resets to zero once all queued data has been sent, but if you keep calling , it will continue to climb.\n\nWhat is the WebSocketStream API?\n\nThe WebSocketStream API deals with the problem of non-existent or non-ergonomic backpressure by integrating streams with the WebSocket API. This means backpressure can be applied \"for free\", without any extra cost.\n\nSuggested use cases for the WebSocketStream API\n\nExamples of sites that can use this API include:\n• High-bandwidth WebSocket applications that need to retain interactivity, in particular video and screen-sharing.\n• Similarly, video capture and other applications that generate a lot of data in the browser that needs to be uploaded to the server. With backpressure, the client can stop producing data rather than accumulating data in memory.\n\nHow to use the WebSocketStream API\n\nThe WebSocketStream API is promise-based, which makes dealing with it feel natural in a modern JavaScript world. You start by constructing a new and passing it the URL of the WebSocket server. Next, you wait for the connection to be , which results in a and/or a .\n\nBy calling the method, you finally obtain a , which you can then data from until the stream is done, that is, until it returns an object of the form .\n\nAccordingly, by calling the method, you finally obtain a , which you can then data to.\n\nWhat about the promised backpressure feature? You get it \"for free\", no extra steps needed. If takes extra time, the next message is only consumed once the pipeline is ready. Likewise the step only proceeds if it is safe to do so.\n\nThe second argument to WebSocketStream is an option bag to allow for future extension. The only option is , which behaves the same as the second argument to the WebSocket constructor:\n\nThe selected as well as potential are part of the dictionary available via the promise. All the information about the live connection is provided by this promise, since it is not relevant if the connection fails.\n\nThe information that was available from the and events in the WebSocket API is now available via the promise. The promise rejects in the event of an unclean close, otherwise it resolves to the code and reason sent by the server.\n\nAll possible status codes and their meaning is explained in the list of status codes.\n\nA WebSocketStream can be closed with an . Therefore, pass an to the constructor.\n\nAs an alternative, you can also use the method, but its main purpose is to permit specifying the code and reason which is sent to the server.\n\nChrome is currently the only browser to implement the WebSocketStream API. For interoperability with the classic WebSocket API, applying backpressure to received messages is not possible. Applying backpressure to sent messages is possible, but involves polling the property, which is inefficient and non-ergonomic.\n\nTo check if the WebSocketStream API is supported, use:\n\nOn supporting browsers, you can see the WebSocketStream API in action in the embedded iframe, or directly on Glitch.\n\nThe Chrome team wants to hear about your experiences with the WebSocketStream API.\n\nTell us about the API design\n\nIs there something about the API that doesn't work like you expected? Or are there missing methods or properties that you need to implement your idea? Have a question or comment on the security model? File a spec issue on the corresponding GitHub repo, or add your thoughts to an existing issue.\n\nDid you find a bug with Chrome's implementation? Or is the implementation different from the spec? File a bug at new.crbug.com. Be sure to include as much detail as you can, simple instructions for reproducing, and enter in the Components box. Glitch works great for sharing quick and easy reproduction cases.\n\nAre you planning to use the WebSocketStream API? Your public support helps the Chrome team to prioritize features and shows other browser vendors how critical it is to support them.\n\nSend a tweet to @ChromiumDev using the hashtag and let us know where and how you're using it.\n\nThe WebSocketStream API was implemented by Adam Rice and Yutaka Hirano."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://grafana.com/docs/k6/latest/javascript-api/k6-experimental/websockets",
        "document": "This is an experimental module.\n\n\n\nWhile we intend to keep experimental modules as stable as possible, we may need to introduce breaking changes. This could happen at future k6 releases until the module becomes fully stable and graduates as a k6 core module. For more information, refer to the extension graduation process.\n\n\n\nExperimental modules maintain a high level of stability and follow regular maintenance and security measures. Feel free to open an issue if you have any feedback or suggestions.\n\nThis experimental API implements the browser WebSocket API with additional k6-specific functionalities (cookies, tags, headers and so on).\n\nThe main difference between this module and is that this module uses a global event loop instead of a local one. A global event loop lets a single VU have multiple concurrent connections, which improves performance.\n\nThe is not fully implemented, and we’re working on it, but we believe it’s usable for most users. So whether you’re writing a new WebSocket test, or currently using the module, we invite you to give it a try, and report any issues in the project’s issue tracker. Our midterm goal is to make this module part of k6 core, and long-term to replace the module.\n\nA WebSocket instance also has the following properties:\n\nk6 takes specific measurements for Websockets. For the complete list, refer to the Metrics reference.\n• How to use the timeout and interval functions to stop the connections after some period."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\n* Some parts of this feature may have varying levels of support."
    }
]