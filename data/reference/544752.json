[
    {
        "link": "https://biopython.org/wiki/SeqIO",
        "document": "This page describes , the standard Sequence Input/Output interface for BioPython 1.43 and later. For implementation details, see the development page.\n\nPython novices might find Peter’s introductory Biopython Workshop useful which start with working with sequence files using SeqIO.\n\nThere is a whole chapter in the Tutorial (PDF) on , and although there is some overlap it is well worth reading in addition to this WIKI page. There is also the API documentation (which you can read online, or from within Python with the help command).\n\nprovides a simple uniform interface to input and output assorted sequence file formats (including multiple sequence alignments), but will only deal with sequences as objects. There is a sister interface for working directly with sequence alignment files as Alignment objects.\n\nThe design was partly inspired by the simplicity of BioPerl’s SeqIO. In the long term we hope to match BioPerl’s impressive list of supported sequence file formats and multiple alignment formats.\n\nNote that the inclusion of (and ) in Biopython does lead to some duplication or choice in how to deal with some file formats. For example, will also read sequences from Nexus files - but can also do much more, for example reading any phylogenetic trees in a Nexus file.\n\nMy vision is that for manipulating sequence data you should try as your first choice. Unless you have some very specific requirements, I hope this should suffice.\n\nThe authorative list of supported formats is in the code’s docstrings. The table here may not be fully up to date.\n\nThis table lists the file formats that can read, write and index, with the Biopython version where this was first supported (or git to indicate this is supported in our latest in development code). The format name is a simple lowercase string. Where possible we use the same name as BioPerl’s SeqIO and EMBOSS.\n\nWith you can treat sequence alignment file formats just like any other sequence file, but the new module is designed to work with such alignment files directly. You can also convert a set of objects from any file format into an alignment - provided they are all the same length. Note that when using to write sequences to an alignment file format, all the (gapped) sequences should be the same length.\n\nThe main function is which takes a file handle (or filename) and format name, and returns a iterator. This lets you do things like:\n\nIn the above example, we opened the file using the built-in python function . The - statement makes sure that the file is properly closed after reading it. That should all happen automatically if you just use the filename instead.\n\nNote that you must specify the file format explicitly, unlike BioPerl’s SeqIO which can try to guess using the file name extension and/or the file contents. See Explicit is better than implicit (The Zen of Python).\n\nIf you had a different type of file, for example a Clustalw alignment file such as which contains seven sequences, the only difference is you specify instead of :\n\nIterators are great for when you only need the records one by one, in the order found in the file. For some tasks you may need to have random access to the records in any order. In this situation, use the built in python function to turn the iterator into a list:\n\nAnother common task is to index your records by some identifier. For small files we have a function to turn a iterator (or list) into a dictionary (in memory):\n\nThe function will use the record ID as the dictionary key by default, but you can specify any mapping you like with its optional argument, .\n\nFor larger files, it isn’t possible to hold everything in memory, so is not suitable. Biopython 1.52 inwards includes the function for this situation, but you might also consider .\n\nBiopython 1.45 introduced another function, , which like will expect a handle and format. It is for use when the handle contains one and only one record, which is returned as a single object. If there are no records, or more than one, then an exception is raised:\n\nFor the related situation where you just want the first record (and are happy to ignore any subsequent records), you can use the built-in python function :\n\nFor writing records to a file use the function , which takes a iterator (or list), output handle (or filename) and format string:\n\nThere are more examples in the following section on converting between file formats.\n\nNote that if you are writing to an alignment file format, all your sequences must be the same length.\n\nIf you supply the sequences as a iterator, then for sequential file formats like Fasta or GenBank, the records can be written one by one. Because only one record is created at a time, very little memory is required. See the example below filtering a set of records.\n\nOn the other hand, for interlaced or non-sequential file formats like Clustal, the function will be forced to automatically convert an iterator into a list. This will destroy any potential memory saving from using an generator/iterator approach.\n\nSuppose you have a GenBank file which you want to turn into a Fasta file. For example, lets consider the file which is included in the Biopython unit tests under the GenBank directory.\n\nYou could read the file like this, using the function:\n\nNotice that this file contains six records. Now instead of printing the records, let’s pass the iterator to the function, to turn this GenBank file into a Fasta file:\n\nOr more concisely using the function (in Biopython 1.52 or later), just:\n\nIn this example the GenBank file started like this:\n\nThe resulting Fasta file looks like this:\n\nNote that all the Fasta file can store is the identifier, description and sequence.\n\nBy changing the format strings, that code could be used to convert between any supported file formats.\n\nWhile you may simply want to convert a file (as shown above), a more realistic example is to manipulate or filter the data in some way.\n\nFor example, let’s save all the “short” sequences of less than 300 nucleotides to a Fasta file:\n\nIf you know about list comprehensions then you could have written the above example like this instead:\n\nI’m not convinced this is actually any easier to understand, but it is shorter.\n\nHowever,if you are dealing with very large files with thousands of records, you could benefit from using a generator expression instead. This avoids creating the entire list of desired records in memory:\n\nRemember that for sequential file formats like Fasta or GenBank, will accept a iterator. The advantage of the code above is that only one record will be in memory at any one time.\n\nHowever, as explained in the output section, for non-sequential file formats like Clustal is forced to automatically turn the iterator into a list, so this advantage is lost.\n\nIf this is all confusing, don’t panic and just ignore the fancy stuff. For moderately sized datasets having too many records in memory at once (e.g. in lists) is probably not going to be a problem.\n\nIn this example, we’ll use with the module (in Biopython 1.44 or later). First of all, we’ll just print out the checksum for each sequence in the GenBank file :\n\nYou should get this output:\n\nNow lets use the checksum function and to build a dictionary using the SEGUID as the keys. The trick here is to use the Python lambda syntax to create a temporary function to get the SEGUID for each - we can’t use the function directly as it only works on objects or strings.\n\nThis script will read a Genbank file with a whole mitochondrial genome (e.g. the tobacco mitochondrion, Nicotiana tabacum mitochondrion ), create 500 records containing random fragments of this genome, and save them as a fasta file. These subsequences are created using a random starting points and a fixed length of 200.\n\nThat should give something like this as the output file,\n\nSometimes you won’t want to write your object(s) to a file, but to a string. For example, you might be preparing output for display as part of a webpage. If you want to write multiple records to a single string, use to create a string-based handle. The Tutorial (PDF) has an example of this in the chapter.\n\nFor the special case where you want a single record as a string in a given file format, Biopython 1.48 added a new format method:\n\nThe format method will take any output format supported by where the file format can be used for a single record (e.g. , or ).\n\nNote that we don’t recommend you use this for file output - using is faster and more general.\n\nIf you are having problems with , please join the discussion mailing list (see mailing lists).\n\nIf you think you’ve found a bug, please report it on the project’s GitHub page."
    },
    {
        "link": "https://biopython.org/docs/1.76/api/Bio.SeqIO.html",
        "document": "Bio.SeqIO is also documented at SeqIO and by a whole chapter in our tutorial:\n\nThe main function is Bio.SeqIO.parse(…) which takes an input file handle (or in recent versions of Biopython alternatively a filename as a string), and format string. This returns an iterator giving SeqRecord objects: Note that the parse() function will invoke the relevant parser for the format with its default settings. You may want more control, in which case you need to create a format specific sequence iterator directly. Some of these parsers are wrappers around low-level parsers which build up SeqRecord objects for the consistent SeqIO interface. In cases where the run-time is critical, such as large FASTA or FASTQ files, calling these underlying parsers will be much faster - in this case these generator functions which return tuples of strings:\n\nIf you expect your file to contain one-and-only-one record, then we provide the following ‘helper’ function which will return a single SeqRecord, or raise an exception if there are no records or more than one record: This style is useful when you expect a single record only (and would consider multiple records an error). For example, when dealing with GenBank files for bacterial genomes or chromosomes, there is normally only a single record. Alternatively, use this with a handle when downloading a single record from the internet. However, if you just want the first record from a file containing multiple record, use the next() function on the iterator (or under Python 2, the iterator’s next() method): The above code will work as long as the file contains at least one record. Note that if there is more than one record, the remaining records will be silently ignored.\n\nFor non-interlaced files (e.g. Fasta, GenBank, EMBL) with multiple records using a sequence iterator can save you a lot of memory (RAM). There is less benefit for interlaced file formats (e.g. most multiple alignment file formats). However, an iterator only lets you access the records one by one. If you want random access to the records by number, turn this into a list: If you want random access to the records by a key such as the record id, turn the iterator into a dictionary: However, using list() or the to_dict() function will load all the records into memory at once, and therefore is not possible on very large files. Instead, for some file formats Bio.SeqIO provides an indexing approach providing dictionary like access to any record. For example, Many but not all of the supported input file formats can be indexed like this. For example “fasta”, “fastq”, “qual” and even the binary format “sff” work, but alignment formats like “phylip”, “clustalw” and “nexus” will not. In most cases you can also use SeqIO.index to get the record from the file as a raw string (not a SeqRecord). This can be useful for example to extract a sub-set of records from a file where SeqIO cannot output the file format (e.g. the plain text SwissProt format, “swiss”) or where it is important to keep the output 100% identical to the input). For example, Here the original file and what Biopython would output differ in the line wrapping. Also note that under Python 3, the get_raw method will return a bytes string, hence the use of decode to turn it into a (unicode) string. This is unnecessary on Python 2. Also note that the get_raw method will preserve the newline endings. This example FASTQ file uses Unix style endings (b”n” only), Here is the same file but using DOS/Windows new lines (b”rn” instead), Because this uses two bytes for each new line, the file is longer than the Unix equivalent with only one byte.\n\nThe effect of calling write() multiple times on a single file will vary depending on the file format, and is best avoided unless you have a strong reason to do so. If you give a filename, then each time you call write() the existing file will be overwritten. For sequential files formats (e.g. fasta, genbank) each “record block” holds a single sequence. For these files it would probably be safe to call write() multiple times by re-using the same handle. However, trying this for certain alignment formats (e.g. phylip, clustal, stockholm) would have the effect of concatenating several multiple sequence alignments together. Such files are created by the PHYLIP suite of programs for bootstrap analysis, but it is clearer to do this via Bio.AlignIO instead. Worse, many fileformats have an explicit header and/or footer structure (e.g. any XMl format, and most binary file formats like SFF). Here making multiple calls to write() will result in an invalid file.\n\nWhen specifying the file format, use lowercase strings. The same format names are also used in Bio.AlignIO and include the following:\n• None abi-trim - Same as “abi” but with quality trimming with Mott’s algorithm\n• None ace - Reads the contig sequences from an ACE assembly file.\n• None cif-atom - Uses Bio.PDB.MMCIFParser to determine the (partial) protein sequence as it appears in the structure based on the atomic coordinates.\n• None cif-seqres - Reads a macromolecular Crystallographic Information File (mmCIF) file to determine the complete protein sequence as defined by the _pdbx_poly_seq_scheme records.\n• None fasta - The generic sequence file format where each record starts with an identifer line starting with a “>” character, followed by lines of sequence.\n• None fasta-2line - Stricter interpretation of the FASTA format using exactly two lines per record (no line wrapping).\n• None fastq - A “FASTA like” format used by Sanger which also stores PHRED sequence quality values (with an ASCII offset of 33).\n• None fastq-sanger - An alias for “fastq” for consistency with BioPerl and EMBOSS\n• None fastq-solexa - Original Solexa/Illumnia variant of the FASTQ format which encodes Solexa quality scores (not PHRED quality scores) with an ASCII offset of 64.\n• None fastq-illumina - Solexa/Illumina 1.3 to 1.7 variant of the FASTQ format which encodes PHRED quality scores with an ASCII offset of 64 (not 33). Note as of version 1.8 of the CASAVA pipeline Illumina will produce FASTQ files using the standard Sanger encoding.\n• None gb - An alias for “genbank”, for consistency with NCBI Entrez Utilities\n• None ig - The IntelliGenetics file format, apparently the same as the MASE alignment format.\n• None imgt - An EMBL like format from IMGT where the feature tables are more indented to allow for longer feature types.\n• None nib - UCSC’s nib file format for nucleotide sequences, which uses one nibble (4 bits) to represent each nucleotide, and stores two nucleotides in one byte.\n• None pdb-seqres - Reads a Protein Data Bank (PDB) file to determine the complete protein sequence as it appears in the header (no dependencies).\n• None pdb-atom - Uses Bio.PDB to determine the (partial) protein sequence as it appears in the structure based on the atom coordinate section of the file (requires NumPy for Bio.PDB).\n• None phd - Output from PHRED, used by PHRAP and CONSED for input.\n• None pir - A “FASTA like” format introduced by the National Biomedical Research Foundation (NBRF) for the Protein Information Resource (PIR) database, now part of UniProt.\n• None seqxml - SeqXML, simple XML format described in Schmitt et al (2011).\n• None tab - Simple two column tab separated sequence files, where each line holds a record’s identifier and sequence. For example, this is used as by Aligent’s eArray software when saving microarray probes in a minimal tab delimited text file.\n• None qual - A “FASTA like” format holding PHRED quality values from sequencing DNA, but no actual sequences (usually provided in separate FASTA files).\n• None uniprot-xml - The UniProt XML format (replacement for the SwissProt plain text format which we call “swiss”) Note that while Bio.SeqIO can read all the above file formats, it cannot write to all of them. You can also use any file format supported by Bio.AlignIO, such as “nexus”, “phylip” and “stockholm”, which gives you access to the individual sequences making up each alignment as SeqRecords.\n• None sequences - A list (or iterator) of SeqRecord objects, or (if using Biopython 1.54 or later) a single SeqRecord.\n• None handle - File handle object to write to, or filename as string (note older versions of Biopython only took a handle). Note if providing a file handle, your code should close the handle after calling this function (to ensure the data gets flushed to disk). Returns the number of records written (as an integer).\n• None handle - handle to the file, or the filename as a string (note older versions of Biopython only took a handle).\n• None alphabet - optional Alphabet object, useful when the sequence type cannot be automatically inferred from the file itself (e.g. format=”fasta” or “tab”) Typical usage, opening a file to read in, and looping over the record(s): For file formats like FASTA where the alphabet cannot be determined, it may be useful to specify the alphabet explicitly: If you have a string ‘data’ containing the file contents, you must first turn this into a handle in order to parse it: Use the Bio.SeqIO.read(…) function when you expect a single record only.\n• None handle - handle to the file, or the filename as a string (note older versions of Biopython only took a handle).\n• None alphabet - optional Alphabet object, useful when the sequence type cannot be automatically inferred from the file itself (e.g. format=”fasta” or “tab”) This function is for use parsing sequence files containing exactly one record. For example, reading a GenBank file: If the handle contains no records, or more than one record, an exception is raised. For example: : More than one record found in handle If however you want the first record from a file containing multiple records this function would raise an exception (as shown in the example above). Instead use: Use the Bio.SeqIO.parse(handle, format) function if you want to read multiple records from the handle.\n• None sequences - An iterator that returns SeqRecord objects, or simply a list of SeqRecord objects.\n• None key_function - Optional callback function which when given a SeqRecord should return a unique key for the dictionary. If key_function is omitted then record.id is used, on the assumption that the records objects returned are SeqRecords with a unique id. If there are duplicate keys, an error is raised. Since Python 3.7, the default dict class maintains key order, meaning this dictionary will reflect the order of records given to it. For CPython, this was already implemented in 3.6. As of Biopython 1.73, we explicitly use OrderedDict for CPython older than 3.6 (and for other Python older than 3.7) so that you can always assume the record order is preserved. Example usage, defaulting to using the record.id as key: A more complex example, using the key_function argument in order to use a sequence checksum as the dictionary key: This approach is not suitable for very large sets of sequences, as all the SeqRecord objects are held in memory. Instead, consider using the Bio.SeqIO.index() function (if it supports your particular file format). Since Python 3.6, the default dict class maintains key order, meaning this dictionary will reflect the order of records given to it. As of Biopython 1.72, on older versions of Python we explicitly use an OrderedDict so that you can always assume the record order is preserved.\n• None filename - string giving name of file to be indexed\n• None alphabet - optional Alphabet object, useful when the sequence type cannot be automatically inferred from the file itself (e.g. format=”fasta” or “tab”)\n• None key_function - Optional callback function which when given a SeqRecord identifier string should return a unique key for the dictionary. This indexing function will return a dictionary like object, giving the SeqRecord objects as values. As of Biopython 1.69, this will preserve the ordering of the records in file when iterating over the entries. If the file is BGZF compressed, this is detected automatically. Ordinary GZIP files are not supported: Note that this pseudo dictionary will not support all the methods of a true Python dictionary, for example values() is not defined as in Python 2 since this would require loading all of the records into memory at once. When you call the index function, it will scan through the file, noting the location of each record. When you access a particular record via the dictionary methods, the code will jump to the appropriate part of the file and then parse that section into a SeqRecord. Note that not all the input formats supported by Bio.SeqIO can be used with this index function. It is designed to work only with sequential file formats (e.g. “fasta”, “gb”, “fastq”) and is not suitable for any interlaced file format (e.g. alignment formats such as “clustal”). For small files, it may be more efficient to use an in memory Python dictionary, e.g. As with the to_dict() function, by default the id string of each record is used as the key. You can specify a callback function to transform this (the record identifier string) into your preferred key. For example: Another common use case would be indexing an NCBI style FASTA file, where you might want to extract the GI number from the FASTA identifier to use as the dictionary key. Notice that unlike the to_dict() function, here the key_function does not get given the full SeqRecord to use to generate the key. Doing so would impose a severe performance penalty as it would require the file to be completely parsed while building the index. Right now this is usually avoided. See Also: Bio.SeqIO.index_db() and Bio.SeqIO.to_dict() Index several sequence files and return a dictionary like object. The index is stored in an SQLite database rather than in memory (as in the Bio.SeqIO.index(…) function).\n• None index_filename - Where to store the SQLite index\n• None filenames - list of strings specifying file(s) to be indexed, or when indexing a single file this can be given as a string. (optional if reloading an existing index, but must match)\n• None format - lower case string describing the file format (optional if reloading an existing index, but must match)\n• None alphabet - optional Alphabet object, useful when the sequence type cannot be automatically inferred from the file itself (e.g. format=”fasta” or “tab”)\n• None key_function - Optional callback function which when given a SeqRecord identifier string should return a unique key for the dictionary. This indexing function will return a dictionary like object, giving the SeqRecord objects as values: #use an in memory SQLite DB for this test In this example the two files contain 85 and 10 records respectively. BGZF compressed files are supported, and detected automatically. Ordinary GZIP compressed files are not supported. See Also: Bio.SeqIO.index() and Bio.SeqIO.to_dict(), and the Python module glob which is useful for building lists of files. Convert between two sequence file formats, return number of records. NOTE - If you provide an output filename, it will be opened which will overwrite any existing file without warning. This may happen if even the conversion is aborted (e.g. an invalid out_format name is given). For example, going from a filename to a handle:"
    },
    {
        "link": "https://biopython.org/DIST/docs/tutorial/Tutorial-1.83.html",
        "document": "\n• Chapter 1 Introduction\n• 1.2 What can I find in the Biopython package\n• Chapter 2 Quick Start – What can you do with Biopython?\n• 2.1 General overview of what Biopython provides\n• 2.4 Parsing sequence file formats\n• 2.4.3 I love parsing – please don’t stop talking about it!\n• 2.6 What to do next\n• Chapter 4 Sequence annotation objects\n• 4.3 Feature, location and position objects\n• 4.3.3 Sequence described by a feature or location\n• Chapter 5 Sequence Input/Output\n• 5.1 Parsing or Reading Sequences\n• 5.1.2 Iterating over the records in a sequence file\n• 5.1.3 Getting a list of the records in a sequence file\n• 5.5 Writing Sequence Files\n• 5.5.3 Converting a file of sequences to their reverse complements\n• 5.5.4 Getting your SeqRecord objects as formatted strings\n• Chapter 6 Sequence alignments\n• 6.1 Alignment objects\n• 6.1.1 Creating an Alignment object from sequences and coordinates\n• 6.3 Getting information about the alignment\n• Chapter 7 Pairwise sequence alignment\n• 7.11 Generalized pairwise alignments\n• 7.11.2 Generalized pairwise alignments using match/mismatch scores and an alphabet\n• Chapter 8 Multiple Sequence Alignment objects\n• 8.2 Writing Alignments\n• 8.2.2 Getting your alignment objects as formatted strings\n• Chapter 12 Accessing NCBI’s Entrez databases\n• 12.15 Examples\n• 12.15.4 Finding the lineage of an organism\n• 12.16 Using the history and WebEnv\n• 12.16.1 Searching for and downloading sequences using the history\n• 12.16.2 Searching for and downloading abstracts using the history\n• Chapter 14 Going 3D: The PDB module\n• 14.6 Analyzing structures\n• 14.6.7 Mapping the residues of two related structures onto each other\n• 14.8 Accessing the Protein Data Bank\n• 14.8.3 Keeping a local copy of the PDB up to date\n• 14.9 General questions\n• 14.9.1 How well tested is Bio.PDB?\n• 14.9.2 How fast is it?\n• 14.9.3 Is there support for molecular graphics?\n• Chapter 17 Sequence motif analysis using Bio.motifs\n• 17.6 Searching for instances\n• 17.6.2 Searching for matches using the PSSM score\n• 17.7 Each motif object has an associated Position-Specific Scoring Matrix\n• Chapter 22 Cookbook – Cool things to do with it\n• Chapter 24 Where to go from here – contributing to Biopython\n• Chapter 25 Appendix: Useful stuff about Python\n• 25.1 What the heck is a handle?\n\nBiopython is a collection of freely available Python (https://www.python.org) modules for computational molecular biology. Python is an object oriented, interpreted, flexible language that is widely used for scientific computing. Python is easy to learn, has a very clear syntax and can easily be extended with modules written in C, C++ or FORTRAN. Since its inception in 2000 [4], Biopython has been continuously developed and maintained by a large group of volunteers worldwide.\n\nThe Biopython web site (http://www.biopython.org) provides an online resource for modules, scripts, and web links for developers of Python-based software for bioinformatics use and research. Biopython includes parsers for various bioinformatics file formats (BLAST, Clustalw, FASTA, Genbank,...), access to online services (NCBI, Expasy,...), a standard sequence class, sequence alignment and motif analysis tools, clustering algorithms, a module for structural biology, and a module for phylogenetics analysis.\n\n1.2 What can I find in the Biopython package\n\nThe main Biopython releases have lots of functionality, including:\n• The ability to parse bioinformatics files into Python utilizable data structures, including support for the following formats:\n• Blast output – both from standalone and WWW Blast\n• Files in the supported formats can be iterated over record by record or indexed and accessed via a Dictionary interface.\n• Code to deal with popular on-line bioinformatics destinations such as:\n• ExPASy – Swiss-Prot and Prosite entries, as well as Prosite searches\n• Interfaces to common bioinformatics programs such as:\n• A standard sequence class that deals with sequences, ids on sequences, and sequence features.\n• Tools for performing common operations on sequences, such as translation, transcription and weight calculations.\n• Code to perform classification of data using k Nearest Neighbors, Naive Bayes or Support Vector Machines.\n• Code for dealing with alignments, including a standard way to create and deal with substitution matrices.\n• Code making it easy to split up parallelizable tasks into separate processes.\n• GUI-based programs to do basic sequence manipulations, translations, BLASTing, etc.\n• Extensive documentation and help with using the modules, including this file, on-line wiki documentation, the web site, and the mailing list.\n• Integration with BioSQL, a sequence database schema also supported by the BioPerl and BioJava projects.\n\nWe hope this gives you plenty of reasons to download and start using Biopython!\n\nAll of the installation information for Biopython was separated from this document to make it easier to keep updated.\n\nThe short version is use , see the main README file for other options.\n• How do I cite Biopython in a scientific publication? \n\n Please cite our application note [5, Cock , 2009] as the main Biopython reference. In addition, please cite any publications from the following list if appropriate, in particular as a reference for specific modules within Biopython (more information can be found on our website):\n• For the official project announcement: [4, Chapman and Chang, 2000];\n• For the FASTQ file format as supported in Biopython, BioPerl, BioRuby, BioJava, and EMBOSS: [6, Cock , 2010].\n• How should I capitalize “Biopython”? Is “BioPython” OK? \n\n The correct capitalization is “Biopython”, not “BioPython” (even though that would have matched BioPerl, BioJava and BioRuby).\n• How is the Biopython software licensed? \n\n Biopython is distributed under the Biopython License Agreement. However, since the release of Biopython 1.69, some files are explicitly dual licensed under your choice of the Biopython License Agreement or the BSD 3-Clause License. This is with the intention of later offering all of Biopython under this dual licensing approach.\n• What is the Biopython logo and how is it licensed? \n\n As of July 2017 and the Biopython 1.70 release, the Biopython logo is a yellow and blue snake forming a double helix above the word “biopython” in lower case. It was designed by Patrick Kunzmann and this logo is dual licensed under your choice of the Biopython License Agreement or the BSD 3-Clause License. Prior to this, the Biopython logo was two yellow snakes forming a double helix around the word “BIOPYTHON”, designed by Henrik Vestergaard and Thomas Hamelryck in 2003 as part of an open competition.\n• Do you have a change-log listing what’s new in each release? \n\n See the file included with the source code (originally called just ), or read the latest NEWS file on GitHub.\n• What is going wrong with my print commands? \n\n As of Biopython 1.77, we only support Python 3, so this tutorial uses the Python 3 style print function.\n• How do I find out what version of Biopython I have installed? \n\n Use this: If the “ ” line fails, Biopython is not installed. Note that those are double underscores before and after version. If the second line fails, your version is very out of date. If the version string ends with a plus like “ ”, you don’t have an official release, but an old snapshot of the in development code after that version was released. This naming was used until June 2016 in the run-up to Biopython 1.68. If the version string ends with “ ” like “ ”, again you don’t have an official release, but instead a snapshot of the in development code before that version was released.\n• Where is the latest version of this document?\n\n If you download a Biopython source code archive, it will include the relevant version in both HTML and PDF formats. The latest published version of this document (updated at each release) is online:\n• What is wrong with my sequence comparisons? \n\n There was a major change in Biopython 1.65 making the and classes (and subclasses) use simple string-based comparison which you can do explicitly with . Older versions of Biopython would use instance-based comparison for objects which you can do explicitly with . If you still need to support old versions of Biopython, use these explicit forms to avoid problems. See Section 3.10.\n• What file formats do and read and write? \n\n Check the built in docstrings ( , then ), or see and on the wiki for the latest listing.\n• Why won’t the and functions , and take filenames? They insist on handles! \n\n You need Biopython 1.54 or later, or just use handles explicitly (see Section 25.1). It is especially important to remember to close output handles explicitly after writing your data.\n• Why won’t the and functions accept a single record or alignment? They insist on a list or iterator! \n\n You need Biopython 1.54 or later, or just wrap the item with to create a list of one element.\n• Why doesn’t give me the full sequence of a object? \n\n You need Biopython 1.45 or later.\n• Why doesn’t work with the latest plain text NCBI blast output? \n\n The NCBI keep tweaking the plain text output from the BLAST tools, and keeping our parser up to date is/was an ongoing struggle. If you aren’t using the latest version of Biopython, you could try upgrading. However, we (and the NCBI) recommend you use the XML output instead, which is designed to be read by a computer program.\n• Why has my script using stopped working? \n\n This could be due to NCBI changes in February 2012 introducing EFetch 2.0. First, they changed the default return modes - you probably want to add to your call. Second, they are now stricter about how to provide a list of IDs – Biopython 1.59 onwards turns a list into a comma separated string automatically.\n• Why doesn’t give the same results as the NCBI BLAST website? \n\n You need to specify the same options – the NCBI often adjust the default settings on the website, and they do not match the QBLAST defaults anymore. Check things like the gap penalties and expectation threshold.\n• Why can’t I add objects together? \n\n You need Biopython 1.53 or later.\n• Why doesn’t work? The module imports fine but there is no function! \n\n You need Biopython 1.57 or later (and a Python with SQLite3 support).\n• Where is the object? The module imports fine but this class isn’t there! \n\n You need Biopython 1.54 or later. Alternatively, the older class supports some of its functionality, but using this is now discouraged.\n• Why can’t I run command line tools directly from the application wrappers? \n\n You need Biopython 1.55 or later, but these were deprecated in Biopython 1.78. Consider using the Python module directly.\n• I looked in a directory for code, but I couldn’t find the code that does something. Where’s it hidden? \n\n One thing to know is that we put code in files. If you are not used to looking for code in this file this can be confusing. The reason we do this is to make the imports easier for users. For instance, instead of having to do a “repetitive” import like , you can just use .\n• Why doesn’t work? \n\n We deprecated the module in Biopython 1.51 (August 2009) and removed it in Biopython 1.55 (August 2010). There is a brief example showing how to convert old code to use instead in the DEPRECATED.rst file.\n\nFor more general questions, the Python FAQ pages https://docs.python.org/3/faq/index.html may be useful.\n\nChapter 2 Quick Start – What can you do with Biopython?\n\nThis section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of Python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your Python, the main Python web site provides quite a bit of free documentation to get started with (https://docs.python.org/3/).\n\nSince much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run.\n\nNow that that is all out of the way, let’s get into what we can do with Biopython.\n\n2.1 General overview of what Biopython provides\n\nAs mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with “things” of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in Python, of course!) or at least an interest in learning to program. Biopython’s job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn’t exist and contributing it to Biopython, please go ahead!). So Biopython’s job is to make you happy!\n\nOne thing to note about Biopython is that it often provides multiple ways of “doing the same thing.” Things have improved in recent releases, but this can still be frustrating as in Python there should ideally be one right way to do something. However, this can also be a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look in the Cookbook (Chapter 22, this has some cools tricks and tips), and built in “docstrings” (via the Python help command, or the API documentation) or ultimately the code itself.\n\nDisputably (of course!), the central object in bioinformatics is the sequence. Thus, we’ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the object, which we’ll discuss in more detail in Chapter 3.\n\nMost of the time when we think about sequences we have in my mind a string of letters like ‘ ’. You can create such object with this sequence as follows - the “ ” represents the Python prompt followed by what you would type in:\n\nThe object differs from the Python string in the methods it supports. You can’t do this with a plain string:\n\nThe next most important class is the or Sequence Record. This holds a sequence (as a object) with additional annotation including an identifier, name and description. The module for reading and writing sequence file formats works with objects, which will be introduced below and covered in more detail by Chapter 5.\n\nThis covers the basic features and uses of the Biopython sequence class. Now that you’ve got some idea of what it is like to interact with the Biopython libraries, it’s time to delve into the fun, fun world of dealing with biological file formats!\n\nBefore we jump right into parsers and everything else to do with Biopython, let’s set up an example to motivate everything we do and make life more interesting. After all, if there wasn’t any biology in this tutorial, why would you want you read it?\n\nSince I love plants, I think we’re just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we’ve suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some Lady Slipper Orchids photos on Flickr, or try a Google Image Search).\n\nOf course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So let’s suppose we’re thinking about writing a funding proposal to do a molecular study of Lady Slipper evolution, and would like to see what kind of research has already been done and how we can add to that.\n\nAfter a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: Cypripedium, Paphiopedilum, Phragmipedium, Selenipedium and Mexipedium.\n\nThat gives us enough to get started delving for more information. So, let’s look at how the Biopython tools can help us. We’ll start with sequence parsing in Section 2.4, but the orchids will be back later on as well - for example we’ll search PubMed for papers about orchids and extract sequence data from GenBank in Chapter 12, extract data from Swiss-Prot from certain orchid proteins in Chapter 13, and work with ClustalW multiple sequence alignments of orchid proteins in Section 6.7.2.\n\nA large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers.\n\nWe are now going to briefly introduce the module – you can find out more in Chapter 5. We’ll start with an online search for our friends, the lady slipper orchids. To keep this introduction simple, we’re just using the NCBI website by hand. Let’s just take a look through the nucleotide databases at NCBI, using an Entrez online search (https://www.ncbi.nlm.nih.gov/nuccore/?term=Cypripedioideae) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids).\n\nWhen this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file and as a GenBank formatted text file (files ls_orchid.fasta and ls_orchid.gbk, also included with the Biopython source code under Doc/examples/).\n\nIf you run the search today, you’ll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from in the Biopython source code. In Section 2.5 we will look at how to do a search like this from within Python.\n\nIf you open the lady slipper orchids FASTA file ls_orchid.fasta in your favorite text editor, you’ll see that the file starts like this:\n\nIt contains 94 records, each has a line starting with “ ” (greater-than symbol) followed by the sequence on one or more lines. Now try this in Python:\n\nYou should get something like this on your screen:\n\nNow let’s load the GenBank file ls_orchid.gbk instead - notice that the code to do this is almost identical to the snippet used above for the FASTA file - the only difference is we change the filename and the format string:\n\nYou’ll notice that a shorter string has been used as the in this case.\n\n2.4.3 I love parsing – please don’t stop talking about it!\n\nBiopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. Chapter 5 covers in more detail, while Chapter 6 introduces for sequence alignments.\n\nWhile the most popular file formats have parsers integrated into and/or , for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet. Please also check the wiki pages http://biopython.org/wiki/SeqIO and http://biopython.org/wiki/AlignIO for the latest information, or ask on the mailing list. The wiki pages should include an up to date list of supported file types, and some additional examples.\n\nThe next place to look for information about specific parsers and how to do cool things with them is in the Cookbook (Chapter 22 of this Tutorial). If you don’t find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)\n\nOne of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from Python scripts. Currently, Biopython has code to extract information from the following databases:\n• Entrez (and PubMed) from the NCBI – See Chapter 12.\n\nThe code in these modules basically makes it easy to write Python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.\n\n2.6 What to do next\n\nNow that you’ve made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is finish reading this tutorial, and then if you want start snooping around in the source code, and looking at the automatically generated documentation.\n\nOnce you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook (Chapter 22), which may have example code to do something similar to what you want to do.\n\nIf you know what you want to do, but can’t figure out how to do it, please feel free to post questions to the main Biopython list (see http://biopython.org/wiki/Mailing_lists). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.\n\nBiological sequences are arguably the central object in Bioinformatics, and in this chapter we’ll introduce the Biopython mechanism for dealing with sequences, the object. Chapter 4 will introduce the related object, which combines the sequence information with any annotation, used again in Chapter 5 for Sequence Input/Output.\n\nSequences are essentially strings of letters like , which seems very natural since this is the most common way that sequences are seen in biological file formats.\n\nThe most important difference between objects and standard Python strings is they have different methods. Although the object supports many of the same methods as a plain string, its method differs by doing biological translation, and there are also additional biologically relevant methods like .\n\nIn most ways, we can deal with Seq objects as if they were normal Python strings, for example getting the length, or iterating over the elements:\n\nYou can access elements of the sequence in the same way as for strings (but remember, Python counts from zero!):\n\nThe object has a method, just like a string. Note that this means that like a Python string, this gives a non-overlapping count:\n\nFor some biological uses, you may actually want an overlapping count (i.e. 3 in this trivial example). When searching for single letters, this makes no difference:\n\nWhile you could use the above snippet of code to calculate a GC%, note that the module has several GC functions already built. For example:\n\nNote that using the function should automatically cope with mixed case sequences and the ambiguous nucleotide S which means G or C.\n\nAlso note that just like a normal Python string, the object is in some ways “read-only”. If you need to edit your sequence, for example simulating a point mutation, look at the Section 3.13 below which talks about the object.\n\nA more complicated example, let’s get a slice of the sequence:\n\nNote that ‘Seq‘ objects follow the usual indexing conventions for Python strings, with the first element of the sequence numbered 0. When you do a slice the first item is included (i.e. 4 in this case) and the last is excluded (12 in this case).\n\nAlso like a Python string, you can do slices with a start, stop and stride (the step size, which defaults to one). For example, we can get the first, second and third codon positions of this DNA sequence:\n\nAnother stride trick you might have seen with a Python string is the use of a -1 stride to reverse the string. You can do this with a object too:\n\nIf you really do just need a plain string, for example to write to a file, or insert into a database, then this is very easy to get:\n\nSince calling on a object returns the full sequence as a string, you often don’t actually have to do this conversion explicitly. Python does this automatically in the print function:\n\nYou can also use the object directly with a placeholder when using the Python string formatting or interpolation operator ( ):\n\nThis line of code constructs a simple FASTA format record (without worrying about line wrapping). Section 4.6 describes a neat way to get a FASTA formatted string from a object, while the more general topic of reading and writing FASTA format sequence files is covered in Chapter 5.\n\nTwo objects can be concatenated by adding them:\n\nBiopython does not check the sequence contents and will not raise an exception if for example you concatenate a protein sequence and a DNA sequence (which is likely a mistake):\n\nYou may often have many sequences to add together, which can be done with a for loop like this:\n\nLike Python strings, Biopython also has a method:\n\nPython strings have very useful and methods for changing the case. For example,\n\nThese are useful for doing case insensitive matching:\n\nFor nucleotide sequences, you can easily obtain the complement or reverse complement of a object using its built-in methods:\n\nAs mentioned earlier, an easy way to just reverse a object (or a Python string) is slice it with -1 step:\n\nIf you do accidentally end up trying to do something weird like taking the (reverse) complement of a protein sequence, the results are biologically meaningless:\n\nHere the letter “E” is not a valid IUPAC ambiguity code for nucleotides, so was not complemented. However, “V” means “A”, “C” or “G” and has complement “B“, and so on.\n\nThe example in Section 5.5.3 combines the object’s reverse complement method with for sequence input/output.\n\nBefore talking about transcription, I want to try to clarify the strand issue. Consider the following (made up) stretch of double stranded DNA which encodes a short peptide:\n\nThe actual biological transcription process works from the template strand, doing a reverse complement (TCAG → CUGA) to give the mRNA. However, in Biopython and bioinformatics in general, we typically work directly with the coding strand because this means we can get the mRNA sequence just by switching T → U.\n\nNow let’s actually get down to doing a transcription in Biopython. First, let’s create objects for the coding and template DNA strands:\n\nThese should match the figure above - remember by convention nucleotide sequences are normally read from the 5’ to 3’ direction, while in the figure the template strand is shown reversed.\n\nNow let’s transcribe the coding strand into the corresponding mRNA, using the object’s built in method:\n\nAs you can see, all this does is to replace T by U.\n\nIf you do want to do a true biological transcription starting with the template strand, then this becomes a two-step process:\n\nThe object also includes a back-transcription method for going from the mRNA to the coding strand of the DNA. Again, this is a simple U → T substitution:\n\nNote: The object’s and methods were added in Biopython 1.49. For older releases you would have to use the module’s functions instead, see Section 3.15.\n\nSticking with the same example discussed in the transcription section above, now let’s translate this mRNA into the corresponding protein sequence - again taking advantage of one of the object’s biological methods:\n\nYou can also translate directly from the coding strand DNA sequence:\n\nYou should notice in the above protein sequences that in addition to the end stop character, there is an internal stop as well. This was a deliberate choice of example, as it gives an excuse to talk about some optional arguments, including different translation tables (Genetic Codes).\n\nThe translation tables available in Biopython are based on those from the NCBI (see the next section of this tutorial). By default, translation will use the standard genetic code (NCBI table id 1). Suppose we are dealing with a mitochondrial sequence. We need to tell the translation function to use the relevant genetic code instead:\n\nYou can also specify the table using the NCBI table number which is shorter, and often included in the feature annotation of GenBank files:\n\nNow, you may want to translate the nucleotides up to the first in frame stop codon, and then stop (as happens in nature):\n\nNotice that when you use the argument, the stop codon itself is not translated - and the stop symbol is not included at the end of your protein sequence.\n\nYou can even specify the stop symbol if you don’t like the default asterisk:\n\nNow, suppose you have a complete coding sequence CDS, which is to say a nucleotide sequence (e.g. mRNA – after any splicing) which is a whole number of codons (i.e. the length is a multiple of three), commences with a start codon, ends with a stop codon, and has no internal in-frame stop codons. In general, given a complete CDS, the default translate method will do what you want (perhaps with the option). However, what if your sequence uses a non-standard start codon? This happens a lot in bacteria – for example the gene yaaX in E. coli K12:\n\nIn the bacterial genetic code GTG is a valid start codon, and while it does normally encode Valine, if used as a start codon it should be translated as methionine. This happens if you tell Biopython your sequence is a complete CDS:\n\nIn addition to telling Biopython to translate an alternative start codon as methionine, using this option also makes sure your sequence really is a valid CDS (you’ll get an exception if not).\n\nThe example in Section 22.1.3 combines the object’s translate method with for sequence input/output.\n\nIn the previous sections we talked about the object translation method (and mentioned the equivalent function in the module – see Section 3.15). Internally these use codon table objects derived from the NCBI information at ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt, also shown on https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi in a much more readable layout.\n\nAs before, let’s just focus on two choices: the Standard translation table, and the translation table for Vertebrate Mitochondrial DNA.\n\nAlternatively, these tables are labeled with ID numbers 1 and 2, respectively:\n\nYou can compare the actual tables visually by printing them:\n\nYou may find these following properties useful – for example if you are trying to do your own gene finding:\n\nSequence comparison is actually a very complicated topic, and there is no easy way to decide if two sequences are equal. The basic problem is the meaning of the letters in a sequence are context dependent - the letter “A” could be part of a DNA, RNA or protein sequence. Biopython can track the molecule type, so comparing two objects could mean considering this too.\n\nShould a DNA fragment “ACG” and an RNA fragment “ACG” be equal? What about the peptide “ACG“? Or the Python string “ACG“? In everyday use, your sequences will generally all be the same type of (all DNA, all RNA, or all protein). Well, as of Biopython 1.65, sequence comparison only looks at the sequence and compares like the Python string.\n\nAs an extension to this, using sequence objects as keys in a Python dictionary is equivalent to using the sequence as a plain string for the key. See also Section 3.3.\n\nIn some cases, the length of a sequence may be known but not the actual letters constituting it. For example, GenBank and EMBL files may represent a genomic DNA sequence only by its config information, without specifying the sequence contents explicitly. Such sequences can be represented by creating a object with the argument , followed by the sequence length:\n\nThe object thus created has a well-defined length. Any attempt to access the sequence contents, however, will raise an :\n\nSometimes the sequence contents is defined for parts of the sequence only, and undefined elsewhere. For example, the following excerpt of a MAF (Multiple Alignment Format) file shows an alignment of human, chimp, macaque, mouse, rat, dog, and opossum genome sequences:\n\nIn each row, the first number indicates the starting position (in zero-based coordinates) of the aligned sequence on the chromosome, followed by the size of the aligned sequence, the strand, the size of the full chromosome, and the aligned sequence.\n\nA object representing such a partially defined sequence can be created using a dictionary for the argument, where the keys are the starting coordinates of the known sequence segments, and the values are the corresponding sequence contents. For example, for the first sequence we would use\n\nExtracting a subsequence from a partially define sequence may return a fully defined sequence, an undefined sequence, or a partially defined sequence, depending on the coordinates:\n\nPartially defined sequences can also be created by appending sequences, if at least one of the sequences is partially or fully undefined:\n\nJust like the normal Python string, the object is “read only”, or in Python terminology, immutable. Apart from wanting the object to act like a string, this is also a useful default since in many biological applications you want to ensure you are not changing your sequence data:\n\nObserve what happens if you try to edit the sequence:\n\nHowever, you can convert it into a mutable sequence (a object) and do pretty much anything you want with it:\n\nAlternatively, you can create a object directly from a string:\n\nEither way will give you a sequence object which can be changed:\n\nNote that the object’s method, like the method of a Python list, reverses the sequence in place.\n\nAn important technical difference between mutable and immutable objects in Python means that you can’t use a object as a dictionary key, but you can use a Python string or a object in this way.\n\nOnce you have finished editing your a object, it’s easy to get back to a read-only object should you need to:\n\nYou can also get a string from a object just like from a object (Section 3.3).\n\nSequence objects have “find“, “rfind“, “index“, and “rindex“ methods that perform the same function as the corresponding methods on plain string objects. The only difference is that the subsequence can be a string, “bytes“, “bytearray“, “Seq“, or “MutableSeq“ object:\n\nA “ValueError“ is raised if the subsequence is not found:\n\nwhile the “find“ method returns -1 if the subsequence is not found:\n\nThe methods “rfind“ and “rindex“ search for the subsequence starting from the right hand side of the sequence:\n\nUse the “search“ method to search for multiple subsequences at the same time. This method returns an iterator:\n\nThe “search“ method also takes plain strings, ‘bytes‘, ‘bytearray‘, ‘Seq‘, and ‘MutableSeq‘ objects as subsequences; identical subsequences are reported only once, as in the example above.\n\nTo close this chapter, for those you who really don’t want to use the sequence objects (or who prefer a functional programming style to an object orientated one), there are module level functions in will accept plain Python strings, objects or objects:\n\nYou are, however, encouraged to work with objects by default.\n\nChapter 3 introduced the sequence classes. Immediately “above” the class is the Sequence Record or class, defined in the module. This class allows higher level features such as identifiers and features (as objects) to be associated with the sequence, and is used throughout the sequence input/output interface described fully in Chapter 5.\n\nIf you are only going to be working with simple data like FASTA files, you can probably skip this chapter for now. If on the other hand you are going to be using richly annotated sequence data, say from GenBank or EMBL files, this information is quite important.\n\nWhile this chapter should cover most things to do with the and objects in this chapter, you may also want to read the wiki page (http://biopython.org/wiki/SeqRecord), and the built in documentation (also online – SeqRecord and SeqFeature):\n\nThe (Sequence Record) class is defined in the module. This class allows higher level features such as identifiers and features to be associated with a sequence (see Chapter 3), and is the basic data type for the sequence input/output interface (see Chapter 5).\n\nThe class itself is quite simple, and offers the following information as attributes:\n\nUsing a object is not very complicated, since all of the information is presented as attributes of the class. Usually you won’t create a “by hand”, but instead use to read in a sequence file for you (see Chapter 5 and the examples below). However, creating can be quite simple.\n\nTo create a at a minimum you just need a object:\n\nAdditionally, you can also pass the id, name and description to the initialization function, but if not they will be set as strings indicating they are unknown, and can be modified subsequently:\n\nIncluding an identifier is very important if you want to output your to a file. You would normally include this when creating the object:\n\nAs mentioned above, the has an dictionary attribute . This is used for any miscellaneous annotations that doesn’t fit under one of the other more specific attributes. Adding annotations is easy, and just involves dealing directly with the annotation dictionary:\n\nWorking with per-letter-annotations is similar, is a dictionary like attribute which will let you assign any Python sequence (i.e. a string, list or tuple) which has the same length as the sequence:\n\nThe and attributes are just Python lists, and should be used to store strings and objects (discussed later in this chapter) respectively.\n\nThis example uses a fairly large FASTA file containing the whole sequence for Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, originally downloaded from the NCBI. This file is included with the Biopython unit tests under the GenBank folder, or online NC_005816.fna from our website.\n\nThe file starts like this - and you can check there is only one record present (i.e. only one line starting with a greater than symbol):\n\nBack in Chapter 2 you will have seen the function used to loop over all the records in a file as objects. The module has a sister function for use on files which contain just one record which we’ll use here (see Chapter 5 for details):\n\nNow, let’s have a look at the key attributes of this individually – starting with the attribute which gives you a object:\n\nNext, the identifiers and description:\n\nAs you can see above, the first word of the FASTA record’s title line (after removing the greater than symbol) is used for both the and attributes. The whole title line (after removing the greater than symbol) is used for the record description. This is deliberate, partly for backwards compatibility reasons, but it also makes sense if you have a FASTA file like this:\n\nNote that none of the other annotation attributes get populated when reading a FASTA file:\n\nIn this case our example FASTA file was from the NCBI, and they have a fairly well defined set of conventions for formatting their FASTA lines. This means it would be possible to parse this information and extract the GI number and accession for example. However, FASTA files from other sources vary, so this isn’t possible in general.\n\nAs in the previous example, we’re going to look at the whole sequence for Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, originally downloaded from the NCBI, but this time as a GenBank file. Again, this file is included with the Biopython unit tests under the GenBank folder, or online NC_005816.gb from our website.\n\nThis file contains a single record (i.e. only one LOCUS line) and starts:\n\nAgain, we’ll use to read this file in, and the code is almost identical to that for used above for the FASTA file (see Chapter 5 for details):\n\nThe comes from the LOCUS line, while the includes the version suffix. The description comes from the DEFINITION line:\n\nMost of the annotations information gets recorded in the dictionary, for example:\n\nThe list gets populated from any PROJECT or DBLINK lines:\n\nFinally, and perhaps most interestingly, all the entries in the features table (e.g. the genes or CDS features) get recorded as objects in the list.\n\nWe’ll talk about objects next, in Section 4.3.\n\nSequence features are an essential part of describing a sequence. Once you get beyond the sequence itself, you need some way to organize and easily get at the more “abstract” information that is known about the sequence. While it is probably impossible to develop a general sequence feature class that will cover everything, the Biopython class attempts to encapsulate as much of the information about the sequence as possible. The design is heavily based on the GenBank/EMBL feature tables, so if you understand how they look, you’ll probably have an easier time grasping the structure of the Biopython classes.\n\nThe key idea about each object is to describe a region on a parent sequence, typically a object. That region is described with a location object, typically a range between two positions (see Section 4.3.2 below).\n\nThe class has a number of attributes, so first we’ll list them and their general features, and then later in the chapter work through examples to show how this applies to a real life example. The attributes of a SeqFeature are:\n\nThe key idea about each object is to describe a region on a parent sequence, for which we use a location object, typically describing a range between two positions. Two try to clarify the terminology we’re using:\n\nI just mention this because sometimes I get confused between the two.\n\nUnless you work with eukaryotic genes, most locations are extremely simple - you just need start and end coordinates and a strand. That’s essentially all the basic object does.\n\nIn practice of course, things can be more complicated. First of all we have to handle compound locations made up of several regions. Secondly, the positions themselves may be fuzzy (inexact).\n\nBiopython 1.62 introduced the as part of a restructuring of how complex locations made up of multiple regions are represented. The main usage is for handling ‘join’ locations in EMBL/GenBank files.\n\nSo far we’ve only used simple positions. One complication in dealing with feature locations comes in the positions themselves. In biology many times things aren’t entirely certain (as much as us wet lab biologists try to make them certain!). For instance, you might do a dinucleotide priming experiment and discover that the start of mRNA transcript starts at one of two sites. This is very useful information, but the complication comes in how to represent this as a position. To help us deal with this, we have the concept of fuzzy positions. Basically there are several types of fuzzy positions, so we have five classes do deal with them:\n\nHere’s an example where we create a location with fuzzy end points:\n\nNote that the details of some of the fuzzy-locations changed in Biopython 1.59, in particular for BetweenPosition and WithinPosition you must now make it explicit which integer position should be used for slicing etc. For a start position this is generally the lower (left) value, while for an end position this would generally be the higher (right) value.\n\nIf you print out a object, you can get a nice representation of the information:\n\nWe can access the fuzzy start and end positions using the start and end attributes of the location:\n\nIf you don’t want to deal with fuzzy positions and just want numbers, they are actually subclasses of integers so should work like integers:\n\nSimilarly, to make it easy to create a position without worrying about fuzzy positions, you can just pass in numbers to the constructors, and you’ll get back out objects:\n\nThat is most of the nitty gritty about dealing with fuzzy positions in Biopython. It has been designed so that dealing with fuzziness is not that much more complicated than dealing with exact positions, and hopefully you find that true!\n\nYou can use the Python keyword with a or location object to see if the base/residue for a parent coordinate is within the feature/location or not.\n\nFor example, suppose you have a SNP of interest and you want to know which features this SNP is within, and lets suppose this SNP is at index 4350 (Python counting!). Here is a simple brute force solution where we just check all the features one by one in a loop:\n\nNote that gene and CDS features from GenBank or EMBL files defined with joins are the union of the exons – they do not cover any introns.\n\n4.3.3 Sequence described by a feature or location\n\nA or location object doesn’t directly contain a sequence, instead the location (see Section 4.3.2) describes how to get this from the parent sequence. For example consider a (short) gene sequence with location 5:18 on the reverse strand, which in GenBank/EMBL notation using 1-based counting would be complement(6..18), like this:\n\nYou could take the parent sequence, slice it to extract 5:18, and then take the reverse complement. The feature location’s start and end are integer-like so this works:\n\nThis is a simple example so this isn’t too bad – however once you have to deal with compound features (joins) this is rather messy. Instead, the object has an method to take care of all this (and since Biopython 1.78 can handle trans-splicing by supplying a dictionary of referenced sequences):\n\nThe length of a or location matches that of the region of sequence it describes.\n\nFor objects the length is just the difference between the start and end positions. However, for a the length is the sum of the constituent regions.\n\nThe objects can be very complex, but here’s a simple example:\n\nWhat happens when you try to compare these “identical” records?\n\nPerhaps surprisingly older versions of Biopython would use Python’s default object comparison for the , meaning would only return if these variables pointed at the same object in memory. In this example, would have returned here!\n\nAs of Biopython 1.67, comparison like will instead raise an explicit error to avoid people being caught out by this:\n\nInstead you should check the attributes you are interested in, for example the identifier and the sequence:\n\nBeware that comparing complex objects quickly gets complicated (see also Section 3.10).\n\nAnother common annotation related to a sequence is a reference to a journal or other published work dealing with the sequence. We have a fairly simple way of representing a Reference in Biopython – we have a class that stores the relevant information about a reference as attributes of an object.\n\nThe attributes include things that you would expect to see in a reference like , and . Additionally, it also can hold the and and a about the reference. These are all accessed simply as attributes of the object.\n\nA reference also has a object so that it can specify a particular location on the sequence that the reference refers to. For instance, you might have a journal that is dealing with a particular gene located on a BAC, and want to specify that it only refers to this position exactly. The is a potentially fuzzy location, as described in section 4.3.2.\n\nAny reference objects are stored as a list in the object’s dictionary under the key “references”. That’s all there is too it. References are meant to be easy to deal with, and hopefully general enough to cover lots of usage cases.\n\nThe method of the class gives a string containing your record formatted using one of the output file formats supported by , such as FASTA:\n\nThis method takes a single mandatory argument, a lower case string which is supported by as an output format (see Chapter 5). However, some of the file formats can write to require more than one record (typically the case for multiple sequence alignment formats), and thus won’t work via this method. See also Section 5.5.4.\n\nYou can slice a , to give you a new covering just part of the sequence. What is important here is that any per-letter annotations are also sliced, and any features which fall completely within the new sequence are preserved (with their locations adjusted).\n\nFor example, taking the same GenBank file used earlier:\n\nFor this example we’re going to focus in on the gene, . If you have a look at the GenBank file directly you’ll find this gene/CDS has location string 4343..4780, or in Python counting 4342:4780. From looking at the file you can work out that these are the twelfth and thirteenth entries in the file, so in Python zero-based counting they are entries 11 and 12 in the features list:\n\nLet’s slice this parent record from 4300 to 4800 (enough to include the gene/CDS), and see how many features we get:\n\nOur sub-record just has two features, the gene and CDS entries for :\n\nNotice that their locations have been adjusted to reflect the new parent sequence!\n\nWhile Biopython has done something sensible and hopefully intuitive with the features (and any per-letter annotation), for the other annotation it is impossible to know if this still applies to the sub-sequence or not. To avoid guessing, with the exception of the molecule type, the .annotations and .dbxrefs are omitted from the sub-record, and it is up to you to transfer any relevant information as appropriate.\n\nYou may wish to preserve other entries like the organism? Beware of copying the entire annotations dictionary as in this case your partial sequence is no longer circular DNA - it is now linear:\n\nThe same point could be made about the record id, name and description, but for practicality these are preserved:\n\nThis illustrates the problem nicely though, our new sub-record is not the complete sequence of the plasmid, so the description is wrong! Let’s fix this and then view the sub-record as a reduced GenBank file using the format method described above in Section 4.6:\n\nSee Sections 22.1.7 and 22.1.8 for some FASTQ examples where the per-letter annotations (the read quality scores) are also sliced.\n\nYou can add objects together, giving a new . What is important here is that any common per-letter annotations are also added, all the features are preserved (with their locations adjusted), and any other common annotation is also kept (like the id, name and description).\n\nFor an example with per-letter annotation, we’ll use the first record in a FASTQ file. Chapter 5 will explain the functions:\n\nLet’s suppose this was Roche 454 data, and that from other information you think the TTT should be only TT. We can make a new edited record by first slicing the before and after the “extra” third T:\n\nNow add the two parts together:\n\nEasy and intuitive? We hope so! You can make this shorter with just:\n\nNow, for an example with features, we’ll use a GenBank file. Suppose you have a circular genome:\n\nYou can shift the origin like this:\n\nNote that this isn’t perfect in that some annotation like the database cross references, all the annotations except molecule type, and one of the features (the source feature) have been lost:\n\nThis is because the slicing step is cautious in what annotation it preserves (erroneously propagating annotation can cause major problems). If you want to keep the database cross references or the annotations dictionary, this must be done explicitly:\n\nAlso note that in an example like this, you should probably change the record identifiers since the NCBI references refer to the original unmodified sequence.\n\nOne of the new features in Biopython 1.57 was the object’s method. This tries to balance easy of use with worries about what to do with the annotation in the reverse complemented record.\n\nFor the sequence, this uses the Seq object’s reverse complement method. Any features are transferred with the location and strand recalculated. Likewise any per-letter-annotation is also copied but reversed (which makes sense for typical examples like quality scores). However, transfer of most annotation is problematical.\n\nFor instance, if the record ID was an accession, that accession should not really apply to the reverse complemented sequence, and transferring the identifier by default could easily cause subtle data corruption in downstream analysis. Therefore by default, the ’s id, name, description, annotations and database cross references are all not transferred by default.\n\nThe object’s method takes a number of optional arguments corresponding to properties of the record. Setting these arguments to means copy the old values, while means drop the old values and use the default value. You can alternatively provide the new desired value instead.\n\nConsider this example record:\n\nHere we take the reverse complement and specify a new identifier – but notice how most of the annotation is dropped (but not the features):\n\nIn this chapter we’ll discuss in more detail the module, which was briefly introduced in Chapter 2 and also used in Chapter 4. This aims to provide a simple interface for working with assorted sequence file formats in a uniform way. See also the wiki page (http://biopython.org/wiki/SeqIO), and the built in documentation (also online):\n\nThe “catch” is that you have to work with objects (see Chapter 4), which contain a object (see Chapter 3) plus annotation like an identifier and description. Note that when dealing with very large FASTA or FASTQ files, the overhead of working with all these objects can make scripts too slow. In this case consider the low-level and parsers which return just a tuple of strings for each record (see Section 5.6).\n\nThe workhorse function is used to read in sequence data as SeqRecord objects. This function expects two arguments:\n• The first argument is a to read the data from, or a filename. A handle is typically a file opened for reading, but could be the output from a command line program, or data downloaded from the internet (see Section 5.3). See Section 25.1 for more about handles.\n• The second argument is a lower case string specifying sequence format – we don’t try and guess the file format for you! See for a full listing of supported formats.\n\nThe function returns an iterator which gives objects. Iterators are typically used in a for loop as shown below.\n\nSometimes you’ll find yourself dealing with files which contain only a single record. For this situation use the function which takes the same arguments. Provided there is one and only one record in the file, this is returned as a object. Otherwise an exception is raised.\n\nIn general is used to read in sequence files as objects, and is typically used with a for loop like this:\n\nThe above example is repeated from the introduction in Section 2.4, and will load the orchid DNA sequences in the FASTA format file ls_orchid.fasta. If instead you wanted to load a GenBank format file like ls_orchid.gbk then all you need to do is change the filename and the format string:\n\nSimilarly, if you wanted to read in a file in another file format, then assuming supports it you would just need to change the format string as appropriate, for example “swiss” for SwissProt files or “embl” for EMBL text files. There is a full listing on the wiki page (http://biopython.org/wiki/SeqIO) and in the built in documentation (also online).\n\nAnother very common way to use a Python iterator is within a list comprehension (or a generator expression). For example, if all you wanted to extract from the file was a list of the record identifiers we can easily do this with the following list comprehension:\n\nThere are more examples using in a list comprehension like this in Section 22.2 (e.g. for plotting sequence lengths or GC%).\n\n5.1.2 Iterating over the records in a sequence file\n\nIn the above examples, we have usually used a for loop to iterate over all the records one by one. You can use the for loop with all sorts of Python objects (including lists, tuples and strings) which support the iteration interface.\n\nThe object returned by is actually an iterator which returns objects. You get to see each record in turn, but once and only once. The plus point is that an iterator can save you memory when dealing with large files.\n\nInstead of using a for loop, can also use the function on an iterator to step through the entries, like this:\n\nNote that if you try to use and there are no more results, you’ll get the special exception.\n\nOne special case to consider is when your sequence files have multiple records, but you only want the first one. In this situation the following code is very concise:\n\nA word of warning here – using the function like this will silently ignore any additional records in the file. If your files have one and only one record, like some of the online examples later in this chapter, or a GenBank file for a single chromosome, then use the new function instead. This will check there are no extra unexpected records present.\n\n5.1.3 Getting a list of the records in a sequence file\n\nIn the previous section we talked about the fact that gives you a iterator, and that you get the records one by one. Very often you need to be able to access the records in any order. The Python data type is perfect for this, and we can turn the record iterator into a list of objects using the built-in Python function like so:\n\nYou can of course still use a for loop with a list of objects. Using a list is much more flexible than an iterator (for example, you can determine the number of records from the length of the list), but does need more memory because it will hold all the records in memory at once.\n\nThe object and its annotation structures are described more fully in Chapter 4. As an example of how annotations are stored, we’ll look at the output from parsing the first record in the GenBank file ls_orchid.gbk.\n\nThat should give something like this:\n\nThis gives a human readable summary of most of the annotation data for the . For this example we’re going to use the attribute which is just a Python dictionary. The contents of this annotations dictionary were shown when we printed the record above. You can also print them out directly:\n\nLike any Python dictionary, you can easily get the keys:\n\nIn general, the annotation values are strings, or lists of strings. One special case is any references in the file get stored as reference objects.\n\nSuppose you wanted to extract a list of the species from the ls_orchid.gbk GenBank file. The information we want, Cypripedium irapeanum, is held in the annotations dictionary under ‘source’ and ‘organism’, which we can access like this:\n\nIn general, ‘organism’ is used for the scientific name (in Latin, e.g. Arabidopsis thaliana), while ‘source’ will often be the common name (e.g. thale cress). In this example, as is often the case, the two fields are identical.\n\nNow let’s go through all the records, building up a list of the species each orchid sequence is from:\n\nAnother way of writing this code is to use a list comprehension:\n\nIn either case, the result is:\n\nGreat. That was pretty easy because GenBank files are annotated in a standardized way.\n\nNow, let’s suppose you wanted to extract a list of the species from a FASTA file, rather than the GenBank file. The bad news is you will have to write some code to extract the data you want from the record’s description line - if the information is in the file in the first place! Our example FASTA format file ls_orchid.fasta starts like this:\n\nYou can check by hand, but for every record the species name is in the description line as the second word. This means if we break up each record’s at the spaces, then the species is there as field number one (field zero is the record identifier). That means we can do this:\n\nThe concise alternative using list comprehensions would be:\n\nIn general, extracting information from the FASTA description line is not very nice. If you can get your sequences in a well annotated file format like GenBank or EMBL, then this sort of annotation information is much easier to deal with.\n\nIn the previous section, we demonstrated how to extract data from a . Another common task is to alter this data. The attributes of a can be modified directly, for example:\n\nNote, if you want to change the way FASTA is output when written to a file (see Section 5.5), then you should modify both the and attributes. To ensure the correct behavior, it is best to include the plus a space at the start of the desired :\n\nIn the previous section, we looked at parsing sequence data from a file. Instead of using a filename, you can give a handle (see Section 25.1), and in this section we’ll use handles to parse sequence from compressed files.\n\nAs you’ll have seen above, we can use or with a filename - for instance this quick example calculates the total length of the sequences in a multiple record GenBank file using a generator expression:\n\nHere we use a file handle instead, using the statement to close the handle automatically:\n\nOr, the old fashioned way where you manually close the handle:\n\nNow, suppose we have a gzip compressed file instead? These are very commonly used on Linux. We can use Python’s module to open the compressed file for reading - which gives us a handle object:\n\nSimilarly if we had a bzip2 compressed file:\n\nThere is a gzip (GNU Zip) variant called BGZF (Blocked GNU Zip Format), which can be treated like an ordinary gzip file for reading, but has advantages for random access later which we’ll talk about later in Section 5.4.4.\n\nIn the previous sections, we looked at parsing sequence data from a file (using a filename or handle), and from compressed files (using a handle). Here we’ll use with another type of handle, a network connection, to download and parse sequences from the internet.\n\nNote that just because you can download sequence data and parse it into a object in one go doesn’t mean this is a good idea. In general, you should probably download sequences once and save them to a file for reuse.\n\nSection 12.6 talks about the Entrez EFetch interface in more detail, but for now let’s just connect to the NCBI and get a few Opuntia (prickly-pear) sequences from GenBank using their GI numbers.\n\nFirst of all, let’s fetch just one record. If you don’t care about the annotations and features downloading a FASTA file is a good choice as these are compact. Now remember, when you expect the handle to contain one and only one record, use the function:\n\nThe NCBI will also let you ask for the file in other formats, in particular as a GenBank file. Until Easter 2009, the Entrez EFetch API let you use “genbank” as the return type, however the NCBI now insist on using the official return types of “gb” (or “gp” for proteins) as described on EFetch for Sequence and other Molecular Biology Databases. As a result, in Biopython 1.50 onwards, we support “gb” as an alias for “genbank” in .\n\nThe expected output of this example is:\n\nNotice this time we have three features.\n\nNow let’s fetch several records. This time the handle contains multiple records, so we must use the function:\n\nThat should give the following output:\n\nSee Chapter 12 for more about the module, and make sure to read about the NCBI guidelines for using Entrez (Section 12.1).\n\nNow let’s use a handle to download a SwissProt file from ExPASy, something covered in more depth in Chapter 13. As mentioned above, when you expect the handle to contain one and only one record, use the function:\n\nAssuming your network connection is OK, you should get back:\n\nLooping over the iterator returned by once will exhaust the file. For self-indexed files, such as files in the twoBit format, the return value of can also be used as a dictionary, allowing random access to the sequence contents. As in this case parsing is done on demand, the file must remain open as long as the sequence data is being accessed:\n\nFor other file formats, provides three related functions module which allow dictionary like random access to a multi-sequence file. There is a trade off here between flexibility and memory usage. In summary:\n• is the most flexible but also the most memory demanding option (see Section 5.4.1). This is basically a helper function to build a normal Python with each entry held as a object in memory, allowing you to modify the records.\n• is a useful middle ground, acting like a read only dictionary and parsing sequences into objects on demand (see Section 5.4.2).\n• also acts like a read only dictionary but stores the identifiers and file offsets in a file on disk (as an SQLite3 database), meaning it has very low memory requirements (see Section 5.4.3), but will be a little bit slower.\n\nSee the discussion for an broad overview (Section 5.4.5).\n\nThe next thing that we’ll do with our ubiquitous orchid files is to show how to index them and access them like a database using the Python data type (like a hash in Perl). This is very useful for moderately large files where you only need to access certain elements of the file, and makes for a nice quick ’n dirty database. For dealing with larger files where memory becomes a problem, see Section 5.4.2 below.\n\nYou can use the function to make a SeqRecord dictionary (in memory). By default this will use each record’s identifier (i.e. the attribute) as the key. Let’s try this using our GenBank file:\n\nThere is just one required argument for , a list or generator giving objects. Here we have just used the output from the function. As the name suggests, this returns a Python dictionary.\n\nSince this variable is an ordinary Python dictionary, we can look at all of the keys we have available:\n\nUnder Python 3 the dictionary methods like “.keys()“ and “.values()“ are iterators rather than lists.\n\nIf you really want to, you can even look at all the records at once:\n\nWe can access a single object via the keys and manipulate the object as normal:\n\nSo, it is very easy to create an in memory “database” of our GenBank records. Next we’ll try this for the FASTA file instead.\n\nNote that those of you with prior Python experience should all be able to construct a dictionary like this “by hand”. However, typical dictionary construction methods will not deal with the case of repeated keys very nicely. Using the will explicitly check for duplicate keys, and raise an exception if any are found.\n\nUsing the same code as above, but for the FASTA file instead:\n\nThis time the keys are:\n\nYou should recognize these strings from when we parsed the FASTA file earlier in Section 2.4.1. Suppose you would rather have something else as the keys - like the accession numbers. This brings us nicely to ’s optional argument , which lets you define what to use as the dictionary key for your records.\n\nFirst you must write your own function to return the key you want (as a string) when given a object. In general, the details of function will depend on the sort of input records you are dealing with. But for our orchids, we can just split up the record’s identifier using the “pipe” character (the vertical line) and return the fourth entry (field three):\n\nThen we can give this function to the function to use in building the dictionary:\n\nFinally, as desired, the new dictionary keys:\n\nTo give another example of working with dictionaries of objects, we’ll use the SEGUID checksum function. This is a relatively recent checksum, and collisions should be very rare (i.e. two different sequences with the same checksum), an improvement on the CRC64 checksum.\n\nOnce again, working with the orchids GenBank file:\n\nNow, recall the function’s argument expects a function which turns a into a string. We can’t use the function directly because it expects to be given a object (or a string). However, we can use Python’s feature to create a “one off” function to give to instead:\n\nThat should have retrieved the record Z78532.1, the second entry in the file.\n\nAs the previous couple of examples tried to illustrate, using is very flexible. However, because it holds everything in memory, the size of file you can work with is limited by your computer’s RAM. In general, this will only work on small to medium files.\n\nFor larger files you should consider , which works a little differently. Although it still returns a dictionary like object, this does not keep everything in memory. Instead, it just records where each record is within the file – when you ask for a particular record, it then parses it on demand.\n\nAs an example, let’s use the same GenBank file as before:\n\nNote that won’t take a handle, but only a filename. There are good reasons for this, but it is a little technical. The second argument is the file format (a lower case string as used in the other functions). You can use many other simple file formats, including FASTA and FASTQ files (see the example in Section 22.1.11). However, alignment formats like PHYLIP or Clustal are not supported. Finally as an optional argument you can supply a key function.\n\nHere is the same example using the FASTA file - all we change is the filename and the format name:\n\nSuppose you want to use the same keys as before? Much like with the example in Section 5.4.1.1, you’ll need to write a tiny function to map from the FASTA identifier (as a string) to the key you want:\n\nThen we can give this function to the function to use in building the dictionary:\n\nEasy when you know how?\n\n5.4.2.2 Getting the raw data for a record\n\nThe dictionary-like object from gives you each entry as a object. However, it is sometimes useful to be able to get the original raw data straight from the file. For this use the method which takes a single argument (the record identifier) and returns a bytes string (extracted from the file without modification).\n\nA motivating example is extracting a subset of a records from a large file where either does not (yet) support the output file format (e.g. the plain text SwissProt file format) or where you need to preserve the text exactly (e.g. GenBank or EMBL output from Biopython does not yet preserve every last bit of annotation).\n\nLet’s suppose you have download the whole of UniProt in the plain text SwissPort file format from their FTP site (ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.dat.gz) and uncompressed it as the file , and you want to extract just a few records from it:\n\nNote with Python 3 onwards, we have to open the file for writing in binary mode because the method returns bytes strings.\n\nThere is a longer example in Section 22.1.5 using the function to sort a large sequence file (without loading everything into memory at once).\n\nBiopython 1.57 introduced an alternative, , which can work on even extremely large files since it stores the record information as a file on disk (using an SQLite3 database) rather than in memory. Also, you can index multiple files together (providing all the record identifiers are unique).\n• Index filename, we suggest using something ending . This index file is actually an SQLite3 database.\n• List of sequence filenames to index (or a single filename)\n• File format (lower case string as used in the rest of the module).\n\nAs an example, consider the GenBank flat file releases from the NCBI FTP site, ftp://ftp.ncbi.nih.gov/genbank/, which are gzip compressed GenBank files.\n\nAs of GenBank release 210, there are 38 files making up the viral sequences, gbvrl1.seq, …, gbvrl38.seq, taking about 8GB on disk once decompressed, and containing in total nearly two million records.\n\nIf you were interested in the viruses, you could download all the virus files from the command line very easily with the rsync command, and then decompress them with gunzip:\n\nUnless you care about viruses, that’s a lot of data to download just for this example - so let’s download just the first four chunks (about 25MB each compressed), and decompress them (taking in all about 1GB of space):\n\nNow, in Python, index these GenBank files as follows:\n\nIndexing the full set of virus GenBank files took about ten minutes on my machine, just the first four files took about a minute or so.\n\nHowever, once done, repeating this will reload the index file in a fraction of a second.\n\nYou can use the index as a read only Python dictionary - without having to worry about which file the sequence comes from, e.g.\n\n5.4.3.1 Getting the raw data for a record\n\nJust as with the function discussed above in Section 5.4.2.2, the dictionary like object also lets you get at the raw bytes of each record:\n\nVery often when you are indexing a sequence file it can be quite large – so you may want to compress it on disk. Unfortunately efficient random access is difficult with the more common file formats like gzip and bzip2. In this setting, BGZF (Blocked GNU Zip Format) can be very helpful. This is a variant of gzip (and can be decompressed using standard gzip tools) popularized by the BAM file format, samtools, and tabix.\n\nTo create a BGZF compressed file you can use the command line tool which comes with samtools. In our examples we use a filename extension , so they can be distinguished from normal gzipped files (named ). You can also use the module to read and write BGZF files from within Python.\n\nThe and can both be used with BGZF compressed files. For example, if you started with an uncompressed GenBank file:\n\nYou could compress this (while keeping the original file) at the command line using the following command – but don’t worry, the compressed file is already included with the other example files:\n\nYou can use the compressed file in exactly the same way:\n\nThe indexing automatically detects the BGZF compression. Note that you can’t use the same index file for the uncompressed and compressed files.\n\nSo, which of these methods should you use and why? It depends on what you are trying to do (and how much data you are dealing with). However, in general picking is a good starting point. If you are dealing with millions of records, multiple files, or repeated analyses, then look at .\n\nReasons to choose over either or boil down to a need for flexibility despite its high memory needs. The advantage of storing the objects in memory is they can be changed, added to, or removed at will. In addition to the downside of high memory consumption, indexing can also take longer because all the records must be fully parsed.\n\nBoth and only parse records on demand. When indexing, they scan the file once looking for the start of each record and do as little work as possible to extract the identifier.\n• Faster to build the index (more noticeable in simple file formats)\n• Slightly faster access as SeqRecord objects (but the difference is only really noticeable for simple to parse file formats).\n• Can use any immutable Python object as the dictionary keys (e.g. a tuple of strings, or a frozen set) not just strings.\n• Don’t need to worry about the index database being out of date if the sequence file being indexed has changed.\n• Not memory limited – this is already important with files from second generation sequencing where 10s of millions of sequences are common, and using can require more than 4GB of RAM and therefore a 64bit version of Python.\n• Because the index is kept on disk, it can be reused. Although building the index database file takes longer, if you have a script which will be rerun on the same datafiles in future, this could save time in the long run.\n• The method can be much faster, since for most file formats the length of each record is stored as well as its offset.\n\nWe’ve talked about using for sequence input (reading files), and now we’ll look at which is for sequence output (writing files). This is a function taking three arguments: some objects, a handle or filename to write to, and a sequence format.\n\nHere is an example, where we start by creating a few objects the hard way (by hand, rather than by loading them from a file):\n\nNow we have a list of objects, we’ll write them to a FASTA format file:\n\nAnd if you open this file in your favorite text editor it should look like this:\n\nSuppose you wanted to know how many records the function wrote to the handle? If your records were in a list you could just use , however you can’t do that when your records come from a generator/iterator. The function returns the number of objects written to the file.\n\nNote - If you tell the function to write to a file that already exists, the old file will be overwritten without any warning.\n\nSome people like their parsers to be “round-tripable”, meaning if you read in a file and write it back out again it is unchanged. This requires that the parser must extract enough information to reproduce the original file exactly. does not aim to do this.\n\nAs a trivial example, any line wrapping of the sequence data in FASTA files is allowed. An identical would be given from parsing the following two examples which differ only in their line breaks:\n\nTo make a round-tripable FASTA parser you would need to keep track of where the sequence line breaks occurred, and this extra information is usually pointless. Instead Biopython uses a default line wrapping of 60 characters on output. The same problem with white space applies in many other file formats too. Another issue in some cases is that Biopython does not (yet) preserve every last bit of annotation (e.g. GenBank and EMBL).\n\nOccasionally preserving the original layout (with any quirks it may have) is important. See Section 5.4.2.2 about the method of the dictionary-like object for one potential solution.\n\nIn previous example we used a list of objects as input to the function, but it will also accept a iterator like we get from – this lets us do file conversion by combining these two functions.\n\nFor this example we’ll read in the GenBank format file ls_orchid.gbk and write it out in FASTA format:\n\nStill, that is a little bit complicated. So, because file conversion is such a common task, there is a helper function letting you replace that with just:\n\nThe function will take handles or filenames. Watch out though – if the output file already exists, it will overwrite it! To find out more, see the built in help:\n\nIn principle, just by changing the filenames and the format names, this code could be used to convert between any file formats available in Biopython. However, writing some formats requires information (e.g. quality scores) which other files formats don’t contain. For example, while you can turn a FASTQ file into a FASTA file, you can’t do the reverse. See also Sections 22.1.9 and 22.1.10 in the cookbook chapter which looks at inter-converting between different FASTQ formats.\n\nFinally, as an added incentive for using the function (on top of the fact your code will be shorter), doing it this way may also be faster! The reason for this is the convert function can take advantage of several file format specific optimizations and tricks.\n\n5.5.3 Converting a file of sequences to their reverse complements\n\nSuppose you had a file of nucleotide sequences, and you wanted to turn it into a file containing their reverse complement sequences. This time a little bit of work is required to transform the objects we get from our input file into something suitable for saving to our output file.\n\nTo start with, we’ll use to load some nucleotide sequences from a file, then print out their reverse complements using the object’s built in method (see Section 3.6):\n\nNow, if we want to save these reverse complements to a file, we’ll need to make objects. We can use the object’s built in method (see Section 4.9) but we must decide how to name our new records.\n\nThis is an excellent place to demonstrate the power of list comprehensions which make a list in memory:\n\nNow list comprehensions have a nice trick up their sleeves, you can add a conditional statement:\n\nThat would create an in memory list of reverse complement records where the sequence length was under 700 base pairs. However, we can do exactly the same with a generator expression - but with the advantage that this does not create a list of all the records in memory at once:\n\nThere is a related example in Section 22.1.3, translating each record in a FASTA file from nucleotides to amino acids.\n\n5.5.4 Getting your SeqRecord objects as formatted strings\n\nSuppose that you don’t really want to write your records to a file or handle – instead you want a string containing the records in a particular file format. The interface is based on handles, but Python has a useful built in module which provides a string based handle.\n\nFor an example of how you might use this, let’s load in a bunch of objects from our orchids GenBank file, and create a string containing the records in FASTA format:\n\nThis isn’t entirely straightforward the first time you see it! On the bright side, for the special case where you would like a string containing a single record in a particular file format, use the the class’ method (see Section 4.6).\n\nNote that although we don’t encourage it, you can use the method to write to a file, for example something like this:\n\nWhile this style of code will work for a simple sequential file format like FASTA or the simple tab separated format used here, it will not work for more complex or interlaced file formats. This is why we still recommend using , as in the following example:\n\nMaking a single call to is also much quicker than multiple calls to the method.\n\nWorking with the low-level or is often more practical than when dealing with large high-throughput FASTA or FASTQ sequencing files where speed matters. As noted in the introduction to this chapter, the file-format neutral interface has the overhead of creating many objects even for simple formats like FASTA.\n\nWhen parsing FASTA files, internally calls the low-level with the file handle. You can use this directly - it iterates over the file handle returning each record as a tuple of two strings, the title line (everything after the character) and the sequence (as a plain string):\n\nAs long as you don’t care about line wrapping (and you probably don’t for short read high-throughput data), then outputting FASTA format from these strings is also very fast:\n\nLikewise, when parsing FASTQ files, internally calls the low-level with the file handle. If you don’t need the quality scores turned into integers, or can work with them as ASCII strings this is ideal:\n\nThere are more examples of this in the Cookbook (Chapter 22), including how to output FASTQ efficiently from strings using this code snippet:\n\nSequence alignments are a collection of two or more sequences that have been aligned to each other – usually with the insertion of gaps, and the addition of leading or trailing gaps – such that all the sequence strings are the same length.\n\nAlignments may extend over the full length of each sequence, or may be limited to a subsection of each sequence. In Biopython, all sequence alignments are represented by an object, described in section 6.1. objects can be obtained by parsing the output of alignment software such as Clustal or BLAT (described in section 6.6. or by using Biopython’s pairwise sequence aligner, which can align two sequences to each other (described in Chapter 7).\n\nSee Chapter 8 for a description of the older class and the parsers in that parse the output of sequence alignment software, generating objects.\n\nThe class is defined in . Usually you would get an object by parsing the output of alignment programs (section 6.6) or by running Biopython’s pairwise aligner (Chapter 7). For the benefit of this section, however, we will create an object from scratch.\n\n6.1.1 Creating an Alignment object from sequences and coordinates\n\nSuppose you have three sequences:\n\nTo create an object, we also need the coordinates that define how the sequences are aligned to each other. We use a NumPy array for that:\n\nThese coordinates define the alignment for the following sequence segments:\n• , , and are aligned to each other;\n• and are aligned to each other, with a gap of one nucleotide in ;\n• , , and are aligned to each other;\n• is not aligned to or .\n\nNote that the alignment does not include the first nucleotide of and last two nucleotides of .\n\nNow we can create the object:\n\nThe alignment object has an attribute pointing to the sequences included in this alignment:\n\nand an attribute with the alignment coordinates:\n\nPrint the object to show the alignment explicitly:\n\nwith the starting and end coordinate for each sequence are shown to the left and right, respectively, of the alignment.\n\nIf you start out with the aligned sequences, with dashes representing gaps, then you can calculate the coordinates using the class method. This method is primarily employed in Biopython’s alignment parsers (see Section 6.6), but it may be useful for other purposes. For example, you can construct the object from aligned sequences as follows:\n\nThe initial nucleotide of and the final nucleotides of were not included in the alignment and is therefore missing here. But this is easy to fix:\n\nNow we can create the object:\n\nwhich identical to the object created above in section 6.1.1.\n\nBy default, the argument to the initializer is , which assumes that there are no gaps in the alignment. All sequences in an ungapped alignment must have the same length. If the argument is , then the initializer will fill in the attribute of the object for you:\n\nThe following attributes are commonly found on objects:\n• : This is a list of the sequences aligned to each other. Depending on how the alignment was created, the sequences can have the following types:\n• any other object with a contiguous buffer of format , , , or ;\n• lists or tuples of objects defined in the attribute of the object that created the alignment (see section 7.11). For pairwise alignments (meaning an alignment of two sequences), the properties and are aliases for and , respectively.\n• : A NumPy array of integers storing the sequence indices defining how the sequences are aligned to each other;\n• : The alignment score, as found by the parser in the alignment file, or as calculated by the (see section 7.1);\n• : A dictionary storing most other annotations associated with the alignment;\n• : A dictionary storing annotations that extend along the alignment and have the same length as the alignment, such as a consensus sequence (see section 6.7.2 for an example).\n\nAn object created by the parser in may have additional attributes, depending on the alignment file format from which the alignment was read.\n\nSlices of the form , where is an integer and and are integers or are absent, return a string showing the aligned sequence (including gaps) for the target (if ) or the query (if ) that includes only the columns through in the printed alignment.\n\nTo illustrate this, in the following example the printed alignment has 8 columns:\n\nTo get the aligned sequence strings individually, use\n\nColumns to be included can also be selected using an iterable over integers:\n\nTo get the letter at position of the printed alignment, use ; this will return if a gap is found at that position:\n\nTo get specific columns in the alignment, use\n\nSlices of the form return a new object including only sequences of the alignment:\n\nSlices of the form , where and are integers or are absent, return a new object that includes only the columns through in the printed alignment.\n\nExtracting the first 4 columns for the example alignment above gives:\n\nSimilarly, extracting the last 6 columns gives:\n\nThe column index can also be an iterable of integers:\n\n6.3 Getting information about the alignment\n\nThe number of aligned sequences is returned by :\n\nThe alignment length is defined as the number of columns in the alignment as printed. This is equal to the sum of the number of matches, number of mismatches, and the total length of gaps in each sequence:\n\nThe property returns a tuple consisting of the length of the alignment and the number of columns in the alignment as printed:\n\nTwo alignments are equal to each other (meaning that evaluates to ) if each of the sequences in and are equal to each other, and and contain the same coordinates. If either of these conditions is not fulfilled, then evaluates to . Inequality of two alignments (e.g., ) is established by first comparing and , and if they are equal, by comparing to .\n\nFor pairwise alignments, the property of an alignment returns the start and end indices of subsequences in the target and query sequence that were aligned to each other. If the alignment between target (t) and query (q) consists of N chunks, you get two tuples of length N:\n\nNote that different alignments may have the same subsequences aligned to each other. In particular, this may occur if alignments differ from each other in terms of their gap placement only:\n\nThe property returns a 2D NumPy array with the sequence index of each letter in the alignment, with gaps indicated by -1:\n\nThe property returns a list of 1D NumPy arrays, one for each of the aligned sequences, with the column index in the alignment for each letter in the sequence. Letters not included in the alignment are indicated by -1:\n\nThe method calculates the number of identities, mismatches, and gaps of a pairwise alignment. For an alignment of more than two sequences, the number of identities, mismatches, and gaps are calculated and summed for all pairs of sequences in the alignment. The three numbers are returned as an object, which is a with fields , , and . This method currently takes no arguments, but in the future will likely be modified to accept optional arguments allowing its behavior to be customized.\n\nThe method calculates how often each letter appears in each column of the alignment:\n\nUse the method to find the number of substitutions between each pair of nucleotides:\n\nNote that the matrix is not symmetric: The counts for a row letter R and a column letter C is the number of times letter R in a sequence is replaced by letter C in a sequence appearing below it. For example, the number of ’s that are aligned to an in a later sequence is\n\nwhile the number of A’s that are aligned to a C in a later sequence is\n\nTo get a symmetric matrix, use\n\nThe total number of substitutions between ’s and ’s in the alignment is 1.0 + 1.0 = 2.\n\nUsing NumPy, you can turn the object into an array of letters. In particular, this may be useful for fast calculations on the alignment content.\n\nBy default, this will give you an array of characters (with data type ). You can create an array of Unicode (Python string) characters by using :\n\nNote that the object and the NumPy array are separate objects in memory - editing one will not update the other!\n\nThe method sorts the alignment sequences. By default, sorting is done based on the attribute of each sequence if available, or the sequence contents otherwise.\n\nAlternatively, you can supply a function to determine the sort order. For example, you can sort the sequences by increasing GC content:\n\nNote that the function is applied to the full sequence (including the initial and final nucleotides of ), not just to the aligned part.\n\nThe argument lets you reverse the sort order to obtain the sequences in decreasing GC content:\n\nReverse-complementing an alignment will take the reverse complement of each sequence, and recalculate the coordinates:\n\nReverse-complementing an alignment preserves its column annotations (in reverse order), but discards all other annotations.\n\nAlignments can be added together to form an extended alignment if they have the same number of rows. As an example, let’s first create two alignments:\n\nNow, let’s look at these two alignments:\n\nAdding the two alignments will combine the two alignments row-wise:\n\nFor this to work, both alignments must have the same number of sequences (here they both have 3 rows):\n\nThe sequences are objects, which can be added together. Refer to Chapter 4 for details of how the annotation is handled. This example is a special case in that both original alignments shared the same names, meaning when the rows are added they also get the same name.\n\nAny common annotations are preserved, but differing annotation is lost. This is the same behavior used in the annotations and is designed to prevent accidental propagation of inappropriate values:\n\nSuppose you have a pairwise alignment of a transcript to a chromosome:\n\nand a pairwise alignment between the transcript and a sequence (e.g., obtained by RNA-seq):\n\nUse the method on , with as argument, to find the alignment of the RNA-sequence to the genome:\n\nTo be able to print the sequences, in this example we constructed and using sequences with a defined sequence contents. However, mapping the alignment does not depend on the sequence contents; only the coordinates of and are used to construct the coordinates for .\n\nThe map method can also be used to lift over an alignment between different genome assemblies. In this case, self is a DNA alignment between two genome assemblies, and the argument is an alignment of a transcript against one of the genome assemblies:\n\nshowing that the range 122250000:122909835 of chr1 on chimpanzee genome assembly panTro5 aligns to range 111776384:112019978 of chr1 of chimpanzee genome assembly panTro6. See section 6.7.20 for more information about the chain file format.\n\nThis shows that nucleotide range 32:344 of expressed sequence tag DC525629 aligns to range 122835789:122907314 of chr1 of chimpanzee genome assembly panTro5. Note that the target sequence and the target sequence have the same length:\n\nWe swap the target and query of the chain such that the query of corresponds to the target of :\n\nNow we can get the coordinates of DC525629 against chimpanzee genome assembly panTro6 by calling , with as the argument:\n\nThis shows that nucleotide range 32:344 of expressed sequence tag DC525629 aligns to range 111982717:112009302 of chr1 of chimpanzee genome assembly panTro6. Note that the genome span of DC525629 on chimpanzee genome assembly panTro5 is 122907314 - 122835789 = 71525 bp, while on panTro6 the genome span is 112009302 - 111982717 = 26585 bp.\n\nConsider a multiple alignment of genomic sequences of chimpanzee, human, macaque, marmoset, mouse, and rat:\n\nSuppose we want to replace the older versions of the genome assemblies ( , , , , , and ) by their current versions ( , , , , , and ). To do so, we need the pairwise alignment between the old and the new assembly version for each species. These are provided by UCSC as chain files, typically used for UCSC’s tool. The files in the subdirectory in the Biopython source distribution were extracted from UCSC’s files to only include the relevant genomic region. For example, to lift over to , we use the file with the following contents:\n\nTo lift over the genome assembly for each species, we read in the corresponding file:\n\nNote that the order of species is the same in and . Now we can lift over the multiple sequence alignment to the new genome assembly versions:\n\nAs the files do not include the sequence contents, we cannot print the sequence alignment directly. Instead, we read in the genomic sequence separately (as a file, as it allows lazy loading; see section 5.4) for each species:\n\nThe method can also be used to create a multiple alignment of codon sequences from a multiple sequence alignment of the corresponding amino acid sequences (see Section 7.12.2 for details).\n\nThe (plural) class inherits from and from , and can be used as a list to store objects. The behavior of objects is different from that of objects in three important ways:\n• An object is its own iterator, whereas calling on a list object creates a new iterator each time. An object iterator will therefore behave the same as an iterator returned by (see section 6.6.1) or an iterator returned by the pairwise aligner (see Section 7). >>> from Bio.Align import Alignments >>> alignment_list = [alignment1, alignment2, alignment3] >>> for item in alignment_list: ... print(repr(item)) # doctest: +ELLIPSIS ... <Alignment object (2 rows x 24 columns) at ...> <Alignment object (2 rows x 8 columns) at ...> <Alignment object (2 rows x 19 columns) at ...> >>> for item in alignment_list: ... print(repr(item)) # doctest: +ELLIPSIS ... <Alignment object (2 rows x 24 columns) at ...> <Alignment object (2 rows x 8 columns) at ...> <Alignment object (2 rows x 19 columns) at ...> >>> alignments = Alignments([alignment1, alignment2, alignment3]) >>> for item in alignments: ... print(repr(item)) # doctest: +ELLIPSIS ... <Alignment object (2 rows x 24 columns) at ...> <Alignment object (2 rows x 8 columns) at ...> <Alignment object (2 rows x 19 columns) at ...> >>> for item in alignments: ... print(repr(item)) # doctest: +ELLIPSIS ... The last loop does not print anything because the iterator is already exhausted.\n• The class defines a method that resets the iterator to its first item, allowing us to loop over it again: >>> alignments.rewind() >>> for item in alignments: ... print(repr(item)) # doctest: +ELLIPSIS ... <Alignment object (2 rows x 24 columns) at ...> <Alignment object (2 rows x 8 columns) at ...> <Alignment object (2 rows x 19 columns) at ...>\n• Metadata can be stored as attributes on an object, whereas a plain does not accept attributes: >>> alignment_list.score = 100 # doctest: +ELLIPSIS Traceback (most recent call last): ... AttributeError: 'list' object has no attribute 'score'... >>> alignments.score = 100 >>> alignments.score 100\n\nOutput from sequence alignment software such as Clustal can be parsed into objects by the and functions. Their usage is analogous to the and functions in (see Section 5.1): The function is used to read an output file containing a single alignment and returns an object, while the function returns an iterator to iterate over alignments stored in an output file containing one or more alignments. Section 6.7 describes the alignment formats that can be parsed in . also provides a function that can write alignments in most of these formats.\n\nThe alignments iterator returned by inherits from the base class. This class defines a method that resets the iterator to let it loop over the alignments from the beginning. You can also call on the alignments to obtain the number of alignments. Depending on the file format, the number of alignments may be explicitly stored in the file (for example in the case of bigBed, bigPsl, and bigMaf files), or otherwise the number of alignments is counted by looping over them once (and returning the iterator to its original position). If the file is large, it may therefore take a considerable amount of time for to return. As the number of alignments is cached, subsequent calls to will return quickly.\n\nDepending on the file format, the alignments object returned by may contain attributes that store metadata found in the file, such as the version number of the software that was used to create the alignments. The specific attributes stored for each file format are described in Section 6.7.\n\nTo write alignments to a file, use\n\nwhere is either a single alignment or a list of alignments, is a file name or an open file-like object, and is the file format to be used. As some file formats allow or require metadata to be stored with the alignments, you may want to use the (plural) class instead of a plain list of alignments (see Section 6.5), alloing you to store a metadata dictionary as an attribute on the object:\n\nFor text (non-binary) formats, you can call Python’s built-in function on an alignment to get a string showing the alignment in the requested format, or use objects in formatted (f-) strings. If called without an argument, the function returns the string representation of the alignment:\n\nBy specifying one of the formats shown in Section 6.7, will create a string showing the alignment in the requested format:\n\nAs optional keyword arguments cannot be used with Python’s built-in function or with formatted strings, the class has a method with optional arguments to customize the alignment format, as described in the subsections below. For example, we can print the alignment in BED format (see section 6.7.14) with a specific number of columns:\n\nThe table below shows the alignment formats that can be parsed in Bio.Align. The format argument used in functions to specify the file format is case-insensitive. Most of these file formats can also be written by , as shown in the table.\n\nFiles in the aligned FASTA format store exactly one (pairwise or multiple) sequence alignment, in which gaps in the alignment are represented by dashes ( ). Use to read or write files in the aligned FASTA format. Note that this is different from output generated by William Pearson’s FASTA alignment program (parsing such output is described in section 6.7.9 instead).\n\nThe file in Biopython’s test suite stores one multiple alignment in the aligned FASTA format. The contents of this file is as follows:\n\nTo read this file, use\n\nWe can print the alignment to see its default representation:\n\nor we can print it in the aligned FASTA format:\n\nor any other available format, for example Clustal (see section 6.7.2):\n\nThe sequences associated with the alignment are objects:\n\nNote that these sequences do not contain gaps (\" \" characters), as the alignment information is stored in the attribute instead:\n\nUse to write this alignment to a file (here, we’ll use a object instead of a file):\n\nNote that returns the number of alignments written (1, in this case).\n\nClustal is a set of multiple sequence alignment programs that are available both as standalone programs as as web servers. The file (available online or in the subdirectory of the Biopython source code) is an output file generated by Clustal. Its first few lines are\n\nTo parse this file, use\n\nThe attribute on stores the information shown in the file header:\n\nYou can call on the to pull out the first (and only) alignment:\n\nIf you are not interested in the metadata, then it is more convenient to use the function, as anyway each Clustal file contains only one alignment:\n\nThe consensus line below each alignment block in the Clustal output file contains an asterisk if the sequence is conserved at each position. This information is stored in the attribute of the :\n\nPrinting the in format will show the sequence alignment, but does not include the metadata:\n\nWriting the in format will include both the metadata and the sequence alignment:\n\nUse an (plural) object (see Section 6.5) if you are creating alignments by hand, and would like to include metadata information in the output.\n\nThis is an example of a protein sequence alignment in the Stockholm file format used by PFAM:\n\nThis is the seed alignment for the 7kD_DNA_binding (PF02294.20) PFAM entry, downloaded from the InterPro website (https://www.ebi.ac.uk/interpro/). This version of the PFAM entry is also available in the Biopython source distribution as the file in the subdirectory . We can load this file as follows:\n\nWe can print out a summary of the alignment:\n\nYou could also call Python’s built-in function on the alignment object to show it in a particular file format (see section 6.6.3 for details), for example in the Stockholm format to regenerate the file:\n\nor alternatively as aligned FASTA (see section 6.7.1):\n\nor in the PHYLIP format (see section 6.7.4):\n\nGeneral information of the alignment is stored under the attribute of the object, for example\n\nThe individual sequences in this alignment are stored under as s, including any annotations associated with each sequence record:\n\nThe secondary structure of the second sequence ( ) is stored in the attribute of the :\n\nThe consensus sequence and secondary structure are associated with the sequence alignment as a whole, and are therefore stored in the attribute of the object:\n\nThe PHYLIP format for sequence alignments is derived from the PHYLogeny Interference Package from Joe Felsenstein. Files in the PHYLIP format start with two numbers for the number of rows and columns in the printed alignment. The sequence alignment itself can be in sequential format or in interleaved format. An example of the former is the file (provided in in the Biopython source distribution):\n\nIn the sequential format, the complete alignment for one sequence is shown before proceeding to the next sequence. In the interleaved format, the alignments for different sequences are next to each other, for example in the file (provided in in the Biopython source distribution):\n\nThe parser in detects from the file contents if it is in the sequential or in the interleaved format, and then parses it appropriately.\n\nHere, two alignments are considered to be equal if they have the same sequence contents and the same alignment coordinates.\n\nWhen outputting the alignment in PHYLIP format, writes each of the aligned sequences on one line:\n\nWe can write the alignment in PHYLIP format, parse the result, and confirm it is the same as the original alignment object:\n\nEMBOSS (European Molecular Biology Open Software Suite) is a set of open-source software tools for molecular biology and bioinformatics [37]. It includes software such as and for pairwise sequence alignment. This is an example of output generated by the program for Smith-Waterman local pairwise sequence alignment (available as in the directory of the Biopython distribution):\n\nAs this output file contains only one alignment, we can use to extract it directly. Here, instead we will use so we can see the metadata of this run:\n\nThe attribute of stores the information shown in the header of the file, including the program used to generate the output, the date and time the program was run, the output file name, and the specific alignment file format that was used (assumed to be by default):\n\nTo pull out the alignment, we use\n\nWe can use indices to extract specific parts of the alignment:\n\nThe attribute of the stores the information associated with this alignment specifically:\n\nThe number of gaps, identities, and mismatches can also be obtained by calling the method on the object:\n\nwhere is a in the module in Python’s standard library.\n\nThe consensus line shown between the two sequences is stored in the attribute:\n\nUse the function (or the method) to print the alignment in other formats, for example in the PHYLIP format (see section 6.7.4):\n\nWe can use to get the individual sequences. However, as this is a pairwise alignment, we can also use and to get the target and query sequences:\n\nCurrently, Biopython does not support writing sequence alignments in the output formats defined by EMBOSS.\n\nThe Multiple Sequence Format (MSF) was created to store multiple sequence alignments generated by the GCG (Genetics Computer Group) set of programs. The file in the directory of the Biopython distribution is an example of a sequence alignment file in the MSF format This file shows an alignment of 11 protein sequences:\n\nTo parse this file with Biopython, use\n\nThe parser skips all lines up to and including the line starting with \" \". The following lines (until the \" \" demarcation) are read by the parser to verify the length of each sequence. The alignment section (after the \" \" demarcation) is read by the parser and stored as an object:\n\nThe sequences and their names are stored in the attribute:\n\nThe alignment coordinates are stored in the attribute:\n\nCurrently, Biopython does not support writing sequence alignments in the MSF format.\n\nExonerate is a generic program for pairwise sequence alignments [42]. The sequence alignments found by Exonerate can be output in a human-readable form, in the \"cigar\" (Compact Idiosyncratic Gapped Alignment Report) format, or in the \"vulgar\" (Verbose Useful Labelled Gapped Alignment Report) format. The user can request to include one or more of these formats in the output. The parser in can only parse alignments in the cigar or vulgar formats, and will not parse output that includes alignments in human-readable format.\n\nThe file in the Biopython test suite is an example of an Exonerate output file showing the alignments in vulgar format:\n\nThis file includes three alignments. To parse this file, use\n\nThe dictionary stores general information about these alignments, shown at the top of the output file:\n\nNow we can iterate over the alignments. The first alignment, with alignment score 6146.0, has no gaps:\n\nNote that the target (the first sequence) in the printed alignment is on the reverse strand while the query (the second sequence) is on the forward strand, with the target coordinate decreasing and the query coordinate increasing. Printing this alignment in format using Python’s built-in function writes a vulgar line:\n\nUsing the method allows us to request either a vulgar line (default) or a cigar line:\n\nThe vulgar line contains information about the alignment (in the section ) that is missing from the cigar line . The vulgar line specifies that the alignment starts with a single aligned nucleotides, followed by three aligned nucleotides that form a codon ( ), followed by 1226 aligned nucleotides. In the cigar line, we see a single aligned nucleotide, followed by three aligned nucleotides, followed by 1226 aligned nucleotides; it does not specify that the three aligned nucleotides form a codon. This information from the vulgar line is stored in the attribute:\n\nSee the Exonerate documentation for the definition of other operation codes.\n\nSimilarly, the or argument can be used when calling to write a file with vulgar or cigar alignment lines.\n\nWe can print the alignment in BED and PSL format:\n\nThe SAM format parser defines its own (optional) attribute (section 6.7.13), which is not quite consistent with the attribute defined in the Exonerate format parser. As the attribute is optional, we delete it before printing the alignment in SAM format:\n\nThe third alignment contains four long gaps:\n\nThe NEXUS file format [30] is used by several programs to store phylogenetic information. This is an example of a file in the NEXUS format (available as in the subdirectory in the Biopython distribution):\n\nIn general, files in the NEXUS format can be much more complex. relies heavily on NEXUS parser in (see Chapter 16) to extract objects from NEXUS files.\n\nTo read the alignment in this NEXUS file, use\n\nThe sequences are stored under the attribute:\n\nTo print this alignment in the NEXUS format, use\n\nSimilarly, you can use to write the alignment in the NEXUS format to the file .\n\nAlignment output in tabular output is generated by the FASTA aligner [34] run with the or argument, or by BLAST [1] run with the argument.\n\nThe file in the subdirectory of the Biopython source distribution is an example of an output file generated by FASTA with the argument:\n\nTo parse this file, use\n\nInformation shown in the file header is stored in the attribute of :\n\nExtract a specific alignment by iterating over the . As an example, let’s go to the fourth alignment:\n\nThe sequence information of the target and query sequences is stored in the and attributes (as well as under ):\n\nInformation of the alignment is stored under the attribute of the :\n\nBLAST in particular offers many options to customize tabular output by including or excluding specific columns; see the BLAST documentation for details. This information is stored in the dictionaries , , or , as appropriate.\n\nAlignment files in the format are generated by or in HH-suite [44]. As an example, see the file in Biopython’s test suite:\n\nThe file contains three sections:\n• A header with general information about the alignments;\n• A summary with one line for each of the alignments obtained;\n\nTo parse this file, use\n\nMost of the header information is stored in the attribute of :\n\nexcept the query name, which is stored as an attribute:\n\nas it will reappear in each of the alignments.\n\nLet’s look at the first alignment in more detail:\n\nThe target and query sequences are stored in . As these are pairwise alignments, we can also access them through and :\n\nThe ID of the query is set from the (note that the query ID printed in the alignment in the file is abbreviated):\n\nThe ID of the target is taken from the sequence alignment block (the line starting with ):\n\nThe sequence contents of the target and query are filled in from the information available in this alignment:\n\nThe sequence contents will be incomplete (a partially defined sequence; see Section 3.12) if the alignment does not extend over the full sequence.\n\nThe second line of this alignment block, starting with \" \", shows the name and description of the Hidden Markov Model from which the target sequence was taken. These are stored under the keys and in the dictionary:\n\nThe dictionary stores the target alignent consensus sequence, the secondary structure as predicted by PSIPRED, and the target secondary structure as determined by DSSP:\n\nIn this example, for the query sequence only the consensus sequence is available:\n\nThe dictionary stores information about the alignment shown on the third line of the alignment block:\n\nConfidence values for the pairwise alignment are stored under the key in the dictionary. This dictionary also stores the score for each column, shown between the query and the target section of each alignment block:\n\nA2M files are alignment files created by or in the SAM Sequence Alignment and Modeling Software System [26, 21]. An A2M file contains one multiple alignment. The A2M file format is similar to aligned FASTA (see section 6.7.1). However, to distinguish insertions from deletions, A2M uses both dashes and periods to represent gaps, and both upper and lower case characters in the aligned sequences. Matches are represented by upper case letters and deletions by dashes in alignment columns containing matches or deletions only. Insertions are represented by lower case letters, with gaps aligned to the insertion shown as periods. Header lines start with \" \" followed by the name of the sequence, and optionally a description.\n\nThe file in Biopython’s test suite is an example of an A2M file (see section 6.7.1 for the same alignment in aligned FASTA format):\n\nTo parse this alignment, use\n\nThe parser analyzes the pattern of dashes, periods, and lower and upper case letters in the A2M file to determine if a column is an match/mismatch/deletion (\" \") or an insertion (\" \"). This information is stored under the key of the dictionary:\n\nAs the state information is stored in the , we can print the alignment in the A2M format:\n\nSimilarly, the alignment can be written in the A2M format to an output file using (see section 6.6.2).\n\nMauve [8] is a software package for constructing multiple genome alignments. These alignments are stored in the eXtended Multi-FastA (xmfa) format. Depending on how exactly (the aligner program in Mauve) was called, the xmfa format is slightly different.\n\nIf is called with a single sequence input file, as in\n\nwhere contains the genome sequences:\n\nthen the output file is as follows:\n\nwith numbers (1, 2, 3) referring to the input genome sequences for horse ( ), mouse ( ), and dog ( ), respectively. This xmfa file consists of six alignment blocks, separated by characters. Use to extract these alignments:\n\nThe file header data are stored in the attribute:\n\nThe attribute stores the sequence identifiers for the three sequences, which in this case is the three numbers:\n\nThese identifiers are used in the individual alignments:\n\nNote that only the first block is a real alignment; the other blocks contain only a single sequence. By including these blocks, the xmfa file contains the full sequence that was provided in the input file.\n\nIf is called with a separate input file for each genome, as in\n\nwhere each Fasta file contains the genome sequence for one species only, then the output file is as follows:\n\nThe identifiers for horse, for mouse, and for dog are now shown explicitly in the output file. This xmfa file consists of two alignment blocks, separated by characters. Use to extract these alignments:\n\nThe file header data now does not include the input file name:\n\nThe attribute stores the sequence identifiers for the three sequences:\n\nThese identifiers are used in the individual alignments:\n\nTo output the alignments in Mauve format, use :\n\nHere, the writer makes use of the information stored in and to create this format. If your object does not have these attributes, you can provide them as keyword arguments to :\n\nPython does not allow you to add these attributes to the object directly, as in this example it was converted to a plain list. However, you can construct an object and add attributes to it (see Section 6.5):\n\nWhen printing a single alignment in format, use keyword arguments to provide the metadata and identifiers:\n\nFiles in the Sequence Alignment/Map (SAM) format [29] store pairwise sequence alignments, usually of next-generation sequencing data against a reference genome. The file in Biopython’s test suite is an example of a minimal file in the SAM format. Its first few lines are as follows:\n\nTo parse this file, use\n\nThe of the first line is 69. According to the SAM/BAM file format specification, lines for which the flag contains the bitwise flag 4 are unmapped. As 69 has the bit corresponding to this position set to True, this sequence is unmapped and was not aligned to the genome (in spite of the first line showing ). The target of this alignment (or the first item in ) is therefore :\n\nThe second line represents an alignment to chromosome 1:\n\nAs this SAM file does not store the genome sequence information for each alignment, we cannot print the alignment. However, we can print the alignment information in SAM format or any other format (such as BED, see section 6.7.14) that does not require the target sequence information:\n\nHowever, we cannot print the alignment in PSL format (see section 6.7.16) as that would require knowing the size of the target sequence chr1:\n\nIf you know the size of the target sequences, you can set them by hand:\n\nThe file in Biopython’s test suite contains the same alignments, but now also includes a header. Its first few lines are as follows:\n\nThe header stores general information about the alignments, including the size of the target chromosomes. The target information is stored in the attribute of the object:\n\nOther information provided in the header is stored in the attribute:\n\nWith the target information, we can now also print the alignment in PSL format:\n\nWe can now also print the alignment in human-readable form, but note that the target sequence contents is not available from this file:\n\nAlignments in the file in the Biopython test suite contain an additional tag that shows how the query sequence differs from the target sequence:\n\nThe parser reconstructs the local genome sequence from the tag, allowing us to see the target sequence explicitly when printing the alignment:\n\nSAM files may include additional information to distinguish simple sequence insertions and deletions from skipped regions of the genome (e.g. introns), hard and soft clipping, and padded sequence regions. As this information cannot be stored in the attribute of an object, and is stored in a dedicated attribute instead. Let’s use the third alignment in this SAM file as an example:\n\nIn this alignment, the cigar string defines 46 aligned nucleotides, an intron of 1827 nucleotides, 82 aligned nucleotides, an intron of 3376 nucleotides, 76 aligned nucleotides, and 12 hard-clipped nucleotides. These operations are shown in the attribute, except for hard-clipping, which is stored in (or , if applicable) instead.\n\nTo write a SAM file with alignments created from scratch, use an (plural) object (see Section 6.5) to store the alignments as well as the metadata and targets:\n\nBED (Browser Extensible Data) files are typically used to store the alignments of gene transcripts to the genome. See the description from UCSC for a full explanation of the BED format.\n\nBED files have three required fields and nine optional fields. The file in subdirectory is an example of a BED file with 12 fields:\n\nTo parse this file, use\n\nNote that the first sequence (\" \") was mapped to the forward strand, while the second sequence (\" \") was mapped to the reverse strand.\n\nAs a BED file does not store the length of each chromosome, the length of the target sequence is set to its maximum:\n\nThe length of the query sequence can be inferred from its alignment information:\n\nThe alignment score (field 5) and information stored in fields 7-9 (referred to as , , and in the BED format specification) are stored as attributes on the object:\n\nTo print an alignment in the BED format, you can use Python’s built-in function:\n\nor you can use the method of the object. This allows you to specify the number of fields to be written as the keyword argument:\n\nThe same keyword argument can be used with :\n\nThe bigBed file format is an indexed binary version of a BED file 6.7.14. To create a bigBed file, you can either use the program from UCSC (). or you can use Biopython for it by calling the function with . While the two methods should result in identical bigBed files, using is much faster and may be more reliable, as it is the gold standard. As bigBed files come with a built-in index, it allows you to quickly search a specific genomic region.\n\nAs an example, let’s parse the bigBed file , available in the subdirectory in the Biopython distribution:\n\nThe contains the specification of the columns, in AutoSql format, that was used to create the bigBed file. Target sequences (typically, the chromosomes against which the sequences were aligned) are stored in the attribute. In the bigBed format, only the identifier and the size of each target is stored. In this example, there is only a single chromosome:\n\nLet’s look at the individual alignments. The alignment information is stored in the same way as for a BED file (see section 6.7.14):\n\nThe default bigBed format does not store the sequence contents of the target and query. If these are available elsewhere (for example, a Fasta file), you can set and to show the sequence contents when printing the alignment, or to write the alignment in formats that require the sequence contents (such as Clustal, see section 6.7.2). The test script in the subdirectory in the Biopython distribution gives some examples on how to do that.\n\nNow let’s see how to search for a sequence region. These are the sequences stored in the bigBed file, printed in BED format (see section 6.7.14):\n\nUse the method on the object to find regions on chr3 between positions 48000000 and 49000000. This method returns an iterator:\n\nThe chromosome name may be to include all chromosomes, and the start and end positions may be to start searching from position 0 or to continue searching until the end of the chromosome, respectively.\n\nWriting alignments in the bigBed format is as easy as calling :\n\nYou can specify the number of BED fields to be included in the bigBed file. For example, to write a BED6 file, use\n\nSame as for , you can include additional columns in the bigBed output. Suppose the file (available in the subdirectory of the Biopython distribution) stores the declaration of the included BED fields in AutoSql format. We can read this declaration as follows:\n\nNow we can write a bigBed file with the 9 BED fields plus the additional fields and by calling\n\nHere, we also requested to include additional indices on the and in the bigBed file. expects to find the keys and in the dictionary. Please refer to the test script in the subdirectory in the Biopython distribution for more examples of writing alignment files in the bigBed format.\n\nPSL (Pattern Space Layout) files are are generated by the BLAST-Like Alignment Tool BLAT [24]. Like BED files (see section 6.7.14), PSL files are typically used to store alignments of transcripts to genomes. This is an example of a short BLAT file (available as in the subdirectory of the Biopython distribution), with the standard PSL header consisting of 5 lines:\n\nTo parse this file, use\n\nIterate over the alignments to get one object for each line:\n\nLet’s look at the last alignment in more detail. The first four columns in the PSL file show the number of matches, the number of mismatches, the number of nucleotides aligned to repeat regions, and the number of nucleotides aligned to N (unknown) characters. These values are stored as attributes to the object:\n\nAs the sequence data of the target and query are not stored explicitly in the PSL file, the sequence content of and is undefined. However, their sequence lengths are known:\n\nWe can print the alignment in BED or PSL format:\n\nHere, the number of matches, mismatches, repeat region matches, and matches to unknown nucleotides were taken from the corresponding attributes of the object. If these attributes are not available, for example if the alignment did not come from a PSL file, then these numbers are calculated using the sequence contents, if available. Repeat regions in the target sequence are indicated by masking the sequence as lower-case or upper-case characters, as defined by the following values for the keyword argument:\n• (default): Do not count matches to masked sequences separately;\n• : Count and report matches to lower-case characters as matches to repeat regions;\n• : Count and report matches to upper-case characters as matches to repeat regions;\n\nThe character used for unknown nucleotides is defined by the argument. For consistency with BLAT, the wildcard character is by default. Use if you don’t want to count matches to any unknown nucleotides separately.\n\nThe same arguments can be used when writing alignments to an output file in PSL format using . This function has an additional keyword ( by default) specifying if the PSL header should be written.\n\nIn addition to the method, you can use Python’s built-in function:\n\nallowing objects to be used in formatted (f-) strings in Python:\n\nNote that optional keyword arguments cannot be used with the function or with formatted strings.\n\nA bigPsl file is a bigBed file with a BED12+13 format consisting of the 12 predefined BED fields and 13 custom fields defined in the AutoSql file bigPsl.as provided by UCSC, creating an indexed binary version of a PSL file (see section 6.7.16). To create a bigPsl file, you can either use the and programs from UCSC. or you can use Biopython by calling the function with . While the two methods should result in identical bigPsl files, the UCSC tools are much faster and may be more reliable, as it is the gold standard. As bigPsl files are bigBed files, they come with a built-in index, allowing you to quickly search a specific genomic region.\n\nAs an example, let’s parse the bigBed file , available in the subdirectory in the Biopython distribution. This file is the bigPsl equivalent of the bigBed file (see section 6.7.15) and of the PSL file (see section 6.7.16).\n\nThe declaration contains the specification of the columns as defined by the AutoSql file from UCSC. Target sequences (typically, the chromosomes against which the sequences were aligned) are stored in the attribute. In the bigBed format, only the identifier and the size of each target is stored. In this example, there is only a single chromosome:\n\nIterating over the alignments gives one Alignment object for each line:\n\nLet’s look at the individual alignments. The alignment information is stored in the same way as for the corresponding PSL file (see section 6.7.16):\n\nWe can print the alignment in BED or PSL format:\n\nAs a bigPsl file is a special case of a bigBed file, you can use the method on the alignments object to find alignments to specific genomic regions. For example, we can look for regions on chr3 between positions 48000000 and 49000000:\n\nThe chromosome name may be to include all chromosomes, and the start and end positions may be to start searching from position 0 or to continue searching until the end of the chromosome, respectively.\n\nTo write a bigPsl file with Biopython, use , where is the name of the output bigPsl file. Alternatively, you can use a (binary) stream for output. Additional options are\n• : If (default), compress data using zlib; if , do not compress data.\n• : List of strings with the names of extra columns to be indexed.\n• : If , look for a query feature of type CDS and write it in NCBI style in the PSL file (default: ).\n• : If , include the query sequence in the PSL file (default: ).\n• : Specify if repeat regions in the target sequence are masked and should be reported in the field instead of in the field. Acceptable values are\n• : Report alignments to the wildcard character (representing unknown nucleotides) in the target or query sequence in the field instead of in the , , or fields. Default value is .\n\nSee section 6.7.16 for an explanation on how the number of matches, mismatches, repeat region matches, and matches to unknown nucleotides are obtained.\n\nMAF (Multiple Alignment Format) files store a series of multiple sequence alignments in a human-readable format. MAF files are typically used to store alignment s of genomes to each other. The file in the subdirectory of the Biopython distribution is an example of a simple MAF file:\n\nTo parse this file, use\n\nInformation shown in the file header (the track line and subsequent lines starting with \" \")) is stored in the attribute of the object:\n\nBy iterating over the we obtain one object for each alignment block in the MAF file:\n\nIn addition to the \" \" (alignment block) and \" \" (sequence) lines, MAF files may contain \" \" lines with information about the genome sequence before and after this block, \" \" lines with information about empty parts of the alignment, and \" \" lines showing the quality of each aligned base. This is an example of an alignment block including such lines:\n\nThis is the 10th alignment block in the file (available in the subdirectory of the Biopython distribution):\n\nThe \" \" lines show the relationship between the sequence in the current alignment block to the ones in the preceding and subsequent alignment block. This information is stored in the attribute of the corresponding sequence:\n\nshowing that there are 9085 bases inserted (\" \") between this block and the preceding one, while the block is contiguous (\" \") with the subsequent one. See the UCSC documentation for the full description of these fields and status characters.\n\nThe \" \" lines show the sequence quality, which is stored under the \" \" dictionary key of the attribute of the corresponding sequence:\n\nThe \" \" lines show information about species with a contiguous sequence before and after this alignment bloack, but with no aligning nucleotides in this alignment block. This is stored under the \" \" key of the dictionary:\n\nThis shows for example that there were non-aligning bases inserted (\" \") from position 158040939 to 158048983 on the opposite strand of the genomic sequence. Again, see the UCSC documentation for the full definition of \" \" lines.\n\nTo print an alignment in MAF format, you can use Python’s built-in function:\n\nTo write a complete MAF file, use , where is the name of the output MAF file. Alternatively, you can use a (text) stream for output. File header information will be taken from the attribute of the object. If you are creating the alignments from scratch, you can use the (plural) class to create a list-like object (see Section 6.5) and give it a attribute.\n\nA bigMaf file is a bigBed file with a BED3+1 format consisting of the 3 required BED fields plus a custom field that stores a MAF alignment block as a string, crearing an indexed binary version of a MAF file (see section 6.7.19). The associated AutoSql file bigMaf.as is provided by UCSC. To create a bigMaf file, you can either use the and programs from UCSC. or you can use Biopython by calling the Bio.Align.write function with . While the two methods should result in identical bigMaf files, the UCSC tools are much faster and may be more reliable, as it is the gold standard. As bigMaf files are bigBed files, they come with a built-in index, allowing you to quickly search a specific region of the reference genome.\n\nThe file in the subdirectory of the Biopython distribution is an example of a bigMaf file. This file is equivalent to the MAF file (see section 6.7.18). To parse this file, use\n\nThe declaration contains the specification of the columns as defined by the bigMaf.as AutoSql file from UCSC.\n\nThe bigMaf file does not store the header information found in the MAF file, but it does define a reference genome. The corresponding is stored in the attribute of the object:\n\nBy iterating over the we obtain one object for each alignment block in the bigMaf file:\n\nInformation in the \" \", \" \", and \" \" lines is stored in the same way as in the corresponding MAF file (see section 6.7.18):\n\nTo write a complete bigMaf file, use , where is the name of the output bigMaf file. Alternatively, you can use a (binary) stream for output. If you are creating the alignments from scratch, you can use the (plural) class to create a list-like object (see Section 6.5) and give it a attribute. The latter must be a list of objects for the chromosomes for the reference species in the order in which they appear in the alignments. Alternatively, you can use the keyword argument when calling . The of each must be of the form , where refers to the reference species. has the additional keyword argument ( by default) specifying whether the data should be compressed using zlib.\n\nAs a bigMaf file is a special case of a bigBed file, you can use the method on the object to find alignments to specific regions of the reference species. For example, we can look for regions on chr10 between positions 3018000 and 3019000 on chromosome 10:\n\nThe chromosome name may be to include all chromosomes, and the start and end positions may be to start searching from position 0 or to continue searching until the end of the chromosome, respectively. Note that we can search on genomic position for the reference species only.\n\nChain files describe a pairwise alignment between two nucleotide sequences, allowing gaps in both sequences. Only the length of each aligned subsequences and the gap lengths are stored in a chain file; the sequences themselves are not stored. Chain files are typically used to store alignments between two genome assembly versions, allowing alignments to one genome assembly version to be lifted over to the other genome assembly. This is an example of a chain file (available as in the subdirectory of the Biopython distribution):\n\nThis file was generated by running UCSC’s program on the PSL file . According to the chain file format specification, there should be a blank line after each chain block, but some tools (including ) apparently do not follow this rule.\n\nTo parse this file, use\n\nIterate over alignments to get one object for each chain:\n\nRewind the alignments, and iterate from the start until we reach the seventh alignment:\n\nCheck the alignment score and chain ID (the first and last number, respectively, in the header line of each chain block) to confirm that we got the seventh alignment:\n\nWe can print the alignment in the chain file format. The alignment coordinates are consistent with the information in the chain block, with an aligned section of 6 nucleotides, a gap of 4 nucleotides, and an aligned section of 38 nucleotides:\n\nWe can also print the alignment in a few other alignment fite formats:\n\nPairwise sequence alignment is the process of aligning two sequences to each other by optimizing the similarity score between them. The module contains the class for global and local alignments using the Needleman-Wunsch, Smith-Waterman, Gotoh (three-state), and Waterman-Smith-Beyer global and local pairwise alignment algorithms, with numerous options to change the alignment parameters. We refer to Durbin et al. [11] for in-depth information on sequence alignment algorithms.\n\nThe object (see Section 7.2) stores the alignment parameters to be used for the pairwise alignments. These attributes can be set in the constructor of the object:\n\nor after the object is made:\n\nUse the method to calculate the alignment score between two sequences:\n\nThe method returns objects, each representing one alignment between the two sequences:\n\nIterate over the objects and print them to see the alignments:\n\nas well as pointers to the sequences that were aligned:\n\nInternally, the alignment is stored in terms of the sequence coordinates:\n\nHere, the two rows refer to the target and query sequence. These coordinates show that the alignment consists of the following three blocks:\n• aligned to a gap, since is an empty string;\n\nThe number of aligned sequences is always 2 for a pairwise alignment:\n\nThe alignment length is defined as the number of columns in the alignment as printed. This is equal to the sum of the number of matches, number of mismatches, and the total length of gaps in the target and query:\n\nThe property, which returns the start and end indices of aligned subsequences, returns two tuples of length 2 for the first alignment:\n\nwhile for the alternative alignment, two tuples of length 3 are returned:\n\nNote that different alignments may have the same subsequences aligned to each other. In particular, this may occur if alignments differ from each other in terms of their gap placement only:\n\nThe method can be applied on a pairwise alignment to find the pairwise alignment of the query of to the target of , where the target of and the query of are identical. A typical example is where is the pairwise alignment between a chromosome and a transcript, is the pairwise alignment between the transcript and a sequence (e.g., an RNA-seq read), and we want to find the alignment of the sequence to the chromosome:\n\nMapping the alignment does not depend on the sequence contents. If we delete the sequence contents, the same alignment is found in PSL format (though we obviously lose the ability to print the sequence alignment):\n\nBy default, a global pairwise alignment is performed, which finds the optimal alignment over the whole length of and . Instead, a local alignment will find the subsequence of and with the highest alignment score. Local alignments can be generated by setting to :\n\nNote that there is some ambiguity in the definition of the best local alignments if segments with a score 0 can be added to the alignment. We follow the suggestion by Waterman & Eggert [49] and disallow such extensions.\n\nThe object stores all alignment parameters to be used for the pairwise alignments. To see an overview of the values for all parameters, use\n\nSee Sections 7.3, 7.4, and 7.5 below for the definition of these parameters. The attribute (described above in Section 7.1) can be set equal to or to specify global or local pairwise alignment, respectively.\n\nDepending on the gap scoring parameters (see Sections 7.4 and 7.5) and mode, a object automatically chooses the appropriate algorithm to use for pairwise sequence alignment. To verify the selected algorithm, use\n\nA object also stores the precision є to be used during alignment. The value of є is stored in the attribute , and by default is equal to 10−6:\n\nTwo scores will be considered equal to each other for the purpose of the alignment if the absolute difference between them is less than є.\n\nSubstitution scores define the value to be added to the total score when two letters (nucleotides or amino acids) are aligned to each other. The substitution scores to be used by the can be specified in two ways:\n• By specifying a match score for identical letters, and a mismatch scores for mismatched letters. Nucleotide sequence alignments are typically based on match and mismatch scores. For example, by default BLAST [1] uses a match score of +1 and a mismatch score of −2 for nucleotide alignments by , with a gap penalty of 2.5 (see section 7.4 for more information on gap scores). Match and mismatch scores can be specified by setting the and attributes of the object: When using match and mismatch scores, you can specify a wildcard character ( by default) for unknown letters. These will get a zero score in alignments, irrespective of the value of the match or mismatch score:\n• Alternatively, you can use the attribute of the object to specify a substitution matrix. This allows you to apply different scores for different pairs of matched and mismatched letters. This is typically used for amino acid sequence alignments. For example, by default BLAST [1] uses the BLOSUM62 substitution matrix for protein alignments by . This substitution matrix is available from Biopython: >>> from Bio.Align import substitution_matrices >>> substitution_matrices.load() # doctest: +ELLIPSIS ['BENNER22', 'BENNER6', 'BENNER74', 'BLASTN', 'BLASTP', 'BLOSUM45', 'BLOSUM50', 'BLOSUM62', ..., 'TRANS'] >>> matrix = substitution_matrices.load(\"BLOSUM62\") >>> print(matrix) # doctest: +ELLIPSIS # Matrix made by matblas from blosum62.iij ... A R N D C Q ... A 4.0 -1.0 -2.0 -2.0 0.0 -1.0 ... R -1.0 5.0 0.0 -2.0 -3.0 1.0 ... N -2.0 0.0 6.0 1.0 -3.0 0.0 ... D -2.0 -2.0 1.0 6.0 -3.0 0.0 ... C 0.0 -3.0 -3.0 -3.0 9.0 -3.0 ... Q -1.0 1.0 0.0 0.0 -3.0 5.0 ... ... >>> aligner.substitution_matrix = matrix >>> score = aligner.score(\"ACDQ\", \"ACDQ\") >>> score 24.0 >>> score = aligner.score(\"ACDQ\", \"ACNQ\") >>> score 19.0 When using a substitution matrix, is not interpreted as an unknown character. Instead, the score provided by the substitution matrix will be used:\n\nBy default, is . The attributes and are ignored if is not . Setting or to valid values will reset to .\n\nAffine gap scores are defined by a score to open a gap, and a score to extend an existing gap:\n\nwhere n is the length of the gap. Biopython’s pairwise sequence aligner allows fine-grained control over the gap scoring scheme by specifying the following twelve attributes of a object:\n\nThese attributes allow for different gap scores for internal gaps and on either end of the sequence, as shown in this example:\n\nFor convenience, objects have additional attributes that refer to a number of these values collectively, as shown (hierarchically) in Table 7.1.\n\nFor even more fine-grained control over the gap scores, you can specify a gap scoring function. For example, the gap scoring function below disallows a gap after two nucleotides in the query sequence:\n\nBy default, a object is initialized with a match score of +1.0, a mismatch score of 0.0, and all gap scores equal to 0.0, While this has the benefit of being a simple scoring scheme, in general it does not give the best performance. Instead, you can use the argument to select a predefined scoring scheme when initializing a object. Currently, the provided scoring schemes are and , which are suitable for nucleotide alignments, and , which is suitable for protein alignments. Selecting these scoring schemes will initialize the object to the default scoring parameters used by BLASTN, MegaBLAST, and BLASTP, respectively.\n\nThe returned by are a kind of immutable iterable objects (similar to ). While they appear similar to a or of objects, they are different in the sense that each object is created dynamically when it is needed. This approach was chosen because the number of alignments can be extremely large, in particular for poor alignments (see Section 7.10 for an example).\n\nYou can perform the following operations on :\n• returns the number of alignments stored. This function returns quickly, even if the number of alignments is huge. If the number of alignments is extremely large (typically, larger than 9,223,372,036,854,775,807, which is the largest integer that can be stored as a on 64 bit machines), will raise an . A large number of alignments suggests that the alignment quality is low.\n• You can extract a specific alignment by index:\n• You can iterate over alignments, for example as in By calling , you can rewind the iterator to the first alignment and iterate over the alignments from the beginning: >>> from Bio import Align >>> aligner = Align.PairwiseAligner() >>> alignments = aligner.align(\"AAA\", \"AA\") >>> for alignment in alignments: ... print(alignment) ... target 0 AAA 3 0 ||- 3 query 0 AA- 2 <BLANKLINE> target 0 AAA 3 0 |-| 3 query 0 A-A 2 <BLANKLINE> target 0 AAA 3 0 -|| 3 query 0 -AA 2 <BLANKLINE> >>> alignments.rewind() >>> for alignment in alignments: ... print(alignment) ... target 0 AAA 3 0 ||- 3 query 0 AA- 2 <BLANKLINE> target 0 AAA 3 0 |-| 3 query 0 A-A 2 <BLANKLINE> target 0 AAA 3 0 -|| 3 query 0 -AA 2 <BLANKLINE> You can also convert the iterator into a or : It is wise to check the number of alignments by calling before attempting to call to save all alignments as a list.\n• The alignment score (which has the same value for each alignment in ) is stored as an attribute. This allows you to check the alignment score before proceeding to extract individual alignments:\n\nBy default, the pairwise aligner aligns the forward strand of the query to the forward strand of the target. To calculate the alignment score for to the reverse strand of , use :\n\nThe alignments against the reverse strand can be obtained by specifying when calling :\n\nNote that the score for aligning to the reverse strand of may be different from the score for aligning the reverse complement of to the forward strand of if the left and right gap scores are different:\n\nSubstitution matrices [11] provide the scoring terms for classifying how likely two different residues are to substitute for each other. This is essential in doing sequence comparisons. Biopython provides a ton of common substitution matrices, including the famous PAM and BLOSUM series of matrices, and also provides functionality for creating your own substitution matrices.\n\nYou can think of substitutions matrices as 2D arrays in which the indices are letters (nucleotides or amino acids) rather than integers. The class in is a subclass of numpy arrays that supports indexing both by integers and by specific strings. An instance can either be a one-dimensional array or a square two-dimensional arrays. A one-dimensional object can for example be used to store the nucleotide frequency of a DNA sequence, while a two-dimensional object can be used to represent a scoring matrix for sequence alignments.\n\nTo create a one-dimensional , only the alphabet of allowed letters needs to be specified:\n\nThe allowed letters are stored in the property:\n\nThis property is read-only; modifying the underlying attribute may lead to unexpected results. Elements can be accessed both by letter and by integer index:\n\nUsing a letter that is not in the alphabet, or an index that is out of bounds, will cause a :\n\nA two-dimensional can be created by specifying :\n\nAgain, both letters and integers can be used for indexing, and specifying a letter that is not in the alphabet will cause an :\n\nSelecting a row or column from the two-dimensional array will return a one-dimensional :\n\nobjects can thus be used as an array and as a dictionary. They can be converted to plain numpy arrays or plain dictionary objects:\n\nWhile the alphabet of an is usually a string, you may also use a tuple of (immutable) objects. This is used for example for a codon substitution matrix, where the keys are not individual nucleotides or amino acids but instead three-nucleotide codons.\n\nWhile the property of an is immutable, you can create a new object by selecting the letters you are interested in from the alphabet. For example,\n\nNote that this also allows you to reorder the alphabet.\n\nData for letters that are not found in the alphabet are set to zero:\n\nAs the class is a subclass of numpy array, it can be used as such. A is triggered if the objects appearing in a mathematical operation have different alphabets, for example\n\nAs is a subclass of a numpy array, you can apply mathematical operations on an object in much the same way. Here, we illustrate this by calculating a scoring matrix from the alignment of the 16S ribosomal RNA gene sequences of Escherichia coli and Bacillus subtilis. First, we create a object (see Chapter 7) and initialize it with the default scores used by :\n\nNext, we read in the 16S ribosomal RNA gene sequence of Escherichia coli and Bacillus subtilis (provided in and ), and align them to each other:\n\nThe number of alignments generated is very large:\n\nHowever, as they only differ trivially from each other, we arbitrarily choose the first alignment, and count the number of each substitution:\n\nWe normalize against the total number to find the probability of each substitution, and create a symmetric matrix of observed frequencies:\n\nThe background probability is the probability of finding an A, C, G, or T nucleotide in each sequence separately. This can be calculated as the sum of each row or column:\n\nThe number of substitutions expected at random is simply the product of the background distribution with itself:\n\nThe scoring matrix can then be calculated as the logarithm of the odds-ratio of the observed and the expected probabilities:\n\nThe matrix can be used to set the substitution matrix for the pairwise aligner (see Chapter 7):\n\nIn this example, we’ll first read a protein sequence alignment from the Clustalw file protein.aln (also available online here)\n\nSection 6.7.2 contains more information on doing this.\n\nThe property of the alignment stores the number of times different residues substitute for each other:\n\nTo make the example more readable, we’ll select only amino acids with polar charged side chains:\n\nRows and columns for other amino acids were removed from the matrix.\n\nNext, we normalize the matrix and make it symmetric.\n\nSumming over rows or columns gives the relative frequency of occurrence of each residue:\n\nThe expected frequency of residue pairs is then\n\nHere, creates a 2D array consisting of a single column with the values of , and a 2D array with these values as a single row. Taking their dot product (inner product) creates a matrix of expected frequencies where each entry consists of two values multiplied with each other. For example, is equal to .\n\nWe can now calculate the log-odds matrix by dividing the observed frequencies by the expected frequencies and taking the logarithm:\n\nThis matrix can be used as the substitution matrix when performing alignments. For example,\n\nincludes a parser to read one- and two-dimensional objects from file. One-dimensional arrays are represented by a simple two-column format, with the first column containing the key and the second column the corresponding value. For example, the file (obtained from UCSC), available in the subdirectory of the Biopython distribution, contains the size in nucleotides of each chromosome in human genome assembly hg38:\n\nTo parse this file, use\n\nUse to read the values as integers:\n\nFor two-dimensional arrays, we follow the file format of substitution matrices provided by NCBI. For example, the BLOSUM62 matrix, which is the default substitution matrix for NCBI’s protein-protein BLAST [1] program , is stored as follows:\n\nThis file is included in the Biopython distribution under . To parse this file, use\n\nThe header lines starting with are stored in the attribute :\n\nWe can now use this matrix as the substitution matrix on an aligner object:\n\nTo save an Array object, create a string first:\n\nand write the to a file.\n\nBiopython contains a large set of substitution matrices defined in the literature, including BLOSUM (Blocks Substitution Matrix) [19] and PAM (Point Accepted Mutation) matrices [9]. These matrices are available as flat files in the directory, and can be loaded into Python using the function in the submodule. For example, the BLOSUM62 matrix can be loaded by running\n\nThis substitution matrix has an alphabet consisting of the 20 amino acids used in the genetic code, the three ambiguous amino acids B (asparagine or aspartic acid), Z (glutamine or glutamic acid), and X (representing any amino acid), and the stop codon represented by an asterisk:\n\nTo get a full list of available substitution matrices, use without an argument:\n\nNote that the substitution matrix provided by Schneider et al. [40] uses an alphabet consisting of three-nucleotide codons:\n\nSuppose you want to do a global pairwise alignment between the same two hemoglobin sequences from above (HBA_HUMAN, HBB_HUMAN) stored in alpha.faa and beta.faa:\n\nshowing an alignment score of 72.0. To see the individual alignments, do\n\nIn this example, the total number of optimal alignments is huge (more than 4 × 1037), and calling will raise an :\n\nLet’s have a look at the first alignment:\n\nThe alignment object stores the alignment score, as well as the alignment itself:\n\nBetter alignments are usually obtained by penalizing gaps: higher costs for opening a gap and lower costs for extending an existing gap. For amino acid sequences match scores are usually encoded in matrices like PAM or BLOSUM. Thus, a more meaningful alignment for our example can be obtained by using the BLOSUM62 matrix, together with a gap open penalty of 10 and a gap extension penalty of 0.5:\n\nThis alignment has the same score that we obtained earlier with EMBOSS needle using the same sequences and the same parameters.\n\nIn most cases, is used to perform alignments of sequences (strings or objects) consisting of single-letter nucleotides or amino acids. More generally, can also be applied to lists or tuples of arbitrary objects. This section will describe some examples of such generalized pairwise alignments.\n\nSchneider et al. [40] created a substitution matrix for aligning three-nucleotide codons (see below in section 7.9 for more information). This substitution matrix is associated with an alphabet consisting of all three-letter codons:\n\nWe can use this matrix to align codon sequences to each other:\n\nNote that aligning to , as in this example:\n\nwould get a much lower score:\n\npresumably because and both code for leucine, while codes for phenylalanine. The three-letter codon substitution matrix also reveals a preference among codons representing the same amino acid. For example, has a preference for preferred compared to , though all three code for leucine:\n\n7.11.2 Generalized pairwise alignments using match/mismatch scores and an alphabet\n\nUsing the three-letter amino acid symbols, the sequences above translate to\n\nWe can align these sequences directly to each other by using a three-letter amino acid alphabet:\n\nWe use +6/-1 match and mismatch scores as an approximation of the BLOSUM62 matrix, and align these sequences to each other:\n\nInternally, the first step when performing an alignment is to replace the two sequences by integer arrays consisting of the indices of each letter in each sequence in the alphabet associated with the aligner. This step can be bypassed by passing integer arrays directly:\n\nNote that the indices should consist of 32-bit integers, as specified in this example by .\n\nUnknown letters can again be included by defining a wildcard character, and using the corresponding Unicode code point number as the index:\n\nInteger sequences can also be aligned using a substitution matrix, in this case a numpy square array without an alphabet associated with it. In this case, all index values must be non-negative, and smaller than the size of the substitution matrix:\n\nThe class in the module implements a specialized aligner for aligning a nucleotide sequence to the amino acid sequence it encodes. Such alignments are non-trivial if frameshifts occur during translation.\n\nTo align a nucleotide sequence to an amino acid sequence, first create a object:\n\nThe object stores the alignment parameters to be used for the alignments:\n\nThe , , and parameters are defined in the same was as for the class described above (see Section 7.2). The values specified by the , , , and parameters are added to the alignment score whenever a -2, -1, +1, or +2 frame shift, respectively, occurs in the alignment. By default, the frame shift scores are set to -3.0. Similar to the class (Table 7.1), the class defines additional attributes that refer to a number of these values collectively, as shown in Table 7.2.\n\nNow let’s consider two nucleotide sequences and the amino acid sequences they encode:\n\nWhile the two protein sequences both consist of 23 amino acids, the first nucleotide sequence consists of 3 × 23 = 69 nucleotides while the second nucleotide sequence tonsists of only 68 nucleotides:\n\nThis is due to a -1 frame shift event during translation of the second nucleotide sequence. Use to align to , and to , returning an iterator of objects:\n\nWhile is a continuous alignment of the 69 nucleotides to the 23 amino acids, in we find a -1 frame shift after 24 nucleotides. As contains the nucleotide sequence after applying the -1 frame shift, it is one nucleotide longer than and can be translated directly, resulting in the amino acid sequence :\n\nThe alignment score is stored as an attribute on the and iterators, and on the individual alignments and :\n\nwhere the score of the - alignment is equal to the number of aligned amino acids, and the score of the - alignment is 3 less due to the penalty for the frame shift. To calculate the alignment score without calculating the alignment itself, the method can be used:\n\nSuppose we have a third related amino acid sequence and its associated nucleotide sequence:\n\nAs above, we use the to align the nucleotide sequence to the amino acid sequence:\n\nThe three amino acid sequences can be aligned to each other, for example using ClustalW. Here, we create the alignment by hand:\n\nNow we can use the method on the protein alignment, with the nucleotide-to-protein pairwise alignments as the argument, to obtain the corresponding codon alignment:\n\nCalculating the number of nonsynonymous and synonymous substitutions per site\n\nThe most important application of a codon alignment is to estimate the number of nonsynonymous substitutions per site (dN) and synonymous substitutions per site (dS). These can be calculated by the function in . This function takes a pairwise codon alignment and input, as well as the optional arguments specifying the calculation method, (defaulting to the Standard Code), the ratio of the transition and transversion rates, and to specify the equilibrium codon frequency. Biopython currently supports three counting based methods ( , , ) as well as the maximum likelihood method ( ) to estimate dN and dS:\n• : Nei and Gojobori (1986) [33] (default). With this method, you can also specify the ratio of the transition and transversion rates via the argument , defaulting to .\n• : Goldman and Yang (1994) [13]. With this method, you can also specify the equilibrium codon frequency via the argument, with the following options:\n• : count the nucleotide frequency in the provided codon sequences, and use it to calculate the background codon frequency;\n• : (default) count the nucleotide frequency separately for the first, second, and third position in the provided codons, and use it to calculate the background codon frequency;\n• : count the frequency of codons from the provided codon sequences, with a pseudocount of 0.1.\n\nThe method can be applied to a pairwise codon alignment. In general, the different calculation methods will result in slightly different estimates for dN and dS:\n\nFor a multiple alignment of codon sequences, you can calculate a matrix of dN and dS values:\n\nThe objects and returned by are instances of the class in . This function only takes as an optional argument.\n\nFrom these two sequences, you can create a dN tree and a dS tree using :\n\nThe McDonald-Kreitman test assesses the amount of adaptive evolution by comparing the within species synonymous substitutions and nonsynonymous substitutions to the between species synonymous substitutions and nonsynonymous substitutions to see if they are from the same evolutionary process. The test requires gene sequences sampled from different individuals of the same species. In the following example, we will use Adh gene from fruit fly. The data includes 11 individuals from Drosophila melanogaster, 4 individuals from Drosophila simulans, and 12 individuals from Drosophila yakuba. The protein alignment data and the nucleotide sequences are available in the directory as the files and , respectively, in the Biopython distribution. The function in implements the Mcdonald-Kreitman test.\n\nIn addition to the multiple codon alignment, the function takes as input the species to which each sequence in the alignment belongs to. The codon table can be provided as an optional argument .\n\nThis chapter describes the older class and the parsers in that parse the output of sequence alignment software, generating objects. By Multiple Sequence Alignments we mean a collection of multiple sequences which have been aligned together – usually with the insertion of gap characters, and addition of leading or trailing gaps – such that all the sequence strings are the same length. Such an alignment can be regarded as a matrix of letters, where each row is held as a object internally.\n\nWe will introduce the object which holds this kind of data, and the module for reading and writing them as various file formats (following the design of the module from the previous chapter). Note that both and can read and write sequence alignment files. The appropriate choice will depend largely on what you want to do with the data.\n\nThe final part of this chapter is about using common multiple sequence alignment tools like ClustalW and MUSCLE from Python, and parsing the results with Biopython.\n\nWe have two functions for reading in sequence alignments, and which following the convention introduced in are for files containing one or multiple alignments respectively.\n\nUsing will return an iterator which gives objects. Iterators are typically used in a for loop. Examples of situations where you will have multiple different alignments include resampled alignments from the PHYLIP tool , or multiple pairwise alignments from the EMBOSS tools or , or Bill Pearson’s FASTA tools.\n\nHowever, in many situations you will be dealing with files which contain only a single alignment. In this case, you should use the function which returns a single object.\n• The first argument is a to read the data from, typically an open file (see Section 25.1), or a filename.\n• The second argument is a lower case string specifying the alignment format. As in we don’t try and guess the file format for you! See for a full listing of supported formats.\n\nThere is also an optional argument which is discussed in Section 8.1.3 below for dealing with ambiguous file formats which may contain more than one alignment.\n\nAs an example, consider the following annotation rich protein alignment in the PFAM or Stockholm file format:\n\nThis is the seed alignment for the Phage_Coat_Gp8 (PF05371) PFAM entry, downloaded from a now out of date release of PFAM from https://pfam.xfam.org/. We can load this file as follows (assuming it has been saved to disk as “PF05371_seed.sth” in the current working directory):\n\nThis code will print out a summary of the alignment:\n\nYou’ll notice in the above output the sequences have been truncated. We could instead write our own code to format this as we please by iterating over the rows as objects:\n\nYou could also call Python’s built-in function on the alignment object to show it in a particular file format – see Section 8.2.2 for details.\n\nDid you notice in the raw file above that several of the sequences include database cross-references to the PDB and the associated known secondary structure? Try this:\n\nTo have a look at all the sequence annotation, try this:\n\nPFAM provide a nice web interface at http://pfam.xfam.org/family/PF05371 which will actually let you download this alignment in several other formats. This is what the file looks like in the FASTA file format:\n\nNote the website should have an option about showing gaps as periods (dots) or dashes, we’ve shown dashes above. Assuming you download and save this as file “PF05371_seed.faa” then you can load it with almost exactly the same code:\n\nAll that has changed in this code is the filename and the format string. You’ll get the same output as before, the sequences and record identifiers are the same. However, as you should expect, if you check each there is no annotation nor database cross-references because these are not included in the FASTA file format.\n\nNote that rather than using the Sanger website, you could have used to convert the original Stockholm format file into a FASTA file yourself (see below).\n\nWith any supported file format, you can load an alignment in exactly the same way just by changing the format string. For example, use “phylip” for PHYLIP files, “nexus” for NEXUS files or “emboss” for the alignments output by the EMBOSS tools. There is a full listing on the wiki page (http://biopython.org/wiki/AlignIO) and in the built-in documentation (also online):\n\nThe previous section focused on reading files containing a single alignment. In general however, files can contain more than one alignment, and to read these files we must use the function.\n\nSuppose you have a small alignment in PHYLIP format:\n\nIf you wanted to bootstrap a phylogenetic tree using the PHYLIP tools, one of the steps would be to create a set of many resampled alignments using the tool . This would give output something like this, which has been abbreviated for conciseness:\n\nIf you wanted to read this in using you could use:\n\nThis would give the following output, again abbreviated for display:\n\nAs with the function , using returns an iterator. If you want to keep all the alignments in memory at once, which will allow you to access them in any order, then turn the iterator into a list:\n\nMany alignment file formats can explicitly store more than one alignment, and the division between each alignment is clear. However, when a general sequence file format has been used there is no such block structure. The most common such situation is when alignments have been saved in the FASTA file format. For example consider the following:\n\nThis could be a single alignment containing six sequences (with repeated identifiers). Or, judging from the identifiers, this is probably two different alignments each with three sequences, which happen to all have the same length.\n\nWhat about this next example?\n\nAgain, this could be a single alignment with six sequences. However this time based on the identifiers we might guess this is three pairwise alignments which by chance have all got the same lengths.\n\nThis final example is similar:\n\nIn this third example, because of the differing lengths, this cannot be treated as a single alignment containing all six records. However, it could be three pairwise alignments.\n\nClearly trying to store more than one alignment in a FASTA file is not ideal. However, if you are forced to deal with these as input files can cope with the most common situation where all the alignments have the same number of records. One example of this is a collection of pairwise alignments, which can be produced by the EMBOSS tools and – although in this situation, should be able to understand their native output using “emboss” as the format string.\n\nTo interpret these FASTA examples as several separate alignments, we can use with the optional argument which specifies how many sequences are expected in each alignment (in these examples, 3, 2 and 2 respectively). For example, using the third example as the input data:\n\nUsing or without the argument would give a single alignment containing all six records for the first two examples. For the third example, an exception would be raised because the lengths differ preventing them being turned into a single alignment.\n\nIf the file format itself has a block structure allowing to determine the number of sequences in each alignment directly, then the argument is not needed. If it is supplied, and doesn’t agree with the file contents, an error is raised.\n\nNote that this optional argument assumes each alignment in the file has the same number of sequences. Hypothetically you may come across stranger situations, for example a FASTA file containing several alignments each with a different number of sequences – although I would love to hear of a real world example of this. Assuming you cannot get the data in a nicer file format, there is no straight forward way to deal with this using . In this case, you could consider reading in the sequences themselves using and batching them together to create the alignments as appropriate.\n\nWe’ve talked about using and for alignment input (reading files), and now we’ll look at which is for alignment output (writing files). This is a function taking three arguments: some objects (or for backwards compatibility the obsolete objects), a handle or filename to write to, and a sequence format.\n\nHere is an example, where we start by creating a few objects the hard way (by hand, rather than by loading them from a file). Note we create some objects to construct the alignment from.\n\nNow we have a list of objects, we’ll write them to a PHYLIP format file:\n\nAnd if you open this file in your favorite text editor it should look like this:\n\nIts more common to want to load an existing alignment, and save that, perhaps after some simple manipulation like removing certain rows or columns.\n\nSuppose you wanted to know how many alignments the function wrote to the handle? If your alignments were in a list like the example above, you could just use , however you can’t do that when your records come from a generator/iterator. Therefore the function returns the number of alignments written to the file.\n\nNote - If you tell the function to write to a file that already exists, the old file will be overwritten without any warning.\n\nConverting between sequence alignment file formats with works in the same way as converting between sequence file formats with (Section 5.5.2). We load generally the alignment(s) using and then save them using the – or just use the helper function.\n\nFor this example, we’ll load the PFAM/Stockholm format file used earlier and save it as a Clustal W format file:\n\nOr, using and :\n\nThe function expects to be given multiple alignment objects. In the example above we gave it the alignment iterator returned by .\n\nIn this case, we know there is only one alignment in the file so we could have used instead, but notice we have to pass this alignment to as a single element list:\n\nEither way, you should end up with the same new Clustal W format file “PF05371_seed.aln” with the following content:\n\nAlternatively, you could make a PHYLIP format file which we’ll name “PF05371_seed.phy”:\n\nThis time the output looks like this:\n\nOne of the big handicaps of the original PHYLIP alignment file format is that the sequence identifiers are strictly truncated at ten characters. In this example, as you can see the resulting names are still unique - but they are not very readable. As a result, a more relaxed variant of the original PHYLIP format is now quite widely used:\n\nThis time the output looks like this, using a longer indentation to allow all the identifiers to be given in full:\n\nIf you have to work with the original strict PHYLIP format, then you may need to compress the identifiers somehow – or assign your own names or numbering system. This following bit of code manipulates the record identifiers before saving the output:\n\nThis code used a Python dictionary to record a simple mapping from the new sequence system to the original identifier:\n\nHere is the new (strict) PHYLIP format output:\n\nIn general, because of the identifier limitation, working with strict PHYLIP file formats shouldn’t be your first choice. Using the PFAM/Stockholm format on the other hand allows you to record a lot of additional annotation too.\n\n8.2.2 Getting your alignment objects as formatted strings\n\nThe interface is based on handles, which means if you want to get your alignment(s) into a string in a particular file format you need to do a little bit more work (see below). However, you will probably prefer to call Python’s built-in function on the alignment object. This takes an output format specification as a single argument, a lower case string which is supported by as an output format. For example:\n\nWithout an output format specification, returns the same output as .\n\nAs described in Section 4.6, the object has a similar method using output formats supported by .\n\nInternally is calling with a handle. You can do this in your own code if for example you are using an older version of Biopython:\n\nNow that we’ve covered loading and saving alignments, we’ll look at what else you can do with them.\n\nFirst of all, in some senses the alignment objects act like a Python of objects (the rows). With this model in mind hopefully the actions of (the number of rows) and iteration (each row as a ) make sense:\n\nYou can also use the list-like and methods to add more rows to the alignment (as objects). Keeping the list metaphor in mind, simple slicing of the alignment should also make sense - it selects some of the rows giving back another alignment object:\n\nWhat if you wanted to select by column? Those of you who have used the NumPy matrix or array objects won’t be surprised at this - you use a double index.\n\nUsing two integer indices pulls out a single letter, short hand for this:\n\nYou can pull out a single column as a string like this:\n\nYou can also select a range of columns. For example, to pick out those same three rows we extracted earlier, but take just their first six columns:\n\nLeaving the first index as means take all the rows:\n\nThis brings us to a neat way to remove a section. Notice columns 7, 8 and 9 which are gaps in three of the seven sequences:\n\nAgain, you can slice to get everything after the ninth column:\n\nNow, the interesting thing is that addition of alignment objects works by column. This lets you do this as a way to remove a block of columns:\n\nAnother common use of alignment addition would be to combine alignments for several different genes into a meta-alignment. Watch out though - the identifiers need to match up (see Section 4.8 for how adding objects works). You may find it helpful to first sort the alignment rows alphabetically by id:\n\nNote that you can only add two alignments together if they have the same number of rows.\n\nDepending on what you are doing, it can be more useful to turn the alignment object into an array of letters – and you can do this with NumPy:\n\nNote that this leaves the original Biopython alignment object and the NumPy array in memory as separate objects - editing one will not update the other!\n\nThe property of an alignment reports how often letters in the alignment are substituted for each other. This is calculated by taking all pairs of rows in the alignment, counting the number of times two letters are aligned to each other, and summing this over all pairs. For example,\n\nAs the ordering of pairs is arbitrary, counts are divided equally above and below the diagonal. For example, the 9 alignments of to are stored as 4.5 at position and 4.5 at position . This arrangement helps to make the math easier when calculating a substitution matrix from these counts, as described in Section 7.9.\n\nNote that contains entries for the letters appearing in the alignment only. You can use the method to add entries for missing letters, for example\n\nThis also allows you to change the order of letters in the alphabet.\n\nOnce you have an alignment, you are very likely going to want to find out information about it. Instead of trying to have all of the functions that can generate information about an alignment in the alignment object itself, we’ve tried to separate out the functionality into separate classes, which act on the alignment.\n\nGetting ready to calculate summary information about an object is quick to do. Let’s say we’ve got an alignment object called , for example read in using as described in Chapter 8. All we need to do to get an object that will calculate summary information is:\n\nThe object is very useful, and will do the following neat things for you:\n• Get a position specific score matrix for the alignment – see section 8.3.6\n• Calculate the information content for the alignment – see section 8.3.7\n• Generate information on substitutions in the alignment – section 7.9 details using this to generate a substitution matrix.\n\nThe object, described in section 8.3.4, provides functionality to calculate a quick consensus of an alignment. Assuming we’ve got a object called we can calculate a consensus by doing:\n\nAs the name suggests, this is a really simple consensus calculator, and will just add up all of the residues at each point in the consensus, and if the most common value is higher than some threshold value will add the common residue to the consensus. If it doesn’t reach the threshold, it adds an ambiguity character to the consensus. The returned consensus object is a object.\n\nYou can adjust how works by passing optional parameters:\n\nAlternatively, you can convert the multiple sequence alignment object to a new-style object (see section 6.1) by using the attribute (see section 8.4):\n\nYou can then create a object (see section 17.1):\n\nThe method (see section 17.1.2) lets you specify in detail how the consensus sequence should be calculated. For example,\n\nPosition specific score matrices (PSSMs) summarize the alignment information in a different way than a consensus, and may be useful for different tasks. Basically, a PSSM is a count matrix. For each column in the alignment, the number of each alphabet letters is counted and totaled. The totals are displayed relative to some representative sequence along the left axis. This sequence may be the consensus sequence, but can also be any sequence in the alignment.\n\nFor instance for the alignment above:\n\nwe get a PSSM with the consensus sequence along the side using\n\nwhere we ignore any ambiguity residues when calculating the PSSM.\n\nTwo notes should be made about this:\n• To maintain strictness with the alphabets, you can only include characters along the top of the PSSM that are in the alphabet of the alignment object. Gaps are not included along the top axis of the PSSM.\n• The sequence passed to be displayed along the left side of the axis does not need to be the consensus. For instance, if you wanted to display the second sequence in the alignment along this axis, you would need to do:\n\nThe command above returns a object. You can access any element of the PSSM by subscripting like . For instance, to get the counts for the ’A’ residue in the second element of the above PSSM you would do:\n\nThe structure of the PSSM class hopefully makes it easy both to access elements and to pretty print the matrix.\n\nAlternatively, you can convert the multiple sequence alignment object to a new-style object (see section 6.1) by using the attribute (see section 8.4):\n\nYou can then create a object (see section 17.1):\n\nand obtain the counts of each nucleotide in each position:\n\nA potentially useful measure of evolutionary conservation is the information content of a sequence.\n\nA useful introduction to information theory targeted towards molecular biologists can be found at http://www.lecb.ncifcrf.gov/~toms/paper/primer/. For our purposes, we will be looking at the information content of a consensus sequence, or a portion of a consensus sequence. We calculate information content at a particular column in a multiple sequence alignment using the following formula:\n• – The information content for the -th column in an alignment.\n• – The number of letters in the alphabet.\n• – The frequency of a particular letter in the -th column (i. e. if G occurred 3 out of 6 times in an alignment column, this would be 0.5)\n• – The expected frequency of a letter . This is an optional argument, usage of which is left at the user’s discretion. By default, it is automatically assigned to 0.05 = 1/20 for a protein alphabet, and 0.25 = 1/4 for a nucleic acid alphabet. This is for getting the information content without any assumption of prior distributions. When assuming priors, or when using a non-standard alphabet, you should supply the values for .\n\nWell, now that we have an idea what information content is being calculated in Biopython, let’s look at how to get it for a particular region of the alignment.\n\nFirst, we need to use our alignment to get an alignment summary object, which we’ll assume is called (see section 8.3.4) for instructions on how to get this. Once we’ve got this object, calculating the information content for a region is as easy as:\n\nNow, will contain the relative information content over the region [2:6] in relation to the expected frequencies.\n\nThe value return is calculated using base 2 as the logarithm base in the formula above. You can modify this by passing the parameter as the base you want:\n\nBy default nucleotide or amino acid residues with a frequency of 0 in a column are not take into account when the relative information column for that column is computed. If this is not the desired result, you can use instead.\n\nIn this case, the observed frequency P of a particular letter i in the j-th column is computed as follows:\n• – the pseudo count you pass as argument.\n• – the pseudo count you pass as argument.\n• – The expected frequency of the letter as described above.\n\nWell, now you are ready to calculate information content. If you want to try applying this to some real life problems, it would probably be best to dig into the literature on information content to get an idea of how it is used. Hopefully your digging won’t reveal any mistakes made in coding this function!\n\nUse the property to create a new-style object (see section 6.1) from an old-style object:\n\nNote that the property creates and returns a new object that is consistent with the information stored in the object at the time the object is created. Any changes to the after calling the property will not propagate to the object. However, you can of course call the property again to create a new object consistent with the updated object.\n\nYou can create your own substitution matrix from an alignment. In this example, we’ll first read a protein sequence alignment from the Clustalw file protein.aln (also available online here)\n\nSection 8.6.1 contains more information on doing this.\n\nThe property of the alignment stores the number of times different residues substitute for each other:\n\nTo make the example more readable, we’ll select only amino acids with polar charged side chains:\n\nRows and columns for other amino acids were removed from the matrix.\n\nNext, we normalize the matrix:\n\nSumming over rows or columns gives the relative frequency of occurrence of each residue:\n\nThe expected frequency of residue pairs is then\n\nHere, creates a 2D array consisting of a single column with the values of , and a 2D array with these values as a single row. Taking their dot product (inner product) creates a matrix of expected frequencies where each entry consists of two values multiplied with each other. For example, is equal to .\n\nWe can now calculate the log-odds matrix by dividing the observed frequencies by the expected frequencies and taking the logarithm:\n\nThis matrix can be used as the substitution matrix when performing alignments. For example,\n\nThere are lots of algorithms out there for aligning sequences, both pairwise alignments and multiple sequence alignments. These calculations are relatively slow, and you generally wouldn’t want to write such an algorithm in Python. For pairwise alignments, you can use Biopython’s (see Chapter 7), which is implemented in C and therefore fast. Alternatively, you can run an external alignment program by invoking it from Python. Normally you would:\n• Prepare an input file of your unaligned sequences, typically this will be a FASTA file which you might create using (see Chapter 5).\n• Run the alignment program by running its command using Python’s module.\n• Read the output from the tool, i.e. your aligned sequences, typically using (see earlier in this chapter).\n\nHere, we will show a few examples of this workflow.\n\nClustalW is a popular command line tool for multiple sequence alignment (there is also a graphical interface called ClustalX). Before trying to use ClustalW from within Python, you should first try running the ClustalW tool yourself by hand at the command line, to familiarize yourself the other options.\n\nFor the most basic usage, all you need is to have a FASTA input file, such as opuntia.fasta (available online or in the Doc/examples subdirectory of the Biopython source code). This is a small FASTA file containing seven prickly-pear DNA sequences (from the cactus family Opuntia). By default ClustalW will generate an alignment and guide tree file with names based on the input FASTA file, in this case opuntia.aln and opuntia.dnd, but you can override this or make it explicit:\n\nNotice here we have given the executable name as clustalw2, indicating we have version two installed, which has a different filename to version one (clustalw, the default). Fortunately both versions support the same set of arguments at the command line (and indeed, should be functionally identical).\n\nYou may find that even though you have ClustalW installed, the above command doesn’t work – you may get a message about “command not found” (especially on Windows). This indicated that the ClustalW executable is not on your PATH (an environment variable, a list of directories to be searched). You can either update your PATH setting to include the location of your copy of ClustalW tools (how you do this will depend on your OS), or simply type in the full path of the tool. Remember, in Python strings and are by default interpreted as a new line and a tab – which is why we’re put a letter “r” at the start for a raw string that isn’t translated in this way. This is generally good practice when specifying a Windows style file name.\n\nNow, at this point it helps to know about how command line tools “work”. When you run a tool at the command line, it will often print text output directly to screen. This text can be captured or redirected, via two “pipes”, called standard output (the normal results) and standard error (for error messages and debug messages). There is also standard input, which is any text fed into the tool. These names get shortened to stdin, stdout and stderr. When the tool finishes, it has a return code (an integer), which by convention is zero for success, while a non-zero return code indicates that an error has occurred.\n\nIn the example of ClustalW above, when run at the command line all the important output is written directly to the output files. Everything normally printed to screen while you wait is captured in and , while the return code is stored in .\n\nWhat we care about are the two output files, the alignment and the guide tree. We didn’t tell ClustalW what filenames to use, but it defaults to picking names based on the input file. In this case the output should be in the file . You should be able to work out how to read in the alignment using by now:\n\nIn case you are interested (and this is an aside from the main thrust of this chapter), the opuntia.dnd file ClustalW creates is just a standard Newick tree file, and can parse these:\n\nChapter 16 covers Biopython’s support for phylogenetic trees in more depth.\n\nMUSCLE is a more recent multiple sequence alignment tool than ClustalW. As before, we recommend you try using MUSCLE from the command line before trying to run it from Python.\n\nFor the most basic usage, all you need is to have a FASTA input file, such as opuntia.fasta (available online or in the Doc/examples subdirectory of the Biopython source code). You can then tell MUSCLE to read in this FASTA file, and write the alignment to an output file named :\n\nMUSCLE will output the alignment as a FASTA file (using gapped sequences). The module is able to read this alignment using format=\"fasta\":\n\nYou can also set the other optional parameters; see MUSCLE’s built-in help for details.\n\nThe EMBOSS suite includes the water and needle tools for Smith-Waterman algorithm local alignment, and Needleman-Wunsch global alignment. The tools share the same style interface, so switching between the two is trivial – we’ll just use needle here.\n\nSuppose you want to do a global pairwise alignment between two sequences, prepared in FASTA format as follows:\n\nin a file alpha.faa, and secondly in a file beta.faa:\n\nYou can find copies of these example files with the Biopython source code under the directory.\n\nThe command to align these two sequences against each other using needle is as follows:\n\nWhy not try running this by hand at the command prompt? You should see it does a pairwise comparison and records the output in the file needle.txt (in the default EMBOSS alignment file format).\n\nEven if you have EMBOSS installed, running this command may not work – you might get a message about “command not found” (especially on Windows). This probably means that the EMBOSS tools are not on your PATH environment variable. You can either update your PATH setting, or simply use the full path to the tool, for example:\n\nNext we want to use Python to run this command for us. As explained above, for full control, we recommend you use Python’s built-in subprocess module:\n\nNext we can load the output file with as discussed earlier in this chapter, as the emboss format:\n\nIn this example, we told EMBOSS to write the output to a file, but you can tell it to write the output to stdout instead (useful if you don’t want a temporary output file to get rid of – use outfile=stdout argument):\n\nSimilarly, it is possible to read one of the inputs from stdin (e.g. asequence=\"stdin\").\n\nThis has only scratched the surface of what you can do with needle and water. One useful trick is that the second file can contain multiple sequences (say five), and then EMBOSS will do five pairwise alignments.\n\nPlease note that Bio.pairwise2 was deprecated in Release 1.80. As an alternative, please consider using (described in Chapter 7).\n\ncontains essentially the same algorithms as water (local) and needle (global) from the EMBOSS suite (see above) and should return the same results. The module has undergone some optimization regarding speed and memory consumption recently (Biopython versions >1.67) so that for short sequences (global alignments: ~2000 residues, local alignments ~600 residues) it’s faster (or equally fast) to use than calling EMBOSS’ water or needle via the command line tools.\n\nSuppose you want to do a global pairwise alignment between the same two hemoglobin sequences from above (HBA_HUMAN, HBB_HUMAN) stored in alpha.faa and beta.faa:\n\nAs you see, we call the alignment function with . The tricky part are the last two letters of the function name (here: xx), which are used for decoding the scores and penalties for matches (and mismatches) and gaps. The first letter decodes the match score, e.g. x means that a match counts 1 while mismatches have no costs. With m general values for either matches or mismatches can be defined (for more options see Biopython’s API). The second letter decodes the cost for gaps; x means no gap costs at all, with s different penalties for opening and extending a gap can be assigned. So, means that only matches between both sequences are counted.\n\nOur variable alignments now contains a list of alignments (at least one) which have the same optimal score for the given conditions. In our example this are 80 different alignments with the score 72 ( will return up to 1000 alignments). Have a look at one of these alignments:\n\nEach alignment is a named tuple consisting of the two aligned sequences, the score, the start and the end positions of the alignment (in global alignments the start is always 0 and the end the length of the alignment). has a function for a nicer printout:\n\nSince Biopython 1.77 the required parameters can be supplied with keywords. The last example can now also be written as:\n\nBetter alignments are usually obtained by penalizing gaps: higher costs for opening a gap and lower costs for extending an existing gap. For amino acid sequences match scores are usually encoded in matrices like PAM or BLOSUM. Thus, a more meaningful alignment for our example can be obtained by using the BLOSUM62 matrix, together with a gap open penalty of 10 and a gap extension penalty of 0.5 (using ):\n\nThis alignment has the same score that we obtained earlier with EMBOSS needle using the same sequences and the same parameters.\n\nLocal alignments are called similarly with the function , where again XX stands for a two letter code for the match and gap functions:\n\nIn recent Biopython versions, will only print the aligned part of a local alignment (together with the start positions in 1-based notation, as shown in the above example). If you are also interested in the non- aligned parts of the sequences, use the keyword-parameter :\n\nNote that local alignments must, as defined by Smith & Waterman, have a positive score (>0). Thus, may return no alignments if no score >0 has been obtained. Also, will not report alignments which are the result of the addition of zero-scoring extensions on either site. In the next example, the pairs serine/aspartic acid (S/D) and lysine/asparagine (K/N) both have a match score of 0. As you see, the aligned part has not been extended:\n\nInstead of supplying a complete match/mismatch matrix, the match code m allows for easy defining general match/mismatch values. The next example uses match/mismatch scores of 5/-4 and gap penalties (open/extend) of 2/0.5 using :\n\nOne useful keyword argument of the functions is score_only. When set to True it will only return the score of the best alignment(s), but in a significantly shorter time. It will also allow the alignment of longer sequences before a memory error is raised. Another useful keyword argument is one_alignment_only=True which will also result in some speed gain.\n\nUnfortunately, does not work with Biopython’s multiple sequence alignment objects (yet). However, the module has some interesting advanced features: you can define your own match and gap functions (interested in testing affine logarithmic gap costs?), gap penalties and end gaps penalties can be different for both sequences, sequences can be supplied as lists (useful if you have residues that are encoded by more than one character), etc. These features are hard (if at all) to realize with other alignment tools. For more details see the modules documentation in Biopython’s API.\n\nHey, everybody loves BLAST right? I mean, geez, how can it get any easier to do comparisons between one of your sequences and every other sequence in the known world? But, of course, this section isn’t about how cool BLAST is, since we already know that. It is about the problem with BLAST – it can be really difficult to deal with the volume of data generated by large runs, and to automate BLAST runs in general.\n\nFortunately, the Biopython folks know this only too well, so they’ve developed lots of tools for dealing with BLAST and making things much easier. This section details how to use these tools and do useful things with them.\n\nDealing with BLAST can be split up into two steps, both of which can be done from within Biopython. Firstly, running BLAST for your query sequence(s), and getting some output. Secondly, parsing the BLAST output in Python for further analysis.\n\nYour first introduction to running BLAST was probably via the NCBI web-service. In fact, there are lots of ways you can run BLAST, which can be categorized in several ways. The most important distinction is running BLAST locally (on your own machine), and running BLAST remotely (on another machine, typically the NCBI servers). We’re going to start this chapter by invoking the NCBI online BLAST service from within a Python script.\n\nNOTE: The following Chapter 11 describes . We intend this to ultimately replace the older module, as it provides a more general framework handling other related sequence searching tools as well. However, for now you can use either that or the older module for dealing with NCBI BLAST.\n\nWe use the function in the module to call the online version of BLAST. This has three non-optional arguments:\n• The first argument is the blast program to use for the search, as a lower case string. The options and descriptions of the programs are available at . Currently only works with blastn, blastp, blastx, tblast and tblastx.\n• The second argument specifies the databases to search against. Again, the options for this are available on the NCBI Guide to BLAST .\n• The third argument is a string containing your query sequence. This can either be the sequence itself, the sequence in fasta format, or an identifier like a GI number.\n• Do not contact the server more often than once every 10 seconds.\n• Do not poll for any single RID more often than once a minute.\n• Use the URL parameter email and tool, so that the NCBI can contact you if there is a problem.\n• Run scripts weekends or between 9 pm and 5 am Eastern time on weekdays if more than 50 searches will be submitted.\n\nTo fulfill the third point, one can set the variable.\n\nThe function also takes a number of other option arguments, which are basically analogous to the different parameters you can set on the BLAST web page. We’ll just highlight a few of them here:\n• The argument sets the base URL for running BLAST over the internet. By default it connects to the NCBI, but one can use this to connect to an instance of NCBI BLAST running in the cloud. Please refer to the documentation for the function for further details.\n• The function can return the BLAST results in various formats, which you can choose with the optional keyword: , , , or . The default is , as that is the format expected by the parser, described in section 10.3 below.\n• The argument sets the expectation or e-value threshold.\n\nFor more about the optional BLAST arguments, we refer you to the NCBI’s own documentation, or that built into Biopython:\n\nNote that the default settings on the NCBI BLAST website are not quite the same as the defaults on QBLAST. If you get different results, you’ll need to check the parameters (e.g., the expectation value threshold and the gap values).\n\nFor example, if you have a nucleotide sequence you want to search against the nucleotide database (nt) using BLASTN, and you know the GI number of your query sequence, you can use:\n\nAlternatively, if we have our query sequence already in a FASTA formatted file, we just need to open the file and read in this record as a string, and use that as the query argument:\n\nWe could also have read in the FASTA file as a and then supplied just the sequence itself:\n\nSupplying just the sequence means that BLAST will assign an identifier for your sequence automatically. You might prefer to use the object’s format method to make a FASTA string (which will include the existing identifier):\n\nThis approach makes more sense if you have your sequence(s) in a non-FASTA file format which you can extract using (see Chapter 5).\n\nWhatever arguments you give the function, you should get back your results in a handle object (by default in XML format). The next step would be to parse the XML output into Python objects representing the search results (Section 10.3), but you might want to save a local copy of the output file first. I find this especially useful when debugging my code that extracts info from the BLAST results (because re-running the online search is slow and wastes the NCBI computer time).\n\nWe need to be a bit careful since we can use to read the BLAST output only once – calling again returns an empty string.\n\nAfter doing this, the results are in the file and the original handle has had all its data extracted (so we closed it). However, the function of the BLAST parser (described in 10.3) takes a file-handle-like object, so we can just open the saved file for input:\n\nNow that we’ve got the BLAST results back into a handle again, we are ready to do something with them, so this leads us right into the parsing section (see Section 10.3 below). You may want to jump ahead to that now ….\n\nRunning BLAST locally (as opposed to over the internet, see Section 10.1) has at least major two advantages:\n• Local BLAST may be faster than BLAST over the internet;\n• Local BLAST allows you to make your own database to search for sequences against.\n\nDealing with proprietary or unpublished sequence data can be another reason to run BLAST locally. You may not be allowed to redistribute the sequences, so submitting them to the NCBI as a BLAST query would not be an option.\n\nUnfortunately, there are some major drawbacks too – installing all the bits and getting it setup right takes some effort:\n• Local BLAST requires (large) BLAST databases to be setup (and potentially kept up to date).\n\nTo further confuse matters there are several different BLAST packages available, and there are also other tools which can produce imitation BLAST output files, such as BLAT.\n\nThe “new” NCBI BLAST+ suite was released in 2009. This replaces the old NCBI “legacy” BLAST package (see below).\n\nThis section will show briefly how to use these tools from within Python. If you have already read or tried the alignment tool examples in Section 8.6 this should all seem quite straightforward. First, we construct a command line string (as you would type in at the command line prompt if running standalone BLAST by hand). Then we can execute this command from within Python.\n\nFor example, taking a FASTA file of gene nucleotide sequences, you might want to run a BLASTX (translation) search against the non-redundant (NR) protein database. Assuming you (or your systems administrator) has downloaded and installed the NR database, you might run:\n\nThis should run BLASTX against the NR database, using an expectation cut-off value of 0.001 and produce XML output to the specified file (which we can then parse). On my computer this takes about six minutes - a good reason to save the output to a file so you can repeat any analysis as needed.\n\nFrom within python we can use the module to build the command line string, and run it:\n\nIn this example there shouldn’t be any output from BLASTX to the terminal. You may want to check the output file has been created.\n\nAs you may recall from earlier examples in the tutorial, the contains seven sequences, so the BLAST XML output should contain multiple results. Therefore use to parse it as described below in Section 10.3.\n\nNCBI BLAST+ (written in C++) was first released in 2009 as a replacement for the original NCBI “legacy” BLAST (written in C) which is no longer being updated. There were a lot of changes – the old version had a single core command line tool which covered multiple different BLAST search types (which are now separate commands in BLAST+), and all the command line options were renamed. Biopython’s wrappers for the NCBI “legacy” BLAST tools have been deprecated and will be removed in a future release. To try to avoid confusion, we do not cover calling these old tools from Biopython in this tutorial.\n\nYou may also come across Washington University BLAST (WU-BLAST), and its successor, Advanced Biocomputing BLAST (AB-BLAST, released in 2009, not free/open source). These packages include the command line tools and , which mimicked from the NCBI “legacy” BLAST suite. Biopython does not currently provide wrappers for calling these tools, but should be able to parse any NCBI compatible output from them.\n\nAs mentioned above, BLAST can generate output in various formats, such as XML, HTML, and plain text. Originally, Biopython had parsers for BLAST plain text and HTML output, as these were the only output formats offered at the time. Unfortunately, the BLAST output in these formats kept changing, each time breaking the Biopython parsers. Our HTML BLAST parser has been removed, while the deprecated plain text BLAST parser is now only available via . Use it at your own risk, it may or may not work, depending on which BLAST version you’re using.\n\nAs keeping up with changes in BLAST became a hopeless endeavor, especially with users running different BLAST versions, we now recommend to parse the output in XML format, which can be generated by recent versions of BLAST. Not only is the XML output more stable than the plain text and HTML output, it is also much easier to parse automatically, making Biopython a whole lot more stable.\n\nYou can get BLAST output in XML format in various ways. For the parser, it doesn’t matter how the output was generated, as long as it is in the XML format.\n• You can use Biopython to run BLAST over the internet, as described in section 10.1.\n• You can use Biopython to run BLAST locally, as described in section 10.2.\n• You can do the BLAST search yourself on the NCBI site through your web browser, and then save the results. You need to choose XML as the format in which to receive the results, and save the final BLAST page you get (you know, the one with all of the interesting results!) to a file.\n• You can also run BLAST locally without using Biopython, and save the output in a file. Again, you need to choose XML as the format in which to receive the results.\n\nThe important point is that you do not have to use Biopython scripts to fetch the data in order to be able to parse it. Doing things in one of these ways, you then need to get a handle to the results. In Python, a handle is just a nice general way of describing input to any info source so that the info can be retrieved using and functions (see Section 25.1).\n\nIf you followed the code above for interacting with BLAST through a script, then you already have , the handle to the BLAST results. For example, using a GI number to do an online search:\n\nIf instead you ran BLAST some other way, and have the BLAST output (in XML format) in the file , all you need to do is to open the file for reading:\n\nNow that we’ve got a handle, we are ready to parse the output. The code to parse it is really quite small. If you expect a single BLAST result (i.e., you used a single query):\n\nor, if you have lots of results (i.e., multiple query sequences):\n\nJust like and (see Chapters 5 and 6), we have a pair of input functions, and , where is for when you have exactly one object, and is an iterator for when you can have lots of objects – but instead of getting or objects, we get BLAST record objects.\n\nTo be able to handle the situation where the BLAST file may be huge, containing thousands of results, returns an iterator. In plain English, an iterator allows you to step through the BLAST output, retrieving BLAST records one by one for each BLAST search result:\n\nOr, you can use a -loop:\n\nNote though that you can step through the BLAST records only once. Usually, from each BLAST record you would save the information that you are interested in. If you want to save all returned BLAST records, you can convert the iterator into a list:\n\nNow you can access each BLAST record in the list with an index as usual. If your BLAST file is huge though, you may run into memory problems trying to save them all in a list.\n\nUsually, you’ll be running one BLAST search at a time. Then, all you need to do is to pick up the first (and only) BLAST record in :\n\nI guess by now you’re wondering what is in a BLAST record.\n\nA BLAST Record contains everything you might ever want to extract from the BLAST output. Right now we’ll just show an example of how to get some info out of the BLAST report, but if you want something in particular that is not described here, look at the info on the record class in detail, and take a gander into the code or automatically generated documentation – the docstrings have lots of good info about what is stored in each piece of information.\n\nTo continue with our example, let’s just print out some summary info about all hits in our blast report greater than a particular threshold. The following code does this:\n\nThis will print out summary reports like the following:\n\nBasically, you can do anything you want to with the info in the BLAST report once you have parsed it. This will, of course, depend on what you want to use it for, but hopefully this helps you get started on doing what you need to do!\n\nAn important consideration for extracting information from a BLAST report is the type of objects that the information is stored in. In Biopython, the parsers return objects, either or depending on what you are parsing. These objects are defined in and are quite complete.\n\nHere is my attempt at a UML class diagram for the record class:\n\nThe PSIBlast record object is similar, but has support for the rounds that are used in the iteration steps of PSIBlast:\n\nIf you are good at UML and see mistakes/improvements that can be made, please let me know.\n\nYou can run the standalone version of PSI-BLAST (the legacy NCBI command line tool , or its replacement ) directly from the command line or using python’s module.\n\nAt the time of writing, the NCBI do not appear to support tools running a PSI-BLAST search via the internet.\n\nNote that the parser can read the XML output from current versions of PSI-BLAST, but information like which sequences in each iteration is new or reused isn’t present in the XML file.\n\nYou can run the standalone version of RPS-BLAST (either the legacy NCBI command line tool , or its replacement with the same name) directly from the command line or using python’s module.\n\nAt the time of writing, the NCBI do not appear to support tools running an RPS-BLAST search via the internet.\n\nYou can use the parser to read the XML output from current versions of RPS-BLAST.\n\nBiological sequence identification is an integral part of bioinformatics. Several tools are available for this, each with their own algorithms and approaches, such as BLAST (arguably the most popular), FASTA, HMMER, and many more. In general, these tools usually use your sequence to search a database of potential matches. With the growing number of known sequences (hence the growing number of potential matches), interpreting the results becomes increasingly hard as there could be hundreds or even thousands of potential matches. Naturally, manual interpretation of these searches’ results is out of the question. Moreover, you often need to work with several sequence search tools, each with its own statistics, conventions, and output format. Imagine how daunting it would be when you need to work with multiple sequences using multiple search tools.\n\nWe know this too well ourselves, which is why we created the submodule in Biopython. allows you to extract information from your search results in a convenient way, while also dealing with the different standards and conventions used by different search tools. The name is a homage to BioPerl’s module of the same name.\n\nIn this chapter, we’ll go through the main features of to show what it can do for you. We’ll use two popular search tools along the way: BLAST and BLAT. They are used merely for illustrative purposes, and you should be able to adapt the workflow to any other search tools supported by in a breeze. You’re very welcome to follow along with the search output files we’ll be using. The BLAST output file can be downloaded here, and the BLAT output file here or are included with the Biopython source code under the folder. Both output files were generated using this sequence:\n\nThe BLAST result is an XML file generated using against the NCBI database. For BLAT, the sequence database was the February 2009 human genome draft and the output format is PSL.\n\nWe’ll start from an introduction to the object model. The model is the representation of your search results, thus it is core to itself. After that, we’ll check out the main functions in that you may often use.\n\nNow that we’re all set, let’s go to the first step: introducing the core object model.\n\nDespite the wildly differing output styles among many sequence search tools, it turns out that their underlying concept is similar:\n• The output file may contain results from one or more search queries.\n• In each search query, you will see one or more hits from the given search database.\n• In each database hit, you will see one or more regions containing the actual sequence alignment between your query sequence and the database sequence.\n• Some programs like BLAT or Exonerate may further split these regions into several alignment fragments (or blocks in BLAT and possibly exons in exonerate). This is not something you always see, as programs like BLAST and HMMER do not do this.\n\nRealizing this generality, we decided use it as base for creating the object model. The object model consists of a nested hierarchy of Python objects, each one representing one concept outlined above. These objects are:\n• , to represent a single database hit. objects are contained within and in each there is zero or more objects.\n• (short for high-scoring pair), to represent region(s) of significant alignments between query and hit sequences. objects are contained within objects and each has one or more objects.\n• , to represent a single contiguous alignment between query and hit sequences. objects are contained within objects. Most sequence search tools like BLAST and HMMER unify and objects as each will only have a single . However there are tools like BLAT and Exonerate that produce containing multiple . Don’t worry if this seems a tad confusing now, we’ll elaborate more on these two objects later on.\n\nThese four objects are the ones you will interact with when you use . They are created using one of the main methods: , , , or . The details of these methods are provided in later sections. For this section, we’ll only be using read and parse. These functions behave similarly to their and counterparts:\n• is used for search output files with a single query and returns a object\n• is used for search output files with multiple queries and returns a generator that yields objects\n\nWith that settled, let’s start probing each object, beginning with .\n\nThe QueryResult object represents a single search query and contains zero or more Hit objects. Let’s see what it looks like using the BLAST file we have:\n\nWe’ve just begun to scratch the surface of the object model, but you can see that there’s already some useful information. By invoking on the object, you can see:\n• The program name and version (blastn version 2.2.27+)\n• The query ID, description, and its sequence length (ID is 42291, description is ‘mystery_seq’, and it is 61 nucleotides long)\n• The target database to search against (refseq_rna)\n• A quick overview of the resulting hits. For our query sequence, there are 100 potential hits (numbered 0–99 in the table). For each hit, we can also see how many HSPs it contains, its ID, and a snippet of its description. Notice here that truncates the hit table overview, by showing only hits numbered 0–29, and then 97–99.\n\nNow let’s check our BLAT results using the same procedure as above:\n\nYou’ll immediately notice that there are some differences. Some of these are caused by the way PSL format stores its details, as you’ll see. The rest are caused by the genuine program and target database differences between our BLAST and BLAT searches:\n• The program name and version. knows that the program is BLAT, but in the output file there is no information regarding the program version so it defaults to ‘<unknown version>’.\n• The query ID, description, and its sequence length. Notice here that these details are slightly different from the ones we saw in BLAST. The ID is ‘mystery_seq’ instead of 42991, there is no known description, but the query length is still 61. This is actually a difference introduced by the file formats themselves. BLAST sometimes creates its own query IDs and uses your original ID as the sequence description.\n• The target database is not known, as it is not stated in the BLAT output file.\n• And finally, the list of hits we have is completely different. Here, we see that our query sequence only hits the ‘chr19’ database entry, but in it we see 17 HSP regions. This should not be surprising however, given that we are using a different program, each with its own target database.\n\nAll the details you saw when invoking the method can be accessed individually using Python’s object attribute access notation (a.k.a. the dot notation). There are also other format-specific attributes that you can access using the same method.\n\nFor a complete list of accessible attributes, you can check each format-specific documentation. Here are the ones for BLAST and for BLAT.\n\nHaving looked at using on objects, let’s drill down deeper. What exactly is a ? In terms of Python objects, is a hybrid between a list and a dictionary. In other words, it is a container object with all the convenient features of lists and dictionaries.\n\nLike Python lists and dictionaries, objects are iterable. Each iteration returns a object:\n\nTo check how many items (hits) a has, you can simply invoke Python’s method:\n\nLike Python lists, you can retrieve items (hits) from a using the slice notation:\n\nTo retrieve multiple hits, you can slice objects using the slice notation as well. In this case, the slice will return a new object containing only the sliced hits:\n\nLike Python dictionaries, you can also retrieve hits using the hit’s ID. This is particularly useful if you know a given hit ID exists within a search query results:\n\nYou can also get a full list of objects using and a full list of IDs using :\n\nWhat if you just want to check whether a particular hit is present in the query results? You can do a simple Python membership test using the keyword:\n\nSometimes, knowing whether a hit is present is not enough; you also want to know the rank of the hit. Here, the method comes to the rescue:\n\nRemember that we’re using Python’s indexing style here, which is zero-based. This means our hit above is ranked at no. 23, not 22.\n\nAlso, note that the hit rank you see here is based on the native hit ordering present in the original search output file. Different search tools may order these hits based on different criteria.\n\nIf the native hit ordering doesn’t suit your taste, you can use the method of the object. It is very similar to Python’s method, with the addition of an option to create a new sorted object or not.\n\nHere is an example of using to sort the hits based on each hit’s full sequence length. For this particular sort, we’ll set the flag to so that sorting will return a new object and leave our initial object unsorted. We’ll also set the flag to so that we sort in descending order.\n\nThe advantage of having the flag here is that we’re preserving the native ordering, so we may use it again later. You should note that this is not the default behavior of , however, which is why we needed to set the flag to explicitly.\n\nAt this point, you’ve known enough about objects to make it work for you. But before we go on to the next object in the model, let’s take a look at two more sets of methods that could make it even easier to work with objects: the and methods.\n\nIf you’re familiar with Python’s list comprehensions, generator expressions or the built in and functions, you’ll know how useful they are for working with list-like objects (if you’re not, check them out!). You can use these built in methods to manipulate objects, but you’ll end up with regular Python lists and lose the ability to do more interesting manipulations.\n\nThat’s why, objects provide its own flavor of and methods. Analogous to , there are and methods. As their name implies, these methods filter its object either on its objects or objects. Similarly, analogous to , objects also provide the and methods. These methods apply a given function to all hits or HSPs in a object, respectively.\n\nLet’s see these methods in action, beginning with . This method accepts a callback function that checks whether a given object passes the condition you set or not. In other words, the function must accept as its argument a single object and returns or .\n\nHere is an example of using to filter out objects that only have one HSP:\n\nworks the same as , only instead of looking at the objects, it performs filtering on the objects in each hits.\n\nAs for the methods, they too accept a callback function as their arguments. However, instead of returning or , the callback function must return the modified or object (depending on whether you’re using or ).\n\nLet’s see an example where we’re using to rename the hit IDs:\n\nAgain, works the same as , but on objects instead of objects.\n\nobjects represent all query results from a single database entry. They are the second-level container in the object hierarchy. You’ve seen that they are contained by objects, but they themselves contain objects.\n\nLet’s see what they look like, beginning with our BLAST search:\n\nYou see that we’ve got the essentials covered here:\n• The query ID and description is present. A hit is always tied to a query, so we want to keep track of the originating query as well. These values can be accessed from a hit using the and attributes.\n• We also have the unique hit ID, description, and full sequence lengths. They can be accessed using , , and , respectively.\n• Finally, there’s a table containing quick information about the HSPs this hit contains. In each row, we’ve got the important HSP details listed: the HSP index, its e-value, its bit score, its span (the alignment length including gaps), its query coordinates, and its hit coordinates.\n\nNow let’s contrast this with the BLAT search. Remember that in the BLAT search we had one hit with 17 HSPs.\n\nHere, we’ve got a similar level of detail as with the BLAST hit we saw earlier. There are some differences worth explaining, though:\n• The e-value and bit score column values. As BLAT HSPs do not have e-values and bit scores, the display defaults to ‘?’.\n• What about the span column? The span values is meant to display the complete alignment length, which consists of all residues and any gaps that may be present. The PSL format do not have this information readily available and does not attempt to try guess what it is, so we get a ‘?’ similar to the e-value and bit score columns.\n\nIn terms of Python objects, behaves almost the same as Python lists, but contain objects exclusively. If you’re familiar with lists, you should encounter no difficulties working with the object.\n\nJust like Python lists, objects are iterable, and each iteration returns one object it contains:\n\nYou can invoke on a to see how many objects it has:\n\nYou can use the slice notation on objects, whether to retrieve single or multiple objects. Like , if you slice for multiple , a new object will be returned containing only the sliced objects:\n\nYou can also sort the inside a , using the exact same arguments like the sort method you saw in the object.\n\nFinally, there are also the and methods you can use on objects. Unlike in the object, objects only have one variant of ( ) and one variant of ( ). Both of and work on the objects a has.\n\n(high-scoring pair) represents region(s) in the hit sequence that contains significant alignment(s) to the query sequence. It contains the actual match between your query sequence and a database entry. As this match is determined by the sequence search tool’s algorithms, the object contains the bulk of the statistics computed by the search tool. This also makes the distinction between objects from different search tools more apparent compared to the differences you’ve seen in or objects.\n\nLet’s see some examples from our BLAST and BLAT searches. We’ll look at the BLAST HSP first:\n\nJust like and , invoking on an shows its general details:\n• There are the query and hit IDs and descriptions. We need these to identify our .\n• We’ve also got the matching range of the query and hit sequences. The slice notation we’re using here is an indication that the range is displayed using Python’s indexing style (zero-based, half open). The number inside the parenthesis denotes the strand. In this case, both sequences have the plus strand.\n• Some quick statistics are available: the e-value and bitscore.\n• There is information about the HSP fragments. Ignore this for now; it will be explained later on.\n• And finally, we have the query and hit sequence alignment itself.\n\nThese details can be accessed on their own using the dot notation, just like in and :\n\nThey’re not the only attributes available, though. objects come with a default set of properties that makes it easy to probe their various details. Here are some examples:\n\nCheck out the documentation for a full list of these predefined properties.\n\nFurthermore, each sequence search tool usually computes its own statistics / details for its objects. For example, an XML BLAST search also outputs the number of gaps and identical residues. These attributes can be accessed like so:\n\nThese details are format-specific; they may not be present in other formats. To see which details are available for a given sequence search tool, you should check the format’s documentation in . Alternatively, you may also use for a quick list of what’s available:\n\nFinally, you may have noticed that the and attributes of our HSP are not just regular strings:\n\nThey are objects you saw earlier in Section 4! This means that you can do all sorts of interesting things you can do with objects on and/or .\n\nIt should not surprise you now that the object has an property which is a object:\n\nHaving probed the BLAST HSP, let’s now take a look at HSPs from our BLAT results for a different kind of HSP. As usual, we’ll begin by invoking on it:\n\nSome of the outputs you may have already guessed. We have the query and hit IDs and descriptions and the sequence coordinates. Values for evalue and bitscore is ‘?’ as BLAT HSPs do not have these attributes. But The biggest difference here is that you don’t see any sequence alignments displayed. If you look closer, PSL formats themselves do not have any hit or query sequences, so won’t create any sequence or alignment objects. What happens if you try to access , , or ? You’ll get the default values for these attributes, which is :\n\nThis does not affect other attributes, though. For example, you can still access the length of the query or hit alignment. Despite not displaying any attributes, the PSL format still have this information so can extract them:\n\nOther format-specific attributes are still present as well:\n\nSo far so good? Things get more interesting when you look at another ‘variant’ of HSP present in our BLAT results. You might recall that in BLAT searches, sometimes we get our results separated into ‘blocks’. These blocks are essentially alignment fragments that may have some intervening sequence between them.\n\nLet’s take a look at a BLAT HSP that contains multiple blocks to see how deals with this:\n\nWhat’s happening here? We still some essential details covered: the IDs and descriptions, the coordinates, and the quick statistics are similar to what you’ve seen before. But the fragments detail is all different. Instead of showing ‘Fragments: 1’, we now have a table with two data rows.\n\nThis is how deals with HSPs having multiple fragments. As mentioned before, an HSP alignment may be separated by intervening sequences into fragments. The intervening sequences are not part of the query-hit match, so they should not be considered part of query nor hit sequence. However, they do affect how we deal with sequence coordinates, so we can’t ignore them.\n\nTake a look at the hit coordinate of the HSP above. In the field, we see that the coordinate is . But looking at the table rows, we see that not the entire region spanned by this coordinate matches our query. Specifically, the intervening region spans from to .\n\nWhy then, is the query coordinates seem to be contiguous, you ask? This is perfectly fine. In this case it means that the query match is contiguous (no intervening regions), while the hit match is not.\n\nAll these attributes are accessible from the HSP directly, by the way:\n\nMost of these attributes are not readily available from the PSL file we have, but calculates them for you on the fly when you parse the PSL file. All it needs are the start and end coordinates of each fragment.\n\nWhat about the , , and attributes? If the HSP has multiple fragments, you won’t be able to use these attributes as they only fetch single or objects. However, you can use their counterparts: , , and . These properties will return a list containing or objects from each of the HSP fragment. There are other attributes that behave similarly, i.e. they only work for HSPs with one fragment. Check out the documentation for a full list.\n\nFinally, to check whether you have multiple fragments or not, you can use the property like so:\n\nBefore we move on, you should also know that we can use the slice notation on objects, just like or objects. When you use this notation, you’ll get an object in return, the last component of the object model.\n\nrepresents a single, contiguous match between the query and hit sequences. You could consider it the core of the object model and search result, since it is the presence of these fragments that determine whether your search have results or not.\n\nIn most cases, you don’t have to deal with objects directly since not that many sequence search tools fragment their HSPs. When you do have to deal with them, what you should remember is that objects were written with to be as compact as possible. In most cases, they only contain attributes directly related to sequences: strands, reading frames, molecule types, coordinates, the sequences themselves, and their IDs and descriptions.\n\nThese attributes are readily shown when you invoke on an . Here’s an example, taken from our BLAST search:\n\nAt this level, the BLAT fragment looks quite similar to the BLAST fragment, save for the query and hit sequences which are not present:\n\nIn all cases, these attributes are accessible using our favorite dot notation. Some examples:\n\nBefore we move on to the main functions, there is something you ought to know about the standards uses. If you’ve worked with multiple sequence search tools, you might have had to deal with the many different ways each program deals with things like sequence coordinates. It might not have been a pleasant experience as these search tools usually have their own standards. For example, one tools might use one-based coordinates, while the other uses zero-based coordinates. Or, one program might reverse the start and end coordinates if the strand is minus, while others don’t. In short, these often creates unnecessary mess must be dealt with.\n\nWe realize this problem ourselves and we intend to address it in . After all, one of the goals of is to create a common, easy to use interface to deal with various search output files. This means creating standards that extend beyond the object model you just saw.\n\nNow, you might complain, \"Not another standard!\". Well, eventually we have to choose one convention or the other, so this is necessary. Plus, we’re not creating something entirely new here; just adopting a standard we think is best for a Python programmer (it is Biopython, after all).\n\nThere are three implicit standards that you can expect when working with :\n• The first one pertains to sequence coordinates. In , all sequence coordinates follows Python’s coordinate style: zero-based and half open. For example, if in a BLAST XML output file the start and end coordinates of an HSP are 10 and 28, they would become 9 and 28 in . The start coordinate becomes 9 because Python indices start from zero, while the end coordinate remains 28 as Python slices omit the last item in an interval.\n• The second is on sequence coordinate orders. In , start coordinates are always less than or equal to end coordinates. This isn’t always the case with all sequence search tools, as some of them have larger start coordinates when the sequence strand is minus.\n• The last one is on strand and reading frame values. For strands, there are only four valid choices: (plus strand), (minus strand), (protein sequences), and (no strand). For reading frames, the valid choices are integers from to and .\n\nNote that these standards only exist in objects. If you write objects into an output format, will use the format’s standard for the output. It does not force its standard over to your output file.\n\nThere are two functions you can use for reading search output files into objects: and . They’re essentially similar to and functions in other submodules like or . In both cases, you need to supply the search output file name and the file format name, both as Python strings. You can check the documentation for a list of format names recognizes.\n\nis used for reading search output files with only one query and returns a object. You’ve seen used in our previous examples. What you haven’t seen is that may also accept additional keyword arguments, depending on the file format.\n\nHere are some examples. In the first one, we use just like previously to read a BLAST tabular output file. In the second one, we use a keyword argument to modify so it parses the BLAST tabular variant with comments in it:\n\nThese keyword arguments differs among file formats. Check the format documentation to see if it has keyword arguments that modifies its parser’s behavior.\n\nAs for the , it is used for reading search output files with any number of queries. The function returns a generator object that yields a object in each iteration. Like , it also accepts format-specific keyword arguments:\n\nSometimes, you’re handed a search output file containing hundreds or thousands of queries that you need to parse. You can of course use for this file, but that would be grossly inefficient if you need to access only a few of the queries. This is because will parse all queries it sees before it fetches your query of interest.\n\nIn this case, the ideal choice would be to index the file using or . If the names sound familiar, it’s because you’ve seen them before in Section 5.4.2. These functions also behave similarly to their counterparts, with the addition of format-specific keyword arguments.\n\nHere are some examples. You can use with just the filename and format name:\n\nOr also with the format-specific keyword argument:\n\nOr with the argument, as in :\n\nworks like as , only it writes the query offsets into an SQLite database file.\n\nIt is occasionally useful to be able to manipulate search results from an output file and write it again to a new file. provides a function that lets you do exactly this. It takes as its arguments an iterable returning objects, the output filename to write to, the format name to write to, and optionally some format-specific keyword arguments. It returns a four-item tuple, which denotes the number or , , , and objects that were written.\n\nYou should note different file formats require different attributes of the , , and objects. If these attributes are not present, writing won’t work. In other words, you can’t always write to the output format that you want. For example, if you read a BLAST XML file, you wouldn’t be able to write the results to a PSL file as PSL files require attributes not calculated by BLAST (e.g. the number of repeat matches). You can always set these attributes manually, if you really want to write to PSL, though.\n\nLike , , , and , also accepts format-specific keyword arguments. Check out the documentation for a complete list of formats can write to and their arguments.\n\nFinally, also provides a function, which is simply a shortcut for and . Using the convert function, our example above would be:\n\nAs uses , it is only limited to format conversions that have all the required attributes. Here, the BLAST XML file provides all the default values a BLAST tabular file requires, so it works just fine. However, other format conversions are less likely to work since you need to manually assign the required attributes first.\n\nEntrez (https://www.ncbi.nlm.nih.gov/Web/Search/entrezfs.html) is a data retrieval system that provides users access to NCBI’s databases such as PubMed, GenBank, GEO, and many others. You can access Entrez from a web browser to manually enter queries, or you can use Biopython’s module for programmatic access to Entrez. The latter allows you for example to search PubMed or download GenBank records from within a Python script.\n\nThe module makes use of the Entrez Programming Utilities (also known as EUtils), consisting of eight tools that are described in detail on NCBI’s page at https://www.ncbi.nlm.nih.gov/books/NBK25501/. Each of these tools corresponds to one Python function in the module, as described in the sections below. This module makes sure that the correct URL is used for the queries, and that NCBI’s guidelines for responsible data access are being followed.\n\nThe output returned by the Entrez Programming Utilities is typically in XML format. To parse such output, you have several options:\n• Use ’s parser to parse the XML output into a Python object;\n• Use one of the XML parsers available in Python’s standard library;\n• Read the XML output as raw text, and parse it by string searching and manipulation.\n\nSee the Python documentation for a description of the XML parsers in Python’s standard library. Here, we discuss the parser in Biopython’s module. This parser can be used to parse data as provided through ’s programmatic access functions to Entrez, but can also be used to parse XML data from NCBI Entrez that are stored in a file. In the latter case, the XML file should be opened in binary mode (e.g. ) for the XML parser in to work correctly. Alternatively, you can pass the file name or path to the XML file, and let take care of opening and closing the file.\n\nNCBI uses DTD (Document Type Definition) files to describe the structure of the information contained in XML files. Most of the DTD files used by NCBI are included in the Biopython distribution. The parser makes use of the DTD files when parsing an XML file returned by NCBI Entrez.\n\nOccasionally, you may find that the DTD file associated with a specific XML file is missing in the Biopython distribution. In particular, this may happen when NCBI updates its DTD files. If this happens, will show a warning message with the name and URL of the missing DTD file. The parser will proceed to access the missing DTD file through the internet, allowing the parsing of the XML file to continue. However, the parser is much faster if the DTD file is available locally. For this purpose, please download the DTD file from the URL in the warning message and place it in the directory , containing the other DTD files. If you don’t have write access to this directory, you can also place the DTD file in , where represents your home directory. Since this directory is read before the directory , you can also put newer versions of DTD files there if the ones in become outdated. Alternatively, if you installed Biopython from source, you can add the DTD file to the source code’s directory, and reinstall Biopython. This will install the new DTD file in the correct location together with the other DTD files.\n\nThe Entrez Programming Utilities can also generate output in other formats, such as the Fasta or GenBank file formats for sequence databases, or the MedLine format for the literature database, discussed in Section 12.13.\n\nThe functions in for programmatic access to Entrez return data either in binary format or in text format, depending on the type of data requested. In most cases, these functions return data in text format by decoding the data obtained from NCBI Entrez to Python strings under the assumption that the encoding is UTF-8. However, XML data are returned in binary format. The reason for this is that the encoding is specified in the XML document itself, which means that we won’t know the correct encoding to use until we start parsing the file. ’s parser therefore accepts data in binary format, extracts the encoding from the XML, and uses it to decode all text in the XML document to Python strings, ensuring that all text (in particular in languages other than English) are interpreted correctly. This is also the reason why you should open an XML file a binary mode when you want to use ’s parser to parse the file.\n\nBefore using Biopython to access the NCBI’s online resources (via or some of the other modules), please read the NCBI’s Entrez User Requirements. If the NCBI finds you are abusing their systems, they can and will ban your access!\n• For any series of more than 100 requests, do this at weekends or outside USA peak times. This is up to you to obey.\n• Use the address, not the standard NCBI Web address. Biopython uses this web address.\n• If you are using a API key, you can make at most 10 queries per second, otherwise at most 3 queries per second. This is automatically enforced by Biopython. Include in the argument list or set it as a module level variable:\n• Use the optional email parameter so the NCBI can contact you if there is a problem. You can either explicitly set this as a parameter with each call to Entrez (e.g. include in the argument list), or you can set a global email address: Bio.Entrez will then use this email address with each call to Entrez. The example.com address is a reserved domain name specifically for documentation (RFC 2606). Please DO NOT use a random email – it’s better not to give an email at all. The email parameter has been mandatory since June 1, 2010. In case of excessive usage, NCBI will attempt to contact a user at the e-mail address provided prior to blocking access to the E-utilities.\n• If you are using Biopython within some larger software suite, use the tool parameter to specify this. You can either explicitly set the tool name as a parameter with each call to Entrez (e.g. include in the argument list), or you can set a global tool name: The tool parameter will default to Biopython.\n• For large queries, the NCBI also recommend using their session history feature (the WebEnv session cookie string, see Section 12.16). This is only slightly more complicated.\n\nIn conclusion, be sensible with your usage levels. If you plan to download lots of data, consider other options. For example, if you want easy access to all the human genes, consider fetching each chromosome by FTP as a GenBank file, and importing these into your own BioSQL database (see Section 22.3).\n\nEInfo provides field index term counts, last update, and available links for each of NCBI’s databases. In addition, you can use EInfo to obtain a list of all database names accessible through the Entrez utilities:\n\nThe variable now contains a list of databases in XML format:\n\nSince this is a fairly simple XML file, we could extract the information it contains simply by string searching. Using ’s parser instead, we can directly parse this XML file into a Python object:\n\nNow is a dictionary with exactly one key:\n\nThe values stored in this key is the list of database names shown in the XML above:\n\nFor each of these databases, we can use EInfo again to obtain more information:\n\nTry for other information stored in this record. One of the most useful is a list of possible search fields for use with ESearch:\n\nThat’s a long list, but indirectly this tells you that for the PubMed database, you can do things like Jones[AUTH] to search the author field, or Sanger[AFFL] to restrict to authors at the Sanger Centre. This can be very handy - especially if you are not so familiar with a particular database.\n\nTo search any of these databases, we use . For example, let’s search in PubMed for publications that include Biopython in their title:\n\nIn this output, you see PubMed IDs (including 19304878 which is the PMID for the Biopython application note), which can be retrieved by EFetch (see section 12.6).\n\nYou can also use ESearch to search GenBank. Here we’ll do a quick search for the matK gene in Cypripedioideae orchids (see Section 12.2 about EInfo for one way to find out which fields you can search in each Entrez database):\n\nEach of the IDs (JQ660909.1, JQ660908.1, JQ660907.1, …) is a GenBank identifier (Accession number). See section 12.6 for information on how to actually download these GenBank records.\n\nNote that instead of a species name like Cypripedioideae[Orgn], you can restrict the search using an NCBI taxon identifier, here this would be txid158330[Orgn]. This isn’t currently documented on the ESearch help page - the NCBI explained this in reply to an email query. You can often deduce the search term formatting by playing with the Entrez web interface. For example, including complete[prop] in a genome search restricts to just completed genomes.\n\nAs a final example, let’s get a list of computational journal titles:\n\nAgain, we could use EFetch to obtain more information for each of these journal IDs.\n\nESearch has many useful options — see the ESearch help page for more information.\n\nEPost uploads a list of UIs for use in subsequent search strategies; see the EPost help page for more information. It is available from Biopython through the function.\n\nTo give an example of when this is useful, suppose you have a long list of IDs you want to download using EFetch (maybe sequences, maybe citations – anything). When you make a request with EFetch your list of IDs, the database etc, are all turned into a long URL sent to the server. If your list of IDs is long, this URL gets long, and long URLs can break (e.g. some proxies don’t cope well).\n\nInstead, you can break this up into two steps, first uploading the list of IDs using EPost (this uses an “HTML post” internally, rather than an “HTML get”, getting round the long URL problem). With the history support, you can then refer to this long list of IDs, and download the associated data with EFetch.\n\nLet’s look at a simple example to see how EPost works – uploading some PubMed identifiers:\n\nThe returned XML includes two important strings, and which together define your history session. You would extract these values for use with another Entrez call such as EFetch:\n\nSection 12.16 shows how to use the history feature.\n\nESummary retrieves document summaries from a list of primary IDs (see the ESummary help page for more information). In Biopython, ESummary is available as . Using the search result above, we can for example find out more about the journal with ID 30367:\n\nEFetch is what you use when you want to retrieve a full record from Entrez. This covers several possible databases, as described on the main EFetch Help page.\n\nFor most of their databases, the NCBI support several different file formats. Requesting a specific file format from Entrez using requires specifying the and/or optional arguments. The different combinations are described for each database type on the pages linked to on NCBI efetch webpage.\n\nOne common usage is downloading sequences in the FASTA or GenBank/GenPept plain text formats (which can then be parsed with , see Sections 5.3.1 and 12.6). From the Cypripedioideae example above, we can download GenBank record EU490707 using :\n\nPlease be aware that as of October 2016 GI identifiers are discontinued in favor of accession numbers. You can still fetch sequences based on their GI, but new sequences are no longer given this identifier. You should instead refer to them by the “Accession number” as done in the example.\n\nThe arguments and let us download this record in the GenBank format.\n\nNote that until Easter 2009, the Entrez EFetch API let you use “genbank” as the return type, however the NCBI now insist on using the official return types of “gb” or “gbwithparts” (or “gp” for proteins) as described on online. Also note that until Feb 2012, the Entrez EFetch API would default to returning plain text files, but now defaults to XML.\n\nAlternatively, you could for example use to get the Fasta-format; see the EFetch Sequences Help page for other options. Remember – the available formats depend on which database you are downloading from - see the main EFetch Help page.\n\nIf you fetch the record in one of the formats accepted by (see Chapter 5), you could directly parse it into a :\n\nNote that a more typical use would be to save the sequence data to a local file, and then parse it with . This can save you having to re-download the same file repeatedly while working on your script, and places less load on the NCBI’s servers. For example:\n\nTo get the output in XML format, which you can parse using the function, use :\n\nSo, that dealt with sequences. For examples of parsing file formats specific to the other databases (e.g. the format used in PubMed), see Section 12.13.\n\nIf you want to perform a search with , and then download the records with , you should use the WebEnv history feature – see Section 12.16.\n\nELink, available from Biopython as , can be used to find related items in the NCBI Entrez databases. For example, you can us this to find nucleotide entries for an entry in the gene database, and other cool stuff.\n\nLet’s use ELink to find articles related to the Biopython application note published in Bioinformatics in 2009. The PubMed ID of this article is 19304878:\n\nThe variable consists of a Python list, one for each database in which we searched. Since we specified only one PubMed ID to search for, contains only one item. This item is a dictionary containing information about our search term, as well as all the related items that were found:\n\nThe key contains the search results, stored as a list consisting of one item for each target database. In our search results, we only find hits in the PubMed database (although sub-divided into categories):\n\nThe exact numbers should increase over time:\n\nThe actual search results are stored as under the key.\n\nLet’s now at the first search result:\n\nThis is the article we searched for, which doesn’t help us much, so let’s look at the second search result:\n\nThis paper, with PubMed ID 14630660, is about the Biopython PDB parser.\n\nWe can use a loop to print out all PubMed IDs:\n\nNow that was nice, but personally I am often more interested to find out if a paper has been cited. Well, ELink can do that too – at least for journals in Pubmed Central (see Section 12.16.3).\n\nFor help on ELink, see the ELink help page. There is an entire sub-page just for the link names, describing how different databases can be cross referenced.\n\nEGQuery provides counts for a search term in each of the Entrez databases (i.e. a global query). This is particularly useful to find out how many items your search terms would find in each database without actually performing lots of separate searches with ESearch (see the example in 12.15.2 below).\n\nIn this example, we use to obtain the counts for “Biopython”:\n\nSee the EGQuery help page for more information.\n\nESpell retrieves spelling suggestions. In this example, we use to obtain the correct spelling of Biopython:\n\nSee the ESpell help page for more information. The main use of this is for GUI tools to provide automatic suggestions for search terms.\n\nThe function reads the entire XML file returned by Entrez into a single Python object, which is kept in memory. To parse Entrez XML files too large to fit in memory, you can use the function . This is a generator function that reads records in the XML file one by one. This function is only useful if the XML file reflects a Python list object (in other words, if on a computer with infinite memory resources would return a Python list).\n\nFor example, you can download the entire Entrez Gene database for a given organism as a file from NCBI’s ftp site. These files can be very large. As an example, on September 4, 2009, the file , containing the Entrez Gene database for human, had a size of 116576 kB. This file, which is in the format, can be converted into an XML file using NCBI’s program (see NCBI’s ftp site for more information):\n\nThe resulting XML file has a size of 6.1 GB. Attempting on this file will result in a on many computers.\n\nThe XML file consists of a list of Entrez gene records, each corresponding to one Entrez gene in human. retrieves these gene records one by one. You can then print out or store the relevant information in each record by iterating over the records. For example, this script iterates over the Entrez gene records and prints out the gene numbers and names for all current genes:\n\nAlternatively, you can use\n\nand let take care of opening and closing the file. This is safer, as the file will then automatically be closed after parsing it, or if an error occurs.\n\nPubmed records may contain HTML tags to indicate e.g. subscripts, superscripts, or italic text, as well as mathematical symbols via MathML. By default, the parser treats all text as plain text without markup; for example, the fragment “P < 0.05” in the abstract of a Pubmed record, which is encoded as\n\nin the XML returned by Entrez, is converted to the Python string\n\nby the parser. While this is more human-readable, it is not valid HTML due to the less-than sign, and makes further processing of the text e.g. by an HTML parser impractical. To ensure that all strings returned by the parser are valid HTML, call or with the argument set to :\n\nThe parser will then replace all characters disallowed in HTML by their HTML-escaped equivalent; in the example above, the parser will generate\n\nwhich is a valid HTML fragment. By default, is .\n\nThe file is not an XML file\n\nFor example, this error occurs if you try to parse a Fasta file as if it were an XML file:\n\nHere, the parser didn’t find the tag with which an XML file is supposed to start, and therefore decides (correctly) that the file is not an XML file.\n\nThe file ends prematurely or is otherwise corrupted\n\nWhen your file is in the XML format but is corrupted (for example, by ending prematurely), the parser will raise a CorruptedXMLError.\n\nHere is an example of an XML file that ends prematurely:\n\nwhich will generate the following traceback:\n\nNote that the error message tells you at what point in the XML file the error was detected.\n\nThe file contains items that are missing from the associated DTD\n\nThis is an example of an XML file containing tags that do not have a description in the corresponding DTD file:\n\nIn this file, for some reason the tag (and several others) are not listed in the DTD file , which is specified on the second line as the DTD for this XML file. By default, the parser will stop and raise a ValidationError if it cannot find some tag in the DTD:\n\nOptionally, you can instruct the parser to skip such tags instead of raising a ValidationError. This is done by calling or with the argument equal to False:\n\nOf course, the information contained in the XML tags that are not in the DTD are not present in the record returned by .\n\nThe file contains an error message\n\nThis may occur, for example, when you attempt to access a PubMed record for a nonexistent PubMed ID. By default, this will raise a :\n\nIf you are accessing multiple PubMed records, the would prevent you from receiving results for any of the PubMed records if one of the PubMed IDs is incorrect. To circumvent this, you can set the argument to . This will return the requested results for the valid PubMed IDs, and an for the incorrect ID:\n\nThe function can parse most (if not all) XML output returned by Entrez. Entrez typically allows you to retrieve records in other formats, which may have some advantages compared to the XML format in terms of readability (or download size).\n\nTo request a specific file format from Entrez using requires specifying the and/or optional arguments. The different combinations are described for each database type on the NCBI efetch webpage.\n\nOne obvious case is you may prefer to download sequences in the FASTA or GenBank/GenPept plain text formats (which can then be parsed with , see Sections 5.3.1 and 12.6). For the literature databases, Biopython contains a parser for the format used in PubMed.\n\nYou can find the Medline parser in . Suppose we want to parse the file , containing one Medline record. You can find this file in Biopython’s directory. The file looks like this:\n\nWe first open the file and then parse it:\n\nThe now contains the Medline record as a Python dictionary:\n\nThe key names used in a Medline record can be rather obscure; use\n\nTo parse a file containing multiple Medline records, you can use the function instead:\n\nInstead of parsing Medline records stored in files, you can also parse Medline records downloaded by . For example, let’s look at all Medline records in PubMed related to Biopython:\n\nWe now use to download these Medline records:\n\nHere, we specify to obtain the Medline records in plain-text Medline format. Now we use to parse these records:\n\nFor comparison, here we show an example using the XML format:\n\nNote that in both of these examples, for simplicity we have naively combined ESearch and EFetch. In this situation, the NCBI would expect you to use their history feature, as illustrated in Section 12.16.\n\nGEO (Gene Expression Omnibus) is a data repository of high-throughput gene expression and hybridization array data. The module can be used to parse GEO-formatted data.\n\nThe following code fragment shows how to parse the example GEO file into a record and print the record:\n\nYou can search the “gds” database (GEO datasets) with ESearch:\n\nFrom the Entrez website, UID “200000016” is GDS16 while the other hit “100000028” is for the associated platform, GPL28. Unfortunately, at the time of writing the NCBI don’t seem to support downloading GEO files using Entrez (not as XML, nor in the Simple Omnibus Format in Text (SOFT) format).\n\nHowever, it is actually pretty straight forward to download the GEO files by FTP from ftp://ftp.ncbi.nih.gov/pub/geo/ instead. In this case you might want ftp://ftp.ncbi.nih.gov/pub/geo/DATA/SOFT/by_series/GSE16/GSE16_family.soft.gz (a compressed file, see the Python module gzip).\n\nUniGene is an NCBI database of the transcriptome, with each UniGene record showing the set of transcripts that are associated with a particular gene in a specific organism. A typical UniGene record looks like this:\n\nThis particular record shows the set of transcripts (shown in the lines) that originate from the human gene NAT2, encoding en N-acetyltransferase. The lines show proteins with significant similarity to NAT2, whereas the lines show the corresponding sequence-tagged sites in the genome.\n\nTo parse UniGene files, use the module:\n\nThe returned by is a Python object with attributes corresponding to the fields in the UniGene record. For example,\n\nThe and lines are stored as Python lists of strings:\n\nSpecialized objects are returned for the , , and lines, storing the keys shown in each line as attributes:\n\nand similarly for the and lines.\n\nTo parse a file containing more than one UniGene record, use the function in :\n\nNormally you won’t have to worry about using a proxy, but if this is an issue on your network here is how to deal with it. Internally, uses the standard Python library for accessing the NCBI servers. This will check an environment variable called to configure any simple proxy automatically. Unfortunately this module does not support the use of proxies which require authentication.\n\nYou may choose to set the environment variable once (how you do this will depend on your operating system). Alternatively you can set this within Python at the start of your script, for example:\n\nSee the urllib documentation for more details.\n\nIf you are in the medical field or interested in human issues (and many times even if you are not!), PubMed (https://www.ncbi.nlm.nih.gov/PubMed/) is an excellent source of all kinds of goodies. So like other things, we’d like to be able to grab information from it and use it in Python scripts.\n\nIn this example, we will query PubMed for all articles having to do with orchids (see section 2.3 for our motivation). We first check how many of such articles there are:\n\nNow we use the function to download the PubMed IDs of these 463 articles:\n\nThis returns a Python list containing all of the PubMed IDs of articles related to orchids:\n\nNow that we’ve got them, we obviously want to get the corresponding Medline records and extract the information from them. Here, we’ll download the Medline records in the Medline flat-file format, and use the module to parse them:\n\nNOTE - We’ve just done a separate search and fetch here, the NCBI much prefer you to take advantage of their history support in this situation. See Section 12.16.\n\nKeep in mind that is an iterator, so you can iterate through the records only once. If you want to save the records, you can convert them to a list:\n\nLet’s now iterate over the records to print out some information about each record:\n\nThe output for this looks like:\n\nEspecially interesting to note is the list of authors, which is returned as a standard Python list. This makes it easy to manipulate and search using standard Python tools. For instance, we could loop through a whole bunch of entries searching for a particular author with code like the following:\n\nHopefully this section gave you an idea of the power and flexibility of the Entrez and Medline interfaces and how they can be used together.\n\nHere we’ll show a simple example of performing a remote Entrez query. In section 2.3 of the parsing examples, we talked about using NCBI’s Entrez website to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we’ll look at how to automate that process using a Python script. In this example, we’ll just show how to connect, get the results, and parse them, with the Entrez module doing all of the work.\n\nFirst, we use EGQuery to find out the number of results we will get before actually downloading them. EGQuery will tell us how many search results were found in each of the databases, but for this example we are only interested in nucleotides:\n\nSo, we expect to find 4457 Entrez Nucleotide records (this increased from 814 records in 2008; it is likely to continue to increase in the future). If you find some ridiculously high number of hits, you may want to reconsider if you really want to download all of them, which is our next step. Let’s use the argument to restrict the maximum number of records retrieved to the number available in 2008:\n\nHere, is a Python dictionary containing the search results and some auxiliary information. Just for information, let’s look at what is stored in this dictionary:\n\nFirst, let’s check how many results were found:\n\nYou might have expected this to be 814, the maximum number of records we asked to retrieve. However, represents the total number of records available for that search, not how many were retrieved. The retrieved records are stored in , which should contain the total number we asked for:\n\nLet’s look at the first five results:\n\nWe can download these records using . While you could download these records one by one, to reduce the load on NCBI’s servers, it is better to fetch a bunch of records at the same time, shown below. However, in this situation you should ideally be using the history feature described later in Section 12.16.\n\nEach of these records corresponds to one GenBank record.\n\nYou could use this to quickly set up searches – but for heavy usage, see Section 12.16.\n\nThe GenBank record format is a very popular method of holding information about sequences, sequence features, and other associated sequence information. The format is a good way to get information from the NCBI databases at https://www.ncbi.nlm.nih.gov/.\n\nIn this example we’ll show how to query the NCBI databases,to retrieve the records from the query, and then parse them using - something touched on in Section 5.3.1. For simplicity, this example does not take advantage of the WebEnv history feature – see Section 12.16 for this.\n\nFirst, we want to make a query and find out the ids of the records to retrieve. Here we’ll do a quick search for one of our favorite organisms, Opuntia (prickly-pear cacti). We can do quick search and get back the GIs (GenBank identifiers) for all of the corresponding records. First we check how many records there are:\n\nNow we download the list of GenBank identifiers:\n\nNow we use these GIs to download the GenBank records - note that with older versions of Biopython you had to supply a comma separated list of GI numbers to Entrez, as of Biopython 1.59 you can pass a list and this is converted for you:\n\nIf you want to look at the raw GenBank files, you can read from this stream and print out the result:\n\nIn this case, we are just getting the raw records. To get the records in a more Python-friendly form, we can use to parse the GenBank data into objects, including objects (see Chapter 5):\n\nWe can now step through the records and look at the information we are interested in:\n\nUsing these automated query retrieval functionality is a big plus over doing things by hand. Although the module should obey the NCBI’s max three queries per second rule, the NCBI have other recommendations like avoiding peak hours. See Section 12.1. In particular, please note that for simplicity, this example does not use the WebEnv history feature. You should use this for any non-trivial search and download work, see Section 12.16.\n\nFinally, if plan to repeat your analysis, rather than downloading the files from the NCBI and parsing them immediately (as shown in this example), you should just download the records once and save them to your hard disk, and then parse the local file.\n\n12.15.4 Finding the lineage of an organism\n\nStaying with a plant example, let’s now find the lineage of the Cypripedioideae orchid family. First, we search the Taxonomy database for Cypripedioideae, which yields exactly one NCBI taxonomy identifier:\n\nNow, we use to download this entry in the Taxonomy database, and then parse it:\n\nAgain, this record stores lots of information:\n\nWe can get the lineage directly from this record:\n\nThe record data contains much more than just the information shown here - for example look under \"LineageEx\" instead of \"Lineage\" and you’ll get the NCBI taxon identifiers of the lineage entries too.\n\n12.16 Using the history and WebEnv\n\nOften you will want to make a series of linked queries. Most typically, running a search, perhaps refining the search, and then retrieving detailed search results. You can do this by making a series of separate calls to Entrez. However, the NCBI prefer you to take advantage of their history support - for example combining ESearch and EFetch.\n\nAnother typical use of the history support would be to combine EPost and EFetch. You use EPost to upload a list of identifiers, which starts a new history session. You then download the records with EFetch by referring to the session (instead of the identifiers).\n\n12.16.1 Searching for and downloading sequences using the history\n\nSuppose we want to search and download all the Opuntia rpl16 nucleotide sequences, and store them in a FASTA file. As shown in Section 12.15.3, we can naively combine to get a list of Accession numbers, and then call to download them all.\n\nHowever, the approved approach is to run the search with the history feature. Then, we can fetch the results by reference to the search results - which the NCBI can anticipate and cache.\n\nTo do this, call as normal, but with the additional argument of ,\n\nAs before (see Section 12.15.2), the XML output includes the first search results, with defaulting to 20:\n\nYou also get given two additional pieces of information, the WebEnv session cookie, and the QueryKey:\n\nHaving stored these values in variables session_cookie and query_key we can use them as parameters to instead of giving the GI numbers as identifiers.\n\nWhile for small searches you might be OK downloading everything at once, it is better to download in batches. You use the retstart and retmax parameters to specify which range of search results you want returned (starting entry using zero-based counting, and maximum number of results to return). Note that if Biopython encounters a transient failure like a HTTP 500 response when communicating with NCBI, it will automatically try again a couple of times. For example,\n\nFor illustrative purposes, this example downloaded the FASTA records in batches of three. Unless you are downloading genomes or chromosomes, you would normally pick a larger batch size.\n\n12.16.2 Searching for and downloading abstracts using the history\n\nHere is another history example, searching for papers published in the last year about the Opuntia, and then downloading them into a file in MedLine format:\n\nAt the time of writing, this gave 28 matches - but because this is a date dependent search, this will of course vary. As described in Section 12.13.1 above, you can then use to parse the saved records.\n\nBack in Section 12.7 we mentioned ELink can be used to search for citations of a given paper. Unfortunately this only covers journals indexed for PubMed Central (doing it for all the journals in PubMed would mean a lot more work for the NIH). Let’s try this for the Biopython PDB parser paper, PubMed ID 14630660:\n\nGreat - eleven articles. But why hasn’t the Biopython application note been found (PubMed ID 19304878)? Well, as you might have guessed from the variable names, there are not actually PubMed IDs, but PubMed Central IDs. Our application note is the third citing paper in that list, PMCID 2682512.\n\nSo, what if (like me) you’d rather get back a list of PubMed IDs? Well we can call ELink again to translate them. This becomes a two step process, so by now you should expect to use the history feature to accomplish it (Section 12.16).\n\nBut first, taking the more straightforward approach of making a second (separate) call to ELink:\n\nThis time you can immediately spot the Biopython application note as the third hit (PubMed ID 19304878).\n\nNow, let’s do that all again but with the history …TODO.\n\nAnd finally, don’t forget to include your own email address in the Entrez calls.\n\nSwiss-Prot (https://web.expasy.org/docs/swiss-prot_guideline.html) is a hand-curated database of protein sequences. Biopython can parse the “plain text” Swiss-Prot file format, which is still used for the UniProt Knowledgebase which combined Swiss-Prot, TrEMBL and PIR-PSD.\n\nAlthough in the following we focus on the older human readable plain text format, can read both this and the newer UniProt XML file format for annotated protein sequences.\n\nIn Section 5.3.2, we described how to extract the sequence of a Swiss-Prot record as a object. Alternatively, you can store the Swiss-Prot record in a object, which in fact stores the complete information contained in the Swiss-Prot record. In this section, we describe how to extract objects from a Swiss-Prot file.\n\nTo parse a Swiss-Prot record, we first get a handle to a Swiss-Prot record. There are several ways to do so, depending on where and how the Swiss-Prot record is stored:\n• Open a Swiss-Prot file over the internet: to open the file stored on the Internet before calling .\n• Open a Swiss-Prot file over the internet from the ExPASy database (see section 13.5.1):\n\nThe key point is that for the parser, it doesn’t matter how the handle was created, as long as it points to data in the Swiss-Prot format. The parser will automatically decode the data as ASCII (the encoding used by Swiss-Prot) if the handle was opened in binary mode.\n\nWe can use as described in Section 5.3.2 to get file format agnostic objects. Alternatively, we can use get objects, which are a much closer match to the underlying file format.\n\nTo read one Swiss-Prot record from the handle, we use the function :\n\nThis function should be used if the handle points to exactly one Swiss-Prot record. It raises a if no Swiss-Prot record was found, and also if more than one record was found.\n\nWe can now print out some information about this record:\n\nTo parse a file that contains more than one Swiss-Prot record, we use the function instead. This function allows us to iterate over the records in the file.\n\nFor example, let’s parse the full Swiss-Prot database and collect all the descriptions. You can download this from the ExPASy FTP site as a single gzipped-file (about 300MB). This is a compressed file containing a single file, (over 1.5GB).\n\nAs described at the start of this section, you can use the Python library to open and uncompress a .gz file, like this:\n\nHowever, uncompressing a large file takes time, and each time you open the file for reading in this way, it has to be decompressed on the fly. So, if you can spare the disk space you’ll save time in the long run if you first decompress the file to disk, to get the file inside. Then you can open the file for reading as usual:\n\nAs of June 2009, the full Swiss-Prot database downloaded from ExPASy contained 468851 Swiss-Prot records. One concise way to build up a list of the record descriptions is with a list comprehension:\n\nOr, using a for loop over the record iterator:\n\nBecause this is such a large input file, either way takes about eleven minutes on my new desktop computer (using the uncompressed file as input).\n\nIt is equally easy to extract any kind of information you’d like from Swiss-Prot records. To see the members of a Swiss-Prot record, use\n\nSwiss-Prot also distributes a file , which lists the keywords and categories used in Swiss-Prot. The file contains entries in the following form:\n\nThe entries in this file can be parsed by the function in the module. Each entry is then stored as a , which is a Python dictionary.\n\nProsite is a database containing protein domains, protein families, functional sites, as well as the patterns and profiles to recognize them. Prosite was developed in parallel with Swiss-Prot. In Biopython, a Prosite record is represented by the class, whose members correspond to the different fields in a Prosite record.\n\nIn general, a Prosite file can contain more than one Prosite records. For example, the full set of Prosite records, which can be downloaded as a single file ( ) from the ExPASy FTP site, contains 2073 records (version 20.24 released on 4 December 2007). To parse such a file, we again make use of an iterator:\n\nWe can now take the records one at a time and print out some information. For example, using the file containing the complete Prosite database, we’d find\n\nand so on. If you’re interested in how many Prosite records there are, you could use\n\nTo read exactly one Prosite from the handle, you can use the function:\n\nThis function raises a ValueError if no Prosite record is found, and also if more than one Prosite record is found.\n\nIn the Prosite example above, the accession numbers , , and so on refer to Prosite documentation. The Prosite documentation records are available from ExPASy as individual files, and as one file ( ) containing all Prosite documentation records.\n\nWe use the parser in to parse Prosite documentation records. For example, to create a list of all accession numbers of Prosite documentation record, you can use\n\nAgain a function is provided to read exactly one Prosite documentation record from the handle.\n\nExPASy’s Enzyme database is a repository of information on enzyme nomenclature. A typical Enzyme record looks as follows:\n\nIn this example, the first line shows the EC (Enzyme Commission) number of lipoprotein lipase (second line). Alternative names of lipoprotein lipase are \"clearing factor lipase\", \"diacylglycerol lipase\", and \"diglyceride lipase\" (lines 3 through 5). The line starting with \"CA\" shows the catalytic activity of this enzyme. Comment lines start with \"CC\". The \"PR\" line shows references to the Prosite Documentation records, and the \"DR\" lines show references to Swiss-Prot records. Not of these entries are necessarily present in an Enzyme record.\n\nIn Biopython, an Enzyme record is represented by the class. This record derives from a Python dictionary and has keys corresponding to the two-letter codes used in Enzyme files. To read an Enzyme file containing one Enzyme record, use the function in :\n\nThe function raises a ValueError if no Enzyme record is found, and also if more than one Enzyme record is found.\n\nThe full set of Enzyme records can be downloaded as a single file ( ) from the ExPASy FTP site, containing 4877 records (release of 3 March 2009). To parse such a file containing multiple Enzyme records, use the function in to obtain an iterator:\n\nWe can now iterate over the records one at a time. For example, we can make a list of all EC numbers for which an Enzyme record is available:\n\nSwiss-Prot, Prosite, and Prosite documentation records can be downloaded from the ExPASy web server at https://www.expasy.org. Four kinds of queries are available from ExPASy:\n\nTo access this web server from a Python script, we use the module.\n\nLet’s say we are looking at chalcone synthases for Orchids (see section 2.3 for some justification for looking for interesting things about orchids). Chalcone synthase is involved in flavanoid biosynthesis in plants, and flavanoids make lots of cool things like pigment colors and UV protectants.\n\nIf you do a search on Swiss-Prot, you can find three orchid proteins for Chalcone Synthase, id numbers O23729, O23730, O23731. Now, let’s write a script which grabs these, and parses out some interesting information.\n\nFirst, we grab the records, using the function of . This function is very nice since you can feed it an id and get back a handle to a raw text record (no HTML to mess with!). We can the use to pull out the Swiss-Prot record, or to get a SeqRecord. The following code accomplishes what I just wrote:\n\nIf the accession number you provided to does not exist, then will raise a . You can catch exceptions to detect invalid accession numbers:\n\nNow, you may remark that I knew the records’ accession numbers beforehand. Indeed, needs either the entry name or an accession number. When you don’t have them handy, right now you could use https://www.uniprot.org/ but we do not have a Python wrapper for searching this from a script. Perhaps you could contribute here?\n\nProsite and Prosite documentation records can be retrieved either in HTML format, or in raw format. To parse Prosite and Prosite documentation records with Biopython, you should retrieve the records in raw format. For other purposes, however, you may be interested in these records in HTML format.\n\nTo retrieve a Prosite or Prosite documentation record in raw format, use . For example, to download a Prosite record and print it out in raw text format, use\n\nTo retrieve a Prosite record and parse it into a object, use\n\nThe same function can be used to retrieve a Prosite documentation record and parse it into a object:\n\nFor non-existing accession numbers, returns a handle to an empty string. When faced with an empty string, and will raise a ValueError. You can catch these exceptions to detect invalid accession numbers.\n\nThe functions and are used to download Prosite and Prosite documentation records in HTML format. To create a web page showing one Prosite record, you can use\n\nFor these functions, an invalid accession number returns an error message in HTML format.\n\nScanProsite allows you to scan protein sequences online against the Prosite database by providing a UniProt or PDB sequence identifier or the sequence itself. For more information about ScanProsite, please see the ScanProsite documentation as well as the documentation for programmatic access of ScanProsite.\n\nYou can use Biopython’s module to scan the Prosite database from Python. This module both helps you to access ScanProsite programmatically, and to parse the results returned by ScanProsite. To scan for Prosite patterns in the following protein sequence:\n\nyou can use the following code:\n\nBy executing , you can obtain the search results in raw XML format. Instead, let’s use to parse the raw XML into a Python object:\n\nA object is derived from a list, with each element in the list storing one ScanProsite hit. This object also stores the number of hits, as well as the number of search sequences, as returned by ScanProsite. This ScanProsite search resulted in six hits:\n\nOther ScanProsite parameters can be passed as keyword arguments; see the documentation for programmatic access of ScanProsite for more information. As an example, passing to include matches with low level scores lets use find one additional hit:\n\nBio.PDB is a Biopython module that focuses on working with crystal structures of biological macromolecules. Among other things, Bio.PDB includes a PDBParser class that produces a Structure object, which can be used to access the atomic data in the file in a convenient manner. There is limited support for parsing the information contained in the PDB header. PDB file format is no longer being modified or extended to support new content and PDBx/mmCIF became the standard PDB archive format in 2014. All the Worldwide Protein Data Bank (wwPDB) sites uses the macromolecular Crystallographic Information File (mmCIF) data dictionaries to describe the information content of PDB entries. mmCIF uses a flexible and extensible key-value pair format for representing macromolecular structural data and imposes no limitations for the number of atoms, residues or chains that can be represented in a single PDB entry (no split entries!).\n\nThen use this parser to create a structure object from the mmCIF file:\n\nTo have some more low level access to an mmCIF file, you can use the class to create a Python dictionary that maps all mmCIF tags in an mmCIF file to their values. Whether there are multiple values (like in the case of tag , which holds the y coordinates of all atoms) or a single value (like the initial deposition date), the tag is mapped to a list of values. The dictionary is created from the mmCIF file as follows:\n\nExample: get the solvent content from an mmCIF file:\n\nExample: get the list of the y coordinates of all atoms\n\nYou can use the direct MMTFParser to read a structure from a file:\n\nOr you can use the same class to get a structure by its PDB ID:\n\nThis gives you a Structure object as if read from a PDB or mmCIF file.\n\nYou can also have access to the underlying data using the external MMTF library which Biopython is using internally:\n\nFor example you can access just the X-coordinate.\n\nThe PERMISSIVE flag indicates that a number of common problems (see 14.7.1) associated with PDB files will be ignored (but note that some atoms and/or residues will be missing). If the flag is not present a PDBConstructionException will be generated if any problems are detected during the parse operation.\n\nThe Structure object is then produced by letting the PDBParser object parse a PDB file (the PDB file in this case is called , is a user defined name for the structure):\n\nYou can extract the header and trailer (simple lists of strings) of the PDB file from the PDBParser object with the get_header and get_trailer methods. Note however that many PDB files contain headers with incomplete or erroneous information. Many of the errors have been fixed in the equivalent mmCIF files. Hence, if you are interested in the header information, it is a good idea to extract information from mmCIF files using the MMCIF2Dict tool described above, instead of parsing the PDB header.\n\nNow that is clarified, let’s return to parsing the PDB header. The structure object has an attribute called header which is a Python dictionary that maps header records to their values.\n\nThe available keys are , , , , , , (which maps to a list of references), , , (which maps to a dictionary with various information about the crystallized compound), , , and (which maps to dictionary with additional information about the domain if present).\n\nmaps to a bool that is True if at least one non-empty header line was found. In this case you should assume that the molecule used in the experiment has some residues for which no ATOM coordinates could be determined. maps to a list of dictionaries with information about the missing residues. The list of missing residues will be empty or incomplete if the PDB header does not follow the template from the PDB specification.\n\nThe dictionary can also be created without creating a Structure object, ie. directly from the PDB file:\n\nIn order to parse a PQR file, proceed in a similar manner as in the case of PDB files:\n\nThe is_pqr flag set to True indicates that the file to be parsed is a PQR file, and that the parser should read the atomic charge and radius fields for each atom entry. Following the same procedure as for PQR files, a Structure object is then produced, and the PQR file is parsed.\n\nThat’s not yet supported, but we are definitely planning to support that in the future (it’s not a lot of work). Contact the Biopython developers via the mailing list if you need this.\n\nThe MMCIFIO class can be used to write structures to the mmCIF file format:\n\nThe Select class can be used in a similar way to PDBIO below. mmCIF dictionaries read using MMCIF2Dict can also be written:\n\nUse the PDBIO class for this. It’s easy to write out specific parts of a structure too, of course.\n\nIf you want to write out a part of the structure, make use of the Select class (also in PDBIO). Select has four methods:\n\nBy default, every method returns 1 (which means the model/­chain/­residue/­atom is included in the output). By subclassing Select and returning 0 when appropriate you can exclude models, chains, etc. from the output. Cumbersome maybe, but very powerful. The following code only writes out glycine residues:\n\nIf this is all too complicated for you, the Dice module contains a handy extract function that writes out all residues in a chain between a start and end residue.\n\nUse the PDBIO class as you would for a PDB file, with the flag is_pqr=True. The PDBIO methods can be used in the case of PQR files as well.\n\nTo write structures to the MMTF file format:\n\nThe Select class can be used as above. Note that the bonding information, secondary structure assignment and some other information contained in standard MMTF files is not written out as it is not easy to determine from the structure object. In addition, molecules that are grouped into the same entity in standard MMTF files are treated as separate entities by MMTFIO.\n\nThe overall layout of a Structure object follows the so-called SMCRA (Structure/Model/Chain/Residue/Atom) architecture:\n\nThis is the way many structural biologists/bioinformaticians think about structure, and provides a simple but efficient way to deal with structure. Additional stuff is essentially added when needed. A UML diagram of the Structure object (forget about the Disordered classes for now) is shown in Figure 14.1. Such a data structure is not necessarily best suited for the representation of the macromolecular content of a structure, but it is absolutely necessary for a good interpretation of the data present in a file that describes the structure (typically a PDB or MMCIF file). If this hierarchy cannot represent the contents of a structure file, it is fairly certain that the file contains an error or at least does not describe the structure unambiguously. If a SMCRA data structure cannot be generated, there is reason to suspect a problem. Parsing a PDB file can thus be used to detect likely problems. We will give several examples of this in section 14.7.1.\n\nStructure, Model, Chain and Residue are all subclasses of the Entity base class. The Atom class only (partly) implements the Entity interface (because an Atom does not have children).\n\nFor each Entity subclass, you can extract a child by using a unique id for that child as a key (e.g. you can extract an Atom object from a Residue object by using an atom name string as a key, you can extract a Chain object from a Model object by using its chain identifier as a key).\n\nDisordered atoms and residues are represented by DisorderedAtom and DisorderedResidue classes, which are both subclasses of the DisorderedEntityWrapper base class. They hide the complexity associated with disorder and behave exactly as Atom and Residue objects.\n\nIn general, a child Entity object (i.e. Atom, Residue, Chain, Model) can be extracted from its parent (i.e. Residue, Chain, Model, Structure, respectively) by using an id as a key.\n\nYou can also get a list of all child Entities of a parent Entity object. Note that this list is sorted in a specific way (e.g. according to chain identifier for Chain objects in a Model object).\n\nYou can also get the parent from a child:\n\nAt all levels of the SMCRA hierarchy, you can also extract a full id. The full id is a tuple containing all id’s starting from the top object (Structure) down to the current object. A full id for a Residue object e.g. is something like:\n\nThe Residue id indicates that the residue is not a hetero-residue (nor a water) because it has a blank hetero field, that its sequence identifier is 10 and that its insertion code is .\n\nTo get the entity’s id, use the method:\n\nYou can check if the entity has a child with a given id by using the method:\n\nThe length of an entity is equal to its number of children:\n\nIt is possible to delete, rename, add, etc. child entities from a parent entity, but this does not include any sanity checks (e.g. it is possible to add two residues with the same id to one chain). This really should be done via a nice Decorator class that includes integrity checking, but you can take a look at the code (Entity.py) if you want to use the raw interface.\n\nThe Structure object is at the top of the hierarchy. Its id is a user given string. The Structure contains a number of Model children. Most crystal structures (but not all) contain a single model, while NMR structures typically consist of several models. Disorder in crystal structures of large parts of molecules can also result in several models.\n\nThe id of the Model object is an integer, which is derived from the position of the model in the parsed file (they are automatically numbered starting from 0). Crystal structures generally have only one model (with id 0), while NMR files usually have several models. Whereas many PDB parsers assume that there is only one model, the class in is designed such that it can easily handle PDB files with more than one model.\n\nAs an example, to get the first model from a Structure object, use\n\nThe id of a Chain object is derived from the chain identifier in the PDB/mmCIF file, and is a single character (typically a letter). Each Chain in a Model object has a unique id. As an example, to get the Chain object with identifier “A” from a Model object, use\n\nA residue id is a tuple with three elements:\n• The (hetfield): this is\n• in the case of a water molecule;\n• followed by the residue name for other hetero residues (e.g. in the case of a glucose molecule); This scheme is adopted for reasons described in section 14.4.1.\n• The (resseq), an integer describing the position of the residue in the chain (e.g., 100);\n• The (icode); a string, e.g. ’A’. The insertion code is sometimes used to preserve a certain desirable residue numbering scheme. A Ser 80 insertion mutant (inserted e.g. between a Thr 80 and an Asn 81 residue) could e.g. have sequence identifiers and insertion codes as follows: Thr 80 A, Ser 80 B, Asn 81. In this way the residue numbering scheme stays in tune with that of the wild type structure.\n\nThe id of the above glucose residue would thus be (’H_GLC’, 100, ’A’). If the hetero-flag and insertion code are blank, the sequence identifier alone can be used:\n\nThe reason for the hetero-flag is that many, many PDB files use the same sequence identifier for an amino acid and a hetero-residue or a water, which would create obvious problems if the hetero-flag was not used.\n\nUnsurprisingly, a Residue object stores a set of Atom children. It also contains a string that specifies the residue name (e.g. “ASN”) and the segment identifier of the residue (well known to X-PLOR users, but not used in the construction of the SMCRA data structure).\n\nLet’s look at some examples. Asn 10 with a blank insertion code would have residue id (’ ’, 10, ’ ’). Water 10 would have residue id (’W’, 10, ’ ’). A glucose molecule (a hetero residue with residue name GLC) with sequence identifier 10 would have residue id (’H_GLC’, 10, ’ ’). In this way, the three residues (with the same insertion code and sequence identifier) can be part of the same chain because their residue id’s are distinct.\n\nIn most cases, the hetflag and insertion code fields will be blank, e.g. (’ ’, 10, ’ ’). In these cases, the sequence identifier can be used as a shortcut for the full id:\n\nEach Residue object in a Chain object should have a unique id. However, disordered residues are dealt with in a special way, as described in section 14.3.3.\n\nYou can use is_aa(residue) to test if a Residue object is an amino acid.\n\nThe Atom object stores the data associated with an atom, and has no children. The id of an atom is its atom name (e.g. “OG” for the side chain oxygen of a Ser residue). An Atom id needs to be unique in a Residue. Again, an exception is made for disordered atoms, as described in section 14.3.2.\n\nThe atom id is simply the atom name (eg. ’CA’). In practice, the atom name is created by stripping all spaces from the atom name in the PDB file.\n\nHowever, in PDB files, a space can be part of an atom name. Often, calcium atoms are called ’CA..’ in order to distinguish them from Cα atoms (which are called ’.CA.’). In cases were stripping the spaces would create problems (ie. two atoms called ’CA’ in the same residue) the spaces are kept.\n\nIn a PDB file, an atom name consists of 4 chars, typically with leading and trailing spaces. Often these spaces can be removed for ease of use (e.g. an amino acid C α atom is labeled “.CA.” in a PDB file, where the dots represent spaces). To generate an atom name (and thus an atom id) the spaces are removed, unless this would result in a name collision in a Residue (i.e. two Atom objects with the same atom name and id). In the latter case, the atom name including spaces is tried. This situation can e.g. happen when one residue contains atoms with names “.CA.” and “CA..”, although this is not very likely.\n\nThe atomic data stored includes the atom name, the atomic coordinates (including standard deviation if present), the B factor (including anisotropic B factors and standard deviation if present), the altloc specifier and the full atom name including spaces. Less used items like the atom element number or the atomic charge sometimes specified in a PDB file are not stored.\n\nTo manipulate the atomic coordinates, use the transform method of the Atom object. Use the set_coord method to specify the atomic coordinates directly.\n\nAn Atom object has the following additional methods:\n\nTo represent the atom coordinates, siguij, anisotropic B factor and sigatm Numpy arrays are used.\n\nThe get_vector method returns a Vector object representation of the coordinates of the Atom object, allowing you to do vector operations on atomic coordinates. Vector implements the full set of 3D vector operations, matrix multiplication (left and right) and some advanced rotation-related operations as well.\n\nAs an example of the capabilities of Bio.PDB’s Vector module, suppose that you would like to find the position of a Gly residue’s Cβ atom, if it had one. Rotating the N atom of the Gly residue along the Cα-C bond over -120 degrees roughly puts it in the position of a virtual Cβ atom. Here’s how to do it, making use of the rotaxis method (which can be used to construct a rotation around a certain axis) of the Vector module:\n\nThis example shows that it’s possible to do some quite nontrivial vector operations on atomic data, which can be quite useful. In addition to all the usual vector operations (cross (use **), and dot (use *) product, angle, norm, etc.) and the above mentioned rotaxis function, the Vector module also has methods to rotate (rotmat) or reflect (refmat) one vector on top of another.\n\nThese are some examples:\n\nNote that you can use a shortcut:\n\nBio.PDB can handle both disordered atoms and point mutations (i.e. a Gly and an Ala residue in the same position).\n\nDisorder should be dealt with from two points of view: the atom and the residue points of view. In general, we have tried to encapsulate all the complexity that arises from disorder. If you just want to loop over all Cα atoms, you do not care that some residues have a disordered side chain. On the other hand it should also be possible to represent disorder completely in the data structure. Therefore, disordered atoms or residues are stored in special objects that behave as if there is no disorder. This is done by only representing a subset of the disordered atoms or residues. Which subset is picked (e.g. which of the two disordered OG side chain atom positions of a Ser residue is used) can be specified by the user.\n\nDisordered atoms are represented by ordinary Atom objects, but all Atom objects that represent the same physical atom are stored in a Disordered­Atom object (see Figure 14.1). Each Atom object in a Disordered­Atom object can be uniquely indexed using its altloc specifier. The Disordered­Atom object forwards all uncaught method calls to the selected Atom object, by default the one that represents the atom with the highest occupancy. The user can of course change the selected Atom object, making use of its altloc specifier. In this way atom disorder is represented correctly without much additional complexity. In other words, if you are not interested in atom disorder, you will not be bothered by it.\n\nEach disordered atom has a characteristic altloc identifier. You can specify that a Disordered­Atom object should behave like the Atom object associated with a specific altloc identifier:\n\nThe most common case is a residue that contains one or more disordered atoms. This is evidently solved by using DisorderedAtom objects to represent the disordered atoms, and storing the DisorderedAtom object in a Residue object just like ordinary Atom objects. The DisorderedAtom will behave exactly like an ordinary atom (in fact the atom with the highest occupancy) by forwarding all uncaught method calls to one of the Atom objects (the selected Atom object) it contains.\n\nA special case arises when disorder is due to a point mutation, i.e. when two or more point mutants of a polypeptide are present in the crystal. An example of this can be found in PDB structure 1EN2.\n\nSince these residues belong to a different residue type (e.g. let’s say Ser 60 and Cys 60) they should not be stored in a single Residue object as in the common case. In this case, each residue is represented by one Residue object, and both Residue objects are stored in a single Disordered­Residue object (see Figure 14.1).\n\nThe Dis­ordered­Residue object forwards all un­caught methods to the selected Residue object (by default the last Residue object added), and thus behaves like an ordinary residue. Each Residue object in a Disordered­Residue object can be uniquely identified by its residue name. In the above example, residue Ser 60 would have id “SER” in the Disordered­Residue object, while residue Cys 60 would have id “CYS”. The user can select the active Residue object in a Disordered­Residue object via this id.\n\nExample: suppose that a chain has a point mutation at position 10, consisting of a Ser and a Cys residue. Make sure that residue 10 of this chain behaves as the Cys residue.\n\nIn addition, you can get a list of all Atom objects (ie. all DisorderedAtom objects are ’unpacked’ to their individual Atom objects) using the get_unpacked_list method of a (Disordered)­Residue object.\n\nA common problem with hetero residues is that several hetero and non-hetero residues present in the same chain share the same sequence identifier (and insertion code). Therefore, to generate a unique id for each hetero residue, waters and other hetero residues are treated in a different way.\n\nRemember that Residue object have the tuple (hetfield, resseq, icode) as id. The hetfield is blank (“ ”) for amino and nucleic acids, and a string for waters and other hetero residues. The content of the hetfield is explained below.\n\nThe hetfield string of a water residue consists of the letter “W”. So a typical residue id for a water is (“W”, 1, “ ”).\n\nThe hetfield string for other hetero residues starts with “H_” followed by the residue name. A glucose molecule e.g. with residue name “GLC” would have hetfield “H_GLC”. Its residue id could e.g. be (“H_GLC”, 1, “ ”).\n\nParse a PDB file, and extract some Model, Chain, Residue and Atom objects\n\nIterating through all atoms of a structure\n\nThere is a shortcut if you want to iterate over all atoms in a structure:\n\nSimilarly, to iterate over all atoms in a chain, use\n\nIterating over all residues of a model\n\nor if you want to iterate over all residues in a model:\n\nYou can also use the function to get all residues from a structure:\n\nor to get all atoms from a chain:\n\nObviously, . You can use this to go up in the hierarchy, e.g. to get a list of (unique) or parents from a list of :\n\nFor more info, see the API documentation.\n\nPrint out coordinates of all CA atoms in structure with B factor over 50\n\nPrint out all the residues that contain disordered atoms\n\nLoop over all disordered atoms, and select all atoms with altloc A (if present)\n\nThis will make sure that the SMCRA data structure will behave as if only the atoms with altloc A are present.\n\nTo extract polypeptides from a structure, construct a list of Polypeptide objects from a Structure object using PolypeptideBuilder as follows:\n\nA Polypeptide object is simply a UserList of Residue objects, and is always created from a single Model (in this case model 1). You can use the resulting Polypeptide object to get the sequence as a Seq object or to get a list of Cα atoms as well. Polypeptides can be built using a C-N or a Cα-Cα distance criterion.\n\nNote that in the above case only model 0 of the structure is considered by PolypeptideBuilder. However, it is possible to use PolypeptideBuilder to build Polypeptide objects from Model and Chain objects as well.\n\nThe first thing to do is to extract all polypeptides from the structure (as above). The sequence of each polypeptide can then easily be obtained from the Polypeptide objects. The sequence is represented as a Biopython Seq object.\n\nThe minus operator for atoms has been overloaded to return the distance between two atoms.\n\nUse the vector representation of the atomic coordinates, and the calc_angle function from the Vector module:\n\nUse the vector representation of the atomic coordinates, and the calc_dihedral function from the Vector module:\n\nProtein structures are normally supplied in 3D XYZ coordinates relative to a fixed origin, as in a PDB or mmCIF file. The internal_coords module facilitates converting this system to and from bond lengths, angles and dihedral angles. In addition to supporting standard psi, phi, chi, etc. calculations on protein structures, this representation is invariant to translation and rotation, and the implementation exposes multiple benefits for structure analysis.\n\nFirst load up some modules here for later examples:\n\nWe start with the simple case of computing internal coordinates for a structure:\n\nThe chain break warnings for 1A8O are suppressed by removing the verbose=True option above. To avoid the creation of a break and instead allow unrealistically long N-C bonds, override the class variable MaxPeptideBond, e.g.:\n\nAt this point the values are available at both the chain and residue level. The first residue of 1A8O is HETATM MSE (selenomethionine), so we investigate residue 2 below using either canonical names or atom specifiers. Here we obtain the chi1 dihedral and tau angles by name and by atom sequence, and the Cα-Cβ distance by specifying the atom pair:\n\nThe Chain.internal_coord object holds arrays and dictionaries of hedra (3 bonded atoms) and dihedra (4 bonded atoms) objects. The dictionaries are indexed by tuples of AtomKey objects; AtomKey objects capture residue position, insertion code, 1 or 3-character residue name, atom name, altloc and occupancy.\n\nBelow we obtain the same chi1 and tau angles as above by indexing the Chain arrays directly, using AtomKeys to index the Chain arrays:\n\nObtaining bond length data at the Chain level is more complicated (and not recommended). As shown here, multiple hedra will share a single bond in different positions:\n\nPlease use the Residue level set_length function instead.\n\nMissing atoms and other issues can cause problems when rebuilding a structure. Use structure_rebuild_test to determine quickly if a structure has sufficient data for a clean rebuild. Add verbose=True and/or inspect the result dictionary for more detail:\n\nIt’s preferable to use the residue level set_angle and set_length facilities for modifying internal coordinates rather than directly accessing the Chain structures. While directly modifying hedra angles is safe, bond lengths appear in multiple overlapping hedra as noted above, and this is handled by set_length. When applied to a dihedral angle, set_angle will wrap the result to +/-180 and rotate adjacent dihedra as well (such as both bonds for an isoleucine chi1 angle - which is probably what you want).\n\nRebuilding a structure from internal coordinates is a simple call to :\n\nThe generated structure can be written with PDBIO, as normal:\n\nA file format is defined in the PICIO module to describe protein chains as hedra and dihedra relative to initial coordinates. All parts of the file other than the residue sequence information (e.g. (’1A8O’, 0, ’A’, (’ ’, 153, ’ ’)) ILE) are optional, and will be filled in with default values if not specified and read_PIC is called with the defaults=True option. Default values are calculated from Sep 2019 Dunbrack cullpdb_pc20_res2.2_R1.0.\n\nHere we write ‘myChain’ as a .pic file of internal coordinate specifications and then read it back in as ‘myProtein2’.\n\nAs all internal coordinate values can be replaced with defaults, PICIO.read_PIC_seq is supplied as a utility function to create a valid (mostly helical) default structure from an input sequence:\n\nIt may be of interest to explore the accuracy required in e.g. omega angles (180.0), hedra angles and/or bond lengths when generating structures from internal coordinates. The picFlags option to write_PIC enables this, allowing the selection of data to be written to the .pic file vs. left unspecified to get default values.\n\nVarious combinations are possible and some presets are supplied, for example classic will write only psi, phi, tau, proline omega and sidechain chi angles to the .pic file:\n\nAll 3D XYZ coordinates in Biopython Atom objects are moved to a single large array in the Chain class and replaced by Numpy ‘views’ into this array in an early step of atom_to_internal_coordinates. Software accessing Biopython Atom coordinates is not affected, but the new array may offer efficiencies for future work.\n\nUnlike the Atom XYZ coordinates, AtomArray coordinates are homogeneous, meaning they are arrays like [ x y z 1.0] with 1.0 as the fourth element. This facilitates efficient transformation using combined translation and rotation matrices throughout the internal_coords module. There is a corresponding AtomArrayIndex dictionary, mapping AtomKeys to their coordinates.\n\nHere we demonstrate reading coordinates for a specific Cβ atom from the array, then show that modifying the array value modifies the Atom object at the same time:\n\nNote that it is easy to ‘break’ the view linkage between the Atom coord arrays and the chain atomArray. When modifying Atom coordinates directly, use syntax for an element-by-element copy to avoid this:\n\nUsing the atomArrayIndex and knowledge of the AtomKey class enables us to create Numpy ‘selectors’, as shown below to extract an array of only the Cα atom coordinates:\n\nA benefit of the atomArray is that generating a distance plot from it is a single line of Numpy code:\n\nDespite its briefness, the idiom cam be difficult to remember and in the form above generates all-atom distances rather than the classic Cα plot as may be desired. The distance_plot method wraps the line above and accepts an optional selector like CaSelect defined in the previous section. See Figure 14.2.\n\nThe all-atom distance plot is another representation of a protein structure, also invariant to translation and rotation but lacking in chirality information (a mirror-image structure will generate the same distance plot). By combining the distance matrix with the signs of each dihedral angle, it is possible to regenerate the internal coordinates.\n\nThis work uses equations developed by Blue, the Hedronometer, discussed in https://math.stackexchange.com/a/49340/409 and further in http://daylateanddollarshort.com/mathdocs/Heron-like-Results-for-Tetrahedral-Volume.pdf.\n\nTo begin, we extract the distances and chirality values from ‘myChain’:\n\nWe need a valid data structure matching ‘myChain’ to correctly rebuild it; using read_PIC_seq above would work in the general case, but the 1A8O example used here has some ALTLOC complexity which the sequence alone would not generate. For demonstration the easiest approach is to simply duplicate the ‘myChain’ structure, but we set all the atom and internal coordinate chain arrays to 0s (only for demonstration) just to be certain there is no data coming through from the original structure:\n\nThe approach is to regenerate the internal coordinates from the distance plot data, then generate the atom coordinates from the internal coordinates as shown above. To place the final generated structure in the same coordinate space as the starting structure, we copy just the coordinates for the first three N-Cα-C atoms from the chain start of ‘myChain’ to the ‘myChain2’ structure (this is only needed to demonstrate equivalence at end):\n\nThe distance_to_internal_coordinates routine needs arrays of the six inter-atom distances for each dihedron for the target structure. The convenience routine distplot_to_dh_arrays extracts these values from the previously generated distance matrix as needed, and may be replaced by a user method to write these data to the arrays in the Chain.internal_coords object.\n\nThe steps below generate the atom coordinates from the newly generated ‘myChain2’ internal coordinates, then use the Numpy allclose routine to confirm that all values match to better than PDB file resolution:\n\nNote that this procedure does not use the entire distance matrix, but only the six local distances between the four atoms of each dihedral angle.\n\nThe internal_coords module relies on transforming atom coordinates between different coordinate spaces for both calculation of torsion angles and reconstruction of structures. Each dihedron has a coordinate space transform placing its first atom on the XZ plane, second atom at the origin, and third atom on the +Z axis, as well as a corresponding reverse transform which will return it to the coordinates in the original structure. These transform matrices are available to use as shown below. By judicious choice of a reference dihedron, pairwise and higher order residue intereactions can be investigated and visualized across multiple protein structures, e.g. Figure 14.3.\n\nThis example superimposes each PHE residue in a chain on its N-Cα-Cβ atoms, and presents all PHEs in the chain in the respective coordinate space as a simple demonstration. A more realistic exploration of pairwise sidechain interactions would examine a dataset of structures and filter for interaction classes as discussed in the relevant literature.\n\nOpenSCAD (https://openscad.org) is a language for creating solid 3D CAD objects. The algorithm to construct a protein structure from internal coordinates is supplied in OpenSCAD with data describing a structure, such that a model can be generated suitable for 3D printing. While other software can generate STL data as a rendering option for 3D printing (e.g. Chimera, https://www.cgl.ucsf.edu/chimera/), this approach generates spheres and cylinders as output and is therefore more amenable to modifications relevant to 3D printing protein structures. Individual residues and bonds can be selected in the OpenSCAD code for special handling, such as highlighting by size or adding rotatable bonds in specific positions (see https://www.thingiverse.com/thing:3957471 for an example).\n\nA few control attributes are available in the internal_coords classes to modify or filter data as internal coordinates are calculated. These are listed in Table 14.1:\n\nUse NeighborSearch to perform neighbor lookup. The neighbor lookup is done using a KD tree module written in C (see the KDTree class in module Bio.PDB.kdtrees), making it very fast. It also includes a fast method to find all point pairs within a certain distance of each other.\n\nUse a Superimposer object to superimpose two coordinate sets. This object calculates the rotation and translation matrix that rotates two lists of atoms on top of each other in such a way that their RMSD is minimized. Of course, the two lists need to contain the same number of atoms. The Superimposer object can also apply the rotation/translation to a list of atoms. The rotation and translation are stored as a tuple in the rotran attribute of the Superimposer object (note that the rotation is right multiplying!). The RMSD is stored in the rmsd attribute.\n\nThe algorithm used by Superimposer comes from [15, Golub & Van Loan] and makes use of singular value decomposition (this is implemented in the general Bio.SVDSuperimposer module).\n\nTo superimpose two structures based on their active sites, use the active site atoms to calculate the rotation/translation matrices (as above), and apply these to the whole molecule.\n\n14.6.7 Mapping the residues of two related structures onto each other\n\nFirst, create an alignment file in FASTA format, then use the StructureAlignment class. This class can also be used for alignments with more than two structures.\n\nHalf Sphere Exposure (HSE) is a new, 2D measure of solvent exposure [18]. Basically, it counts the number of Cα atoms around a residue in the direction of its side chain, and in the opposite direction (within a radius of 13 Å. Despite its simplicity, it outperforms many other measures of solvent exposure.\n\nHSE comes in two flavors: HSEα and HSEβ. The former only uses the Cα atom positions, while the latter uses the Cα and Cβ atom positions. The HSE measure is calculated by the HSExposure class, which can also calculate the contact number. The latter class has methods which return dictionaries that map a Residue object to its corresponding HSEα, HSEβ and contact number values.\n\nFor this functionality, you need to install DSSP (and obtain a license for it — free for academic use, see https://swift.cmbi.umcn.nl/gv/dssp/). Then use the DSSP class, which maps Residue objects to their secondary structure (and accessible surface area). The DSSP codes are listed in Table 14.2. Note that DSSP (the program, and thus by consequence the class) cannot handle multiple models!\n\nThe DSSP class can also be used to calculate the accessible surface area of a residue. But see also section 14.6.10.\n\nResidue depth is the average distance of a residue’s atoms from the solvent accessible surface. It’s a fairly new and very powerful parameterization of solvent accessibility. For this functionality, you need to install Michel Sanner’s MSMS program (https://www.scripps.edu/sanner/html/msms_home.html). Then use the ResidueDepth class. This class behaves as a dictionary which maps Residue objects to corresponding (residue depth, Cα depth) tuples. The Cα depth is the distance of a residue’s Cα atom to the solvent accessible surface.\n\nYou can also get access to the molecular surface itself (via the get_surface function), in the form of a Numeric Python array with the surface points.\n\nIt is well known that many PDB files contain semantic errors (not the structures themselves, but their representation in PDB files). Bio.PDB tries to handle this in two ways. The PDBParser object can behave in two ways: a restrictive way and a permissive way, which is the default.\n\nIn the permissive state (DEFAULT), PDB files that obviously contain errors are “corrected” (i.e. some residues or atoms are left out). These errors include:\n• Multiple residues with the same identifier\n• Multiple atoms with the same identifier (taking into account the altloc identifier)\n\nThese errors indicate real problems in the PDB file (for details see [16, Hamelryck and Manderick, 2003]). In the restrictive state, PDB files with errors cause an exception to occur. This is useful to find errors in PDB files.\n\nSome errors however are automatically corrected. Normally each disordered atom should have a non-blank altloc identifier. However, there are many structures that do not follow this convention, and have a blank and a non-blank identifier for two disordered positions of the same atom. This is automatically interpreted in the right way.\n\nSometimes a structure contains a list of residues belonging to chain A, followed by residues belonging to chain B, and again followed by residues belonging to chain A, i.e. the chains are ’broken’. This is also correctly interpreted.\n\nThe PDBParser/Structure class was tested on about 800 structures (each belonging to a unique SCOP superfamily). This takes about 20 minutes, or on average 1.5 seconds per structure. Parsing the structure of the large ribosomal subunit (1FKK), which contains about 64000 atoms, takes 10 seconds on a 1000 MHz PC.\n\nThree exceptions were generated in cases where an unambiguous data structure could not be built. In all three cases, the likely cause is an error in the PDB file that should be corrected. Generating an exception in these cases is much better than running the chance of incorrectly describing the structure in a data structure.\n\nOne structure contains two amino acid residues in one chain with the same sequence identifier (resseq 3) and icode. Upon inspection it was found that this chain contains the residues Thr A3, …, Gly A202, Leu A3, Glu A204. Clearly, Leu A3 should be Leu A203. A couple of similar situations exist for structure 1FFK (which e.g. contains Gly B64, Met B65, Glu B65, Thr B67, i.e. residue Glu B65 should be Glu B66).\n\nStructure 1EJG contains a Ser/Pro point mutation in chain A at position 22. In turn, Ser 22 contains some disordered atoms. As expected, all atoms belonging to Ser 22 have a non-blank altloc specifier (B or C). All atoms of Pro 22 have altloc A, except the N atom which has a blank altloc. This generates an exception, because all atoms belonging to two residues at a point mutation should have non-blank altloc. It turns out that this atom is probably shared by Ser and Pro 22, as Ser 22 misses the N atom. Again, this points to a problem in the file: the N atom should be present in both the Ser and the Pro residue, in both cases associated with a suitable altloc identifier.\n\nSome errors are quite common and can be easily corrected without much risk of making a wrong interpretation. These cases are listed below.\n\nNormally each disordered atom should have a non-blank altloc identifier. However, there are many structures that do not follow this convention, and have a blank and a non-blank identifier for two disordered positions of the same atom. This is automatically interpreted in the right way.\n\nSometimes a structure contains a list of residues belonging to chain A, followed by residues belonging to chain B, and again followed by residues belonging to chain A, i.e. the chains are “broken”. This is correctly interpreted.\n\nSometimes a PDB file cannot be unambiguously interpreted. Rather than guessing and risking a mistake, an exception is generated, and the user is expected to correct the PDB file. These cases are listed below.\n\nAll residues in a chain should have a unique id. This id is generated based on:\n• The hetfield string (“W” for waters and “H_” followed by the residue name for other hetero residues)\n• The residue names of the residues in the case of point mutations (to store the Residue objects in a DisorderedResidue object).\n\nIf this does not lead to a unique id something is quite likely wrong, and an exception is generated.\n\nAll atoms in a residue should have a unique id. This id is generated based on:\n• The atom name (without spaces, or with spaces if a problem arises).\n\nIf this does not lead to a unique id something is quite likely wrong, and an exception is generated.\n\nStructures can be downloaded from the PDB (Protein Data Bank) by using the retrieve_pdb_file method on a PDBList object. The argument for this method is the PDB identifier of the structure.\n\nThe PDBList class can also be used as a command-line tool:\n\nThe downloaded file will be called pdb1fat.ent and stored in the current working directory. Note that the retrieve_pdb_file method also has an optional argument pdir that specifies a specific directory in which to store the downloaded PDB files.\n\nThe retrieve_pdb_file method also has some options to specify the compression format used for the download, and the program used for local decompression (default .Z format and gunzip). In addition, the PDB ftp site can be specified upon creation of the PDBList object. By default, the server of the Worldwide Protein Data Bank (ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/) is used. See the API documentation for more details. Thanks again to Kristian Rother for donating this module.\n\nThe following commands will store all PDB files in the /data/pdb directory:\n\nThe API method for this is called download_entire_pdb. Adding the -d option will store all files in the same directory. Otherwise, they are sorted into PDB-style subdirectories according to their PDB ID’s. Depending on the traffic, a complete download will take 2-4 days.\n\n14.8.3 Keeping a local copy of the PDB up to date\n\nThis can also be done using the PDBList object. One simply creates a PDBList object (specifying the directory where the local copy of the PDB is present) and calls the update_pdb method:\n\nOne can of course make a weekly cronjob out of this to keep the local copy automatically up-to-date. The PDB ftp site can also be specified (see API documentation).\n\nPDBList has some additional methods that can be of use. The get_all_obsolete method can be used to get a list of all obsolete PDB entries. The changed_this_week method can be used to obtain the entries that were added, modified or obsoleted during the current week. For more info on the possibilities of PDBList, see the API documentation.\n\n14.9.1 How well tested is Bio.PDB?\n\nPretty well, actually. Bio.PDB has been extensively tested on nearly 5500 structures from the PDB - all structures seemed to be parsed correctly. More details can be found in the Bio.PDB Bioinformatics article. Bio.PDB has been used/is being used in many research projects as a reliable tool. In fact, I’m using Bio.PDB almost daily for research purposes and continue working on improving it and adding new features.\n\n14.9.2 How fast is it?\n\nThe PDBParser performance was tested on about 800 structures (each belonging to a unique SCOP superfamily). This takes about 20 minutes, or on average 1.5 seconds per structure. Parsing the structure of the large ribosomal subunit (1FKK), which contains about 64000 atoms, takes 10 seconds on a 1000 MHz PC. In short: it’s more than fast enough for many applications.\n\n14.9.3 Is there support for molecular graphics?\n\nNot directly, mostly since there are quite a few Python based/Python aware solutions already, that can potentially be used with Bio.PDB. My choice is Pymol, BTW (I’ve used this successfully with Bio.PDB, and there will probably be specific PyMol modules in Bio.PDB soon/some day). Python based/aware molecular graphics solutions include:\n\nBio.PDB was used in the construction of DISEMBL, a web server that predicts disordered regions in proteins (http://dis.embl.de/). Bio.PDB has also been used to perform a large scale search for active sites similarities between protein structures in the PDB [17, Hamelryck, 2003], and to develop a new algorithm that identifies linear secondary structure elements [31, Majumdar et al., 2005].\n\nJudging from requests for features and information, Bio.PDB is also used by several LPCs (Large Pharmaceutical Companies :-).\n\nis a Biopython module supporting population genetics, available in Biopython 1.44 onwards. The objective for the module is to support widely used data formats, applications and databases.\n\nGenePop (http://genepop.curtin.edu.au/) is a popular population genetics software package supporting Hardy-Weinberg tests, linkage disequilibrium, population differentiation, basic statistics, F and migration estimates, among others. GenePop does not supply sequence based statistics as it doesn’t handle sequence data. The GenePop file format is supported by a wide range of other population genetic software applications, thus making it a relevant format in the population genetics field.\n\nprovides a parser and generator of GenePop file format. Utilities to manipulate the content of a record are also provided. Here is an example on how to read a GenePop file (you can find example GenePop data files in the Test/PopGen directory of Biopython):\n\nThis will read a file called example.gen and parse it. If you do print rec, the record will be output again, in GenePop format.\n\nThe most important information in rec will be the loci names and population information (but there is more – use help(GenePop.Record) to check the API documentation). Loci names can be found on rec.loci_list. Population information can be found on rec.populations. Populations is a list with one element per population. Each element is itself a list of individuals, each individual is a pair composed by individual name and a list of alleles (2 per marker), here is an example for rec.populations:\n\nSo we have two populations, the first with two individuals, the second with only one. The first individual of the first population is called Ind1, allelic information for each of the 3 loci follows. Please note that for any locus, information might be missing (see as an example, Ind2 above).\n\nA few utility functions to manipulate GenePop records are made available, here is an example:\n\nGenePop does not support population names, a limitation which can be cumbersome at times. Functionality to enable population names is currently being planned for Biopython. These extensions won’t break compatibility in any way with the standard format. In the medium term, we would also like to support the GenePop web service.\n\nThe Bio.Phylo module was introduced in Biopython 1.54. Following the lead of SeqIO and AlignIO, it aims to provide a common way to work with phylogenetic trees independently of the source data format, as well as a consistent API for I/O operations.\n\nBio.Phylo is described in an open-access journal article [45, Talevich et al., 2012], which you might also find helpful.\n\nTo get acquainted with the module, let’s start with a tree that we’ve already constructed, and inspect it a few different ways. Then we’ll colorize the branches, to use a special phyloXML feature, and finally save it.\n\nCreate a simple Newick file named simple.dnd using your favorite text editor, or use simple.dnd provided with the Biopython source code:\n\nThis tree has no branch lengths, only a topology and labeled terminals. (If you have a real tree file available, you can follow this demo using that instead.)\n\nLaunch the Python interpreter of your choice:\n\nFor interactive work, launching the IPython interpreter with the flag enables matplotlib integration, so graphics will pop up automatically. We’ll use that during this demo.\n\nNow, within Python, read the tree file, giving the file name and the name of the format.\n\nPrinting the tree object as a string gives us a look at the entire object hierarchy.\n\nThe Tree object contains global information about the tree, such as whether it’s rooted or unrooted. It has one root clade, and under that, it’s nested lists of clades all the way down to the tips.\n\nThe function creates a simple ASCII-art (plain text) dendrogram. This is a convenient visualization for interactive exploration, in case better graphical tools aren’t available.\n\nIf you have matplotlib or pylab installed, you can create a graphical tree using the function.\n\nThe function supports the display of different colors and branch widths in a tree. As of Biopython 1.59, the and attributes are available on the basic Clade object and there’s nothing extra required to use them. Both attributes refer to the branch leading the given clade, and apply recursively, so all descendent branches will also inherit the assigned width and color values during display.\n\nIn earlier versions of Biopython, these were special features of PhyloXML trees, and using the attributes required first converting the tree to a subclass of the basic tree object called Phylogeny, from the Bio.Phylo.PhyloXML module.\n\nIn Biopython 1.55 and later, this is a convenient tree method:\n\nIn Biopython 1.54, you can accomplish the same thing with one extra import:\n\nNote that the file formats Newick and Nexus don’t support branch colors or widths, so if you use these attributes in Bio.Phylo, you will only be able to save the values in PhyloXML format. (You can still save a tree as Newick or Nexus, but the color and width values will be skipped in the output file.)\n\nNow we can begin assigning colors. First, we’ll color the root clade gray. We can do that by assigning the 24-bit color value as an RGB triple, an HTML-style hex string, or the name of one of the predefined colors.\n\nColors for a clade are treated as cascading down through the entire clade, so when we colorize the root here, it turns the whole tree gray. We can override that by assigning a different color lower down on the tree.\n\nLet’s target the most recent common ancestor (MRCA) of the nodes named “E” and “F”. The method returns a reference to that clade in the original tree, so when we color that clade “salmon”, the color will show up in the original tree.\n\nIf we happened to know exactly where a certain clade is in the tree, in terms of nested list entries, we can jump directly to that position in the tree by indexing it. Here, the index refers to the second child of the first child of the root.\n\nNote that a clade’s color includes the branch leading to that clade, as well as its descendents. The common ancestor of E and F turns out to be just under the root, and with this coloring we can see exactly where the root of the tree is.\n\nMy, we’ve accomplished a lot! Let’s take a break here and save our work. Call the write function with a file name or handle — here we use standard output, to see what would be written — and the format phyloxml. PhyloXML saves the colors we assigned, so you can open this phyloXML file in another tree viewer like Archaeopteryx, and the colors will show up there, too.\n\nThe rest of this chapter covers the core functionality of Bio.Phylo in greater detail. For more examples of using Bio.Phylo, see the cookbook page on Biopython.org:\n\nLike SeqIO and AlignIO, Phylo handles file input and output through four functions: , , and , all of which support the tree file formats Newick, NEXUS, phyloXML and NeXML, as well as the Comparative Data Analysis Ontology (CDAO).\n\nThe function parses a single tree in the given file and returns it. Careful; it will raise an error if the file contains more than one tree, or no trees.\n\nTo handle multiple (or an unknown number of) trees, use the function iterates through each of the trees in the given file:\n\nWrite a tree or iterable of trees back to file with the function:\n\nConvert files between any of the supported formats with the function:\n\nTo use strings as input or output instead of actual files, use as you would with SeqIO and AlignIO:\n\nThe simplest way to get an overview of a object is to it:\n\nThis is essentially an outline of the object hierarchy Biopython uses to represent a tree. But more likely, you’d want to see a drawing of the tree. There are three functions to do this.\n\nAs we saw in the demo, prints an ascii-art drawing of the tree (a rooted phylogram) to standard output, or an open file handle if given. Not all of the available information about the tree is shown, but it provides a way to quickly view the tree without relying on any external dependencies.\n\nThe function draws a more attractive image using the matplotlib library. See the API documentation for details on the arguments it accepts to customize the output.\n\nSee the Phylo page on the Biopython wiki (http://biopython.org/wiki/Phylo) for descriptions and examples of the more advanced functionality in , and .\n\nThe objects produced by and are containers for recursive sub-trees, attached to the object at the attribute (whether or not the phylogenetic tree is actually considered rooted). A has globally applied information for the phylogeny, such as rootedness, and a reference to a single ; a has node- and clade-specific information, such as branch length, and a list of its own descendent instances, attached at the attribute.\n\nSo there is a distinction between and . In practice, though, you rarely need to worry about it. To smooth over the difference, both and inherit from , which contains the implementations for methods that would be commonly used to search, inspect or modify a tree or any of its clades. This means that almost all of the methods supported by are also available on and any clade below it. ( also has a property, which returns the clade object itself.)\n\nFor convenience, we provide a couple of simplified methods that return all external or internal nodes directly as a list:\n\nThese both wrap a method with full control over tree traversal, . Two more traversal methods, and , rely on the same core functionality and accept the same arguments, which we’ll call a “target specification” for lack of a better description. These specify which objects in the tree will be matched and returned during iteration. The first argument can be any of the following types:\n• A , which tree elements will match by identity — so searching with a Clade instance as the target will find that clade in the tree;\n• A , which matches tree elements’ string representation — in particular, a clade’s ;\n• A or , where every tree element of the same type (or sub-type) will be matched;\n• A where keys are tree element attributes and values are matched to the corresponding attribute of each tree element. This one gets even more elaborate:\n• If an is given, it matches numerically equal attributes, e.g. 1 will match 1 or 1.0\n• If a boolean is given (True or False), the corresponding attribute value is evaluated as a boolean and checked for the same\n• If a string is given, the value is treated as a regular expression (which must match the whole string in the corresponding element attribute, not just a prefix). A given string without special regex characters will match string attributes exactly, so if you don’t use regexes, don’t worry about it. For example, in a tree with clade names Foo1, Foo2 and Foo3, matches Foo1, matches all three clades, and doesn’t match anything. Since floating-point arithmetic can produce some strange behavior, we don’t support matching floats directly. Instead, use the boolean True to match every element with a nonzero value in the specified attribute, then filter on that attribute manually with an inequality (or exact number, if you like living dangerously). If the dictionary contains multiple entries, a matching element must match each of the given attribute values — think “and”, not “or”.\n• A taking a single argument (it will be applied to each element in the tree), returning True or False. For convenience, LookupError, AttributeError and ValueError are silenced, so this provides another safe way to search for floating-point values in the tree, or some more complex characteristic.\n\nAfter the target, there are two optional keyword arguments:\n\nFinally, the methods accept arbitrary keyword arguments which are treated the same way as a dictionary target specification: keys indicate the name of the element attribute to search for, and the argument value (string, integer, None or boolean) is compared to the value of each attribute found. If no keyword arguments are given, then any TreeElement types are matched. The code for this is generally shorter than passing a dictionary as the target specification: can be shortened to .\n\nNow that we’ve mastered target specifications, here are the methods used to traverse a tree:\n\nTwo more methods help navigating between nodes in the tree:\n\nThese methods provide information about the whole tree (or any clade).\n\nThe rest of these methods are boolean checks:\n\nThese methods modify the tree in-place. If you want to keep the original tree intact, make a complete copy of the tree first, using Python’s copy module:\n\nSee the Phylo page on the Biopython wiki (http://biopython.org/wiki/Phylo) for more examples of using the available methods.\n\nThe phyloXML file format includes fields for annotating trees with additional data types and visual cues.\n\nSee the PhyloXML page on the Biopython wiki (http://biopython.org/wiki/PhyloXML) for descriptions and examples of using the additional annotation features provided by PhyloXML.\n\nWhile Bio.Phylo doesn’t infer trees from alignments itself, there are third-party programs available that do. These can be accessed from within python by using the module.\n\nBelow is an example on how to use a python script to interact with PhyML (http://www.atgc-montpellier.fr/phyml/). The program accepts an input alignment in phylip-relaxed format (that’s Phylip format, but without the 10-character limit on taxon names) and a variety of options.\n\nThe ‘stdout = subprocess.PIPE‘ argument makes the output of the program accessible through ‘results.stdout‘ for debugging purposes, (the same can be done for ‘stderr‘), and ‘text=True‘ makes the returned information be a python string, instead of a ‘bytes‘ object.\n\nThis generates a tree file and a stats file with the names [input filename] and [input filename] . The tree file is in Newick format:\n\nThe module can also be used for interacting with any other programs that provide a command line interface such as RAxML (https://sco.h-its.org/exelixis/software.html), FastTree (http://www.microbesonline.org/fasttree/), dnaml and protml.\n\nBiopython 1.58 brought support for PAML (http://abacus.gene.ucl.ac.uk/software/paml.html), a suite of programs for phylogenetic analysis by maximum likelihood. Currently the programs codeml, baseml and yn00 are implemented. Due to PAML’s usage of control files rather than command line arguments to control runtime options, usage of this wrapper strays from the format of other application wrappers in Biopython.\n\nA typical workflow would be to initialize a PAML object, specifying an alignment file, a tree file, an output file and a working directory. Next, runtime options are set via the set_options() method or by reading an existing control file. Finally, the program is run via the run() method and the output file is automatically parsed to a results dictionary.\n\nHere is an example of typical usage of codeml:\n\nExisting output files may be parsed as well using a module’s read() function:\n\nDetailed documentation for this new module currently lives on the Biopython wiki: http://biopython.org/wiki/PAML\n\nBio.Phylo is under active development. Here are some features we might add in future releases:\n\nWe’re open to any suggestions for improving the functionality and usability of this module; just let us know on the mailing list or our bug database.\n\nFinally, if you need additional functionality not yet included in the Phylo module, check if it’s available in another of the high-quality Python libraries for phylogenetics such as DendroPy (https://dendropy.org/) or PyCogent (http://pycogent.org/). Since these libraries also support standard file formats for phylogenetic trees, you can easily transfer data between libraries by writing to a temporary file or StringIO object.\n\nThis chapter gives an overview of the functionality of the package included in Biopython. It is intended for people who are involved in the analysis of sequence motifs, so I’ll assume that you are familiar with basic notions of motif analysis. In case something is unclear, please look at Section 17.10 for some relevant links.\n\nMost of this chapter describes the new package included in Biopython 1.61 onwards, which is replacing the older package introduced with Biopython 1.50, which was in turn based on two older former Biopython modules, and . It provides most of their functionality with a unified motif object implementation.\n\nSpeaking of other libraries, if you are reading this you might be interested in TAMO, another python library designed to deal with sequence motifs. It supports more de-novo motif finders, but it is not a part of Biopython and has some restrictions on commercial use.\n\nSince we are interested in motif analysis, we need to take a look at objects in the first place. For that we need to import the Bio.motifs library:\n\nand we can start creating our first motif objects. We can either create a object from a list of instances of the motif, or we can obtain a object by parsing a file from a motif database or motif finding software.\n\nSuppose we have these instances of a DNA motif:\n\nthen we can create a Motif object as follows:\n\nThe instances from which this motif was created is stored in the property:\n\nPrinting the Motif object shows the instances from which it was constructed:\n\nThe length of the motif is defined as the sequence length, which should be the same for all instances:\n\nThe Motif object has an attribute containing the counts of each nucleotide at each position. Printing this counts matrix shows it in an easily readable format:\n\nYou can access these counts as a dictionary:\n\nbut you can also think of it as a 2D array with the nucleotide as the first dimension and the position as the second dimension:\n\nYou can also directly access columns of the counts matrix\n\nInstead of the nucleotide itself, you can also use the index of the nucleotide in the alphabet of the motif:\n\nThe consensus sequence of a motif is defined as the sequence of letters along the positions of the motif for which the largest value in the corresponding columns of the matrix is obtained:\n\nConversely, the anticonsensus sequence corresponds to the smallest values in the columns of the matrix:\n\nNote that there is some ambiguity in the definition of the consensus and anticonsensus sequence if in some columns multiple nucleotides have the maximum or minimum count.\n\nFor DNA sequences, you can also ask for a degenerate consensus sequence, in which ambiguous nucleotides are used for positions where there are multiple nucleotides with high counts:\n\nHere, W and R follow the IUPAC nucleotide ambiguity codes: W is either A or T, and V is A, C, or G [7]. The degenerate consensus sequence is constructed following the rules specified by Cavener [3].\n\nThe method lets you specify in detail how the consensus sequence should be calculated. This method largely follows the conventions of the EMBOSS program , and takes the following arguments:\n\nThis is an example:\n\nWe can get the reverse complement of a motif by calling the method on it:\n\nThe reverse complement is only defined for DNA motifs.\n\nYou can slice the motif to obtain a new object for the selected positions:\n\nThe relative entropy (or Kullback-Leibler distance) H of column j of the motif is defined as [39, 11]\n• – The number of letters in the alphabet (given by );\n• – The observed frequency of letter , normalized, in the -th column (see below);\n• – The background probability of letter (given by ).\n\nThe observed frequency p is computed as follows:\n• – the number of times letter appears in column of the alignment (given by );\n• – The total number of letters in column : = ∑ (given by ).\n• – the pseudocount of letter (given by ).\n• – the total pseudocount: = ∑ (given by ).\n\nWith these definitions, both p and b are normalized to 1:\n\nThe relative entropy is the same as the information content if the background distribution is uniform.\n\nThe relative entropy for each column of motif can be obtained using the property:\n\nThese values are calculated using the base-2 logarithm, and are therefore in units of bits. The second column (which consists of nucleotides only) has the highest relative entropy; the fourth column (which consists of , , or nucleotides) has the lowest relative entropy). The relative entropy of the motif can be calculated by summing over the columns:\n\nIf we have internet access, we can create a weblogo:\n\nWe should get our logo saved as a PNG in the specified file.\n\nCreating motifs from instances by hand is a bit boring, so it’s useful to have some I/O functions for reading and writing motifs. There are not any really well established standards for storing motifs, but there are a couple of formats that are more used than others.\n\nOne of the most popular motif databases is JASPAR. In addition to the motif sequence information, the JASPAR database stores a lot of meta-information for each motif. The module contains a specialized class in which this meta-information is represented as attributes:\n• - the name of the TF, e.g. ’Arnt’\n• - the JASPAR collection to which the motif belongs, e.g. ’CORE’\n• - the structural class of this TF, e.g. ’Zipper-Type’\n• - the family to which this TF belongs, e.g. ’Helix-Loop-Helix’\n• - the species to which this TF belongs, may have multiple values, these are specified as taxonomy IDs, e.g. 10090\n• - the taxonomic supergroup to which this motif belongs, e.g. ’vertebrates’\n• - the accession number of the TF protein, e.g. ’P53762’\n• - the type of data used to construct this motif, e.g. ’SELEX’\n• - the Pubmed ID of literature supporting this motif, may be multiple values, e.g. 7592839\n• - external reference to the TF in the PAZAR database, e.g. ’TF0000003’\n• - free form text containing notes about the construction of the motif\n\nThe class inherits from the generic class and therefore provides all the facilities of any of the motif formats — reading motifs, writing motifs, scanning sequences for motif instances etc.\n\nJASPAR stores motifs in several different ways including three different flat file formats and as an SQL database. All of these formats facilitate the construction of a counts matrix. However, the amount of meta information described above that is available varies with the format.\n\nThe first of the three flat file formats contains a list of instances. As an example, these are the beginning and ending lines of the JASPAR file showing known binding sites of the mouse helix-loop-helix transcription factor Arnt.\n\nThe parts of the sequence in capital letters are the motif instances that were found to align to each other.\n\nWe can create a object from these instances as follows:\n\nThe instances from which this motif was created is stored in the property:\n\nThe counts matrix of this motif is automatically calculated from the instances:\n\nThis format does not store any meta information.\n\nJASPAR also makes motifs available directly as a count matrix, without the instances from which it was created. This format only stores the counts matrix for a single motif. For example, this is the JASPAR file containing the counts matrix for the human SRF transcription factor:\n\nWe can create a motif for this count matrix as follows:\n\nAs this motif was created from the counts matrix directly, it has no instances associated with it:\n\nWe can now ask for the consensus sequence of these two motifs:\n\nAs with the instances file, no meta information is stored in this format.\n\nThe file format allows multiple motifs to be specified in a single file. In this format each of the motif records consist of a header line followed by four lines defining the counts matrix. The header line begins with a character (similar to the Fasta file format) and is followed by the unique JASPAR matrix ID and the TF name. The following example shows a formatted file containing the three motifs Arnt, RUNX1 and MEF2A:\n\nThe motifs are read as follows:\n\nNote that printing a JASPAR motif yields both the counts data and the available meta-information.\n\nIn addition to parsing these flat file formats, we can also retrieve motifs from a JASPAR SQL database. Unlike the flat file formats, a JASPAR database allows storing of all possible meta information defined in the JASPAR class. It is beyond the scope of this document to describe how to set up a JASPAR database (please see the main JASPAR website). Motifs are read from a JASPAR database using the module. First connect to the JASPAR database using the JASPAR5 class which models the the latest JASPAR schema:\n\nNow we can fetch a single motif by its unique JASPAR ID with the method. Note that a JASPAR ID consists of a base ID and a version number separated by a decimal point, e.g. ’MA0004.1’. The method allows you to use either the fully specified ID or just the base ID. If only the base ID is provided, the latest version of the motif is returned.\n\nPrinting the motif reveals that the JASPAR SQL database stores much more meta-information than the flat files:\n\nWe can also fetch motifs by name. The name must be an exact match (partial matches or database wildcards are not currently supported). Note that as the name is not guaranteed to be unique, the method actually returns a list.\n\nThe method allows you to fetch motifs which match a specified set of criteria. These criteria include any of the above described meta information as well as certain matrix properties such as the minimum information content ( in the example below), the minimum length of the matrix or the minimum number of sites used to construct the matrix. Only motifs which pass ALL the specified criteria are returned. Note that selection criteria which correspond to meta information which allow for multiple values may be specified as either a single value or a list of values, e.g. and in the example below.\n\nAn important thing to note is that the JASPAR class was designed to be compatible with the popular Perl TFBS modules. Therefore some specifics about the choice of defaults for background and pseudocounts as well as how information content is computed and sequences searched for instances is based on this compatibility criteria. These choices are noted in the specific subsections below.\n• The Perl modules appear to allow a choice of custom background probabilities (although the documentation states that uniform background is assumed). However the default is to use a uniform background. Therefore it is recommended that you use a uniform background for computing the position-specific scoring matrix (PSSM). This is the default when using the Biopython module.\n• By default, the Perl modules use a pseudocount equal to √ * bg[nucleotide], where represents the total number of sequences used to construct the matrix. To apply this same pseudocount formula, set the motif attribute using the function: Note that it is possible for the counts matrix to have an unequal number of sequences making up the columns. The pseudocount computation uses the average number of sequences making up the matrix. However, when is called on the counts matrix, each count value in a column is divided by the total number of sequences making up that specific column, not by the average number of sequences. This differs from the Perl modules because the normalization is not done as a separate step and so the average number of sequences is used throughout the computation of the pssm. Therefore, for matrices with unequal column counts, the PSSM computed by the module will differ somewhat from the pssm computed by the Perl modules.\n• The information content (IC) or specificity of a matrix is computed using the method of the class. However of note, in the Perl modules the default behavior is to compute the IC without first applying pseudocounts, even though by default the PSSMs are computed using pseudocounts as described above.\n• Searching for instances with the Perl motifs was usually performed using a relative score threshold, i.e. a score in the range 0 to 1. In order to compute the absolute PSSM score corresponding to a relative score one can use the equation: To convert the absolute score of an instance back to a relative score, one can use the equation: For example, using the Arnt motif before, let’s search a sequence with a relative score threshold of 0.8.\n\nMEME [2] is a tool for discovering motifs in a group of related DNA or protein sequences. It takes as input a group of DNA or protein sequences and outputs as many motifs as requested. Therefore, in contrast to JASPAR files, MEME output files typically contain multiple motifs. This is an example.\n\nAt the top of an output file generated by MEME shows some background information about the MEME and the version of MEME used:\n\nFurther down, the input set of training sequences is recapitulated:\n\nand the exact command line that was used:\n\nNext is detailed information on each motif that was found:\n\nTo parse this file (stored as ), use\n\nThe command reads the complete file directly, so you can close the file after calling . The header information is stored in attributes:\n\nThe record is an object of the class. The class inherits from list, and you can think of as a list of Motif objects:\n\nIn addition to these generic motif attributes, each motif also stores its specific information as calculated by MEME. For example,\n\nIn addition to using an index into the record, as we did above, you can also find it by its name:\n\nEach motif has an attribute with the sequence alignment in which the motif was found, providing some information on each of the sequences:\n\nTRANSFAC is a manually curated database of transcription factors, together with their genomic binding sites and DNA binding profiles [32]. While the file format used in the TRANSFAC database is nowadays also used by others, we will refer to it as the TRANSFAC file format.\n\nA minimal file in the TRANSFAC format looks as follows:\n\nThis file shows the frequency matrix of motif of 12 nucleotides. In general, one file in the TRANSFAC format can contain multiple motifs. For example, this is the contents of the example TRANSFAC file :\n\nIf any discrepancies between the file contents and the TRANSFAC file format are detected, a is raised. Note that you may encounter files that do not follow the TRANSFAC format strictly. For example, the number of spaces between columns may be different, or a tab may be used instead of spaces. Use to enable parsing such files without raising a :\n\nWhen parsing a non-compliant file, we recommend to check the record returned by to ensure that it is consistent with the file contents.\n\nThe overall version number, if available, is stored as :\n\nEach motif in is in instance of the class, which inherits both from the class and from a Python dictionary. The dictionary uses the two-letter keys to store any additional information about the motif:\n\nTRANSFAC files are typically much more elaborate than this example, containing lots of additional information about the motif. Table 17.2.3 lists the two-letter field codes that are commonly found in TRANSFAC files:\n\nEach motif also has an attribute containing the references associated with the motif, using these two-letter keys:\n\nPrinting the motifs writes them out in their native TRANSFAC format:\n\nYou can export the motifs in the TRANSFAC format by capturing this output in a string and saving it in a file:\n\nSpeaking of exporting, let’s look at export functions in general. We can use the built-in function to write the motif in the simple JASPAR format:\n\nSimilarly, we can use to write the motif in the JASPAR format:\n\nTo write the motif in a TRANSFAC-like matrix format, use\n\nTo write out multiple motifs, you can use . This function can be used regardless of whether the motifs originated from a TRANSFAC file. For example,\n\nOr, to write multiple motifs in the format:\n\nThe attribute of a Motif object shows how often each nucleotide appeared at each position along the alignment. We can normalize this matrix by dividing by the number of instances in the alignment, resulting in the probability of each nucleotide at each position along the alignment. We refer to these probabilities as the position-weight matrix. However, beware that in the literature this term may also be used to refer to the position-specific scoring matrix, which we discuss below.\n\nUsually, pseudocounts are added to each position before normalizing. This avoids overfitting of the position-weight matrix to the limited number of motif instances in the alignment, and can also prevent probabilities from becoming zero. To add a fixed pseudocount to all nucleotides at all positions, specify a number for the argument:\n\nAlternatively, can be a dictionary specifying the pseudocounts for each nucleotide. For example, as the GC content of the human genome is about 40%, you may want to choose the pseudocounts accordingly:\n\nThe position-weight matrix has its own methods to calculate the consensus, anticonsensus, and degenerate consensus sequences:\n\nNote that due to the pseudocounts, the degenerate consensus sequence calculated from the position-weight matrix is slightly different from the degenerate consensus sequence calculated from the instances in the motif:\n\nThe reverse complement of the position-weight matrix can be calculated directly from the :\n\nUsing the background distribution and PWM with pseudo-counts added, it’s easy to compute the log-odds ratios, telling us what are the log odds of a particular symbol to be coming from a motif against the background. We can use the method on the position-weight matrix:\n\nHere we can see positive values for symbols more frequent in the motif than in the background and negative for symbols more frequent in the background. 0.0 means that it’s equally likely to see a symbol in the background and in the motif.\n\nThis assumes that A, C, G, and T are equally likely in the background. To calculate the position-specific scoring matrix against a background with unequal probabilities for A, C, G, T, use the argument. For example, against a background with a 40% GC content, use\n\nThe maximum and minimum score obtainable from the PSSM are stored in the and properties:\n\nThe mean and standard deviation of the PSSM scores with respect to a specific background are calculated by the and methods.\n\nA uniform background is used if is not specified. The mean is equal to the Kullback-Leibler divergence or relative entropy described in Section 17.1.5.\n\nThe , , , and methods can be applied directly to PSSM objects.\n\nThe most frequent use for a motif is to find its instances in some sequence. For the sake of this section, we will use an artificial sequence like this:\n\nThe simplest way to find instances, is to look for exact matches of the true instances of the motif:\n\nWe can do the same with the reverse complement (to find instances on the complementary strand):\n\n17.6.2 Searching for matches using the PSSM score\n\nIt’s just as easy to look for positions, giving rise to high log-odds scores against our motif:\n\nThe negative positions refer to instances of the motif found on the reverse strand of the test sequence, and follow the Python convention on negative indices. Therefore, the instance of the motif at is located at both for positive and for negative values of .\n\nYou may notice the threshold parameter, here set arbitrarily to 3.0. This is in log , so we are now looking only for words, which are eight times more likely to occur under the motif model than in the background. The default threshold is 0.0, which selects everything that looks more like the motif than the background.\n\nYou can also calculate the scores at all positions along the sequence:\n\nIn general, this is the fastest way to calculate PSSM scores. The scores returned by are for the forward strand only. To obtain the scores on the reverse strand, you can take the reverse complement of the PSSM:\n\nIf you want to use a less arbitrary way of selecting thresholds, you can explore the distribution of PSSM scores. Since the space for a score distribution grows exponentially with motif length, we are using an approximation with a given precision to keep computation cost manageable:\n\nThe object can be used to determine a number of different thresholds. We can specify the requested false-positive rate (probability of “finding” a motif instance in background generated sequence):\n\nor the false-negative rate (probability of “not finding” an instance generated from the motif):\n\nor a threshold (approximately) satisfying some relation between the false-positive rate and the false-negative rate (fnr/fpr≃ t):\n\nor a threshold satisfying (roughly) the equality between the −log of the false-positive rate and the information content (as used in patser software by Hertz and Stormo):\n\nFor example, in case of our motif, you can get the threshold giving you exactly the same results (for this sequence) as searching for instances with balanced threshold with rate of 1000.\n\n17.7 Each motif object has an associated Position-Specific Scoring Matrix\n\nTo facilitate searching for potential TFBSs using PSSMs, both the position-weight matrix and the position-specific scoring matrix are associated with each motif. Using the Arnt motif as an example:\n\nThe negative infinities appear here because the corresponding entry in the frequency matrix is 0, and we are using zero pseudocounts by default:\n\nIf you change the attribute, the position-frequency matrix and the position-specific scoring matrix are recalculated automatically:\n\nYou can also set the to a dictionary over the four nucleotides if you want to use different pseudocounts for them. Setting to resets it to its default value of zero.\n\nThe position-specific scoring matrix depends on the background distribution, which is uniform by default:\n\nAgain, if you modify the background distribution, the position-specific scoring matrix is recalculated:\n\nSetting to resets it to a uniform distribution:\n\nIf you set equal to a single value, it will be interpreted as the GC content:\n\nNote that you can now calculate the mean of the PSSM scores over the background against which it was computed:\n\nas well as its standard deviation:\n\nNote that the position-weight matrix and the position-specific scoring matrix are recalculated each time you call or , respectively. If speed is an issue and you want to use the PWM or PSSM repeatedly, you can save them as a variable, as in\n\nOnce we have more than one motif, we might want to compare them.\n\nBefore we start comparing motifs, I should point out that motif boundaries are usually quite arbitrary. This means we often need to compare motifs of different lengths, so comparison needs to involve some kind of alignment. This means we have to take into account two things:\n\nTo align the motifs, we use ungapped alignment of PSSMs and substitute zeros for any missing columns at the beginning and end of the matrices. This means that effectively we are using the background distribution for columns missing from the PSSM. The distance function then returns the minimal distance between motifs, as well as the corresponding offset in their alignment.\n\nTo give an example, let us first load another motif, which is similar to our test motif :\n\nTo make the motifs comparable, we choose the same values for the pseudocounts and the background distribution as our motif :\n\nWe’ll compare these motifs using the Pearson correlation. Since we want it to resemble a distance measure, we actually take 1−r, where r is the Pearson correlation coefficient (PCC):\n\nThis means that the best PCC between motif and is obtained with the following alignment:\n\nwhere stands for background distribution. The PCC itself is roughly 1−0.239=0.761.\n\nCurrently, Biopython has only limited support for de novo motif finding. Namely, we support running and also parsing of MEME. Since the number of motif finding tools is growing rapidly, contributions of new parsers are welcome.\n\nLet’s assume, you have run MEME on sequences of your choice with your favorite parameters and saved the output in the file . You can retrieve the motifs reported by MEME by running the following piece of code:\n\nBesides the most wanted list of motifs, the result object contains more useful information, accessible through properties with self-explanatory names:\n\nThe motifs returned by the MEME Parser can be treated exactly like regular Motif objects (with instances), they also provide some extra functionality, by adding additional information about the instances.\n\nCluster analysis is the grouping of items into clusters based on the similarity of the items to each other. In bioinformatics, clustering is widely used in gene expression data analysis to find groups of genes with similar gene expression profiles. This may identify functionally related genes, as well as suggest the function of presently unknown genes.\n\nThe Biopython module provides commonly used clustering algorithms and was designed with the application to gene expression data in mind. However, this module can also be used for cluster analysis of other types of data. and the underlying C Clustering Library is described by De Hoon et al. [10].\n\nThe following four clustering approaches are implemented in :\n\nThe data to be clustered are represented by a n × m Numerical Python array . Within the context of gene expression data clustering, typically the rows correspond to different genes whereas the columns correspond to different experimental conditions. The clustering algorithms in can be applied both to rows (genes) and to columns (experiments).\n\nThe n × m Numerical Python integer array indicates if any of the values in are missing. If , then is missing and is ignored in the analysis.\n\nThe k-means/medians/medoids clustering algorithms and Self-Organizing Maps (SOMs) include the use of a random number generator. The uniform random number generator in is based on the algorithm by L’Ecuyer [27], while random numbers following the binomial distribution are generated using the BTPE algorithm by Kachitvichyanukul and Schmeiser [23]. The random number generator is initialized automatically during its first call. As this random number generator uses a combination of two multiplicative linear congruential generators, two (integer) seeds are needed for initialization, for which we use the system-supplied random number generator (in the C standard library). We initialize this generator by calling with the epoch time in seconds, and use the first two random numbers generated by as seeds for the uniform random number generator in .\n\nIn order to cluster items into groups based on their similarity, we should first define what exactly we mean by similar. provides eight distance functions, indicated by a single character, to measure similarity, or conversely, distance:\n• : Absolute value of the Pearson correlation coefficient;\n• : Uncentered Pearson correlation (equivalent to the cosine of the angle between two data vectors);\n\nThe first two are true distance functions that satisfy the triangle inequality:\n\nand are therefore referred to as metrics. In everyday language, this means that the shortest distance between two points is a straight line.\n\nThe remaining six distance measures are related to the correlation coefficient, where the distance d is defined in terms of the correlation r by d=1−r. Note that these distance functions are semi-metrics that do not satisfy the triangle inequality. For example, for\n\nIn , we define the Euclidean distance as\n\nOnly those terms are included in the summation for which both x and y are present, and the denominator n is chosen accordingly. As the expression data x and y are subtracted directly from each other, we should make sure that the expression data are properly normalized when using the Euclidean distance.\n\nThe city-block distance, alternatively known as the Manhattan distance, is related to the Euclidean distance. Whereas the Euclidean distance corresponds to the length of the shortest path between two points, the city-block distance is the sum of distances along each dimension. As gene expression data tend to have missing values, in we define the city-block distance as the sum of distances divided by the number of dimensions:\n\nThis is equal to the distance you would have to walk between two points in a city, where you have to walk along city blocks. As for the Euclidean distance, the expression data are subtracted directly from each other, and we should therefore make sure that they are properly normalized.\n\nThe Pearson correlation coefficient is defined as\n\nin which x, ȳ are the sample mean of x and y respectively, and σ , σ are the sample standard deviation of x and y. The Pearson correlation coefficient is a measure for how well a straight line can be fitted to a scatterplot of x and y. If all the points in the scatterplot lie on a straight line, the Pearson correlation coefficient is either +1 or -1, depending on whether the slope of line is positive or negative. If the Pearson correlation coefficient is equal to zero, there is no correlation between x and y.\n\nThe Pearson distance is then defined as\n\nAs the Pearson correlation coefficient lies between -1 and 1, the Pearson distance lies between 0 and 2.\n\nBy taking the absolute value of the Pearson correlation, we find a number between 0 and 1. If the absolute value is 1, all the points in the scatter plot lie on a straight line with either a positive or a negative slope. If the absolute value is equal to zero, there is no correlation between x and y.\n\nThe corresponding distance is defined as\n\nwhere r is the Pearson correlation coefficient. As the absolute value of the Pearson correlation coefficient lies between 0 and 1, the corresponding distance lies between 0 and 1 as well.\n\nIn the context of gene expression experiments, the absolute correlation is equal to 1 if the gene expression profiles of two genes are either exactly the same or exactly opposite. The absolute correlation coefficient should therefore be used with care.\n\nIn some cases, it may be preferable to use the uncentered correlation instead of the regular Pearson correlation coefficient. The uncentered correlation is defined as\n\nThis is the same expression as for the regular Pearson correlation coefficient, except that the sample means x, ȳ are set equal to zero. The uncentered correlation may be appropriate if there is a zero reference state. For instance, in the case of gene expression data given in terms of log-ratios, a log-ratio equal to zero corresponds to the green and red signal being equal, which means that the experimental manipulation did not affect the gene expression.\n\nThe distance corresponding to the uncentered correlation coefficient is defined as\n\nwhere r is the uncentered correlation. As the uncentered correlation coefficient lies between -1 and 1, the corresponding distance lies between 0 and 2.\n\nThe uncentered correlation is equal to the cosine of the angle of the two data vectors in n-dimensional space, and is often referred to as such.\n\nAs for the regular Pearson correlation, we can define a distance measure using the absolute value of the uncentered correlation:\n\nwhere r is the uncentered correlation coefficient. As the absolute value of the uncentered correlation coefficient lies between 0 and 1, the corresponding distance lies between 0 and 1 as well.\n\nGeometrically, the absolute value of the uncentered correlation is equal to the cosine between the supporting lines of the two data vectors (i.e., the angle without taking the direction of the vectors into consideration).\n\nThe Spearman rank correlation is an example of a non-parametric similarity measure, and tends to be more robust against outliers than the Pearson correlation.\n\nTo calculate the Spearman rank correlation, we replace each data value by their rank if we would order the data in each vector by their value. We then calculate the Pearson correlation between the two rank vectors instead of the data vectors.\n\nAs in the case of the Pearson correlation, we can define a distance measure corresponding to the Spearman rank correlation as\n\nwhere r is the Spearman rank correlation.\n\nKendall’s τ is another example of a non-parametric similarity measure. It is similar to the Spearman rank correlation, but instead of the ranks themselves only the relative ranks are used to calculate τ (see Snedecor & Cochran [43]).\n\nWe can define a distance measure corresponding to Kendall’s τ as\n\nAs Kendall’s τ is always between -1 and 1, the corresponding distance will be between 0 and 2.\n\nFor most of the distance functions available in , a weight vector can be applied. The weight vector contains weights for the items in the data vector. If the weight for item i is w , then that item is treated as if it occurred w times in the data. The weight do not have to be integers.\n\nThe distance matrix is a square matrix with all pairwise distances between the items in , and can be calculated by the function in the module:\n\nwhere the following arguments are defined:\n• (required)\n\n Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n The weights to be used when calculating distances. If is , then equal weights are assumed.\n• (default: ) \n\n Determines if the distances between the rows of are to be calculated ( is ), or between the columns of ( is ).\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n\nTo save memory, the distance matrix is returned as a list of 1D arrays. The number of columns in each row is equal to the row number. Hence, the first row has zero elements. For example,\n\nwhich can be rewritten as\n\nThis corresponds to the distance matrix:\n\nThe centroid of a cluster can be defined either as the mean or as the median of each dimension over all cluster items. The function in can be used to calculate either:\n\nwhere the following arguments are defined:\n• (required) \n\n Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n Vector of integers showing to which cluster each item belongs. If is , then all items are assumed to belong to the same cluster.\n• (default: ) \n\n Specifies whether the arithmetic mean ( ) or the median ( ) is used to calculate the cluster center.\n• (default: ) \n\n Determines if the centroids of the rows of are to be calculated ( is ), or the centroids of the columns of ( is ).\n\nThis function returns the tuple . The centroid data are stored in the 2D Numerical Python array , with missing data indicated by the 2D Numerical Python integer array . The dimensions of these arrays are (number of clusters, number of columns) if is , or (number of rows, number of clusters) if is . Each row (if is ) or column (if is ) contains the averaged data corresponding to the centroid of each cluster.\n\nGiven a distance function between items, we can define the distance between two clusters in several ways. The distance between the arithmetic means of the two clusters is used in pairwise centroid-linkage clustering and in k-means clustering. In k-medoids clustering, the distance between the medians of the two clusters is used instead. The shortest pairwise distance between items of the two clusters is used in pairwise single-linkage clustering, while the longest pairwise distance is used in pairwise maximum-linkage clustering. In pairwise average-linkage clustering, the distance between two clusters is defined as the average over the pairwise distances.\n\nTo calculate the distance between two clusters, use\n\nwhere the following arguments are defined:\n• (required)\n\n Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n The weights to be used when calculating distances. If is , then equal weights are assumed.\n• (default: ) \n\n A list containing the indices of the items belonging to the first cluster. A cluster containing only one item can be represented either as a list , or as an integer .\n• (default: ) \n\n A list containing the indices of the items belonging to the second cluster. A cluster containing only one items can be represented either as a list , or as an integer .\n• (default: ) \n\n Specifies how the distance between clusters is defined:\n• : Distance between the two cluster centroids (arithmetic mean);\n• : Distance between the two cluster centroids (median);\n• : Shortest pairwise distance between items in the two clusters;\n• : Longest pairwise distance between items in the two clusters;\n• : Average over the pairwise distances between items in the two clusters.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n• (default: ) \n\n If is , calculate the distance between the rows of . If is , calculate the distance between the columns of .\n\nPartitioning algorithms divide items into k clusters such that the sum of distances over the items to their cluster centers is minimal. The number of clusters k is specified by the user. Three partitioning algorithms are available in :\n\nThese algorithms differ in how the cluster center is defined. In k-means clustering, the cluster center is defined as the mean data vector averaged over all items in the cluster. Instead of the mean, in k-medians clustering the median is calculated for each dimension in the data vector. Finally, in k-medoids clustering the cluster center is defined as the item which has the smallest sum of distances to the other items in the cluster. This clustering algorithm is suitable for cases in which the distance matrix is known but the original data matrix is not available, for example when clustering proteins based on their structural similarity.\n\nThe expectation-maximization (EM) algorithm is used to find this partitioning into k groups. In the initialization of the EM algorithm, we randomly assign items to clusters. To ensure that no empty clusters are produced, we use the binomial distribution to randomly choose the number of items in each cluster to be one or more. We then randomly permute the cluster assignments to items such that each item has an equal probability to be in any cluster. Each cluster is thus guaranteed to contain at least one item.\n• Calculate the centroid of each cluster, defined as either the mean, the median, or the medoid of the cluster;\n• Calculate the distances of each item to the cluster centers;\n• For each item, determine which cluster centroid is closest;\n• Reassign each item to its closest cluster, or stop the iteration if no further item reassignments take place.\n\nTo avoid clusters becoming empty during the iteration, in k-means and k-medians clustering the algorithm keeps track of the number of items in each cluster, and prohibits the last remaining item in a cluster from being reassigned to a different cluster. For k-medoids clustering, such a check is not needed, as the item that functions as the cluster centroid has a zero distance to itself, and will therefore never be closer to a different cluster.\n\nAs the initial assignment of items to clusters is done randomly, usually a different clustering solution is found each time the EM algorithm is executed. To find the optimal clustering solution, the k-means algorithm is repeated many times, each time starting from a different initial random clustering. The sum of distances of the items to their cluster center is saved for each run, and the solution with the smallest value of this sum will be returned as the overall clustering solution.\n\nHow often the EM algorithm should be run depends on the number of items being clustered. As a rule of thumb, we can consider how often the optimal solution was found; this number is returned by the partitioning algorithms as implemented in this library. If the optimal solution was found many times, it is unlikely that better solutions exist than the one that was found. However, if the optimal solution was found only once, there may well be other solutions with a smaller within-cluster sum of distances. If the number of items is large (more than several hundreds), it may be difficult to find the globally optimal solution.\n\nThe EM algorithm terminates when no further reassignments take place. We noticed that for some sets of initial cluster assignments, the EM algorithm fails to converge due to the same clustering solution reappearing periodically after a small number of iteration steps. We therefore check for the occurrence of such periodic solutions during the iteration. After a given number of iteration steps, the current clustering result is saved as a reference. By comparing the clustering result after each subsequent iteration step to the reference state, we can determine if a previously encountered clustering result is found. In such a case, the iteration is halted. If after a given number of iterations the reference state has not yet been encountered, the current clustering solution is saved to be used as the new reference state. Initially, ten iteration steps are executed before resaving the reference state. This number of iteration steps is doubled each time, to ensure that periodic behavior with longer periods can also be detected.\n\nThe k-means and k-medians algorithms are implemented as the function in :\n\nwhere the following arguments are defined:\n• (required)\n\n Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n The weights to be used when calculating distances. If is , then equal weights are assumed.\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n The number of times the -means/-medians clustering algorithm is performed, each time with a different (random) initial condition. If is given, the value of is ignored and the clustering algorithm is run only once, as it behaves deterministically in that case.\n• (default: ) \n\n describes how the center of a cluster is found: For other values of , the arithmetic mean is used.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1). Whereas all eight distance measures are accepted by , from a theoretical viewpoint it is best to use the Euclidean distance for the -means algorithm, and the city-block distance for -medians.\n• (default: ) \n\n Specifies the initial clustering to be used for the EM algorithm. If is , then a different random initial clustering is used for each of the runs of the EM algorithm. If is not , then it should be equal to a 1D array containing the cluster number (between and ) for each item. Each cluster should contain at least one item. With the initial clustering specified, the EM algorithm is deterministic.\n\nThis function returns a tuple , where is an integer array containing the number of the cluster to which each row or cluster was assigned, is the within-cluster sum of distances for the optimal clustering solution, and is the number of times this optimal solution was found.\n\nThe routine performs k-medoids clustering on a given set of items, using the distance matrix and the number of clusters passed by the user:\n\nwhere the following arguments are defined: , nclusters=2, npass=1, initialid=None)|\n• (required) \n\n The matrix containing the distances between the items; this matrix can be specified in three ways:\n• as a 2D Numerical Python array (in which only the left-lower part of the array will be accessed):\n• as a 1D Numerical Python array containing consecutively the distances in the left-lower part of the distance matrix:\n• as a list containing the rows of the left-lower part of the distance matrix: These three expressions correspond to the same distance matrix.\n• (default: ) \n\n The number of times the -medoids clustering algorithm is performed, each time with a different (random) initial condition. If is given, the value of is ignored, as the clustering algorithm behaves deterministically in that case.\n• (default: ) \n\n Specifies the initial clustering to be used for the EM algorithm. If is , then a different random initial clustering is used for each of the runs of the EM algorithm. If is not , then it should be equal to a 1D array containing the cluster number (between and ) for each item. Each cluster should contain at least one item. With the initial clustering specified, the EM algorithm is deterministic.\n\nThis function returns a tuple , where is an array containing the number of the cluster to which each item was assigned, is the within-cluster sum of distances for the optimal k-medoids clustering solution, and is the number of times the optimal solution was found. Note that the cluster number in is defined as the item number of the item representing the cluster centroid.\n\nHierarchical clustering methods are inherently different from the k-means clustering method. In hierarchical clustering, the similarity in the expression profile between genes or experimental conditions are represented in the form of a tree structure. This tree structure can be shown graphically by programs such as Treeview and Java Treeview, which has contributed to the popularity of hierarchical clustering in the analysis of gene expression data.\n\nThe first step in hierarchical clustering is to calculate the distance matrix, specifying all the distances between the items to be clustered. Next, we create a node by joining the two closest items. Subsequent nodes are created by pairwise joining of items or nodes based on the distance between them, until all items belong to the same node. A tree structure can then be created by retracing which items and nodes were merged. Unlike the EM algorithm, which is used in k-means clustering, the complete process of hierarchical clustering is deterministic.\n\nSeveral flavors of hierarchical clustering exist, which differ in how the distance between subnodes is defined in terms of their members. In , pairwise single, maximum, average, and centroid linkage are available.\n• In pairwise single-linkage clustering, the distance between two nodes is defined as the shortest distance among the pairwise distances between the members of the two nodes.\n• In pairwise maximum-linkage clustering, alternatively known as pairwise complete-linkage clustering, the distance between two nodes is defined as the longest distance among the pairwise distances between the members of the two nodes.\n• In pairwise average-linkage clustering, the distance between two nodes is defined as the average over all pairwise distances between the items of the two nodes.\n• In pairwise centroid-linkage clustering, the distance between two nodes is defined as the distance between their centroids. The centroids are calculated by taking the mean over all the items in a cluster. As the distance from each newly formed node to existing nodes and items need to be calculated at each step, the computing time of pairwise centroid-linkage clustering may be significantly longer than for the other hierarchical clustering methods. Another peculiarity is that (for a distance measure based on the Pearson correlation), the distances do not necessarily increase when going up in the clustering tree, and may even decrease. This is caused by an inconsistency between the centroid calculation and the distance calculation when using the Pearson correlation: Whereas the Pearson correlation effectively normalizes the data for the distance calculation, no such normalization occurs for the centroid calculation.\n\nFor pairwise single-, complete-, and average-linkage clustering, the distance between two nodes can be found directly from the distances between the individual items. Therefore, the clustering algorithm does not need access to the original gene expression data, once the distance matrix is known. For pairwise centroid-linkage clustering, however, the centroids of newly formed subnodes can only be calculated from the original data and not from the distance matrix.\n\nThe implementation of pairwise single-linkage hierarchical clustering is based on the SLINK algorithm [41], which is much faster and more memory-efficient than a straightforward implementation of pairwise single-linkage clustering. The clustering result produced by this algorithm is identical to the clustering solution found by the conventional single-linkage algorithm. The single-linkage hierarchical clustering algorithm implemented in this library can be used to cluster large gene expression data sets, for which conventional hierarchical clustering algorithms fail due to excessive memory requirements and running time.\n\nThe result of hierarchical clustering consists of a tree of nodes, in which each node joins two items or subnodes. Usually, we are not only interested in which items or subnodes are joined at each node, but also in their similarity (or distance) as they are joined. To store one node in the hierarchical clustering tree, we make use of the class , which defined in . An instance of has three attributes:\n\nHere, and are integers referring to the two items or subnodes that are joined at this node, and is the distance between them. The items being clustered are numbered from 0 to (number of items − 1), while clusters are numbered from -1 to −(number of items−1). Note that the number of nodes is one less than the number of items.\n\nTo create a new object, we need to specify and ; is optional.\n\nThe attributes , , and of an existing object can be modified directly:\n\nAn error is raised if and are not integers, or if cannot be converted to a floating-point value.\n\nThe Python class represents a full hierarchical clustering solution. A object can be created from a list of objects:\n\nThe initializer checks if the list of nodes is a valid hierarchical clustering result:\n\nIndividual nodes in a object can be accessed using square brackets:\n\nAs a object is immutable, we cannot change individual nodes in a object. However, we can convert the tree to a list of nodes, modify this list, and create a new tree from this list:\n\nThis guarantees that any object is always well-formed.\n\nTo display a hierarchical clustering solution with visualization programs such as Java Treeview, it is better to scale all node distances such that they are between zero and one. This can be accomplished by calling the method on an existing object:\n\nThis method takes no arguments, and returns .\n\nBefore drawing the tree, you may also want to reorder the tree nodes. A hierarchical clustering solution of n items can be drawn as 2n−1 different but equivalent dendrograms by switching the left and right subnode at each node. The method visits each node in the hierarchical clustering tree and verifies if the average order value of the left subnode is less than or equal to the average order value of the right subnode. If not, the left and right subnodes are exchanged. Here, the order values of the items are given by the user. In the resulting dendrogram, items in the left-to-right order will tend to have increasing order values. The method will return the indices of the elements in the left-to-right order after sorting:\n\nsuch that item will occur at position i in the dendrogram.\n\nAfter hierarchical clustering, the items can be grouped into k clusters based on the tree structure stored in the object by cutting the tree:\n\nwhere (defaulting to ) is the desired number of clusters k. This method ignores the top k−1 linking events in the tree structure, resulting in k separated clusters of items. The number of clusters k should be positive, and less than or equal to the number of items. This method returns an array containing the number of the cluster to which each item is assigned. Clusters are numbered 0 to k−1 in their left-to-right order in the dendrogram.\n\nTo perform hierarchical clustering, use the function in .\n\nwhere the following arguments are defined:\n• Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n The weights to be used when calculating distances. If is , then equal weights are assumed.\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n defines the linkage method to be used:\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n\nTo apply hierarchical clustering on a precalculated distance matrix, specify the argument when calling function instead of the argument:\n\nIn this case, the following arguments are defined:\n• The distance matrix, which can be specified in three ways:\n• as a 2D Numerical Python array (in which only the left-lower part of the array will be accessed):\n• as a 1D Numerical Python array containing consecutively the distances in the left-lower part of the distance matrix:\n• as a list containing the rows of the left-lower part of the distance matrix: These three expressions correspond to the same distance matrix. As may shuffle the values in the distance matrix as part of the clustering algorithm, be sure to save this array in a different variable before calling if you need it later.\n• The linkage method to be used: While pairwise single-, maximum-, and average-linkage clustering can be calculated from the distance matrix alone, pairwise centroid-linkage cannot.\n\nWhen calling , either or should be .\n\nThis function returns a object. This object contains (number of items − 1) nodes, where the number of items is the number of rows if rows were clustered, or the number of columns if columns were clustered. Each node describes a pairwise linking event, where the node attributes and each contain the number of one item or subnode, and the distance between them. Items are numbered from 0 to (number of items − 1), while clusters are numbered -1 to −(number of items−1).\n\nSelf-Organizing Maps (SOMs) were invented by Kohonen to describe neural networks (see for instance Kohonen, 1997 [25]). Tamayo (1999) first applied Self-Organizing Maps to gene expression data [46].\n\nSOMs organize items into clusters that are situated in some topology. Usually a rectangular topology is chosen. The clusters generated by SOMs are such that neighboring clusters in the topology are more similar to each other than clusters far from each other in the topology.\n\nThe first step to calculate a SOM is to randomly assign a data vector to each cluster in the topology. If rows are being clustered, then the number of elements in each data vector is equal to the number of columns.\n\nAn SOM is then generated by taking rows one at a time, and finding which cluster in the topology has the closest data vector. The data vector of that cluster, as well as those of the neighboring clusters, are adjusted using the data vector of the row under consideration. The adjustment is given by\n\nThe parameter τ is a parameter that decreases at each iteration step. We have used a simple linear function of the iteration step:\n\nτ is the initial value of τ as specified by the user, i is the number of the current iteration step, and n is the total number of iteration steps to be performed. While changes are made rapidly in the beginning of the iteration, at the end of iteration only small changes are made.\n\nAll clusters within a radius R are adjusted to the gene under consideration. This radius decreases as the calculation progresses as\n\nin which the maximum radius is defined as\n\nwhere (N , N ) are the dimensions of the rectangle defining the topology.\n\nThe function implements the complete algorithm to calculate a Self-Organizing Map on a rectangular grid. First it initializes the random number generator. The node data are then initialized using the random number generator. The order in which genes or samples are used to modify the SOM is also randomized. The total number of iterations in the SOM algorithm is specified by the user.\n\nwhere the following arguments are defined:\n• (required) \n\n Array containing the data for the items.\n• (default: ) \n\n Array of integers showing which data are missing. If , then is missing. If is , then all data are present.\n• (default: ) \n\n contains the weights to be used when calculating distances. If is , then equal weights are assumed.\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n The number of cells horizontally and vertically in the rectangular grid on which the Self-Organizing Map is calculated.\n• (default: ) \n\n The initial value for the parameter τ that is used in the SOM algorithm. The default value for is 0.02, which was used in Michael Eisen’s Cluster/TreeView program.\n• (default: ) \n\n The number of iterations to be performed.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n• : \n\n An array with two columns, where the number of rows is equal to the number of items that were clustered. Each row contains the and coordinates of the cell in the rectangular SOM grid to which the item was assigned.\n• : \n\n An array with dimensions ( , , number of columns) if rows are being clustered, or ( , , number of rows) if columns are being clustered. Each element of this array is a 1D vector containing the gene expression data for the centroid of the cluster in the grid cell with coordinates .\n\nPrincipal Component Analysis (PCA) is a widely used technique for analyzing multivariate data. A practical example of applying Principal Component Analysis to gene expression data is presented by Yeung and Ruzzo (2001) [51].\n\nIn essence, PCA is a coordinate transformation in which each row in the data matrix is written as a linear sum over basis vectors called principal components, which are ordered and chosen such that each maximally explains the remaining variance in the data vectors. For example, an n × 3 data matrix can be represented as an ellipsoidal cloud of n points in three dimensional space. The first principal component is the longest axis of the ellipsoid, the second principal component the second longest axis of the ellipsoid, and the third principal component is the shortest axis. Each row in the data matrix can be reconstructed as a suitable linear combination of the principal components. However, in order to reduce the dimensionality of the data, usually only the most important principal components are retained. The remaining variance present in the data is then regarded as unexplained variance.\n\nThe principal components can be found by calculating the eigenvectors of the covariance matrix of the data. The corresponding eigenvalues determine how much of the variance present in the data is explained by each principal component.\n\nBefore applying principal component analysis, typically the mean is subtracted from each column in the data matrix. In the example above, this effectively centers the ellipsoidal cloud around its centroid in 3D space, with the principal components describing the variation of points in the ellipsoidal cloud with respect to their centroid.\n\nThe function below first uses the singular value decomposition to calculate the eigenvalues and eigenvectors of the data matrix. The singular value decomposition is implemented as a translation in C of the Algol procedure [14], which uses Householder bidiagonalization and a variant of the QR algorithm. The principal components, the coordinates of each data vector along the principal components, and the eigenvalues corresponding to the principal components are then evaluated and returned in decreasing order of the magnitude of the eigenvalue. If data centering is desired, the mean should be subtracted from each column in the data matrix before calling the routine.\n\nTo apply Principal Component Analysis to a rectangular matrix , use\n• Array containing the mean over each column in .\n• The coordinates of each row in with respect to the principal components.\n• The eigenvalues corresponding to each of the principal components.\n\nThe original matrix can be recreated by calculating .\n\nCluster/TreeView are GUI-based codes for clustering gene expression data. They were originally written by Michael Eisen while at Stanford University [12]. contains functions for reading and writing data files that correspond to the format specified for Cluster/TreeView. In particular, by saving a clustering result in that format, TreeView can be used to visualize the clustering results. We recommend using Alok Saldanha’s http://jtreeview.sourceforge.net/Java TreeView program [38], which can display hierarchical as well as k-means clustering results.\n\nAn object of the class contains all information stored in a Cluster/TreeView-type data file. To store the information contained in the data file in a object, we first open the file and then read it:\n\nThis two-step process gives you some flexibility in the source of the data. For example, you can use\n\nto open a file stored on the Internet before calling .\n\nThe command reads the tab-delimited text file containing gene expression data in the format specified for Michael Eisen’s Cluster/TreeView program. In this file format, rows represent genes and columns represent samples or observations. For a simple time course, a minimal input file would look like this:\n\nEach row (gene) has an identifier that always goes in the first column. In this example, we are using yeast open reading frame codes. Each column (sample) has a label in the first row. In this example, the labels describe the time at which a sample was taken. The first column of the first row contains a special field that tells the program what kind of objects are in each row. In this case, YORF stands for yeast open reading frame. This field can be any alphanumeric value. The remaining cells in the table contain data for the appropriate gene and sample. The 5.8 in row 2 column 4 means that the observed value for gene YAL001C at 2 hours was 5.8. Missing values are acceptable and are designated by empty cells (e.g. YAL004C at 2 hours).\n\nThe input file may contain additional information. A maximal input file would look like this:\n\nThe added columns NAME, GWEIGHT, and GORDER and rows EWEIGHT and EORDER are optional. The NAME column allows you to specify a label for each gene that is distinct from the ID in column 1.\n\nA object has the following attributes:\n• The data array containing the gene expression data. Genes are stored row-wise, while samples are stored column-wise.\n• This array shows which elements in the array, if any, are missing. If , then is missing. If no data were found to be missing, is set to .\n• This is a list containing a unique description for each gene (i.e., ORF numbers).\n• This is a list containing a description for each gene (i.e., gene name). If not present in the data file, is set to .\n• The weights that are to be used to calculate the distance in expression profile between genes. If not present in the data file, is set to .\n• The preferred order in which genes should be stored in an output file. If not present in the data file, is set to .\n• This is a list containing a description of each sample, e.g. experimental condition.\n• The weights that are to be used to calculate the distance in expression profile between samples. If not present in the data file, is set to .\n• The preferred order in which samples should be stored in an output file. If not present in the data file, is set to .\n• The string that was used instead of UNIQID in the data file.\n\nAfter loading a object, each of these attributes can be accessed and modified directly. For example, the data can be log-transformed by taking the logarithm of .\n\nTo calculate the distance matrix between the items stored in the record, use\n\nwhere the following arguments are defined:\n• (default: ) \n\n Determines if the distances between the rows of are to be calculated ( is ), or between the columns of ( is ).\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n\nThis function returns the distance matrix as a list of rows, where the number of columns of each row is equal to the row number (see section 18.1).\n\nTo calculate the centroids of clusters of items stored in the record, use\n• (default: ) \n\n Vector of integers showing to which cluster each item belongs. If is not given, then all items are assumed to belong to the same cluster.\n• (default: ) \n\n Specifies whether the arithmetic mean ( ) or the median ( ) is used to calculate the cluster center.\n• (default: ) \n\n Determines if the centroids of the rows of are to be calculated ( is ), or the centroids of the columns of ( is ).\n\nThis function returns the tuple ; see section 18.2 for a description.\n\nTo calculate the distance between clusters of items stored in the record, use\n\nwhere the following arguments are defined:\n• (default: ) \n\n A list containing the indices of the items belonging to the first cluster. A cluster containing only one item can be represented either as a list , or as an integer .\n• (default: ) \n\n A list containing the indices of the items belonging to the second cluster. A cluster containing only one item can be represented either as a list , or as an integer .\n• (default: ) \n\n Specifies how the distance between clusters is defined:\n• : Distance between the two cluster centroids (arithmetic mean);\n• : Distance between the two cluster centroids (median);\n• : Shortest pairwise distance between items in the two clusters;\n• : Longest pairwise distance between items in the two clusters;\n• : Average over the pairwise distances between items in the two clusters.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n• (default: ) \n\n If is , calculate the distance between the rows of . If is , calculate the distance between the columns of .\n\nTo perform hierarchical clustering on the items stored in the record, use\n\nwhere the following arguments are defined:\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n defines the linkage method to be used:\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n• Determines if genes or samples are being clustered. If is , genes (rows) are being clustered. If is , samples (columns) are clustered.\n\nThis function returns a object. This object contains (number of items − 1) nodes, where the number of items is the number of rows if rows were clustered, or the number of columns if columns were clustered. Each node describes a pairwise linking event, where the node attributes and each contain the number of one item or subnode, and the distance between them. Items are numbered from 0 to (number of items − 1), while clusters are numbered -1 to −(number of items−1).\n\nTo perform k-means or k-medians clustering on the items stored in the record, use\n\nwhere the following arguments are defined:\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n The number of times the -means/-medians clustering algorithm is performed, each time with a different (random) initial condition. If is given, the value of is ignored and the clustering algorithm is run only once, as it behaves deterministically in that case.\n• (default: ) \n\n describes how the center of a cluster is found: For other values of , the arithmetic mean is used.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n\nThis function returns a tuple , where is an integer array containing the number of the cluster to which each row or cluster was assigned, is the within-cluster sum of distances for the optimal clustering solution, and is the number of times this optimal solution was found.\n\nTo calculate a Self-Organizing Map of the items stored in the record, use\n\nwhere the following arguments are defined:\n• (default: ) \n\n Determines if rows ( is ) or columns ( is ) are to be clustered.\n• (default: ) \n\n The number of cells horizontally and vertically in the rectangular grid on which the Self-Organizing Map is calculated.\n• (default: ) \n\n The initial value for the parameter τ that is used in the SOM algorithm. The default value for is 0.02, which was used in Michael Eisen’s Cluster/TreeView program.\n• (default: ) \n\n The number of iterations to be performed.\n• (default: , Euclidean distance) \n\n Defines the distance function to be used (see 18.1).\n• : \n\n An array with two columns, where the number of rows is equal to the number of items that were clustered. Each row contains the and coordinates of the cell in the rectangular SOM grid to which the item was assigned.\n• : \n\n An array with dimensions ( , , number of columns) if rows are being clustered, or ( , , number of rows) if columns are being clustered. Each element of this array is a 1D vector containing the gene expression data for the centroid of the cluster in the grid cell with coordinates .\n\nTo save the clustering result, use\n\nwhere the following arguments are defined:\n• The string is used as the base name for names of the files that are to be saved.\n• This argument describes the gene (row-wise) clustering result. In case of -means clustering, this is a 1D array containing the number of the cluster each gene belongs to. It can be calculated using . In case of hierarchical clustering, is a object.\n• This argument describes the (column-wise) clustering result for the experimental conditions. In case of -means clustering, this is a 1D array containing the number of the cluster each experimental condition belongs to. It can be calculated using . In case of hierarchical clustering, is a object.\n\nThis method writes the text file , , , , and/or for subsequent reading by the Java TreeView program. If and are both , this method only writes the text file ; this file can subsequently be read into a new object.\n\nThis is an example of a hierarchical clustering calculation, using single linkage clustering for genes and maximum linkage clustering for experimental conditions. As the Euclidean distance is being used for gene clustering, it is necessary to scale the node distances such that they are all between zero and one. This is needed for the Java TreeView code to display the tree diagram correctly. To cluster the experimental conditions, the uncentered correlation is being used. No scaling is needed in this case, as the distances in are already between zero and two.\n\nThe example data can be found in Biopython’s subdirectory and is from the paper [20, Hihara et al., 2001].\n\nThis will create the files , , and .\n\nThis will create the files , , and .\n\nThe module depends on the third party Python library ReportLab. Although focused on producing PDF files, ReportLab can also create encapsulated postscript (EPS) and (SVG) files. In addition to these vector based images, provided certain further dependencies such as the Python Imaging Library (PIL) are installed, ReportLab can also output bitmap images (including JPEG, PNG, GIF, BMP and PICT formats).\n\nThe module was added to Biopython 1.50, having previously been available as a separate Python module dependent on Biopython. GenomeDiagram is described in the Bioinformatics journal publication by Pritchard et al. (2006) [35], which includes some examples images. There is a PDF copy of the old manual here, http://biopython.org/DIST/docs/GenomeDiagram/userguide.pdf which has some more examples.\n\nAs the name might suggest, GenomeDiagram was designed for drawing whole genomes, in particular prokaryotic genomes, either as linear diagrams (optionally broken up into fragments to fit better) or as circular wheel diagrams. Have a look at Figure 2 in Toth et al. (2006) [47] for a good example. It proved also well suited to drawing quite detailed figures for smaller genomes such as phage, plasmids or mitochondria, for example see Figures 1 and 2 in Van der Auwera et al. (2009) [48] (shown with additional manual editing).\n\nThis module is easiest to use if you have your genome loaded as a object containing lots of objects - for example as loaded from a GenBank file (see Chapters 4 and 5).\n\nGenomeDiagram uses a nested set of objects. At the top level, you have a diagram object representing a sequence (or sequence region) along the horizontal axis (or circle). A diagram can contain one or more tracks, shown stacked vertically (or radially on circular diagrams). These will typically all have the same length and represent the same sequence region. You might use one track to show the gene locations, another to show regulatory regions, and a third track to show the GC percentage.\n\nThe most commonly used type of track will contain features, bundled together in feature-sets. You might choose to use one feature-set for all your CDS features, and another for tRNA features. This isn’t required - they can all go in the same feature-set, but it makes it easier to update the properties of just selected features (e.g. make all the tRNA features red).\n\nThere are two main ways to build up a complete diagram. Firstly, the top down approach where you create a diagram object, and then using its methods add track(s), and use the track methods to add feature-set(s), and use their methods to add the features. Secondly, you can create the individual objects separately (in whatever order suits your code), and then combine them.\n\nWe’re going to draw a whole genome from a object read in from a GenBank file (see Chapter 5). This example uses the pPCP1 plasmid from Yersinia pestis biovar Microtus, the file is included with the Biopython unit tests under the GenBank folder, or online NC_005816.gb from our website.\n\nWe’re using a top down approach, so after loading in our sequence we next create an empty diagram, then add an (empty) track, and to that add an (empty) feature set:\n\nNow the fun part - we take each gene object in our , and use it to generate a feature on the diagram. We’re going to color them blue, alternating between a dark blue and a light blue.\n\nNow we come to actually making the output file. This happens in two steps, first we call the method, which creates all the shapes using ReportLab objects. Then we call the method which renders these to the requested file format. Note you can output in multiple file formats:\n\nAlso, provided you have the dependencies installed, you can also do bitmaps, for example:\n\nNotice that the argument which we set to four controls how many pieces the genome gets broken up into.\n\nIf you want to do a circular figure, then try this:\n\nThese figures are not very exciting, but we’ve only just got started.\n\nNow let’s produce exactly the same figures, but using the bottom up approach. This means we create the different objects directly (and this can be done in almost any order) and then combine them.\n\nYou can now call the and methods as before to produce a linear or circular diagram, using the code at the end of the top-down example above. The figures should be identical.\n\nIn the above example we used a ’s objects to build our diagram (see also Section 4.3). Sometimes you won’t have objects, but just the coordinates for a feature you want to draw. You have to create minimal object, but this is easy:\n\nFor strand, use +1 for the forward strand, -1 for the reverse strand, and None for both. Here is a short self contained example:\n\nThe top part of the image in the next subsection shows the output (in the default feature color, pale green).\n\nNotice that we have used the name argument here to specify the caption text for these features. This is discussed in more detail next.\n\nRecall we used the following (where feature was a object) to add a feature to the diagram:\n\nIn the example above the annotation was used to pick a sensible caption for the features. By default the following possible entries under the object’s qualifiers dictionary are used: gene, label, name, locus_tag, and product. More simply, you can specify a name directly:\n\nIn addition to the caption text for each feature’s label, you can also choose the font, position (this defaults to the start of the sigil, you can also choose the middle or at the end) and orientation (for linear diagrams only, where this defaults to rotated by 45 degrees):\n\nCombining each of these three fragments with the complete example in the previous section should give something like this:\n\nWe’ve not shown it here, but you can also set label_color to control the label’s color (used in Section 19.1.9).\n\nYou’ll notice the default font is quite small - this makes sense because you will usually be drawing many (small) features on a page, not just a few large ones as shown here.\n\nThe examples above have all just used the default sigil for the feature, a plain box, which was all that was available in the last publicly released standalone version of GenomeDiagram. Arrow sigils were included when GenomeDiagram was added to Biopython 1.50:\n\nThese are shown below. Most sigils fit into a bounding box (as given by the default BOX sigil), either above or below the axis for the forward or reverse strand, or straddling it (double the height) for strand-less features. The BIGARROW sigil is different, always straddling the axis with the direction taken from the feature’s stand.\n\nWe introduced the arrow sigils in the previous section. There are two additional options to adjust the shapes of the arrows, firstly the thickness of the arrow shaft, given as a proportion of the height of the bounding box:\n\nThe results are shown below:\n\nSecondly, the length of the arrow head - given as a proportion of the height of the bounding box (defaulting to 0.5, or 50%):\n\nThe results are shown below:\n\nBiopython 1.61 adds a new sigil which always straddles the axis, pointing left for the reverse strand or right otherwise:\n\nAll the shaft and arrow head options shown above for the sigil can be used for the sigil too.\n\nNow let’s return to the pPCP1 plasmid from Yersinia pestis biovar Microtus, and the top down approach used in Section 19.1.3, but take advantage of the sigil options we’ve now discussed. This time we’ll use arrows for the genes, and overlay them with strand-less features (as plain boxes) showing the position of some restriction digest sites.\n\nAll the examples so far have used a single track, but you can have more than one track – for example show the genes on one, and repeat regions on another. In this example we’re going to show three phage genomes side by side to scale, inspired by Figure 6 in Proux et al. (2002) [36]. We’ll need the GenBank files for the following three phage:\n• – Clip11262, complete genome, of which we are focussing only on integrated prophage 5 (similar length).\n\nYou can download these using Entrez if you like, see Section 12.6 for more details. For the third record we’ve worked out where the phage is integrated into the genome, and slice the record to extract it (with the features preserved, see Section 4.7), and must also reverse complement to match the orientation of the first two phage (again preserving the features, see Section 4.9):\n\nThe figure we are imitating used different colors for different gene functions. One way to do this is to edit the GenBank file to record color preferences for each feature - something Sanger’s Artemis editor does, and which GenomeDiagram should understand. Here however, we’ll just hard code three lists of colors.\n\nNote that the annotation in the GenBank files doesn’t exactly match that shown in Proux et al., they have drawn some unannotated genes.\n\nNow to draw them – this time we add three tracks to the diagram, and also notice they are given different start/end values to reflect their different lengths (this requires Biopython 1.59 or later).\n\nI did wonder why in the original manuscript there were no red or orange genes marked in the bottom phage. Another important point is here the phage are shown with different lengths - this is because they are all drawn to the same scale (they are different lengths).\n\nThe key difference from the published figure is they have color-coded links between similar proteins – which is what we will do in the next section.\n\nBiopython 1.59 added the ability to draw cross links between tracks - both simple linear diagrams as we will show here, but also linear diagrams split into fragments and circular diagrams.\n\nContinuing the example from the previous section inspired by Figure 6 from Proux et al. 2002 [36], we would need a list of cross links between pairs of genes, along with a score or color to use. Realistically you might extract this from a BLAST file computationally, but here I have manually typed them in.\n\nMy naming convention continues to refer to the three phage as A, B and C. Here are the links we want to show between A and B, given as a list of tuples (percentage similarity score, gene in A, gene in B).\n\nLikewise for B and C:\n\nFor the first and last phage these identifiers are locus tags, for the middle phage there are no locus tags so I’ve used gene names instead. The following little helper function lets us lookup a feature using either a locus tag or gene name:\n\nWe can now turn those list of identifier pairs into SeqFeature pairs, and thus find their location coordinates. We can now add all that code and the following snippet to the previous example (just before the line – see the finished example script Proux_et_al_2002_Figure_6.py included in the Doc/examples folder of the Biopython source code) to add cross links to the figure:\n\nThere are several important pieces to this code. First the object has a attribute which is just a list of objects. Each object takes two sets of track-specific coordinates (here given as tuples, you can alternatively use a object instead). You can optionally supply a color, border color, and say if this link should be drawn flipped (useful for showing inversions).\n\nYou can also see how we turn the BLAST percentage identity score into a color, interpolating between white (0%) and a dark red (100%). In this example we don’t have any problems with overlapping cross-links. One way to tackle that is to use transparency in ReportLab, by using colors with their alpha channel set. However, this kind of shaded color scheme combined with overlap transparency would be difficult to interpret. The result:\n\nThere is still a lot more that can be done within Biopython to help improve this figure. First of all, the cross links in this case are between proteins which are drawn in a strand specific manor. It can help to add a background region (a feature using the ‘BOX’ sigil) on the feature track to extend the cross link. Also, we could reduce the vertical height of the feature tracks to allocate more to the links instead – one way to do that is to allocate space for empty tracks. Furthermore, in cases like this where there are no large gene overlaps, we can use the axis-straddling sigil, which allows us to further reduce the vertical space needed for the track. These improvements are demonstrated in the example script Proux_et_al_2002_Figure_6.py included in the Doc/examples folder of the Biopython source code. The result:\n\nBeyond that, finishing touches you might want to do manually in a vector image editor include fine tuning the placement of gene labels, and adding other custom annotation such as highlighting particular regions.\n\nAlthough not really necessary in this example since none of the cross-links overlap, using a transparent color in ReportLab is a very useful technique for superimposing multiple links. However, in this case a shaded color scheme should be avoided.\n\nYou can control the tick marks to show the scale – after all every graph should show its units, and the number of the grey-track labels.\n\nAlso, we have only used the so far. GenomeDiagram also has a which can be used for show line graphs, bar charts and heat plots (e.g. to show plots of GC% on a track parallel to the features).\n\nThese options are not covered here yet, so for now we refer you to the User Guide (PDF) included with the standalone version of GenomeDiagram (but please read the next section first), and the docstrings.\n\nIf you have old code written using the standalone version of GenomeDiagram, and you want to switch it over to using the new version included with Biopython then you will have to make a few changes - most importantly to your import statements.\n\nAlso, the older version of GenomeDiagram used only the UK spellings of color and center (colour and centre). You will need to change to the American spellings, although for several years the Biopython version of GenomeDiagram supported both.\n\nFor example, if you used to have:\n\nyou could just switch the import statements like this:\n\nand hopefully that should be enough. In the long term you might want to switch to the new names, but you would have to change more of your code:\n\nIf you run into difficulties, please ask on the Biopython mailing list for advice. One catch is that we have not included the old module yet. This included a number of GC% related functions, which will probably be merged under later on.\n\nThe module allows drawing of chromosomes. There is an example in Jupe et al. (2012) [22] (open access) using colors to highlight different gene families.\n\nHere is a very simple example - for which we’ll use Arabidopsis thaliana.\n\nYou can skip this bit, but first I downloaded the five sequenced chromosomes as five individual FASTA files from the NCBI’s FTP site ftp://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Arabidopsis_thaliana/ and then parsed them with to find out their lengths. You could use the GenBank files for this (and the next example uses those for plotting features), but if all you want is the length it is faster to use the FASTA files for the whole chromosomes:\n\nThis gave the lengths of the five chromosomes, which we’ll now use in the following short demonstration of the module:\n\nThis should create a very simple PDF file, shown here:\n\nThis example is deliberately short and sweet. The next example shows the location of features of interest.\n\nContinuing from the previous example, let’s also show the tRNA genes. We’ll get their locations by parsing the GenBank files for the five Arabidopsis thaliana chromosomes. You’ll need to download these files from the NCBI FTP site ftp://ftp.ncbi.nlm.nih.gov/genomes/archive/old_refseq/Arabidopsis_thaliana/, and preserve the subdirectory names or edit the paths below:\n\nIt might warn you about the labels being too close together - have a look at the forward strand (right hand side) of Chr I, but it should create a colorful PDF file, shown here:\n\nKEGG (https://www.kegg.jp/) is a database resource for understanding high-level functions and utilities of the biological system, such as the cell, the organism and the ecosystem, from molecular-level information, especially large-scale molecular datasets generated by genome sequencing and other high-throughput experimental technologies.\n\nPlease note that the KEGG parser implementation in Biopython is incomplete. While the KEGG website indicates many flat file formats, only parsers and writers for compound, enzyme, and map are currently implemented. However, a generic parser is implemented to handle the other formats.\n\nParsing a KEGG record is as simple as using any other file format parser in Biopython. (Before running the following codes, please open http://rest.kegg.jp/get/ec:5.4.2.2 with your web browser and save it as .)\n\nAlternatively, if the input KEGG file has exactly one entry, you can use :\n\nThe following section will shows how to download the above enzyme using the KEGG api as well as how to use the generic parser with data that does not have a custom parser implemented.\n\nBiopython has full support for the querying of the KEGG api. Querying all KEGG endpoints are supported; all methods documented by KEGG (https://www.kegg.jp/kegg/rest/keggapi.html) are supported. The interface has some validation of queries which follow rules defined on the KEGG site. However, invalid queries which return a 400 or 404 must be handled by the user.\n\nFirst, here is how to extend the above example by downloading the relevant enzyme and passing it through the Enzyme parser.\n\nNow, here’s a more realistic example which shows a combination of querying the KEGG API. This will demonstrate how to extract a unique set of all human pathway gene symbols which relate to DNA repair. The steps that need to be taken to do so are as follows. First, we need to get a list of all human pathways. Secondly, we need to filter those for ones which relate to \"repair\". Lastly, we need to get a list of all the gene symbols in all repair pathways.\n\nThe KEGG API wrapper is compatible with all endpoints. Usage is essentially replacing all slashes in the url with commas and using that list as arguments to the corresponding method in the KEGG module. Here are a few examples from the api documentation (https://www.kegg.jp/kegg/docs/keggapi.html).\n\nThis chapter gives an overview of the functionalities of the package included in Biopython. The scope of this package is the analysis of phenotypic data, which means parsing and analyzing growth measurements of cell cultures. In its current state the package is focused on the analysis of high-throughput phenotypic experiments produced by the Phenotype Microarray technology, but future developments may include other platforms and formats.\n\nThe Phenotype Microarray is a technology that measures the metabolism of bacterial and eukaryotic cells on roughly 2000 chemicals, divided in twenty 96-well plates. The technology measures the reduction of a tetrazolium dye by NADH, whose production by the cell is used as a proxy for cell metabolism; color development due to the reduction of this dye is typically measured once every 15 minutes. When cells are grown in a media that sustains cell metabolism, the recorded phenotypic data resembles a sigmoid growth curve, from which a series of growth parameters can be retrieved.\n\nThe package can parse two different formats of Phenotype Microarray data: the CSV (comma separated values) files produced by the machine’s proprietary software and JSON files produced by analysis software, like opm or DuctApe. The parser will return one or a generator of PlateRecord objects, depending on whether the read or parse method is being used. You can test the parse function by using the Plates.csv file provided with the Biopython source code.\n\nThe parser returns a series of PlateRecord objects, each one containing a series of WellRecord objects (holding each well’s experimental data) arranged in 8 rows and 12 columns; each row is indicated by a uppercase character from A to H, while columns are indicated by a two digit number, from 01 to 12. There are several ways to access WellRecord objects from a PlateRecord objects:\n\nThe raw data extracted from the PM files is comprised of a series of tuples for each well, containing the time (in hours) and the colorimetric measure (in arbitrary units). Usually the instrument collects data every fifteen minutes, but that can vary between experiments. The raw data can be accessed by iterating on a WellRecord object; in the example below only the first ten time points are shown.\n\nThis method, while providing a way to access the raw data, doesn’t allow a direct comparison between different WellRecord objects, which may have measurements at different time points.\n\nTo make it easier to compare different experiments and in general to allow a more intuitive handling of the phenotypic data, the module allows to define a custom slicing of the time points that are present in the WellRecord object. Colorimetric data for time points that have not been directly measured are derived through a linear interpolation of the available data, otherwise a NaN is returned. This method only works in the time interval where actual data is available. Time intervals can be defined with the same syntax as list indexing; the default time interval is therefore one hour.\n\nDifferent time intervals can be used, for instance five minutes:\n\nMany Phenotype Microarray plates contain a control well (usually A01), that is a well where the media shouldn’t support any growth; the low signal produced by this well can be subtracted from the other wells. The PlateRecord objects have a dedicated function for that, which returns another PlateRecord object with the corrected data.\n\nThose wells where metabolic activity is observed show a sigmoid behavior for the colorimetric data. To allow an easier way to compare different experiments a sigmoid curve can be fitted onto the data, so that a series of summary parameters can be extracted and used for comparisons. The parameters that can be extracted from the curve are:\n\nAll the parameters (except min, max and average_height) require the scipy library to be installed.\n\nThe fit function uses three sigmoid functions:\n\nThese functions have been derived from this publication. The fit method by default tries first to fit the gompertz function: if it fails it will then try to fit the logistic and then the richards function. The user can also specify one of the three functions to be applied.\n\nPlateRecord objects can be written to file in the form of JSON files, a format compatible with other software packages such as opm or DuctApe.\n\nChapter 22 Cookbook – Cool things to do with it\n\nBiopython now has two collections of “cookbook” examples – this chapter (which has been included in this tutorial for many years and has gradually grown), and http://biopython.org/wiki/Category:Cookbook which is a user contributed collection on our wiki.\n\nWe’re trying to encourage Biopython users to contribute their own examples to the wiki. In addition to helping the community, one direct benefit of sharing an example like this is that you could also get some feedback on the code from other Biopython users and developers - which could help you improve all your Python code.\n\nIn the long term, we may end up moving all of the examples in this chapter to the wiki, or elsewhere within the tutorial.\n\nThis section shows some more examples of sequence input/output, using the module described in Chapter 5.\n\nOften you’ll have a large file with many sequences in it (e.g. FASTA file or genes, or a FASTQ or SFF file of reads), a separate shorter list of the IDs for a subset of sequences of interest, and want to make a new sequence file for this subset.\n\nLet’s say the list of IDs is in a simple text file, as the first word on each line. This could be a tabular file where the first column is the ID. Try something like this:\n\nNote that we use a Python rather than a , this makes testing membership faster.\n\nAs discussed in Section 5.6, for a large FASTA or FASTQ file for speed you would be better off not using the high-level interface, but working directly with strings. This next example shows how to do this with FASTQ files – it is more complicated:\n\nLet’s suppose you are looking at genome sequence, hunting for some sequence feature – maybe extreme local GC% bias, or possible restriction digest sites. Once you’ve got your Python code working on the real genome it may be sensible to try running the same search on randomized versions of the same genome for statistical analysis (after all, any “features” you’ve found could just be there just by chance).\n\nFor this discussion, we’ll use the GenBank file for the pPCP1 plasmid from Yersinia pestis biovar Microtus. The file is included with the Biopython unit tests under the GenBank folder, or you can get it from our website, NC_005816.gb. This file contains one and only one record, so we can read it in as a using the function:\n\nSo, how can we generate a shuffled versions of the original sequence? I would use the built in Python module for this, in particular the function – but this works on a Python list. Our sequence is a object, so in order to shuffle it we need to turn it into a list:\n\nNow, in order to use to output the shuffled sequence, we need to construct a new with a new object using this shuffled list. In order to do this, we need to turn the list of nucleotides (single letter strings) into a long string – the standard Python way to do this is with the string object’s join method.\n\nLet’s put all these pieces together to make a complete Python script which generates a single FASTA file containing 30 randomly shuffled versions of the original sequence.\n\nThis first version just uses a big for loop and writes out the records one by one (using the ’s format method described in Section 5.5.4):\n\nPersonally I prefer the following version using a function to shuffle the record and a generator expression instead of the for loop:\n\nSuppose you’ve got an input file of CDS entries for some organism, and you want to generate a new FASTA file containing their protein sequences. i.e. Take each nucleotide sequence from the original file, and translate it. Back in Section 3.8 we saw how to use the object’s , and the optional argument which enables correct translation of alternative start codons.\n\nWe can combine this with as shown in the reverse complement example in Section 5.5.3. The key point is that for each nucleotide , we need to create a protein - and take care of naming it.\n\nYou can write you own function to do this, choosing suitable protein identifiers for your sequences, and the appropriate genetic code. In this example we just use the default table and add a prefix to the identifier:\n\nWe can then use this function to turn the input nucleotide records into protein records ready for output. An elegant way and memory efficient way to do this is with a generator expression:\n\nThis should work on any FASTA file of complete coding sequences. If you are working on partial coding sequences, you may prefer to use in the example above, as this wouldn’t check for a valid start codon etc.\n\nOften you’ll get data from collaborators as FASTA files, and sometimes the sequences can be in a mixture of upper and lower case. In some cases this is deliberate (e.g. lower case for poor quality regions), but usually it is not important. You may want to edit the file to make everything consistent (e.g. all upper case), and you can do this easily using the method of the object (added in Biopython 1.55):\n\nHow does this work? The first line is just importing the module. The second line is the interesting bit – this is a Python generator expression which gives an upper case version of each record parsed from the input file (mixed.fas). In the third line we give this generator expression to the function and it saves the new upper cases records to our output file (upper.fas).\n\nThe reason we use a generator expression (rather than a list or list comprehension) is this means only one record is kept in memory at a time. This can be really important if you are dealing with large files with millions of entries.\n\nSuppose you wanted to sort a sequence file by length (e.g. a set of contigs from an assembly), and you are working with a file format like FASTA or FASTQ which can read, write (and index).\n\nIf the file is small enough, you can load it all into memory at once as a list of objects, sort the list, and save it:\n\nThe only clever bit is specifying a comparison method for how to sort the records (here we sort them by length). If you wanted the longest records first, you could flip the comparison or use the reverse argument:\n\nNow that’s pretty straight forward - but what happens if you have a very large file and you can’t load it all into memory like this? For example, you might have some next-generation sequencing reads to sort by length. This can be solved using the function.\n\nFirst we scan through the file once using , recording the record identifiers and their lengths in a list of tuples. We then sort this list to get them in length order, and discard the lengths. Using this sorted list of identifiers allows us to retrieve the records one by one, and we pass them to for output.\n\nThese examples all use to parse the records into objects which are output using . What if you want to sort a file format which doesn’t support, like the plain text SwissProt format? Here is an alternative solution using the method added to in Biopython 1.54 (see Section 5.4.2.2).\n\nNote with Python 3 onwards, we have to open the file for writing in binary mode because the method returns objects.\n\nAs a bonus, because it doesn’t parse the data into objects a second time it should be faster. If you only want to use this with FASTA format, we can speed this up one step further by using the low-level FASTA parser to get the record identifiers and lengths:\n\nThe FASTQ file format was introduced at Sanger and is now widely used for holding nucleotide sequencing reads together with their quality scores. FASTQ files (and the related QUAL files) are an excellent example of per-letter-annotation, because for each nucleotide in the sequence there is an associated quality score. Any per-letter-annotation is held in a in the dictionary as a list, tuple or string (with the same number of elements as the sequence length).\n\nOne common task is taking a large set of sequencing reads and filtering them (or cropping them) based on their quality scores. The following example is very simplistic, but should illustrate the basics of working with quality data in a object. All we are going to do here is read in a file of FASTQ data, and filter it to pick out only those records whose PHRED quality scores are all above some threshold (here 20).\n\nFor this example we’ll use some real data downloaded from the ENA sequence read archive, ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz (2MB) which unzips to a 19MB file SRR020192.fastq. This is some Roche 454 GS FLX single end data from virus infected California sea lions (see https://www.ebi.ac.uk/ena/data/view/SRS004476 for details).\n\nNow let’s do a simple filtering for a minimum PHRED quality of 20:\n\nThis pulled out only 14580 reads out of the 41892 present. A more sensible thing to do would be to quality trim the reads, but this is intended as an example only.\n\nFASTQ files can contain millions of entries, so it is best to avoid loading them all into memory at once. This example uses a generator expression, which means only one is created at a time - avoiding any memory limitations.\n\nNote that it would be faster to use the low-level parser here (see Section 5.6), but that does not turn the quality string into integer scores.\n\nFor this example we’re going to pretend that GATGACGGTGT is a 5’ primer sequence we want to look for in some FASTQ formatted read data. As in the example above, we’ll use the SRR020192.fastq file downloaded from the ENA (ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz).\n\nBy using the main interface, the same approach would work with any other supported file format (e.g. FASTA files). However, for large FASTQ files it would be faster the low-level parser here (see the earlier example, and Section 5.6).\n\nThis code uses with a generator expression (to avoid loading all the sequences into memory at once), and the object’s method to see if the read starts with the primer sequence:\n\nThat should find 13819 reads from SRR014849.fastq and save them to a new FASTQ file, with_primer.fastq.\n\nNow suppose that instead you wanted to make a FASTQ file containing these reads but with the primer sequence removed? That’s just a small change as we can slice the (see Section 4.7) to remove the first eleven letters (the length of our primer):\n\nAgain, that should pull out the 13819 reads from SRR020192.fastq, but this time strip off the first ten characters, and save them to another new FASTQ file, with_primer_trimmed.fastq.\n\nNow, suppose you want to create a new FASTQ file where these reads have their primer removed, but all the other reads are kept as they were? If we want to still use a generator expression, it is probably clearest to define our own trim function:\n\nThis takes longer, as this time the output file contains all 41892 reads. Again, we’re used a generator expression to avoid any memory problems. You could alternatively use a generator function rather than a generator expression.\n\nThis form is more flexible if you want to do something more complicated where only some of the records are retained – as shown in the next example.\n\nThis is essentially a simple extension to the previous example. We are going to going to pretend GATGACGGTGT is an adaptor sequence in some FASTQ formatted read data, again the SRR020192.fastq file from the NCBI (ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz).\n\nThis time however, we will look for the sequence anywhere in the reads, not just at the very beginning:\n\nBecause we are using a FASTQ input file in this example, the objects have per-letter-annotation for the quality scores. By slicing the object the appropriate scores are used on the trimmed records, so we can output them as a FASTQ file too.\n\nCompared to the output of the previous example where we only looked for a primer/adaptor at the start of each read, you may find some of the trimmed reads are quite short after trimming (e.g. if the adaptor was found in the middle rather than near the start). So, let’s add a minimum length requirement as well:\n\nBy changing the format names, you could apply this to FASTA files instead. This code also could be extended to do a fuzzy match instead of an exact match (maybe using a pairwise alignment, or taking into account the read quality scores), but that will be much slower.\n\nBack in Section 5.5.2 we showed how to use to convert between two file formats. Here we’ll go into a little more detail regarding FASTQ files which are used in second generation DNA sequencing. Please refer to Cock et al. (2009) [6] for a longer description. FASTQ files store both the DNA sequence (as a string) and the associated read qualities.\n\nPHRED scores (used in most FASTQ files, and also in QUAL files, ACE files and SFF files) have become a de facto standard for representing the probability of a sequencing error (here denoted by P ) at a given base using a simple base ten log transformation:\n\nThis means a wrong read (P = 1) gets a PHRED quality of 0, while a very good read like P = 0.00001 gets a PHRED quality of 50. While for raw sequencing data qualities higher than this are rare, with post processing such as read mapping or assembly, qualities of up to about 90 are possible (indeed, the MAQ tool allows for PHRED scores in the range 0 to 93 inclusive).\n\nThe FASTQ format has the potential to become a de facto standard for storing the letters and quality scores for a sequencing read in a single plain text file. The only fly in the ointment is that there are at least three versions of the FASTQ format which are incompatible and difficult to distinguish...\n• The original Sanger FASTQ format uses PHRED qualities encoded with an ASCII offset of 33. The NCBI are using this format in their Short Read Archive. We call this the (or ) format in .\n• Solexa (later bought by Illumina) introduced their own version using Solexa qualities encoded with an ASCII offset of 64. We call this the format.\n• Illumina pipeline 1.3 onwards produces FASTQ files with PHRED qualities (which is more consistent), but encoded with an ASCII offset of 64. We call this the format.\n\nThe Solexa quality scores are defined using a different log transformation:\n\nGiven Solexa/Illumina have now moved to using PHRED scores in version 1.3 of their pipeline, the Solexa quality scores will gradually fall out of use. If you equate the error estimates (P ) these two equations allow conversion between the two scoring systems - and Biopython includes functions to do this in the module, which are called if you use to convert an old Solexa/Illumina file into a standard Sanger FASTQ file:\n\nIf you want to convert a new Illumina 1.3+ FASTQ file, all that gets changed is the ASCII offset because although encoded differently the scores are all PHRED qualities:\n\nNote that using like this is much faster than combining and because optimized code is used for converting between FASTQ variants (and also for FASTQ to FASTA conversion).\n\nFor good quality reads, PHRED and Solexa scores are approximately equal, which means since both the fasta-solexa and fastq-illumina formats use an ASCII offset of 64 the files are almost the same. This was a deliberate design choice by Illumina, meaning applications expecting the old fasta-solexa style files will probably be OK using the newer fastq-illumina files (on good data). Of course, both variants are very different from the original FASTQ standard as used by Sanger, the NCBI, and elsewhere (format name fastq or fastq-sanger).\n\nFor more details, see the built in help (also online):\n\nFASTQ files hold both sequences and their quality strings. FASTA files hold just sequences, while QUAL files hold just the qualities. Therefore a single FASTQ file can be converted to or from paired FASTA and QUAL files.\n\nGoing from FASTQ to FASTA is easy:\n\nGoing from FASTQ to QUAL is also easy:\n\nHowever, the reverse is a little more tricky. You can use to iterate over the records in a single file, but in this case we have two input files. There are several strategies possible, but assuming that the two files are really paired the most memory efficient way is to loop over both together. The code is a little fiddly, so we provide a function called in the module to do this. This takes two handles (the FASTA file and the QUAL file) and returns a iterator:\n\nThis function will check that the FASTA and QUAL files are consistent (e.g. the records are in the same order, and have the same sequence length). You can combine this with the function to convert a pair of FASTA and QUAL files into a single FASTQ files:\n\nFASTQ files are usually very large, with millions of reads in them. Due to the sheer amount of data, you can’t load all the records into memory at once. This is why the examples above (filtering and trimming) iterate over the file looking at just one at a time.\n\nHowever, sometimes you can’t use a big loop or an iterator - you may need random access to the reads. Here the function may prove very helpful, as it allows you to access any read in the FASTQ file by its name (see Section 5.4.2).\n\nAgain we’ll use the SRR020192.fastq file from the ENA (ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz), although this is actually quite a small FASTQ file with less than 50,000 reads:\n\nWhen testing this on a FASTQ file with seven million reads, indexing took about a minute, but record access was almost instant.\n\nThe sister function lets you save the index to an SQLite3 database file for near instantaneous reuse - see Section 5.4.2 for more details.\n\nThe example in Section 22.1.5 show how you can use the function to sort a large FASTA file – this could also be used on FASTQ files.\n\nIf you work with 454 (Roche) sequence data, you will probably have access to the raw data as a Standard Flowgram Format (SFF) file. This contains the sequence reads (called bases) with quality scores and the original flow information.\n\nA common task is to convert from SFF to a pair of FASTA and QUAL files, or to a single FASTQ file. These operations are trivial using the function (see Section 5.5.2):\n\nRemember the convert function returns the number of records, in this example just ten. This will give you the untrimmed reads, where the leading and trailing poor quality sequence or adaptor will be in lower case. If you want the trimmed reads (using the clipping information recorded within the SFF file) use this:\n\nIf you run Linux, you could ask Roche for a copy of their “off instrument” tools (often referred to as the Newbler tools). This offers an alternative way to do SFF to FASTA or QUAL conversion at the command line (but currently FASTQ output is not supported), e.g.\n\nThe way Biopython uses mixed case sequence strings to represent the trimming points deliberately mimics what the Roche tools do.\n\nFor more information on the Biopython SFF support, consult the built in help:\n\nA very simplistic first step at identifying possible genes is to look for open reading frames (ORFs). By this we mean look in all six frames for long regions without stop codons – an ORF is just a region of nucleotides with no in frame stop codons.\n\nOf course, to find a gene you would also need to worry about locating a start codon, possible promoters – and in Eukaryotes there are introns to worry about too. However, this approach is still useful in viruses and Prokaryotes.\n\nTo show how you might approach this with Biopython, we’ll need a sequence to search, and as an example we’ll again use the bacterial plasmid – although this time we’ll start with a plain FASTA file with no pre-marked genes: NC_005816.fna. This is a bacterial sequence, so we’ll want to use NCBI codon table 11 (see Section 3.8 about translation).\n\nHere is a neat trick using the object’s method to get a list of all the possible ORF translations in the six reading frames:\n\nNote that here we are counting the frames from the 5’ end (start) of each strand. It is sometimes easier to always count from the 5’ end (start) of the forward strand.\n\nYou could easily edit the above loop based code to build up a list of the candidate proteins, or convert this to a list comprehension. Now, one thing this code doesn’t do is keep track of where the proteins are.\n\nYou could tackle this in several ways. For example, the following code tracks the locations in terms of the protein counting, and converts back to the parent sequence by multiplying by three, then adjusting for the frame and strand:\n\nIf you comment out the sort statement, then the protein sequences will be shown in the same order as before, so you can check this is doing the same thing. Here we have sorted them by location to make it easier to compare to the actual annotation in the GenBank file (as visualized in Section 19.1.9).\n\nIf however all you want to find are the locations of the open reading frames, then it is a waste of time to translate every possible codon, including doing the reverse complement to search the reverse strand too. All you need to do is search for the possible stop codons (and their reverse complements). Using regular expressions is an obvious approach here (see the Python module ). These are an extremely powerful (but rather complex) way of describing search strings, which are supported in lots of programming languages and also command line tools like grep as well). You can find whole books about this topic!\n\nThis section shows some more examples of sequence parsing, using the module described in Chapter 5, plus the Python library matplotlib’s plotting interface (see the matplotlib website for a tutorial). Note that to follow these examples you will need matplotlib installed - but without it you can still try the data parsing bits.\n\nThere are lots of times when you might want to visualize the distribution of sequence lengths in a dataset – for example the range of contig sizes in a genome assembly project. In this example we’ll reuse our orchid FASTA file ls_orchid.fasta which has only 94 sequences.\n\nFirst of all, we will use to parse the FASTA file and compile a list of all the sequence lengths. You could do this with a for loop, but I find a list comprehension more pleasing:\n\nNow that we have the lengths of all the genes (as a list of integers), we can use the matplotlib histogram function to display it.\n\nThat should pop up a new window containing the following graph:\n\nNotice that most of these orchid sequences are about 740 bp long, and there could be two distinct classes of sequence here with a subset of shorter sequences.\n\nTip: Rather than using to show the plot in a window, you can also use to save the figure to a file (e.g. as a PNG or PDF).\n\nAnother easily calculated quantity of a nucleotide sequence is the GC%. You might want to look at the GC% of all the genes in a bacterial genome for example, and investigate any outliers which could have been recently acquired by horizontal gene transfer. Again, for this example we’ll reuse our orchid FASTA file ls_orchid.fasta.\n\nFirst of all, we will use to parse the FASTA file and compile a list of all the GC percentages. Again, you could do this with a for loop, but I prefer this:\n\nHaving read in each sequence and calculated the GC%, we then sorted them into ascending order. Now we’ll take this list of floating point values and plot them with matplotlib:\n\nAs in the previous example, that should pop up a new window containing a graph:\n\nIf you tried this on the full set of genes from one organism, you’d probably get a much smoother plot than this.\n\nA dot plot is a way of visually comparing two nucleotide sequences for similarity to each other. A sliding window is used to compare short sub-sequences to each other, often with a mismatch threshold. Here for simplicity we’ll only look for perfect matches (shown in black in the plot below).\n\nTo start off, we’ll need two sequences. For the sake of argument, we’ll just take the first two from our orchid FASTA file ls_orchid.fasta:\n\nWe’re going to show two approaches. Firstly, a simple naive implementation which compares all the window sized sub-sequences to each other to compiles a similarity matrix. You could construct a matrix or array object, but here we just use a list of lists of booleans created with a nested list comprehension:\n\nNote that we have not checked for reverse complement matches here. Now we’ll use the matplotlib’s function to display this data, first requesting the gray color scheme so this is done in black and white:\n\nThat should pop up a new window containing a graph like this:\n\nAs you might have expected, these two sequences are very similar with a partial line of window sized matches along the diagonal. There are no off diagonal matches which would be indicative of inversions or other interesting events.\n\nThe above code works fine on small examples, but there are two problems applying this to larger sequences, which we will address below. First off all, this brute force approach to the all against all comparisons is very slow. Instead, we’ll compile dictionaries mapping the window sized sub-sequences to their locations, and then take the set intersection to find those sub-sequences found in both sequences. This uses more memory, but is much faster. Secondly, the function is limited in the size of matrix it can display. As an alternative, we’ll use the function.\n\nWe start by creating dictionaries mapping the window-sized sub-sequences to locations:\n\nIn order to use the we need separate lists for the x and y coordinates:\n\nWe are now ready to draw the revised dot plot as a scatter plot:\n\nThat should pop up a new window containing a graph like this:\n\nPersonally I find this second plot much easier to read! Again note that we have not checked for reverse complement matches here – you could extend this example to do this, and perhaps plot the forward matches in one color and the reverse matches in another.\n\nIf you are working with second generation sequencing data, you may want to try plotting the quality data. Here is an example using two FASTQ files containing paired end reads, SRR001666_1.fastq for the forward reads, and SRR001666_2.fastq for the reverse reads. These were downloaded from the ENA sequence read archive FTP site (ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz and ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz), and are from E. coli – see https://www.ebi.ac.uk/ena/data/view/SRR001666 for details.\n\nIn the following code the function is used in order to show the forward and reverse qualities on two subplots, side by side. There is also a little bit of code to only plot the first fifty reads.\n\nYou should note that we are using the format name fastq here because the NCBI has saved these reads using the standard Sanger FASTQ format with PHRED scores. However, as you might guess from the read lengths, this data was from an Illumina Genome Analyzer and was probably originally in one of the two Solexa/Illumina FASTQ variant file formats instead.\n\nThis example uses the function instead of , but as mentioned before both are useful. Here is the result:\n\nBioSQL is a joint effort between the OBF projects (BioPerl, BioJava etc) to support a shared database schema for storing sequence data. In theory, you could load a GenBank file into the database with BioPerl, then using Biopython extract this from the database as a record object with features - and get more or less the same thing as if you had loaded the GenBank file directly as a SeqRecord using (Chapter 5).\n\nBiopython’s BioSQL module is currently documented at http://biopython.org/wiki/BioSQL which is part of our wiki pages.\n\nBiopython has a regression testing framework (the file ) based on unittest, the standard unit testing framework for Python. Providing comprehensive tests for modules is one of the most important aspects of making sure that the Biopython code is as bug-free as possible before going out. It also tends to be one of the most undervalued aspects of contributing. This chapter is designed to make running the Biopython tests and writing good test code as easy as possible. Ideally, every module that goes into Biopython should have a test (and should also have documentation!). All our developers, and anyone installing Biopython from source, are strongly encouraged to run the unit tests.\n\nWhen you download the Biopython source code, or check it out from our source code repository, you should find a subdirectory call . This contains the key script , lots of individual scripts named , and lots of other subdirectories which contain input files for the test suite.\n\nAs part of building and installing Biopython you will typically run the full test suite at the command line from the Biopython source top level directory using the following:\n\nThis is actually equivalent to going to the subdirectory and running:\n\nYou’ll often want to run just some of the tests, and this is done like this:\n\nWhen giving the list of tests, the extension is optional, so you can also just type:\n\nTo run the docstring tests (see section 23.3), you can use\n\nYou can also skip any tests which have been setup with an explicit online component by adding , e.g.\n\nBy default, runs all tests, including the docstring tests.\n\nIf an individual test is failing, you can also try running it directly, which may give you more information.\n\nTests based on Python’s standard framework will and then define classes, each with one or more sub-tests as methods starting with which check some specific aspect of the code.\n\nLike most Python projects, you can also use Tox to run the tests on multiple Python versions, provided they are already installed in your system.\n\nWe do not provide the configuration tox.ini file in our code base because of difficulties pinning down user-specific settings (e.g. executable names of the Python versions). You may also only be interested in testing Biopython only against a subset of the Python versions that we support.\n\nIf you are interested in using Tox, you could start with the example tox.ini shown below:\n\nUsing the template above, executing tox will test your Biopython code against PyPy, Python 3.8 and 3.9. It assumes that those Pythons’ executables are named “python3.8“ for Python 3.8, and so on.\n\nLet’s say you want to write some tests for a module called . This can be a module you wrote, or an existing module that doesn’t have any tests yet. In the examples below, we assume that is a module that does simple math.\n\nEach Biopython test consists of a script containing the test itself, and optionally a directory with input files used by the test:\n• – The actual test code for your module.\n• [optional]– A directory where any necessary input files will be located. If you have any output files that should be manually reviewed, output them here (but this is discouraged) to prevent clogging up the main Tests directory. In general, use a temporary file/folder.\n\nAny script with a prefix in the directory will be found and run by . Below, we show an example test script . If you put this script in the Biopython directory, then will find it and execute the tests contained in it:\n\nThe -framework has been included with Python since version 2.1, and is documented in the Python Library Reference (which I know you are keeping under your pillow, as recommended). There is also online documentation for unittest. If you are familiar with the system (or something similar like the nose test framework), you shouldn’t have any trouble. You may find looking at the existing examples within Biopython helpful too.\n\nHere’s a minimal -style test script for , which you can copy and paste to get started:\n\nIn the division tests, we use instead of to avoid tests failing due to roundoff errors; see the chapter in the Python documentation for details and for other functionality available in (online reference).\n\nThese are the key points of -based tests:\n• Test cases are stored in classes that derive from and cover one basic aspect of your code\n• You can use methods and for any repeated code which should be run before and after each test method. For example, the method might be used to create an instance of the object you are testing, or open a file handle. The should do any “tidying up”, for example closing the file handle.\n• The tests are prefixed with and each test should cover one specific part of what you are trying to test. You can have as many tests as you want in a class.\n• At the end of the test script, you can use to execute the tests when the script is run by itself (rather than imported from ). If you run this script, then you’ll see something like the following: $ python test_BiospamMyModule.py test_addition1 (__main__.TestAddition) ... ok test_addition2 (__main__.TestAddition) ... ok test_division1 (__main__.TestDivision) ... ok test_division2 (__main__.TestDivision) ... ok ---------------------------------------------------------------------- Ran 4 tests in 0.059s OK\n• To indicate more clearly what each test is doing, you can add docstrings to each test. These are shown when running the tests, which can be useful information if a test is failing. import unittest from Bio import Biospam class BiospamTestAddition(unittest.TestCase): def test_addition1(self): \"\"\"An addition test\"\"\" result = Biospam.addition(2, 3) self.assertEqual(result, 5) def test_addition2(self): \"\"\"A second addition test\"\"\" result = Biospam.addition(9, -1) self.assertEqual(result, 8) class BiospamTestDivision(unittest.TestCase): def test_division1(self): \"\"\"Now let's check division\"\"\" result = Biospam.division(3.0, 2.0) self.assertAlmostEqual(result, 1.5) def test_division2(self): \"\"\"A second division test\"\"\" result = Biospam.division(10.0, -2.0) self.assertAlmostEqual(result, -5.0) if __name__ == \"__main__\": runner = unittest.TextTestRunner(verbosity=2) unittest.main(testRunner=runner) Running the script will now show you: $ python test_BiospamMyModule.py An addition test ... ok A second addition test ... ok Now let's check division ... ok A second division test ... ok ---------------------------------------------------------------------- Ran 4 tests in 0.001s OK\n\nIf your module contains docstring tests (see section 23.3), you may want to include those in the tests to be run. You can do so as follows by modifying the code under to look like this:\n\nThis is only relevant if you want to run the docstring tests when you execute if it has some complex run-time dependency checking.\n\nIn general instead include the docstring tests by adding them to the as explained below.\n\nPython modules, classes and functions support built in documentation using docstrings. The doctest framework (included with Python) allows the developer to embed working examples in the docstrings, and have these examples automatically tested.\n\nCurrently only part of Biopython includes doctests. The script takes care of running the doctests. For this purpose, at the top of the script is a manually compiled list of modules to skip, important where optional external dependencies which may not be installed (e.g. the Reportlab and NumPy libraries). So, if you’ve added some doctests to the docstrings in a Biopython module, in order to have them excluded in the Biopython test suite, you must update to include your module. Currently, the relevant part of looks as follows:\n\nNote that we regard doctests primarily as documentation, so you should stick to typical usage. Generally complicated examples dealing with error conditions and the like would be best left to a dedicated unit test.\n\nNote that if you want to write doctests involving file parsing, defining the file location complicates matters. Ideally use relative paths assuming the code will be run from the directory, see the doctests for an example of this.\n\nTo run the docstring tests only, use\n\nNote that the doctest system is fragile and care is needed to ensure your output will match on all the different versions of Python that Biopython supports (e.g. differences in floating point numbers).\n\nThis Tutorial you are reading has a lot of code snippets, which are often formatted like a doctest. We have our own system in file to allow tagging code snippets in the Tutorial source to be run as Python doctests. This works by adding special comment lines before each Python block, e.g.\n\nOften code examples are not self-contained, but continue from the previous Python block. Here we use the magic comment as shown here:\n\nThe special comment line can take a working directory (relative to the folder) to use if you have any example data files, e.g. will use the folder, while will use the folder.\n\nAfter the directory argument, you can specify any Python dependencies which must be present in order to run the test by adding to indicate must work, e.g.\n\nYou can run the Tutorial doctests via:\n\nChapter 24 Where to go from here – contributing to Biopython\n\nGetting feedback on the Biopython modules is very important to us. Open-source projects like this benefit greatly from feedback, bug-reports (and patches!) from a wide variety of contributors.\n\nThe main forums for discussing feature requests and potential bugs are the Biopython mailing list and issues or pull requests on GitHub.\n\nAdditionally, if you think you’ve found a new bug, you can submit it to our issue tracker at https://github.com/biopython/biopython/issues (this replaced the older Open Bioinformatics Foundation hosted RedMine tracker). This way, it won’t get buried in anyone’s Inbox and forgotten about.\n\nWe encourage all our uses to sign up to the main Biopython mailing list. Once you’ve got the hang of an area of Biopython, we’d encourage you to help answer questions from beginners. After all, you were a beginner once.\n\nWe’re happy to take feedback or contributions - either via a bug-report or on the Mailing List. While reading this tutorial, perhaps you noticed some topics you were interested in which were missing, or not clearly explained. There is also Biopython’s built in documentation (the docstrings, these are also online), where again, you may be able to help fill in any blanks.\n\nAs explained in Chapter 22, Biopython now has a wiki collection of user contributed “cookbook” examples, http://biopython.org/wiki/Category:Cookbook – maybe you can add to this?\n\nWe currently provide source code archives (suitable for any OS, if you have the right build tools installed), and pre-compiled wheels via https://github.com/biopython/biopython-wheels to cover the major operating systems.\n\nMost major Linux distributions have volunteers who take these source code releases, and compile them into packages for Linux users to easily install (taking care of dependencies etc). This is really great and we are of course very grateful. If you would like to contribute to this work, please find out more about how your Linux distribution handles this. There is a similar process for conda packages via https://github.com/conda-forge/biopython-feedstock thanks to the conda-forge team.\n\nBelow are some tips for certain platforms to maybe get people started with helping out:\n\nOnce you’ve got a package, please test it on your system to make sure it installs everything in a good way and seems to work properly. Once you feel good about it, make a pull request on GitHub and write to our Biopython mailing list. You’ve done it. Thanks!\n\nEven if you don’t have any new functionality to add to Biopython, but you want to write some code, please consider extending our unit test coverage. We’ve devoted all of Chapter 23 to this topic.\n\nThere are no barriers to joining Biopython code development other than an interest in creating biology-related code in Python. The best place to express an interest is on the Biopython mailing lists – just let us know you are interested in coding and what kind of stuff you want to work on. Normally, we try to have some discussion on modules before coding them, since that helps generate good ideas – then just feel free to jump right in and start coding!\n\nThe main Biopython release tries to be fairly uniform and interworkable, to make it easier for users. You can read about some of (fairly informal) coding style guidelines we try to use in Biopython in the contributing documentation at http://biopython.org/wiki/Contributing. We also try to add code to the distribution along with tests (see Chapter 23 for more info on the regression testing framework) and documentation, so that everything can stay as workable and well documented as possible (including docstrings). This is, of course, the most ideal situation, under many situations you’ll be able to find other people on the list who will be willing to help add documentation or more tests for your code once you make it available. So, to end this paragraph like the last, feel free to start working!\n\nPlease note that to make a code contribution you must have the legal right to contribute it and license it under the Biopython license. If you wrote it all yourself, and it is not based on any other code, this shouldn’t be a problem. However, there are issues if you want to contribute a derivative work - for example something based on GPL or LPGL licensed code would not be compatible with our license. If you have any queries on this, please discuss the issue on the mailing list or GitHub.\n\nAnother point of concern for any additions to Biopython regards any build time or run time dependencies. Generally speaking, writing code to interact with a standalone tool (like BLAST, EMBOSS or ClustalW) doesn’t present a big problem. However, any dependency on another library - even a Python library (especially one needed in order to compile and install Biopython like NumPy) would need further discussion.\n\nAdditionally, if you have code that you don’t think fits in the distribution, but that you want to make available, we maintain Script Central (http://biopython.org/wiki/Scriptcentral) which has pointers to freely available code in Python for bioinformatics.\n\nHopefully this documentation has got you excited enough about Biopython to try it out (and most importantly, contribute!). Thanks for reading all the way through!\n\nIf you haven’t spent a lot of time programming in Python, many questions and problems that come up in using Biopython are often related to Python itself. This section tries to present some ideas and code that come up often (at least for us!) while using the Biopython libraries. If you have any suggestions for useful pointers that could go here, please contribute!\n\n25.1 What the heck is a handle?\n\nHandles are mentioned quite frequently throughout this documentation, and are also fairly confusing (at least to me!). Basically, you can think of a handle as being a “wrapper” around text information.\n\nHandles provide (at least) two benefits over plain text information:\n• They provide a standard way to deal with information stored in different ways. The text information can be in a file, or in a string stored in memory, or the output from a command line program, or at some remote website, but the handle provides a common way of dealing with information in all of these formats.\n• They allow text information to be read incrementally, instead of all at once. This is really important when you are dealing with huge text files which would use up all of your memory if you had to load them all.\n\nHandles can deal with text information that is being read (e. g. reading from a file) or written (e. g. writing information to a file). In the case of a “read” handle, commonly used functions are , which reads the entire text information from the handle, and , which reads information one line at a time. For “write” handles, the function is regularly used.\n\nThe most common usage for handles is reading information from a file, which is done using the built-in Python function . Here, we handle to the file m_cold.fasta which you can download here (or find included in the Biopython source code as Doc/examples/m_cold.fasta).\n\nHandles are regularly used in Biopython for passing information to parsers. For example, since Biopython 1.54 the main functions in and have allowed you to use a filename instead of a handle:\n\nOn older versions of Biopython you had to use a handle, e.g.\n\nThis pattern is still useful - for example suppose you have a gzip compressed FASTA file you want to parse:\n\nWith our parsers for plain text files, it is essential to use gzip in text mode (the default is binary mode).\n\nSee Section 5.2 for more examples like this, including reading bzip2 compressed files.\n\nOne useful thing is to be able to turn information contained in a string into a handle. The following example shows how to do this using from the Python standard library:"
    },
    {
        "link": "https://labxchange.org/library/items/lb:LabXchange:d64401b3:html:1",
        "document": ""
    },
    {
        "link": "http://biopython.org/DIST/docs/tutorial/Tutorial-1.81.pdf",
        "document": ""
    },
    {
        "link": "https://labxchange.org/library/items/lb:LabXchange:d64401b3:html:1",
        "document": ""
    },
    {
        "link": "https://biostars.org/p/9507777",
        "document": "The scaling problem is not that of parsing a FASTA file but counting the occurrence of the substring.\n\nThe parsing of the FASTA file in BioPython simply loads it into a single massive string object and that is plenty fast - it would be hard to improve on that in Python, as the code behind the scenes is quite simple, and is very likely IO bound already.\n\nWhen you consider counting substrings, it depends on whether you are counting exact matches or not, and whether you need to find potentially overlapping matches or not.\n\nso counting all one million in a 4 million long sequence made out of will take about 4ms, this may be quick or slow depending on your needs"
    },
    {
        "link": "https://stackoverflow.com/questions/53583647/read-user-inputted-fasta-file-and-parse-using-biopython",
        "document": "I am trying to create a python script where the user can type in their FASTA file and that file will then be parsed using Biopython. I am struggling to get this to work. The script I have thus far is this:\n\nI would like the user to be prompted to type in their file and its extension and that file should be used to parse with Biopython such that that output is printed. I also want to be about to send the print output to a log file. Any help would be appreciate.\n\nThe purpose of the script is to take a fasta file, parse and trim primers. I know there is an easy method to do this using Biopython entirely but as per instruction Biopython can only be used to parse not trim. Any insight into this would be appreciated as well."
    },
    {
        "link": "https://biopython.org/docs/latest/Tutorial/chapter_quick_start.html",
        "document": "Quick Start – What can you do with Biopython?\n\nThis section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of Python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your Python, the main Python web site provides quite a bit of free documentation to get started with (https://docs.python.org/3/).\n\nSince much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run.\n\nNow that that is all out of the way, let’s get into what we can do with Biopython.\n\nAs mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with “things” of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in Python, of course!) or at least an interest in learning to program. Biopython’s job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn’t exist and contributing it to Biopython, please go ahead!). So Biopython’s job is to make you happy! One thing to note about Biopython is that it often provides multiple ways of “doing the same thing.” Things have improved in recent releases, but this can still be frustrating as in Python there should ideally be one right way to do something. However, this can also be a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look in the Cookbook (Chapter Cookbook – Cool things to do with it, this has some cools tricks and tips), and built-in “docstrings” (via the Python help command or and ), or ultimately the code itself.\n\nDisputably (of course!), the central object in bioinformatics is the sequence. Thus, we’ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the object, which we’ll discuss in more detail in Chapter Sequence objects. Most of the time when we think about sequences we have in my mind a string of letters like . You can create such object with this sequence as follows - the represents the Python prompt followed by what you would type in: The object differs from the Python string in the methods it supports. You can’t do this with a plain string: The next most important class is the or Sequence Record. This holds a sequence (as a object) with additional annotation including an identifier, name and description. The module for reading and writing sequence file formats works with objects, which will be introduced below and covered in more detail by Chapter Sequence Input/Output. This covers the basic features and uses of the Biopython sequence class. Now that you’ve got some idea of what it is like to interact with the Biopython libraries, it’s time to delve into the fun, fun world of dealing with biological file formats!\n\nBefore we jump right into parsers and everything else to do with Biopython, let’s set up an example to motivate everything we do and make life more interesting. After all, if there wasn’t any biology in this tutorial, why would you want you read it? Since I love plants, I think we’re just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we’ve suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some Lady Slipper Orchids photos on Flickr, or try a Google Image Search). Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So let’s suppose we’re thinking about writing a funding proposal to do a molecular study of Lady Slipper evolution, and would like to see what kind of research has already been done and how we can add to that. After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: Cypripedium, Paphiopedilum, Phragmipedium, Selenipedium and Mexipedium. That gives us enough to get started delving for more information. So, let’s look at how the Biopython tools can help us. We’ll start with sequence parsing in Section Parsing sequence file formats, but the orchids will be back later on as well - for example we’ll search PubMed for papers about orchids and extract sequence data from GenBank in Chapter Accessing NCBI’s Entrez databases, extract data from Swiss-Prot from certain orchid proteins in Chapter Swiss-Prot and ExPASy, and work with ClustalW multiple sequence alignments of orchid proteins in Section ClustalW.\n\nA large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers. We are now going to briefly introduce the module – you can find out more in Chapter Sequence Input/Output. We’ll start with an online search for our friends, the lady slipper orchids. To keep this introduction simple, we’re just using the NCBI website by hand. Let’s just take a look through the nucleotide databases at NCBI, using an Entrez online search (https://www.ncbi.nlm.nih.gov/nuccore/?term=Cypripedioideae) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). When this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file and as a GenBank formatted text file (files ls_orchid.fasta and ls_orchid.gbk, also included with the Biopython source code under ). If you run the search today, you’ll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from in the Biopython source code. In Section Connecting with biological databases we will look at how to do a search like this from within Python. If you open the lady slipper orchids FASTA file ls_orchid.fasta in your favorite text editor, you’ll see that the file starts like this: It contains 94 records, each has a line starting with (greater-than symbol) followed by the sequence on one or more lines. Now try this in Python: You should get something like this on your screen: Now let’s load the GenBank file ls_orchid.gbk instead - notice that the code to do this is almost identical to the snippet used above for the FASTA file - the only difference is we change the filename and the format string: You’ll notice that a shorter string has been used as the in this case. Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. Chapter Sequence Input/Output covers in more detail, while Chapter Sequence alignments introduces for sequence alignments. While the most popular file formats have parsers integrated into and/or , for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet. Please also check the wiki pages http://biopython.org/wiki/SeqIO and http://biopython.org/wiki/AlignIO for the latest information, or ask on the mailing list. The wiki pages should include an up to date list of supported file types, and some additional examples. The next place to look for information about specific parsers and how to do cool things with them is in the Cookbook (Chapter Cookbook – Cool things to do with it of this Tutorial). If you don’t find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)\n\nOne of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from Python scripts. Currently, Biopython has code to extract information from the following databases:\n• None Entrez (and PubMed) from the NCBI – See Chapter Accessing NCBI’s Entrez databases. The code in these modules basically makes it easy to write Python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information."
    },
    {
        "link": "https://stackoverflow.com/questions/62534586/trouble-parsing-fasta-files-in-python",
        "document": "Background for those who arn't familiar with FASTA files. This format contains one or multiple DNA, RNA, or protein sequences with a one-line descriptive tag of the sequence that starts with a \">\" and then the sequence in the following lines(Ex. For DNA it would be a lot of repeating of A, T, G, and C). It also comes with many unnecessary line breaks. So far this code works when I only have one sequence per file but it seems to ignore the if condition if there are multiple. For example it should add each new tag: sequence pair into the dictionary everytime it notices a \">\" but instead it only runs once and puts the first description as the key in the dictionary and joins the rest of the file regardless of \">\" characters and uses that as the value. How can I get this loop to notice a new \">\" after the first occurrence?\n\nI am purposefully steering away from the biopython module."
    }
]