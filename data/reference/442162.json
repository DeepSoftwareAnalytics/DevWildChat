[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html",
        "document": "Cancels this timer task. If the task has been scheduled for one-time execution and has not yet run, or has not yet been scheduled, it will never run. If the task has been scheduled for repeated execution, it will never run again. (If the task is running when this call occurs, the task will run to completion, but will never run again.)\n\nNote that calling this method from within the method of a repeating timer task absolutely guarantees that the timer task will not run again.\n\nThis method may be called repeatedly; the second and subsequent calls have no effect."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html",
        "document": "A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.\n\nCorresponding to each object is a single background thread that is used to execute all of the timer's tasks, sequentially. Timer tasks should complete quickly. If a timer task takes excessive time to complete, it \"hogs\" the timer's task execution thread. This can, in turn, delay the execution of subsequent tasks, which may \"bunch up\" and execute in rapid succession when (and if) the offending task finally completes.\n\nAfter the last live reference to a object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's method.\n\nIf the timer's task execution thread terminates unexpectedly, for example, because its method is invoked, any further attempt to schedule a task on the timer will result in an , as if the timer's method had been invoked.\n\nThis class is thread-safe: multiple threads can share a single object without the need for external synchronization.\n\nThis class does not offer real-time guarantees: it schedules tasks using the method.\n\nJava 5.0 introduced the package and one of the concurrency utilities therein is the which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the / combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing (just implement ). Configuring with one thread makes it equivalent to .\n\nImplementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks."
    },
    {
        "link": "https://download.java.net/java/early_access/jdk25/docs/api/java.base/java/util/TimerTask.html",
        "document": "Cancels this timer task. If the task has been scheduled for one-time execution and has not yet run, or has not yet been scheduled, it will never run. If the task has been scheduled for repeated execution, it will never run again. (If the task is running when this call occurs, the task will run to completion, but will never run again.)\n\nNote that calling this method from within the method of a repeating timer task absolutely guarantees that the timer task will not run again.\n\nThis method may be called repeatedly; the second and subsequent calls have no effect."
    },
    {
        "link": "https://baeldung.com/java-timer-and-timertask",
        "document": "Timer and TimerTask are java util classes that we use to schedule tasks in a background thread. Basically, TimerTask is the task to perform, and Timer is the scheduler.\n\nLet’s start by simply running a single task with the help of a Timer:\n\nThis performs the task after a certain delay, which we gave as the second parameter of the schedule() method. In the next section, we’ll see how to schedule a task at a given date and time.\n\nNote that if we’re running this as a JUnit test, we should add a Thread.sleep(delay * 2) call to allow the Timer’s thread to run the task before the Junit test stops executing.\n\nNow let’s look at the Timer#schedule(TimerTask, Date) method, which takes a Date instead of a long as its second parameter. This allows us to schedule the task at a certain instant rather than after a delay.\n\nThis time, let’s imagine we have an old legacy database and want to migrate its data into a new database with a better schema.\n\nWe can create a DatabaseMigrationTask class that will handle this migration:\n\nFor simplicity, we represent the two databases by a List of Strings. Simply put, our migration consists of putting the data from the first list into the second.\n\nTo perform this migration at the desired instant, we’ll have to use the overloaded version of the schedule() method:\n\nAs we can see, we give the migration task and the date of execution to the schedule() method.\n\nThen the migration is executed at the time indicated by twoSecondsLater:\n\nBefore that moment, the migration doesn’t occur.\n\nNow that we’ve covered how to schedule the single execution of a task let’s see how to deal with repeatable tasks.\n\nOnce again, the Timer class offers multiple possibilities. We can set up the repetition to observe either a fixed delay or a fixed rate.\n\nA fixed delay means that the execution will start after a period of time after the moment the last execution started, even if it was delayed (therefore being itself delayed).\n\nLet’s say we want to schedule a task every two seconds, with the first execution taking one second and the second one taking two but being delayed by one second. Then the third execution starts at the fifth second:\n\nOn the other hand, a fixed rate means that each execution will respect the initial schedule, no matter if a previous execution has been delayed.\n\nLet’s reuse our previous example. With a fixed rate, the second task will start after three seconds (because of the delay), but the third one will start after four seconds (respecting the initial schedule of one execution every two seconds):\n\nNow that we’ve covered these two principles let’s see how we can use them.\n\nTo use fixed-delay scheduling, there are two more overloads of the schedule() method, each taking an extra parameter stating the periodicity in milliseconds.\n\nWhy two overloads? Because there’s still the possibility of starting the task at a certain moment or after a certain delay.\n\nAs for the fixed-rate scheduling, we have the two scheduleAtFixedRate() methods, which also take the periodicity in milliseconds. Again, we have one method to start the task at a given date and time and another to start it after a given delay.\n\nIt’s also worth mentioning that, if a task takes more time than the period to execute, it delays the whole chain of executions, whether we’re using fixed-delay or fixed-rate.\n\nNow let’s imagine we want to implement a newsletter system, sending an email to our followers every week. In this case, a repetitive task seems ideal.\n\nSo let’s schedule the newsletter every second, which is basically spamming, but we’re good to go as the sending is fake.\n\nEach time it executes, the task will print its scheduled time, which we gather using the TimerTask#scheduledExecutionTime() method.\n\nSo what if we want to schedule this task every second in fixed-delay mode? We’ll have to use the overloaded version of the schedule() that we mentioned earlier:\n\nOf course, we only carry the tests for a few occurrences:\n\nAs we can see, there is at least one second between each execution, but they’re sometimes delayed by a millisecond. This phenomenon is due to our decision to use fixed-delay repetition.\n\nNow, what if we were to use a fixed-rate repetition? Then we would have to use the scheduledAtFixedRate() method:\n\nThis time, executions aren’t delayed by the previous ones:\n\nThe execution of a task can be cancelled in a few ways.\n\nThe first option is to call the TimerTask.cancel() method inside the run() method’s implementation of the TimerTask itself:\n\nAnother option is to call the Timer.cancel() method on a Timer object:\n\n4.3. Stop the Thread of the TimerTask Inside Run\n\nWe can also stop the thread inside the run method of the task, thus cancelling the entire task:\n\nNotice the TODO instruction in the run implementation; in order to run this simple example, we’ll need to actually stop the thread.\n\nIn a real-world custom thread implementation, stopping the thread should be supported, but in this case, we can ignore the deprecation and use the simple stop API on the Thread class itself.\n\nWe can also make good use of an ExecutorService to schedule timer tasks, instead of using the timer.\n\nHere’s a quick example of how to run a repeated task at a specified interval:\n\nSo what are the main differences between the Timer and the ExecutorService solution:\n• Timer can be sensitive to changes in the system clock; ScheduledThreadPoolExecutor isn’t.\n• Timer has only one execution thread; ScheduledThreadPoolExecutor can be configured with any number of threads.\n• Runtime Exceptions thrown inside the TimerTask kill the thread, so the following scheduled tasks won’t run further; with ScheduledThreadExecutor, the current task will be cancelled, but the rest will continue to run.\n\nIn this article, we illustrated the many ways we can use the simple, yet flexible Timer and TimerTask infrastructure built into Java for quickly scheduling tasks. There are, of course, much more complex and complete solutions in the Java world if we need them, such as the Quartz library, but this is a very good place to start."
    },
    {
        "link": "https://stackoverflow.com/questions/6666517/java-timer-scheduled-tasks",
        "document": "They doesn't go away. Each object is associated with a background process. Even when you remove all references to your in your program, the background process will still continue to run (it holds it's own reference to the object). Because of this, the object will not be subject to garbage collection.\n\nSee the official documentation for details.\n\nCorresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially ... After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). However, this can take arbitrarily long to occur."
    },
    {
        "link": "https://stackoverflow.com/questions/4544197/how-do-i-schedule-a-task-to-run-at-periodic-intervals",
        "document": "I wish to offer you an alternative to using - ScheduledThreadPoolExecutor, an implementation of the ScheduledExecutorService interface. It has some advantages over the Timer class, according to \"Java in Concurrency\":\n\nA creates only a single thread for executing timer tasks. If a timer task takes too long to run, the timing accuracy of other can suffer. If a recurring is scheduled to run every 10 ms and another Timer-Task takes 40 ms to run, the recurring task either (depending on whether it was scheduled at fixed rate or fixed delay) gets called four times in rapid succession after the long-running task completes, or \"misses\" four invocations completely. Scheduled thread pools address this limitation by letting you provide multiple threads for executing deferred and periodic tasks.\n\nAnother problem with Timer is that it behaves poorly if a throws an unchecked exception. Also, called \"thread leakage\"\n\nThe Timer thread doesn't catch the exception, so an unchecked exception thrown from a terminates the timer thread. Timer also doesn't resurrect the thread in this situation; instead, it erroneously assumes the entire Timer was cancelled. In this case, TimerTasks that are already scheduled but not yet executed are never run, and new tasks cannot be scheduled.\n\nAnd another recommendation if you need to build your own scheduling service, you may still be able to take advantage of the library by using a , a implementation that provides the scheduling functionality of . A manages a collection of Delayed objects. A Delayed has a delay time associated with it: lets you take an element only if its delay has expired. Objects are returned from a ordered by the time associated with their delay."
    },
    {
        "link": "https://stackoverflow.com/questions/47763088/how-do-i-put-a-limit-on-timertask-rather-than-having-it-run-forever",
        "document": "I'm using the timer utility to repeatedly post output of a code. Right now I have it set to repeat nonstop on a 1 second interval. How could I change this to instead repeat until a time limit set by the user is reached?"
    },
    {
        "link": "https://javanexus.com/blog/scheduling-recurring-tasks-java",
        "document": "Scheduling recurring tasks is a fundamental requirement in many software applications. In Java, there are several ways to achieve this, each with its own strengths and use cases. In this post, we will explore some effective methods for scheduling recurring tasks in Java, including built-in APIs and third-party libraries.\n\nThe and classes provide a simple way to schedule recurring tasks. You can create a and schedule a to be executed at fixed intervals. Here's an example:\n\nOne advantage of using and is their simplicity. However, they have limitations, such as not being suitable for long-running tasks and not handling exceptions gracefully.\n\nThe interface in the package provides a more flexible and robust way to schedule recurring tasks. It allows you to schedule tasks to execute after a certain delay or at fixed intervals. Here's an example:\n\nThe offers better control over the scheduling of tasks, exception handling, and support for long-running tasks. It is the recommended approach for scheduling tasks in modern Java applications.\n\nQuartz is a popular third-party library for scheduling recurring tasks in Java. It provides a rich set of features for job scheduling, including cron-like expressions for more complex scheduling requirements. Here's an example of scheduling a job with Quartz:\n\nQuartz is suitable for enterprise-level applications with complex scheduling requirements. It provides features such as job persistence, clustering, and job chaining.\n\nIn Java, there are multiple ways to schedule recurring tasks, each with its own strengths and use cases. For simple tasks, and can be used, but for more robust and flexible task scheduling, is the recommended approach. Additionally, for enterprise-level applications with complex scheduling requirements, Quartz Scheduler is a powerful choice.\n\nChoosing the right method for scheduling recurring tasks depends on the specific requirements of your application. Consider factors such as simplicity, flexibility, and scalability when making your decision.\n\nBy understanding and leveraging these scheduling techniques, you can effectively manage recurring tasks in your Java applications, ensuring that they run reliably and efficiently over time.\n\nRemember to select the most suitable approach for your specific use case and always consider the trade-offs between simplicity and complexity to maintain an effective and manageable codebase."
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-implement-java-timer-tasks-419624",
        "document": "In Java, the Timer class provides a simple mechanism for scheduling tasks to run at a specified time or periodically. It's part of the package and offers a convenient way to execute background tasks with precise timing control.\n\nA Timer is a utility class that allows you to schedule tasks for future execution in a background thread. It provides two primary scheduling methods:\n\ngraph TD A[Timer] --> B[TimerTask] A --> C[Scheduling Methods] C --> D[schedule()] C --> E[scheduleAtFixedRate()] C --> F[scheduleAtFixedDelay()]\n• Timers are not guaranteed to be precisely accurate\n• For more complex scheduling, consider using\n\nWhen to Use Timer\n\nWhile useful, Java Timer has some constraints:\n\nAt LabEx, we recommend understanding these basics before implementing complex timer-based applications."
    },
    {
        "link": "https://developer.ibm.com/articles/j-schedule",
        "document": ""
    }
]