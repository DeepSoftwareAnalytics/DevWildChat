[
    {
        "link": "https://stackoverflow.com/questions/42497507/javafx-fxml-controller-event-handler-and-initialization-best-practice",
        "document": "I ran into a design problem which has to do with the order of event handling and initialization of JavaFX controllers.\n\nI want to update a TabPane, whenever the corresponding tab is selected. To achieve this, I use FXML to register the event handler as follows:\n\nIn the event handling code, I got something like\n\nupdateImageView in turn loads images using a data source passed to the controller using Dependency Injection.\n\nOption 1: This dependency injection is currently implemented as follows:\n\nOption 2 I could use the initialize() method of the controller to initialize it using singletons. This does break the dependency injection and is not my preferred solution.\n\nOption 3 I could refrain from using FXML and instantiate everything manually. This allows me to instantiate the controller and perform dependency injection before even invoking JavaFX/FXML. There are numerous examples online, which all end up in a mess for complex GUIs. I would like to stick to FXMLLoader because this seems like a neat and comfortable way. Please point it out if this is actually not the best practice.\n\nOption 4 I could register the event handlers manually in the initialize() method of the controller (or for that matter, after performing the dependency injection/setting up the controller from somehwere else). This defies the point of defining event handlers in FXML in the first place.\n\nSo, what is wrong with Option 1 and 2? tabChanged is actually called before any initialization is performed on the controller, resulting in null pointer exceptions. Now, I could go about ignoring all events until the controller is initialized - this is probably a bad idea because events which come up just once will be missed. Another option is to enforce initialization in (probably) many event handlers. This does not seem like a viable option either.\n\nI must be missing something obvious. I am aware that this pertains to common design choices/best practices; however, I was unable to feed the right keywords to Google.\n\nI am looking forward to your help/suggestions - thank you!"
    },
    {
        "link": "https://openjfx.io/javadoc/21/javafx.fxml/javafx/fxml/doc-files/introduction_to_fxml.html",
        "document": "FXML is a scriptable, XML-based markup language for constructing Java object graphs. It provides a convenient alternative to constructing such graphs in procedural code, and is ideally suited to defining the user interface of a JavaFX application, since the hierarchical structure of an XML document closely parallels the structure of the JavaFX scene graph.\n\nThis document introduces the FXML markup language and explains how it can be used to simplify development of JavaFX applications.\n\nIn FXML, an XML element represents one of the following:\n\nClass instances, instance properties, static properties, and define blocks are discussed in this section below. Scripting is discussed in a later section.\n\nClass instances can be constructed in FXML in several ways. The most common is via instance declaration elements, which simply create a new instance of a class by name. Other ways of creating class instances include referencing existing values, copying existing values, and including external FXML files. Each is discussed in more detail below.\n\nIf an element's tag is considered an instance declaration if the tag begins with uppercase letter (and the class is imported) or, as in Java, it denotes a fully-qualified (including the package name) name of a class. When the FXML loader (also introduced later) encounters such an element, it creates an instance of that class.\n\nImporting a class is done using the \"import\" processing instruction (PI). For example, the following PI imports the javafx.scene.control.Label class into the current FXML document’s namespace:\n\nThis PI imports all classes from the javafx.scene.control package into the current namespace:\n\nAny class that adheres to JavaBean constructor and property naming conventions can be readily instantiated and configured using FXML. The following is a simple but complete example that creates an instance of javafx.scene.control.Label and sets its \"text\" property to \"Hello, World!\":\n\nNote that the Label’s \"text\" property in this example is set using an XML attribute. Properties can also be set using nested property elements. Property elements are discussed in more detail later in this section. Property attributes are discussed in a later section.\n\nClasses that don't conform to Bean conventions can also be constructed in FXML, using an object called a \"builder\". Builders are discussed in more detail later.\n\nInternally, the FXML loader uses an instance of com.sun.javafx.fxml.BeanAdapter to wrap an instantiated object and invoke its setter methods. This (currently) private class implements the java.util.Map interface and allows a caller to get and set Bean property values as key/value pairs.\n\nIf an element represents a type that already implements Map (such as java.util.HashMap), it is not wrapped and its get() and put() methods are invoked directly. For example, the following FXML creates an instance of HashMap and sets its \"foo\" and \"bar\" values to \"123\" and \"456\", respectively:\n\nThe fx:value attribute can be used to initialize an instance of a type that does not have a default constructor but provides a static valueOf(String) method. For example, java.lang.String as well as each of the primitive wrapper types define a valueOf() method and can be constructed in FXML as follows:\n\nCustom classes that define a static valueOf(String) method can also be constructed this way.\n\nThe fx:factory attribute is another means of creating objects whose classes do not have a default constructor. The value of the attribute is the name of a static, no-arg factory method for producing class instances. For example, the following markup creates an instance of an observable array list, populated with three string values:\n\nA third means of creating instances of classes that do not conform to Bean conventions (such as those representing immutable values) is a \"builder\". The builder design pattern delegates object construction to a mutable helper class (called a \"builder\") that is responsible for manufacturing instances of the immutable type.\n\nBuilder support in FXML is provided by two interfaces. The javafx.util.Builder interface defines a single method named build() which is responsible for constructing the actual object:\n\nA javafx.util.BuilderFactory is responsible for producing builders that are capable of instantiating a given type:\n\nA default builder factory, JavaFXBuilderFactory, is provided in the javafx.fxml package. This factory is capable of creating and configuring most immutable JavaFX types. For example, the following markup uses the default builder to create an instance of the immutable javafx.scene.paint.Color class:\n\nNote that, unlike Bean types, which are constructed when the element's start tag is processed, objects constructed by a builder are not instantiated until the element's closing tag is reached. This is because all of the required arguments may not be available until the element has been fully processed. For example, the Color object in the preceding example could also be written as:\n\nThe Color instance cannot be fully constructed until all three of the color components are known.\n\nWhen processing markup for an object that will be constructed by a builder, the Builder instances are treated like value objects - if a Builder implements the Map interface, the put() method is used to set the builder's attribute values. Otherwise, the builder is wrapped in a BeanAdapter and its properties are assumed to be exposed via standard Bean setters.\n\nThe <fx:include> tag creates an object from FXML markup defined in another file. It is used as follows:\n\nwhere filename is the name of the FXML file to include. Values that begin with a leading slash character are treated as relative to the classpath. Values with no leading slash are considered relative to the path of the current document.\n\nFor example, given the following markup:\n\nIf my_button.fxml contains the following:\n\nthe resulting scene graph would contain a VBox as a root object with a single Button as a child node.\n\nNote the use of the \"fx\" namespace prefix. This is a reserved prefix that defines a number of elements and attributes that are used for internal processing of an FXML source file. It is generally declared on the root element of a FXML document. Other features provided by the \"fx\" namespace are described in the following sections.\n\n<fx:include> also supports attributes for specifying the name of the resource bundle that should be used to localize the included content, as well as the character set used to encode the source file. Resource resolution is discussed in a later section.\n\nThe <fx:constant> element creates a reference to a class constant. For example, the following markup sets the value of the \"minWidth\" property of aButton instance to the value of the NEGATIVE_INFINITY constant defined by the java.lang.Double class:\n\nThe <fx:reference> element creates a new reference to an existing element. Wherever this tag appears, it will effectively be replaced by the value of the named element. It is used in conjunction with either the fx:id attribute or with a script variables, both of which are discussed in more detail in later sections. The \"source\" attribute of the <fx:reference> element specifies the name of the object to which the new element will refer.\n\nFor example, the following markup assigns a previously-defined Image instance named \"myImage\" to the \"image\" property of an ImageView control:\n\nNote that, since it is also possible to dereference a variable using the attribute variable resolution operator (discussed later in the Attributes section), fx:reference is generally only used when a reference value must be specified as an element, such as when adding the reference to a collection:\n\nFor most other cases, using an attribute is simpler and more concise.\n\nThe <fx:copy> element creates a copy of an existing element. Like <fx:reference>, it is used with the fx:id attribute or a script variable. The element's \"source\" attribute specifies the name of the object that will be copied. The source type must define a copy constructor that will be used to construct the copy from the source value.\n\nAt the moment, no JavaFX platform classes provide such a copy constructor, so this element is provided primarily for use by application developers. This may change in a future release.\n\nThe <fx:root> element creates a reference to a previously defined root element. It is only valid as the root node of an FXML document. <fx:root> is used primarily when creating custom controls that are backed by FXML markup. This is discussed in more detail in the FXMLLoader section.\n\nElements whose tag names begin with a lowercase letter represent object properties. A property element may represent one of the following:\n\nIf an element represents a property setter, the contents of the element (which must be either a text node or a nested class instance element) are passed as the value to the setter for the property.\n\nFor example, the following FXML creates an instance of the Label class and sets the value of the label's \"text\" property to \"Hello, World!\":\n\nThis produces the same result as the earlier example which used an attribute to set the \"text\" property:\n\nProperty elements are generally used when the property value is a complex type that can't be represented using a simple string-based attribute value, or when the character length of the value is so long that specifying it as an attribute would have a negative impact on readability.\n\nFXML uses \"type coercion\" to convert property values to the appropriate type as needed. Type coercion is required because the only data types supported by XML are elements, text, and attributes (whose values are also text). However, Java supports a number of different data types including built-in primitive value types as well as extensible reference types.\n\nThe FXML loader uses the coerce() method of BeanAdapter to perform any required type conversions. This method is capable of performing basic primitive type conversions such as String to boolean or int to double, and will also convert String to Class or String to Enum. Additional conversions can be implemented by defining a static valueOf() method on the target type.\n\nA read-only list property is a Bean property whose getter returns an instance of java.util.List and has no corresponding setter method. The contents of a read-only list element are automatically added to the list as they are processed.\n\nFor example, the \"children\" property of javafx.scene.Group is a read-only list property representing the group's child nodes:\n\nAs each sub-element of the <children> element is read, it is added to the list returned by Group#getChildren().\n\nA read-only map property is a bean property whose getter returns an instance of java.util.Map and has no corresponding setter method. The attributes of a read-only map element are applied to the map when the closing tag is processed.\n\nThe \"properties\" property of javafx.scene.Node is an example of a read-only map property. The following markup sets the \"foo\" and \"bar\" properties of a Label instance to \"123\" and \"456\", respectively:\n\nNote that a read-only property whose type is neither a List nor a Map will be treated as if it were a read-only map. The return value of the getter method will be wrapped in a BeanAdapter and can be used in the same way as any other read-only map.\n\nA class may define a \"default property\" using the @DefaultProperty annotation defined in the javafx.beans package. If present, the sub-element representing the default property can be omitted from the markup.\n\nFor example, since javafx.scene.layout.Pane (the superclass of javafx.scene.layout.VBox) defines a default property of \"children\", a <children> element is not required; the loader will automatically add the sub-elements of the VBox to the container's \"children\" collection:\n\nNote that default properties are not limited to collections. If an element's default property refers to a scalar value, any sub-element of that element will be set as the value of the property.\n\nFor example, since javafx.scene.control.ScrollPane defines a default property of \"content\", a scroll pane containing a TextArea as its content can be specified as follows:\n\nTaking advantage of default properties can significantly reduce the verbosity of FXML markup.\n\nAn element may also represent a \"static\" property (sometimes called an \"attached property\"). Static properties are properties that only make sense in a particular context. They are not intrinsic to the class to which they are applied, but are defined by another class (often, the parent container of a control).\n\nStatic properties are prefixed with the name of class that defines them. For example, The following FXML invokes the static setter for GridPane's \"rowIndex\" and \"columnIndex\" properties:\n\nThis translates roughly to the following in Java:\n\nThe calls to GridPane#setRowIndex() and GridPane#setColumnIndex() \"attach\" the index data to the Label instance. GridPane then uses these during layout to arrange its children appropriately. Other containers, including AnchorPane, BorderPane, and StackPane, define similar properties.\n\nAs with instance properties, static property elements are generally used when the property value cannot be efficiently represented by an attribute value. Otherwise, static property attributes (discussed in a later section) will generally produce more concise and readable markup.\n\nThe <fx:define> element is used to create objects that exist outside of the object hierarchy but may need to be referred to elsewhere.\n\nFor example, when working with radio buttons, it is common to define a ToggleGroup that will manage the buttons' selection state. This group is not part of the scene graph itself, so should not be added to the buttons' parent. A define block can be used to create the button group without interfering with the overall structure of the document:\n\nElements in define blocks are usually assigned an ID that can be used to refer to the element's value later. IDs are discussed in more detail in later sections.\n\nAn attribute in FXML may represent one of the following:\n\nEach are discussed in more detail in the following sections.\n\nLike property elements, attributes can also be used to configure the properties of a class instance. For example, the following markup creates a Button whose text reads \"Click Me!\":\n\nAs with property elements, property attributes support type coercion. When the following markup is processed, the \"x\", \"y\", \"width\", and \"height\" values will be converted to doubles, and the \"fill\" value will be converted to a Color:\n\nUnlike property elements, which are applied as they are processed, property attributes are not applied until the closing tag of their respective element is reached. This is done primarily to facilitate the case where an attribute value depends on some information that won't be available until after the element's content has been completely processed (for example, the selected index of a TabPane control, which can't be set until all of the tabs have been added).\n\nAnother key difference between property attributes and property elements in FXML is that attributes support a number of \"resolution operators\" that extend their functionality. The following operators are supported and are discussed in more detail below:\n\nAs strings, XML attributes cannot natively represent typed location information such as a URL. However, it is often necessary to specify such locations in markup; for example, the source of an image resource. The location resolution operator (represented by an \"@\" prefix to the attribute value) is used to specify that an attribute value should be treated as a location relative to the current file rather than a simple string.\n\nFor example, the following markup creates an ImageView and populates it with image data from my_image.png, which is assumed to be located at a path relative to the current FXML file:\n\nSince Image is an immutable object, a builder is required to construct it. Alternatively, if Image were to define a valueOf(URL) factory method, the image view could be populated as follows:\n\nThe value of the \"image\" attribute would be converted to a URL by the FXML loader, then coerced to an Image using the valueOf() method.\n\nNote that whitespace values in the URL must be encoded; for example, to refer to a file named \"My Image.png\", the FXML document should contain the following:\n\nIn FXML, resource substitution can be performed at load time for localization purposes. When provided with an instance of java.util.ResourceBundle, the FXML loader will replace instances of resource names with their locale-specific values. Resource names are identified by a \"%\" prefix, as shown below:\n\nIf the loader is given a resource bundle defined as follows:\n\nthe output of the FXML loader would be a Label instance containing the text \"This is the text!\".\n\nAn FXML document defines a variable namespace in which named elements and script variables may be uniquely identified. The variable resolution operator allows a caller to replace an attribute value with an instance of a named object before the corresponding setter method is invoked. Variable references are identified by a \"$\" prefix, as shown below:\n\nAssigning an fx:id value to an element creates a variable in the document's namespace that can later be referred to by variable dereference attributes, such as the \"toggleGroup\" attribute shown above, or in script code, discussed in a later section. Additionally, if the object's type defines an \"id\" property, this value will also be passed to the objects setId() method.\n\nIf the value of an attribute begins with one of the resource resolution prefixes, the character can be escaped by prepending it with a leading backslash (\"\\\") character. For example, the following markup creates a Label instance whose text reads \"$10.00\":\n\nAttribute variables as shown above are resolved once at load time. Later updates to the variables value are not automatically reflected in any properties to which the value was assigned. In many cases, this is sufficient; however, it is often convenient to \"bind\" a property value to a variable or expression such that changes to the variable are automatically propagated to the target property. Expression bindings can be used for this purpose.\n\nAn expression binding also begins with the variable resolution operator, but is followed by a set of curly braces which wrap the expression value. For example, the following markup binds the value of a text input's \"text\" property to the \"text\" property of a Label instance:\n\nAs the user types in the text input, the label's text content will be automatically updated.\n\nMore complex expression are also supported. A list of supported constants and operators follows:\n\nAttributes representing static properties are handled similarly to static property elements and use a similar syntax. For example, the earlier GridPane markup shown earlier to demonstrate static property elements could be rewritten as follows:\n\nIn addition to being more concise, static property attributes, like instance property attributes, support location, resource, and variable resolution operators, the only limitation being that it is not possible to create an expression binding to a static property.\n\nEvent handler attributes are a convenient means of attaching behaviors to document elements. Any class that defines a setOnEvent() method can be assigned an event handler in markup.\n\nFXML supports three types of event handler attributes: script event handlers, controller method event handlers and expressions. Each are discussed below.\n\nA script event handler is an event handler that executes script code when the event is fired, similar to event handlers in HTML. For example, the following script-based handler for the button's \"onAction\" event uses JavaScript to write the text \"You clicked me!\" to the console when the user presses the button:\n\nNote the use of the language processing instruction at the beginning of the code snippet. This PI tells the FXML loader which scripting language should be used to execute the event handler. A page language must be specified whenever inline script is used in an FXML document, and can only be specified once per document. However, this does not apply to external scripts, which may be implemented using any number of supported scripting languages. Scripting is discussed in more detail in the next section.\n\nNote: to turn off automatic compilation of script code place the processing instruction <?compile false?> before the element that contains the script. To turn on compilation of script code again use the processing instruction <?compile true?> (or short: <?compile?>). The compile processing instruction can be used repeatedly to turn compilation of script code off and on.\n\nNote: The JavaScript script engine is disabled by default. If the JDK has a JavaScript script engine, it can be enabled using a system property javafx.allowjs=true.\n\nA controller method event handler is a method defined by a document's \"controller\". A controller is an object that is associated with the deserialized contents of an FXML document and is responsible for coordinating the behaviors of the objects (often user interface elements) defined by the document.\n\nA controller method event handler is specified by a leading hash symbol followed by the name of the handler method. For example:\n\nNote the use of the fx:controller attribute on the root element. This attribute is used to associate a controller class with the document. If MyController is defined as follows:\n\nthe handleButtonAction() will be called when the user presses the button, and the text \"You clicked me!\" will be written to the console.\n\nIn general, a handler method should conform to the signature of a standard event handler; that is, it should take a single argument of a type that extends javafx.event.Event and should return void (similar to an event delegate in C#). The event argument often carries important and useful information about the nature of the event; however, it is optional and may be omitted if desired. So this is also a valid handler:\n\nControllers are discussed in more detail in a later section.\n\nAny expression that point to a variable of javafx.event.EventHandler type can be used as an expression handler.\n\nPrevious example using an expression handler:\n\nWith the controller that contains a field like this\n\nNote that other kinds of expressions, like binding expressions are not supported in this context.\n\nCollections and object properties cannot be listen to using setOnEvent() methods. For these reason, special handler methods need to be used. ObservableList, ObservableMap or ObservableSet uses a special onChange attribute that points to a handler method with a ListChangeListener.Change, MapChangeListener.Change or SetChangeListener.Change parameter, respectively.\n\nSimilarly, the property handlers are methods that have the same parameters as changed method of ChangeListener :\n\nA handler for parent property would look like this\n\nFor convenience, the first parameter can be a subclass of ObservableValue, e.g. Property\n\nFor registering to a property, a special on<propertyName>Change attribute must be used.\n\nNote that collections and properties do not currently support scripting handlers.\n\nThe <fx:script> tag allows a caller to import scripting code into or embed script within a FXML file. Any JVM scripting language can be used, including JavaScript, Groovy, and Clojure, among others. Script code is often used to define event handlers directly in markup or in an associated source file, since event handlers can often be written more concisely in more loosely-typed scripting languages than they can in a statically-typed language such as Java.\n\nNote: The JavaScript script engine is disabled by default. If the JDK has a JavaScript script engine, it can be enabled using a system property javafx.allowjs=true.\n\nScripts are compiled by default, when they are first loaded, if the ScriptEngine implements the javax.script.Compilable interface. If compilation fails, the FXMLLoader will fall back to interpreted mode.\n\nNote: to turn off automatic compilation of script code place the processing instruction <?compile false?> before the script element. To turn on compilation of script code again use the processing instruction <?compile true?> (or short: <?compile?>). The compile processing instruction can be used repeatedly to turn compilation of script code off and on.\n\nThe following example markup defines a function called handleButtonAction() that is called by the action handler attached to the Button element:\n\nClicking the button triggers the event handler, which invokes the function, producing output identical to the previous examples.\n\nScript code may also be defined in external files. The previous example could be split into an FXML file and a JavaScript source file with no difference in functionality:\n\nIt is often preferable to separate code from markup in this way, since many text editors support syntax highlighting for the various scripting languages supported by the JVM. It can also help improve readability of the source code and markup.\n\nNote that script blocks are not limited to defining event handler functions. Script code is executed as it is processed, so it can also be used to dynamically configure the structure of the resulting output. As a simple example, the following FXML includes a script block that defines a variable named \"labelText\". The value of this variable is used to populate the text property of a Label instance:\n\nWarning: As of JavaFX 8, importClass() javascript function is no longer supported. You have to use fully qualified names as in the example above or load a nashorn compatibility script.\n\nWhile it can be convenient to write simple event handlers in script, either inline or defined in external files, it is often preferable to define more complex application logic in a compiled, strongly-typed language such as Java. As discussed earlier, the fx:controller attribute allows a caller to associate a \"controller\" class with an FXML document. A controller is a compiled class that implements the \"code behind\" the object hierarchy defined by the document.\n\nAs shown earlier, controllers are often used to implement event handlers for user interface elements defined in markup:\n\nIn many cases, it is sufficient to simply declare event handlers in this manner. However, when more control over the behavior of the controller and the elements it manages is required, the controller can define an initialize() method, which will be called once on an implementing controller when the contents of its associated document have been completely loaded:\n\nThis allows the implementing class to perform any necessary post-processing on the content. It also provides the controller with access to the resources that were used to load the document and the location that was used to resolve relative paths within the document (commonly equivalent to the location of the document itself).\n\nFor example, the following code defines an initialize() method that attaches an action handler to a button in code rather than via an event handler attribute, as was done in the previous example. The button instance variable is injected by the loader as the document is read. The resulting application behavior is identical:\n\nNote that, in the previous examples, the controller member fields and event handler methods were declared as public so they can be set or invoked by the loader. In practice, this is not often an issue, since a controller is generally only visible to the FXML loader that creates it. However, for developers who prefer more restricted visibility for controller fields or handler methods, the javafx.fxml.FXML annotation can be used. This annotation marks a protected or private class member as accessible to FXML. If the class being annotated is in a named module, the module containing that class must open the containing package to at least the javafx.fxml module.\n\nFor example, the controllers from the previous examples could be rewritten as follows:\n\nIn the first version, the handleButtonAction() is tagged with @FXML to allow markup defined in the controller's document to invoke it. In the second example, the button field is annotated to allow the loader to set its value. The initialize() method is similarly annotated.\n\nController instances for nested FXML documents loaded via the <fx:include> element are mapped directly to member fields of the including controller. This allows a developer to easily access functionality defined by an include (such as a dialog window presented by an application's main window controller). For example, given the following code:\n\nwhen the controller's initialize() method is called, the dialog field will contain the root element loaded from the \"dialog.fxml\" include, and the dialogController field will contain the include's controller. The main controller can then invoke methods on the included controller, to populate and show the dialog, for example. Note that as the content of the file referenced by fx:include otherwise would become part of the scene graph spanned from main_window_content.fxml, it is necessary to wrap fx:include by fx:define to separate the scene graphs of both windows.\n\nThe FXMLLoader class is responsible for actually loading an FXML source file and returning the resulting object graph. For example, the following code loads an FXML file from a location on the classpath relative to the loading class and localizes it with a resource bundle named \"com.foo.example\". The type of the root element is assumed to be a subclass of javafx.scene.layout.Pane, and the document is assumed to define a controller of type MyController:\n\nNote that the output of an FXMLLoader#load() operation is an instance hierarchy that reflects the actual named classes in the document, not org.w3c.dom nodes representing those classes. Internally, FXMLLoader uses the javax.xml.stream API (also known as the Streaming API for XML, or StAX) to load an FXML document. StAX is an extremely efficient event-based XML parsing API that is conceptually similar to its W3C predecessor, SAX. It allows an FXML document to be processed in a single pass, rather than loaded into an intermediate DOM structure and then post-processed.\n\nThe setRoot() and setController() methods of FXMLLoader allow a caller to inject document root and controller values, respectively, into the document namespace, rather than delegating creation of these values to FXMLLoader itself. This allows a developer to easily create reusable controls that are internally implemented using markup, but (from an API perspective) appear identically to controls implemented programmatically.\n\nFor example, the following markup defines the structure of a simple custom control containing a TextField and a Button instance. The root container is defined as an instance of javafx.scene.layout.VBox:\n\nAs mentioned earlier, the <fx:root> tag creates a reference to a previously defined root element. The value of this element is obtained by calling the getRoot() method of FXMLLoader. Prior to calling load(), the caller must specify this value via a call to setRoot(). The caller may similarly provide a value for the document's controller by calling setController(), which sets the value that will be used as the document's controller when the document is read. These two methods are commonly used together when creating custom FXML-based components.\n\nIn the following example, the CustomControl class extends VBox (the type declared by the <fx:root> element), and sets itself as both the root and controller of the FXML document in its constructor. When the document is loaded, the contents of CustomControl will be populated with the contents of the previous FXML document:\n\nNow, callers can use instances of this control in code or in markup, just like any other control; e.g.:\n\nIf FXMLLoader is used to load types in a named module, the application must ensure that all types that are referenced in the FXML files, including the controller class and any custom Node classes, are reflectively accessible to the javafx.fxml module. A type is reflectively accessible if the module opens the containing package to at least the javafx.fxml module.\n\nFor example, if com.foo.MyController is in the foo.app module, the module-info.java might look like this:\n\nAlternatively, a type is reflectively accessible if the module exports the containing package unconditionally.\n\nReport a bug or suggest an enhancement\n\n Copyright © 2008, 2023, Oracle and/or its affiliates. All rights reserved."
    },
    {
        "link": "https://stackoverflow.com/questions/41308629/handling-events-in-controller-in-javafx-and-mvc-not-fxml",
        "document": "I'm learning JavaFx now and MVC and I'm trying to connect my button to the model through the Controller. I tried many ways to use but it doesn't work outside the view class so what is the proper way to do it?\n\nthis is my View class\n\nand this is my Controller Class\n\nI know that I should connect the button to a method in the model but right now I just want to know how I can make it work.\n\nthis is my main too"
    },
    {
        "link": "https://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html",
        "document": "FXML is a scriptable, XML-based markup language for constructing Java object graphs. It provides a convenient alternative to constructing such graphs in procedural code, and is ideally suited to defining the user interface of a JavaFX application, since the hierarchical structure of an XML document closely parallels the structure of the JavaFX scene graph.\n\nThis document introduces the FXML markup language and explains how it can be used to simplify development of JavaFX applications.\n\nIn FXML, an XML element represents one of the following:\n\nClass instances, instance properties, static properties, and define blocks are discussed in this section below. Scripting is discussed in a later section.\n\nClass instances can be constructed in FXML in several ways. The most common is via instance declaration elements, which simply create a new instance of a class by name. Other ways of creating class instances include referencing existing values, copying existing values, and including external FXML files. Each is discussed in more detail below.\n\nIf an element's tag name begins with an uppercase letter (and it is not a \"static\" property setter, described later), it is considered an instance declaration. When the FXML loader (also introduced later) encounters such an element, it creates an instance of that class.\n\nAs in Java, class names can be fully-qualified (including the package name), or they can be imported using the \"import\" processing instruction (PI). For example, the following PI imports the javafx.scene.control.Label class into the current FXML document’s namespace:\n\nThis PI imports all classes from the javafx.scene.control package into the current namespace:\n\nAny class that adheres to JavaBean constructor and property naming conventions can be readily instantiated and configured using FXML. The following is a simple but complete example that creates an instance of javafx.scene.control.Label and sets its \"text\" property to \"Hello, World!\":\n\nNote that the Label’s \"text\" property in this example is set using an XML attribute. Properties can also be set using nested property elements. Property elements are discussed in more detail later in this section. Property attributes are discussed in a later section.\n\nClasses that don't conform to Bean conventions can also be constructed in FXML, using an object called a \"builder\". Builders are discussed in more detail later.\n\nInternally, the FXML loader uses an instance of com.sun.javafx.fxml.BeanAdapter to wrap an instantiated object and invoke its setter methods. This (currently) private class implements the java.util.Map interface and allows a caller to get and set Bean property values as key/value pairs.\n\nIf an element represents a type that already implements Map (such as java.util.HashMap), it is not wrapped and its get() and put() methods are invoked directly. For example, the following FXML creates an instance of HashMap and sets its \"foo\" and \"bar\" values to \"123\" and \"456\", respectively:\n\nThe fx:value attribute can be used to initialize an instance of a type that does not have a default constructor but provides a static valueOf(String) method. For example, java.lang.String as well as each of the primitive wrapper types define a valueOf() method and can be constructed in FXML as follows:\n\nCustom classes that define a static valueOf(String) method can also be constructed this way.\n\nThe fx:factory attribute is another means of creating objects whose classes do not have a default constructor. The value of the attribute is the name of a static, no-arg factory method for producing class instances. For example, the following markup creates an instance of an observable array list, populated with three string values:\n\nA third means of creating instances of classes that do not conform to Bean conventions (such as those representing immutable values) is a \"builder\". The builder design pattern delegates object construction to a mutable helper class (called a \"builder\") that is responsible for manufacturing instances of the immutable type.\n\nBuilder support in FXML is provided by two interfaces. The javafx.util.Builder interface defines a single method named build() which is responsible for constructing the actual object:\n\nA javafx.util.BuilderFactory is responsible for producing builders that are capable of instantiating a given type:\n\nA default builder factory, JavaFXBuilderFactory, is provided in the javafx.fxml package. This factory is capable of creating and configuring most immutable JavaFX types. For example, the following markup uses the default builder to create an instance of the immutable javafx.scene.paint.Color class:\n\nNote that, unlike Bean types, which are constructed when the element's start tag is processed, objects constructed by a builder are not instantiated until the element's closing tag is reached. This is because all of the required arguments may not be available until the element has been fully processed. For example, the Color object in the preceding example could also be written as:\n\nThe Color instance cannot be fully constructed until all three of the color components are known.\n\nWhen processing markup for an object that will be constructed by a builder, the Builder instances are treated like value objects - if a Builder implements the Map interface, the put() method is used to set the builder's attribute values. Otherwise, the builder is wrapped in a BeanAdapter and its properties are assumed to be exposed via standard Bean setters.\n\nThe <fx:include> tag creates an object from FXML markup defined in another file. It is used as follows:\n\nwhere filename is the name of the FXML file to include. Values that begin with a leading slash character are treated as relative to the classpath. Values with no leading slash are considered relative to the path of the current document.\n\nFor example, given the following markup:\n\nIf my_button.fxml contains the following:\n\nthe resulting scene graph would contain a VBox as a root object with a single Button as a child node.\n\nNote the use of the \"fx\" namespace prefix. This is a reserved prefix that defines a number of elements and attributes that are used for internal processing of an FXML source file. It is generally declared on the root element of a FXML document. Other features provided by the \"fx\" namespace are described in the following sections.\n\n<fx:include> also supports attributes for specifying the name of the resource bundle that should be used to localize the included content, as well as the character set used to encode the source file. Resource resolution is discussed in a later section.\n\nThe <fx:constant> element creates a reference to a class constant. For example, the following markup sets the value of the \"minWidth\" property of aButton instance to the value of the NEGATIVE_INFINITY constant defined by the java.lang.Double class:\n\nThe <fx:reference> element creates a new reference to an existing element. Wherever this tag appears, it will effectively be replaced by the value of the named element. It is used in conjunction with either the fx:id attribute or with a script variables, both of which are discussed in more detail in later sections. The \"source\" attribute of the <fx:reference> element specifies the name of the object to which the new element will refer.\n\nFor example, the following markup assigns a previously-defined Image instance named \"myImage\" to the \"image\" property of an ImageView control:\n\nNote that, since it is also possible to dereference a variable using the attribute variable resolution operator (discussed later in the Attributes section), fx:reference is generally only used when a reference value must be specified as an element, such as when adding the reference to a collection:\n\nFor most other cases, using an attribute is simpler and more concise.\n\nThe <fx:copy> element creates a copy of an existing element. Like <fx:reference>, it is used with the fx:id attribute or a script variable. The element's \"source\" attribute specifies the name of the object that will be copied. The source type must define a copy constructor that will be used to construct the copy from the source value.\n\nAt the moment, no JavaFX platform classes provide such a copy constructor, so this element is provided primarily for use by application developers. This may change in a future release.\n\nThe <fx:root> element creates a reference to a previously defined root element. It is only valid as the root node of an FXML document. <fx:root> is used primarily when creating custom controls that are backed by FXML markup. This is discussed in more detail in the FXMLLoader section.\n\nElements whose tag names begin with a lowercase letter represent object properties. A property element may represent one of the following:\n\nIf an element represents a property setter, the contents of the element (which must be either a text node or a nested class instance element) are passed as the value to the setter for the property.\n\nFor example, the following FXML creates an instance of the Label class and sets the value of the label's \"text\" property to \"Hello, World!\":\n\nThis produces the same result as the earlier example which used an attribute to set the \"text\" property:\n\nProperty elements are generally used when the property value is a complex type that can't be represented using a simple string-based attribute value, or when the character length of the value is so long that specifying it as an attribute would have a negative impact on readability.\n\nFXML uses \"type coercion\" to convert property values to the appropriate type as needed. Type coercion is required because the only data types supported by XML are elements, text, and attributes (whose values are also text). However, Java supports a number of different data types including built-in primitive value types as well as extensible reference types.\n\nThe FXML loader uses the coerce() method of BeanAdapter to perform any required type conversions. This method is capable of performing basic primitive type conversions such as String to boolean or int to double, and will also convert String to Class or String to Enum. Additional conversions can be implemented by defining a static valueOf() method on the target type.\n\nA read-only list property is a Bean property whose getter returns an instance of java.util.List and has no corresponding setter method. The contents of a read-only list element are automatically added to the list as they are processed.\n\nFor example, the \"children\" property of javafx.scene.Group is a read-only list property representing the group's child nodes:\n\nAs each sub-element of the <children> element is read, it is added to the list returned by Group#getChildren().\n\nA read-only map property is a bean property whose getter returns an instance of java.util.Map and has no corresponding setter method. The attributes of a read-only map element are applied to the map when the closing tag is processed.\n\nThe \"properties\" property of javafx.scene.Node is an example of a read-only map property. The following markup sets the \"foo\" and \"bar\" properties of a Label instance to \"123\" and \"456\", respectively:\n\nNote that a read-only property whose type is neither a List nor a Map will be treated as if it were a read-only map. The return value of the getter method will be wrapped in a BeanAdapter and can be used in the same way as any other read-only map.\n\nA class may define a \"default property\" using the @DefaultProperty annotation defined in the javafx.beans package. If present, the sub-element representing the default property can be omitted from the markup.\n\nFor example, since javafx.scene.layout.Pane (the superclass of javafx.scene.layout.VBox) defines a default property of \"children\", a <children> element is not required; the loader will automatically add the sub-elements of the VBox to the container's \"children\" collection:\n\nNote that default properties are not limited to collections. If an element's default property refers to a scalar value, any sub-element of that element will be set as the value of the property.\n\nFor example, since javafx.scene.control.ScrollPane defines a default property of \"content\", a scroll pane containing a TextArea as its content can be specified as follows:\n\nTaking advantage of default properties can significantly reduce the verbosity of FXML markup.\n\nAn element may also represent a \"static\" property (sometimes called an \"attached property\"). Static properties are properties that only make sense in a particular context. They are not intrinsic to the class to which they are applied, but are defined by another class (often, the parent container of a control).\n\nStatic properties are prefixed with the name of class that defines them. For example, The following FXML invokes the static setter for GridPane's \"rowIndex\" and \"columnIndex\" properties:\n\nThis translates roughly to the following in Java:\n\nAs with instance properties, static property elements are generally used when the property value cannot be efficiently represented by an attribute value. Otherwise, static property attributes (discussed in a later section) will generally produce more concise and readable markup.\n\nThe <fx:define> element is used to create objects that exist outside of the object hierarchy but may need to be referred to elsewhere.\n\nFor example, when working with radio buttons, it is common to define a ToggleGroup that will manage the buttons' selection state. This group is not part of the scene graph itself, so should not be added to the buttons' parent. A define block can be used to create the button group without interfering with the overall structure of the document:\n\nElements in define blocks are usually assigned an ID that can be used to refer to the element's value later. IDs are discussed in more detail in later sections.\n\nAn attribute in FXML may represent one of the following:\n\nEach are discussed in more detail in the following sections.\n\nLike property elements, attributes can also be used to configure the properties of a class instance. For example, the following markup creates a Button whose text reads \"Click Me!\":\n\nAs with property elements, property attributes support type coercion. When the following markup is processed, the \"x\", \"y\", \"width\", and \"height\" values will be converted to doubles, and the \"fill\" value will be converted to a Color:\n\nUnlike property elements, which are applied as they are processed, property attributes are not applied until the closing tag of their respective element is reached. This is done primarily to facilitate the case where an attribute value depends on some information that won't be available until after the element's content has been completely processed (for example, the selected index of a TabPane control, which can't be set until all of the tabs have been added).\n\nAnother key difference between property attributes and property elements in FXML is that attributes support a number of \"resolution operators\" that extend their functionality. The following operators are supported and are discussed in more detail below:\n\nAs strings, XML attributes cannot natively represent typed location information such as a URL. However, it is often necessary to specify such locations in markup; for example, the source of an image resource. The location resolution operator (represented by an \"@\" prefix to the attribute value) is used to specify that an attribute value should be treated as a location relative to the current file rather than a simple string.\n\nFor example, the following markup creates an ImageView and populates it with image data from my_image.png, which is assumed to be located at a path relative to the current FXML file:\n\nSince Image is an immutable object, a builder is required to construct it. Alternatively, if Image were to define a valueOf(URL) factory method, the image view could be populated as follows:\n\nThe value of the \"image\" attribute would be converted to a URL by the FXML loader, then coerced to an Image using the valueOf() method.\n\nIn FXML, resource substitution can be performed at load time for localization purposes. When provided with an instance of java.util.ResourceBundle, the FXML loader will replace instances of resource names with their locale-specific values. Resource names are identified by a \"%\" prefix, as shown below:\n\nIf the loader is given a resource bundle defined as follows:\n\nthe output of the FXML loader would be a Label instance containing the text \"This is the text!\".\n\nAn FXML document defines a variable namespace in which named elements and script variables may be uniquely identified. The variable resolution operator allows a caller to replace an attribute value with an instance of a named object before the corresponding setter method is invoked. Variable references are identified by a \"$\" prefix, as shown below:\n\nAssigning an fx:id value to an element creates a variable in the document's namespace that can later be referred to by variable dereference attributes, such as the \"toggleGroup\" attribute shown above, or in script code, discussed in a later section. Additionally, if the object's type defines an \"id\" property, this value will also be passed to the objects setId() method.\n\nIf the value of an attribute begins with one of the resource resolution prefixes, the character can be escaped by prepending it with a leading backslash (\"\\\") character. For example, the following markup creates a Label instance whose text reads \"$10.00\":\n\nAttribute variables as shown above are resolved once at load time. Later updates to the variables value are not automatically reflected in any properties to which the value was assigned. In many cases, this is sufficient; however, it is often convenient to \"bind\" a property value to a variable or expression such that changes to the variable are automatically propagated to the target property. Expression bindings can be used for this purpose.\n\nAn expression binding also begins with the variable resolution operator, but is followed by a set of curly braces which wrap the expression value. For example, the following markup binds the value of a text input's \"text\" property to the \"text\" property of a Label instance:\n\nAs the user types in the text input, the label's text content will be automatically updated.\n\nOnly simple expressions that resolve to property values or page variables are currently supported. Support for more complex expressions involving boolean or other operators may be added in the future.\n\nAttributes representing static properties are handled similarly to static property elements and use a similar syntax. For example, the earlier GridPane markup shown earlier to demonstrate static property elements could be rewritten as follows:\n\nIn addition to being more concise, static property attributes, like instance property attributes, support location, resource, and variable resolution operators, the only limitation being that it is not possible to create an expression binding to a static property.\n\nEvent handler attributes are a convenient means of attaching behaviors to document elements. Any class that defines a setOnEvent() method can be assigned an event handler in markup, as can any observable property (via an \"onPropertyChange\" attribute).\n\nFXML supports two types of event handler attributes: script event handlers and controller method event handlers. Each are discussed below.\n\nA script event handler is an event handler that executes script code when the event is fired, similar to event handlers in HTML. For example, the following script-based handler for the button's \"onAction\" event uses JavaScript to write the text \"You clicked me!\" to the console when the user presses the button:\n\nNote the use of the language processing instruction at the beginning of the code snippet. This PI tells the FXML loader which scripting language should be used to execute the event handler. A page language must be specified whenever inline script is used in an FXML document, and can only be specified once per document. However, this does not apply to external scripts, which may be implemented using any number of supported scripting languages. Scripting is discussed in more detail in the next section.\n\nA controller method event handler is a method defined by a document's \"controller\". A controller is an object that is associated with the deserialized contents of an FXML document and is responsible for coordinating the behaviors of the objects (often user interface elements) defined by the document.\n\nA controller method event handler is specified by a leading hash symbol followed by the name of the handler method. For example:\n\nNote the use of the fx:controller attribute on the root element. This attribute is used to associate a controller class with the document. If MyController is defined as follows:\n\nthe handleButtonAction() will be called when the user presses the button, and the text \"You clicked me!\" will be written to the console.\n\nIn general, a handler method should conform to the signature of a standard event handler; that is, it should take a single argument of a type that extends javafx.event.Event and should return void (similar to an event delegate in C#). The event argument often carries important and useful information about the nature of the event; however, it is optional and may be omitted if desired.\n\nControllers are discussed in more detail in a later section.\n\nFor example, the following markup defines a function called handleButtonAction() that is called by the action handler attached to the Button element:\n\nClicking the button triggers the event handler, which invokes the function, producing output identical to the previous examples.\n\nScript code may also be defined in external files. The previous example could be split into an FXML file and a JavaScript source file with no difference in functionality:\n\nIt is often preferable to separate code from markup in this way, since many text editors support syntax highlighting for the various scripting languages supported by the JVM. It can also help improve readability of the source code and markup.\n\nNote that script blocks are not limited to defining event handler functions. Script code is executed as it is processed, so it can also be used to dynamically configure the structure of the resulting output. As a simple example, the following FXML includes a script block that defines a variable named \"labelText\". The value of this variable is used to populate the text property of a Label instance:\n\nWhile it can be convenient to write simple event handlers in script, either inline or defined in external files, it is often preferable to define more complex application logic in a compiled, strongly-typed language such as Java. As discussed earlier, the fx:controller attribute allows a caller to associate a \"controller\" class with an FXML document. A controller is a compiled class that implements the \"code behind\" the object hierarchy defined by the document.\n\nAs shown earlier, controllers are often used to implement event handlers for user interface elements defined in markup:\n\nIn many cases, it is sufficient to simply declare event handlers in this manner. However, when more control over the behavior of the controller and the elements it manages is required, the controller can define an initialize() method, which will be called once on an implementing controller when the contents of its associated document have been completely loaded:\n\nThis allows the implementing class to perform any necessary post-processing on the content. It also provides the controller with access to the resources that were used to load the document and the location that was used to resolve relative paths within the document (commonly equivalent to the location of the document itself).\n\nFor example, the following code defines an initialize() method that attaches an action handler to a button in code rather than via an event handler attribute, as was done in the previous example. The button instance variable is injected by the loader as the document is read. The resulting application behavior is identical:\n\nNote that, in the previous examples, the controller member fields and event handler methods were declared as public so they can be set or invoked by the loader. In practice, this is not often an issue, since a controller is generally only visible to the FXML loader that creates it. However, for developers who prefer more restricted visibility for controller fields or handler methods, the javafx.fxml.FXML annotation can be used. This annotation marks a protected or private class member as accessible to FXML.\n\nFor example, the controllers from the previous examples could be rewritten as follows:\n\nIn the first version, the handleButtonAction() is tagged with @FXML to allow markup defined in the controller's document to invoke it. In the second example, the button field is annotated to allow the loader to set its value. The initialize() method is similarly annotated.\n\nNote that the @FXML annotation can currently only be used with trusted code. Because the FXML loader relies on reflection to set member fields and invoke member methods, it must call setAccessible() on any non-public Field. setAccessible() is a privileged operation that can only be executed in a secure context. This may change in a future release.\n\nController instances for nested FXML documents loaded via the <fx:include> element are mapped directly to member fields of the including controller. This allows a developer to easily access functionality defined by an include (such as a dialog window presented by an application's main window controller). For example, given the following code:\n\nwhen the controller's initialize() method is called, the dialog field will contain the root element loaded from the \"dialog.fxml\" include, and the dialogController field will contain the include's controller. The main controller can then invoke methods on the included controller, to populate and show the dialog, for example.\n\nThe FXMLLoader class is responsible for actually loading an FXML source file and returning the resulting object graph. For example, the following code loads an FXML file from a location on the classpath relative to the loading class and localizes it with a resource bundle named \"com.foo.example\". The type of the root element is assumed to be a subclass of javafx.scene.layout.Pane, and the document is assumed to define a controller of type MyController:\n\nNote that the output of an FXMLLoader#load() operation is an instance hierarchy that reflects the actual named classes in the document, not org.w3c.dom nodes representing those classes. Internally, FXMLLoader uses the javax.xml.stream API (also known as the Streaming API for XML, or StAX) to load an FXML document. StAX is an extremely efficient event-based XML parsing API that is conceptually similar to its W3C predecessor, SAX. It allows an FXML document to be processed in a single pass, rather than loaded into an intermediate DOM structure and then post-processed.\n\nThe setRoot() and setController() methods of FXMLLoader allow a caller to inject document root and controller values, respectively, into the document namespace, rather than delegating creation of these values to FXMLLoader itself. This allows a developer to easily create reusable controls that are internally implemented using markup, but (from an API perspective) appear identically to controls implemented programmatically.\n\nFor example, the following markup defines the structure of a simple custom control containing a TextField and a Button instance. The root container is defined as an instance of javafx.scene.layout.VBox:\n\nAs mentioned earlier, the <fx:root> tag creates a reference to a previously defined root element. The value of this element is obtained by calling the getRoot() method of FXMLLoader. Prior to calling load(), the caller must specify this value via a call to setRoot(). The caller may similarly provide a value for the document's controller by calling setController(), which sets the value that will be used as the document's controller when the document is read. These two methods are commonly used together when creating custom FXML-based components.\n\nIn the following example, the CustomControl class extends VBox (the type declared by the <fx:root> element), and sets itself as both the root and controller of the FXML document in its constructor. When the document is loaded, the contents of CustomControl will be populated with the contents of the previous FXML document:\n\nNow, callers can use instances of this control in code or in markup, just like any other control; e.g.:\n\nCopyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved."
    },
    {
        "link": "https://docs.oracle.com/javafx/2/events/handlers.htm",
        "document": "This topic describes event handlers in JavaFX applications. Learn how event handlers can be used to process the events generated by keyboard actions, mouse actions, scroll actions, and other user interactions with your application.\n\nEvent handlers enable you to handle events during the event bubbling phase. A node can have one or more handlers for handling an event. A single handler can be used for more than one node and more than one event type. If an event handler for a child node does not consume the event, an event handler for a parent node enables the parent node to act on the event after a child node processes it and to provide common event processing for multiple child nodes.\n\nTo process an event during the event bubbling phase, a node must register an event handler. An event handler is an implementation of the interface. The method of this interface provides the code that is executed when the event that is associated with the handler is received by the node that registered the handler. To register a handler, use the method. This method takes the event type and the handler as arguments. In Example 4-1, the first handler is added to a single node and processes a specific event type. A second handler for handling input events is defined and registered by two different nodes. The same handler is also registered for two different types of events. // Register an event handler for a single node and a specific event type node.addEventHandler(DragEvent.DRAG_ENTERED, new EventHandler<DragEvent>() { public void handle(DragEvent) { ... }; }); // Define an event handler EventHandler handler = new EventHandler(<InputEvent>() { public void handle(InputEvent event) { System.out.println(\"Handling event \" + event.getEventType()); event.consume(); } // Register the same handler for two different nodes myNode1.addEventHandler(DragEvent.DRAG_EXITED, handler); myNode2.addEventHandler(DragEvent.DRAG_EXITED, handler); // Register the handler for another event type myNode1.addEventHandler(MouseEvent.MOUSE_DRAGGED, handler); Note that an event handler that is defined for one type of event can also be used for any subtypes of that event. See Event Types for information on the hierarchy of event types. When you no longer want an event handler to process events for a node or for an event type, remove the handler using the method. This method takes the event type and the handler as arguments. In Example 4-2, the handler defined in Example 4-1 is removed from the event for . The handler is still executed by and by for the event. \n\n To remove an event handler that was registered by a convenience method, pass null to the convenience method, for example, . \n\n\n\nEvent handlers are typically used on a the leaf nodes or on a branch node of the event dispatch chain and are called during the event bubbling phase of event handling. Use a handler on a branch node to perform actions such as defining a default response for all child nodes. To see an example of how handlers can be used, download the file. Extract the NetBeans project and open it in the NetBeans IDE. The following sections describe the handlers that are used by this example. The Keyboard example demonstrates the following uses of handlers:\n• Registering a single handler for two different event types Figure 4-1 is the screen that is shown when the Keyboard Example is started. The user interface consists of four letters, each in its own square, which represent the corresponding keyboard key. The first key on the screen is highlighted, which indicates that it has the focus. Use the left and right arrow keys on the keyboard to move the focus to a different key on the screen. When the Enter key is pressed, the key on the screen with the focus changes to red. When the Enter key is released, the key on the screen returns to its previous color. When the key for a letter that matches one of the keys on the screen is pressed, the matching key on the screen changes to red, and returns to its previous color when the key is released. When a key that does not match any key on the screen is pressed, nothing happens. Figure 4-2 shows the screen when the A key has focus and the D key on the keyboard is pressed. Handlers for the Keyboard Example In the Keyboard example, internally each key shown on the screen is represented by a key node. All key nodes are contained in a single keyboard node. Each key node has a handler that receives key events when the key has focus. The handler responds to the key-pressed and key-released events for the Enter key by changing the color of the key on the screen. The event is then consumed so that the keyboard node, which is the parent node, does not receive the event. Example 4-3 shows the method that defines the handler for the key nodes. Example 4-3 Handler for the Key Nodes private void installEventHandler(final Node keyNode) { // handler for enter key press / release events, other keys are // handled by the parent (keyboard) node handler final EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() { public void handle(final KeyEvent keyEvent) { if (keyEvent.getCode() == KeyCode.ENTER) { setPressed(keyEvent.getEventType() == KeyEvent.KEY_PRESSED); keyEvent.consume(); } } }; keyNode.setOnKeyPressed(keyEventHandler); keyNode.setOnKeyReleased(keyEventHandler); } The keyboard node has two handlers that handle key events that are not consumed by a key node handler. The first handler changes the color of the key node that matches the key pressed. The second handler responds to the left and right arrow keys and moves the focus. Example 4-4 shows method that defines the handlers for the keyboard node. Example 4-4 Handlers for the Keyboard Node private void installEventHandler(final Parent keyboardNode) { // handler for key pressed / released events not handled by // key nodes final EventHandler<KeyEvent> keyEventHandler = new EventHandler<KeyEvent>() { public void handle(final KeyEvent keyEvent) { final Key key = lookupKey(keyEvent.getCode()); if (key != null) { key.setPressed(keyEvent.getEventType() == KeyEvent.KEY_PRESSED); keyEvent.consume(); } } }; keyboardNode.setOnKeyPressed(keyEventHandler); keyboardNode.setOnKeyReleased(keyEventHandler); keyboardNode.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() { public void handle( final KeyEvent keyEvent) { handleFocusTraversal( keyboardNode, keyEvent); } }); } The two handlers for the key-pressed event are considered peer handlers. Therefore, even though each handler consumes the event, the other handler is still invoked."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/net/NetworkInterface.html",
        "document": "\n• Get the name of this network interface. the name of this network interface\n• Convenience method to return an Enumeration with all or a subset of the InetAddresses bound to this network interface. If there is a security manager, its method is called for each InetAddress. Only InetAddresses where the doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the (\"getNetworkInformation\") permission, then all InetAddresses are returned. an Enumeration object with all or a subset of the InetAddresses bound to this network interface\n• of this network interface. Get a List of all or a subset of theof this network interface. If there is a security manager, its method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the doesn't throw a SecurityException will be returned in the List. a object with all or a subset of the InterfaceAddresss of this network interface\n• Get an Enumeration with all the subinterfaces (also known as virtual interfaces) attached to this network interface. For instance eth0:1 will be a subinterface to eth0. an Enumeration object with all of the subinterfaces of this network interface\n• Returns the parent NetworkInterface of this interface if this is a subinterface, or if it is a physical (non virtual) interface or has no parent. The this interface is attached to.\n• Returns the index of this network interface. The index is an integer greater or equal to zero, or for unknown. This is a system specific value and interfaces with the same name can have different indexes on different machines. the index of this network interface or if the index is unknown\n• Get the display name of this network interface. A display name is a human readable String describing the network device. a non-empty string representing the display name of this network interface, or null if no display name is available.\n• Searches for the network interface with the specified name. - The name of the network interface. A with the specified name, or if there is no network interface with the specified name. - If the specified name is .\n• Get a network interface given its index. - an integer, the index of the interface the NetworkInterface obtained from its index, or if there is no interface with such an index on the system - if index has a negative value\n• Convenience method to search for a network interface that has the specified Internet Protocol (IP) address bound to it. If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned. - The to search with. A or if there is no network interface with the specified IP address. - If the specified address is .\n• Returns all the interfaces on this machine. The contains at least one element, possibly representing a loopback interface that only supports communication between entities on this machine. NOTE: can use getNetworkInterfaces()+getInetAddresses() to obtain all IP addresses for this node an Enumeration of NetworkInterfaces found on this machine\n• Returns whether a network interface is up and running. if the interface is up and running.\n• if the interface is a loopback interface.\n• Returns whether a network interface is a point to point interface. A typical point to point interface would be a PPP connection through a modem. if the interface is a point to point interface.\n• Returns whether a network interface supports multicasting or not.\n• Returns the hardware address (usually MAC) of the interface if it has one and if it can be accessed given the current privileges. If a security manager is set, then the caller must have the permission (\"getNetworkInformation\"). a byte array containing the address, or if the address doesn't exist, is not accessible or a security manager is set and the caller does not have the permission NetPermission(\"getNetworkInformation\")\n• Returns the Maximum Transmission Unit (MTU) of this interface. the value of the MTU for that interface.\n• Returns whether this interface is a virtual interface (also called subinterface). Virtual interfaces are, on some systems, interfaces created as a child of a physical interface and given different settings (like address or MTU). Usually the name of the interface will the name of the parent followed by a colon (:) and a number identifying the child since there can be several virtual interfaces attached to a single physical interface. if this interface is a virtual interface.\n• if and only if the argument is not and it represents the same NetworkInterface as this object. Compares this object against the specified object. The result isif and only if the argument is notand it represents the same NetworkInterface as this object. Two instances of represent the same NetworkInterface if both name and addrs are the same for both. - the object to compare against. if the objects are the same; otherwise.\n• Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by The general contract of is:\n• Whenever it is invoked on the same object more than once during an execution of a Java application, the method must consistently return the same integer, provided no information used in comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.\n• If two objects are equal according to the method, then calling the method on each of the two objects must produce the same integer result.\n• It is not required that if two objects are unequal according to the method, then calling the method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java™ programming language.) a hash code value for this object.\n• method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. Returns a string representation of the object. In general, themethod returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The method for class returns a string consisting of the name of the class of which the object is an instance, the at-sign character ` ', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:"
    },
    {
        "link": "https://docs.oracle.com/javase%2F8%2Fdocs%2Fapi%2F%2F/index.html?java/net/NetworkInterface.html",
        "document": "Looking for a different release? Other releases"
    },
    {
        "link": "https://stackoverflow.com/questions/8462498/how-to-determine-internet-network-interface-in-java",
        "document": "On my laptop (running Windows 7, with Virtual Box and it's network interface installed) the following code prints out the name of my wireless interface along with my local address. It uses a brute force approach at the end of the day, but will only try and actually connect to addresses that are considered to be the best candidates.\n\nOne thing to watch out for. would bark at me that the address and port is already in use if I tried to run my code too fast in succession like the connection isn't cleaned up fast enough. should be a random port maybe."
    },
    {
        "link": "https://baeldung.com/java-network-interfaces",
        "document": "In this article, we’ll focus on network interfaces and how to access them programmatically in Java.\n\nSimply put, a network interface is the point of interconnection between a device and any of its network connections.\n\nIn everyday language, we refer to them by the term Network Interface Cards (NICs) – but they don’t all have to be of hardware form.\n\nFor example, the popular localhost IP 127.0.0.1, which we use a lot in testing web and network applications is the loopback interface – which is not a direct hardware interface.\n\nOf course, systems often have multiple active network connections, such as wired ethernet, WIFI, Bluetooth, etc.\n\nIn Java, the main API we can use to interact directly with them is the java.net.NetworkInterface class. And so, to get started quickly, let’s import the full package:\n\nMost Java programs won’t probably interact with them directly; there are however special scenarios when we do need this kind of low-level access.\n\nThe most outstanding of these is where a system has multiple cards and you would like to have the freedom to choose a specific interface to use a socket with. In such a scenario, we usually know the name but not necessarily the IP address.\n\nNormally, when we want to make a socket connection the to a specific server address:\n\nThis way, the system will pick a suitable local address, bind to it and communicate to the server through its network interface. However, this approach does not allow us to choose our own.\n\nWe will make an assumption here; we don’t know the address but we know the name. Just for demonstration purposes, let’s assume we want the connection over the loopback interface, by convention, its name is lo, at least on Linux and Windows systems, on OSX it is lo0:\n\nSo we retrieve the network interface attached to lo first, retrieve the addresses attached to it, create a socket, bind it to any of the enumerated addresses which we don’t even know at compile time and then connect.\n\nA NetworkInterface object contains a name and a set of IP addresses assigned to it. So binding to any of these addresses will guarantee communication through this interface.\n\nThis does not really say anything special about the API. We know that if we want our local address to be localhost, the first snippet would suffice if we just added the binding code.\n\nAdditionally, we would never really have to go through all the several steps since localhost has one well-known address, 127.0.0.1 and we can easily bind the socket to it.\n\nHowever, in your case, lo could perhaps have represented other interfaces like Bluetooth – net1, wireless network – net0 or ethernet – eth0. In such cases, you would not know the IP address at compile time.\n\nIn this section, we will explore the other available APIs for retrieving the available interfaces. In the previous section, we saw just one of these approaches; the getByName() static method.\n\nIt’s worth noting that the NetworkInterface class does not have any public constructors, so we are of course not able to create a new instance. Instead, we’re going to use the available APIs to retrieve one.\n\nThe API we looked at so far is used to search a network interface by the specified name:\n\nIt returns null if none is for the name:\n\nThe second API is getByInetAddress(), it also requires that we provide a known parameter, this time we can provide the IP address:\n\nOr name of the host:\n\nOr if you are specific about localhost:\n\nAnother alternative is also to explicitly use the loopback interface:\n\nThe third approach which has only been available since Java 7 is to get a network interface by its index:\n\nThe final approach involves using the getNetworkInterfaces API. It returns an Enumeration of all available network interfaces in the system. It’s upon us to retrieve the returned objects in a loop, the standard idiom uses a List:\n\nThere is a lot of valuable information we can get from one after retrieving its object. One of the most useful is the list of IP addresses assigned to it.\n\nWe can get IP addresses using two APIs. The first API is getInetAddresses(). It returns an Enumeration of InetAddress instances which we can process as we deem fit:\n\nThe second API is getInterfaceAddresses(). It returns a List of InterfaceAddress instances which are more powerful than InetAddress instances. For example, apart from the IP address, you may be interested in the broadcast address:\n\nWe can access network parameters about an interface beyond the name and IP addresses assigned to it. To check if it is up and running:\n\nTo check if it is a loopback interface:\n\nTo check if it represents a point to point network connection:\n\nTo check if multicasting is supported:\n\nOr to retrieve its physical address, usually called MAC address:\n\nAnother parameter is the Maximum Transmission Unit which defines the largest packet size that can be transmitted through this interface:\n\nIn this article, we have shown network interfaces, how to access them programmatically and why we would need to access them."
    },
    {
        "link": "https://stackoverflow.com/questions/11102108/how-to-get-all-network-interfaces-in-java-and-store-the-information-in-java-map",
        "document": "I'm new to Java programming. I need a way to get all network interfaces in Linux using java and store that information in Java . I found many ways in Google how to do this in a static way - just how to get and display the information. My code needs to be portable - the code must display the configuration deployed on server with 2 or 4 network ports.\n\nI thing that the best way to do this is to use Java to get the information and then later on display it. Would you please help me?"
    }
]