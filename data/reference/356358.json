[
    {
        "link": "https://threejs.org/docs",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/index.html",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/api/en/core/Object3D.html",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/manual/en/introduction/Creating-a-scene.html",
        "document": "The goal of this section is to give a brief introduction to three.js. We will start by setting up a scene, with a spinning cube. A working example is provided at the bottom of the page in case you get stuck and need help.\n\nIf you haven't yet, go through the [link:#manual/introduction/Installation Installation] guide. We'll assume you've already set up the same project structure (including index.html and main.js), have installed three.js, and are either running a build tool, or using a local server with a CDN and import maps.\n\nTo actually be able to display anything with three.js, we need three things: scene, camera and renderer, so that we can render the scene with camera.\n\nLet's take a moment to explain what's going on here. We have now set up the scene, our camera and the renderer.\n\nThere are a few different cameras in three.js. For now, let's use a `PerspectiveCamera`.\n\nThe first attribute is the `field of view`. FOV is the extent of the scene that is seen on the display at any given moment. The value is in degrees.\n\nThe second one is the `aspect ratio`. You almost always want to use the width of the element divided by the height, or you'll get the same result as when you play old movies on a widescreen TV - the image looks squished.\n\nThe next two attributes are the `near` and `far` clipping plane. What that means, is that objects further away from the camera than the value of `far` or closer than `near` won't be rendered. You don't have to worry about this now, but you may want to use other values in your apps to get better performance.\n\nNext up is the renderer. In addition to creating the renderer instance, we also need to set the size at which we want it to render our app. It's a good idea to use the width and height of the area we want to fill with our app - in this case, the width and height of the browser window. For performance intensive apps, you can also give `setSize` smaller values, like `window.innerWidth/2` and `window.innerHeight/2`, which will make the app render at quarter size.\n\nIf you wish to keep the size of your app but render it at a lower resolution, you can do so by calling `setSize` with false as `updateStyle` (the third argument). For example, `setSize(window.innerWidth/2, window.innerHeight/2, false)` will render your app at half resolution, given that your <canvas> has 100% width and height.\n\nLast but not least, we add the `renderer` element to our HTML document. This is a <canvas> element the renderer uses to display the scene to us.\n\n\"That's all good, but where's that cube you promised?\" Let's add it now.\n\nTo create a cube, we need a `BoxGeometry`. This is an object that contains all the points (`vertices`) and fill (`faces`) of the cube. We'll explore this more in the future.\n\nIn addition to the geometry, we need a material to color it. Three.js comes with several materials, but we'll stick to the `MeshBasicMaterial` for now. All materials take an object of properties which will be applied to them. To keep things very simple, we only supply a color attribute of `0x00ff00`, which is green. This works the same way that colors work in CSS or Photoshop (`hex colors`).\n\nThe third thing we need is a `Mesh`. A mesh is an object that takes a geometry, and applies a material to it, which we then can insert to our scene, and move freely around.\n\nBy default, when we call `scene.add()`, the thing we add will be added to the coordinates `(0,0,0)`. This would cause both the camera and the cube to be inside each other. To avoid this, we simply move the camera out a bit.\n\nIf you copied the code from above into the main.js file we created earlier, you wouldn't be able to see anything. This is because we're not actually rendering anything yet. For that, we need what's called a render or animation loop.\n\nThis will create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say \"why don't we just create a setInterval ?\" The thing is - we could, but `requestAnimationFrame` which is internally used in `WebGLRenderer` has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.\n\nIf you insert all the code above into the file you created before we began, you should see a green box. Let's make it all a little more interesting by rotating it.\n\nAdd the following code right above the `renderer.render` call in your `animate` function:\n\nThis will be run every frame (normally 60 times per second), and give the cube a nice rotation animation. Basically, anything you want to move or change while the app is running has to go through the animation loop. You can of course call other functions from there, so that you don't end up with an `animate` function that's hundreds of lines.\n\nCongratulations! You have now completed your first three.js application. It's simple, but you have to start somewhere.\n\nThe full code is available below and as an editable [link:https://jsfiddle.net/tswh48fL/ live example]. Play around with it to get a better understanding of how it works."
    },
    {
        "link": "https://stackoverflow.com/questions/19532128/three-js-manually-created-geometry",
        "document": "I'm trying to create a THREE.Geometry from scratch. When I try to use it (in a THREE.Mesh), I get\n\nThe geometry is created and becomes visible on screen, .\n\nHere is the code I'm using:\n\nWhat else do I need to do to make it work?\n\nUpdate: Still happens in R62. It happens with geometry generated by three.js' built in PlaneGeometry class too, so maybe it's a three.js bug. I'll file a report.\n\nI should also mention that execution does in fact not stop, that was a mistake on my part. I'm just getting the error, and it doesn't feel like I should have any errors if nothing is wrong.\n\nUpdate 2: There's an issue logged here, but it's been closed."
    },
    {
        "link": "https://threejs-journey.com/lessons/animations",
        "document": "We created a scene that we rendered once at the end of our code. That is already good progress, but most of the time, you'll want to animate your creations.\n\nAnimations, when using Three.js, work like stop motion. You move the objects, and you do a render. Then you move the objects a little more, and you do another render. Etc. The more you move the objects between renders, the faster they'll appear to move.\n\nThe screen you are looking at runs at a specific frequency. We call that a frame rate. The frame rate mostly depends on the screen, but the computer itself has limitations. Most screens run at 60 frames per second. If you do the maths, that means about a frame every 16ms. But some screens can run much faster, and when the computer has difficulties processing things, it'll run more slowly.\n\nWe want to execute a function that will move objects and do the render on each frame regardless of the frame rate.\n\nThe native JavaScript way of doing so is by using the method.\n\nAs we had before, all we have in the starter is our cube in the scene's center.\n\nThe primary purpose of requestAnimationFrame is not to run code on each frame.\n\nwill execute the function you provide on the next frame. But then, if this function also uses to execute that same function on the next frame, you'll end up with your function being executed on each frame forever which is exactly what we want.\n\nCreate a function named and call this function once. In this function, use to call this same function on the next frame:\n\nThat's it. You have your infinite loop.\n\nAs you can see on the console, the is being called on each frame. If you test this code on a computer with a high frame rate, the will appears at a higher frequency.\n\nYou can now move the call inside that function and increase the cube :\n\nCongratulations, you now have a Three.js animation.\n\nThe problem is, if you test this code on a computer with high frame rate, the cube will rotate faster, and if you test on a lower frame rate, the cube will rotate slower.\n\nTo adapt the animation to the framerate, we need to know how much time it's been since the last tick.\n\nFirst, we need a way to measure time. In native JavaScript, you can use to get the current timestamp:\n\nThe timestamp corresponds to how much time has passed since the 1st of January 1970 (the beginning of time for Unix). In JavaScript, its unit is in milliseconds.\n\nWhat you need now is to subtract the current timestamp to that of the previous frame to get what we can call the and use this value when animating objects:\n\nThe cube should rotate faster because the deltaTime should be around if your screen is running at , so feel free to reduce it by multiplying the value.\n\nNow that we base our rotation on how much time was spent since the last frame, this rotation speed will be the same on every screen and every computers regardless of the frame rate."
    },
    {
        "link": "https://stackoverflow.com/questions/45343673/three-js-animate-in-real-time",
        "document": "I'm using three.js and animated some Objects. I animated the object by using the animate() function of three.js. Basically something like that:\n\nUnfortunatlly this is called every rendered frame. So on each device with different framerates the speed of my object is different. Is there a way to make this depending on seconds or miliseconds?"
    },
    {
        "link": "https://discourse.threejs.org/t/i-really-cannot-find-a-good-example-or-explanation-to-how-to-get-animations-working/16862",
        "document": "Is there anybody that would like to help me with this?\n\nI cannot find a full expample, tutorial or explanation on how to get animations working.\n\n I have tried some stuff and I will try to put a .zip of my project here. I think I have a missing link between the clock and the animations.\n\nthanks so much in advance!"
    },
    {
        "link": "https://dev.to/pahund/animating-camera-movement-in-three-js-17e9",
        "document": "How to Fix Blurry Text on HTML Canvases on Mobile Phones\n\nStill Trying to Draw a Mind Map with Three.js and React\n\nDrawing a Mind Map with Three.js and React, for Real This Time\n\nI'm building a social media network and collaboration tool based on mind maps, documenting my work in this series of blog posts. Follow me if you're interested in what I've learned along the way about building web apps with React, Tailwind CSS, Firebase, Apollo/GraphQL, three.js and TypeScript.\n\nLet's figure out how we can make a 3D model we build with three.js interactive – when we click on it, the camera moves to put the clicked object to the center of the screen, like this:\n\nI currently need this for a project I'm working on, Nuffshell, a social network and collaboration tool based on mind maps.\n\nFor this part of my series, however, I'm not going to work on my Nuffshell code, but build something from scratch, to make it easier for you to follow along.\n\nIf you do want to follow along, I recommend you use CodeSandbox and create a new project using the “Vanilla” template:\n\nThis already has everything set up for you to work with JavaScript modules.\n\nAs a first step, I'm going to set up my basic 3D scene that shows four colored cubes, for now, without interactivity or animation.\n\nI find it good practice to factor every part of my program into functions that do one thing exactly. A function should not be longer than a screen length.\n\nWith this in mind, here are the JavaScript modules I create for setting up my 3D scene. Each module contains one function.\n\nMy createRenderer sets up the 3D renderer and attaches it to the HTML page (through a DOM element called app).\n\nI'm setting the size so that the 3D scene fills out the whole browser viewport.\n\nIn this function, I'm setting up a scene. Scenes in three.js are the top-level containers for all the 3D objects to be rendered.\n\nMaking 3D models in three.js is similar to making real-life movies: you need cameras and light sources to “film” it.\n\nThis function sets up the camera.\n\nNotice how I'm setting the Z-coordinate of the camera to 5. This means that the camera is some distance away from the object it is going to “film”.\n\nNext up is the function for the objects to be shown in my 3D scene. It creates simple 3D cubes. I can provide a color and X/Y coordinates. The Z coordinate is set to 0 for all cubes.\n\nThe 3D objects in three.js are made up of geometries and materials.\n\nLike in real life, we need a light source to be able to see anything in our 3D scene, so this function is for creating that.\n\nSince we want to have an animated 3D model, we need to render our model over and over again, 60 times per second, in a never-ending loop. My animate function accepts a callback argument, which is a function that gets executed as often as the browser can handle.\n\nI use the browser's requestAnimationFrame function for this, which the standard way to do this in pretty much all browser games.\n\nPutting It All Together\n\nSo now that we have functions to initialize renderer and scene, create a camera, a light source and some cubes and animate them, we can finally use these to create our 3D scene.\n\nNote how the camera, light and comes are all added to the scene.\n\nOur animate function makes sure the scene gets rendered over and over again. For now, pretty useless, but it will become important in the next steps.\n\nHere's the project so far:\n\nMe need to be able to click on 3D objects to tell the camera where to move to. To achieve this, I'm adding a dependency to the npm package three.interactive to my project.\n\nThis library allows us to add event listener to our 3D objects, just like with HTML DOM nodes.\n\nAt the beginning of my index.js, I'm adding an import statement to use three.interactive:\n\nIn addition to the renderer, scene and camera, I'm creating an interaction manager:\n\nAs you can see, the interaction manager needs to be able to control the renderer, camera and the canvas DOM element that the scene is rendered to.\n\nI change the for loop that creates the cube objects and adds them to the scene to write a log statement to the console when a cube is clicked, to see if it works:\n\nNotice event.stopPropagation – this is necessary so that if objects are overlapping, only the top object handles the click. Again, this works just like click handlers on DOM nodes.\n\nThe one thing that we still need to do is edit the animate loop so the the interaction manager updates with every iteration:\n\nHere's the project so far:\n\nWhen you open up the console on this sandbox (click on “console” in the lower left), then click on the 3D cubes, you'll see the log statements issued by the click handler I've added.\n\nNow let's actually move the camera to the position of the cube that was clicked.\n\nThis is actually pretty straightforward – I just have to update the camera's position to match the X/Y coordinates of the cube that was clicked.\n\nHere's the updated for loop that creates the cubes:\n\nNote that while the camera's X and Y coordinates change, the Z coordinate remains the same – the camera will still have 5 units distance from the objects it is “filming”.\n\nClick on the cubes to try it out!\n\nSo far, when a cube is clicked, the camera jumps to the cube's position immediately. This is a step in the right direction, but actually want the camera to move over to the cube's position in a smooth motion (technically, this is called “panning”).\n\nIn short, we want to add some proper animation magic!\n\nFor creating smooth motions in animations, we use a technique called inbetweening, or “tweeting”, in short.\n\nThis technique is as old as animating itself, it was used by the artists making Snow White in the 1930s, just as it is used by the artists making animations today.\n\nThe basic idea is that you have a start and end state or something to animate (also called “keyframes”), then draw all of the states in between to create the illusion of gradual change.\n\nHere, we have 3 keyframes:\n• Ball is on the upper left of the screen\n• Ball is in the bottom in the middle\n• Ball is on the upper right\n\nBy adding the tweens, it will look like the ball is bouncing on the floor in a smooth notion. Without them, the ball would just kind of jaggedly jump from one place to another.\n\nTo make our camera move smoothly, we need to use tweening. Like interactivity, three.js does not provide this out of the box. We're going to have to add another npm package dependency to our project: @tweenjs/tween.js.\n\nThis library is not specifically for use with three.js. You can use it any time something should be changed over a period of time.\n\nLet's add an import statement to index.js to use it:\n\nI create a tween in the for loop that creates my cubes, to the click handler that is fired when one of the cubes ist clicked:\n\nTo add the tween, I just have to instantiate a Tween object. The argument I'm passing to the constructor is the data I want to have “tweened”. In my case, this is an object containing X and Y coordinates. At the beginning of the tween, these X/Y coords are the original camera position.\n\nWith the to method, I tell the tween library what the end state of the tweened data should be. This will be the position of the cube that was clicked.\n\nWith the onUpdate method, I determine how the data that is being tweened can be used to affect my animation. It is called for every tweening step. I use this to update the position of the camera.\n\nFinally, the start method tells the library to start tweening right away.\n\nOne more thing – we now have to add a call to the update method of our tweening library to our animation loop:\n\nHere's the final version of our project:\n\nWhen you click on a cube, the camera pans smoothly over to its position – nice!\n\nThis tutorial is part of my project diary. I'm building social media network and collaboration tool, based on mind maps. I will continue to blog about my progress in follow-up articles. Stay tuned!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame",
        "document": "In this example, an element is animated for 2 seconds (2000 milliseconds). The element moves at a speed of 0.1px/ms to the right, so its relative position (in CSS pixels) can be calculated in function of the time elapsed since the start of the animation (in milliseconds) with . The element's final position is 200px ( ) to the right of its initial position.\n\nThe following three examples illustrate different approaches to setting the zero point in time, the baseline for calculating the progress of your animation in each frame. If you want to synchronize to an external clock, such as , the highest precision available is the duration of a single frame, 16.67ms @60hz. The callback's timestamp argument represents the end of the previous frame, so the soonest your newly calculated value(s) will be rendered is in the next frame.\n\nThis example waits until the first callback executes to set . If your animation jumps to a new value when it starts, you must structure it this way. If you do not need to synchronize to anything external, such as audio, then this approach is recommended because some browsers have a multi-frame delay between the initial call to and the first call to the callback function.\n\nThis example uses to set a zero value before the first call to . aligns with the argument, so the zero value is equivalent to the 0th frame's timestamp.\n\nThis example animates using instead of the callback's timestamp value. You might use this to achieve slightly higher synchronization precision, though the extra degree of precision is variable and not much of an increase. Note: This example does not allow you to synchronize animation callbacks reliably."
    }
]