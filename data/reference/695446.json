[
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://docs.python.org/3/reference/datamodel.html",
        "document": "Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer”, code is also represented by objects.) Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The operator compares the identity of two objects; the function returns an integer representing its identity. CPython implementation detail: For CPython, is the memory address where is stored. An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. The function returns an object’s type (which is an object itself). Like its identity, an object’s type is also unchangeable. The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object’s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable. Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether — it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable. CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed detection of cyclically linked garbage, which collects most objects as soon as they become unreachable, but is not guaranteed to collect garbage containing circular references. See the documentation of the module for information on controlling the collection of cyclic garbage. Other implementations act differently and CPython may change. Do not depend on immediate finalization of objects when they become unreachable (so you should always close files explicitly). Note that the use of the implementation’s tracing or debugging facilities may keep objects alive that would normally be collectable. Also note that catching an exception with a … statement may keep objects alive. Some objects contain references to “external” resources such as open files or windows. It is understood that these resources are freed when the object is garbage-collected, but since garbage collection is not guaranteed to happen, such objects also provide an explicit way to release the external resource, usually a method. Programs are strongly recommended to explicitly close such objects. The … statement and the statement provide convenient ways to do this. Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries. The references are part of a container’s value. In most cases, when we talk about the value of a container, we imply the values, not the identities of the contained objects; however, when we talk about the mutability of a container, only the identities of the immediately contained objects are implied. So, if an immutable container (like a tuple) contains a reference to a mutable object, its value changes if that mutable object is changed. Types affect almost all aspects of object behavior. Even the importance of object identity is affected in some sense: for immutable types, operations that compute new values may actually return a reference to any existing object with the same type and value, while for mutable objects this is not allowed. For example, after , a and b may or may not refer to the same object with the value one, depending on the implementation. This is because is an immutable type, so the reference to can be reused. This behaviour depends on the implementation used, so should not be relied upon, but is something to be aware of when making use of object identity tests. However, after , c and d are guaranteed to refer to two different, unique, newly created empty lists. (Note that assigns the same object to both e and f.)"
    },
    {
        "link": "https://realpython.com/python-classes",
        "document": "Python classes form the backbone of object-oriented programming, enabling you to encapsulate data and behavior into a single entity. When you work with a Python class, you define attributes to store data and methods to perform actions. This structure allows you to model real-world objects and create organized, reusable code.\n\nA class in Python serves as a blueprint for creating objects, which are instances of the class. You use classes when you need to encapsulate related data and functions, making your code modular and easier to manage. By defining classes, you can create multiple objects that share the same attributes and methods, while maintaining their own unique state.\n\nIn this tutorial, you’ll learn how to define and use Python classes, understand the distinction between classes and objects, and explore methods and attributes. You’ll also learn about instance and class attributes, methods, inheritance, and common pitfalls to avoid when working with classes.\n\nBy the end of this tutorial, you’ll understand that:\n• A class in Python is like a recipe for creating objects that encapsulate both data and behavior.\n• You use classes to model complex data structures and behaviors in a modular way.\n• You define classes in Python using the keyword, and instantiate them to create objects.\n• A class is a blueprint, while an object is an instance of a class.\n• Instance attributes are unique to each object, while class attributes are shared across all instances of the class.\n\nTo get the most out of this tutorial, you should know about Python variables, data types, and functions. Some experience with object-oriented programming (OOP) is also a plus. Don’t worry if you’re not an OOP expert yet. In this tutorial, you’ll learn the key concepts that you need to get started and more. You’ll also write several practical examples to help reinforce your knowledge of Python classes.\n\nPython is a multiparadigm programming language that supports object-oriented programming (OOP) through classes that you can define with the keyword. You can think of a class as a piece of code that specifies the data and behavior that represent and model a particular type of object. What is a class in Python? A common analogy is that a class is like the blueprint for a house. You can use the blueprint to create several houses and even a complete neighborhood. Each concrete house is an object or instance that’s derived from the blueprint. Each instance can have its own properties, such as color, owner, and interior design. These properties carry what’s commonly known as the object’s state. Instances can also have different behaviors, such as locking the doors and windows, opening the garage door, turning the lights on and off, watering the garden, and more. In OOP, you commonly use the term attributes to refer to the properties or data associated with a specific object of a given class. In Python, attributes are variables defined inside a class with the purpose of storing all the required data for the class to work. Similarly, you’ll use the term methods to refer to the different behaviors that objects will show. Methods are functions that you define within a class. These functions typically operate on or with the attributes of the underlying instance or class. Attributes and methods are collectively referred to as members of a class or object. You can write classes to model the real world. These classes will help you better organize your code and solve complex programming problems. For example, you can use classes to create objects that emulate people, animals, vehicles, books, buildings, cars, or other objects. You can also model virtual objects, such as a web server, directory tree, chatbot, file manager, and more. Finally, you can use classes to build class hierarchies. This way, you’ll promote code reuse and remove repetition throughout your codebase. In this tutorial, you’ll learn a lot about classes and all the cool things that you can do with them. To kick things off, you’ll start by defining your first class in Python. Then you’ll dive into other topics related to instances, attributes, and methods. To define a class, you need to use the keyword followed by the class name and a colon, just like you’d do for other compound statements in Python. Then you must define the class body, which will start at the next indentation level: In a class’s body, you can define attributes and methods as needed. As you already learned, attributes are variables that hold the class data, while methods are functions that provide behavior and typically act on the class data. Note: In Python, the body of a given class works as a namespace where attributes and methods live. You can only access those attributes and methods through the class or its objects. As an example of how to define attributes and methods, say that you need a class to model different circles in a drawing application. Initially, your class will have a single attribute to hold the radius. It’ll also have a method to calculate the circle’s area: In this code snippet, you define using the keyword. Inside the class, you write two methods. The method has a special meaning in Python classes. This method is known as the object initializer because it defines and sets the initial values for the object’s attributes. You’ll learn more about this method in the Instance Attributes section. The second method of is conveniently named and will compute the area of a specific circle by using its radius. In this example, you’ve used the module to access the constant as it’s defined in that module. It’s common for method names to contain a verb, such as calculate, to describe an action the method performs. To learn more about naming functions and methods in Python, check out the How Do You Choose Python Function Names? tutorial. Note: In Python, the first argument of most methods is . This argument holds a reference to the current object so that you can use it inside the class. You’ll learn more about this argument in the section on instance methods with . Cool! You’ve written your first class. Now, how can you use this class in your code to represent several concrete circles? Well, you need to instantiate your class to create specific circle objects from it. The action of creating concrete objects from an existing class is known as instantiation. With every instantiation, you create a new object of the target class. To get your hands dirty, go ahead and make a couple of instances of by running the following code in a Python REPL session: To create an object of a Python class like , you must call the class constructor with a pair of parentheses and a set of appropriate arguments. What arguments? In Python, the class constructor accepts the same arguments as the method. In this example, the class expects the argument. Calling the class constructor with different argument values will allow you to create different objects or instances of the target class. In the above example, and are separate instances of . In other words, they’re two different and concrete circles, as you can conclude from the code’s output. Great! You already know how to create objects of an existing class by calling the class constructor with the required arguments. Now, how can you access the attributes and methods of a given class? That’s what you’ll learn in the next section. In Python, you can access the attributes and methods of an object by using dot notation with the dot operator. The following snippet of code shows the required syntax: Note that the dot ( ) in this syntax basically means give me the following attribute or method from this object. The first line returns the value stored in the target attribute, while the second line accesses the target method and calls it. Note: Remember that to call a function or method, you need to use a pair of parentheses and a series of arguments, if applicable. Now get back to your circle objects and run the following code: In the first couple of lines after the instantiation, you access the attribute on your object. Then you call the method to calculate the circle’s area. In the second pair of statements, you do the same but on the object. You can also use dot notation and the assignment operator to change the current value of an attribute: Now the radius of is entirely different. When you call , the result immediately reflects this change. You’ve changed the object’s internal state or data, which typically impacts its behaviors or methods.\n\nAs you’ve learned, classes are great when you must bundle data and behavior together in a single entity. The data will come in the form of attributes, while the behavior will come as methods. You already have an idea of what an attribute is. Now it’s time to dive deeper into how you can add, access, and modify attributes in your custom classes. First, you need to know that your classes can have two types of attributes in Python:\n• Class attributes: A variable that you define in the class body directly. Class attributes belong to their containing class. Their data is common to the class and all its instances.\n• Instance attributes: A variable that you define inside an instance method using the argument and dot notation, like in . Instance attributes belong to a concrete instance of a given class. Their data is only available to that instance and defines its state. Both types of attributes have their specific use cases. Instance attributes are, by far, the most common type of attribute that you’ll use in your day-to-day coding, but class attributes also come in handy. Class attributes are variables that you define directly in the class body but outside of any method. These attributes are tied to the class itself rather than to particular objects of that class. All the objects that you create from a particular class share the same class attributes with the same original values. Because of this, if you change a class attribute, then that change affects all the derived objects. As an example, say that you want to create a class that keeps an internal count of the instances you’ve created. In that case, you can use a class attribute: keeps a class attribute that works as a counter of instances. When Python parses this class, it initializes the counter to zero and leaves it alone. Creating instances of this class means automatically calling the method and incremementing by one. Note: In the above example, you’ve used the class name to access inside . However, using the built-in function is best because it’ll make your class more flexible: The built-in function returns the class or type of , which is in this example. This subtle change makes your class more robust and reliable by avoiding hard-coding the name of the class that provides the attribute. It’s important to note that you can access class attributes using either the class or one of its instances. That’s why you can use the object to retrieve the value of . However, if you need to modify a class attribute, then you must use the class itself rather than one of its instances. For example, if you use to modify , then you’ll be overriding the original class attribute by creating a new instance attribute: You can’t modify class attributes through instances of the containing class. Doing that will create new instance attributes with the same name as the original class attributes. That’s why returns in this example. You’ve overridden the class attribute in the highlighted line. Note: It’s curious what Python does in the example above. It uses the initial value of as a class attribute to create a new instance attribute with the same name and increments it by one. How come? Well, the line is equivalent to the following assignment: In this statement, the attribute on the left of the equal sign is an instance attribute, while the attribute on the right side of the sign is a class attribute. Otherwise, the operator would’ve raised a . In general, you should use class attributes for sharing data between instances of a class. Any changes on a class attribute will be visible to all the instances of that class. Instance attributes are variables tied to a particular object of a given class. The value of an instance attribute is attached to the object itself. So, the attribute’s value is specific to its containing instance. Python lets you dynamically attach attributes to existing objects that you’ve already created. However, you most often define instance attributes inside instance methods, which are those methods that receive as their first argument. Note: Even though you can define instance attributes inside any instance method, it’s best to define all of them in the method, which is the instance initializer. This ensures that all of the attributes have consistent values when you create a new instance. Additionally, it makes the code more organized and easier to debug. Consider the following class, which defines a bunch of instance attributes: In this class, you define a total of seven instance attributes inside . The attributes , , , and take values from the arguments to , which are the arguments that you must pass to the class constructor, , to create concrete objects. Then, you explicitly initialize the attributes , , and with sensible values that don’t come from the user. Note: Inside a class, you must access all instance attributes through the argument. This argument holds a reference to the current instance, which is where the attributes belong and live. The argument plays a fundamental role in Python classes. You’ll learn more about in the section Instance Methods With . Here’s how your class works in practice: In these examples, you create two different instances of . Each instance takes specific input arguments at instantiation time to initialize part of its attributes. Note how the values of the associated attributes are different and specific to the concrete instance. Unlike class attributes, you can’t access instance attributes through the class. You need to access them through their containing instance: Instance attributes are specific to a concrete instance of a given class. So, you can’t access them through the class object. If you try to do that, then you get an exception. In Python, both classes and instances have a special attribute called . This attribute holds a dictionary containing the writable members of the underlying class or instance. Remember, these members can be attributes or methods. Each key in represents an attribute name. The value associated with a given key represents the value of the corresponding attribute. In a class, will contain class attributes and methods. In an instance, will hold instance attributes. When you access a class member through the class object, Python automatically searches for the member’s name in the class . If the name isn’t there, then you get an . Similarly, when you access an instance member through a concrete instance of a class, Python looks for the member’s name in the instance . If the name doesn’t appear there, then Python looks in the class . If the name isn’t found, then you get a . Here’s a toy class that illustrates how this mechanism works: In this class, you define a class attribute with a value of . In the method, you define an instance attribute that takes its value from the user’s input. Finally, you define a method to print both attributes. Now it’s time to check the content of in the class object. Go ahead and run the following code: The highlighted lines show that both the class attribute and the method are in the class dictionary. Note how you can use to access the value of class attributes by specifying the attribute’s name in square brackets, as you usually access keys in a dictionary. Note: You can access the same dictionary by calling the built-in function on your class or instance, as you did before. In instances, the dictionary will contain instance attributes only: The instance dictionary in this example holds and its specific value for the object at hand. Again, you can access any existing instance attribute using and the attribute name in square brackets. You can modify the instance dynamically. This means that you can change the value of existing instance attributes through , as you did in the final example above. You can even add new attributes to an instance using its dictionary. Using to change the value of instance attributes will allow you to avoid exceptions when you’re wiring descriptors in Python. You’ll learn more about descriptors in the Property and Descriptor-Based Attributes section. In Python, you can add new attributes to your classes and instances dynamically. This possibility allows you to attach new data and behavior to your classes and objects in response to changing requirements or contexts. It also allows you to adapt existing classes to specific and dynamic needs. For example, you can take advantage of this Python feature when you don’t know the required attributes of a given class at the time when you’re defining that class itself. Consider the following class, which aims to store a row of data from a database table or a CSV file: In this class, you haven’t defined any attributes or methods because you don’t know what data the class will store. Fortunately, you can add attributes and even methods to this class dynamically. For example, say that you’ve read a row of data from an file using . This class reads the data and returns it in a dictionary-like object. Now suppose that you have the following dictionary of data: Next, you want to add this data to an instance of your class, and you need to represent each data field as an instance attribute. Here’s how you can do it: In this code snippet, you first create an instance of called . Then you run a loop to iterate over the items of your dictionary of data, . Inside the loop, you use the built-in function to sequentially add each field as an attribute to your object. If you inspect , then you’ll note that it stores all the original data as attributes. You can also use dot notation and an assignment to add new attributes and methods to a class dynamically: Here, you first create a minimal class with no custom attributes or methods. To define the class’s body, you’ve just used a statement as a placeholder, which is Python’s way of doing nothing. Then you create an object called . Note how you can use dot notation and an assignment to add new attributes to the instance. In this example, you add and attributes with appropriate values. Then you provide the class with an initializer or method. In this method, you take the and arguments, which you turn into instance attributes in the method’s body. Then you add the method to dynamically. After this addition, you can create objects by passing the name and job to the class constructor. As you can conclude from the above example, you can construct an entire Python class dynamically. Even though this capability of Python may seem neat, you must use it carefully because it can make your code difficult to understand and reason about. Python allows you to add function-like behavior on top of existing instance attributes and turn them into managed attributes. This type of attribute prevents you from introducing breaking changes into your APIs. In other words, with managed attributes, you can have function-like behavior and attribute-like access at the same time. You don’t need to change your APIs by replacing attributes with method calls, which can potentially break your users’ code. To create a managed attribute with function-like behavior in Python, you can use either a property or a descriptor, depending on your specific needs. Note: To dive deeper into Python properties, check out Python’s : Add Managed Attributes to Your Classes. As an example, get back to your class and say that you need to validate the radius to ensure that it only stores positive numbers. How would you do that without changing your class interface? The quickest approach to this problem is to use a property and implement the validation logic in the setter method. Here’s what your new version of can look like: To turn an existing attribute like into a property, you typically use the decorator to write the getter method. The getter method must return the value of the attribute. In this example, the getter returns the circle’s radius, which is stored in the non-public attribute. Note: The pipe sign ( ) in the call to expresses union types. You can use this syntax in Python 3.10 or greater. If you’re using a lower version of Python, then you can use a tuple of types . To define the setter method of a property-based attribute, you need to use the decorator . In the example, you use . Then you need to define the method itself. Note that property setters need to take an argument providing the value that you want to store in the underlying attribute. Inside the setter method, you use a conditional to check whether the input value is an integer or a floating-point number. You also check if the value is less than or equal to . If either is true, then you raise a with a descriptive message about the actual issue. Finally, you assign to and that’s it. Now, is a property-based attribute. Here’s an example of this new version of in action: The first instance of in this example takes a valid value for its radius. Note how you can continue working with as a regular attribute rather than as a method. If you try to assign an invalid value to , then you get a exception. Note: Remember to reload the module if you’re working on the same REPL session as before. This recommendation will also be valid for all the examples in this tutorial where you change modules that you defined in previous examples. It’s important to note that the validation also runs at instantiation time when you call the class constructor to create new instances of . This behavior is consistent with your validation strategy. Using a descriptor to create managed attributes is another powerful way to add function-like behavior to your instance attributes without changing your APIs. Like properties, descriptors can also have getter, setter, and other types of methods. Note: To learn more about descriptors and how to use them, check out Python Descriptors: An Introduction. To explore how descriptors work, say that you’ve decided to continue creating classes for your drawing application, and now you have the following class: This class uses the same pattern as your class. Instead of using , the class takes a argument and computes the area using the appropriate expression for a square. This class is pretty similar to , and the repetition starts looking odd. Then you think of using a descriptor to abstract away the validation process. Here’s what you come up with: The first thing to notice in this example is that you moved all the classes to a file. In that file, you define a descriptor class called by implementing the and special methods, which are part of the descriptor protocol. Next, you remove the property from and the property from . In , you add a class attribute, which holds an instance of . You do something similar in , but the class attribute is appropriately named . Here are a few examples of how your classes work now: Python descriptors provide a powerful tool for adding function-like behavior on top of your instance attributes. They can help you remove repetition from your code, making it cleaner and more maintainable. They also promote code reuse. In a Python class, using the attribute can help you reduce the memory footprint of the corresponding instances. This attribute prevents the automatic creation of an instance . Using is particularly handy when you have a class with a fixed set of attributes, and you’ll use that class to create a large number of objects. In the example below, you have a class with a attribute that consists of a tuple of allowed attributes. Each attribute will represent a Cartesian coordinate: This class defines as a tuple with two items. Each item represents the name of an instance attribute. So, they must be strings holding valid Python identifiers. Note: Although can hold a object, you should use a object instead. Even if changing the list in after processing the class body had no effect, it’d be misleading to use a mutable sequence there. Instances of your class don’t have a , as the code shows. This feature makes them memory-efficient. To illustrate this efficiency, you can measure the memory consumption of an instance of . To do this, you can use the Pympler library, which you can install from PyPI using the command. Once you’ve installed Pympler with , then you can run the following code in your REPL: The function from Pympler says that the object occupies 112 bytes in your computer’s memory. Now get back to your REPL session and redefine without providing a attribute. With this update in place, go ahead and run the memory check again: The same object, , now consumes 528 bytes of memory. This number is over four times greater than what you got with the original implementation of . Imagine how much memory would save if you had to create a million points in your code. The attribute adds a second interesting behavior to your custom classes. It prevents you from adding new instance attributes dynamically: Adding a to your classes allows you to provide a series of allowed attributes. This means that you won’t be able to add new attributes to your instances dynamically. If you try to do it, then you’ll get an exception. A word of caution is in order, as many of Python’s built-in mechanisms implicitly assume that objects have the attribute. When you use , then you waive that assumption, which means that some of those mechanisms might not work as expected anymore.\n\nPython classes allow you to bundle data and behavior together in a single entity through attributes and methods, respectively. You’ll use the data to define the object’s current state and the methods to operate on that data or state. A method is just a function that you define inside a class. By defining it there, you make the relationship between the class and the method explicit and clear. Because they’re just functions, methods can take arguments and return values as functions do. However, the syntax for calling a method is a bit different from the syntax for calling a function. To call a method, you need to specify the class or instances in which that method is defined. To do this, you need to use dot notation. Remember that classes are namespaces, and their members aren’t directly accessible from the outside. In a Python class, you can define three different types of methods:\n• Instance methods, which take the current instance, , as their first argument\n• Class methods, which take the current class, , as their first argument\n• Static methods, which take neither the instance nor the class as an argument Every type of method has its own characteristics and specific use cases. Instance methods are, by far, the most common methods that you’ll use in your custom Python classes. Note: To learn more about instance, class, and static methods, check out Python’s Instance, Class, and Static Methods Demystified. In the following sections, you’ll dive into how each of these methods works and how to create them in your classes. To get started, you’ll begin with instance methods, which are the most common methods that you’ll define in your classes. In a class, an instance method is a function that takes the current instance as its first argument. In Python, this first argument is called by convention. Note: Naming the current instance is a strong convention in Python. It’s so strong that it may look like is one of the Python keywords. However, you could use any other name instead of . Even though it’s possible to use any name for the first argument of an instance method, using is definitely the right choice because it’ll make your code look like Python code in the eyes of other developers. The argument holds a reference to the current instance, allowing you to access that instance from within methods. More importantly, through , you can access and modify the instance attributes and call other methods within the class. To define an instance method, you just need to write a regular function that accepts as its first argument. Up to this point, you’ve already written some instance methods. To continue learning about them, turn back to your class. Now say that you want to add methods to start, stop, accelerate, and brake the car. To kick things off, you’ll begin by writing the and methods: The and methods are pretty straightforward. They take the current instance, , as their first argument. Inside the methods, you use to access the attribute on the current instance using dot notation. Then you change the current value of this attribute to in and to in . Both methods print informative messages to illustrate what your car is doing. Note: Instance methods should act on instance attributes by either accessing them or changing their values. If you find yourself writing an instance method that doesn’t use in its body, then that may not be an instance method. In this case, you should probably use a class method or a static method, depending on your specific needs. Now you can add the and methods, which will be a bit more complex: The method takes an argument that represents the increment of speed that occurs when you call the method. For simplicity, you haven’t set any validation for the input increment of speed, so using negative values can cause issues. Inside the method, you first check whether the car’s engine is started, returning immediately if it’s not. Then you check if the incremented speed is less than or equal to the allowed maximum speed for your car. If this condition is true, then you increment the speed. Otherwise, you set the speed to the allowed limit. The method works similarly. This time, you compare the decremented speed to because cars can’t have a negative speed. If the condition is true, then you decrement the speed according to the input argument. Otherwise, you set the speed to its lower limit, . Again, you have no validation on the input decrement of speed, so be careful with negative values. Your class now has four methods that operate on and with its attributes. It’s time for a drive: Great! Your class works nicely! You can start your car’s engine, increment the speed, brake, and stop the car’s engine. You’re also confident that no one can increment the car’s speed if the car’s engine is stopped. How does that sound for minimal modeling of a car? It’s important to note that when you call an instance method on a concrete instance like using dot notation, you don’t have to provide a value for the argument. Python takes care of that step for you. It automatically passes the target instance to . So, you only have to provide the rest of the arguments. However, you can manually provide the desired instance if you want. To do this, you need to call the method on the class: In this example, you call instance methods directly on the class. For this type of call to work, you need to explicitly provide an appropriate value to the argument. In this example, that value is the instance. Note that if you don’t provide a suitable instance, then the call fails with a . The error message is pretty clear. There’s a missing positional argument, . Python supports what it calls special methods, which are also known as dunder or magic methods. These methods are typically instance methods, and they’re a fundamental part of Python’s internal class mechanism. They have an important feature in common: Python calls them automatically in response to specific operations. Python uses these methods for many different tasks. They provide a great set of tools that will allow you to unlock the power of classes in Python. You’ll recognize special methods because their names start and end with a double underscore, which is the origin of their other name, dunder methods (double underscore). Arguably, is the most common special method in Python classes. As you already know, this method works as the instance initializer. Python automatically calls it when you call a class constructor. Note: To dive deeper into special methods, check out the Python’s Magic Methods: Leverage Their Power in Your Classes tutorial. You’ve already written a couple of methods. So, you’re ready to learn about other common and useful special methods. For example, the and methods provide string representations for your objects. Go ahead and update your class to add these two methods: The method provides what’s known as the informal string representation of an object. This method must return a string that represents the object in a user-friendly manner. You can access an object’s informal string representation using either or . The method is similar, but it must return a string that allows you to re-create the object if possible. So, this method returns what’s known as the formal string representation of an object. This string representation is mostly targeted at Python programmers, and it’s pretty useful when you’re working in an interactive REPL session. In interactive mode, Python falls back to calling when you access an object or evaluate an expression, issuing the formal string representation of the resulting object. In script mode, you can access an object’s formal string representation using the built-in function. Run the following code to give your new methods a try. Remember that you need to restart your REPL or reload : When you use an instance of as an argument to or , you get a user-friendly string representation of the car at hand. This informal representation comes in handy when you need your programs to present your users with information about specific objects. If you access an instance of directly in a REPL session, then you get a formal string representation of the object. You can copy and paste this representation to re-create the object in an appropriate environment. That’s why this string representation is intended to be useful for developers, who can take advantage of it while debugging and testing their code. Python protocols are another fundamental topic that’s closely related to special methods. Protocols consist of one or more special methods that support a given feature or functionality. Common examples of protocols include: Allows you to create iterator objects Enables an object to work on statements Of course, Python has many other protocols that support cool features of the language. You already coded an example of using the descriptor protocol in the Property and Descriptor-Based Attributes section. Here’s an example of a minimal class that implements the iterable protocol: This class takes three arguments representing the space coordinates of a given point. The method is a generator function that returns an iterator. The resulting iterator yields the coordinates of on demand. The call to iterates over the attributes , , and , returning a object. You don’t need to call directly. Python calls it automatically when you use an instance of in an iteration. You can also add class methods to your custom Python classes. A class method is a method that takes the class object as its first argument instead of taking . In this case, the argument should be called , which is also a strong convention in Python. So, you should stick to it. You can create class methods using the decorator. Providing your classes with multiple constructors is one of the most common use cases of class methods in Python. For example, say you want to add an alternative constructor to your so that you can quickly create points from tuples or lists of coordinates: In the class method, you take a sequence of coordinates as an argument, create a object from it, and return the object to the caller. To create the new object, you use the argument, which holds an implicit reference to the current class, which Python injects into your method automatically. In this example, you use the class directly to access the class method . Note that you can also access the method using a concrete instance, like in the example. In each of the calls to , you’ll get a completely new instance of . However, class methods should be accessed through the corresponding class name for better clarity and to avoid confusion. Your Python classes can also have static methods. These methods don’t take the instance or the class as an argument. So, they’re regular functions defined within a class. You could’ve also defined them outside the class as stand-alone function. You’ll typically define a static method instead of a regular function outside the class when that function is closely related to your class, and you want to bundle it together for convenience or for consistency with your code’s API. Remember that calling a function is a bit different from calling a method. To call a method, you need to specify a class or object that provides that method. If you want to write a static method in one of your custom classes, then you need to use the decorator. Check out the method below: ! This is your 3D Point!\" The static method takes a as an argument and prints a message on the screen. Note that this is only a toy example of how to write static methods in your classes. Static methods like don’t operate on the current instance, , or the current class, . They work as independent functions enclosed in a class. You’ll typically put them inside a class when they’re closely related to that class but don’t necessarily affect the class or its instances. Hey Pythonista! This is your 3D Point! Hey Python developer! This is your 3D Point! As you already know, the method takes a name as an argument and prints a message to your screen. Note that you can call the method using the class or any of its instances. As with class methods, you should generally call static methods through the corresponding class instead of one of its instances. Programming languages like Java and C++ don’t expose attributes as part of their classes’ public APIs. Instead, these programming languages make extensive use of getter and setter methods to give you access to attributes. Note: To dive deeper into the getter and setter pattern and how Python approaches it, check out Getters and Setters: Manage Attributes in Python. Using methods to access and update attributes promotes encapsulation. Encapsulation is a fundamental OOP principle that recommends protecting an object’s state or data from the outside world, preventing direct access. The object’s state should only be accessible through a public interface consisting of getter and setter methods. For example, say that you have a class with a instance attribute. You can make a non-public attribute and provide getter and setter methods to access and change that attribute: In this example, is the getter method and allows you to access the underlying attribute. Similarly, is the setter method and allows you to change the current value of . The attribute is non-public and is where the actual data is stored. Here’s how you can use your class: Here, you create an instance of using the class constructor and as the required name. That means you can use the method to access Jane’s name and the method to update it. The getter and setter pattern is common in languages like Java and C++. Besides promoting encapsulation and APIs centered on method calls, this pattern also allows you to quickly add function-like behavior to your attributes without introducing breaking changes in your APIs. However, this pattern is less popular in the Python community. In Python, it’s completely normal to expose attributes as part of an object’s public API. If you ever need to add function-like behavior on top of a public attribute, then you can turn it into a property instead of breaking the API by replacing the attribute with a method. Here’s how most Python developers would write the class: This class doesn’t have getter and setter methods for the attribute. Instead, it exposes the attribute as part of its API. So, you can use it directly: In this example, instead of using a setter method to change the value of , you use the attribute directly in an assignment statement. This is common practice in Python code. If your class evolves to a point where you need to add function-like behavior on top of , then you can turn the attribute into a property. For example, say that you need to store the attribute in uppercase letters. Then you can do something like the following: This class defines as a property with appropriate getter and setter methods. Python will automatically call these methods, respectively, when you access or update the attribute’s value. The setter method takes care of uppercasing the input value before assigning it back to : Python properties allow you to add function-like behavior to your attributes while you continue to use them as normal attributes instead of as methods. Note how you can still assign new values to using an assignment instead of a method call. Running the assignment triggers the setter method, which uppercases the input value.\n\nIn the Python standard library, you’ll find many tools that solve different problems and deal with different challenges. Among all these tools, you’ll find a few that will make you more productive when writing custom classes. For example, if you want a tool that saves you from writing a lot of class-related boilerplate code, then you can take advantage of data classes and the module. Similarly, if you’re looking for a tool that allows you to quickly create class-based enumerations of constants, then you can turn your eye to the module and its different types of enumeration classes. In the following sections, you’ll learn the basics of using data classes and enumerations to efficiently write robust, reliable, and specialized classes in Python. Python’s data classes specialize in storing data. However, they’re also code generators that produce a lot of class-related boilerplate code for you behind the scenes. For example, if you use the data class infrastructure to write a custom class, then you won’t have to implement special methods like , , , and . The data class will write them for you. More importantly, the data class will write these methods applying best practices and avoiding potential errors. Note: To learn more about data classes in Python, check out the Data Classes in Python 3.7+ (Guide) tutorial. As you already know, special methods support important functionalities in Python classes. In the case of data classes, you’ll have accurate string representation, comparison capabilities, hashability, and more. Even though the name data class may suggest that this type of class is limited to containing data, it can also contain methods. So, data classes are like regular classes but with superpowers. To create a data class, go ahead and import the decorator from the module. You’ll use this decorator in the definition of your class. This time, you won’t write an method. You’ll just define data fields as class attributes with type hints. For example, here’s how you can write the class as a data class: ! This is your 3D Point!\" This new implementation of uses Python’s decorator to turn the regular class into a data class. Instead of defining an method, you list the attributes with their corresponding types. The data class will take care of writing a proper initializer for you. Note that you don’t define or either. Note: Data classes are pretty flexible when it comes to defining their fields or attributes. You can declare them with the type annotation syntax. You can initialize them with a sensible default value. You can also combine both approaches depending on your needs: In this code snippet, you declare the first attribute using the type annotation syntax. The second attribute has a default value with no type annotation. Finally, the third attribute has both type annotation and a default value. However, when you don’t specify a type hint for an attribute, then Python won’t automatically generate the corresponding code for that attribute. Once you’ve defined the data fields or attributes, you can start adding methods. In this example, you keep the class method and the static method. Go ahead and run the following code to check the additional functionality that has added to this version of : Your class works pretty well! It provides a suitable string representation with an automatically generated method. You can iterate over the fields using the function from the module. Finally, you can compare two instances of the class for equality ( ). As you can conclude, this new version of has saved you from writing several lines of tricky boilerplate code. An enumeration, or just enum, is a data type that you’ll find in several programming languages. Enums allow you to create sets of named constants, which are known as members and can be accessed through the enumeration itself. Python doesn’t have a built-in enum data type. However, Python 3.4 introduced the module to provide the class for supporting general-purpose enumerations. Days of the week, months and seasons of the year, HTTP status codes, colors in a traffic light, and pricing plans of a web service are all great examples of constants that you can group in an enum. In short, you can use enums to represent variables that can take one of a limited set of possible values. The class, among other similar classes in the module, allows you to quickly and efficiently create custom enumerations or groups of similar constants with neat features that you don’t have to code yourself. Apart from member constants, enums can also have methods to operate with those constants. Note: To learn more about how to create and use enumerations in your Python code, check out the Build Enumerations of Constants With Python’s Enum tutorial. To define a custom enumeration, you can subclass the class. Here’s an example of an enumeration that groups the days of the week: In this code example, you define by subclassing from the module. This specific enum groups seven constants representing the days of the week. These constants are the enum members. Because they’re constants, you should follow the convention for naming any constant in Python: uppercase letters and underscores between words, if applicable. Enumerations have a few cool features that you can take advantage of. For example, their members are strict constants, so you can’t change their values. They’re also iterable by default: If you try to change the value of an enum member, then you get an . So, enum members are strictly constants. You can iterate over the members directly because enumerations support iteration by default. You can directly access their members using different syntax: In the first example, you access an enum member using dot notation, which is pretty intuitive and readable. In the second example, you access a member by calling the enumeration with that member’s value as an argument. Finally, you use a dictionary-like syntax to access another member by name. If you want fine-grain access to a member’s components, then you can use the and attributes: In these examples, you access the and attributes of specific members of . These attributes provide access to each member’s component. Finally, you can also add custom behavior to your enumerations. To do that, you can use methods as you’d do with regular classes: After saving your code to , you add a class method called to your enumeration. This method will just return your favorite day of the week, which is Friday, of course! Then you add a method to provide a user-friendly string representation for the current day. Here’s how you can use these methods in your code: You’ve added new functionality to your enumeration through class and instance methods. Isn’t that cool?\n\nInheritance is a powerful feature of object-oriented programming. It consists of creating hierarchical relationships between classes, where child classes inherit attributes and methods from their parent class. In Python, one class can have multiple parents or, more broadly, ancestors. This is known as implementation inheritance, which allows you to reduce duplication and repetition by code reuse. It can also make your code more modular, better organized, and more scalable. However, classes also inherit the interface by becoming more specialized kinds of their ancestors. In some cases, you’ll be able to use a child instance where an ancestor is expected. In the following sections, you’ll learn how to use inheritance in Python. You’ll start with simple inheritance and continue with more complex concepts. So, get ready! This is going to be fun! When you have a class that inherits from a single parent class, then you’re using single-base inheritance or just simple inheritance. To make a Python class inherit from another, you need to list the parent class’s name in parentheses after the child class’s name in the definition. Here’s the syntax that you must use: In this code snippet, is the class you want to inherit from. Parent classes typically provide generic and common functionality that you can reuse throughout multiple child classes. is the class that inherits attributes and methods from . The highlighted line shows the required syntax. Note: In this tutorial, you’ll use the terms parent class, superclass, and base class interchangeably to refer to the class that you inherit from. Similarly, you’ll use the terms child class, derived class, and subclass to refer to classes that inherit from other classes. Here’s a practical example to get started with simple inheritance and how it works. Suppose you’re building an app to track vehicles and routes. At first, the app will track cars and motorcycles. You think of creating a class and deriving two subclasses from it. One subclass will represent a car, and the other will represent a motorcycle. The class will provide common attributes, such as , , and . It’ll also provide the and methods to start and stop the vehicle engine, respectively: In this code, you define the class with attributes and methods that will be common to all your vehicle types. You can say that provides the common interface of all your vehicles. You’ll inherit from this class to reuse this interface and its functionality in your subclasses. Now you can define the and classes. Both of them will have some unique attributes and methods specific to the vehicle type. For example, the will have a attribute and a method: Your class uses as its parent class. This means that will automatically inherit the , , and attributes, as well as the non-public attribute. It’ll also inherit the and methods. Note: Like inheritance in biology, inheritance in OOP goes in a single direction, from the parents to the children. In other words, children inherit from their parents and not the other way around. The class defines a attribute. As you already know, you should define and initialize instance attributes in . This requires you to provide a custom method in , which will shadow the superclass initializer. How can you write an method in and still guarantee that you initialize the , , and attributes? That’s where the built-in function comes on the scene. This function allows you to access members in the superclass, as its name suggests. Note: To learn more about using in your classes, check out Supercharge Your Classes With Python . In , you use to call the method on . Note that you pass the input values for , , and so that can initialize these attributes correctly. After this call to , you add and initialize the attribute, which is specific to the class. Finally, you write the method, which is also specific to . This method is just a demonstrative example, so it only prints a message to your screen. Now it’s time to define the class, which will inherit from too. This class will have a attribute and a method: Again, you call to initialize , , and . After that, you define and initialize the attribute. Finally, you write the method. Again, this method is just a demonstrative example. With this code in place, you can start using and right away: Driving my \"Tesla - Model S\" on the road Riding my \"Harley-Davidson - Iron 883\" on the road. Cool! Your Tesla and your Harley-Davidson work nicely. You can start their engines, drive or ride them, and so on. Note how you can use both the inherited and specific attributes and methods in both classes. You’ll typically use single inheritance or inheritance in general when you have classes that share common attributes and behaviors and want to reuse them in derived classes. So, inheritance is a great tool for code reuse. Subclasses will inherit and reuse functionality from their parent. Subclasses will frequently extend their parent’s interface with new attributes and methods. You can use them as a new starting point to create another level of inheritance. This practice will lead to the creation of class hierarchies. Using inheritance, you can design and build class hierarchies, also known as inheritance trees. A class hierarchy is a set of closely related classes that are connected through inheritance and arranged in a tree-like structure. The class or classes at the top of the hierarchy are the base classes, while the classes below are derived classes or subclasses. Inheritance-based hierarchies express an is-a-type-of relationship between subclasses and their base classes. For example, a bird is a type of animal. Each level in the hierarchy will inherit attributes and behaviors from the above levels. Therefore, classes at the top of the hierarchy are generic classes with common functionality, while classes down the hierarchy are more specialized. They’ll inherit attributes and behaviors from their superclasses and will also add their own. Taxonomic classification of animals is a commonly used example to explain class hierarchies. In this hierarchy, you’ll have a generic class at the top. Below this class, you can have subclasses like , , , and so on. These subclasses are more specific classes than and inherit the attributes and methods from it. They can also have their own attributes and methods. To continue with the hierarchy, you can subclass , , and and create derived classes with even more specific characteristics. Here’s a short toy implementation of this example: At the top of the hierarchy, you have the class. This is the base class of your hierarchy. It has the , , and attributes, which will be string objects. These attributes are common to all animals. Then you define the , , and classes by inheriting from . These classes have a class attribute that holds the distinguishing characteristic of each group of animals. Then you create concrete mammals like and . These classes have specific methods that are common to all dogs and cats, respectively. Similarly, you define two classes that inherit from and two more that inherit from . Here’s a tree-like class diagram that will help you see the hierarchical relationship between classes: Each level in the hierarchy can—and typically will—add new attributes and functionality on top of those that its parents already provide. If you walk through the diagram from top to button, then you’ll move from generic to specialized classes. These latter classes implement new methods that are specific to the class at hand. In this example, the methods just print some information to the screen and automatically return , which is the null value in Python. Note: You can create class diagrams to represent class hierarchies that are based on inheritance. However, that’s not the only relationship that can appear between your classes. With class diagrams, you can also represent other types of relationships, including the following:\n• Composition expresses a strong has-a relationship. For example, a robot has an arm. If the robot stops existing, then the arm stops existing too.\n• Aggregation expresses a softer has-a relationship. For example, a university has an instructor. If the university stops existing, the instructor doesn’t stop existing.\n• Association expresses a uses-a relationship. For example, a student may be associated with a course. They will use the course. This relationship is common in database systems where you have one-to-one, one-to-many, and many-to-many associations. You’ll learn more about some of these types of relationships in the section called Using Alternatives to Inheritance. That’s how you design and create class hierarchies to reuse code and functionality. Such hierarchies also allow you to give your code a modular organization, making it more maintainable and scalable. When you’re using inheritance, you can face an interesting and challenging issue. In some situations, a parent class may provide a given functionality only at a basic level, and you may want to extend that functionality in your subclasses. In other situations, the feature in the parent class isn’t appropriate for the subclass. In these situations, you can use one of the following strategies, depending on your specific case:\n• Extending an inherited method in a subclass, which means that you’ll reuse the functionality provided by the superclass and add new functionality on top\n• Overriding an inherited method in a subclass, which means that you’ll completely discard the functionality from the superclass and provide new functionality in the subclass Here’s an example of a small class hierarchy that applies the first strategy to provide extended functionality based on the inherited one: In this example, you define as the base class. In , you create a few instance attributes. Then you define the method, which prints information about the aircraft’s technical specifications. Next, you define , inheriting from . The method of extends the corresponding method of by calling to initialize the , , and attributes. You already saw something like this in the previous section. also extends the functionality of . In this case, you first call from using . Then you add a new call to that adds new information to the technical description of the helicopter at hand. When you call on a instance, you get the information provided by the base class, , and also the specific information added by itself. You’ve extended the functionality of in its subclass . Now it’s time to take a look at how you can override a method in a subclass. As an example, say that you have a base class called that defines several attributes and methods like in the following example: In this class, you define a few instance attributes to store important data about the current worker. You also provide the method to display relevant information about the worker. Finally, you write a generic method to compute the salary of workers from their hourly salary and the number of hours worked. Later in the development cycle, some requirements change. Now you realize that managers compute their salaries in a different way. They’ll have an hourly bonus that you must add to the normal hourly salary before computing the final amount. After thinking a bit about the problem, you decide that has to override completely. Here’s the implementation that you come up with: In the initializer, you take the hourly bonus as an argument. Then you call the parent’s method as usual and define the instance attribute. Finally, you override with a completely different implementation that doesn’t reuse the inherited functionality. In Python, you can use multiple inheritance. This type of inheritance allows you to create a class that inherits from several parent classes. The subclass will have access to attributes and methods from all its parents. Multiple inheritance allows you to reuse code from several existing classes. However, you must manage the complexity of multiple inheritance with care. Otherwise, you can face issues like the diamond problem. You’ll learn more about this topic in the Method Resolution Order (MRO) section. Here’s a small example of multiple inheritance in Python: In this example, you write a class with , , and attributes. The class also has the , , and methods. Then you create a class that inherits from and extends it with a new method called . You also create an class that inherits from and adds a method. Finally, you define a class to represent a car that you can drive on the road or fly in the sky. Isn’t that cool? Note that this class includes both and in its list of parent classes. So, it’ll inherit functionality from both superclasses. Here’s how you can use the class: In this code snippet, you first create an instance of . Then you call all its methods, including the inherited ones. As you can see, multiple inheritance promotes code reuse, allowing you to use functionality from several base classes at the same time. By the way, if you get this to really fly, then make sure you don’t stop the engine while you’re flying! When you’re using multiple inheritance, you can face situations where one class inherits from two or more classes that have the same base class. This is known as the diamond problem. The real issue appears when multiple parents provide specific versions of the same method. In this case, it’d be difficult to determine which version of that method the subclass will end up using. Python deals with this issue using a specific method resolution order (MRO). So, what is the method resolution order in Python? It’s an algorithm that tells Python how to search for inherited methods in a multiple inheritance context. Python’s MRO determines which implementation of a method or attribute to use when there are multiple versions of it in a class hierarchy. Python’s MRO is based on the order of parent classes in the subclass definition. For example, comes before in the class from the previous section. MRO also considers the inheritance relationships between classes. In general, Python searches for methods and attributes in the following order:\n• The superclass listed next, from left to right, up to the last superclass It’s important to note that the current class comes first in the search. Additionally, if you have multiple parents that implement a given method or attributes, then Python will search them in the same order that they’re listed in the class definition. To illustrate the MRO, consider the following sample class hierarchy: In this example, inherits from and , which inherit from . All the superclasses in the hierarchy define a different version of . Which of these versions will end up calling? To answer this question, go ahead and call on a instance: When you call on an instance of , you get on your screen. This means that Python found on the class first. That’s the version of that you end up calling. You ignore the versions from and . Note: Sometimes, you may run into complex inheritance relationships where Python won’t be able to create a consistent method resolution order. In those cases, you’ll get a pointing out the issue. You can check the current MRO of a given class by using the special attribute: In this output, you can see that Python searches for methods and attributes in by going through itself, then , then , then , and finally, , which is the base class of all Python classes. The attribute can help you tweak your classes and define the specific MRO that you want your class to use. The way to tweak this is by moving and reordering the parent classes in the subclass definition until you get the desired MRO. A mixin class provides methods that you can reuse in many other classes. Mixin classes don’t define new types, so they’re not intended to be instantiated but only inherited. You use their functionality to attach extra features to other classes quickly. You can access the functionality of a mixin class in different ways. One of these ways is inheritance. However, inheriting from mixin classes doesn’t imply an is-a relationship because these classes don’t define concrete types. They just bundle specific functionality that’s intended to be reused in other classes. To illustrate how to use mixin classes, say that you’re building a class hierarchy with a class at the top. From this class, you’ll derive classes like , , , and several others. Then you realize that all the subclasses of need methods that serialize their data into different formats, including JSON and pickle. With this in mind, you think of writing a class that takes care of this task. Here’s what you come up with: In this example, is the parent class, and is a mixin class that provides serialization functionality. The class inherits from both and . Therefore, it’ll inherit the and methods, which you can use to serialize instances of in your code. In this example, is a . However, it’s not a because this class doesn’t define a type of object. It’s just a mixin class that packs serialization capabilities. Note: Because of the method resolution order (MRO), which you learned about earlier, placing your mixin classes before the base classes on the list of parents is often necessary. It’s especially true for class-based views in the Django web framework, which uses mixins to modify the behavior of a base view class. Now your class is able to serialize its data using JSON and pickle formats. That’s great! Can you think of any other useful mixin classes? Up to this point, you’ve learned a lot about simple and multiple inheritance in Python. In the following section, you’ll go through some of the advantages of using inheritance when writing and organizing your code. Inheritance is a powerful tool that you can use to model and solve many real-world problems in your code. Some benefits of using inheritance include the following:\n• Reusability: You can quickly inherit and reuse working code from one or more parent classes in as many subclasses as you need.\n• Modularity: You can use inheritance to organize your code in hierarchies of related classes.\n• Maintainability: You can quickly fix issues or add features to a parent class. These changes will be automatically available in all its subclasses. Inheritance also reduces code duplication.\n• Polymorphism: You can create subclasses that can replace their parent class, providing the same or equivalent functionality.\n• Extensibility: You can quickly extend an exiting class by adding new data and behavior to its subclasses. You can also use inheritance to define a uniform API for all the classes that belong to a given hierarchy. This promotes consistency and leverages polymorphism. Using classes and inheritance, you can make your code more modular, reusable, and extensible. Inheritance enables you to apply good design principles, such as separation of concerns. This principle states that you should organize code in small classes that each take care of a single task. Even though inheritance comes with several benefits, it can also end up causing issues. If you overuse it or use it incorrectly, then you can:\n• Artificially increase your code’s complexity with multiple inheritance or multiple levels of inheritance\n• Face issues like the diamond problem where you’ll have to deal with the method resolution order\n• End up with fragile base classes where changes to a parent class produce unexpected behaviors in subclasses Of course, these aren’t the only potential pitfalls. For example, having multiple levels of inheritance can make your code harder to reason about, which may impact your code’s maintainability in the long term. Another drawback of inheritance is that inheritance is defined at compile time. So, there’s no way to change the inherited functionality at runtime. Other techniques, like composition, allow you to dynamically change the functionality of a given class by replacing its components.\n\nInheritance, and especially multiple inheritance, can be a complex and hard-to-grasp topic. Fortunately, inheritance isn’t the only technique that allows you to reuse functionality in object-oriented programming. You also have composition, which represents a has-a relationship between classes. Composition allows you to build an object from its components. The composite object doesn’t have direct access to each component’s interface. However, it can leverage each component’s implementation. Delegation is another technique that you can use to promote code reuse in your OOP code. With delegation, you can represent can-do relationships, where an object relies on another object to perform a given task. In the following sections, you’ll learn more about these techniques and how they can make your object-oriented code more robust and flexible. As you’ve already learned, you can use composition to model a has-a relationship between objects. In other words, through composition, you can create complex objects by combining objects that will work as components. Note that these components may not make sense as stand-alone classes. Favoring composition over inheritance leads to more flexible class designs. Unlike inheritance, composition is defined at runtime, which means that you can dynamically replace a current component with another component of the same type. This characteristic makes it possible to change the composite’s behavior at runtime. In the example below, you use composition to create an class from the and components: In this example, you build an class out of its components, and . The class provides horizontal movements, while the class represents the robot’s arm and provides vertical movement and welding functionality. Here’s how you can use in your code: Rotating body 20 degrees to the right... Great! Your robot works as expected. It allows you to move its body and arm according to your movement needs. It also allows you to weld different mechanical pieces together. An idea to make this robot even cooler is to implement several types of arms with different welding technologies. Then you can change the arm by doing something like . You can even add a method to your robot class. How does that sound as a learning exercise? Unlike inheritance, composition doesn’t expose the entire interface of components, so it preserves encapsulation. Instead, the composite objects access and use only the required functionality from their components. This characteristic makes your class design more robust and reliable because it won’t expose unneeded members. Following the robot example, say you have several different robots in a factory. Each robot can have different capabilities like welding, cutting, shaping, polishing, and so on. You also have several independent arms. Some of them can perform all those actions. Some of them can perform just a subset of the actions. Now say that a given robot can only weld. However, this robot can use different arms with different welding technologies. If you use inheritance, then the robot will have access to other operations like cutting and shaping, which can cause an accident or breakdown. If you use composition, then the welder robot will only have access to the arm’s welding feature. That said, composition can help you protect your classes from unintended use. Delegation is another technique that you can use as an alternative to inheritance. With delegation, you can model can-do relationships, where an object hands a task over to another object, which takes care of executing the task. Note that the delegated object can exist independently from the delegator. You can use delegation to achieve code reuse, separation of concerns, and modularity. For example, say that you want to create a stack data structure. You think of taking advantage of Python’s as a quick way to store and manipulate the underlying data. Here’s how you end up writing your class: In , you define a object called that can take its initial data from the argument. You’ll use this list to store the data in the containing , so you delegate all the operations related to storing, adding, and deleting data to this list object. Then you implement the typical operations, and . Note how these operations conveniently delegate their responsibilities on and , respectively. Your class has handed its operations over to the object, which already knows how to perform them. It’s important to notice that this class is pretty flexible. You can replace the list object in with any other object as long as it implements the and methods. For example, you can use a object from the module. Because you’ve used delegation to write your class, the internal implementation of isn’t visible or directly accessible in , which preserves encapsulation: The public interface of your class only contains the stack-related methods and , as you can see in the function’s output. This prevents the users of your class from using list-specific methods that aren’t compatible with the classic stack data structure. If you use inheritance, then your child class, , will inherit all the functionality from its parent class, : In this example, your class has inherited all the methods from . These methods are exposed as part of your class’s public API, which may lead to incorrect uses of the class and its instances. With inheritance, the internals of parent classes are visible to subclasses, which breaks encapsulation. If some of the parent’s functionality isn’t appropriate for the child, then you run the risk of incorrect use. In this situation, composition and delegation are safer options. Note: To learn more about creating custom list-like classes, check out the Custom Python Lists: Inheriting From vs tutorial. Finally, in Python, you can quickly implement delegation through the special method. Python calls this method automatically whenever you access an instance attribute or method. You can use this method to redirect the request to another object that can provide the appropriate method or attribute. To illustrate this technique, get back to the mixin example where you used a mixin class to provide serialization capabilities to your class. Here’s how to rewrite the example using delegation: In this new implementation, the serializer class takes the instance that provides the data as an argument. defines a method that uses the built-in function to access the methods in the class. For example, if you call on an instance of , then that call will be automatically redirected to calling on the instance of . Go ahead and try it out! This is a pretty cool Python feature. You’ve tried your hand at a quick example of delegation in Python to learn how a class can delegate some of its responsibilities to another class, achieving code reuse and separation of concerns. Again, you should note that this technique indirectly exposes all the delegated attributes and methods. So, use it with care. Dependency injection is a design pattern that you can use to achieve loose coupling between a class and its components. With this technique, you can provide an object’s dependencies from the outside, rather than inheriting or implementing them in the object itself. This practice allows you to create flexible classes that are able to change their behavior dynamically, depending on the injected functionality. In your robot example, you can use dependency injection to decouple the and classes from , which will make your code more flexible and versatile. In this new version of , you only made two small changes to . Now this method takes and as arguments and assigns their values to the corresponding instance attributes, and . This allows you to inject appropriate body and arm objects into the class so that it can do its work. Here’s how you can use with this new implementation: Rotating body 20 degrees to the right... Overall, the class’s functionality remains the same as in your first version. The only difference is that now you have to pass the body and arm objects to the class constructor. This step is a common way of implementing dependency injection. Now that you know about a few techniques that you can use as alternatives to inheritance, it’s time for you to learn about abstract base classes (ABCs) in Python. These classes allow you to define consistent APIs for your classes."
    },
    {
        "link": "https://python-textbok.readthedocs.io/en/1.0/Classes.html",
        "document": "We have already seen how we can use a dictionary to group related data together, and how we can use functions to create shortcuts for commonly used groups of statements. A function performs an action using some set of input parameters. Not all functions are applicable to all kinds of data. Classes are a way of grouping together related data and functions which act upon that data.\n\nA class is a kind of data type, just like a string, integer or list. When we create an object of that data type, we call it an instance of a class.\n\nAs we have already mentioned, in some other languages some entities are objects and some are not. In Python, everything is an object – everything is an instance of some class. In earlier versions of Python a distinction was made between built-in types and user-defined classes, but these are now completely indistinguishable. Classes and types are themselves objects, and they are of type . You can find out the type of any object using the function:\n\nThe data values which we store inside an object are called attributes, and the functions which are associated with the object are called methods. We have already used the methods of some built-in objects, like strings and lists.\n\nWhen we design our own objects, we have to decide how we are going to group things together, and what our objects are going to represent.\n\nSometimes we write objects which map very intuitively onto things in the real world. For example, if we are writing code to simulate chemical reactions, we might have objects which we can combine to make a object. However, it isn’t always necessary, desirable or even possible to make all code objects perfectly analogous to their real-world counterparts.\n\nSometimes we may create objects which don’t have any kind of real-world equivalent, just because it’s useful to group certain functions together.\n\nHere is an example of a simple custom class which stores information about a person: # we will use this for date objects We start the class definition with the keyword, followed by the class name and a colon. We would list any parent classes in between round brackets before the colon, but this class doesn’t have any, so we can leave them out. Inside the class body, we define two functions – these are our object’s methods. The first is called , which is a special method. When we call the class object, a new instance of the class is created, and the method on this new object is immediately executed with all the parameters that we passed to the class object. The purpose of this method is thus to set up a new object using data that we have provided. The second method is a custom method which calculates the age of our person using the birthdate and the current date. is sometimes called the object’s constructor, because it is used similarly to the way that constructors are used in other languages, but that is not technically correct – it’s better to call it the initialiser. There is a different method called which is more analogous to a constructor, but it is hardly ever used. You may have noticed that both of these method definitions have as the first parameter, and we use this variable inside the method bodies – but we don’t appear to pass this parameter in. This is because whenever we call a method on an object, the object itself is automatically passed in as the first parameter. This gives us a way to access the object’s properties from inside the object’s methods. In some languages this parameter is implicit – that is, it is not visible in the function signature – and we access it with a special keyword. In Python it is explicitly exposed. It doesn’t have to be called , but this is a very strongly followed convention. Now you should be able to see that our function creates attributes on the object and sets them to the values we have passed in as parameters. We use the same names for the attributes and the parameters, but this is not compulsory. The function doesn’t take any parameters except – it only uses information stored in the object’s attributes, and the current date (which it retrieves using the module). Note that the attribute is itself an object. The class is defined in the module, and we create a new instance of this class to use as the birthdate parameter when we create an instance of the class. We don’t have to assign it to an intermediate variable before using it as a parameter to ; we can just create it when we call , just like we create the string literals for the other parameters. Remember that defining a function doesn’t make the function run. Defining a class also doesn’t make anything run – it just tells Python about the class. The class will not be defined until Python has executed the entirety of the definition, so you can be sure that you can reference any method from any other method on the same class, or even reference the class inside a method of the class. By the time you call that method, the entire class will definitely be defined.\n• None Explain what the following variables refer to, and their scope:\n\nIt is important to note that the attributes set on the object in the function do not form an exhaustive list of all the attributes that our object is ever allowed to have. In some languages you must provide a list of the object’s attributes in the class definition, placeholders are created for these allowed attributes when the object is created, and you may not add new attributes to the object later. In Python, you can add new attributes, and even new methods, to an object on the fly. In fact, there is nothing special about the function when it comes to setting attributes. We could store a cached age value on the object from inside the function: Starting an attribute or method name with an underscore ( ) is a convention which we use to indicate that it is a “private” internal property and should not be accessed directly. In a more realistic example, our cached value would sometimes expire and need to be recalculated – so we should always use the method to make sure that we get the right value. We could even add a completely unrelated attribute from outside the object: It is very common for an object’s methods to update the values of the object’s attributes, but it is considered bad practice to create new attributes in a method without initialising them in the method. Setting arbitrary properties from outside the object is frowned upon even more, since it breaks the object-oriented paradigm (which we will discuss in the next chapter). The method will definitely be executed before anything else when we create the object – so it’s a good place to do all of our initialisation of the object’s data. If we create a new attribute outside the method, we run the risk that we will try to use it before it has been initialised. In the example above we have to check if an attribute exists on the object before we try to use it, because if we haven’t run the method before it will not have been created yet. It would be much tidier if we called this method at least once from , to make sure that is created as soon as we create the object. Initialising all our attributes in , even if we just set them to empty values, makes our code less error-prone. It also makes it easier to read and understand – we can see at a glance what attributes our object has. An method doesn’t have to take any parameters (except ) and it can be completely absent. What if we want to get or set the value of an attribute of an object without hard-coding its name? We may sometimes want to loop over several attribute names and perform the same operation on all of them, as we do in this example which uses a dictionary: How can we do something similar with an object? We can’t use the operator, because it must be followed by the attribute name as a bare word. If our attribute name is stored as a string value in a variable, we have to use the function to retrieve the attribute value from an object: Note that is a built-in function, not a method on the object: it takes the object as its first parameter. The second parameter is the name of the variable as a string, and the optional third parameter is the default value to be returned if the attribute does not exist. If we do not specify a default value, will raise an exception if the attribute does not exist. Similarly, allows us to set the value of an attribute. In this example, we copy data from a dictionary to an object: The first parameter of is the object, the second is the name of the function, and the third is the new value for the attribute. As we saw in the previous function example, detects whether an attribute exists. There’s nothing preventing us from using on attributes even if the name can be hard-coded, but this is not recommended: it’s an unnecessarily verbose and round-about way of accessing attributes: # means the same thing as You should only use these functions if you have a good reason to do so.\n• None Rewrite the class so that a person’s age is calculated for the first time when a new person instance is created, and recalculated (when it is requested) if the day has changed since the last time that it was calculated.\n\nAll the attributes which are defined on a instance are instance attributes – they are added to the instance when the method is executed. We can, however, also define attributes which are set on the class. These attributes will be shared by all instances of that class. In many ways they behave just like instance attributes, but there are some caveats that you should be aware of. We define class attributes in the body of a class, at the same indentation level as method definitions (one level up from the insides of methods): As you can see, we access the class attribute just like we would access an instance attribute – it is made available as a property on the instance object, which we access inside the method through the variable. All the objects we create will share the same class attribute. Class attributes are often used to define constants which are closely associated with a particular class. Although we can use class attributes from class instances, we can also use them from class objects, without creating an instance: # we can access a class attribute from an instance # but we can also access it from the class Note that the class object doesn’t have access to any instance attributes – those are only created when an instance is created! # This will give us an error Class attributes can also sometimes be used to provide default attribute values: When we set an attribute on an instance which has the same name as a class attribute, we are overriding the class attribute with an instance attribute, which will take precedence over it. If we create two objects and call the method on one of them, we will not affect the other one. We should, however, be careful when a class attribute is of a mutable type – because if we modify it in-place, we will affect all objects of that class at the same time. Remember that all instances share the same class attributes: What we should do in cases like this is initialise the mutable attribute as an instance attribute, inside . Then every instance will have its own separate copy: Note that method definitions are in the same scope as class attribute definitions, so we can use class attribute names as variables in method definitions (without , which is only defined inside the methods): Can we have class methods? Yes, we can. In the next section we will see how to define them using a decorator.\n• None Explain the differences between the attributes , and , and what values they can have in different instances of this class:\n\nIn the previous chapter we learned about decorators – functions which are used to modify the behaviour of other functions. There are some built-in decorators which are often used in class definitions. Just like we can define class attributes, which are shared between all instances of a class, we can define class methods. We do this by using the decorator to decorate an ordinary method. A class method still has its calling object as the first parameter, but by convention we rename this parameter from to . If we call the class method from an instance, this parameter will contain the instance object, but if we call it from the class it will contain the class object. By calling the parameter we remind ourselves that it is not guaranteed to have any instance attributes. What are class methods good for? Sometimes there are tasks associated with a class which we can perform using constants and other class attributes, without needing to create any class instances. If we had to use instance methods for these tasks, we would need to create an instance for no reason, which would be wasteful. Sometimes we write classes purely to group related constants together with functions which act on them – we may never instantiate these classes at all. Sometimes it is useful to write a class method which creates an instance of the class after processing the input so that it is in the right format to be passed to the class constructor. This allows the constructor to be straightforward and not have to implement any complicated parsing or clean-up code: # extract all the parameters from the text file # this is the same as calling Person(*params) A static method doesn’t have the calling object passed into it as the first parameter. This means that it doesn’t have access to the rest of the class or instance at all. We can call them from an instance or a class object, but they are most commonly called from class objects, like class methods. If we are using a class to group together related methods which don’t need to access each other or any other data on the class, we may want to use this technique. The advantage of using static methods is that we eliminate unnecessary or parameters from our method definitions. The disadvantage is that if we do occasionally want to refer to another class method or attribute inside a static method we have to write the class name out in full, which can be much more verbose than using the variable which is available to us inside a class method. Here is a brief example comparing the three method types: # no parameter for class or instance object # we have to use Person directly Sometimes we use a method to generate a property of an object dynamically, calculating it from the object’s other properties. Sometimes you can simply use a method to access a single attribute and return it. You can also use a different method to update the value of the attribute instead of accessing it directly. Methods like this are called getters and setters, because they “get” and “set” the values of attributes, respectively. In some languages you are encouraged to use getters and setters for all attributes, and never to access their values directly – and there are language features which can make attributes inaccessible except through setters and getters. In Python, accessing simple attributes directly is perfectly acceptable, and writing getters and setters for all of them is considered unnecessarily verbose. Setters can be inconvenient because they don’t allow use of compound assignment operators: As we can see, incrementing the height attribute through a setter is much more verbose. Of course we could write a second setter which increments the attribute by the given parameter – but we would have to do something similar for every attribute and every kind of modification that we want to perform. We would have a similar issue with in-place modifications, like adding values to lists. Something which is often considered an advantage of setters and getters is that we can change the way that an attribute is generated inside the object without affecting any code which uses the object. For example, suppose that we initially created a class which has a attribute, but later we want to change the class to have separate and attributes which we combine to create a full name. If we always access the attribute through a setter, we can just rewrite the setter – none of the code which calls the setter will have to be changed. But what if our code accesses the attribute directly? We can write a method which returns the right value, but a method has to be called. Fortunately, the decorator lets us make a method behave like an attribute: There are also decorators which we can use to define a setter and a deleter for our attribute (a deleter will delete the attribute from our object). The getter, setter and deleter methods must all have the same name: # this is much more complicated in real life\n• None Create a class called , which has a single class attribute called , and a constructor which takes the parameters and (these should all be numbers).\n• None Write a method called which returns the sum of the attributes and .\n• None Write a class method called , which takes a single number parameter and returns the product of and .\n• None Write a static method called , which takes two number parameters, and , and returns - .\n• None Write a method called which returns a tuple containing the values of and . Make this method into a property, and write a setter and a deleter for manipulating the values of and .\n\nWe can check what properties are defined on an object using the function: Now we can see our attributes and our method – but what’s all that other stuff? We will discuss inheritance in the next chapter, but for now all you need to know is that any class that you define has as its parent class even if you don’t explicitly say so – so your class will have a lot of default attributes and methods that any Python object has. in Python 2 we have to inherit from explicitly, otherwise our class will be almost completely empty except for our own custom properties. Classes which don’t inherit from are called “old-style classes”, and using them is not recommended. If we were to write the person class in Python 2 we would write the first line as . This is why you can just leave out the method out of your class if you don’t have any initialisation to do – the default that you inherited from (which does nothing) will be used instead. If you do write your own method, it will override the default method. Sometimes we also call this overloading. Many default methods and attributes that are found in built-in Python objects have names which begin and end in double underscores, like or . These names indicate that these properties have a special meaning – you shouldn’t create your own methods or attributes with the same names unless you mean to overload them. These properties are usually methods, and they are sometimes called magic methods. We can use on any object. You can try to use it on all kinds of objects which we have already seen before, like numbers, lists, strings and functions, to see what built-in properties these objects have in common. Here are some examples of special object properties:\n• None : the initialisation method of an object, which is called when the object is created.\n• None : the string representation method of an object, which is called when you use the function to convert that object to a string.\n• None : an attribute which stores the the class (or type) of an object – this is what is returned when you use the function on the object.\n• None : a method which determines whether this object is equal to another. There are also other methods for determining if it’s not equal, less than, etc.. These methods are used in object comparisons, for example when we use the equality operator to check if two objects are equal.\n• None is a method which allows this object to be added to another object. There are equivalent methods for all the other arithmetic operators. Not all objects support all arithemtic operations – numbers have all of these methods defined, but other objects may only have a subset.\n• None : a method which returns an iterator over the object – we will find it on strings, lists and other iterables. It is executed when we use the function on the object.\n• None : a method which calculates the length of an object – we will find it on sequences. It is executed when we use the function of an object.\n• None : a dictionary which contains all the instance attributes of an object, with their names as keys. It can be useful if we want to iterate over all the attributes of an object. does not include any methods, class attributes or special default attributes like .\n• None Create an instance of the class from example 2. Use the function on the instance. Then use the function on the class.\n• None What happens if you call the method on the instance? Verify that you get the same result if you call the function with the instance as a parameter.\n• None What is the type of the instance?\n• None What is the type of the class?\n• None Write a function which prints out the names and values of all the custom attributes of any object that is passed in as a parameter.\n\nWe have already seen how to overload the method so that we can customise it to initialise our class. We can also overload other special methods. For example, the purpose of the method is to output a useful string representation of our object. but by default if we use the function on a person object (which will call the method), all that we will get is the class name and an ID. That’s not very useful! Let’s write a custom method which shows the values of all of the object’s properties: Note that when we insert the birthdate object into the output string with it will itself be converted to a string, so we don’t need to do it ourselves (unless we want to change the format). It is also often useful to overload the comparison methods, so that we can use comparison operators on our person objects. By default, our person objects are only equal if they are the same object, and you can’t test whether one person object is greater than another because person objects have no default order. Suppose that we want our person objects to be equal if all their attributes have the same values, and we want to be able to order them alphabetically by surname and then by first name. All of the magic comparison methods are independent of each other, so we will need to overload all of them if we want all of them to work – but fortunately once we have defined equality and one of the basic order methods the rest are easy to do. Each of these methods takes two parameters – for the current object, and for the other object: # now we can define all the other methods in terms of the first two Note that is not guaranteed to be another person object, and we haven’t put in any checks to make sure that it is. Our method will crash if the other object doesn’t have a or attribute, but if they are present the comparison will work. Whether that makes sense or not is something that we will need to think about if we create similar types of objects. Sometimes it makes sense to exit with an error if the other object is not of the same type as our object, but sometimes we can compare two compatible objects even if they are not of the same type. For example, it makes sense to compare and because they are both numbers, even though one is an integer and the other is a float. Python 2 also has a method which was introduced to the language before the individual comparison methods (called rich comparisons) described above. It is used if the rich comparisons are not defined. You should overload it in a way which is consistent with the rich comparison methods, otherwise you may encounter some very strange behaviour.\n• None Write a class for creating completely generic objects: its function should accept any number of keyword parameters, and set them on the object as attributes with the keys as names. Write a method for the class – the string it returns should include the name of the class and the values of all the object’s custom instance attributes."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/understanding-class-and-instance-variables-in-python-3",
        "document": "Object-oriented programming allows for variables to be used at the class level or the instance level. Variables are essentially symbols that stand in for a value you’re using in a program.\n\nAt the class level, variables are referred to as class variables, whereas variables at the instance level are called instance variables.\n\nWhen we expect variables are going to be consistent across instances, or when we would like to initialize a variable, we can define that variable at the class level. When we anticipate the variables will change significantly across instances, we can define them at the instance level.\n\nOne of the principles of software development is the DRY principle, which stands for don’t repeat yourself. This principle is geared towards limiting repetition within code, and object-oriented programming adheres to the DRY principle as it reduces redundancy.\n\nThis tutorial will demonstrate the use of both class and instance variables in object-oriented programming within Python.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nClass variables are defined within the class construction. Because they are owned by the class itself, class variables are shared by all instances of the class. They therefore will generally have the same value for every instance unless you are using the class variable to initialize a variable.\n\nDefined outside of all the methods, class variables are, by convention, typically placed right below the class header and before the constructor method and other methods.\n\nA class variable alone looks like the following:\n\nHere, the variable is assigned the value .\n\nWe can create an instance of the class (we’ll call it ) and print the variable by using dot notation:\n\nOur program returns the value of the variable.\n\nLet’s add a few more class variables and print them out:\n\nJust like with any other variable, class variables can consist of any data type available to us in Python. In this program we have strings and an integer. Let’s run the program again with the command and review the output:\n\nThe instance of is able to access all the class variables and print them out when we run the program.\n\nClass variables allow us to define variables upon constructing the class. These variables and their associated values are then accessible to each instance of the class.\n\nInstance variables are owned by instances of the class. This means that for each object or instance of a class, the instance variables are different.\n\nIn the class example below, and are instance variables:\n\nWhen we create a object, we will have to define these variables, which are passed as parameters within the constructor method or another method.\n\nAs with class variables, we can similarly call to print instance variables:\n\nWhen we run the program above with , we’ll receive the following output:\n\nThe output we receive is made up of the values of the variables that we initialized for the object instance of .\n\nLet’s create another object of the class called :\n\nThe object, like the object passes the parameters specific for that instance of the class to assign values to the instance variables.\n\nInstance variables, owned by objects of the class, allow for each object or instance to have different values assigned to those variables.\n\nWorking with Class and Instance Variables Together\n\nClass variables and instance variables will often be utilized at the same time, so let’s look at an example of this using the class we created. The comments in the program outline each step of the process.\n\nWhen we run the program with , we’ll receive the following output:\n\nHere, we have made use of both class and instance variables in two objects of the class, and .\n\nIn object-oriented programming, variables at the class level are referred to as class variables, whereas variables at the object level are called instance variables.\n\nThis differentiation allows us to use class variables to initialize objects with a specific value assigned to variables, and use different variables for each object with instance variables.\n\nMaking use of class- and instance-specific variables can ensure that our code adheres to the DRY principle to reduce repetition within code."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/understanding-class-inheritance-in-python-3",
        "document": "Object-oriented programming creates reusable patterns of code to curtail redundancy in development projects. One way that object-oriented programming achieves recyclable code is through inheritance, when one subclass can leverage code from another base class.\n\nThis tutorial will go through some of the major aspects of inheritance in Python, including how parent classes and child classes work, how to override methods and attributes, how to use the function, and how to make use of multiple inheritance.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nInheritance is when a class uses code constructed within another class. If we think of inheritance in terms of biology, we can think of a child inheriting certain traits from their parent. That is, a child can inherit a parent’s height or eye color. Children also may share the same last name with their parents.\n\nClasses called child classes or subclasses inherit methods and variables from parent classes or base classes.\n\nWe can think of a parent class called that has class variables for , , and that the child class will inherit from the .\n\nBecause the subclass is inheriting from the base class, the class can reuse the code of , allowing the programmer to use fewer lines of code and decrease redundancy.\n\nParent or base classes create a pattern out of which child or subclasses can be based on. Parent classes allow us to create child classes through inheritance without having to write the same code over again each time. Any class can be made into a parent class, so they are each fully functional classes in their own right, rather than just templates.\n\nLet’s say we have a general parent class that has and child classes. Many of the methods between personal and business accounts will be similar, such as methods to withdraw and deposit money, so those can belong to the parent class of . The subclass would have methods specific to it, including perhaps a way to collect business records and forms, as well as an variable.\n\nSimilarly, an class may have and methods, and a subclass may include its own specific and methods.\n\nLet’s create a parent class that we will later use to construct types of fish as its subclasses. Each of these fish will have first names and last names in addition to characteristics.\n\nWe’ll create a new file called and start with the constructor method, which we’ll populate with and class variables for each object or subclass.\n\nWe have initialized our variable with the string because we know that most fish will have this as their last name.\n\nLet’s also add some other methods:\n\nWe have added the methods and to the class, so that every subclass will also be able to make use of these methods.\n\nSince most of the fish we’ll be creating are considered to be bony fish (as in they have a skeleton made out of bone) rather than cartilaginous fish (as in they have a skeleton made out of cartilage), we can add a few more attributes to the method:\n\nBuilding a parent class follows the same methodology as building any other class, except we are thinking about what methods the child classes will be able to make use of once we create those.\n\nChild or subclasses are classes that will inherit from the parent class. That means that each child class will be able to make use of the methods and variables of the parent class.\n\nFor example, a child class that subclasses the class will be able to make use of the method declared in without needing to declare it.\n\nWe can think of each child class as being a class of the parent class. That is, if we have a child class called and a parent class called , we can say that a is a , just as a is a .\n\nThe first line of a child class looks a little different than non-child classes as you must pass the parent class into the child class as a parameter:\n\nThe class is a child of the class. We know this because of the inclusion of the word in parentheses.\n\nWith child classes, we can choose to add more methods, override existing parent methods, or accept the default parent methods with the keyword, which we’ll do in this case:\n\nWe can now create a object without having to define any additional methods.\n\nWe have created a object that makes use of each of the methods of the class even though we did not define those methods in the child class. We only needed to pass the value of to the variable because all of the other variables were initialized.\n\nWhen we run the program, we’ll receive the following output:\n\nNext, let’s create another child class that includes its own method. We’ll call this class , and its special method will permit it to live with sea anemone:\n\nNext, let’s create a object to see how this works:\n\nWhen we run the program, we’ll receive the following output:\n\nThe output shows that the object is able to use the methods and as well as its child class method of .\n\nIf we try to use the method in a object, we’ll receive an error:\n\nThis is because the method belongs only to the child class, and not the parent class.\n\nChild classes inherit the methods of the parent class it belongs to, so each child class can make use of those methods within programs.\n\nSo far, we have looked at the child class that made use of the keyword to inherit all of the parent class behaviors, and another child class that inherited all of the parent class behaviors and also created its own unique method that is specific to the child class. Sometimes, however, we will want to make use of some of the parent class behaviors but not all of them. When we change parent class methods we override them.\n\nWhen constructing parent and child classes, it is important to keep program design in mind so that overriding does not produce unnecessary or redundant code.\n\nWe’ll create a child class of the parent class. Because we created the class with the idea that we would be creating primarily bony fish, we’ll have to make adjustments for the class that is instead a cartilaginous fish. In terms of program design, if we had more than one non-bony fish, we would most likely want to make separate classes for each of these two types of fish.\n\nSharks, unlike bony fish, have skeletons made of cartilage instead of bone. They also have eyelids and are unable to swim backwards. Sharks can, however, maneuver themselves backwards by sinking.\n\nIn light of this, we’ll be overriding the constructor method and the method. We don’t need to modify the method since sharks are fish that can swim. Let’s review this child class:\n\nWe have overridden the initialized parameters in the method, so that the variable is now set equal to the string , the variable is now set equal to the string , and the variable is now set to the Boolean value . Each instance of the class can also override these parameters.\n\nThe method now prints a different string than the one in the parent class because sharks are not able to swim backwards in the way that bony fish can.\n\nWe can now create an instance of the child class, which will still make use of the method of the parent class:\n\nWhen we run this code, we’ll receive the following output:\n\nThe child class successfully overrode the and methods of the parent class, while also inheriting the method of the parent class.\n\nWhen there will be a limited number of child classes that are more unique than others, overriding parent class methods can prove to be useful.\n\nWith the function, you can gain access to inherited methods that have been overwritten in a class object.\n\nWhen we use the function, we are calling a parent method into a child method to make use of it. For example, we may want to override one aspect of the parent method with certain functionality, but then call the rest of the original parent method to finish the method.\n\nIn a program that grades students, we may want to have a child class for that inherits from the parent class. In the child class , we may want to override a method of the parent class in order to include functionality to calculate a weighted grade, but still keep the rest of the functionality of the original class. By invoking the function we would be able to achieve this.\n\nThe function is most commonly used within the method because that is where you will most likely need to add some uniqueness to the child class and then complete initialization from the parent.\n\nTo see how this works, let’s modify our child class. Since trout are typically freshwater fish, let’s add a variable to the method and set it equal to the string , but then maintain the rest of the parent class’s variables and parameters:\n\nWe have overridden the method in the child class, providing a different implementation of the that is already defined by its parent class . Within the method of our class we have explicitly invoked the method of the class.\n\nBecause we have overridden the method, we no longer need to pass in as a parameter to , and if we did pass in a parameter, we would reset instead. We will therefore initialize the by calling the variable in our object instance.\n\nNow we can invoke the initialized variables of the parent class and also make use of the unique child variable. Let’s use this in an instance of :\n\nThe output shows that the object of the child class is able to make use of both the child-specific variable while also being able to call the parent variables of , , and .\n\nThe built-in Python function allows us to utilize parent class methods even when overriding certain aspects of those methods in our child classes.\n\nMultiple inheritance is when a class can inherit attributes and methods from more than one parent class. This can allow programs to reduce redundancy, but it can also introduce a certain amount of complexity as well as ambiguity, so it should be done with thought to overall program design.\n\nTo show how multiple inheritance works, let’s create a child class than inherits from a class and a class. We can create a method in each and then use the keyword in the child class:\n\nThe class has a method called that prints one line, and the class has a method called that prints another line. Then we call both classes into the inheritance tuple. This means that is inheriting from two parent classes.\n\nThe object is set as a object, and can use the methods in both parent classes. When we run the program, we’ll see the following output:\n\nThe output shows that methods from both parent classes were effectively used in the child class.\n\nMultiple inheritance allows us to use the code from more than one parent class in a child class. If the same method is defined in multiple parent methods, the child class will use the method of the first parent declared in its tuple list.\n\nThough it can be used effectively, multiple inheritance should be done with care so that our programs do not become ambiguous and difficult for other programmers to understand.\n\nThis tutorial went through constructing parent classes and child classes, overriding parent methods and attributes within child classes, using the function, and allowing for child classes to inherit from multiple parent classes.\n\nInheritance in object-oriented coding can allow for adherence to the DRY (don’t repeat yourself) principle of software development, allowing for more to be done with less code and repetition. Inheritance also compels programmers to think about how they are designing the programs they are creating to ensure that code is effective and clear."
    },
    {
        "link": "https://realpython.com/inheritance-composition-python",
        "document": "In Python, understanding inheritance and composition is crucial for effective object-oriented programming. Inheritance allows you to model an is a relationship, where a derived class extends the functionality of a base class. Composition, on the other hand, models a has a relationship, where a class contains objects of other classes to build complex structures. Both techniques promote code reuse, but they approach it differently.\n\nBy the end of this tutorial, you’ll understand that:\n• Composition and inheritance in Python model relationships between classes, enabling code reuse in different ways.\n• Composition is achieved by creating classes that contain objects of other classes, allowing for flexible designs.\n• Inheritance models an is a relationship, allowing derived classes to extend base class functionality.\n• Inheritance in Python is achieved by defining classes that derive from base classes, inheriting their interface and implementation.\n\nExploring the differences between inheritance and composition helps you choose the right approach for designing robust, maintainable Python applications. Understanding how and when to apply each concept is key to leveraging the full power of Python’s object-oriented programming capabilities.\n\nAn Overview of Inheritance in Python Everything in Python is an object. Modules are objects, class definitions and functions are objects, and of course, objects created from classes are objects too. Inheritance is a required feature of every object-oriented programming language. This means that Python supports inheritance, and as you’ll see later, it’s one of the few languages that supports multiple inheritance. When you write Python code using classes, you’re using inheritance even if you don’t know that you’re using it. Next up, take a look at what that means. The easiest way to see inheritance in Python is to jump into the Python interactive shell and write a little bit of code. You’ll start by writing the simplest class possible: You declared , which doesn’t do much, but it’ll illustrate the most basic inheritance concepts. Now that you have the class declared, you can create an instance of the class and use the function to list its members: The function returns a list of all the members in the specified object. You haven’t declared any members in , so where’s the list coming from? You can find out using the interactive interpreter: As you can see, the two lists are nearly identical. There are three additional members in : However, every single member of the class is also present in . This is because every class that you create in Python implicitly derives from . You could be more explicit and write , but it’s redundant and unnecessary. Note: In Python 2, you had to explicitly derive from for reasons beyond the scope of this tutorial, but you can read about it in the new-style and classic classes section of the Python 2 documentation. Okay, it’s not entirely true that every class in Python derives from . There’s one aptly named exception, which you’ll learn about next. Every class that you create in Python will implicitly derive from . However, there’s one exception to this rule: classes used to indicate errors by raising an exception. If you try to treat a normal Python class like an exception and it, then Python will present you with a : You created a new class to indicate a type of error. Then you tried to raise the class to signal an exception. Python does indeed raise an exception, but the output states that the exception is of type , not , and that all . is a base class provided for all error types. To create a new error type, you must derive your class from or one of its derived classes. The convention in Python is to derive your custom error types from , which in turn derives from . The correct way to define your error type is the following: In this example, explicitly inherits from instead of implicitly inheriting from . With that change, you’ve fulfilled the requirements for creating a custom exception, and you can now raise your new exception class. When you raise , the output correctly states that Python raised an error of the type . Inheritance is the mechanism that you’ll use to create hierarchies of related classes. These related classes will share a common interface that the base classes will define. Derived classes can specialize the interface by providing a particular implementation where applicable. In this section, you’ll start modeling an HR system. Along the way, you’ll explore the use of inheritance and see how derived classes can provide a concrete implementation of the base class interface. The HR system needs to process payroll for the company’s employees, but there are different types of employees depending on how their payroll is calculated. You start by implementing a class that processes payroll: implements a method that takes a collection of employees and prints their , , and check amount using the method exposed on each employee object. Now, you implement a base class, , that handles the common interface for every employee type: is the base class for all employee types. It’s constructed with an and a . What you’re saying is that every must have an as well as a assigned. The HR system requires that every processed must provide a interface that returns the weekly salary for the employee. The implementation of that interface differs depending on the type of . For example, administrative workers have a fixed salary, so every week they get paid the same amount: You create a derived class, , that inherits from . The class initializes with the and required by the base class, and you use to initialize the members of the base class. You can read all about in Supercharge Your Classes With Python . also requires a initialization parameter that represents the amount that the employee makes per week. The class provides the required method that the HR system uses. The implementation just returns the amount stored in . The company also employs manufacturing workers who are paid by the hour, so you add to the HR system: The class is initialized with and , like the base class, plus the and the required to calculate the payroll. You implement the method by returning the hours worked times the hourly rate. Finally, the company employs sales associates who are paid through a fixed salary plus a commission based on their sales, so you create a class: You derive from because both classes have a to consider. At the same time, you initialize with a value that’s based on the sales for the employee. With , you leverage the implementation of the base class to retrieve the salary, and you add the commission value. Since derives from , you have access to the property directly, and you could’ve implemented using the value of that property. The problem with accessing the property directly is that if the implementation of changes, then you’ll have to also change the implementation of . It’s better to rely on the already-implemented method in the base class and extend the functionality as needed. You’ve created your first class hierarchy for the system. The UML diagram of the classes looks like this: The diagram shows the inheritance hierarchy of the classes. The derived classes implement the interface, which the requires. The implementation requires that the objects in the collection contain an , , and implementation. Note: Interfaces are represented similarly to classes in UML diagrams, with the word Interface above the interface name. Interface names are usually prefixed with a capital . In Python, you don’t implement interfaces explicitly. Instead, interfaces are defined by the attributes used and methods called by other functions and methods. Next, create a new file and call it . This program creates the employees and passes them to the payroll system to process payroll: You can run the program in the command line and see the results: The program creates three employee objects, one for each of the derived classes. Then, it creates the payroll system and passes a list of the employees to its method, which calculates the payroll for each employee and prints the results. Notice how the base class doesn’t define a method. This means that if you were to create a plain object and pass it to the , then you’d get an error. You can try it in the Python interactive interpreter: While you can instantiate an object, can’t use the object. Why? Because it can’t call for . To be more explicit about the requirements of , you can convert the class, which is currently a concrete class, to an abstract class. That way, no employee is ever just an , but instead always a derived class that implements . The class in the example above is what is called an abstract base class. Abstract base classes exist to be inherited, but never instantiated. Python provides the module to formally define abstract base classes. You can use leading underscores in your class name to communicate that objects of that class shouldn’t be created. Underscores provide a friendly way to prevent misuse of your code, but they don’t prevent eager users from creating instances of that class. The module in the Python standard library provides functionality to prevent creating objects from abstract base classes. You can modify the implementation of the class to ensure that it can’t be instantiated: You derive from , making it an abstract base class. Then, you decorate the method with the decorator. This change has two nice side-effects:\n• You’re telling users of the module that objects of type can’t be created.\n• You’re telling other developers working on the module that if they derive from , then they must override the abstract method. You can see that you can’t create objects of type anymore using the interactive interpreter: The output shows that you can’t instantiate the class because it contains an abstract method, . Derived classes must override the method to allow creating objects of their type. When you derive one class from another, the derived class inherits both of the following:\n• The base class interface: The derived class inherits all the methods, properties, and attributes of the base class.\n• The base class implementation: The derived class inherits the code that implements the class interface. Most of the time, you’ll want to inherit the implementation of a class, but you’ll want to implement multiple interfaces so that you can use your objects in different situations. Modern programming languages are designed with this basic concept in mind. They allow you to inherit from a single class, but you can implement multiple interfaces. In Python, you don’t have to explicitly declare an interface. Any object that implements the desired interface can be used in place of another object. This is known as duck typing. Duck typing is usually explained as if it walks like a duck and it quacks like a duck, then it must be a duck. In other words, it’s enough to behave like a duck to be considered a duck. To illustrate this, you’ll now add a class to the example above, and it won’t derive from . Create a new file called and add the following code: The class doesn’t derive from , but it exposes the same interface that requires. Remember that requires a list of objects that implement the following interface:\n• An property or attribute that returns the employee’s ID\n• A property or attribute that represents the employee’s name\n• A method that doesn’t take any parameters and returns the payroll amount to process The class meets all these requirements, so can still calculate its payroll. You can modify the program to use the class: The program creates a object and adds it to the list that processes. You can now run the program and see its output: As you can see, the can still process the new object because it meets the desired interface. Since you don’t have to derive from a specific class for your objects to be reusable by the program, you may be asking why you should use inheritance instead of just implementing the desired interface. The following rules may help you to make this decision:\n• Use inheritance to reuse an implementation: Your derived classes should leverage most of their base class implementation. They must also model an is a relationship. A class might also have an and a , but a is not an , so in this case, you shouldn’t use inheritance.\n• Implement an interface to be reused: When you want your class to be reused by a specific part of your application, you implement the required interface in your class, but you don’t need to provide a base class, or inherit from another class. You can now clean up the example above to move on to the next topic. You can delete the file and then modify the module to its original state: You removed the import of the module since the class doesn’t need to be abstract. You also removed the abstract method from it since it doesn’t provide any implementation. Basically, you’re inheriting the implementation of the and attributes of the class in your derived classes. Since is just an interface to the method, you don’t need to implement it in the base class. Notice how the class derives from . This means that inherits the implementation and interface of . You can see how the method leverages the base class implementation because it relies on the result from to implement its own version. If you’re not careful, inheritance can lead you to a huge hierarchical class structure that’s hard to understand and maintain. This is known as the class explosion problem. You started building a class hierarchy of types used by the to calculate payroll. Now, you need to add some functionality to those classes so that you can use them with the new . tracks productivity based on employee roles. There are different employee roles:\n• Managers: They walk around yelling at people, telling them what to do. They’re salaried employees and make more money.\n• Secretaries: They do all the paperwork for managers and ensure that everything gets billed and payed on time. They’re also salaried employees but make less money.\n• Sales employees: They make a lot of phone calls to sell products. They have a salary, but they also get commissions for sales.\n• Factory workers: They manufacture the products for the company. They’re paid by the hour. With those requirements, you start to see that and its derived classes might belong somewhere other than the module because now they’re also used by the . You create an module and move the classes there: The implementation remains the same, but you move the classes to the module. Your module is now much smaller and focused on the payroll system: With both and in place, you can now update your program to support the change: You run the program and verify that it still works: With everything in place, you start adding the new classes: First, you add a class that derives from . The class exposes a method that the productivity system will use. The method takes the that the employee worked. Then you add , , and and then implement the interface, so they can be used by the productivity system—which you haven’t created yet. As a next step, you can create a new file called and add the class: The class tracks employees in the method that takes a list of employees and the number of hours to track. As outlined above, the productivity system makes use of on each of the objects in to accomplish the tracking. You can now add the productivity system to your program, and update it to represent different types of employees: Your updated program creates a list of employees of different types. The employee list is sent to the productivity system to track their work for forty hours. Then the same list of employees is sent to the payroll system to calculate their payroll. You can run the program to see the output: The program shows the employees working for forty hours through the productivity system. Then it calculates and displays the payroll for each of the employees. The program works as expected, but you had to add four new classes to support the changes. As new requirements come, your class hierarchy will inevitably grow, leading to the class explosion problem where your hierarchies will become so big that they’ll be hard to understand and maintain. The following diagram shows the new class hierarchy: The diagram shows how the class hierarchy is growing. Additional requirements might have an exponential effect on the number of classes with this design. Python is one of the few modern programming languages that supports multiple inheritance. Multiple inheritance is the ability to derive a class from multiple base classes at the same time. Multiple inheritance has a bad reputation to the extent that most modern programming languages don’t support it. Instead, modern programming languages support the concept of interfaces. In those languages, you inherit from a single base class and then implement multiple interfaces, so you can reuse your classes in different situations. This approach puts some constraints in your designs. You can only inherit the implementation of one class by directly deriving from it. You can implement multiple interfaces, but you can’t inherit the implementation of multiple classes. This constraint is good for software design because it forces you to design your classes with fewer dependencies on each other. You will see later in this tutorial that you can leverage multiple implementations through composition, which makes software more flexible. This section, however, is about multiple inheritance, so take a look at how it works. It turns out that sometimes temporary secretaries are hired when there’s too much paperwork to do. The class performs the role of a in the context of the , but for payroll purposes, it’s an . You look at your class design. It’s grown a little bit, but you can still understand how it works. It seems you have two options:\n• Derive from : You can derive from to inherit the method for the role, and then override the method to implement it as an .\n• Derive from : You can derive from to inherit the method, and then override the method to implement it as a . Then, you remember that Python supports multiple inheritance, so you decide to derive from both and : Python allows you to inherit from two different classes by specifying them between parentheses in the class declaration, and separating them with commas. Now, you modify your program to add the new temporary secretary employee: You run the program to test it: python program.py TypeError: SalaryEmployee.__init__() takes 4 positional arguments but 5 were given You get a exception saying that positional arguments where expected, but were given. This is because you derived first from and then from , so the interpreter is trying to use to initialize the object. Okay, go ahead and reverse it: Now, run the program again and see what happens: Now it seems that you’re missing a parameter, which is necessary to initialize , but that parameter doesn’t make sense in the context of a because it’s an . Maybe implementing will help: That didn’t work either. Okay, it’s time for you to dive into Python’s method resolution order (MRO) to see what’s going on. When a method or attribute of a class is accessed, Python uses the class MRO to find it. The MRO is also used by to determine which method or attribute to invoke. You can learn more about in Supercharge Your Classes With Python . You can evaluate the class MRO using the interactive interpreter: The MRO shows the order in which Python is going to look for a matching attribute or method. In the example, this is what happens when you create the object:\n• calls , which the MRO is going to match to , which is inherited from . You can bypass parts of the MRO. In this case, you want to skip the initialization of and . You can do this by reversing the inheritance order again back to how you had it initially. Then, you’ll directly call : When you put before , then the MRO of looks like the following: Because you explicitly specified that should use , you’re effectively skipping and in the MRO when initializing an object. That solves the problem of creating the object, but you’ll run into a similar problem when trying to calculate payroll. You can run the program to see the problem: The problem now is that because you reversed the inheritance order, the MRO is finding the method of before the one in . You need to override in and invoke the right implementation from it: The new method now directly invokes to ensure that you get the correct result. You can run the program again to see it working: The program now works as expected because you’re forcing the method resolution order by explicitly telling the interpreter which method you want to use. As you can see, multiple inheritance can be confusing, especially when you run into the diamond problem. The following diagram shows the diamond problem in your class hierarchy: The diagram shows the diamond problem with the current class design. uses multiple inheritance to derive from two classes that ultimately also derive from . This causes two paths to reach the base class, which is something you want to avoid in your designs. The diamond problem appears when you’re using multiple inheritance and deriving from two classes that have a common base class. This can cause the wrong version of a method to be called. As you’ve seen, Python provides a way to force the right method to be invoked, and analyzing the MRO can help you understand the problem. Still, when you run into the diamond problem, it’s better to rethink the design. You’ll now make some changes to leverage multiple inheritance, avoiding the diamond problem. Two different systems use the derived classes:\n• The payroll system that calculates the employee payroll This means that everything related to productivity should be together in one module, and everything related to payroll should be together in another. You can start making changes to the productivity module: The module implements the class, as well as the related roles that it supports. The classes implement the interface required by the system, but they don’t derive from . You can do the same with the module: The module implements the , which calculates payroll for the employees. It also implements the policy classes for payroll. As you can see, the policy classes don’t derive from anymore. You can now add the necessary classes to the module: The module imports policies and roles from the other modules and implements the different types. You’re still using multiple inheritance to inherit the implementation of the salary policy classes and the productivity roles, but the implementation of each class only needs to deal with initialization. Notice that you still need to explicitly initialize the salary policies in the constructors. You probably saw that the initializations of and are identical. Also, the initializations of and are the same. You won’t want to have this kind of code duplication in more complex designs, so you have to be careful when designing class hierarchies. Here’s the UML diagram for the new design: The diagram shows the relationships to define the and using multiple inheritance, but avoiding the diamond problem. You can run the program and see how it works: You’ve seen how inheritance and multiple inheritance work in Python. You can now explore the topic of composition.\n\nComposition is an object-oriented design concept that models a has a relationship. In composition, a class known as composite contains an object, or component, of another class. In other words, a composite class has a component of another class. Composition allows composite classes to reuse the implementation of the components it contains. The composite class doesn’t inherit the component class interface, but it can leverage its implementation. The composition relation between two classes is considered loosely coupled. That means that changes to the component class rarely affect the composite class, and changes to the composite class never affect the component class. This provides better adaptability to change and allows applications to introduce new requirements without affecting existing code. When looking at two competing software designs, one based on inheritance and another based on composition, the composition solution usually is more flexible. You can now look at how composition works. You’ve already used composition in your examples. If you look at the class, then you’ll see that it contains two attributes:\n• to contain the name of the employee These two attributes are objects that the class has. Therefore, you can say that an has an and has a . Another attribute for an might be an . Create a new Python file called and add code for an class: You implemented a basic address class that contains the usual components for an address. You made the attribute optional because not all addresses will have that component. You implemented to provide a pretty representation of an . You can see this implementation in the interactive interpreter: When you the variable, you’re invoking the special method . Since you overloaded the method to return a string formatted as an address, you get a nice, readable representation. Operator and Function Overloading in Custom Python Classes gives a good overview of the special methods available in classes that you can implement to customize the behavior of your objects. You can now add to the class through composition: You initialize the attribute to for now to make it optional, but by doing that, you can now assign an to an . Also notice that there’s no reference in the module to the module. Composition is a loosely coupled relationship that often doesn’t require the composite class to have knowledge of the component. The UML diagram representing the relationship between and looks like this: The diagram shows the basic composition relationship between and . You can now modify the class to leverage the attribute in : You check to see if the object has an address, and if it does, you print it. You can now modify the program to assign some addresses to the employees: You added a couple of addresses to the and objects. When you run the program, you’ll see the addresses printed: Notice how the payroll output for the and objects shows the addresses where the checks were sent. The class leverages the implementation of the class without any knowledge of what an object is or how it’s represented. This type of design is so flexible that you can change the class without any impact to the class. Composition is more flexible than inheritance because it models a loosely coupled relationship. Changes to a component class have minimal or no effects on the composite class. Designs based on composition are more suitable to change. You change behavior by providing new components that implement those behaviors instead of adding new classes to your hierarchy. Take a look at the multiple inheritance example above. Imagine how new payroll policies will affect the design. Try to picture what the class hierarchy will look like if new roles are needed. As you saw before, relying too heavily on inheritance can lead to class explosion. The biggest problem isn’t so much the number of classes in your design, but how tightly coupled the relationships between those classes are. Tightly coupled classes affect each other when changes are introduced. In this section, you’re going to use composition to implement a better design that still fits the requirements of the and the . You can start by implementing the functionality of the : The updated class defines some roles using a string identifier mapped to a role class that implements the role. It exposes a method that, given a role identifier, returns the role type object. If the role isn’t found, then Python raises a exception. It also exposes the previous functionality in the method, where given a list of employees, it tracks the productivity of those employees. You can now implement the different role classes: Each of the roles that you implemented exposes its own method that takes the number of worked. These methods return a string representing the duties. Note: If you’ve followed along throughout the section on inheritance, then you’ll notice that these roles are similar, but slightly different from that example. Feel free to continue working with the roles that you previously defined and their methods if you prefer. You’ll just need to adapt the relevant names to account for the change. The role classes are independent of each other, but they expose the same interface, so they’re interchangeable. You’ll see later how they’re used in the application. Now, you can implement the for the application: keeps an internal database of payroll policies for each employee. It exposes a method that, given an employee , returns its payroll policy. If a specified doesn’t exist in the system, then the method raises a exception. The implementation of works the same as before. It takes a list of employees, calculates the payroll, and prints the results. You can now implement the payroll policy classes: You first implement a class that serves as a base class for all the payroll policies. This class tracks the , which is common to all payroll policies. The other policy classes derive from . You use inheritance here because you want to leverage the implementation of . Also, , , and are a . is initialized with a value that then uses. is initialized with and implements by leveraging the base class . The class derives from because it wants to inherit its implementation. It’s initialized with the parameters, but it also requires a parameter. The is used to calculate the , which is implemented as a property so it gets calculated when requested. In the example, you’re assuming that a sale happens every five hours worked, and the is the number of sales times the value. implements the method by first leveraging the implementation in and then adding the calculated commission. You can now add an class to manage employee addresses: The class keeps an internal database of objects for each employee. It exposes a method that returns the address of the specified employee . If the employee doesn’t exist, then it raises a . The class implementation remains the same as before: The class manages the address components and provides a pretty representation of an address. So far, the new classes have been extended to support more functionality, but there are no significant changes to the previous design. This is going to change with the design of the module and its classes. You can start by implementing an class: keeps track of all the employees in the company. For each employee, it tracks the , , and . It has an instance of the , the , and the . These instances are used to create employees. It exposes an property that returns the list of employees. The objects are created in an internal method. Notice that you don’t have different types of classes. You just need to implement a single class: You initialize the class with the , , and attributes. This class also requires the productivity for the employee and the policy. The class exposes a method that takes the hours worked. This method first retrieves the from the . In other words, it delegates to the object to perform its duties. In the same way, it delegates to the object to track the work . The , as you saw, uses those hours to calculate the payroll if needed. The following diagram shows the composition design used: The diagram shows the design of composition-based policies. There’s a single that’s composed of other data objects like and depends on the and interfaces to delegate the work. There are multiple implementations of these interfaces. You can now use this design in your program: You can run the program to see its output: This design is what’s called policy-based design, where classes are composed of policies, and they delegate to those policies to do the work. Policy-based design was introduced in the book Modern C++ Design, and it uses template metaprogramming in C++ to achieve the results. Python doesn’t support templates, but you can achieve similar results using composition, as you saw in the example above. This type of design gives you all the flexibility you’ll need as requirements change. Imagine that you need to change the way payroll is calculated for an object at runtime. If your design relies on inheritance, then you need to find a way to change the type of an object to change its behavior. With composition, you just need to change the policy that the object uses. Imagine that your all of a sudden becomes a temporary employee who gets paid by the hour. You can modify the object during the execution of the program in the following way: The program gets the employee list from the and retrieves the first employee, which is the manager you want. Then it creates a new initialized at 55 dollars per hour and assigns it to the manager object. The new policy is now used by the , modifying the existing behavior. You can run the program again to see the result: The check for Mary Poppins, your manager, is now for 2200 dollars instead of the fixed weekly salary of 3000 dollars that she used to have. Notice how you added that business rule to the program without changing any of the existing classes. Consider what type of changes would’ve been required with an inheritance design. You would’ve had to create a new class and change the type of the manager employee. There’s no chance that you could’ve changed the policy at runtime.\n\nChoosing Between Inheritance and Composition in Python So far, you’ve seen how inheritance and composition work in Python. You’ve seen that derived classes inherit the interface and implementation of their base classes. You’ve also seen that composition allows you to reuse the implementation of another class. You’ve implemented two solutions to the same problem. The first solution used multiple inheritance, and the second one used composition. You’ve also seen that Python’s duck typing allows you to reuse objects with existing parts of a program by implementing the desired interface. In Python, it isn’t necessary to derive from a base class to reuse your classes. At this point, you might be asking when to use inheritance vs composition in Python. They both enable code reuse. Inheritance and composition can tackle similar problems in your Python programs. The general advice is to use the relationship that creates fewer dependencies between two classes. This relation is composition. Still, there’ll be times where inheritance will make more sense. The following sections provide some guidelines to help you make the right choice between inheritance and composition in Python. You should only use inheritance to model an is a relationship. Liskov’s substitution principle says that an object of type , which inherits from , can replace an object of type without altering the desirable properties of a program. Liskov’s substitution principle is the most important guideline to determine if inheritance is the appropriate design solution. Still, the answer might not be straightforward in all situations. Fortunately, there’s a simple test that you can use to determine if your design follows Liskov’s substitution principle. Let’s say you have a class, , that provides an implementation and interface you want to reuse in another class, . Your initial thought is that you can derive from and inherit both the interface and the implementation. To be sure this is the right design, you follow theses steps:\n• Evaluate is an : Think about this relationship and justify it. Does it make sense?\n• Evaluate is a : Reverse the relationship and justify it. Does it also make sense? If you can justify both relationships, then you should never inherit those classes from one another. Look at a more concrete example. You have a class that exposes an property. You need a class, which also has an . It seems that a is a special type of , so maybe you can derive from it and leverage both the interface and implementation. Before you jump into the implementation, you use Liskov’s substitution principle to evaluate the relationship. A is a because its area is calculated from the product of its times its . The constraint is that and must be equal. It makes sense. You can justify the relationship and explain why a is a . Now reverse the relationship to see if it makes sense. A is a because its area is calculated from the product of its times its . The difference is that and can change independently. It also makes sense. You can justify the relationship and describe the special constraints for each class. This is a good sign that these two classes should never derive from each other. You might have seen other examples that derive from to explain inheritance. You might be skeptical with the little test that you just did. Fair enough. Next, you’ll write a program that illustrates the problem with deriving from . First, you implement . You’re even going to encapsulate the attributes to ensure that you’re meeting all the constraints: You initialize the class with a and a , and the class provides an property that returns the area. The and are encapsulated as and to avoid changing them directly. Now, you derive from and override the necessary interface to meet the constraints of a : You initialize the class with a , which is used to initialize both components of the base class. Now, you write a small program to test the behavior: The program creates a and a and asserts that their is calculated correctly. You can run the program and see that everything is so far: The program executes correctly, so it seems that is just a special case of a . Later on, you need to support resizing objects, so you make the appropriate changes to the class: Your method takes the and for the object. You can add the following code to the program to verify that it works correctly: You resize the rectangle object and assert that the new area is correct. You can run the program to verify the behavior: The assertion passes, and you see that the program runs correctly. So, what happens if you resize a square? Modify the program, and try to modify the object: You pass the same parameters to that you used with , and print the area. When you run the program you see: The program shows that the new area is like the object. The problem now is that the object no longer meets the class constraint that the length and height must be equal. How can you fix that problem? You can try several approaches, but all of them will be awkward. You can override in and ignore the parameter. However, that will be confusing for people looking at other parts of the program where objects are being resized and some of them are not getting the expected areas because they’re really objects. In a small program like this one, it might be easy to spot the causes of the weird behavior, but in a more complex program, the problem will be harder to find. The reality is that if you’re able to justify an inheritance relationship between two classes both ways, then you shouldn’t derive one class from another. In the example, it doesn’t make sense that inherits the interface and implementation of from . That doesn’t mean that objects can’t be resized. It means that the interface is different because it only needs a parameter. This difference in interface justifies not deriving from , like the test above advised. One of the uses of multiple inheritance in Python is to extend class features through mixins. A mixin is a class that provides methods to other classes but isn’t considered a base class. A mixin allows other classes to reuse its interface and implementation without becoming a superclass. It implements a unique behavior that you can aggregate to other unrelated classes. Mixins are similar to composition, but they create a stronger relationship. Say you want to convert objects of certain types in your application to a dictionary representation of the object. You could provide a method in every class that you want to support this feature, but the implementation of seems to be very similar. This could be a good candidate for a mixin. You start by slightly modifying the class from the composition example: The changes are minimal. You just changed the and attributes to be internal by adding a leading underscore to their names. You’ll see soon why you’re making that change. Now, you create an class in a new file called : The class exposes a method that returns the representation of itself as a dictionary. The method is implemented as a comprehension that creates a dictionary mapping to for each item in if the isn’t internal. Note: This is why you made the role and payroll attributes internal in the class—because you don’t want to represent them in the dictionary. As you saw at the beginning, creating a class inherits some members from , and one of those members is , which is basically a mapping of all the attributes in an object to their values. You iterate through all the items in and filter out the ones that have a name that starts with an underscore using . With , you check the specified value. If the value is an , then the method looks to see if it also has a member and uses it to represent the object. Otherwise, it returns a string representation. If the value isn’t an , then it simply returns the value. You can modify the class to support this mixin: All you have to do is inherit the to support the functionality. It’ll be nice to support the same functionality in the class, so you represent the attribute in the same way: You apply the mixin to the class to support the feature. Now, you can write a small program to test it: The program implements , which converts the dictionary to a JSON string using indentation so the output looks better. Then, it iterates through all the employees, printing the dictionary representation provided by . You can run the program to see its output: You leveraged the implementation of in both and classes even when they’re not related. Because only provides behavior, you can reuse it with other classes without causing problems. Composition models a has a relationship. With composition, a class has an instance of the class and can leverage its implementation. You can reuse the class in other classes completely unrelated to the . In the composition example above, the class has an object. implements all the functionality to handle addresses, and other classes can reuse it. Other classes like or can reuse without being related to . They can leverage the same implementation, ensuring that addresses are handled consistently across the application. A problem that you may run into when using composition is that some of your classes may start growing by using multiple components. Your classes may require multiple parameters in the constructor just to pass in the components that they’re made of. This can make your classes hard to use. A way to avoid the problem is by using the factory method to construct your objects. You did that with the composition example. If you look at the implementation of the class, then you’ll notice that it uses to construct an object with the right parameters. This design will work, but ideally, you should be able to construct an object just by specifying an ID, for example . The following changes might improve your design. You can start with the module: First, you make the class internal by prepending an underscore to the class name. Then you provide a internal variable to the module. You’re communicating to other developers that they shouldn’t create or use directly. Instead, you provide two functions, and , as the public interface to the module. This is what other modules should use. What you’re saying is that is a singleton, and there should only be one object created from it. Now, you can do the same with the module: Again, you make internal and provide a public interface to it. The application will use the public interface to get policies and calculate payroll. You’ll now do the same with the module: You’re basically saying that there should only be one , one , and one . Again, this design pattern is called the singleton design pattern, which comes in handy for classes from which there should only be one single instance. Now, you can work on the module. You’ll also mark the as internal and make a singleton out of it, but you’ll make some additional changes: You first import the relevant public functions and classes from other modules. You make internal, and at the bottom, you create a single instance. This instance is public and part of the interface because you’ll want to use it in the application. You changed the attribute to a dictionary where the key is the employee ID and the value is the employee information. You also exposed a method to return the information for the specified employee . The property now sorts the keys to return the employees sorted by their . You replaced the method that constructed the objects with calls to the initializer directly. The class now is initialized with the ID and uses the public functions exposed in the other modules to initialize its attributes. You can now change the program to test the changes: You import the relevant functions from the and modules, as well as the and class. The program is cleaner because you exposed the required interface and encapsulated how to access objects. Notice that you can now create an object directly just using its ID. You can run the program to see its output: The program works the same as before, but now you can see that you can create a single object from its ID and display its dictionary representation. Take a closer look at the class: The class is a composite that contains multiple objects providing different functionality. It contains an that implements all the functionality related to where the employee lives. also contains a productivity role from the module, and a payroll policy from the module. These two objects provide implementations that the class leverages to track work in the method and to calculate the payroll in the method. You’re using composition in two different ways. The class provides additional data to , while the role and payroll objects provide additional behavior. Still, the relationship between and those objects is loosely coupled, which provides some interesting capabilities that you’ll see in the next section. Inheritance, as opposed to composition, is a tightly coupled relationship. With inheritance, there’s only one way to change and customize behavior. Method overriding is the only way to customize the behavior of a base class. This creates rigid designs that are difficult to change. Composition, on the other hand, provides a loosely coupled relationship that enables flexible designs and can be used to change behavior at runtime. Imagine you need to support a long-term disability (LTD) policy when calculating payroll. The policy states that an employee on LTD should be paid 60 percent of their weekly salary, assuming forty hours of work. With an inheritance design, this can be a very difficult requirement to support. Adding it to the composition example is a lot simpler. Start by adding the policy class: Notice that doesn’t inherit from , but implements the same interface. This is because the implementation is completely different, so you don’t want to inherit any of the implementation. The initializes to and provides an internal method that raises an exception if the hasn’t been applied. Then, it provides an method to assign . The public interface first checks that has been applied, and then it implements the functionality in terms of that base policy. The method just delegates to the base policy, and uses it to calculate the and then return the 60 percent. You can now make a small change to the class: You added an method that applies the existing payroll policy to the new policy and then substitutes it. You can now modify the program to apply the policy to an object: The program accesses located at index , creates the object, and applies the policy to the employee. When you call , the change is reflected. You can run the program to evaluate the output: The check amount for employee Kevin Bacon, who’s the sales employee, is now for 1080 dollars instead of 1800 dollars. That’s because the has been applied to the salary. As you can see, you were able to support the changes just by adding a new policy and modifying a couple of interfaces. This is the kind of flexibility that policy design based on composition gives you. Choosing Between Inheritance and Composition in Python Python, as an object-oriented programming language, supports both inheritance and composition. You saw that inheritance is best used to model an is a relationship, whereas composition models a has a relationship. Sometimes, it’s hard to see what the relationship between two classes should be, but you can follow these guidelines:\n• Use inheritance over composition in Python to model a clear is a relationship. First, justify the relationship between the derived class and its base. Then, reverse the relationship and try to justify it. Only if you can’t justify the relationship in both directions should you use inheritance between them.\n• Use inheritance over composition in Python to leverage both the interface and implementation of the base class.\n• Use inheritance over composition in Python to provide mixin features to several unrelated classes when there’s only one implementation of that feature.\n• Use composition over inheritance in Python to model a has a relationship that leverages the implementation of the component class.\n• Use composition over inheritance in Python to create components that multiple classes in your Python applications can reuse.\n• Use composition over inheritance in Python to implement groups of behaviors and policies that can be applied interchangeably to other classes to customize their behavior.\n• Use composition over inheritance in Python to enable runtime behavior changes without affecting existing classes. With that, you have a strong understanding of when to use inheritance vs composition."
    },
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://w3schools.com/python/python_inheritance.asp",
        "document": "Inheritance allows us to define a class that inherits all the methods and properties from another class.\n\nParent class is the class being inherited from, also called base class.\n\nChild class is the class that inherits from another class, also called derived class.\n\nAny class can be a parent class, so the syntax is the same as creating any other class:\n\nTo create a class that inherits the functionality from another class, send the parent class as a parameter when creating the child class:\n\nNow the Student class has the same properties and methods as the Person class.\n\nSo far we have created a child class that inherits the properties and methods from its parent.\n\nWe want to add the function to the child class (instead of the keyword).\n\nWhen you add the function, the child class will no longer inherit the parent's function.\n\nTo keep the inheritance of the parent's function, add a call to the parent's function:\n\nNow we have successfully added the function, and kept the inheritance of the parent class, and we are ready to add functionality in the function.\n\nPython also has a function that will make the child class inherit all the methods and properties from its parent:\n\nBy using the function, you do not have to use the name of the parent element, it will automatically inherit the methods and properties from its parent.\n\nIn the example below, the year should be a variable, and passed into the class when creating student objects. To do so, add another parameter in the function:\n\nIf you add a method in the child class with the same name as a function in the parent class, the inheritance of the parent method will be overridden."
    },
    {
        "link": "https://datacamp.com/tutorial/python-inheritance",
        "document": "Inheritance is one of the foundational pillars of object-oriented programming (OOP) that allows one class (called the child class) to derive attributes and methods from another class (called the parent class). This feature is central to code reuse and simplifies maintenance, making it easier to build scalable and efficient programs.\n\nBefore going further, let's explore the relationship between parent and child classes.\n\nLet’s start with the parent class. A parent class is the base class from which child classes derive. It encapsulates shared attributes and methods.\n\nUsing Python, here is how we define a parent class:\n\nA child class inherits attributes and methods from the parent class. This allows it to use the functionality defined in the parent class. The following code shows how a child class inherits attributes and methods from a parent class:\n\nThis simple syntax allows the child class to utilize and extend the functionality defined in the parent class.\n\nLet’s create a practical example with a class as the parent and a class as the child.\n\nThe class contains shared attributes and a method to display information:\n\nThe class inherits from and adds a new method .\n• The class uses the method from to initialize and .\n• The method is unique to the class, extending its functionality.\n• The method is inherited directly from .\n\nInheritance in Python allows classes to inherit attributes and behaviors from other classes, promoting code reuse and clean design, as we talked about earlier. In this section, we can talk about the different types of Python inheritance, which includes single, multiple, hierarchical, and hybrid inheritance as separate categories.\n\nSingle inheritance occurs when a child class inherits from a single parent class, allowing it to extend the functionality of the parent. This is useful when an object type shares common properties with a broader category but also requires additional attributes or behavior.\n\nThe example I started to work through earlier was single inheritance, but let's now look a bit more closely: In a school management system, all individuals, including students, teachers, and staff, share some common details like and . However, students also have academic records such as grades and enrolled courses. Using single inheritance, we can create a class for shared attributes and extend it with a class for academic details.\n\nHere’s a good example of the above scenario:\n\nThe class inherits the method from but extends it to include and . This is a good example of how single inheritance promotes what is known as modular code.\n\nMultiple inheritance, like a family tree, in a way, allows a child class to inherit from more than one parent class, combining attributes and behaviors from each. This can lead to potential conflicts, which Python resolves using method resolution order (MRO).\n\nWe see that the class inherited attributes and methods from both and . Without any additional effort, the class has access to the method from the parent class and the method from the parent class. We are effectively combining functionality from multiple sources.\n\nHowever, inheriting from multiple classes can lead to conflicts. What if both parent classes define a method or attribute with the same name? I mentioned something about method resolution order earlier but let me know say a little something more about it. Method resolution order determines the order in which classes are searched for methods and attributes. The MRO follows a depth-first, left-to-right approach.\n\nYou can view the MRO of a class using the attribute or the method:\n\nPython also supports more complex inheritance structures. I'll show these more complex ideas using the same example.\n\nMultilevel inheritance happens when a child class inherits from another child class, and that child class inherits from a parent class. This creates a chain of inheritance.\n\nHere, each class in the chain adds something new: manages names and IDs, includes grades, and introduces a thesis. Thanks to , we reuse the initialization logic without duplicating code. It’s efficient, neat, and ensures every level of the “inheritance ladder”, as I think of it, works.\n\nIn hierarchical inheritance, multiple child classes inherit from a single parent class, allowing for shared behavior across subclasses with unique attributes.\n\nLet’s look at a good example together:\n\nHere, the class serves as the foundation, offering common attributes and methods ( , , and ). The and classes then extend this functionality by adding their unique properties ( and ) and customizing the method to reflect their specific contexts.\n\nWith this approach, shared functionality stays in one place (the class), while specialized behavior is neatly encapsulated in the subclasses.\n\nHybrid inheritance combines multiple inheritance types, such as multilevel or multiple inheritance, to model more complex relationships.\n\nLet’s look at an example that shows the complexity of hybrid inheritance.\n\nIn this example, the class demonstrates hybrid inheritance by inheriting attributes and methods from both (which itself inherits from ) and . This combines hierarchical inheritance (where inherits from ) and multiple inheritance (where inherits from both and ).\n\nNow, it's time to see the strengths and weaknesses:\n• Reusability: With inheritance you can write code once in the parent class and reuse it in the child classes. Using the example, both and can inherit a method from the parent class.\n• Simplicity: Inheritance models relationships clearly. A good example is the class which “is-a” type of the parent class.\n• Scalability: It also add new features or child classes without affecting existing code. For example, we can easily add a new class as a child class.\n• Complexity: This won't be surprising, but too many levels of inheritance can make the code hard to follow. For example, if an has too many child classes like , , , etc., it may become confusing.\n• Dependency: Changes to a parent class can unintentionally affect all subclasses. If you modify for example, it might break or .\n• Misuse: Using inheritance when it is not the best fit can complicate designs. You would not want to create a solution where inherits from just to reuse . The relationship doesn’t make sense.\n\nNow that we have explored the basics of inheritance, let’s look at some advanced techniques. These techniques, like method overriding, , abstract base classes, and polymorphism, enhance code flexibility and allow for more sophisticated design patterns.\n\nMethod overriding allows a child class to provide a specific implementation for a method already defined in its parent class. This is useful when the inherited behavior doesn’t fully meet the requirements of the child class.\n\nHere, the class overrides the method from the class to give its own specific implementations. This allows the child class to have its own behavior while still following the same method name.\n\nSo why do we override? We override because we want to customize inherited behavior and also because we want to tailor the functionality of a parent method to a child class’s unique requirements.\n\nThe function is used to call methods in the parent class from the child class. This is particularly useful when you want to extend or modify the functionality of a parent class method, such as the constructor method.\n\nSo why do we use the function? We use the super function because we want to call and initialize the parent class’s constructor and also because we want to avoid explicitly naming the parent class. This is helpful, especially in cases of multiple inheritance.\n\nHere, the class uses to call the method of the parent class, so it does not need to repeat code to initialize the and attributes. The child class then introduces a attribute, which is specific to the class.\n\nAn abstract base class (ABC) is a class that cannot be directly used to create objects. It is meant to define a common set of methods that other classes should implement. So ABCs are useful when you want to ensure that certain methods are always present in the child classes.\n\nThe class here is an abstract class that requires any child class to implement the method. This method is being later implemented by the child class, .\n\nPolymorphism means many shapes. In Python, it allows different classes to use the same method name, but each can implement that method in a different way.\n\nPolymorphism helps us write code that can work with objects of different classes, even if those classes have different behaviors:\n\nIn this example, the function can accept any object of type , but it will call the appropriate method based on whether the object is a or a .\n\nWhile inheritance is powerful, it is easy to misuse. I will share some ideas to help you make the most of the ideas.\n\nWhen a child class overrides a method from its parent, the behavior can change.\n\nFor example, if the parent class has a method, and the child class overrides it without considering all scenarios, it might produce incorrect pay calculations.\n\nThe best practice, in this case, is to always test overridden methods thoroughly and document their behavior.\n\nI know this article is about inheritance, but it is not always the right approach. Sometimes, composition, where you build classes by combining objects rather than extending them might be a better fit with whatever you are doing.\n\nTo distll the differences in the most basic way, think that:\n• Inheritance refers to “Is-a” relationships. For example, a is an .\n• Composition refers to “Has-a” relationships. For example, a has an .\n\nSo, how do you know when composition is the best approach to use? Use composition when the relationship is not strictly hierarchical and/or when you want to reduce tight coupling between classes.\n\nOr, we could also say that, while inheritance models relationships, composition focuses on functionality. To help, consider this:\n• Use inheritance when objects are naturally hierarchical. For example, .\n• Use composition when objects share functionality but are not related. For example, a and both use a .\n\nDeep inheritance chains (many levels of parent-child relationships) can make your code hard to read and maintain. This is a problem because changes to a parent class may unintentionally affect many child classes. Also, debugging becomes complex as behavior is spread across multiple levels.\n\nThe best practice in this case is to keep hierarchies shallow. Also, consider using composition (as I mentioned earlier) or breaking a chain into separate hierarchies if you find it is becoming too deep.\n\nInheritance is a major pillar of object-oriented programming that enables developers like you to create reusable, modular, and scalable code. If you can master inheritance, you will find it easy to simplify complex systems.\n\nA good way to deepen your understanding is to try building inheritance structures in your projects. Start simple, then experiment with more complex hierarchies to see how they work in practice.\n\nIf you are eager to explore even deeper, you can check out our Programming Paradigm Concepts course for a deeper understanding of inheritance and other ideas. Our Python Developer career track is also a good resource that offers a comprehensive path to developing advanced programming skills that will equip you for software development."
    }
]