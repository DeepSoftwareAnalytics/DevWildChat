[
    {
        "link": "https://docs.soliditylang.org",
        "document": "Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.\n\nSolidity is a curly-bracket language designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the language influences section.\n\nSolidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.\n\nWith Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.\n\nWhen deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number to indicate this fast pace of change.\n\nIdeas for improving Solidity or this documentation are always welcome, read our contributors guide for more details.\n\nIf you are new to the concept of smart contracts, we recommend you to get started by digging into the “Introduction to Smart Contracts” section, which covers the following: Once you are accustomed to the basics, we recommend you read the “Solidity by Example” and “Language Description” sections to understand the core concepts of the language. There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the installation page. You can try out code examples directly in your browser with the Remix IDE. Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally. As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the Security Considerations section. If you want to learn more about building decentralized applications on Ethereum, the Ethereum Developer Resources can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks. If you have any questions, you can try searching for answers or asking on the Ethereum StackExchange, or our Gitter channel."
    },
    {
        "link": "https://docs.soliditylang.org/en/latest/contracts.html",
        "document": "Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables in the calling contract are inaccessible. A contract and its functions need to be called for anything to happen. There is no “cron” concept in Ethereum to call a function at a particular event automatically.\n\nContracts can be created “from outside” via Ethereum transactions or from within Solidity contracts. IDEs, such as Remix, make the creation process seamless using UI elements. One way to create contracts programmatically on Ethereum is via the JavaScript API web3.js. It has a function called web3.eth.Contract to facilitate contract creation. When a contract is created, its constructor (a function declared with the keyword) is executed once. A constructor is optional. Only one constructor is allowed, which means overloading is not supported. After the constructor has executed, the final code of the contract is stored on the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor. Internally, constructor arguments are passed ABI encoded after the code of the contract itself, but you do not have to care about this if you use . If a contract wants to create another contract, the source code (and the binary) of the created contract has to be known to the creator. This means that cyclic creation dependencies are impossible. // `TokenCreator` is a contract type that is defined below. // It is fine to reference it as long as it is not used TokenCreator creator // This is the constructor which registers the // creator and the assigned name. // State variables are accessed via their name // and not via e.g. `this.owner`. Functions can // be accessed directly or through `this.f`, // but the latter provides an external view // to the function. Especially in the constructor, // you should not access functions externally, // because the function does not exist yet. // See the next section for details. owner // We perform an explicit type conversion from `address` // to `TokenCreator` and assume that the type of // the calling contract is `TokenCreator`, there is // no real way to verify that. // This does not create a new contract. creator TokenCreator name name_ // Only the creator can alter the name. // We compare the contract based on its // address which can be retrieved by creator name newName // Only the current owner can transfer the token. owner // We ask the creator contract if the transfer // should proceed by using a function of the // the execution also fails here. creator isTokenTransferOK owner newOwner owner newOwner OwnedToken tokenAddress // Create a new `Token` contract and return its address. // From the JavaScript side, the return type // of this function is `address`, as this is // the closest type available in the ABI. OwnedToken name OwnedToken tokenAddress // Again, the external type of `tokenAddress` is tokenAddress changeName name // Perform checks to determine if transferring a token to the pure // Check an arbitrary condition to see if transfer should proceed abi encodePacked currentOwner newOwner\n\nModifiers can be used to change the behavior of functions in a declarative way. For example, you can use a modifier to automatically check a condition prior to executing the function. Modifiers are inheritable properties of contracts and may be overridden by derived contracts, but only if they are marked . For details, please see Modifier Overriding. owner owner // This contract only defines a modifier but does not use // it: it will be used in derived contracts. // The function body is inserted where the special symbol // `_;` in the definition of a modifier appears. // This means that if the owner calls this function, the // function is executed and otherwise, an exception is onlyOwner owner \"Only owner can call this function.\" _ costs price _ priced owned registeredAddresses price initialPrice // It is important to also provide the // `payable` keyword here, otherwise the function will // automatically reject all Ether sent to it. costs price registeredAddresses // This contract inherits the `onlyOwner` modifier from // the `owned` contract. As a result, calls to `changePrice` will // only take effect if they are made by the stored owner. onlyOwner price price_ noReentrancy locked locked _ locked /// This function is protected by a mutex, which means that /// reentrant calls from within `msg.sender.call` cannot call `f` again. /// The `return 7` statement assigns 7 to the return value but still /// executes the statement `locked = false` in the modifier. noReentrancy call success If you want to access a modifier defined in a contract , you can use to reference it without virtual lookup. It is only possible to use modifiers defined in the current contract or its base contracts. Modifiers can also be defined in libraries but their use is limited to functions of the same library. Multiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented. Modifiers cannot implicitly access or change the arguments and return values of functions they modify. Their values can only be passed to them explicitly at the point of invocation. In function modifiers, it is necessary to specify when you want the function to which the modifier is applied to be run. The placeholder statement (denoted by a single underscore character ) is used to denote where the body of the function being modified should be inserted. Note that the placeholder operator is different from using underscores as leading or trailing characters in variable names, which is a stylistic choice. Explicit returns from a modifier or function body only leave the current modifier or function body. Return variables are assigned and control flow continues after the in the preceding modifier. In an earlier version of Solidity, statements in functions having modifiers behaved differently. An explicit return from a modifier with does not affect the values returned by the function. The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their default values just as if the function had an empty body. The symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence. Arbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).\n\nTransient storage is another data location besides memory, storage, calldata (and return-data and code) which was introduced alongside its respective opcodes and by EIP-1153. This new data location behaves as a key-value store similar to storage with the main difference being that data in transient storage is not permanent, but is scoped to the current transaction only, after which it will be reset to zero. Since the content of transient storage has very limited lifetime and size, it does not need to be stored permanently as a part of state and the associated gas costs are much lower than in case of storage. EVM version or newer is required for transient storage to be available. Transient storage variables cannot be initialized in place, i.e., they cannot be assigned to upon declaration, since the value would be cleared at the end of the creation transaction, rendering the initialization ineffective. Transient variables will be default value initialized depending on their underlying type. and variables conflict with transient storage, since their values are either inlined or directly stored in code. Transient storage variables have completely independent address space from storage, so that the order of transient state variables does not affect the layout of storage state variables and vice-versa. They do need distinct names though because all state variables share the same namespace. It is also important to note that the values in transient storage are packed in the same fashion as those in persistent storage. See Storage Layout for more information. Besides that, transient variables can have visibility as well and ones will have a getter function generated automatically as usual. Note that, currently, such use of as a data location is only allowed for value type state variable declarations. Reference types, such as arrays, mappings and structs, as well as local or parameter variables are not yet supported. An expected canonical use case for transient storage is cheaper reentrancy locks, which can be readily implemented with the opcodes as showcased next. sentGifts locked nonReentrant locked locked _ // After the function exits, it can be called again, even in the same transaction. locked nonReentrant balance ether sentGifts call value ether success // In a reentrant function, doing this last would open up the vulnerability sentGifts Transient storage is private to the contract that owns it, in the same way as persistent storage. Only owning contract frames may access their transient storage, and when they do, all the frames access the same transient store. Transient storage is part of the EVM state and is subject to the same mutability enforcements as persistent storage. As such, any read access to it is not and writing access is not . If the opcode is called within the context of a , it will result in an exception instead of performing the modification. is allowed within the context of a . When transient storage is used in the context of or , then the owning contract of the transient storage is the contract that issued or instruction (the caller) as with persistent storage. When transient storage is used in the context of or , then the owning contract of the transient storage is the contract that is the target of the or instruction (the callee). In the case of , since references to transient storage variables are currently not supported, it is not possible to pass those into library calls. In libraries, access to transient storage is only possible using inline assembly. If a frame reverts, all writes to transient storage that took place between entry to the frame and the return are reverted, including those that took place in inner calls. The caller of an external call may employ a block to prevent reverts bubbling up from the inner calls.\n\nState variables can be declared as or . In both cases, the variables cannot be modified after the contract has been constructed. For variables, the value has to be fixed at compile-time, while for , it can still be assigned at construction time. It is also possible to define variables at the file level. Every occurrence of such a variable in the source is replaced by its underlying value and the compiler does not reserve a storage slot for it. It cannot be assigned a slot in transient storage using the keyword either. Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. Not all types for constants and immutables are implemented at this time. The only supported types are strings (only for constants) and value types. X TEXT MY_HASH decimals maxBalance owner decimals_ // Immutables are only immutable when deployed. // At construction time they can be assigned to any number of times. decimals decimals_ // Assignments to immutables can even access the environment. maxBalance ref balance view other balance maxBalance For variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared. Any expression that accesses storage, blockchain data (e.g. , or ) or execution data ( or ) or makes calls to external contracts is disallowed. Expressions that might have a side-effect on memory allocation are allowed, but those that might have a side-effect on other memory objects are not. The built-in functions , , , , and are allowed (even though, with the exception of , they do call external contracts). The reason behind allowing side-effects on the memory allocator is that it should be possible to construct complex objects like e.g. lookup-tables. This feature is not yet fully usable. Variables declared as are a bit less restricted than those declared as : Immutable variables can be assigned a value at construction time. The value can be changed at any time before deployment and then it becomes permanent. One additional restriction is that immutables can only be assigned to inside expressions for which there is no possibility of being executed after creation. This excludes all modifier definitions and functions other than constructors. There are no restrictions on reading immutable variables. The read is even allowed to happen before the variable is written to for the first time because variables in Solidity always have a well-defined initial value. For this reason it is also allowed to never explicitly assign a value to an immutable. When accessing immutables at construction time, please keep the initialization order in mind. Even if you provide an explicit initializer, some expressions may end up being evaluated before that initializer, especially when they are at a different level in inheritance hierarchy. Before Solidity 0.8.21 initialization of immutable variables was more restrictive. Such variables had to be initialized exactly once at construction time and could not be read before then. The contract creation code generated by the compiler will modify the contract’s runtime code before it is returned by replacing all references to immutables with the values assigned to them. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain. The compiler outputs where these immutables are located in the deployed bytecode in the field of the compiler JSON standard output.\n\nFunctions can be defined inside and outside of contracts. Functions outside of a contract, also called “free functions”, always have implicit visibility. Their code is included in all contracts that call them, similar to internal library functions. arr pure i arr length i s arr i arr // The compiler will add its code to the contract. sum arr s found Functions defined outside a contract are still always executed in the context of a contract. They still can call other contracts, send them Ether and destroy the contract that called them, among other things. The main difference to functions defined inside a contract is that free functions do not have direct access to the variable , storage variables and functions not in their scope. Functions take typed parameters as input and may, unlike in many other languages, also return an arbitrary number of values as output. Function parameters are declared the same way as variables, and the name of unused parameters can be omitted. For example, if you want your contract to accept one kind of external call with two integers, you would use something like the following: Function parameters can be used as any other local variable and they can also be assigned to. Function return variables are declared with the same syntax after the keyword. For example, suppose you want to return two results: the sum and the product of two integers passed as function parameters, then you use something like: The names of return variables can be omitted. Return variables can be used as any other local variable and they are initialized with their default value and have that value until they are (re-)assigned. You can either explicitly assign to return variables and then leave the function as above, or you can provide return values (either a single or multiple ones) directly with the statement: If you use an early to leave a function that has return variables, you must provide return values together with the return statement. You cannot return some types from non-internal functions. This includes the types listed below and any composite types that recursively contain them: This restriction does not apply to library functions because of their different internal ABI. When a function has multiple return types, the statement can be used to return multiple values. The number of components must be the same as the number of return variables and their types have to match, potentially after an implicit conversion. Functions can be declared in which case they promise not to modify the state. If the compiler’s EVM target is Byzantium or newer (default) the opcode is used when functions are called, which enforces the state to stay unmodified as part of the EVM execution. For library functions is used, because there is no combined and . This means library functions do not have run-time checks that prevent state modifications. This should not impact security negatively because library code is usually known at compile-time and the static checker performs compile-time checks. The following statements are considered modifying the state:\n• None Calling any function not marked or .\n• None Using inline assembly that contains certain opcodes. on functions used to be an alias to , but this was dropped in version 0.5.0. Prior to version 0.5.0, the compiler did not use the opcode for functions. This enabled state modifications in functions through the use of invalid explicit type conversions. By using for functions, modifications to the state are prevented on the level of the EVM. Functions can be declared in which case they promise not to read from or modify the state. In particular, it should be possible to evaluate a function at compile-time given only its inputs and , but without any knowledge of the current blockchain state. This means that reading from variables can be a non-pure operation. If the compiler’s EVM target is Byzantium or newer (default) the opcode is used, which does not guarantee that the state is not read, but at least that it is not modified. In addition to the list of state modifying statements explained above, the following are considered reading from the state:\n• None Accessing any of the members of , , (with the exception of and ).\n• None Using inline assembly that contains certain opcodes. Pure functions are able to use the and functions to revert potential state changes when an error occurs. Reverting a state change is not considered a “state modification”, as only changes to the state made previously in code that did not have the or restriction are reverted and that code has the option to catch the and not pass it on. This behavior is also in line with the opcode. It is not possible to prevent functions from reading the state at the level of the EVM, it is only possible to prevent them from writing to the state (i.e. only can be enforced at the EVM level, can not). Prior to version 0.5.0, the compiler did not use the opcode for functions. This enabled state modifications in functions through the use of invalid explicit type conversions. By using for functions, modifications to the state are prevented on the level of the EVM. Prior to version 0.4.17 the compiler did not enforce that is not reading the state. It is a compile-time type check, which can be circumvented by doing invalid explicit conversions between contract types, because the compiler can verify that the type of the contract does not do state-changing operations, but it cannot check that the contract that will be called at runtime is actually of that type. A contract can have at most one function, declared using (without the keyword). This function cannot have arguments, cannot return anything and must have visibility and state mutability. It can be virtual, can override and can have modifiers. The receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via or ). If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through a transaction that does not represent a payable function call and throws an exception. In the worst case, the function can only rely on 2300 gas being available (for example when or is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend:\n• None Calling an external function which consumes a large amount of gas When Ether is sent directly to a contract (without a function call, i.e. sender uses or ) but the receiving contract does not define a receive Ether function or a payable fallback function, an exception will be thrown, sending back the Ether (this was different before Solidity v0.4.0). If you want your contract to receive Ether, you have to implement a receive Ether function (using payable fallback functions for receiving Ether is not recommended, since the fallback is invoked and would not fail for interface confusions on the part of the sender). A contract without a receive Ether function can receive Ether as a recipient of a coinbase transaction (aka miner block reward) or as a destination of a . A contract cannot react to such Ether transfers and thus also cannot reject them. This is a design choice of the EVM and Solidity cannot work around it. It also means that can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the receive Ether function). Below you can see an example of a Sink contract that uses function . // This contract keeps all Ether sent to it with no way receive emit Received A contract can have at most one function, declared using either or (both without the keyword). This function must have visibility. A fallback function can be virtual, can override and can have modifiers. The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked . If the version with parameters is used, will contain the full data sent to the contract (equal to ) and can return data in . The returned data will not be ABI-encoded. Instead it will be returned without modifications (not even padding). In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see receive Ether function for a brief description of the implications of this). Like any function, the fallback function can execute complex operations as long as there is enough gas passed on to it. A fallback function is also executed for plain Ether transfers, if no receive Ether function is present. It is recommended to always define a receive Ether function as well, if you define a payable fallback function to distinguish Ether transfers from interface confusions. If you want to decode the input data, you can check the first four bytes for the function selector and then you can use together with the array slice syntax to decode ABI-encoded data: Note that this should only be used as a last resort and proper functions should be used instead. // This function is called for all messages sent to // this contract (there is no other function). // Sending Ether to this contract will cause an exception, // because the fallback function does not have the `payable` fallback x // This function is called for all messages sent to // (there is no other function except the receive function). // Any call with non-empty calldata to this contract will execute // the fallback function (even if Ether is sent along with the call). fallback x y // This function is called for plain Ether transfers, i.e. // for every call with empty calldata. receive x y Test test test call abi encodeWithSignature success // address(test) will not allow to call ``send`` directly, since ``test`` has no payable // It has to be converted to the ``address payable`` type to even allow calling ``send`` on it. testPayable test // If someone sends Ether to that contract, // the transfer will fail, i.e. this returns false here. testPayable send ether TestPayable test test call abi encodeWithSignature success // results in test.x becoming == 1 and test.y becoming 0. success test call value abi encodeWithSignature success // results in test.x becoming == 1 and test.y becoming 1. // If someone sends Ether to that contract, the receive function in TestPayable will be called. // Since that function writes to storage, it takes more gas than is available with a // simple ``send`` or ``transfer``. Because of that, we have to use a low-level call. success test call value ether success // results in test.x becoming == 2 and test.y becoming 2 ether. A contract can have multiple functions of the same name but with different parameter types. This process is called “overloading” and also applies to inherited functions. The following example shows overloading of the function in the scope of contract . pure out value pure really out value Overloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types. B value pure B out out value pure out value Both function overloads above end up accepting the address type for the ABI although they are considered different inside Solidity. Overloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call. Functions are selected as overload candidates if all arguments can be implicitly converted to the expected types. If there is not exactly one candidate, resolution fails. Return parameters are not taken into account for overload resolution. Calling would create a type error since can be implicitly converted both to and types. On another hand would resolve to overload as cannot be implicitly converted to .\n\nSolidity events give an abstraction on top of the EVM’s logging functionality. Applications can subscribe and listen to these events through the RPC interface of an Ethereum client. Events can be defined at file level or as inheritable members of contracts (including interfaces and libraries). When you call them, they cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible (forever as of now, but this might change in the future). The Log and its event data is not accessible from within contracts (not even from the contract that created them). It is possible to request a Merkle proof for logs, so if an external entity supplies a contract with such a proof, it can check that the log actually exists inside the blockchain. You have to supply block headers because the contract can only see the last 256 block hashes. You can add the attribute to up to three parameters which adds them to a special data structure known as “topics” instead of the data part of the log. A topic can only hold a single word (32 bytes) so if you use a reference type for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead. All parameters without the attribute are ABI-encoded into the data part of the log. Topics allow you to search for events, for example when filtering a sequence of blocks for certain events. You can also filter events by the address of the contract that emitted the event. For example, the code below uses the web3.js method to filter logs that match a topic with a certain address value: The hash of the signature of the event is one of the topics, except if you declared the event with the specifier. This means that it is not possible to filter for specific anonymous events by name, you can only filter by the contract address. The advantage of anonymous events is that they are cheaper to deploy and call. It also allows you to declare four indexed arguments rather than three. Since the transaction log only stores the event data and not the type, you have to know the type of the event, including which parameter is indexed and if the event is anonymous in order to correctly interpret the data. In particular, it is possible to “fake” the signature of another event using an anonymous event.\n• None : For non-anonymous events, this is a value containing the hash of the event signature, as used in the default topic. from id // Events are emitted using `emit`, followed by // the name of the event and the arguments // (if any) in parentheses. Any such invocation // (even deeply nested) can be detected from // the JavaScript API by filtering for `Deposit`. emit Deposit id The use in the JavaScript API is as follows: /* abi as generated by the compiler */ // given to the `Deposit` call. The output of the above looks like the following (trimmed):\n\nErrors in Solidity provide a convenient and gas-efficient way to explain to the user why an operation failed. They can be defined inside and outside of contracts (including interfaces and libraries). They have to be used together with the revert statement or the require function. In the case of statements, or calls where the condition is evaluated to be false, all changes in the current call are reverted, and the error data passed back to the caller. The example below shows custom error usage with the statement in function , as well as the newer approach with in function . /// Insufficient balance for transfer. Needed `required` but only error InsufficientBalance balance amount balance revert InsufficientBalance available balance required amount balance amount balance to amount amount balance InsufficientBalance balance amount balance amount balance to amount Another important detail to mention when it comes to using with custom errors, is that memory allocation for the error-based revert reason will only happen in the reverting case, which, along with optimization of constants and string literals makes this about as gas-efficient as the pattern. Errors cannot be overloaded or overridden but are inherited. The same error can be defined in multiple places as long as the scopes are distinct. Instances of errors can only be created using statements, or as the second argument to functions. The error creates data that is then passed to the caller with the revert operation to either return to the off-chain component or catch it in a try/catch statement. Note that an error can only be caught when coming from an external call, reverts happening in internal calls or inside the same function cannot be caught. If you do not provide any parameters, the error only needs four bytes of data and you can use NatSpec as above to further explain the reasons behind the error, which is not stored on chain. This makes this a very cheap and convenient error-reporting feature at the same time. More specifically, an error instance is ABI-encoded in the same way as a function call to a function of the same name and types would be and then used as the return data in the opcode. This means that the data consists of a 4-byte selector followed by ABI-encoded data. The selector consists of the first four bytes of the keccak256-hash of the signature of the error type. It is possible for a contract to revert with different errors of the same name or even with errors defined in different places that are indistinguishable by the caller. For the outside, i.e. the ABI, only the name of the error is relevant, not the contract or file where it is defined. The statement would be equivalent to if you could define . Note, however, that is a built-in type and cannot be defined in user-supplied code. Similarly, a failing or similar conditions will revert with an error of the built-in type . Error data should only be used to give an indication of failure, but not as a means for control-flow. The reason is that the revert data of inner calls is propagated back through the chain of external calls by default. This means that an inner call can “forge” revert data that looks like it could have come from the contract that called it.\n• None : A value containing the error selector.\n\nPolymorphism means that a function call (internal and external) always executes the function of the same name (and parameter types) in the most derived contract in the inheritance hierarchy. This has to be explicitly enabled on each function in the hierarchy using the and keywords. See Function Overriding for more details. It is possible to call functions further up in the inheritance hierarchy internally by explicitly specifying the contract using or using if you want to call the function one level higher up in the flattened inheritance hierarchy (see below). When a contract inherits from other contracts, only a single contract is created on the blockchain, and the code from all the base contracts is compiled into the created contract. This means that all internal calls to functions of base contracts also just use internal function calls ( will use JUMP and not a message call). State variable shadowing is considered as an error. A derived contract can only declare a state variable , if there is no visible state variable with the same name in any of its bases. The general inheritance system is very similar to Python’s, especially concerning multiple inheritance, but there are also some differences. Details are given in the following example. owner owner // Use `is` to derive from another contract. Derived // internal functions and state variables. These cannot be // accessed externally via `this`, though. Owned // The keyword `virtual` means that the function can change virtual owner emit Emitted // These abstract contracts are only provided to make the // interface known to the compiler. Note the function // without body. If a contract does not implement all // functions it can only be used as an interface. abstract virtual abstract virtual virtual // Multiple inheritance is possible. Note that `Owned` is // also a base class of `Emittable`, yet there is only a single // instance of `Owned` (as for virtual inheritance in C++). Owned Emittable Config config Config NameReg config lookup register name // Functions can be overridden by another function with the same name and // the same number/types of inputs. If the overriding function has different // types of output parameters, that causes an error. // Both local and message-based function calls take these overrides // If you want the function to override, you need to use the // `override` keyword. You need to specify the `virtual` keyword again // if you want this function to be overridden again. virtual override owner Config config Config NameReg config lookup unregister // It is still possible to call a specific Emittable emitEvent // If a constructor takes an argument, it needs to be // provided in the header or modifier-invocation-style at // the constructor of the derived contract (see below). Owned Emittable Named owner info newInfo // Here, we only specify `override` and not `virtual`. // This means that contracts deriving from `PriceFeed` // cannot change the behavior of `emitEvent` anymore. override Emittable Named Named emitEvent view info Note that above, we call to “forward” the emit event request. The way this is done is problematic, as seen in the following example: owner owner Owned virtual owner emit Emitted Emittable virtual override /* Here, we emit an event to simulate some Base1 logic */ emit Base1Emitted Emittable emitEvent Emittable virtual override /* Here, we emit an event to simulate some Base2 logic */ emit Base2Emitted Emittable emitEvent Base1 Base2 override Base1 Base2 /* Here, we emit an event to simulate some Final logic */ emit FinalEmitted Base2 emitEvent A call to will call because we specify it explicitly in the final override, but this function will bypass , resulting in the following sequence of events: , instead of the expected sequence: . The way around this is to use : owner owner Owned virtual owner emit Emitted Emittable virtual override /* Here, we emit an event to simulate some Base1 logic */ emit Base1Emitted super emitEvent Emittable virtual override /* Here, we emit an event to simulate some Base2 logic */ emit Base2Emitted super emitEvent Base1 Base2 override Base1 Base2 /* Here, we emit an event to simulate some Final logic */ emit FinalEmitted super emitEvent If calls a function of , it does not simply call this function on one of its base contracts. Rather, it calls this function on the next base contract in the final inheritance graph, so it will call (note that the final inheritance sequence is – starting with the most derived contract: Final, Base2, Base1, Emittable, Owned). The actual function that is called when using super is not known in the context of the class where it is used, although its type is known. This is similar for ordinary virtual method lookup. Base functions can be overridden by inheriting contracts to change their behavior if they are marked as . The overriding function must then use the keyword in the function header. The overriding function may only change the visibility of the overridden function from to . The mutability may be changed to a more strict one following the order: can be overridden by and . can be overridden by . is an exception and cannot be changed to any other mutability. The following example demonstrates changing mutability and visibility: For multiple inheritance, the most derived base contracts that define the same function must be specified explicitly after the keyword. In other words, you have to specify all base contracts that define the same function and have not yet been overridden by another base contract (on some path through the inheritance graph). Additionally, if a contract inherits the same function from multiple (unrelated) bases, it has to explicitly override it: virtual virtual Base1 Base2 // Derives from multiple bases defining foo(), so we must explicitly override Base1 Base2 An explicit override specifier is not required if the function is defined in a common base contract or if there is a unique function in a common base contract that already overrides all other functions. More formally, it is not required to override a function (directly or indirectly) inherited from multiple bases if there is a base contract that is part of all override paths for the signature, and (1) that base implements the function and no paths from the current contract to the base mentions a function with that signature or (2) that base does not implement the function and there is at most one mention of the function in all paths from the current contract to that base. In this sense, an override path for a signature is a path through the inheritance graph that starts at the contract under consideration and ends at a contract mentioning a function with that signature that does not override. If you do not mark a function that overrides as , derived contracts can no longer change the behavior of that function. Functions with the visibility cannot be . Functions without implementation have to be marked outside of interfaces. In interfaces, all functions are automatically considered . Starting from Solidity 0.8.8, the keyword is not required when overriding an interface function, except for the case where the function is defined in multiple bases. Public state variables can override external functions if the parameter and return types of the function matches the getter function of the variable: While public state variables can override external functions, they themselves cannot be overridden. Function modifiers can override each other. This works in the same way as function overriding (except that there is no overloading for modifiers). The keyword must be used on the overridden modifier and the keyword must be used in the overriding modifier: In case of multiple inheritance, all direct base contracts must be specified explicitly: A constructor is an optional function declared with the keyword which is executed upon contract creation, and where you can run contract initialization code. Before the constructor code is executed, state variables are initialised to their specified value if you initialise them inline, or their default value if you do not. After the constructor has run, the final code of the contract is deployed to the blockchain. The deployment of the code costs additional gas linear to the length of the code. This code includes all functions that are part of the public interface and all functions that are reachable from there through function calls. It does not include the constructor code or internal functions that are only called from the constructor. If there is no constructor, the contract will assume the default constructor, which is equivalent to . For example: You can use internal parameters in a constructor (for example storage pointers). In this case, the contract has to be marked abstract, because these parameters cannot be assigned valid values from outside but only through the constructors of derived contracts. Prior to version 0.4.22, constructors were defined as functions with the same name as the contract. This syntax was deprecated and is not allowed anymore in version 0.5.0. Prior to version 0.7.0, you had to specify the visibility of constructors as either or . The constructors of all the base contracts will be called following the linearization rules explained below. If the base constructors have arguments, derived contracts need to specify all of them. This can be done in two ways: x x_ // Either directly specify in the inheritance list... Base // or through a \"modifier\" of the derived constructor... Base Base y y abstract Base // and have the next concrete derived contract initialize it. Derived3 Base One way is directly in the inheritance list ( ). The other is in the way a modifier is invoked as part of the derived constructor ( ). The first way to do it is more convenient if the constructor argument is a constant and defines the behavior of the contract or describes it. The second way has to be used if the constructor arguments of the base depend on those of the derived contract. Arguments have to be given either in the inheritance list or in modifier-style in the derived constructor. Specifying arguments in both places is an error. If a derived contract does not specify the arguments to all of its base contracts’ constructors, it must be declared abstract. In that case, when another contract derives from it, that other contract’s inheritance list or constructor must provide the necessary parameters for all base classes that haven’t had their parameters specified (otherwise, that other contract must be declared abstract as well). For example, in the above code snippet, see and . Languages that allow multiple inheritance have to deal with several problems. One is the Diamond Problem. Solidity is similar to Python in that it uses “C3 Linearization” to force a specific order in the directed acyclic graph (DAG) of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs. Especially, the order in which the base classes are given in the directive is important: You have to list the direct base contracts in the order from “most base-like” to “most derived”. Note that this order is the reverse of the one used in Python. Another simplifying way to explain this is that when a function is called that is defined multiple times in different contracts, the given bases are searched from right to left (left to right in Python) in a depth-first manner, stopping at the first match. If a base contract has already been searched, it is skipped. In the following code, Solidity will give the error “Linearization of inheritance graph impossible”. The reason for this is that requests to override (by specifying in this order), but itself requests to override , which is a contradiction that cannot be resolved. Due to the fact that you have to explicitly override a function that is inherited from multiple bases without a unique override, C3 linearization is not too important in practice. One area where inheritance linearization is especially important and perhaps not as clear is when there are multiple constructors in the inheritance hierarchy. The constructors will always be executed in the linearized order, regardless of the order in which their arguments are provided in the inheriting contract’s constructor. For example: // Constructors are executed in the following order: Base1 Base2 Base1 Base2 // Constructors are executed in the following order: Base2 Base1 Base2 Base1 // Constructors are still executed in the following order: Base2 Base1 Base1 Base2 Inheriting Different Kinds of Members of the Same Name The only situations where, due to inheritance, a contract may contain multiple definitions sharing the same name are:\n\nLibraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused using the ( until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, i.e. points to the calling contract, and especially the storage from the calling contract can be accessed. As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied (it would have no way to name them, otherwise). Library functions can only be called directly (i.e. without the use of ) if they do not modify the state (i.e. if they are or functions), because libraries are assumed to be stateless. In particular, it is not possible to destroy a library. Until version 0.4.20, it was possible to destroy libraries by circumventing Solidity’s type system. Starting from that version, libraries contain a mechanism that disallows state-modifying functions to be called directly (i.e. without ). Libraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like ). Of course, calls to internal functions use the internal calling convention, which means that all internal types can be passed and types stored in memory will be passed by reference and not copied. To realize this in the EVM, the code of internal library functions that are called from a contract and all functions called from therein will at compile time be included in the calling contract, and a regular call will be used instead of a . The inheritance analogy breaks down when it comes to public functions. Calling a public library function with results in an external call ( to be precise). In contrast, is an internal call when is a base contract of the current contract. The following example illustrates how to use libraries (but using a manual method, be sure to check out using for for a more advanced example to implement a set). // We define a new struct datatype that will be used to // hold its data in the calling contract. flags Set // Note that the first parameter is of type \"storage // reference\" and thus only its storage address and not // its contents is passed as part of the call. This is a // special feature of library functions. It is idiomatic // to call the first parameter `self`, if the function can // be seen as a method of that object. Data storage self self flags value self flags value Data storage self self flags value self flags value Data storage self view self flags value Data knownValues // The library functions can be called without a // specific instance of the library, since the // \"instance\" will be the current contract. Set insert knownValues value // In this contract, we can also directly access knownValues.flags, if we want. Of course, you do not have to follow this way to use libraries: they can also be used without defining struct data types. Functions also work without any storage reference parameters, and they can have multiple storage reference parameters and in any position. The calls to , and are all compiled as calls ( ) to an external contract/library. If you use libraries, be aware that an actual external function call is performed. , and will retain their values in this call, though (prior to Homestead, because of the use of , and changed, though). The following example shows how to use types stored in memory and internal functions in libraries in order to implement custom types without the overhead of external function calls: limbs BigInt pure bigint r r limbs r limbs x bigint a bigint b pure bigint r r limbs max a limbs length b limbs length i r limbs length i limb a i limb b i unchecked r limbs i limbA limbB carry limbA limbB limbA limbA limbB type max carry carry carry carry // too bad, we have to add a limb newLimbs r limbs length i i r limbs length i newLimbs i r limbs i newLimbs i carry r limbs newLimbs bigint a pure index a limbs length a limbs index pure a b a b using BigInt bigint pure bigint x BigInt fromUint bigint y BigInt fromUint type max bigint z x add y assert z limb It is possible to obtain the address of a library by converting the library type to the type, i.e. using . As the compiler does not know the address where the library will be deployed, the compiled hex code will contain placeholders of the form (format was different <v0.5.0). The placeholder is a 34 character prefix of the hex encoding of the keccak256 hash of the fully qualified library name, which would be for example if the library was stored in a file called in a directory. Such bytecode is incomplete and should not be deployed. Placeholders need to be replaced with actual addresses. You can do that by either passing them to the compiler when the library is being compiled or by using the linker to update an already compiled binary. See Library Linking for information on how to use the commandline compiler for linking. In comparison to contracts, libraries are restricted in the following ways:\n• None they cannot have state variables\n• None they cannot inherit nor be inherited While external calls to public or external library functions are possible, the calling convention for such calls is considered to be internal to Solidity and not the same as specified for the regular contract ABI. External library functions support more argument types than external contract functions, for example recursive structs and storage pointers. For that reason, the function signatures used to compute the 4-byte selector are computed following an internal naming schema and arguments of types not supported in the contract ABI use an internal encoding. The following identifiers are used for the types in the signatures:\n• None Value types, non-storage and non-storage use the same identifiers as in the contract ABI.\n• None Non-storage array types follow the same convention as in the contract ABI, i.e. for dynamic arrays and for fixed-size arrays of elements.\n• None Non-storage structs are referred to by their fully qualified name, i.e. for .\n• None Storage pointer mappings use where and are the identifiers for the key and value types of the mapping, respectively.\n• None Other storage pointer types use the type identifier of their corresponding non-storage type, but append a single space followed by to it. The argument encoding is the same as for the regular contract ABI, except for storage pointers, which are encoded as a value referring to the storage slot to which they point. Similarly to the contract ABI, the selector consists of the first four bytes of the Keccak256-hash of the signature. Its value can be obtained from Solidity using the member as follows: As mentioned in the introduction, if a library’s code is executed using a instead of a or , it will revert unless a or function is called. The EVM does not provide a direct way for a contract to detect whether it was called using or not, but a contract can use the opcode to find out “where” it is currently running. The generated code compares this address to the address used at construction time to determine the mode of calling. More specifically, the runtime code of a library always starts with a push instruction, which is a zero of 20 bytes at compilation time. When the deploy code runs, this constant is replaced in memory by the current address and this modified code is stored in the contract. At runtime, this causes the deploy time address to be the first constant to be pushed onto the stack and the dispatcher code compares the current address against this constant for any non-view and non-pure function. This means that the actual code stored on chain for a library is different from the code reported by the compiler as .\n\nThe directive can be used to attach functions ( ) as operators to user-defined value types or as member functions to any type ( ). The member functions receive the object they are called on as their first parameter (like the variable in Python). The operator functions receive operands as parameters. It is valid either at file level or inside a contract, at contract level. The first part, , can be one of:\n• None A list of functions, optionally with an operator name assigned (e.g. using {f, g as +, h, L.t} for uint ). If no operator is specified, the function can be either a library function or a free function and is attached to the type as a member function. Otherwise it must be a free function and it becomes the definition of that operator on the type.\n• None The name of a library (e.g. ) - all non-private functions of the library are attached to the type as member functions At file level, the second part, , has to be an explicit type (without data location specifier). Inside contracts, you can also use in place of the type (e.g. ), which has the effect that all functions of the library are attached to all types. If you specify a library, all non-private functions in the library get attached, even those where the type of the first parameter does not match the type of the object. The type is checked at the point the function is called and function overload resolution is performed. If you use a list of functions (e.g. ), then the type ( ) has to be implicitly convertible to the first parameter of each of these functions. This check is performed even if none of these functions are called. Note that private library functions can only be specified when is inside a library. If you define an operator (e.g. using {f as +} for T ), then the type ( ) must be a user-defined value type and the definition must be a function. Operator definitions must be global. The following operators can be defined this way: Note that unary and binary need separate definitions. The compiler will choose the right definition based on how the operator is invoked. The directive is active only within the current scope (either the contract or the current module/source unit), including within all of its functions, and has no effect outside of the contract or module in which it is used. When the directive is used at file level and applied to a user-defined type which was defined at file level in the same file, the word can be added at the end. This will have the effect that the functions and operators are attached to the type everywhere the type is available (including other files), not only in the scope of the using statement. Let us rewrite the set example from the Libraries section in this way, using file-level functions instead of library functions. flags // Now we attach functions to the type. // The attached functions can be used throughout the rest of the module. // If you import the module, you have to // repeat the using directive there, for example as using insert remove contains Data Data storage self self flags value self flags value Data storage self self flags value self flags value Data storage self view self flags value Data knownValues // Here, all variables of type Data have // The following function call is identical to knownValues insert value It is also possible to extend built-in types in that way. In this example, we will use a library. Search storage self view i self length i self i value i type max using Search data data push value data indexOf from index type max data push to data index to Note that all external library calls are actual EVM function calls. This means that if you pass memory or value types, a copy will be performed, even in case of the variable. The only situation where no copy will be performed is when storage reference variables are used or when internal library functions are called. Another example shows how to define a custom operator for a user-defined type: type UFixed16x2 using add as div as UFixed16x2 global SCALE UFixed16x2 a UFixed16x2 b pure UFixed16x2 UFixed16x2 wrap UFixed16x2 unwrap a UFixed16x2 unwrap b UFixed16x2 a UFixed16x2 b pure UFixed16x2 UFixed16x2 unwrap a UFixed16x2 unwrap b a32 SCALE b32 result32 type max UFixed16x2 wrap a32 SCALE b32 UFixed16x2 a UFixed16x2 b pure UFixed16x2 a b UFixed16x2 wrap"
    },
    {
        "link": "https://docs.soliditylang.org/_/downloads/en/latest/pdf",
        "document": ""
    },
    {
        "link": "https://medium.com/@maria.magdalena.makeup/%EF%B8%8Funderstanding-griefing-in-solidity-contracts-a-real-life-example-and-mitigation-strategies-ca45dd235c6b",
        "document": "Let’s dive into a practical example of how griefing can occur in a Solidity smart contract through a “block gas limit attack.”\n\nImagine a decentralized application that allows users to execute complex financial transactions within a smart contract. The contract is designed with efficiency in mind, ensuring that most legitimate operations stay well within Ethereum’s block gas limit. However, an attacker could exploit this by performing a block gas limit attack, effectively disrupting the dApp.\n\nHere’s an example of a simple smart contract that could be vulnerable to such an attack:\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n\n\ncontract VulnerableContract {\n\n // A simple storage mapping\n\n mapping(address => uint256) public balances;\n\n\n\n // Function to deposit Ether into the contract\n\n function deposit() external payable {\n\n balances[msg.sender] += msg.value;\n\n }\n\n\n\n // Function that an attacker could abuse\n\n function complexOperation(uint256 iterations) external {\n\n // This loop is intentionally vulnerable to high gas consumption\n\n for (uint256 i = 0; i < iterations; i++) {\n\n // Perform some expensive operation\n\n // For demonstration, we'll just update a balance repeatedly\n\n balances[msg.sender] += i;\n\n }\n\n }\n\n\n\n // Function to withdraw Ether\n\n function withdraw() external {\n\n uint256 amount = balances[msg.sender];\n\n require(amount > 0, \"No balance to withdraw\");\n\n balances[msg.sender] = 0;\n\n payable(msg.sender).transfer(amount);\n\n }\n\n}\n\nIn this scenario, an attacker can exploit the function, which allows them to specify the number of iterations for a loop. By setting a very high number of iterations, the attacker forces the contract to consume a large amount of gas:\n\nThis transaction consumes so much gas that it can fill an entire Ethereum block, preventing other legitimate transactions from being processed. The result is network congestion, delayed transactions, and increased gas fees for all users interacting with the protocol.\n• Users: Legitimate users of the dApp experience delays because their transactions can’t be included in blocks immediately. Additionally, as the network becomes more congested, users might have to pay higher gas fees to get their transactions processed.\n• Protocol: The protocol itself may suffer from disruptions, particularly if it relies on timely transaction processing. This could lead to unexpected behavior, triggering of fail-safes, or even temporary halts in operation.\n\n💰No Financial Gain for the Attacker\n\nThe key aspect of this attack is that the attacker gains no direct financial benefit. Their goal is purely to disrupt the system, making it a classic example of griefing."
    },
    {
        "link": "https://stackoverflow.com/questions/70799103/what-is-the-use-of-msg-sender-in-solidity",
        "document": "In this codpiece, I am finding it hard to figure out what is is and how it works internally.\n\nWhat I am understanding is, we have a mapping favoriteNumber, and the key is an address and the value is a uint.\n\nWhat is the meaning of comment - \"Update our mapping to store under , I am understanding that we are updating favoriteNumber, but what does it mean that under msg.sender. What is the role of this method, how it's working?"
    },
    {
        "link": "https://docs.soliditylang.org/en/latest/security-considerations.html",
        "document": "While it is usually quite easy to build software that works as expected, it is much harder to check that nobody can use it in a way that was not anticipated.\n\nIn Solidity, this is even more important because you can use smart contracts to handle tokens or, possibly, even more valuable things. Furthermore, every execution of a smart contract happens in public and, in addition to that, the source code is often available.\n\nOf course, you always have to consider how much is at stake: You can compare a smart contract with a web service that is open to the public (and thus, also to malicious actors) and perhaps even open-source. If you only store your grocery list on that web service, you might not have to take too much care, but if you manage your bank account using that web service, you should be more careful.\n\nThis section will list some pitfalls and general security recommendations but can, of course, never be complete. Also, keep in mind that even if your smart contract code is bug-free, the compiler or the platform itself might have a bug. A list of some publicly known security-relevant bugs of the compiler can be found in the list of known bugs, which is also machine-readable. Note that there is a Bug Bounty Program that covers the code generator of the Solidity compiler.\n\nAs always, with open-source documentation, please help us extend this section (especially, some examples would not hurt)!\n\nNOTE: In addition to the list below, you can find more security recommendations and best practices in Guy Lando’s knowledge list and the Consensys GitHub repo.\n\nEverything you use in a smart contract is publicly visible, even local variables and state variables marked . Using random numbers in smart contracts is quite tricky if you do not want block builders to be able to cheat. Any interaction from a contract (A) with another contract (B) and any transfer of Ether hands over control to that contract (B). This makes it possible for B to call back into A before this interaction is completed. To give an example, the following code contains a bug (it is just a snippet and not a complete contract): // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares send shares shares The problem is not too serious here because of the limited gas as part of , but it still exposes a weakness: Ether transfer can always include code execution, so the recipient could be a contract that calls back into . This would let it get multiple refunds and, basically, retrieve all the Ether in the contract. In particular, the following contract will allow an attacker to refund multiple times as it uses which forwards all remaining gas by default: // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares call value shares success shares To avoid reentrancy, you can use the Checks-Effects-Interactions pattern as demonstrated below: /// @dev Mapping of ether shares of the contract. shares shares shares transfer share The Checks-Effects-Interactions pattern ensures that all code paths through a contract complete all required checks of the supplied parameters before modifying the contract’s state (Checks); only then it makes any changes to the state (Effects); it may make calls to functions in other contracts after all planned state changes have been written to storage (Interactions). This is a common foolproof way to prevent reentrancy attacks, where an externally called malicious contract can double-spend an allowance, double-withdraw a balance, among other things, by using logic that calls back into the original contract before it has finalized its transaction. Note that reentrancy is not only an effect of Ether transfer but of any function call on another contract. Furthermore, you also have to take multi-contract situations into account. A called contract could modify the state of another contract you depend on. Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. Either explicitly or just due to normal operation, the number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. This may not apply to functions that are only executed to read data from the blockchain. Still, such functions may be called by other contracts as part of on-chain operations and stall those. Please be explicit about such cases in the documentation of your contracts.\n• None Neither contracts nor “external accounts” are currently able to prevent someone from sending them Ether. Contracts can react on and reject a regular transfer, but there are ways to move Ether without creating a message call. One way is to simply “mine to” the contract address and the second way is using .\n• None If a contract receives Ether (without a function being called), either the receive Ether or the fallback function is executed. If it does not have a nor a function, the Ether will be rejected (by throwing an exception). During the execution of one of these functions, the contract can only rely on the “gas stipend” it is passed (2300 gas) being available to it at that time. This stipend is not enough to modify storage (do not take this for granted though, the stipend might change with future hard forks). To be sure that your contract can receive Ether in that way, check the gas requirements of the receive and fallback functions (for example in the “details” section in Remix).\n• None There is a way to forward more gas to the receiving contract using . This is essentially the same as , only that it forwards all remaining gas and opens up the ability for the recipient to perform more expensive actions (and it returns a failure code instead of automatically propagating the error). This might include calling back into the sending contract or other state changes you might not have thought of. So it allows for great flexibility for honest users but also for malicious actors.\n• None Use the most precise units to represent the Wei amount as possible, as you lose any that is rounded due to a lack of precision.\n• None If you want to send Ether using , there are certain details to be aware of:\n• None If the recipient is a contract, it causes its receive or fallback function to be executed which can, in turn, call back the sending contract.\n• None Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call depth, they can force the transfer to fail; take this possibility into account or use and make sure to always check its return value. Better yet, write your contract using a pattern where the recipient can withdraw Ether instead.\n• None Sending Ether can also fail because the execution of the recipient contract requires more than the allotted amount of gas (explicitly by using require, assert, revert or because the operation is too expensive) - it “runs out of gas” (OOG). If you use or with a return value check, this might provide a means for the recipient to block progress in the sending contract. Again, the best practice here is to use a “withdraw” pattern instead of a “send” pattern. External function calls can fail at any time because they exceed the maximum call stack size limit of 1024. In such situations, Solidity throws an exception. Malicious actors might be able to force the call stack to a high value before they interact with your contract. Note that, since Tangerine Whistle hardfork, the 63/64 rule makes call stack depth attack impractical. Also note that the call stack and the expression stack are unrelated, even though both have a size limit of 1024 stack slots. Note that does not throw an exception if the call stack is depleted but rather returns in that case. The low-level functions , and behave in the same way. If your contract can act as a proxy, i.e. if it can call arbitrary contracts with user-supplied data, then the user can essentially assume the identity of the proxy contract. Even if you have other protective measures in place, it is best to build your contract system such that the proxy does not have any permissions (not even for itself). If needed, you can accomplish that using a second proxy: PermissionlessProxy proxy payload proxy callOther addr payload // Other functions and other functionality // This is the full contract, it has no other functionality and payload addr call payload Never use for authorization. Let’s say you have a wallet contract like this: // THIS CONTRACT CONTAINS A BUG - DO NOT USE owner dest // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin owner dest transfer amount Now someone tricks you into sending Ether to the address of this attack wallet: If your wallet had checked for authorization, it would get the address of the attack wallet, instead of the owner’s address. But by checking , it gets the original address that kicked off the transaction, which is still the owner’s address. The attack wallet instantly drains all your funds. As in many programming languages, Solidity’s integer types are not actually integers. They resemble integers when the values are small, but cannot represent arbitrarily large numbers. The following code causes an overflow because the result of the addition is too large to be stored in the type : Solidity has two modes in which it deals with these overflows: Checked and Unchecked or “wrapping” mode. The default checked mode will detect overflows and cause a failing assertion. You can disable this check using , causing the overflow to be silently ignored. The above code would return if wrapped in . Even in checked mode, do not assume you are protected from overflow bugs. In this mode, overflows will always revert. If it is not possible to avoid the overflow, this can lead to a smart contract being stuck in a certain state. In general, read about the limits of two’s complement representation, which even has some more special edge cases for signed numbers. Try to use to limit the size of inputs to a reasonable range and use the SMT checker to find potential overflows. The Solidity type (see Mapping Types) is a storage-only key-value data structure that does not keep track of the keys that were assigned a non-zero value. Because of that, cleaning a mapping without extra information about the written keys is not possible. If a is used as the base type of a dynamic storage array, deleting or popping the array will have no effect over the elements. The same happens, for example, if a is used as the type of a member field of a that is the base type of a dynamic storage array. The is also ignored in assignments of structs or arrays containing a . Consider the example above and the following sequence of calls: , . At this point, calling returns 256. If we call , the length of the state variable is zeroed, but since its elements cannot be zeroed, their information stays alive in the contract’s storage. After deleting , calling allows us to access again, and calling returns 256 even without another call to . If your information must be deleted, consider using a library similar to iterable mapping, allowing you to traverse the keys and delete their values in the appropriate . Updating the code of your contract may invalidate the values of variables of internal function types. Consider such values ephemeral and avoid storing them in state variables. If you do, you must ensure that they never persist across code updates and are never used by other contracts having access to the same storage space as a result of a delegatecall or account abstraction.\n• None Types that do not occupy the full 32 bytes might contain “dirty higher order bits”. This is especially important if you access - it poses a malleability risk: You can craft transactions that call a function with a raw byte argument of and with . Both are fed to the contract and both will look like the number as far as is concerned, but will be different, so if you use for anything, you will get different results.\n\nIf the compiler warns you about something, you should change it. Even if you do not think that this particular warning has security implications, there might be another issue buried beneath it. Any compiler warning we issue can be silenced by slight changes to the code. Always use the latest version of the compiler to be notified about all recently introduced warnings. Messages of type , issued by the compiler, are not dangerous and simply represent extra suggestions and optional information that the compiler thinks might be useful to the user. Restrict the amount of Ether (or other tokens) that can be stored in a smart contract. If your source code, the compiler or the platform has a bug, these funds may be lost. If you want to limit your loss, limit the amount of Ether. Keep it Small and Modular Keep your contracts small and easily understandable. Single out unrelated functionality in other contracts or into libraries. General recommendations about the source code quality of course apply: Limit the amount of local variables, the length of functions and so on. Document your functions so that others can see what your intention was and whether it is different than what the code does. Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.). As the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function. Early contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above. Note that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern. While making your system fully decentralized will remove any intermediary, it might be a good idea, especially for new code, to include some kind of fail-safe mechanism: You can add a function in your smart contract that performs some self-checks like “Has any Ether leaked?”, “Is the sum of the tokens equal to the balance of the contract?” or similar things. Keep in mind that you cannot use too much gas for that, so help through off-chain computations might be needed there. If the self-check fails, the contract automatically switches into some kind of “failsafe” mode, which, for example, disables most of the features, hands over control to a fixed and trusted third party or just converts the contract into a simple “give me back my Ether” contract. The more people examine a piece of code, the more issues are found. Asking people to review your code also helps as a cross-check to find out whether your code is easy to understand - a very important criterion for good smart contracts."
    },
    {
        "link": "https://helalabs.com/blog/what-is-mapping-in-solidity-examples-and-best-practices",
        "document": "Solidity, a cornerstone in blockchain development, is akin to JavaScript in its syntax yet boasts unique features tailored for smart contract creation. Smart contracts, the backbone of various decentralized applications, operate on blockchain platforms like Ethereum. These self-executing contracts encapsulate rules and automatically enforce them, ushering in a new era of trustless agreements.\n\nMapping in Solidity plays a pivotal role, akin to a dictionary or hash table in other programming languages. It offers an efficient, key-value store mechanism, crucial for managing data within smart contracts. Mapping’s ability to link unique keys to corresponding values underpins numerous blockchain functionalities, from tracking cryptocurrency balances to managing user permissions.\n\nThis article delves into the nitty-gritty of mapping in Solidity. We’ll explore its syntax, practical use cases, and best practices, providing you with a comprehensive understanding of this fundamental concept.\n\nWhat is Mapping in Solidity?\n\nUnderstanding mapping in Solidity is crucial for developing smart contracts on the Ethereum blockchain. In Solidity, a mapping is a data structure used to associate a key with a value, somewhat similar to dictionaries or hash maps in other programming languages. However, there are some unique characteristics and considerations when working with mappings in Solidity. Here are some key points to consider when it comes to understanding mappings in Solidity:\n• None Mappings store key-value pairs, where the key is unique within the mapping.\n• None In the example above, address is the key type, and uint256 is the value type. This mapping might be used to associate Ethereum addresses with their corresponding balances.\n• None Mappings are not initialized by default, and you need to explicitly set values for specific keys.\n• None Accessing a key that has not been set will return the default value for the value type (e.g., 0 for uint256).\n\nAlso Read: What are Crypto Whitepaper and Litepaper? Key Elements and Differences\n• None Mappings can be declared as either storage or memory mappings, depending on where they are used.\n• None Storage mappings are written to the Ethereum blockchain and have persistent data that survives between transactions. They are typically used for state variables.\n• None Memory mappings exist only in the current function’s execution and are not stored on the blockchain. They are often used for temporary data storage within a function.\n• None Mappings cannot be iterated directly. You cannot loop through all the keys in a mapping.\n• None There is no way to determine the number of key-value pairs in a mapping, so you may need to manage this information separately if required.\n• None Writing to a storage mapping consumes more gas than reading from it. Be mindful of gas costs when working with storage mappings, especially in loops or frequently called functions.\n• None Solidity does not provide a built-in mechanism to delete a key from a mapping. To remove a key-value pair, you can set the value to its default (e.g., 0) or use a separate data structure to keep track of deleted keys.\n\nUnderstanding these aspects of mappings in Solidity is crucial for designing efficient and secure smart contracts. Mappings are a fundamental tool for managing data in Ethereum contracts, and they play a significant role in various decentralized applications (DApps) and decentralized finance (DeFi) projects.\n\nIn Solidity, the syntax and declaration of mappings are essential concepts for managing data in smart contracts effectively. Mappings are a fundamental data structure that allows you to create relationships between keys and values in a way that is efficient and secure. Here’s a more detailed explanation of the syntax and declaration of mappings:\n\nTo declare a mapping in Solidity, you use the mapping keyword, followed by the key and value types enclosed in angle brackets (< >). The key type specifies what you’ll use as a lookup, and the value type defines the data associated with each key. For example, mapping(address => uint256) balances; declares a mapping named balances that associates Ethereum addresses (keys) with integer balances (values).\n\nSolidity allows you to use a wide range of types as keys and values in your mappings. In the provided example, we used address as the key type and uint256 as the value type. However, you can use more complex types, such as:\n• None Strings: You can use strings as keys or values in mappings to associate string data with specific keys. For example, mapping(string => uint256) nameToScore; associates player names with their scores in a game.\n• None Structs: Mappings can also use user-defined structs as keys or values. This allows you to create more complex data structures. For instance, if you have a struct named Person with fields like name, age, and address, you can use mapping(uint256 => Person) personRecords; to associate unique IDs with individual Person structs.\n\nOnce you’ve declared a mapping, you can access and modify its elements using the keys. For example, to access the balance of a specific Ethereum address in the balances mapping, you would use balances[address]. You can also update the balance by assigning a new value, like balances[address] = newBalance.\n\nMappings in Solidity are not automatically initialized. You need to set values for individual keys explicitly. If you access a key that hasn’t been set before, it will return a default value (usually zero for numeric types). It’s essential to initialize mappings properly in your smart contract to avoid unexpected behavior.\n\nMappings are efficient for lookups and updates because Solidity compiles them into a low-level data structure known as a hash table. However, be aware that modifying a mapping can consume gas, especially if you’re adding or updating many entries. Gas costs depend on the complexity of the operation and the data size.\n\nMappings in Solidity are a powerful tool for managing key-value relationships in smart contracts. They offer flexibility in choosing key and value types, making them suitable for a wide range of use cases, from tracking balances to more complex data structures like dictionaries and registries. Understanding the syntax and declaration of mappings is crucial for developing robust and efficient smart contracts on the Ethereum blockchain.\n\nIn Solidity, mapping is a widely used data structure that allows you to associate a key with a value, similar to a dictionary or hash map in other programming languages. Here are some practical examples of how mappings can be used in Solidity:\n\nYou can use a mapping to track the balances of Ethereum addresses within a smart contract. This is useful for creating wallets, financial applications, or any system where you need to manage account balances.\n\nMappings can be employed to implement voting systems. Each candidate can be represented by a unique key, and the mapping stores the number of votes received by each candidate. This is useful for conducting fair and transparent voting processes.\n\nMappings are crucial for access control within a smart contract. You can associate addresses with certain privileges, such as admin or user roles. This allows you to restrict access to specific functions or actions based on the user’s role.\n\nMappings are commonly used in token contracts to maintain the balances of token holders. Each Ethereum address is mapped to a token balance, enabling users to transfer tokens to each other securely.\n\nIn various applications, mappings can be used for record-keeping purposes. For example, in a supply chain management system, you can use mappings to track the ownership or status of products at different stages.\n\nMappings can serve as efficient data indexes. For instance, in a decentralized application (DApp) that manages user profiles, you can use a mapping to associate user IDs with their corresponding profile data.\n\nMulti-signature wallets often use mappings to keep track of authorized signers and the number of required signatures to execute a transaction. Mappings help in managing the ownership and control of funds in such wallets.\n\nIn decentralized applications that involve user permissions and role-based access, mappings can be used to define roles and map users to their respective roles. This allows for fine-grained control over who can perform specific actions.\n\nIn decentralized games, mappings can be used to store game state information, such as player scores, game progress, and in-game assets owned by each player.\n\nMappings can be employed in registry systems where you associate keys with specific information, such as domain names in a decentralized domain name system (DNS) or asset registration in a digital asset registry.\n\nMappings in Solidity are versatile and provide a flexible way to structure and access data within smart contracts, making them a fundamental tool for various decentralized applications and blockchain-based systems.\n\nAdvanced mapping techniques in Solidity refer to the use of mappings, a fundamental data structure in the Ethereum blockchain’s programming language, Solidity, in more complex and nuanced ways to efficiently store and retrieve data on the blockchain.\n\nMappings are often used to create key-value pairs, where keys are unique identifiers, and values are associated data. Here are some advanced mapping techniques and concepts in Solidity:\n\nYou can create mappings within mappings, allowing you to build hierarchical data structures. For example, you could have a mapping that associates user addresses with their balances, and within each user’s balance mapping, you can store different types of assets as another mapping.\n\nEnumerations (enums) can be used as keys in mappings to create more structured data storage. For instance, you can use an enum to represent different states or categories and map them to associated data.\n\nSolidity does not natively support iterating over mappings due to the unpredictability of gas costs. However, you can implement your own iteration patterns by maintaining an array of keys or using libraries like IterableMapping (a community-contributed library) to iterate through mapping elements.\n\nSolidity mappings can be declared as storage or memory variables, which affects how data is stored and accessed. Storage variables persist between function calls and modify the blockchain state, whereas memory variables are temporary and used for data manipulation within a function. Understanding when to use storage or memory is crucial for optimizing gas costs.\n\nDeleting data from a mapping is not straightforward. Solidity does not provide a built-in method to remove an element from a mapping. To delete a mapping entry, you often need to use a separate boolean flag to mark entries as deleted or rely on workarounds.\n\nCareful consideration of gas costs is vital when working with mappings. Iterating over large mappings or using nested mappings can lead to high gas costs. Properly managing and minimizing gas usage is essential for efficient smart contract development.\n\nThese advanced mapping techniques in Solidity demonstrate how developers can design more complex data structures and optimize gas consumption in smart contracts. Solidity’s mapping data type is a powerful tool for managing data on the Ethereum blockchain, but it requires a deep understanding of its nuances to build efficient and secure decentralized applications (DApps).\n\nMapping is a commonly used data structure in Solidity, the programming language for Ethereum smart contracts. It allows you to create key-value pairs, similar to dictionaries or associative arrays in other programming languages. While mappings are a powerful tool, they come with some best practices and common pitfalls you should be aware of:\n• None Use Mappings for Efficient Data Retrieval: Mappings are efficient for retrieving data based on a specific key. They have constant time complexity (O(1)) for both insertion and retrieval.\n• None Use Enumerations or Arrays for Iteration: Mappings are not iterable, so if you need to iterate through all the elements, consider using arrays or an enumeration pattern alongside mappings to keep track of keys.\n• None Initialize Mappings in Constructor: Initialize mappings in the constructor or an initialization function to ensure they start with the desired default values. Mappings are not automatically initialized to default values like arrays.\n• None Handle Key Non-Existence: Check whether a key exists in a mapping before accessing its value, as accessing a non-existing key in a mapping returns the default value for that data type (e.g., 0 for uint).\n• None Use a Struct for Complex Data: When dealing with complex data structures, consider using a struct as the value type in your mapping to keep your code organized and more readable.\n• None Access Control: Implement access control mechanisms to restrict who can modify the mapping. Use modifiers and access control functions to ensure only authorized users can update the mapping.\n• None Size Limitations: Be mindful of the gas costs associated with mapping storage. Excessive data in mappings can lead to high gas costs, which may make your contract less efficient.\n• None Reentrancy Vulnerabilities: Be cautious when using mappings in functions that interact with external contracts. Malicious external contracts can trigger reentrancy attacks. Use the “checks-effects-interactions” pattern to mitigate this risk.\n• None Large Mappings: Storing a large number of items in a mapping can increase gas costs and potentially make your contract unmanageable. Consider alternative storage solutions or pagination if you anticipate a large number of entries.\n• None Inefficient Key Generation: If you use dynamically generated keys, ensure that the key generation process is efficient. Inefficient key generation can lead to higher gas costs.\n• None Security Around Key Generation: Ensure that keys are generated securely to prevent unauthorized access to sensitive data. Avoid using predictable keys that an attacker could guess.\n• None Mapping Limitations: Mappings are not suitable for every use case. In some scenarios, other data structures like arrays or sets may be more appropriate.\n• None Lack of Error Handling: Always handle errors that might occur when interacting with mappings. Failing to check for errors can lead to unexpected behavior and vulnerabilities.\n• None Upgradeability: If you plan to upgrade your smart contract, consider the implications of modifying or changing the structure of existing mappings, as it can impact the contract’s compatibility with the old data.\n\nMappings are a fundamental part of Solidity, and when used correctly, they can be a powerful tool for managing data within your smart contracts. However, it’s essential to be aware of their limitations and potential pitfalls to write secure and efficient smart contracts.\n\nIn conclusion, mappings in Solidity are like a reliable Swiss Army knife for blockchain developers, offering a straightforward way to link keys with values. They’re the go-to tool for managing data in Ethereum smart contracts, enabling us to keep track of everything from cryptocurrency balances to voting records. But remember, while mappings are powerful, they come with their own quirks. You’ve got to initialize them, be mindful of gas costs, and handle potential pitfalls like reentrancy vulnerabilities or large data storage. So, when crafting your smart contracts, think of mappings as your trusty sidekick, always ready to help, but handle with care to ensure the security and efficiency of your blockchain creations.\n\nMappings are the building blocks that make decentralized applications and blockchain-based systems tick, giving us the ability to associate keys and values efficiently. They’re like the keys to various doors in the world of Solidity, allowing us to open up new possibilities for data management. So, as you embark on your journey into blockchain development, keep these mapping essentials in your toolkit, and you’ll be well on your way to crafting robust and efficient smart contracts."
    },
    {
        "link": "https://coinsbench.com/a-brief-compilation-of-patterns-and-best-practices-for-solidity-part-i-6de3d37291d1",
        "document": "A brief compilation of patterns and best practices for Solidity -Part I Since the use of is deprecated, Recommended functions : revert(), require() and assert() . \n\nrequire() and revert() - REVERT \n\nassert() - INVALID\n\nDifference in opcodes -> difference in GAS used REVERT ( 0xfd) : refunds all the gas that has not been consumed at the time the exception is thrown INVALID (0xfe) : uses all the gas included in the transaction Use require() : To validate inputs on external function calls, beginning of function, checking state variables Use assert(): use for internal errors and checking invariants In case the logic to check a condition is complex and then you want to throw use revert() because it throws in every case\n\nWhen a contract has to go through multiple states -> each state has different behavior\n• the function of a smart contract should only be accessible during different stages\n• stage transition should be already defined and should not be preventable for all participants\n• state transition can be based on a condition (like American roulette) and can also be timed (in this case the modifier checking the timestamp should be placed before modifier checking for the current stage) 💡 Implementation: This sample contract showcases the state machine for a blind auction and is inspired by the example code provided in the Solidity documentation modifier timedTransitions() {\n\n if (stage == Stages.AcceptingBlindBids && now >= creationTime + 6 days) {\n\n nextStage();\n\n }\n\n if (stage == Stages.RevealBids && now >= creationTime + 10 days) {\n\n nextStage();\n\n }\n\n _;\n\n }\n\nGain access to data stored outside of the blockchain. -For information/data which lies outside the chain, it will not be practical to allow external network calls because -\n• Every node will have to verify results on its own by making a request. Example of data needed: Result of a sports event, Flight Price, Currency price function updatePrice() public payable {\n\n if (oraclize_getPrice(\"URL\") > this.balance) {\n\n //Handle out of funds error\n\n } else {\n\n oraclize_query(\"URL\", \"json(<http://api.fixer.io/latest?symbols=USD>).rates.USD\");\n\n }\n\n } A negative consequence of the usage of oracles is the introduction of a single point of failure. The contract creator as well as the users interacting with the contract rely heavily on the information provided by the oracle. Oracles or their data sources have reported wrong data in the past and it is likely that there will be errors in the future again\n\nStringUtils library -> Pairwise comparison, was good when the difference in pair occurs early. Usage of a hash function for comparison, combined with a check for matching the length of the provided strings, to weed out pairs with different lengths from the start is the best way to mitigate the problem of highly variable and unpredictable gas required for matching strings.\n• Check if strings are of the same length, by converting to bytes data type — has built-in length member.\n\nUpgrade smart contracts without breaking any dependencies To overcome the limitations introduced by the immutability of contract code, a contract can be split up into modules, which are then virtually upgradeable, A new version of the contract can be deployed and its address replaces the old one in storage We make use of a proxy contract that delegates call to specific modules. You should be well versed in how works\n\nKeep contract storage after a smart contract upgrade. Implement several mappings, one for each data type, in which data can be stored. These mappings map the abstracted down value to a certain sha3 hash, acting as key-value storage. A sha3 hash is used as the key, in order to allow identifiers of arbitrary length to be used as keys. Each mapping should be equipped with three-function to manage storage, retrieval and deletion. Because the functions for storage and deletion are affecting the contract state, they should be guarded by the Access restriction pattern, so access is only allowed from the most recent version of the contract using upgradeable The hashing of the storage key should take place at the calling contract.\n\nStorage in Ethereum is a key-value store with keys and values of 32 bytes each. When storage is allocated, all statically-sized variables are written down one after the other, in order of their declaration starting at position 0. The most common data types like u , , take up exactly one 32-byte slot in storage. Smaller data types -> , if possible EVM can pack them together into one 32-byte slot. therefore using less storage, Gas is saved because EVM can combine multiple reads or writes into one single operation\n• Use the smallest possible data type that guarantees the correct execution of code\n• Group all data types that are supposed to go together into one 32 bytes slot, and declare them one after another in the given order. Note that: This is only done for state variables and inside of structs and an array consists of only one data type so there is no ordering necessary"
    },
    {
        "link": "https://docs.soliditylang.org/en/v0.8.29/security-considerations.html",
        "document": "While it is usually quite easy to build software that works as expected, it is much harder to check that nobody can use it in a way that was not anticipated.\n\nIn Solidity, this is even more important because you can use smart contracts to handle tokens or, possibly, even more valuable things. Furthermore, every execution of a smart contract happens in public and, in addition to that, the source code is often available.\n\nOf course, you always have to consider how much is at stake: You can compare a smart contract with a web service that is open to the public (and thus, also to malicious actors) and perhaps even open-source. If you only store your grocery list on that web service, you might not have to take too much care, but if you manage your bank account using that web service, you should be more careful.\n\nThis section will list some pitfalls and general security recommendations but can, of course, never be complete. Also, keep in mind that even if your smart contract code is bug-free, the compiler or the platform itself might have a bug. A list of some publicly known security-relevant bugs of the compiler can be found in the list of known bugs, which is also machine-readable. Note that there is a Bug Bounty Program that covers the code generator of the Solidity compiler.\n\nAs always, with open-source documentation, please help us extend this section (especially, some examples would not hurt)!\n\nNOTE: In addition to the list below, you can find more security recommendations and best practices in Guy Lando’s knowledge list and the Consensys GitHub repo.\n\nEverything you use in a smart contract is publicly visible, even local variables and state variables marked . Using random numbers in smart contracts is quite tricky if you do not want block builders to be able to cheat. Any interaction from a contract (A) with another contract (B) and any transfer of Ether hands over control to that contract (B). This makes it possible for B to call back into A before this interaction is completed. To give an example, the following code contains a bug (it is just a snippet and not a complete contract): // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares send shares shares The problem is not too serious here because of the limited gas as part of , but it still exposes a weakness: Ether transfer can always include code execution, so the recipient could be a contract that calls back into . This would let it get multiple refunds and, basically, retrieve all the Ether in the contract. In particular, the following contract will allow an attacker to refund multiple times as it uses which forwards all remaining gas by default: // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares call value shares success shares To avoid reentrancy, you can use the Checks-Effects-Interactions pattern as demonstrated below: /// @dev Mapping of ether shares of the contract. shares shares shares transfer share The Checks-Effects-Interactions pattern ensures that all code paths through a contract complete all required checks of the supplied parameters before modifying the contract’s state (Checks); only then it makes any changes to the state (Effects); it may make calls to functions in other contracts after all planned state changes have been written to storage (Interactions). This is a common foolproof way to prevent reentrancy attacks, where an externally called malicious contract can double-spend an allowance, double-withdraw a balance, among other things, by using logic that calls back into the original contract before it has finalized its transaction. Note that reentrancy is not only an effect of Ether transfer but of any function call on another contract. Furthermore, you also have to take multi-contract situations into account. A called contract could modify the state of another contract you depend on. Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. Either explicitly or just due to normal operation, the number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. This may not apply to functions that are only executed to read data from the blockchain. Still, such functions may be called by other contracts as part of on-chain operations and stall those. Please be explicit about such cases in the documentation of your contracts.\n• None Neither contracts nor “external accounts” are currently able to prevent someone from sending them Ether. Contracts can react on and reject a regular transfer, but there are ways to move Ether without creating a message call. One way is to simply “mine to” the contract address and the second way is using .\n• None If a contract receives Ether (without a function being called), either the receive Ether or the fallback function is executed. If it does not have a nor a function, the Ether will be rejected (by throwing an exception). During the execution of one of these functions, the contract can only rely on the “gas stipend” it is passed (2300 gas) being available to it at that time. This stipend is not enough to modify storage (do not take this for granted though, the stipend might change with future hard forks). To be sure that your contract can receive Ether in that way, check the gas requirements of the receive and fallback functions (for example in the “details” section in Remix).\n• None There is a way to forward more gas to the receiving contract using . This is essentially the same as , only that it forwards all remaining gas and opens up the ability for the recipient to perform more expensive actions (and it returns a failure code instead of automatically propagating the error). This might include calling back into the sending contract or other state changes you might not have thought of. So it allows for great flexibility for honest users but also for malicious actors.\n• None Use the most precise units to represent the Wei amount as possible, as you lose any that is rounded due to a lack of precision.\n• None If you want to send Ether using , there are certain details to be aware of:\n• None If the recipient is a contract, it causes its receive or fallback function to be executed which can, in turn, call back the sending contract.\n• None Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call depth, they can force the transfer to fail; take this possibility into account or use and make sure to always check its return value. Better yet, write your contract using a pattern where the recipient can withdraw Ether instead.\n• None Sending Ether can also fail because the execution of the recipient contract requires more than the allotted amount of gas (explicitly by using require, assert, revert or because the operation is too expensive) - it “runs out of gas” (OOG). If you use or with a return value check, this might provide a means for the recipient to block progress in the sending contract. Again, the best practice here is to use a “withdraw” pattern instead of a “send” pattern. External function calls can fail at any time because they exceed the maximum call stack size limit of 1024. In such situations, Solidity throws an exception. Malicious actors might be able to force the call stack to a high value before they interact with your contract. Note that, since Tangerine Whistle hardfork, the 63/64 rule makes call stack depth attack impractical. Also note that the call stack and the expression stack are unrelated, even though both have a size limit of 1024 stack slots. Note that does not throw an exception if the call stack is depleted but rather returns in that case. The low-level functions , and behave in the same way. If your contract can act as a proxy, i.e. if it can call arbitrary contracts with user-supplied data, then the user can essentially assume the identity of the proxy contract. Even if you have other protective measures in place, it is best to build your contract system such that the proxy does not have any permissions (not even for itself). If needed, you can accomplish that using a second proxy: PermissionlessProxy proxy payload proxy callOther addr payload // Other functions and other functionality // This is the full contract, it has no other functionality and payload addr call payload Never use for authorization. Let’s say you have a wallet contract like this: // THIS CONTRACT CONTAINS A BUG - DO NOT USE owner dest // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin owner dest transfer amount Now someone tricks you into sending Ether to the address of this attack wallet: If your wallet had checked for authorization, it would get the address of the attack wallet, instead of the owner’s address. But by checking , it gets the original address that kicked off the transaction, which is still the owner’s address. The attack wallet instantly drains all your funds. As in many programming languages, Solidity’s integer types are not actually integers. They resemble integers when the values are small, but cannot represent arbitrarily large numbers. The following code causes an overflow because the result of the addition is too large to be stored in the type : Solidity has two modes in which it deals with these overflows: Checked and Unchecked or “wrapping” mode. The default checked mode will detect overflows and cause a failing assertion. You can disable this check using , causing the overflow to be silently ignored. The above code would return if wrapped in . Even in checked mode, do not assume you are protected from overflow bugs. In this mode, overflows will always revert. If it is not possible to avoid the overflow, this can lead to a smart contract being stuck in a certain state. In general, read about the limits of two’s complement representation, which even has some more special edge cases for signed numbers. Try to use to limit the size of inputs to a reasonable range and use the SMT checker to find potential overflows. The Solidity type (see Mapping Types) is a storage-only key-value data structure that does not keep track of the keys that were assigned a non-zero value. Because of that, cleaning a mapping without extra information about the written keys is not possible. If a is used as the base type of a dynamic storage array, deleting or popping the array will have no effect over the elements. The same happens, for example, if a is used as the type of a member field of a that is the base type of a dynamic storage array. The is also ignored in assignments of structs or arrays containing a . Consider the example above and the following sequence of calls: , . At this point, calling returns 256. If we call , the length of the state variable is zeroed, but since its elements cannot be zeroed, their information stays alive in the contract’s storage. After deleting , calling allows us to access again, and calling returns 256 even without another call to . If your information must be deleted, consider using a library similar to iterable mapping, allowing you to traverse the keys and delete their values in the appropriate . Updating the code of your contract may invalidate the values of variables of internal function types. Consider such values ephemeral and avoid storing them in state variables. If you do, you must ensure that they never persist across code updates and are never used by other contracts having access to the same storage space as a result of a delegatecall or account abstraction.\n• None Types that do not occupy the full 32 bytes might contain “dirty higher order bits”. This is especially important if you access - it poses a malleability risk: You can craft transactions that call a function with a raw byte argument of and with . Both are fed to the contract and both will look like the number as far as is concerned, but will be different, so if you use for anything, you will get different results.\n\nIf the compiler warns you about something, you should change it. Even if you do not think that this particular warning has security implications, there might be another issue buried beneath it. Any compiler warning we issue can be silenced by slight changes to the code. Always use the latest version of the compiler to be notified about all recently introduced warnings. Messages of type , issued by the compiler, are not dangerous and simply represent extra suggestions and optional information that the compiler thinks might be useful to the user. Restrict the amount of Ether (or other tokens) that can be stored in a smart contract. If your source code, the compiler or the platform has a bug, these funds may be lost. If you want to limit your loss, limit the amount of Ether. Keep it Small and Modular Keep your contracts small and easily understandable. Single out unrelated functionality in other contracts or into libraries. General recommendations about the source code quality of course apply: Limit the amount of local variables, the length of functions and so on. Document your functions so that others can see what your intention was and whether it is different than what the code does. Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.). As the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function. Early contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above. Note that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern. While making your system fully decentralized will remove any intermediary, it might be a good idea, especially for new code, to include some kind of fail-safe mechanism: You can add a function in your smart contract that performs some self-checks like “Has any Ether leaked?”, “Is the sum of the tokens equal to the balance of the contract?” or similar things. Keep in mind that you cannot use too much gas for that, so help through off-chain computations might be needed there. If the self-check fails, the contract automatically switches into some kind of “failsafe” mode, which, for example, disables most of the features, hands over control to a fixed and trusted third party or just converts the contract into a simple “give me back my Ether” contract. The more people examine a piece of code, the more issues are found. Asking people to review your code also helps as a cross-check to find out whether your code is easy to understand - a very important criterion for good smart contracts."
    },
    {
        "link": "https://ethereum.stackexchange.com/questions/137880/what-is-the-best-practise-to-storage-large-data-in-smart-contract",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]