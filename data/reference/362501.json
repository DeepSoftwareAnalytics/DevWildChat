[
    {
        "link": "https://digitalocean.com/community/tutorials/setting-up-a-node-project-with-typescript",
        "document": "Node is a runtime environment that makes it possible to write server-side JavaScript. It has gained widespread adoption since its release in 2011. Writing server-side JavaScript can be challenging as a codebase grows due to the dynamic and weak-typed nature of the JavaScript language. Developers coming to JavaScript from other languages often complain about its lack of strong static typing, but this is where TypeScript comes into the picture, to bridge this gap.\n\nTypeScript is a typed (optional) super-set of JavaScript that can help with building and managing large-scale JavaScript projects. It can be thought of as JavaScript with additional features like strong static typing, compilation, and object-oriented programming.\n\nHere are some benefits of using TypeScript:\n\nIn this tutorial, you will set up a Node project with TypeScript. You will build an Express application using TypeScript and transpile it down to JavaScript code.\n\nBefore you begin this guide, you will need Node.js installed on your system. You can accomplish this by following the How to Install Node.js and Create a Local Development Environment guide for your operating system.\n\nTo get started, create a new folder named and move into that directory:\n\nNext, initialize it as an npm project:\n\nThe flag tells to automatically say “yes” to the defaults. You can always update this information later in your file.\n\nNow that your npm project is initialized, you are ready to install and set up TypeScript.\n\nRun the following command from inside your project directory to install the TypeScript:\n\nTypeScript uses a file called to configure the compiler options for a project. Create a file in the root of the project directory:\n\nThen paste in the following JSON:\n\nLet’s go over some of the keys in the JSON snippet above:\n• : This helps the compiler figure out what an import refers to. The value mimics the Node module resolution mechanism.\n• : This is the location to output files after transpilation. In this tutorial, you will save it as .\n\nTo learn more about the key value options available, the official TypeScript documentation offers explanations of every option.\n\nNow, it is time to install the Express framework and create a minimal server:\n\nThe second command installs the Express types for TypeScript support. Types in TypeScript are files, normally with an extension of . The files are used to provide type information about an API, in this case, the Express framework.\n\nThis package is required because TypeScript and Express are independent packages. Without the package, there is no way for TypeScript to know about the types of Express classes.\n\nNext, create a folder in the root of your project directory:\n\nThen create a TypeScript file named within it:\n\nOpen up the file with a text editor of your choice and paste in the following code snippet:\n\nThe code above creates a Node Server that listens on the port for requests. To run the app, you first need to compile it to JavaScript using the following command:\n\nThis uses the configuration file we created in the previous step to determine how to compile the code and where to place the result. In our case, the JavaScript is output to the directory.\n\nIf it runs successfully, a message will be logged to the terminal:\n\nNow, you can visit in your browser and you should see the message:\n\nOpen the file and you will find the transpiled version of the TypeScript code:\n\nAt this point, you have successfully set up your Node project to use TypeScript. Next, you’ll set up the eslint linter to check your TypeScript code for errors.\n\nNow you can configure TypeScript linting for the project. First, we install using :\n\nThen, run ’s initialization command to interactively set up the project:\n\nThis will ask you a series of questions. For this project we’ll answer the following:\n• How would you like to use ESLint?: To check syntax and find problems\n• What type of modules does your project use?: JavaScript modules (import/export)\n• Which framework does your project use?: None of these\n• Does your project use TypeScript?: Yes\n• Where does your code run?: Node\n• What format do you want your config file to be in?: JavaScript\n\nFinally, you will be prompted to install some additional eslint libraries. Choose . The process will finish and you’ll be left with the following configuration file:\n\nRun the linter to check all files with the TypeScript extension:\n\nYou’ve now set up the eslint linter to check your TypeScript syntax. Next, you’ll update your npm configuration to add some convenient scripts for linting and running your project.\n\nIt can be useful to put your commonly run command line tasks into npm scripts. npm scripts are defined in your file and can be run with the command .\n\nIn this step, you will add a script that will transpile the TypeScript code and then run the resulting application.\n\nYou will also add a script to run the eslint linter on your TypeScript files.\n\nOpen the file and update it accordingly:\n\nIn the snippet above, you updated the path to be the compiled app output and added the and commands to the scripts section.\n\nWhen looking at the command, you’ll see that first the command is run, and then the command. This will compile and then run the generated output with .\n\nThe command is the same as we ran in the previous step, minus the use of the prefix which is not needed in this context.\n\nIn this tutorial, you learned about why TypeScript is useful for writing reliable JavaScript code. You also learned about some of the benefits of working with TypeScript.\n\nFinally, you set up a Node project using the Express framework but compiled and ran the project using TypeScript."
    },
    {
        "link": "https://nodejs.org/en/learn/typescript/introduction",
        "document": "TypeScript is an open-source language maintained and developed by Microsoft.\n\nBasically, TypeScript adds additional syntax to JavaScript to support a tighter integration with your editor. Catch errors early in your editor or in your CI/CD pipeline, and write more maintainable code.\n\nWe can talk about other TypeScript benefits later, let's see some examples now!\n\nTake a look at this code snippet and then we can unpack it together:\n\nThe first part (with the keyword) is responsible for declaring our custom object type representing users. Later we utilize this newly created type to create function that accepts one argument of type and returns . After this, we create , our example data that can be used for calling the previously defined function. Finally, we create a new variable with information on whether is an adult.\n\nThere are additional things about this example that you should know. Firstly, if we do not comply with the declared types, TypeScript will inform us that something is wrong and prevent misuse. Secondly, not everything must be typed explicitly—TypeScript infers types for us. For example, the variable is of type even if we didn't type it explicitly, and would be a valid argument for our function even though we didn't declare this variable as of type.\n\nWhat does TypeScript consist of?\n\nTypeScript consists of two main components: the code itself and type definitions.\n\nThe code part is regular JavaScript with additional TypeScript-specific syntax for type annotations. When TypeScript code is compiled, all the TypeScript-specific parts are removed, resulting in clean JavaScript that can run in any environment. For example:\n\nType definitions describe the shape of existing JavaScript code. They are usually stored in files and don't contain any actual implementation—they only describe the types. These definitions are essential for interoperability with JavaScript: code is not usually distributed as TypeScript, but instead transpiled to JavaScript that includes sidecar type definition files.\n\nFor example, when you use Node.js with TypeScript, you'll need type definitions for Node.js APIs. This is available via . Install it using:\n\nThese type definitions allow TypeScript to understand Node.js APIs and provide proper type checking and autocompletion when you use functions like or . For example:\n\nMany popular JavaScript libraries have their type definitions available under the namespace, maintained by the DefinitelyTyped community. This enables seamless integration of existing JavaScript libraries with TypeScript projects.\n\nTypeScript also includes powerful transformation capabilities, particularly for JSX (used in React and similar frameworks). The TypeScript compiler can transform JSX syntax into regular JavaScript, similar to how Babel works. While we won't cover these transformation features in these articles, it's worth noting that TypeScript isn't only a tool for type checking—it's also a build tool for transforming modern JavaScript syntax into compatible versions for different environments.\n\nOkay, so we have some TypeScript code. Now how do we run it? There are few possible ways to run TypeScript code, we will cover all of them in the next articles."
    },
    {
        "link": "https://khalilstemmler.com/blogs/typescript/node-starter-project",
        "document": "We talk about a lot of advanced Node.js and TypeScript concepts on this blog, particularly Domain-Driven Design and large-scale enterprise application patterns. However, after receiving emails from readers interested in seeing what a basic TypeScript starter project looks like, I've put together just that.\n• You should have Node and npm installed\n• You should be familiar with Node and the npm ecosystem\n• You have a code editor installed (preferably VS Code, it's the champ for TypeScript)\n\nIn this short guide, I'll walk you through the process of creating a basic TypeScript application and compiling it. It's actually really easy!\n\nAfterwards, we'll setup a few scripts for hot-reloading in , building for , and running in .\n\nTypeScript, developed and appropriated labeled by Microsoft as \"JavaScript that scales\", is a superset of JavaScript, meaning that everything JavaScript can do, TypeScript can do ( better).\n\nTypeScript was primarily meant to solve two problems:\n• Provide JavaScript developers with the ability to utilize planned features from future JavaScript editions against current JavaScript engines.\n\nWe use TypeScript for most of the topics on this blog because it's a lot better suited for creating long-lasting software and having the compiler help catch bugs and validate types is tremendously helpful.\n\nLet's create a folder for us to work in.\n\nNext, we'll setup the project and add the dependencies.\n\nUsing the flag when creating a will simply approve all the defaults.\n\nThis probably doesn't come as a surprise ;)\n\nAfter we install , we get access to the command line TypeScript compiler through the command. More on that below.\n\nTypeScript has Implicit, Explicit, and Ambient types. Ambient types are types that get added to the global execution scope. Since we're using Node, it would be good if we could get type safety and auto-completion on the Node apis like , , , etc. That's what installing the DefinitelyTyped type definition for Node will do.\n\nThe is where we define the TypeScript compiler options. We can create a tsconfig with several options set.\n• : This is where TypeScript looks for our code. We've configured it to look in the folder. That's where we'll write our TypeScript.\n• : Where TypeScript puts our compiled code. We want it to go to a folder.\n• : If you were in the JavaScript space over the past couple of years, you might have recognized that modules systems had gotten a little bit out of control (AMD, SystemJS, ES Modules, etc). For a topic that requires a much longer discussion, if we're using as our module system (for Node apps, you should be), then we need this to be set to .\n• : If we use JSON in this project, this option allows TypeScript to use it.\n• : This option adds ambient types to our project, allowing us to rely on features from different Ecmascript versions, testing libraries, and even the browser DOM api. We'd like to utilize some language features. This all gets compiled down to .\n• : is the standard Node module system in 2019. Let's use that.\n• : If you're converting an old JavaScript project to TypeScript, this option will allow you to include files among ones.\n• : In TypeScript files, don't allow a type to be unexplicitly specified. Every type needs to either have a specific type or be explicitly declared . No implicit s.\n\nAt this point, you should have a that looks like this:\n\nWe can go ahead and clean the commented out stuff that we don't need. Our should look like this:\n\nWe're set to run our first TypeScript file.\n\nCreate the folder and create our first TypeScript file\n\nTo compile our code, we'll need to run the command using , the Node package executer. will read the in the current directory, and apply the configuration against the TypeScript compiler to generate the compiled JavaScript code.\n\nCheck out , we've compiled our first TypeScript file.\n\nCold reloading is nice for local development. In order to do this, we'll need to rely on a couple more packages: for running TypeScript code directly without having to wait for it be compiled, and , to watch for changes to our code and automatically restart when a file is changed.\n\nAnd then to run the project, all we have to do is run . Let's add a script for that.\n\nBy running , will start our app using , watching for changes to and files from within .\n\nIn order to clean and compile the project for production, we can add a script.\n\nInstall , a cross-platform tool that acts like the command (just obliterates whatever you tell it to).\n\nAnd then, add this to your .\n\nNow, when we run , will remove our old folder before the TypeScript compiler emits new code to .\n\nIn order to start the app in production, all we need to do is run the command first, and then execute the compiled JavaScript at .\n\nThe startup script looks like this.\n\nI told you it was simple! Now, off you go. Create great things, my friend.\n\nA reminder that you can view the entire source code for this here.\n\nStarts the application in development using and to do cold reloading.\n\nBuilds the app at , cleaning the folder first.\n\nStarts the app in production by first building the project with , and then executing the compiled JavaScript at .\n\nI want to talk to you about testing for a moment. I've made a few additions to the project for the purposes of getting my mentorship students up and running faster.\n• There are two ways to write tests in this project.\n• Stateless testing: You can write your tests like this, similarly to how most testing documentation will tell you to write them. This is the simplest way, and it works well for basic unit tests against stateless functions or components.\n• Stateful Testing (Given-When-Then style): This is how I write my High-Value Tests (HVTs) (also known as Acceptance Tests). You can use the Given-When-Then Gherkins format enabled by . I've provided a basic example which you can find within the folder here. For a real-world example of this, check out this folder and read this article.\n• This is my preferred approach most of the time. Especially for stateful tests.\n• (Recommendation): Use the stateless testing approach when you're testing stateless functions or domain objects like value objects and entities.\n\nOh yeah, linting is another thing you'll most likely want to do. If you're interested in that, read the next post, \"How to use ESLint with TypeScript\"."
    },
    {
        "link": "https://stackoverflow.com/questions/9961502/is-there-a-way-to-automatically-build-the-package-json-file-for-node-js-projects",
        "document": "Is package.json supposed to be manually edited? Couldn't a program like NPM just look through the files, see the require statements, and then use that to put the necessary entries in the package.json file? Are there any programs like that?\n\nThe package.json file is used by npm to learn about your node.js project. Use to generate package.json files for you! It comes bundled with npm. Read its documentation here: https://docs.npmjs.com/cli/init Also, there's an official tool you can use to generate this file programmatically: https://github.com/npm/init-package-json\n\n...will ask you a few questions (read this first) about your project/package and then generate a package.json file for you. Then, once you have a package.json file, use ...to install a dependency and automatically append it to your 's list.\n\nI just wrote a simple script to collect the dependencies in . It fulfills my requirement at the moment. This may help some others, I post it here. var fs = require(\"fs\"); function main() { fs.readdir(\"./node_modules\", function (err, dirs) { if (err) { console.log(err); return; } dirs.forEach(function (dir) { if (dir.indexOf(\".\") !== 0) { var packageJsonFile = \"./node_modules/\" + dir + \"/package.json\"; if (fs.existsSync(packageJsonFile)) { fs.readFile(packageJsonFile, function (err, data) { if (err) { console.log(err); } else { var json = JSON.parse(data); console.log('\"' + json.name + '\": \"' + json.version + '\",'); } }); } } }); }); } main(); In my case, the above script outputs: \"colors\": \"0.6.0-1\", \"commander\": \"1.0.5\", \"htmlparser\": \"1.7.6\", \"optimist\": \"0.3.5\", \"progress\": \"0.1.0\", \"request\": \"2.11.4\", \"soupselect\": \"0.2.0\", // Remember: remove the comma character in the last line. Now, you can copy&paste them. Have fun!\n\nto create the package.json file and then you use to fill in the modules you have in the node_modules folder. Edit: @paldepind pointed out that the second command is redundant because now automatically adds what you have in your node_modules/ folder. I don't know if this has always been the case, but now at least, it works without the second command.\n\nTo install , update and uninstall packages under dependencies into package.json file: will automatically add the latest version for the package under dependencies into package.json file also will automatically add the latest version for the package under dependencies into package.json file if you need specific version for a package use this Command line: will automatically add specific version of package under dependencies into package.json file if you need specific range of version for a package use this Command line: will automatically add the latest version for the package between range of version under dependencies into package.json file For more details about how to write version for package npm Doc will update packages into package.json file and will automatically add updated version for all packages under dependencies into package.json file will automatically remove package from dependencies into package.json file and remove package from node_module folder\n\nYou can now use Yeoman - Modern Web App Scaffolding Tool on node terminal using 3 easy steps. First, you'll need to install yo and other required tools: Run yo and... you are all done: Yeoman can write boilerplate code for your entire web application or Controllers and Models. It can fire up a live-preview web server for edits and compile; not just that you can also run your unit tests, minimize and concatenate your code, optimize images, and more... Yeoman (yo) - scaffolding tool that offers an ecosystem of framework-specific scaffolds, called generators, that can be used to perform some of the tedious tasks mentioned earlier. Grunt / gulp - used to build, preview, and test your project. Bower - is used for dependency management, so that you no longer have to manually download your front-end libraries.\n\nIf you git and GitHub user: and/or you don't like template, that generate-package or generate: you can generate your own template via scaffolding apps as generate, sails or yeoman. This answer is relevant for March 2018. In the future, the data from this answer may be obsolete. Author of this answer personally used generate-package at March 2018. You need use git and GitHub for using generate-package. D:\\SashaDemoRepositories\\sasha-npm-init-vs-generate-package>npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help json` for definitive documentation on these fields and exactly what they do. Use `npm install <pkg>` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (sasha-npm-init-vs-generate-package) version: (1.0.0) 0.1.0 description: npm init demo entry point: (index.js) test command: mocha git repository: https://github.com/Kristinita/sasha-npm-init-vs-generate-package keywords: generate, package, npm, package, sasha, vs author: Sasha Chernykh license: (ISC) MIT About to write to D:\\SashaDemoRepositories\\sasha-npm-init-vs-generate-package\\package.json: { \"name\": \"sasha-npm-init-vs-generate-package\", \"version\": \"0.1.0\", \"description\": \"npm init demo\", \"main\": \"index.js\", \"scripts\": { \"test\": \"mocha\" }, \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/Kristinita/sasha-npm-init-vs-generate-package.git\" }, \"keywords\": [ \"generate\", \"package\", \"npm\", \"package\", \"sasha\", \"vs\" ], \"author\": \"Sasha Chernykh\", \"license\": \"MIT\", \"bugs\": { \"url\": \"https://github.com/Kristinita/sasha-npm-init-vs-generate-package/issues\" }, \"homepage\": \"https://github.com/Kristinita/sasha-npm-init-vs-generate-package#readme\" } Is this ok? (yes) y I think, that more simply, that . That create your own template, see generate and yeoman examples."
    },
    {
        "link": "https://medium.com/@induwara99/a-step-by-step-guide-to-setting-up-a-node-js-project-with-typescript-6df4481cb335",
        "document": "Integrating TypeScript with Node.js enhances the development process by improving code readability and maintainability. While it doesn’t increase runtime efficiency, TypeScript’s static typing helps detect errors early, simplifying the management of complex applications.\n\nBefore starting, ensure you have Node.js installed on your machine. Download it from the official website: Node.js.\n\nAdditionally, for API testing, install Postman. You can download it from the official website: Postman\n\nCreate a new folder for your project and navigate to it using the terminal.\n\nRun the following command to initialize a new Node.js project and create a file.\n\nOnce TypeScript is installed, you’ll need to create and configure the file, which is essential for defining compiler options and project settings. To generate a basic file, execute the command:\n\nAfter initializing the file, it's time to tailor it to your project's needs. Open the file and modify it to resemble the configuration below. This example provides a solid foundation for most projects, ensuring strict type-checking, consistent casing in filenames, and compatibility with common module systems:\n\n(Optional) Install the touch-cli globally using npm to create files quickly from the command line\n\nStep 6: Create the Project Structure and Initialize the Express Server Without Types\n\nFirst, create a folder and inside it, a file for your project. This file will contain the source code for your Express server.\n\nOpen the file and write the initial setup code for an Express server:\n• The script starts the server using the compiled JavaScript file in the 'dist' directory.\n• The script builds the TypeScript files to JavaScript using the TypeScript compiler.\n\nExecute the following commands in your terminal to compile the TypeScript code and start your server:\n\nThis will work, but the code lacks type annotations. Visit in your browser, and you should see \"Hello, TypeScript + Node.js + Express!\"\n\nHere, we’ve added types for the variable and the (Request) and (Response) parameters in the route handler.\n\nNow, you have types for the variable. Continue adding types to other parts of your code as needed. This approach allows you to gradually introduce TypeScript into your project.\n\nAfter setting up your application, you can use Postman to send requests to your server and test its responses. This is crucial for ensuring your API behaves as expected.\n• Create a New Request: Set up a new request in Postman by specifying the request type GET and the endpoint URL\n• Send the Request: Hit send and view the response from your server.\n• Analyze the Response: Check the status code, response body, and headers to ensure your API behaves correctly.\n\nThe folder is the directory where TypeScript transpiles the files into files. The folder and are generated after running the command, which compiles the TypeScript code to JavaScript as per the configuration in . This folder is not directly created or modified by the developer; it's managed through the build process controlled by the TypeScript compiler.\n\nThat’s the complete guide to setting up a Node.js project with TypeScript. This setup gives you a strong foundation for building robust and maintainable server-side applications."
    },
    {
        "link": "https://dev.to/luqmanshaban/setting-up-typescript-in-a-nodejs-application-a-step-by-step-guide-5af9",
        "document": "Introduction:\n\n TypeScript is a powerful superset of JavaScript that adds static typing and advanced features to the language. When building Node.js applications, TypeScript can enhance development by providing type checking, better code organization, and improved tooling. In this article, we will walk through the process of setting up TypeScript in a Node.js application, including configuring the and files. By the end, you will be able to console.log \"Hello TypeScript\" from an file.\n\nStep 1: Create a new Node.js project\n\n Before setting up TypeScript, make sure you have Node.js installed on your machine. Create a new directory for your project and navigate to it using the command line. Initialize a new Node.js project by running the following command:\n\n\n\nStep 2: Install required dependencies\n\n To work with TypeScript in a Node.js project, we need to install specific dependencies. In the file, add the following dependencies under the section:\n\n\n\nSave the file, and run the following command to install the dependencies:\n\n\n\nStep 3: Create the tsconfig.json file\n\n To configure TypeScript, we need to create a file in the root of our project. This file defines the compiler options and other settings. Open a text editor and paste the following content into the file:\n\n\n\nHere's a breakdown of the key options in the section:\n• : Specifies the ECMAScript version to compile the TypeScript code to. In this case, we target ECMAScript 6.\n• : Sets the module system to CommonJS, which is used by Node.js.\n• : Generates source map files, which are useful for debugging TypeScript code.\n• : Enables compatibility with modules that use the CommonJS module syntax.\n\nStep 4: Create an index.ts file\n\n In the root of your project, create a new directory. Inside the directory, create an file. Open the file in a text editor and add the following code:\n\n\n\nStep 5: Build and run the TypeScript code\n\n To compile the TypeScript code and run the application, we'll add a script to the file. Under the section, add the following line:\n\n\n\nStep 6: Build and run the application\n\n To compile the TypeScript code into JavaScript and start the application, run the following command:\n\n\n\nYou should see the output \"Hello TypeScript\" in the console, indicating that TypeScript is successfully set up in your Node.js application.\n\nConclusion:\n\n In this article, we walked through the steps required to set up TypeScript in a Node.js application. By configuring the file and installing the necessary dependencies, we enabled static typing and other TypeScript features in our project. Additionally, we created a simple file and used the function to output \"Hello TypeScript.\" Armed with this knowledge, you can now leverage the benefits of TypeScript when developing Node.js applications."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/tsconfig-json.html",
        "document": "The presence of a file in a directory indicates that the directory is the root of a TypeScript project. The file specifies the root files and the compiler options required to compile the project.\n\nJavaScript projects can use a file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.\n\nA project is compiled in one of the following ways:\n• By invoking tsc with no input files, in which case the compiler searches for the file starting in the current directory and continuing up the parent directory chain.\n• By invoking tsc with no input files and a (or just ) command line option that specifies the path of a directory containing a file, or a path to a valid file containing the configurations.\n\nWhen input files are specified on the command line, files are ignored.\n• Using the and properties\n\nDepending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at github.com/tsconfig/bases. These are files which your project extends from which simplifies your by handling the runtime support.\n\nFor example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module :\n\nThis lets your focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.\n\nThe property can be omitted, in which case the compiler’s defaults are used. See our full list of supported Compiler Options.\n\nTo learn more about the hundreds of configuration options in the TSConfig Reference.\n\nThe Schema can be found at the JSON Schema Store."
    },
    {
        "link": "https://blog.appsignal.com/2022/01/19/how-to-set-up-a-nodejs-project-with-typescript.html",
        "document": "This post was updated on 8 August 2023 to use the latest LTS version of Node and TypeScript 5.\n\nIn this tutorial, you will learn how to add TypeScript support to Node.js projects. We will address common needs, such as:\n• configuring third-party packages so that the TypeScript compiler also validates them\n\nTypeScript brings optional static typing to JavaScript projects. The primary benefit of static typing is that type errors are detected and corrected at build time, so code will more likely run correctly once deployed to production. A growing number of JavaScript developers are seeing the value of writing more strongly typed code, which has led to an increase in the adoption of TypeScript for all kinds of JavaScript-based projects.\n\nThis article assumes that you have a basic knowledge of Node.js and TypeScript. You also need to have a recent version of Node.js and npm installed on your computer.\n\nBesides the web browser, Node.js is the most popular platform on which JavaScript code is executed. However, just like the browser, it lacks native support for TypeScript code (unlike Deno, for example).\n\nBefore installing TypeScript, make sure that you've created and initialized a Node.js project with a file. TypeScript is available as a package on the npm registry, and it can be downloaded into your project through a package manager like npm or yarn:\n\nOnce the above command succeeds, you can check the current version through the following command:\n\nIt's advisable to install TypeScript as a project-specific dependency. The same version of the language will then be used, regardless of the machine running the code. You can also install the TypeScript CLI globally by using the switch. A global installation can come in handy for running one-off scripts for testing purposes.\n\nIf you use a Node.js environment manager like Volta, you'll be able to switch between globally installed TypeScript versions and project-specific ones seamlessly.\n\nNow that TypeScript is installed in your project, create a configuration file that specifies which files should be compiled and the compiler options for the project. This file is called , and you should place it at the root of your project directory.\n\nHere's a basic configuration that you can start with:\n\nThe above configuration file extends the base configuration provided by the TypeScript team for the latest LTS version of Node.js (currently v18). Additional options or overrides may be included through the property. It also specifies that all the files in the directory should be included in the program, but everything in the directory is skipped entirely. Both the and properties support glob patterns.\n\nBefore you proceed, ensure you add the base configuration package for Node.js LTS to your project's through the command below. Base packages also exist for Node 10, Node 12, Node 14, up to Node 20, at the time of writing.\n\nGo ahead and create the aforementioned directory in your project root, and place a file inside it. This file should contain the following code:\n\nSave the file, then attempt to compile the TypeScript code to JavaScript through the command below:\n\nYou will get an error indicating that the compiler does not understand the object:\n\nThis error occurs because the compiler option set in the base configuration for Node.js LTS does not include the option, which contains type definitions for the object and other browser-specific APIs. The error message above suggests adding the option to the property to fix the problem, but this is not the correct solution for a Node.js project.\n\nThe correct fix involves installing the type definitions for Node.js APIs so that the TypeScript compiler can understand and validate all the built-in Node.js APIs. Here's how:\n\nOnce installed, the error will vanish the next time is run and a file will be produced in the folder with the following content:\n\nYou can subsequently execute this file through the command:\n\nIf you want to change the folder where the JavaScript files are placed, you can use the outDir compiler option in your file:\n\nSubsequent compilations will emit the JavaScript output into a folder.\n\nThe process of compiling TypeScript source files into JavaScript code before executing them with Node.js can get a little tedious after a while, especially during development. You can eliminate the intermediate steps before running the program through the ts-node CLI to execute files directly. Go ahead and install the package using the command below:\n\nAfterward, execute the file with the command:\n\nUsing in this way places the TypeScript compiler as a middleman between the source files and the Node.js runtime. It transpiles the source code before executing the resulting JavaScript code with (performed under the hood). This makes the script execution a bit slower than JavaScript output directly with . You can opt out of type checking through the or flag to make the script execute faster in scenarios where type validation isn't essential.\n\nAnother feature that enables is the transformation of modern syntax to CommonJS syntax. This means that when using , you can use instead of to utilize Node.js modules in your code. Learn more about this feature in the project's README document.\n\nWhen utilizing Node.js packages from the npm registry, additional setup may be required to compile the project successfully.\n\nThe main problem is that most of the packages you're likely to encounter are written in vanilla JavaScript, so TypeScript cannot determine the valid types for exposed methods. Everything from the library is implicitly typed as .\n\nHere's an example that utilizes the popular Express package to create a web server:\n\nAssuming you've installed the express module with , execute the script with . It should yield the following errors:\n\nThe TypeScript compiler is responsible for the errors shown above. It cannot determine the type of the and parameters in the callback function, so they are both implicitly typed as .\n\nSince the compiler option is set to in the base tsconfig.json file, the noImplicitAny compiler option is also enabled. This ensures that TypeScript will emit an error instead of inferring type when it is unable to determine the type of a value.\n\nYou can fix this error by providing a type declaration file for the module so that the TypeScript compiler can accurately determine the valid types for its exported methods. You can find up-to-date type definitions for many popular npm packages in the DefinitelyTyped GitHub repository.\n\nThe type definition for a package can be downloaded through the scope. For example, use the command below to install the type definitions for Express:\n\nAfter installing the type definitions for Express, compiling and executing the script with should complete successfully without errors.\n\nAn important step towards adding comprehensive support for TypeScript in a Node.js application is setting an adequate linting workflow. You can make use of the popular ESLint package to lint TypeScript code. Although it was originally written for JavaScript code, it also supports TypeScript with the help of a few plugins. Go ahead and install the eslint package in your project with the command below:\n\nNow create a new file in the root of your project directory. Here is where you'll place the configuration settings for ESLint. Note that with the release of ESLint v9.0.0 the config system will change and the config file will be named eslint.config.js.\n\nTo add TypeScript support to ESLint, install the @typescript-eslint/parser and @typescript-eslint/eslint-plugin packages in your project. The former is used to parse TypeScript code to a format that is understandable by ESLint, while the latter provides TypeScript-specific linting rules.\n\nOnce both packages are installed, open up your file in your editor, and enter the following:\n\nIf you want to override any of the linting rules or configure other rules, use the property in the file, as shown below:\n\nAfter saving the file, run the ESLint CLI on your TypeScript code through this command:\n\nYou can also create a script in your file as follows:\n\nTo prevent ESLint from linting certain files or directories, create a file in your project root, and place the patterns for files to ignore therein. Here's an example in which all generated files in the folder are ignored:\n\nYou can also decide to omit every single JavaScript file in your project directory with the following pattern:\n\nNote that everything in the folder, and files or folders that begin with a dot character (except eslint config files), are ignored automatically, so there's no need to place patterns matching such files in your file.\n\nDebugging TypeScript source files is easy and straightforward with the help of and Visual Studio Code. All you need to do is create a launch configuration file ( ) within the directory in the project root and populate the file with the following code:\n\nThe method is preloaded in the above file to handle TypeScript source files correctly. Secondly, the name of the TypeScript file to run when starting a debugging session is provided as the first value in the property.\n\nGo ahead and start debugging your Node.js project by pressing F5 on your keyboard. Try to set a breakpoint, then inspect the values in the current scope once the breakpoint is hit. It should work as expected, without issues!\n\nAccording to its author, ts-node is safe to use in production. Nonetheless, to reduce the start-up time of the server and prevent additional memory usage from keeping the compiler in memory, it's better to compile the source files beforehand. Execute the resulting JavaScript code with the command when deploying to production.\n\nIn this article, you learned how to configure a Node.js project with TypeScript support and run TypeScript source files directly, without an intermediate compilation step.\n\nWe also covered how type definition files work, and how to take advantage of predefined type definition files for popular npm packages so that the TypeScript compiler fully validates all third-party dependencies.\n\nFinally, we discussed how to debug TypeScript files in VSCode, and what to do when deploying your TypeScript project to production.\n\nThanks for reading, and happy coding!\n\nP.S. If you liked this post, subscribe to our JavaScript Sorcery list for a monthly deep dive into more magical JavaScript tips and tricks.\n\nP.P.S. If you need an APM for your Node.js app, go and check out the AppSignal APM for Node.js."
    },
    {
        "link": "https://luqmanshaban.medium.com/setting-up-typescript-in-a-node-js-application-a-step-by-step-guide-dc99ad29e18",
        "document": "TypeScript is a powerful super set of JavaScript that adds static typing and advanced features to the language. When building Node.js applications, TypeScript can enhance development by providing type checking, better code organization, and improved tooling. In this article, we will walk through the process of setting up TypeScript in a Node.js application, including configuring the and files. By the end, you will be able to console.log \"Hello TypeScript\" from an file.\n\nStep 1: Create a new Node.js project Before setting up TypeScript, make sure you have Node.js installed on your machine. Create a new directory for your project and navigate to it using the command line. Initialize a new Node.js project by running the following command:\n\nStep 2: Install required dependencies To work with TypeScript in a Node.js project, we need to install specific dependencies. In the file, add the following dependencies under the section:\n\nSave the file, and run the following command to install the dependencies:\n\nStep 3: Create the tsconfig.json file To configure TypeScript, we need to create a file at the root of our project. This file defines the compiler options and other settings. Open a text editor and paste the following content into the file:\n\nHere’s a breakdown of the key options in the section:\n• : Specifies the ECMAScript version to compile the TypeScript code to. In this case, we target ECMAScript 6.\n• : Sets the module system to CommonJS, which is used by Node.js.\n• : Generates source map files, which are useful for debugging TypeScript code.\n• : Enables compatibility with modules that use the CommonJS module syntax.\n\nStep 4: Create an index.ts file In the root of your project, create a new directory. Inside the directory, create an file. Open the file in a text editor and add the following code:\n\nStep 5: Build and run the TypeScript code To compile the TypeScript code and run the application, we’ll add a script to the file. Under the section, add the following line:\n\nStep 6: Build and run the application To compile the TypeScript code into JavaScript and start the application, run the following command:\n\nYou should see the output in the console, indicating that TypeScript is successfully set up in your Node.js application.\n\nConclusion: In this article, we walked through the steps required to set up TypeScript in a Node.js application. By configuring the file and installing the necessary dependencies, we enabled static typing and other TypeScript features in our project. Additionally, we created a simple file and used the function to output \"Hello TypeScript.\" Armed with this knowledge, you can now leverage the benefits of TypeScript when developing Node.js applications."
    },
    {
        "link": "https://stackoverflow.com/questions/71576397/how-to-configure-typescript-tsconfig-json-in-node-js-to-work-with-esmodules-in",
        "document": "I have a Node.js TypeScript project (AWS Lambda function) that has been working correctly for many months. However I recently needed to add the got package which is an ES Module and trying to run the transpiled project now results in:\n\nThis makes sense and looking inside , the package is indeed an ES Module ( ). However, I was not able to come up with a version of tsconfig.json that would allow me to import this module AND not force me to update my app code in ugly ways (see below) or bundle it (which is obviously a problem for a lambda).\n\nCould anyone please point me to a working in a Node project that supports ES modules inside node_modules?\n\nOne working \"solution\" is to convert my lambda into an ES module too ( in ) and set \"module\" and \"target\" in tsconfig.json to . This will functionally work, but is also forcing me to add suffixes into all relative imports in the project, which is really weird and difficult to read in TypeScript files. I also fear this might not work correctly in environments using older versions of Node.\n\nBundling with and works too, but obviously breaks Lambda's layer/handler separation.\n\nThanks a lot for any ideas!"
    }
]