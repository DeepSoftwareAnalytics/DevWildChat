[
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/overview/powerpoint",
        "document": "This reference contains conceptual overviews, programming tasks, samples, and references to guide you in developing solutions based on PowerPoint.\n\nUse the table of contents in the navigation on the left to view the topics in the following sections:\n• None Object model reference: Provides reference materials for the PowerPoint object model.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://brightcarbon.com/blog/how-to-use-vba-in-powerpoint",
        "document": "You can do some really cool things in Microsoft Office with just a few lines of Visual Basic for Applications (VBA) - from creating your own custom formula in Excel to correcting branded content in PowerPoint to merging address data for a mail campaign in Word. And sometimes you need to share that VBA solution with colleagues and clients, via the Internet. A change that Microsoft rolled out at the end of March 2022 tweaks the process required by Windows users to gain access to this active content."
    },
    {
        "link": "https://learn.microsoft.com/en-us/previous-versions/office/troubleshoot/office-developer/automate-create-presentation-using-visual-basic-net",
        "document": "This article describes how to use automation to create and to show a Microsoft PowerPoint presentation by using Microsoft Visual Basic .NET 2002 or Visual Basic .NET 2003.\n• None Start Microsoft Visual Studio .NET 2002 or Visual Studio .NET 2003. On the File menu, click New and then click Project. Select Windows Application from the Visual Basic Projects types. Form1 is created by default.\n• None Add a reference to the Microsoft PowerPoint Object Library and the Microsoft Graph Object Library. To do this, follow these steps:\n• On the COM tab, locate the Microsoft PowerPoint Object Library, and then click Select. Also locate the Microsoft Graph Object Library, and then click Select. Note Microsoft Office 2003 and later versions of Microsoft Office includes Primary Interop Assemblies (PIAs). Microsoft Office XP does not include PIAs, but they may be downloaded.\n• None In the code window, locate the following code Private Sub Button1_Click(ByVal sender As System.Object, _ ByVal e As System.EventArgs) Handles Button1.Click End Sub Replace with the following code: Private Sub Button1_Click(ByVal sender As System.Object, _ ByVal e As System.EventArgs) Handles Button1.Click Const sTemplate = _ \"C:\\Program Files\\Microsoft Office\\Templates\\Presentation Designs\\Blends.pot\" Const sPic = \"C:\\WINNT\\Soap Bubbles.bmp\" Dim oApp As PowerPoint.Application Dim oPres As PowerPoint.Presentation Dim oSlide As PowerPoint.Slide Dim bAssistantOn As Boolean 'Start Powerpoint and make its window visible but minimized. oApp = New PowerPoint.Application() oApp.Visible = True oApp.WindowState = PowerPoint.PpWindowState.ppWindowMinimized 'Create a new presentation based on the specified template. oPres = oApp.Presentations.Open(sTemplate, , , True) 'Build Slide #1: 'Add text to the slide, change the font and insert/position a 'picture on the first slide. oSlide = oPres.Slides.Add(1, PowerPoint.PpSlideLayout.ppLayoutTitleOnly) With oSlide.Shapes.Item(1).TextFrame.TextRange .Text = \"My Sample Presentation\" .Font.Name = \"Comic Sans MS\" .Font.Size = 48 End With oSlide.Shapes.AddPicture(sPic, False, True, 150, 150, 500, 350) oSlide = Nothing 'Build Slide #2: 'Add text to the slide title, format the text. Also add a chart to the 'slide and change the chart type to a 3D pie chart. oSlide = oPres.Slides.Add(2, PowerPoint.PpSlideLayout.ppLayoutTitleOnly) With oSlide.Shapes.Item(1).TextFrame.TextRange .Text = \"My Chart\" .Font.Name = \"Comic Sans MS\" .Font.Size = 48 End With Dim oChart As Graph.Chart oChart = oSlide.Shapes.AddOLEObject(150, 150, 480, 320, _ \"MSGraph.Chart.8\").OLEFormat.Object oChart.ChartType = Graph.XlChartType.xl3DPie oChart = Nothing oSlide = Nothing 'Build Slide #3: 'Add a text effect to the slide and apply shadows to the text effect. oSlide = oPres.Slides.Add(3, PowerPoint.PpSlideLayout.ppLayoutBlank) oSlide.FollowMasterBackground = False Dim oShape As PowerPoint.Shape oShape = oSlide.Shapes.AddTextEffect(Office.MsoPresetTextEffect.msoTextEffect27, _ \"The End\", \"Impact\", 96, False, False, 230, 200) oShape.Shadow.ForeColor.SchemeColor = PowerPoint.PpColorSchemeIndex.ppForeground oShape.Shadow.Visible = True oShape.Shadow.OffsetX = 3 oShape.Shadow.OffsetY = 3 oShape = Nothing oSlide = Nothing 'Modify the slide show transition settings for all 3 slides in 'the presentation. Dim SlideIdx(3) As Integer SlideIdx(0) = 1 SlideIdx(1) = 2 SlideIdx(2) = 3 With oPres.Slides.Range(SlideIdx).SlideShowTransition .AdvanceOnTime = True .AdvanceTime = 3 .EntryEffect = PowerPoint.PpEntryEffect.ppEffectBoxOut End With Dim oSettings As PowerPoint.SlideShowSettings oSettings = oPres.SlideShowSettings oSettings.StartingSlide = 1 oSettings.EndingSlide = 3 'Prevent Office Assistant from displaying alert messages. bAssistantOn = oApp.Assistant.On oApp.Assistant.On = False 'Run the slide show and wait for the slide show to end. oSettings.Run() Do While oApp.SlideShowWindows.Count >= 1 System.Windows.Forms.Application.DoEvents() Loop oSettings = Nothing 'Reenable Office Assisant, if it was on. If bAssistantOn Then oApp.Assistant.On = True oApp.Assistant.Visible = False End If 'Close the presentation without saving changes and quit PowerPoint. oPres.Saved = True oPres.Close() oPres = Nothing oApp.Quit() oApp = Nothing GC.Collect() End Sub Note In this code, the sTemplate and sPic constants represent the full path and filename to a PowerPoint template and a picture, respectively. Modify these paths as needed to use a template or picture that is installed on your system."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/library-reference/concepts/getting-started-with-vba-in-office",
        "document": "Getting started with VBA in Office\n\nAre you facing a repetitive clean up of fifty tables in Word? Do you want a particular document to prompt the user for input when it opens? Are you having difficulty figuring out how to get your contacts from Microsoft Outlook into a Microsoft Excel spreadsheet efficiently?\n\nYou can perform these tasks and accomplish a great deal more by using Visual Basic for Applications (VBA) for Office—a simple, but powerful programming language that you can use to extend Office applications.\n\nThis article is for experienced Office users who want to learn about VBA and who want some insight into how programming can help them to customize Office.\n\nThe Office suite of applications has a rich set of features. There are many different ways to author, format, and manipulate documents, email, databases, forms, spreadsheets, and presentations. The great power of VBA programming in Office is that nearly every operation that you can perform with a mouse, keyboard, or a dialog box can also be done by using VBA. Further, if it can be done once with VBA, it can be done just as easily a hundred times. (In fact, the automation of repetitive tasks is one of the most common uses of VBA in Office.)\n\nBeyond the power of scripting VBA to accelerate every-day tasks, you can use VBA to add new functionality to Office applications or to prompt and interact with the user of your documents in ways that are specific to your business needs. For example, you could write some VBA code that displays a pop up message that reminds users to save a document to a particular network drive the first time they try to save it.\n\nThis article explores some of the primary reasons to leverage the power of VBA programming. It explores the VBA language and the out-of-the-box tools that you can use to work with your solutions. Finally, it includes some tips and ways to avoid some common programming frustrations and missteps.\n\nWhen to use VBA and why\n\nThere are several principal reasons to consider VBA programming in Office.\n\nVBA is effective and efficient when it comes to repetitive solutions to formatting or correction problems. For example, have you ever changed the style of the paragraph at the top of each page in Word? Have you ever had to reformat multiple tables that were pasted from Excel into a Word document or an Outlook email? Have you ever had to make the same change in multiple Outlook contacts?\n\nIf you have a change that you have to make more than ten or twenty times, it may be worth automating it with VBA. If it is a change that you have to do hundreds of times, it certainly is worth considering. Almost any formatting or editing change that you can do by hand, can be done in VBA.\n\nThere are times when you want to encourage or compel users to interact with the Office application or document in a particular way that is not part of the standard application. For example, you might want to prompt users to take some particular action when they open, save, or print a document.\n\nDo you need to copy all of your contacts from Outlook to Word and then format them in some particular way? Or, do you need to move data from Excel to a set of PowerPoint slides? Sometimes simple copy and paste does not do what you want it to do, or it is too slow. Use VBA programming to interact with the details of two or more Office applications at the same time and then modify the content in one application based on the content in another.\n\nDoing things another way\n\nVBA programming is a powerful solution, but it is not always the optimal approach. Sometimes it makes sense to use other ways to achieve your aims.\n\nThe critical question to ask is whether there is an easier way. Before you begin a VBA project, consider the built-in tools and standard functionalities. For example, if you have a time-consuming editing or layout task, consider using styles or accelerator keys to solve the problem. Can you perform the task once and then use CTRL+Y (Redo) to repeat it? Can you create a new document with the correct format or template, and then copy the content into that new document?\n\nOffice applications are powerful; the solution that you need may already be there. Take some time to learn more about Office before you jump into programming.\n\nBefore you begin a VBA project, ensure that you have the time to work with VBA. Programming requires focus and can be unpredictable. Especially as a beginner, never turn to programming unless you have time to work carefully. Trying to write a \"quick script\" to solve a problem when a deadline looms can result in a very stressful situation. If you are in a rush, you might want to use conventional methods, even if they are monotonous and repetitive.\n\nUsing code to make applications do things\n\nYou might think that writing code is mysterious or difficult, but the basic principles use every-day reasoning and are quite accessible. Microsoft Office applications are created in such a way that they expose things called objects that can receive instructions, in much the same way that a phone is designed with buttons that you use to interact with the phone. When you press a button, the phone recognizes the instruction and includes the corresponding number in the sequence that you are dialing. In programming, you interact with the application by sending instructions to various objects in the application. These objects are expansive, but they have their limits. They can only do what they are designed to do, and they will only do what you instruct them to do.\n\nFor example, consider the user who opens a document in Word, makes a few changes, saves the document, and then closes it. In the world of VBA programming, Word exposes a Document object. By using VBA code, you can instruct the Document object to do things such as Open, Save, or Close.\n\nThe following section discusses how objects are organized and described.\n\nDevelopers organize programming objects in a hierarchy, and that hierarchy is called the object model of the application. Word, for example, has a top-level Application object that contains a Document object. The Document object contains Paragraph objects and so on. Object models roughly mirror what you see in the user interface. They are a conceptual map of the application and its capabilities.\n\nThe definition of an object is called a class, so you might see these two terms used interchangeably. Technically, a class is the description or template that is used to create, or instantiate, an object.\n\nOnce an object exists, you can manipulate it by setting its properties and calling its methods. If you think of the object as a noun, the properties are the adjectives that describe the noun and the methods are the verbs that animate the noun. Changing a property changes some quality of appearance or behavior of the object. Calling one of the object methods causes the object to perform some action.\n\nThe VBA code in this article runs against an open Office application where many of the objects that the code manipulates are already up and running; for example, the Application itself, the Worksheet in Excel, the Document in Word, the Presentation in PowerPoint, the Explorer and Folder objects in Outlook. Once you know the basic layout of the object model and some key properties of the Application that give access to its current state, you can start to extend and manipulate that Office application with VBA in Office.\n\nIn Word, for example, you can change the properties and invoke the methods of the current Word document by using the ActiveDocument property of the Application object. This ActiveDocument property returns a reference to the Document object that is currently active in the Word application. \"Returns a reference to\" means \"gives you access to.\"\n\nThe following code does exactly what it says; that is, it saves the active document in the application.\n\nRead the code from left to right, \"In this Application, with the Document referenced by ActiveDocument, invoke the Save method.\" Be aware that Save is the simplest form of method; it does not require any detailed instructions from you. You instruct a Document object to Save and it does not require any more input from you.\n\nIf a method requires more information, those details are called parameters. The following code runs the SaveAs method, which requires a new name for the file.\n\nValues listed in parentheses after a method name are the parameters. Here, the new name for the file is a parameter for the SaveAs method.\n\nYou use the same syntax to set a property that you use to read a property. The following code executes a method to select cell A1 in Excel and then to set a property to put something in that cell.\n\nThe first challenge in VBA programming is to get a feeling for the object model of each Office application and to read the object, method, and property syntax. The object models are similar in all Office applications, but each is specific to the kind of documents and objects that it manipulates.\n\nIn the first line of the code snippet, there is the Application object, Excel this time, and then the ActiveSheet, which provides access to the active worksheet. After that is a term not as familiar, Range, which means \"define a range of cells in this way.\" The code instructs Range to create itself with just A1 as its defined set of cells. In other words, the first line of code defines an object, the Range, and runs a method against it to select it. The result is automatically stored in another property of the Application called Selection.\n\nThe second line of code sets the Value property of Selection to the text \"Hello World\", and that value appears in cell A1.\n\nThe simplest VBA code that you write might simply gain access to objects in the Office application that you are working with and set properties. For example, you could get access to the rows in a table in Word and change their formatting in your VBA script.\n\nThat sounds simple, but it can be incredibly useful; once you can write that code, you can harness all of the power of programming to make those same changes in several tables or documents, or make them according to some logic or condition. For a computer, making 1000 changes is no different from making 10, so there is an economy of scale here with larger documents and problems, and that is where VBA can really shine and save you time.\n\nNow that you know something about how Office applications expose their object models, you are probably eager to try calling object methods, setting object properties, and responding to object events. To do so, you must write your code in a place and in a way that Office can understand; typically, by using the Visual Basic Editor. Although it is installed by default, many users don't know that it is even available until it is enabled on the ribbon.\n\nAll Office applications use the ribbon. One tab on the ribbon is the Developer tab, where you access the Visual Basic Editor and other developer tools. Because Office does not display the Developer tab by default, you must enable it by using the following procedure:\n• None On the File tab, choose Options to open the Options dialog box.\n• None Choose Customize Ribbon on the left side of the dialog box.\n• None Under Choose commands from on the left side of the dialog box, select Popular Commands.\n• None Under Customize the Ribbon on the right side of the dialog box, select Main Tabs in the drop down list box, and then select the Developer checkbox.\n\nAfter you enable the Developer tab, it is easy to find the Visual Basic and Macros buttons.\n\nTo protect Office users against viruses and dangerous macro code, you cannot save macro code in a standard Office document that uses a standard file extension. Instead, you must save the code in a file with a special extension. For example you cannot save macros in a standard Word document with a .docx extension; instead, you must use a special Word Macro-Enabled Document with a .docm extension.\n\nWhen you open a .docm file, Office security might still prevent the macros in the document from running, with or without telling you. Examine the settings and options in the Trust Center on all Office applications. The default setting disables macro from running, but warns you that macros have been disabled and gives you the option to turn them back on for that document.\n\nYou can designate specific folders where macros can run by creating Trusted Locations, Trusted Documents, or Trusted Publishers. The most portable option is to use Trusted Publishers, which works with digitally signed documents that you distribute. For more information about the security settings in a particular Office application, open the Options dialog box, choose Trust Center, and then choose Trust Center Settings.\n\nWhen you choose the Macro button on the Developer tab, it opens the Macros dialog box, which gives you access to VBA subroutines or macros that you can access from a particular document or application. The Visual Basic button opens the Visual Basic Editor, where you create and edit VBA code.\n\nAnother button on the Developer tab in Word and Excel is the Record Macro button, which automatically generates VBA code that can reproduce the actions that you perform in the application. Record Macro is a terrific tool that you can use to learn more about VBA. Reading the generated code can give you insight into VBA and provide a stable bridge between your knowledge of Office as a user and your knowledge as a programmer. The only caveat is that the generated code can be confusing because the Macro editor must make some assumptions about your intentions, and those assumptions are not necessarily accurate.\n• None Open Excel to a new Workbook and choose the Developer tab in the ribbon. Choose Record Macro and accept all of the default settings in the Record Macro dialog box, including Macro1 as the name of the macro and This Workbook as the location.\n• None Choose OK to begin recording the macro. Note how the button text changes to Stop Recording. Choose that button the instant you complete the actions that you want to record.\n• None Choose cell B1 and type the programmer's classic first string: Hello World. Stop typing and look at the Stop Recording button; it is grayed out because Excel is waiting for you to finish typing the value in the cell.\n• None Choose cell B2 to complete the action in cell B1, and then choose Stop Recording.\n• None Choose Macros on the Developer tab, select Macro1 if it is not selected, and then choose Edit to view the code from Macro1 in the Visual Basic Editor.\n\nLooking at the code\n\nThe macro that you created should look similar to the following code.\n\nBe aware of the similarities to the earlier code snippet that selected text in cell A1, and the differences. In this code, cell B1 is selected, and then the string \"Hello World\" is applied to the cell that has been made active. The quotes around the text specify a string value as opposed to a numeric value.\n\nRemember how you chose cell B2 to display the Stop Recording button again? That action shows up as a line of code as well. The macro recorder records every keystroke.\n\nThe lines of code that start with an apostrophe and colored green by the editor are comments that explain the code or remind you and other programmers the purpose of the code. VBA ignores any line, or portion of a line, that begins with a single quote. Writing clear and appropriate comments in your code is an important topic, but that discussion is out of the scope of this article. Subsequent references to this code in the article don't include those four comment lines.\n\nWhen the macro recorder generates the code, it uses a complex algorithm to determine the methods and the properties that you intended. If you don't recognize a given property, there are many resources available to help you. For example, in the macro that you recorded, the macro recorder generated code that refers to the FormulaR1C1 property. Not sure what that means?\n\nSelect FormulaR1C1 in the recorded macro and press F1. The Help system runs a quick search, determines that the appropriate subjects are in the Excel Developer section of the Excel Help, and lists the FormulaR1C1 property. You can choose the link to read more about the property, but before you do, be aware of the Excel Object Model Reference link near the bottom of the window. Choose the link to view a long list of objects that Excel uses in its object model to describe the Worksheets and their components.\n\nChoose any one of those to see the properties and methods that apply to that particular object, along with cross references to different related options. Many Help entries also have brief code examples that can help you. For example, you can follow the links in the Borders object to see how to set a border in VBA.\n\nThe Borders code looks different from the recorded macro. One thing that can be confusing with an object model is that there is more than one way to address any given object, cell A1 in this example.\n\nSometimes the best way to learn programming is to make minor changes to some working code and see what happens as a result. Try it now. Open Macro1 in the Visual Basic Editor and change the code to the following.\n\nYou don't need to save the code to try it out, so return to the Excel document, choose Macros on the Developer tab, choose Macro1, and then choose Run. Cell A1 now contains the text Wow! and has a double-line border around it.\n\nFigure 3. Results of your first macro\n\nYou just combined macro recording, reading the object model documentation, and simple programming to make a VBA program that does something. Congratulations!\n\nDid not work? Read on for debugging suggestions in VBA.\n\nThe VBA community is very large; a search on the Web can almost always yield an example of VBA code that does something similar to what you want to do. If you cannot find a good example, try to break the task down into smaller units and search on each of those, or try to think of a more common, but similar problem. Starting with an example can save you hours of time.\n\nThat does not mean that free and well-thought-out code is on the Web waiting for you to come along. In fact, some of the code that you find might have bugs or mistakes. The idea is that the examples you find online or in VBA documentation give you a head start. Remember that learning programming requires time and thought. Before you get in a big rush to use another solution to solve your problem, ask yourself whether VBA is the right choice for this problem.\n\nProgramming can get complex quickly. It's critical, especially as a beginner, that you break the problem down to the smallest possible logical units, then write and test each piece in isolation. If you have too much code in front of you and you get confused or muddled, stop and set the problem aside. When you come back to the problem, copy out a small piece of the problem into a new module, solve that piece, get the code working, and test it to ensure that it works. Then move on to the next part.\n\nThere are two main types of programming errors: syntax errors, which violate the grammatical rules of the programming language, and run-time errors, which look syntactically correct, but fail when VBA attempts to execute the code.\n\nAlthough they can be frustrating to fix, syntax errors are easy to catch; the Visual Basic Editor beeps and flashes at you if you type a syntax error in your code.\n\nFor example, string values must be surrounded by double quotes in VBA. To find out what happens when you use single quotes instead, return to the Visual Basic Editor and replace the \"Wow!\" string in the code example with 'Wow!' (that is, the word Wow enclosed in single quotes). If you choose the next line, the Visual Basic Editor reacts. The error \"Compile error: Expected: expression\" is not that helpful, but the line that generates the error turns red to tell you that you have a syntax error in that line and as a result, this program will not run.\n\nChoose OK and change the text back to\"Wow!\".\n\nRuntime errors are harder to catch because the programming syntax looks correct, but the code fails when VBA tries to execute it.\n\nFor example, open the Visual Basic Editor and change the Value property name to ValueX in your Macro, deliberately introducing a runtime error since the Range object does not have a property called ValueX. Go back to the Excel document, open the Macros dialog box and run Macro1 again. You should see a Visual Basic message box that explains the run-time error with the text, \"Object doesn't support this property of method.\" Although that text is clear, choose Debug to find out more.\n\nWhen you return to the Visual Basic Editor, it is in a special debug mode that uses a yellow highlight to show you the line of code that failed. As expected, the line that includes the ValueX property is highlighted.\n\nYou can make changes to VBA code that is running, so change ValueX back to Value and choose the little green play button underneath the Debug menu. The program should run normally again.\n\nIt's a good idea to learn how to use the debugger more deliberately for longer, more complex programs. At a minimum, learn a how to set break-points to stop execution at a point where you want to take a look at the code, how to add watches to see the values of different variables and properties as the code runs, and how to step through the code line by line. These options are all available in the Debug menu and serious debugger users typically memorize the accompanying keyboard shortcuts.\n\nTo open the Developer Reference that is built into Office Help, open the Help reference from any Office application by choosing the question mark in the ribbon or by pressing F1. Then, to the right of the Search button, choose the dropdown arrow to filter the contents. Choose Developer Reference. If you don't see the table of contents in the left panel, choose the little book icon to open it, and then expand the Object Model Reference from there.\n\nFigure 4. Filtering on developer Help applies to all Office applications\n\nTime spent browsing the Object Model reference pays off. After you understand the basics of VBA syntax and the object model for the Office application that you are working with, you advance from guesswork to methodical programming.\n\nOf course the Microsoft Office Developer Center is an excellent portal for articles, tips, and community information.\n\nAll programmers get stuck sometimes, even after reading every reference article they can find and losing sleep at night thinking about different ways to solve a problem. Fortunately, the Internet has fostered a community of developers who help each other solve programming problems.\n\nAny search on the Web for \"office developer forum\" reveals several discussion groups. You can search on \"office development\" or a description of your problem to discover forums, blog posts, and articles as well.\n\nIf you have done everything that you can to solve a problem, don't be afraid to post your question to a developers forum. These forums welcome posts from newer programmers and many of the experienced developers are glad to help.\n\nThe following are a few points of etiquette to follow when you post to a developer forum:\n• None Before you post, look on the site for an FAQ or for guidelines that members want you to follow. Ensure that you post content that is consistent with those guidelines and in the correct section of the forum.\n• None Include a clear and complete code sample, and consider editing your code to clarify it for others if it is part of a longer section of code.\n• None Describe your problem clearly and concisely, and summarize any steps that you have taken to solve the problem. Take the time to write your post as well as you can, especially if you are flustered or in a hurry. Present the situation in a way that will make sense to readers the first time that they read the problem statement.\n• None Be polite and express your appreciation.\n\nGoing further with programming\n\nAlthough this article is short and only scratches the surface of VBA and programming, it is hopefully enough to get you started.\n\nThis section briefly discusses a few more key topics.\n\nIn the simple examples in this article you manipulated objects that the application had already created. You might want to create your own objects to store values or references to other objects for temporary use in your application. These are called variables.\n\nTo use a variable in VBA, must tell VBA which type of object the variable represents by using the Dim statement. You then set its value and use it to set other variables or properties.\n\nThe simple programs in this article execute one line at a time, from the top down. The real power in programming comes from the options that you have to determine which lines of code to execute, based on one or more conditions that you specify. You can extend those capabilities even further when you can repeat an operation many times. For example, the following code extends Macro1.\n\nType or paste the code into the Visual Basic Editor and then run it. Follow the directions in the message box that appears and change the text in cell A1 from Wow! to Yes! and run it again to see the power of looping. This code snippet demonstrates variables, branching and looping. Read it carefully after you see it in action and try to determine what happens as each line executes.\n\nAll of my Office applications: example code\n\nHere are a few scripts to try; each solves a real-world Office problem.\n\nBe aware that there are situations in which you might want to automate email in Outlook; you can use templates as well.\n\nBe aware that you can select a column of cells and run this macro to delete all rows in the selected column that have a blank cell.\n\nBe aware that this code loops through all of the slides and deletes all text boxes that don't have any text. The count variable decrements instead of increments because each time the code deletes an object, it removes that object from the collection, which reduces the count.\n\nBe aware that this code copies the currently open contact in Outlook into the open Word document. This code only works if there is a contact currently open for inspection in Outlook.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://chandoo.org/wp/create-powerpoint-presentations-using-excel-vba",
        "document": "This is a guest post by Drew Kesler.\n\nYou’ve been there before. It’s almost 5:00, and you are going crazy trying to finish the presentation due for a monthly performance meeting the next morning. The model is refreshed, and now it just takes a LOT of copying, pasting, and positioning to get the PowerPoint ready. Finally, the slides are finished…, until you read a new message from your boss requesting a minor change. But of course her change means you have to start all over with the copy and pastes…\n\nThere is always a better way! In the Oil and Gas industry, I constantly have monthly reports to assess the performance of our operating assets. Excel VBA makes it a cinch to automate the entire process. So when a simple change is requested, the presentation is automatically generated with the click of a button. No more wasting time!\n\nSo, here it is – How to Save TONS of Time by Using an Excel VBA Macro to Build Your Presentation:\n\n2. Create a new worksheet and paste in all the charts you need for the presentation.\n\n\n\n3. Open VBA. To do this, you can either press ALT + F11, or you can take the following steps:\n\na. To show the developer tab, click on the Microsoft Office Button and click Excel Options.\n\n\n\nb. Click Popular and then select the Show Developer tab in the Ribbon.\n\n\n\nc. Click on the Developer tab in the ribbon and click Visual Basic.\n\n\n\n5. Paste the following code into the module (I included comments so you can customize it to your liking).\n\n\n\n7. Now all you need to do is go to Excel and run the CreatePowerPoint macro! To make this easy, draw a rectangle shape in your Excel worksheet which contains all the charts you want to export to PowerPoint.\n\n8. Right click the rectangle and click Assign Macro.\n\n\n\n9. Click on the CreatePowerPoint macro and press Okay.\n\n\n\n10. That’s it! Just click your rectangle button then sit back and watch it run! You’ll have your presentation in no time!\n\n\n\nDownload the Example Workbook & Play with this Macro\n\nClick here to download the example workbook and play with the macro.\n\nNote: If you have an error with Power Point application activation, use this code instead.\n\nThank you so much Drew for writing this insightful article and showing us how to automate PPT Creation thru Excel VBA. I have really enjoyed playing this idea. And I am sure our readers will also like it.\n\nIf you like this technique, say thanks to Drew.\n\nHow do you Automate PPT Creation?\n\nDuring my day job, I used to make a lot of presentations. But each one was different. So I used to spend hours crafting them.\n\nAnd nowadays, I hardly make a presentation. But I know many of you make PPTs day in day out. And this technique presented by Drew is a very powerful way to save time.\n\nDo you use macros to automate creation of presentations? What are your favorite tricks & ideas? Please share using comments.\n\nLearn More VBA – Sign-up for our VBA Class Waiting List\n\n\n\nChandoo.org runs a VBA Class that teaches you from scratch, how to build macros to save time & automate your work. We opened our first batch in May this year and had an excellent response. More than 650 students signed up and are now learning VBA each day.\n\nIf you want to learn VBA & advanced Excel, this is a very good class to join.\n\nClick here for full information on VBA classes.\n\nDrew Kesler specializes in process automation and data visualization. He currently performs analytics and modeling for the Oil and Gas industry. His most recent projects include using GIS mapping technology to visualize data and enhance interaction across organizations."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/powerpoint.shape",
        "document": "Represents an object in the drawing layer, such as an AutoShape, freeform, OLE object, or picture.\n\nThere are three objects that represent shapes: the Shapes collection, which represents all the shapes on a document; the ShapeRange collection, which represents a specified subset of the shapes on a document (for example, a ShapeRange object could represent shapes one and four on the document, or it could represent all the selected shapes on the document); and the Shape object, which represents a single shape on a document. If you want to work with several shapes at the same time or with shapes within the selection, use a ShapeRange collection. For an overview of how to work with either a single shape or with more than one shape at a time, see Work with shapes (drawing objects).\n\nThe following examples describe how to:\n• None Return an existing shape on a slide, indexed by name or number.\n• None Return the slide title and other placeholders on a slide.\n• None Return the shapes attached to the ends of a connector.\n\nUse Shapes (index), where index is the shape name or the index number, to return a Shape object that represents a shape on a slide. The following example horizontally flips shape one and the shape named Rectangle 1 on myDocument.\n\nEach shape is assigned a default name when you add it to the Shapes collection. To give the shape a more meaningful name, use the Name property. The following example adds a rectangle to myDocument, gives it the name Red Square, and then sets its foreground color and line style.\n\nTo add a shape to a slide and return a Shape object that represents the newly created shape, use one of the following methods of the Shapes collection: Add3DModel, AddCallout, AddConnector, AddCurve, AddLabel, AddLine, AddMediaObject, AddOLEObject, AddPicture, AddPlaceholder, AddPolyline, AddShape, AddTable, AddTextbox, AddTextEffect, AddTitle.\n\nUse Selection.ShapeRange (index), where index is the shape name or the index number, to return a Shape object that represents a shape within the selection. The following example sets the fill for the first shape in the selection in the active window, assuming that there's at least one shape in the selection.\n\nUse Shapes.Title to return a Shape object that represents an existing slide title. Use Shapes.AddTitle to add a title to a slide that doesn't already have one and return a Shape object that represents the newly created title. Use Shapes.Placeholders (index), where index is the placeholder's index number, to return a Shape object that represents a placeholder. If you have not changed the layering order of the shapes on a slide, the following three statements are equivalent, assuming that slide one has a title.\n\nTo return a Shape object that represents one of the shapes attached by a connector, use the BeginConnectedShape or EndConnectedShape property.\n\nTo return a Shape object that represents the default shape for a presentation, use the DefaultShape property.\n\nUse the BuildFreeform and AddNodes methods to define the geometry of a new freeform, and use the ConvertToShape method to create the freeform and return the Shape object that represents it.\n\nUse GroupItems (index), where index is the shape name or the index number within the group, to return a Shape object that represents a single shape in a grouped shape.\n\nUse the Group or Regroup method to group a range of shapes and return a single Shape object that represents the newly formed group. After a group has been formed, you can work with the group the same way you work with any other shape.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://techshelps.github.io/VBA/ofun/ch06d.htm",
        "document": "PowerPoint's programming model centers around two objects: Shape and TextRange. Although Word and Excel each provide a Shapes collection object that is consistent with PowerPoint's Shapes collection object, shapes aren't the main content type in these two applications: text and cells are, respectively. In PowerPoint, the Shape object is vital because all content in a presentation, including text, exists in a shape. Even if a slide has nothing but text, the text is contained in a shape of a specific type.\n\nTo access text, first you have to access the shape in the Shapes collection object on a slide, and then access the text in a shape using the TextRange object. The TextRange object represents a continuous area of text within a shape. The TextRange object, which is very similar to and nearly as robust as Word's Range object, allows you to retrieve or set text, as well as apply formatting to text, in any shape in a presentation. You can only access the TextRange object by first accessing a shape.\n\nEach slide in a PowerPoint presentation contains a Shapes collection. To access a Shapes collection, you first need to access a specific slide in a presentation's Slides collection. A shape represents any object on a slide, including a text box, an AutoShape, an OLE object, a picture, a table, or a chart. You can access a Shape object using the Shapes collection or the ShapeRange collection. The Shapes collection represents all shapes on a slide, and a ShapeRange collection can represent all or a subset of shapes on a slide. As you'll see in this section, the ShapeRange collection is useful in cases where formatting is applied to multiple shapes.\n\nThe ShapeRange collection object usually consists of a subset of shapes that exist in the Shapes collection for a particular slide. When you work with selected shapes in the active window, you'll commonly work with the ShapeRange collection. Users generally select multiple shapes and apply settings to the shapes in the selection. Before running the following procedure, insert a number of different shapes on the slide in the active window, such as a rectangle, ActiveX control, line, WordArt, and text box. Then select all shapes and run the following procedure from a module in the Visual Basic Editor in PowerPoint:\n\nThe preceding procedure sets properties such as fill color, fill gradient, line border color, and font attributes to the selected shapes. Although some properties may not apply to specific shapes in the selection, using the ShapeRange collection object saves you from having to filter which shapes certain properties don't apply. Therefore, you can write your code generically and PowerPoint will determine if the property can or can't be applied to a specific shape in the ShapeRange collection. This is the same as the course of action in PowerPoint when you select a number of different types of shapes on a slide and click on the Fill Color button on the Drawing toolbar or the Bold button on the Formatting toolbar.\n\nIn some cases, you may want to iterate through the selected shapes, and apply property settings only to a specific shape. The following procedure determines if the slide title shape is in the selection of shapes in the active window. If the slide title shape is in the selection, the procedure positions the title shape back to specific left and top coordinates. You can change the code within the nested If…Then block to set or retrieve any property of the title shape.\n\nThis example uses the objects and properties associated with placeholders to determine if a specific shape is found on a slide or in a selection. Placeholders are described after the following example.\n\nYou can extend the previous example and make it more robust. To do so, set the left and top coordinates of the slide title shape to the default position of the title shape on the slide master of the presentation. This procedure is useful in scenarios where you may want to reset the position of a placeholder, such as the slide title, back to its default coordinates (based on the slide master).\n\nYou can view the master for the slides in the presentation by clicking Master on the View menu and then selecting Slide Master from the submenu in PowerPoint. In the preceding procedure, you declare the variable sldMaster as a Master object. It's set to the master of the slide in the active window. The slide title shape's coordinates are set to the coordinates of the title shape on the slide master.\n\nBecause the nested If…Then only looks for the placeholder of type ppPlaceholderTitle, the sldMaster will always be set to the master that's in view when you click Slide Master on PowerPoint's Master submenu. If the slide layout is a title slide (see the discussion on slide layout later in the chapter), the slide title shape would be of the placeholder type ppPlaceholderCenterTitle.\n\nPlaceholders are special kinds of shapes specific to PowerPoint and aren't found in Word's or Excel's Shapes collection. Placeholders are tied to the layout of a slide. For example, you commonly insert slides with either the title layout or, more commonly, the body layout. The body layout has both a title placeholder and a body placeholder. When you work with text and insert new slides in Outline view, slides are created with the body layout by default.\n\nUsing placeholders, you can access shapes like the slide title or body placeholder shape no matter where the placeholder shape is in the collection. When you change the z-order of a shape on the slide, the index position of a placeholder or any other shape in the Shapes collection changes. As a result, it's easier to use in your code the Placeholders collection, accessed from the Shapes collection, to access the most common shape elements on a slide.\n\nThis procedure inserts a new slide with the layout ppLayoutText. This layout represents a slide with the title and body placeholders. You then use the Placeholders collection to insert text in the title and body placeholders. The procedure adds a new AutoShape and positions it near the top left of the body placeholder.\n\nTo retrieve the main text in a presentation, you usually need to access the title and body placeholder on a slide. Some slides, however, may not have the title or body placeholder. And because there are up to 16 different placeholder PpPlaceholderType constants that represent the possible placeholder types, you may also be searching for other placeholders on a slide. The three procedures listed in this section work together to iterate through the slides in the active presentation and retrieve the slide title and body placeholder text, if either exists. They print the retrieved text to a text file under the Temp folder on the C: drive. You can change the file path \"C:\\Temp\" to an appropriate path on your machine.\n\nIn this example, the procedure sends the content of a PowerPoint presentation to a text file, but you can use the content of a PowerPoint presentation to be the basis of a new Word document. This functionality is similar to pointing to Send To on the File menu and then clicking Microsoft Word on the submenu in PowerPoint. Chapter 7 describes the reverse operation; that is, you use a Word document as a basis for creating a new PowerPoint presentation.\n\nThe first of the following three procedures is the main one. You set the variable sOutputFile to the output text file and use the Open statement to open the text file in Output mode. The Output mode indicates that if the file exists on disk, its content will be overwritten. The For Each…Next loop iterates through each slide in the presentation. The first line within the For Each…Next loop prints the slide title in the text file. The procedure retrieves the slide title by using the function SlideTitle. The section \"Iterate Through Titles in a Presentation\" later in this chapter describes the SlideTitle function.\n\nAfter the slide title is retrieved, the If…Then block in the first procedure then uses the PlaceholderExists function to determine if the body placeholder exists. Because this function is generic, you can use it to determine if any placeholder exists. You need to pass three arguments to the function. The first is the Shapes collection of the slide you want to search on for a specific type of placeholder; the second is the placeholder type you want to search for; and the third is an object declared as type Shape. If the PlaceholderExists function finds the specified placeholder type, the procedure sets the object variable shpPlaceholder to the placeholder. If the placeholder exists, the procedure prints the text contents in the body placeholder to the output text file, followed by a blank line.\n\nCopy the three preceding procedures in a code module in the Visual Basic Editor in PowerPoint, switch back to PowerPoint, and click New on the File menu. In the Presentations tab, select a presentation that's installed on your machine. Click OK. Switch back to the Visual Basic Editor and run the PrintContentsOfPresentationToTextFile procedure. Navigate to the output text file in the Microsoft Windows Explorer to see the results.\n\nYou can extend the preceding example to automatically open the text file after it's been closed for output. This is the same operation you saw in Chapter 4, where the program automatically opens the HTML document saved to disk in the Web browser installed on your machine. The last line in the first procedure in the preceding example contains the following line, which is commented out:\n\nRemove the comment from the beginning of the line, and then add the following Windows API to the top of the code module:\n\nRun the PrintContentsOfPresentationToTextFile procedure again. This time, the output text file should be opened and displayed in Microsoft Notepad. You can use this functionality in any scenario, no matter where you write Visual Basic code.\n\nAs discussed earlier in this chapter, PowerPoint's content breakdown is similar to Excel's. Excel organizes content in worksheets, and PowerPoint uses slides. In PowerPoint, the Slides collection allows your code to iterate through and work with specific slides in a presentation. You can also use the Slides collection object to add a new slide and, hence, new content.\n\nThe following procedure iterates through slides in the Slides collection object. The procedure assigns each slide to the variable sld and prints the slide name, number, and index to the Immediate window in the Visual Basic Editor in PowerPoint.\n\nBy default, PowerPoint gives a new name to each slide created, although there's no way to change a slide's name through the menus, toolbars, or dialog boxes. You can only do that by setting the Name property through Visual Basic code. You can also use the value returned by the Name property as the index argument in the Slides(index) property on the Presentation object so that your code can return a specific Slide object.\n\nThe SlideIndex property returns a number representing the position of the slide in the Slides collection. The SlideIndex number is directly related to the position of the slide on screen. The Name property returns the name of the slide. The SlideNumber property on the Slide object returns the slide number visible on the slide. You can set the slide number in PowerPoint by selecting the Slide number check box in the Slide tab of the Header and Footer dialog box. You can access this dialog box by clicking Header and Footer on the View menu.\n\nYou use the Add method of the Slides collection to insert a new slide in the presentation. The Add method takes two arguments, Index and Layout, and you need both. The Index argument represents the position of the new slide in the Slides collection. If you want to add the slide to the end of the Slides collection, you need to set the Index argument to the number of the slides in the collection plus one. The code would appear as:\n\nIf you want to insert a new slide at the end of the Slides collection, replace the Set sldNew statement in the following procedure with the With…End block above.\n\nThe Layout argument allows your code to specify the slide layout for the new slide. Every slide in PowerPoint has a slide layout. You need to set a Layout argument to a PpSlideLayout constant. When you insert a new slide in PowerPoint by clicking New Slide on the Insert menu in PowerPoint's application window, the New Slide dialog box displays all the possible slide layouts. The name of the layout appears at the right in the dialog box. Most layout names in the dialog box are similar to their associated PpSlideLayout constant. In the preceding procedure, the PpSlideLayout constant ppLayoutText represents the Bulleted List layout in the New Slide dialog box.\n\nA slide's title and body placeholder are two elements you'll commonly find on slides. The slide title is commonly used to display a list of Slides in a presentation. The following procedure allows you to return a list of slide titles exactly like the list you'll find in the Slide Navigator in Slide Show. In Slide Show view, right-click on the slide, click Go, and click Slide Navigator on the submenu.\n\nYou can also see a list of slide titles in the Insert Hyperlink dialog box by clicking Hyperlink on the Insert menu and then selecting Place in This Document on the Link To bar at the left of the dialog box. In the Visual Basic Editor in PowerPoint, run the following procedure. The list of slide titles is printed in the Immediate window.\n\nPowerPoint provides a shortcut that allows you to easily determine if a slide title exists and if so, to access the title shape. Instead of using the Shapes(Index) property on the Slide object or the Placeholders(Index) property on the Shapes collection object to return the slide title, you can use the Title property on the Shapes object. This property provides a shortcut to the Title shape.\n\nEven though the majority of slides have a slide title, some may not. Either the slide layout is blank (ppSlideLayoutBlank) or the user deleted the slide title shape. Therefore, before you access the slide title shape using the Title property on the Shapes object, your code should first use the HasTitle property. If the slide does have a title, the string variable sSlideTitle is set to the text of the slide title shape. The If…Then…Else block determines if the length of text assigned to the variable sSlideTitle is greater than zero. If so, the procedure prints the slide title to the Immediate window. If not, it prints the slide number to the Immediate window.\n\nIn a PowerPoint presentation, all text has to exist in a shape. The TextRange object allows you to insert or manipulate text content in a shape. You can set the TextRange object so that it represents all or only a portion of a range of text. A TextRange object can consist of text that represents a single paragraph (a bulleted list item, for example) or all text in a shape (such as all bulleted items).\n\nWithin every TextRange object, you can return more granular units of text—just as you can in Word with the Range object. The TextRange object allows you to iterate through units of text as large as all the text in a shape and as small as a paragraph (usually a bulleted item), a sentence, a word, and, finally, a character. The TextRange object in PowerPoint is equivalent in purpose to the Range object in Word. Many methods and properties on both of these objects are similar as well.\n\nYou can't apply a number of properties on the Shape or ShapeRange object to all shapes. You can use the Paragraphs, Sentences, Words, or Character properties on the TextRange object to return the collection of paragraphs, sentences, words, or characters from a range of text. However, you can't access the text range on shapes like a line, WordArt, bitmap placeholder, or ActiveX control. Before you try to access text in a range of shapes—in a selection, for example —you need to determine if a shape can contain text.\n\nTo access text, you need to first access the TextFrame object. In hierarchical object terms, a Shape object contains a TextFrame. The TextFrame contains a TextRange object that actually represents text. Some shapes don't contain a TextFrame object. To determine if a shape does contain one, and therefore can contain text, you can use the HasTextFrame property on the Shape object. Thereafter, if a shape does contain text, you can access the text in the shape and set its properties.\n\nBefore running this procedure, insert different shapes on the active slide, such as a line, an ActiveX control, some WordArt, and a rectangle. Add text to the rectangle, the title, and the body placeholder, if they exist. Select all shapes on the slide and then run the procedure. Make sure that the body text is bulleted. The procedure determines if the selection in the active window is a range of shapes. If so, the first For Each…Next loop iterates through the shapes in the selected shape range. If the shape contains a text frame, the nested For Each…Next loop iterates through the paragraphs in the text range of the selected shape.\n\nThe If…Then statement evaluating the bullet Type property is used to determine if there is a bullet visible for the paragraph. If there is, then the For…Each loop proceeds to add a number as the bullet. If a bullet does not exist, the bullet of the paragraph is unaffected. Every bulleted item in a shape, including those that are indented below a main bulleted item, is considered a paragraph. You access the list of bulleted items by using the Paragraphs property on the TextRange object. The Paragraphs property returns the collection of paragraphs in the text range of a shape. You can use the IndentLevel property to return specific paragraphs in a shape. The preceding procedure sets the bullet character to a number if the bullet exists for the paragraph. This procedure mimics the functionality of automatically numbering bulleted items in a shape.\n\nUnlike in Word, in PowerPoint your code can only navigate down the text \"hierarchy\" tree. For example, if you select a bulleted item on a slide in the active window, you can access the sentence, word, and character collections in the bulleted item. However, if you had selected a word, you cannot return the sentence or paragraph the word belonged to. The Range object in Word, on the other hand, allows you to return the paragraph where a range of text, such as a word, is contained.\n\nThe following procedure prints to the Immediate window in the Visual Basic Editor in PowerPoint the first paragraph, sentence, and word of a text selection. For example, in a body placeholder on a slide, type in two bulleted items where the first item has two or more sentences. Select all of the text in the shape and then run the following procedure in a module in the Visual Basic Editor.\n\nPowerPoint is similar to Word in that a unit of text representing a word consists of the text of the word followed by the space between the text and the next word. If you double-click on a word in a Word document or in a shape in PowerPoint, the text and the space after the text is highlighted. The same principle holds for sentences. A sentence in Word and PowerPoint consists of the sentence's text followed by the space between the period and the next sentence. A paragraph includes the text, space after the end of the text (if any), and the paragraph marker.\n\nBefore running this procedure, add text to a body placeholder and add two sentences to the first bulleted item. Select all text in the bulleted item and run the procedure. The procedure prints the text of the first word, sentence, and paragraph (which represents the bulleted item) to the Immediate window, followed by a quote. represents the quote character (\"), which allows you to see the spaces after each unit of text.\n\nUnlike in Word, in PowerPoint you can use the TrimText property to remove all spaces and paragraph markers before and after a unit text. The built-in Trim$ function in the Visual Basic for Applications language works only for removing spaces before and after a text string. The TrimText property in PowerPoint also removes paragraph markers after, for example, a sentence or paragraph. The TrimText property is useful when you retrieve the last paragraph in a shape and don't want the paragraph marker along with the text.\n\nWhen you build presentation content programmatically, you commonly have to insert paragraphs. PowerPoint, like Word, provides two convenient methods for creating a new paragraph before or after an existing one: InsertBefore and InsertAfter. When you access a range representing an existing paragraph or the beginning or end of one, you can use either of these two methods to insert a new paragraph.\n\nThe following procedure assumes that the active presentation contains at least two slides and two shapes on the second slide. The procedure also assumes that the second shape on the second slide has at least two bulleted items. The code inserts a new paragraph at the end of the text range in the shape using the InsertAfter method on the TextRange object. The InsertAfter method takes one argument representing the new text to be added in the new paragraph. This procedure adds a new paragraph after the first paragraph in the shape. Note that in the text string assigned to the variable sNewPara, a carriage return, represented by , is added to the end of the text. When the text string is set to the new paragraph, the carriage return ensures that the new paragraph is separate from the paragraph after the new paragraph.\n\nAnother very common task in programming solutions is to insert content at the end of text in the body placeholder or any shape. The following procedure inserts text at the end of a text range using the InsertAfter method. However, in this case it adds the carriage return character at the beginning of the text string assigned to the string variable sNewPara.\n\nPowerPoint 2000 is the first version of PowerPoint that offers a way of creating tables that's similar to the functionality provided by the Draw Table command on Word's Tables And Borders toolbar. The following two procedures create a simple five-row by three-column table. They create the table on a new slide inserted at the end of the Slides collection in the active presentation. You should note that your code can insert a table that has up to 25 rows and 25 columns. This is also the row and column limit that's set when you create the table using the Tables And Borders toolbar.\n\nFirst you set the new table to the Table variable tbl. PowerPoint doesn't provide the ability to apply predefined formats to your table as Word does using the Table AutoFormat on the Table menu. Since you can't format a table with a preset table format, you need to explicitly format the table through code. You do this by using the SetTableFormatting procedure. You call the procedure InsertTableData to fill the second and third columns with random values after you apply formatting.\n\nAs described in this chapter's Word and Excel table examples, you could, for example, replace the code in InsertTableData with code that accesses data in an Access database."
    },
    {
        "link": "https://stackoverflow.com/questions/34043467/manipulating-text-with-symbols-in-powerpoint-using-vba",
        "document": "I am trying to use VBA to manipulate text in a PowerPoint.\n\nI have formatted text in a frame with greek symbols, superscript and subscript. I want to divide that text into two frames. For example I use something like this:\n\nAs a result there are symbols and formatting lost. Is there any way to make it better? Thanks for any help."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/api/powerpoint.shapes.addtextbox",
        "document": "Creates a text box. Returns a Shape object that represents the new text box.\n\nThis example adds a text box that contains the text \"Test Box\" to myDocument.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://wiseowl.co.uk/vba-macros/guides/shapes/shapes",
        "document": "For a long time I've always shied away from this subject, but it turns out that I shouldn't have: shapes in VBA are surprisingly easy to create and control!\n\nFirst, however, a tip to make your shape-life easier (it sounds like something out of a bad science fiction novel ...).\n\nFor some reason, VBA doesn't support autocompletion that well when you're working with worksheets. For example, as you type in the following lines of code you won't see any Intellisense to help you:\n\nBy contrast, if you use an object variable to refer to a worksheet life will be MUCH easier:\n\nAny worksheet contains a collection of shapes, so often a good place to start is by deleting any shapes that you've already added to a worksheet so that you can start with a blank canvas. The following macro would delete any shapes which have been added to a worksheet:\n\nThe macro works by looking at each of the shapes on the worksheet in turn, applying the Delete method to remove it.\n\nThe easiest way to add a shape in VBA is to apply the AddShape method to the existing collection of shapes:\n\nThe full list of arguments that you need to specify when adding a shape like this are as follows:\n\nYou can add a shape either by specifying its enumeration or by using the integer equivalent. So both of these commands will add the same rectangle:\n\nHere are the shapes added by this code:\n\nWhether you choose to specify the shape type by its number or by its enumeration is up to you!\n\nListing out the types of shapes\n\nA list of the first 137 autoshape types is shown below (for versions of Excel up to 2003, that's all that there is available):\n\nIt's neither particularly well-written or well-commented, but for the sake of completion (and in case anyone finds it useful for reference), here's the code I wrote to generate the above list:\n\nAdding a shape without getting a reference to it\n\nOnce you've added a shape, you'll want to be able to refer to it in the future - and you'll also need to know how to position it exactly where you want on the screen. Consider the following block of code, which adds a square to the current worksheet:\n\nThe problem with this method is that there's no easy way to refer to the shape after adding it. If it's the only shape added to date, this would work:\n\nHowever, referring to a shape by its index number within the collection of shapes clearly isn't a reliable method.\n\nAdding a shape while at the same time getting a reference to it\n\nA much better way to add a shape is by setting an object variable to refer to it immediately after adding it:\n\nNote that (as always in VBA) if you're capturing a reference to something, you need to include brackets round the argument list. The advantage of the above approach is that you can now refer to the shape that's been added either by the object variable used:\n\nOr by its name:\n\nYou've already seen that when you position a shape you do it relative to the top left corner of a worksheet. However, it's easy enough to change this to position a shape relative to a cell:\n\nFor example, supposing that we want to add a shape within the cell like this:\n\nHere's some sample code to do this:\n\nThis code will position the shape relative to the top left corner of the cell, rather than of the worksheet.\n\nNow that we know how to refer to our shapes (and how to position them where we want on screen), it's time to make them look pretty!\n\nFormatting shapes is easy provided that you understand that there are two main properties that you can play about with:\n\nOne other oddity: it's the ForeColor of a shape's fill that you'll usually want to change:\n\nHere's some code to create a pretty circle, for example:\n\nThis would create a circle which is 20% transparent and has a different background colour:\n\nYou could extend the macro above to change the border colour and style of the shape:\n\nThe circle is now beginning to look a bit silly:\n\nAny shape added has a TextFrame property, which gives you access to the text within it. This in turn has a collection of Characters!\n\nThus the code above sets the text in the relevant shape called CalloutBalloon, then changes its font and alignment. You can format only part of the text in a shape, as this example shows:\n\nHere's some code to achieve the above:\n\nThis changes the colour of the 3 characters from position 6 onwards.\n\nHere's the example from the beginning of this tutorial:\n\nThe code to produce it could be as follows:\n\nRunning the CreateWiseOwlBalloon routine should create the two shapes shown (although you'll need to substitute your own picture file path to get it to work).\n\nTime now to look at some specialist shapes: lines and connectors.\n\nThis tutorial doesn't claim to be exhaustive - there are a LOT of things you can do with shapes:\n\nTo add a line, specify its start and end point (logical, really):\n\nFor example, suppose that you wanted to add this red line:\n\nHere's the code to add the line above:\n\nWhen adding connectors, it helps to know that there are 3 types:\n• None Add a connector shape, as you would do a line.\n• None Tell it which shape to begin at.\n• None Tell it which shape to end at.\n• None Finally, reroute the connections (this basically makes sure that the connector is where it should be on screen, given the current position of the two shapes it's linking together).\n\nTo draw the connector on the left above (the curved one), first create the two shapes (the textbox and the owl logo):\n\nYou'll need to use a different picture, of course, if you want to reproduce this. Next, add the connector:\n\nNote that it's not worth thinking about its position or size, as when you reroute it VBA will redraw it. Now say what the connector is connecting!\n\nFinally, you should update the position of the connector:\n\nThe cool thing now is that as you drag either shape around the connector will follow it!\n\nThere are two main ways to work with a number of shapes at the same time: by using the ShapeRange object, or by looping over a collection of shapes.\n\nYou can use an object of type ShapeRange to get access to a set of shapes, allowing you to set properties and apply methods to a set of shapes simultaneously. Here's an example of its use:\n\nOne way to do this is to draw the shapes, then select them:\n\nNow that the shapes are selected, we can apply the ShapeRange method to the current selection to return a set of shapes (I did warn you that I preferred the other method!):\n\nYou can abbreviate this as follows:\n\nThe problem with this approach is that it doesn't allow for autocompletion:\n\nIt's just so much easier (I humbly submit) to loop over all of the shapes, colouring each in turn:\n\nI accept that the above code probably runs more slowly, but you would have to have a serious number of shapes on a worksheet for this to matter!\n\nOne useful thing to be able to do is to check what type each shape is as you loop over it. You can do this by testing a shape's Type, and then more specifically its AutoShapeType:\n\nHere's some code to achieve the above:\n\nAlthough this tutorial has concerned itself almost exclusively with autoshapes, there are lots of other shapes that you can add!\n\nHaving spent all of this time looking at how to create shapes, let's now take a quick look at how to assign macros to them.\n\nPerhaps the most remarkable thing that you can do with shapes is get them to run macros:\n\nHere's the message that clicking on the owl will show:\n\nTo make this work you need to create a macro first, then assign it to a shape.\n\nHere's a modest macro which displays the hoot message on screen (and reads it out for good measure, although it sounds a bit strange!):\n\nTo do this, set the shape's OnAction property:\n\nThat's all that you need to do! Clicking on the shape will now run the Hoot macro."
    }
]