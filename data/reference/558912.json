[
    {
        "link": "https://stackoverflow.com/questions/3551466/how-to-initialize-an-array-constant-specifying-desired-indexes",
        "document": "What I just want is to initialize a string[] array constant by specifying not only the values, but the indexes they will be attached to.\n\nFor example, on:\n\nI would like to state that BullDog corresponds to index 29 and GreyHound to 5 (Like php :) )"
    },
    {
        "link": "https://bytehide.com/blog/array-initialization-csharp",
        "document": "C# is an object-oriented programming language that is fast, simple, and modern. If you’re a fan like me, you know its features and usages are widely spread in different fields. Today, we dive into the core of this mighty language by discussing C# array initialization, a topic that affects how we organize and manipulate data in our code. Stick with me and you’ll see just how fascinating array initialization can be.\n\nBefore we jump into action (pardon my impatience, this subject gets me excited), it’s essential we have a clear understanding of what array initialization in C# is. You see, in coding, the fine-tuning of details is what sets you apart.\n\nAn array is, simply put, a bunch of things in a list that you can access through an index. It’s your own coding pantry where you store and organize stuff for later use. But enough with the appetizers, let’s get to the main course.\n\nHave you ever declared your love for coding? Just as we declare our intentions in life, so must we declare our arrays in C#.\n\nDeclaring an array is letting C# know that it’s there, waiting to be filled with items. As a chef declares to the world his new stunning recipe even before starting to cook, we declare our arrays. But unlike culinary adventures, our ingredients here are strictly of data type. Let’s check out an example:\n\nIn this example, we declared an array named “myArray” of integer type. Pretty simple, right?\n\nNow what if I told you to make a new friend? You’d likely want to know details, like their name, right? Creating or initializing a new array is much the same.\n\nIn this example, we’ve like given our new friend a name and body – “myArray” – and determined it’s defined to store five integers. See? Making new friends is easy!\n\nExploring How to Initialize an Array in C#\n\nThe process of initializing an array in C# is a fundamental programming concept, yet it encompasses a variety of methods with different levels of complexity. From basic initialization to the use of built-in C# functions and methods, we’re about to embark on a journey through the versatile world of arrays in C#. So, buckle up and let’s get started!\n\nOne of the simplest ways to answer the burning question, “how to initialize an array in C#”, involves providing initial values at the time of declaration. It’s equivalent to simultaneously making a shopping list and buying those items. You’re telling C# what you want to store in your array as you create it. Let’s consider a simple example.\n\nIn this line of code, we’re declaring an integer array named “myArray” and initializing it with five elements. The series of numbers within the curly brackets informs C# that our array should contain these five values. You’ll probably agree that it’s relatively straightforward!\n\nBut suppose you’re way too organized (like some of us), and you already know the size of your array, but you’re not ready yet with the data – fret not. In this case, when you don’t have the values to put in the array just yet, you can make an empty array with a specific size like this:\n\nWith this code, we have an array that could contain five integers, but for now, it’s empty. Wouldn’t it be cool if we could fill it up with some data later when we’re ready? Hang tight!\n\nThere is a Hero Function in C# that’s ready to spring into action when you need it. It’s Array.Initialize(). This built-in C# method sets all elements in an array to their default values. Think of it as your ‘factory reset’ button gifted by C# just in case things get out of hand.\n\nLet’s see how to use it:\n\nCan you guess what happened here? After initializing our array as we did previously, we basically reset everything. Each integer in ‘numbers’ has been set to its default value, which is 0 for integers in C#. If you set the array in motion now, it’s like an entirely new, empty shopping cart, ready to be filled with fresh items.\n\nIt’s interesting to note here that Array.Initialize() method works differently with different data types. With value types like integers, it will reset to default values (0 for integers, false for booleans, etc.), but for reference types (objects), it will set them to null.\n\nLet’s not forget arrays of strings (a reference type), where each string in an array would be set to null:\n\nSo whether it’s a numbers game or a tropical fruits party, you now have the command to start over whenever you need. Got cluttered data? With our new hero function Array.Initialize(), no problem!\n\nConsider initializing an array much like building a well-organized toolkit with labels and specified slots for each tool. However, instead of tools, you’re packing elements like numbers, strings, and even other objects. But why would you need to initialize an array with values already in it?\n\nImagine needing to perform a function that runs through a given set of data. Having this information readily available saves time and helps you create a smoother code construct.\n\nC# New Array with Values\n\nWhen we wish to pre-fill our array with predefined data we can initialize our array along with its declaration. Let’s illustrate it with two examples.\n\nIn this line of code, we’re using an array named “groceryList” which is initialized with five string values. This is a pretty handy example. Think about going to the grocery store with a ready shopping list, just like in the above example. Instead of figuring out what you need in the aisles, you already know what to get!\n\nIn this example, we declare, initialize and fill our integer array named “luckyNumbers” at the same time. It is indexed corresponding to five lucky numbers, in the order they were added. Consider it as placing your lottery numbers in your lucky draw entry form. Our array just organized the random numbers into a meaningful order!\n\nDealing specifically with integer arrays, you might consider it akin to managing your bills and coins. All monies, just different denominations. Let’s delve deeper and look at an example to illustrate this.\n\nIn this example, we have an array of integers representing the duration (in minutes) of songs in a playlist. Our array “myPlaylistDuration” is initialized and populated at the same time and can be manipulated easily. Each song is like an integer slot in the array, you have them ordered and arranged in your music player.\n\nTo help us understand the versatility of C# array initialization, let’s take a look at a slightly more complex and practical example. We’ll create an array to store the monthly average high temperatures for a certain location.\n\nHere, we can picture the array as a weather chart of sorts, with each slot representing a month’s average high temperature. We’ve manipulated months’ worth of scattered temperature data into an orderly, easily manageable array of information!\n\nNow let’s move to multidimensional arrays with initial values.\n\nThe above example creates a 2-dimensional array – imagine a grid, or a table, where you have multiple rows and columns. In this case, it’s tracking the exam scores of three students, with each having four entries. Our ‘examScores’ array neatly packs this data in a tabular form for easier handling.\n\nYou might ask – “Why is C# array initialization so critical?” Here’s the simple answer – it defines code effectiveness. Proper initialization makes your code clean, smooth, and efficient, just how we like it.\n\nTake a moment to reflect on the magic of C# array initialization. Realize its power, its beauty. For a coder, this is the same as watching a sunrise after an all-nighter of successful coding. A new day – full of possibilities, ready for you to conquer.\n\nArray initialization in C# is no small feat. It’s a tool that, when used thoughtfully, can make your code tidy and efficient. Remember it, use it, and study it – the benefits will be far-reaching if you do!\n\nAnd remember- just like cooking, coding is an art. Every bit, byte, and array matters! So, dazzle the world with your code artistry. You’ve got the recipe now; happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/82943/initializing-an-array-on-arbitrary-starting-index-in-c-sharp",
        "document": "Is it possible in c# to initialize an array in, for example, subindex 1?\n\nI'm working with Office interop, and every property is an object array that starts in 1 (I assume it was originally programed in VB.NET), and you cannot modify it, you have to set the entire array for it to accept the changes.\n\nAs a workaround I am cloning the original array, modifying that one, and setting it as a whole when I'm done.\n\nBut, I was wondering if it was possible to create a new non-zero based array"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays",
        "document": "You can store multiple variables of the same type in an array data structure. You declare an array by specifying the type of its elements. If you want the array to store elements of any type, you can specify as its type. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from Object.\n\nAn array is a reference type, so the array can be a nullable reference type. The element types might be reference types, so an array can be declared to hold nullable reference types. The following example declarations show the different syntax used to declare the nullability of the array or the elements:\n\nUninitialized elements in an array are set to the default value for that type:\n\nAn array has the following properties:\n• An array can be single-dimensional, multidimensional, or jagged.\n• The number of dimensions are set when an array variable is declared. The length of each dimension is established when the array instance is created. These values can't be changed during the lifetime of the instance.\n• A jagged array is an array of arrays, and each member array has the default value of .\n• Arrays are zero indexed: an array with elements is indexed from to .\n• Array elements can be of any type, including an array type.\n• Array types are reference types derived from the abstract base type Array. All arrays implement IList and IEnumerable. You can use the foreach statement to iterate through an array. Single-dimensional arrays also implement IList<T> and IEnumerable<T>.\n\nThe elements of an array can be initialized to known values when the array is created. Beginning with C# 12, all of the collection types can be initialized using a Collection expression. Elements that aren't initialized are set to the default value. The default value is the 0-bit pattern. All reference types (including non-nullable types), have the values . All value types have the 0-bit patterns. That means the Nullable<T>.HasValue property is and the Nullable<T>.Value property is undefined. In the .NET implementation, the property throws an exception.\n\nThe following example creates single-dimensional, multidimensional, and jagged arrays:\n\nA single-dimensional array is a sequence of like elements. You access an element via its index. The index is its ordinal position in the sequence. The first element in the array is at index . You create a single-dimensional array using the new operator specifying the array element type and the number of elements. The following example declares and initializes single-dimensional arrays:\n\nThe first declaration declares an uninitialized array of five integers, from to . The elements of the array are initialized to the default value of the element type, for integers. The second declaration declares an array of strings and initializes all seven values of that array. A series of statements prints all the elements of the array. For single-dimensional arrays, the statement processes elements in increasing index order, starting with index 0 and ending with index .\n\nYou can pass an initialized single-dimensional array to a method. In the following example, an array of strings is initialized and passed as an argument to a method for strings. The method displays the elements of the array. Next, the method reverses the array elements, and then the method modifies the first three elements of the array. After each method returns, the method shows that passing an array by value doesn't prevent changes to the array elements.\n\nArrays can have more than one dimension. For example, the following declarations create four arrays. Two arrays have have two dimensions. Two arrays have three dimensions. The first two declarations declare the length of each dimension, but don't initialize the values of the array. The second two declarations use an initializer to set the values of each element in the multidimensional array.\n\nFor multi-dimensional arrays, elements are traversed such that the indices of the rightmost dimension are incremented first, then the next left dimension, and so on, to the leftmost index. The following example enumerates both a 2D and a 3D array:\n\nIn a 2D array, you can think of the left index as the row and the right index as the column.\n\nHowever, with multidimensional arrays, using a nested for loop gives you more control over the order in which to process the array elements:\n\nYou pass an initialized multidimensional array to a method in the same way that you pass a one-dimensional array. The following code shows a partial declaration of a print method that accepts a two-dimensional array as its argument. You can initialize and pass a new array in one step, as is shown in the following example. In the following example, a two-dimensional array of integers is initialized and passed to the method. The method displays the elements of the array.\n\nA jagged array is an array whose elements are arrays, possibly of different sizes. A jagged array is sometimes called an \"array of arrays.\" Its elements are reference types and are initialized to . The following examples show how to declare, initialize, and access jagged arrays. The first example, , is declared in one statement. Each contained array is created in subsequent statements. The second example, is declared and initialized in one statement. It's possible to mix jagged and multidimensional arrays. The final example, , is a declaration and initialization of a single-dimensional jagged array that contains three two-dimensional array elements of different sizes.\n\nA jagged array's elements must be initialized before you can use them. Each of the elements is itself an array. It's also possible to use initializers to fill the array elements with values. When you use initializers, you don't need the array size.\n\nThis example builds an array whose elements are themselves arrays. Each one of the array elements has a different size.\n\nYou can create an implicitly typed array in which the type of the array instance is inferred from the elements specified in the array initializer. The rules for any implicitly typed variable also apply to implicitly typed arrays. For more information, see Implicitly Typed Local Variables.\n\nThe following examples show how to create an implicitly typed array:\n\nIn the previous example, notice that with implicitly typed arrays, no square brackets are used on the left side of the initialization statement. Also, jagged arrays are initialized by using just like single-dimensional arrays.\n\nWhen you create an anonymous type that contains an array, the array must be implicitly typed in the type's object initializer. In the following example, is an implicitly typed array of anonymous types, each of which contains an array named . The keyword isn't used inside the object initializers."
    },
    {
        "link": "https://medium.com/@dusan.velimirovic/mastering-arrays-in-c-from-basic-initialization-to-multidimensional-arrays-eff80d442e39",
        "document": "An array in C# is a fixed-size collection of elements of the same type stored in contiguous memory. It provides efficient access and is fundamental for organizing and manipulating data.\n\nAn array represents a fixed number of variables (called elements) of a particular type. The elements in an array are always stored in a contiguous block of memory, providing highly efficient access.\n\nAll arrays inherit from the System.Array class, providing common services for all arrays.\n\nAn array is denoted with square brackets after the element type:\n\nSquare brackets also index the array, accessing a particular element by position:\n\nThe for loop in this example cycles the integer i from 0 to 4:\n\nThe Length property of an array returns the number of elements in the array. After an array has been created, you cannot change its length."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.array?view=net-9.0",
        "document": "The following code example shows how Array.Copy copies elements between an array of type integer and an array of type Object.\n\nThe following code example creates and initializes an Array and displays its properties and its elements.\n\nThe Array class is not part of the System.Collections namespaces. However, it is still considered a collection because it is based on the IList interface.\n\nThe Array class is the base class for language implementations that support arrays. However, only the system and compilers can derive explicitly from the Array class. Users should employ the array constructs provided by the language.\n\nAn element is a value in an Array. The length of an Array is the total number of elements it can contain. The lower bound of an Array is the index of its first element. An Array can have any lower bound, but it has a lower bound of zero by default. A different lower bound can be defined when creating an instance of the Array class using CreateInstance. A multidimensional Array can have different bounds for each dimension. An array can have a maximum of 32 dimensions.\n\nUnlike the classes in the System.Collections namespaces, Array has a fixed capacity. To increase the capacity, you must create a new Array object with the required capacity, copy the elements from the old Array object to the new one, and delete the old Array.\n\nThe array size is limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).\n\n.NET Framework only: By default, the maximum size of an Array is 2 gigabytes (GB). In a 64-bit environment, you can avoid the size restriction by setting the attribute of the gcAllowVeryLargeObjects configuration element to in the run-time environment.\n\nSingle-dimensional arrays implement the System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyList<T> and System.Collections.Generic.IReadOnlyCollection<T> generic interfaces. The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the Array class. In addition, there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations). The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw NotSupportedException.\n\nType objects provide information about array type declarations. Array objects with the same array type share the same Type object.\n\nType.IsArray and Type.GetElementType might not return the expected results with Array because if an array is cast to the type Array, the result is an object, not an array. That is, returns , and returns .\n\nThe Array.Copy method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.\n\nSome methods, such as CreateInstance, Copy, CopyTo, GetValue, and SetValue, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays. LongLength and GetLongLength return 64-bit integers indicating the length of the array.\n\nThe Array is not guaranteed to be sorted. You must sort the Array prior to performing operations (such as BinarySearch) that require the Array to be sorted.\n\nUsing an Array object of pointers in native code is not supported and will throw a NotSupportedException for several methods.\n\nPublic static ( in Visual Basic) members of this type are thread safe. Any instance members are not guaranteed to be thread safe.\n\nThis implementation does not provide a synchronized (thread safe) wrapper for an Array; however, .NET classes based on Array provide their own synchronized version of the collection using the SyncRoot property.\n\nEnumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system?view=net-9.0",
        "document": "The exception that is thrown when there is an attempt to read or write protected memory. Identifies the activation context for the current application. This class cannot be inherited. Contains methods to create types of objects locally or remotely, or obtain references to existing remote objects. This class cannot be inherited. Represents one or more errors that occur during application execution. Provides members for setting and retrieving data about an application's context. Represents an application domain, which is an isolated environment where applications execute. This class cannot be inherited. Provides a managed equivalent of an unmanaged host. Represents assembly binding information that can be added to an instance of AppDomain. The exception that is thrown when an attempt is made to access an unloaded application domain. Serves as the base class for application-defined exceptions. Contains information used to uniquely identify a manifest-based application. This class cannot be inherited. Provides the ability to uniquely identify a manifest-activated application. This class cannot be inherited. The exception that is thrown when one of the arguments provided to a method is not valid. The exception that is thrown when a null reference ( in Visual Basic) is passed to a method that does not accept it as a valid argument. The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method. The exception that is thrown for errors in an arithmetic, casting, or conversion operation. Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime. The exception that is thrown when an attempt is made to store an element of the wrong type within an array. Provides data for the AssemblyLoad event. Specifies the usage of another attribute class. This class cannot be inherited. The exception that is thrown when the file image of a dynamic link library (DLL) or an executable program is invalid. A lightweight abstraction for a payload of bytes that supports converting between string, stream, JSON, and bytes. Converts base data types to an array of bytes, and an array of bytes to base data types. The exception that is thrown when an attempt to unload an application domain fails. Supports iterating over a String object and reading its individual characters. This class cannot be inherited. Indicates whether a program element is compliant with the Common Language Specification (CLS). This class cannot be inherited. Represents the standard input, output, and error streams for console applications. This class cannot be inherited. Provides data for the CancelKeyPress event. This class cannot be inherited. Defines the base class for all context-bound classes. The exception that is thrown when an attempt to marshal an object across a context boundary fails. Indicates that the value of a static field is unique for a particular context. The exception that is thrown when a unit of data is read from or written to an address that is not a multiple of the data size. This class cannot be inherited. Represents a nonexistent value. This class cannot be inherited. Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class. The exception that is thrown when there is an attempt to divide an integral or Decimal value by zero. The exception that is thrown when a DLL specified in a DLL import cannot be found. The exception that is thrown when an object appears more than once in an array of synchronization objects. The exception that is thrown when an attempt to load a class fails due to the absence of an entry method. Provides the base class for enumerations. Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited. Represents the base class for classes that contain event data, and provides a value to use for events that do not include event data. The exception that is thrown when there is an internal error in the execution engine of the common language runtime. This class cannot be inherited. Extensions for configuring fake logging, used in unit tests. Extensions that allow registering a fake redactor in the application. The exception that is thrown when there is an invalid attempt to access a private or protected field inside a class. Indicates that an enumeration can be treated as a bit field; that is, a set of flags. The exception that is thrown when the format of an argument is invalid, or when a composite format string is not well formed. Represents a composite format string, along with the arguments to be formatted. The exception that is thrown when an attempt is made to access an element of an array or collection with an index that is outside its bounds. The exception that is thrown when there is insufficient execution stack available to allow most methods to execute. The exception that is thrown when a check for sufficient available memory fails. This class cannot be inherited. The exception that is thrown for invalid casting or explicit conversion. The exception that is thrown when a method call is invalid for the object's current state. The exception that is thrown when a program contains invalid Microsoft intermediate language (MSIL) or metadata. Generally this indicates a bug in the compiler that generated the program. This exception is also thrown when internal runtime implementation limits have been exceeded by the program. The exception that is thrown when time zone information is invalid. Provides a lazy indirect reference to an object and its associated metadata for use by the Managed Extensibility Framework. Used to set the default loader optimization policy for the main method of an executable application. Encapsulates a memory slot to store local data. This class cannot be inherited. Enables access to objects across application domain boundaries in applications that support remoting. Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions. Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions. The exception that is thrown when an attempt to access a class member fails. Provides extension methods for the memory-related and span-related types, such as Memory<T>, ReadOnlyMemory<T>, Span<T>, and ReadOnlySpan<T>. The exception that is thrown when there is an invalid attempt to access a method, such as accessing a private method from partially trusted code. The exception that is thrown when there is an attempt to dynamically access a field that does not exist. If a field in a class library has been removed or renamed, recompile any assemblies that reference that library. The exception that is thrown when there is an attempt to dynamically access a class member that does not exist or that is not declared as public. If a member in a class library has been removed or renamed, recompile any assemblies that reference that library. The exception that is thrown when there is an attempt to dynamically access a method that does not exist. Indicates that the COM threading model for an application is multithreaded apartment (MTA). Represents a multicast delegate; that is, a delegate that can have more than one element in its invocation list. The exception that is thrown when there is an attempt to combine two delegates based on the Delegate type instead of the MulticastDelegate type. This class cannot be inherited. A parser based on the NetPipe scheme for the \"Indigo\" system. A parser based on the NetTcp scheme for the \"Indigo\" system. A customizable parser based on the news scheme using the Network News Transfer Protocol (NNTP). Indicates that a field of a serializable class should not be serialized. This class cannot be inherited. The exception that is thrown when a floating-point value is positive infinity, negative infinity, or Not-a-Number (NaN). The exception that is thrown when a requested method or operation is not implemented. The exception that is thrown when an invoked method is not supported, or when there is an attempt to read, seek, or write to a stream that does not support the invoked functionality. Supports a value type that can be assigned . This class cannot be inherited. The exception that is thrown when there is an attempt to dereference a null object reference. Supports all classes in the .NET class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all .NET classes; it is the root of the type hierarchy. The exception that is thrown when an operation is performed on a disposed object. Marks program elements that are no longer in use. Represents information about an operating system, such as the version and platform identifier. This class cannot be inherited. The exception that is thrown in a thread upon cancellation of an operation that the thread was executing. The exception that is thrown when there is not enough memory to continue the execution of a program. The exception that is thrown when an arithmetic, casting, or conversion operation in a checked context results in an overflow. Indicates that a method will allow a variable number of arguments in its invocation. This class cannot be inherited. The exception that is thrown when a feature does not run on a particular platform. Provides an IProgress<T> that invokes callbacks for each reported progress value. Represents a pseudo-random number generator, which is an algorithm that produces a sequence of numbers that meet certain statistical requirements for randomness. The exception that is thrown when an array with the wrong number of dimensions is passed to a method. Provides data for loader resolution events, such as the TypeResolve, ResourceResolve, ReflectionOnlyAssemblyResolve, and AssemblyResolve events. Indicates that a class can be serialized using binary or XML serialization. This class cannot be inherited. The exception that is thrown when the execution stack exceeds the stack size. This class cannot be inherited. Indicates that the COM threading model for an application is single-threaded apartment (STA). Represents a string comparison operation that uses specific case and culture-based or ordinal comparison rules. Provides extension methods to work with string normalization. Serves as the base class for system exceptions namespace. Indicates that the value of a static field is unique for each thread. The exception that is thrown when the time allotted for a process or operation has expired. Provides an abstraction for time. Represents any time zone in the world. Provides information about a time zone adjustment, such as the transition to and from daylight saving time. The exception that is thrown when a time zone cannot be found. Represents an n-tuple, where n is 8 or greater. Provides extension methods for tuples to interoperate with language support for tuples in C#. Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types. The exception that is thrown when a method attempts to use a type that it does not have access to. The exception that is thrown as a wrapper around the exception thrown by the class initializer. This class cannot be inherited. The exception that is thrown when type-loading failures occur. The exception that is thrown when there is an attempt to access an unloaded class. The exception that is thrown when the operating system denies access because of an I/O error or a specific type of security error. Provides data for the event that is raised when there is an exception that is not handled in any application domain. Provides an object representation of a uniform resource identifier (URI) and easy access to the parts of the URI. Provides a custom constructor for uniform resource identifiers (URIs) and modifies URIs for the Uri class. The exception that is thrown when an invalid Uniform Resource Identifier (URI) is detected. Parses a new URI scheme. This is an abstract class. A class used to compare UriTemplate instances for structural (instead of reference) equivalence. A class that represents the results of a match operation on a UriTemplate instance. Represents an error when matching a Uri to a UriTemplateTable. A class that represents an associative set of UriTemplate objects. Provides the base class for value types. Represents the version number of an assembly, operating system, or the common language runtime. This class cannot be inherited. Represents a weak reference, which references an object while still allowing that object to be reclaimed by garbage collection. Represents a typed weak reference, which references an object while still allowing that object to be reclaimed by garbage collection. Provides extension methods for converting between tasks and Windows Runtime asynchronous actions and operations.\n\nRepresents a variable-length argument list; that is, the parameters of a function that takes a variable number of arguments. Provides an enumerator for the elements of an ArraySegment<T>. Describes the console key that was pressed, including the character represented by the console key and the state of the SHIFT, ALT, and CTRL modifier keys. Represents dates with values ranging from January 1, 0001 Anno Domini (Common Era) through December 31, 9999 A.D. (C.E.) in the Gregorian calendar. Represents an instant in time, typically expressed as a date and time of day. Represents a point in time, typically expressed as a date and time of day, relative to Coordinated Universal Time (UTC). Provides an enumerator for the invocation list of a delegate. Represents the size and the fragmenation of a generation on entry and on exit of the GC reported in GCMemoryInfo. Provides a set of APIs that can be used to retrieve garbage collection information. Combines the hash code for multiple values into a single hash code. Represents a type that can be used to index a collection either from the beginning or the end. Represents a signed integer where the bit-width is the same as a pointer. Enables enumerating each split within a ReadOnlySpan<T> that has been divided using one or more separators. Provides a handler used by the language compiler to format interpolated strings into character spans. Represents a value type that can be assigned . Represents a range that has start and end indexes. Represents a contiguous region of memory, similar to ReadOnlySpan<T>. Unlike ReadOnlySpan<T>, it is not a byref-like type. Provides an enumerator for the elements of a ReadOnlySpan<T>. Provides a type-safe and memory-safe read-only representation of a contiguous region of arbitrary memory. RuntimeMethodHandle is a handle to the internal metadata representation of a method. Represents a position in a non-contiguous set of memory. Properties of this type should not be interpreted by anything but the type that created it. Provides an enumerator for the elements of a Span<T>. Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory. Represents a time of day, as would be read from a clock, within the range 00:00:00 to 23:59:59.9999999. Provides information about a specific time change, such as the change from daylight saving time to standard time or vice versa, in a particular time zone. Describes objects that contain both a managed pointer to a location and a runtime representation of the type that may be stored at that location. Represents an unsigned integer where the bit-width is the same as a pointer. Provides options that control how a Uri is created and behaves. Provides static methods for creating value tuples. Represents an n-value tuple, where n is 8 or greater. Specifies a return value type for a method that does not return a value.\n\nExposes the public members of the AppDomain class to unmanaged code. Represents assembly binding information that can be added to an instance of AppDomain. Represents the status of an asynchronous operation. Supports cloning, which creates a new instance of a class with the same value as an existing instance. Defines a generalized type-specific comparison method that a value type or class implements to order or sort its instances. Defines a generalized comparison method that a value type or class implements to create a type-specific comparison method for ordering or sorting its instances. Defines methods that convert the value of the implementing reference or value type to a common language runtime type that has an equivalent value. Defines a method that supports custom formatting of the value of an object. Defines a generalized method that a value type or class implements to create a type-specific method for determining equality of instances. Provides a mechanism for retrieving an object to control formatting. Provides functionality to format the value of an object into a string representation. Defines a mechanism for parsing a string to a value. Defines a mechanism for retrieving a service object; that is, an object that provides custom support to other objects. Provides functionality to format the string representation of an object into a span. Defines a mechanism for parsing a span of characters to a value. Provides functionality to format the string representation of an object into a span as UTF-8. Defines a mechanism for parsing a span of UTF-8 characters to a value.\n\nIndicates the context for a manifest-activated application. Specifies the action that a custom application domain manager takes when initializing a new domain. Specifies the application elements on which it is valid to apply an attribute. Specifies whether relevant ToBase64CharArray and ToBase64String methods insert line breaks in their output. Specifies constants that define foreground and background colors for the console. Represents the SHIFT, ALT, and CTRL modifier keys on a keyboard. Specifies combinations of modifier and console keys that can interrupt the current process. Specifies whether a DateTime object represents a local time, a Coordinated Universal Time (UTC), or is not specified as either local time or UTC. Specifies the day of the week. Specifies enumerated constants used to retrieve directory paths to system special folders. Specifies options to use for getting the path to a special folder. Specifies the location where an environment variable is stored or retrieved in a set or get operation. Provides information about the current registration for notification of the next full garbage collection. An enumeration used with the LoaderOptimizationAttribute class to specify loader optimizations for an executable. Specifies the strategy that mathematical rounding methods should use to round a number. Identifies the operating system, or platform, supported by an assembly. Specifies the culture, case, and sort rules to be used by certain overloads of the Compare(String, String) and Equals(Object) methods. Specifies options for applicable Split method overloads, such as whether to omit empty substrings from the returned array or trim whitespace from substrings. Specifies the type of an object. Defines host name types for the CheckHostName(String) method. Provides the possible values for the configuration setting of the IdnElement in the System.Configuration namespace. Defines the different kinds of URIs. Defines the parts of a URI for the GetLeftPart(UriPartial) method.\n\nEncapsulates a method that has no parameters and does not return a value. Encapsulates a method that has a single parameter and does not return a value. Encapsulates a method that has two parameters and does not return a value. Encapsulates a method that has three parameters and does not return a value. Encapsulates a method that has four parameters and does not return a value. Encapsulates a method that has five parameters and does not return a value. Encapsulates a method that has six parameters and does not return a value. Encapsulates a method that has seven parameters and does not return a value. Encapsulates a method that has eight parameters and does not return a value. Encapsulates a method that has nine parameters and does not return a value. Encapsulates a method that has 10 parameters and does not return a value. Encapsulates a method that has 11 parameters and does not return a value. Encapsulates a method that has 12 parameters and does not return a value. Encapsulates a method that has 13 parameters and does not return a value. Encapsulates a method that has 14 parameters and does not return a value. Encapsulates a method that has 15 parameters and does not return a value. Encapsulates a method that has 16 parameters and does not return a value. Represents the callback method to invoke when the application domain is initialized. Represents the method that handles the AssemblyLoad event of an AppDomain. References a method to be called when a corresponding asynchronous operation completes. Represents the method that compares two objects of the same type. Represents the method that will handle the CancelKeyPress event of a Console. Represents a method that converts an object from one type to another type. Used by DoCallBack(CrossAppDomainDelegate) for cross-application domain calls. Represents the method that will handle an event that has no event data. Represents the method that will handle an event when the event provides data. Encapsulates a method that has no parameters and returns a value of the type specified by the parameter. Encapsulates a method that has one parameter and returns a value of the type specified by the parameter. Encapsulates a method that has two parameters and returns a value of the type specified by the parameter. Encapsulates a method that has three parameters and returns a value of the type specified by the parameter. Encapsulates a method that has four parameters and returns a value of the type specified by the parameter. Encapsulates a method that has five parameters and returns a value of the type specified by the parameter. Encapsulates a method that has six parameters and returns a value of the type specified by the parameter. Encapsulates a method that has seven parameters and returns a value of the type specified by the parameter. Encapsulates a method that has eight parameters and returns a value of the type specified by the parameter. Encapsulates a method that has nine parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 10 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 11 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 12 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 13 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 14 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 15 parameters and returns a value of the type specified by the parameter. Encapsulates a method that has 16 parameters and returns a value of the type specified by the parameter. Represents the method that defines a set of criteria and determines whether the specified object meets those criteria. Represents a method that handles the TypeResolve, ResourceResolve, or AssemblyResolve event of an AppDomain. Represents the method that will handle the event raised by an exception that is not handled by the application domain.\n\nOther classes provide services supporting data type conversion, method parameter manipulation, mathematics, remote and local program invocation, application environment management, and supervision of managed and unmanaged applications.\n\nTo access types in the System namespace from C# code without having to provide fully qualified type names, include the statement at the beginning of your source code file.\n\nTo access types in the System namespace from C++/CLI code without having to provide fully qualified type names, include the statement at the beginning of your source code file. In addition, you must compile with the /clr switch."
    },
    {
        "link": "https://code.visualstudio.com/api/references/vscode-api",
        "document": "VS Code API is a set of JavaScript APIs that you can invoke in your Visual Studio Code extension. This page lists all VS Code APIs available to extension authors.\n\nThis listing is compiled from the vscode.d.ts file from the VS Code repository.\n\nregisterCommand(command: string, callback: (args: any[]) => any, thisArg?: any): Disposable\n\nThese are some of the common patterns we use in the VS Code API.\n\nThe VS Code API represents asynchronous operations with promises. From extensions, any type of promise can be returned, like ES6, WinJS, A+, etc.\n\nBeing independent of a specific promise library is expressed in the API by the -type. represents the common denominator which is the then method.\n\nIn most cases the use of promises is optional and when VS Code calls into an extension, it can handle the result type as well as a of the result type. When the use of a promise is optional, the API indicates this by returning -types.\n\nOften operations are started on volatile state which changes before operations can finish. For instance, computing IntelliSense starts and the user continues to type making the result of that operation obsolete.\n\nAPIs that are exposed to such behavior will get passed a on which you can check for cancellation ( ) or get notified when cancellation occurs ( ). The cancellation token is usually the last parameter of a function call and optional.\n\nThe VS Code API uses the dispose pattern for resources that are obtained from VS Code. This applies to event listening, commands, interacting with the UI, and various language contributions.\n\nFor instance, the function returns a which upon calling removes the message again.\n\nEvents in the VS Code API are exposed as functions which you call with a listener-function to subscribe. Calls to subscribe return a which removes the event listener upon dispose.\n\nNames of events follow the pattern. The name signals if the event is going to happen (onWill) or already happened (onDid), what happened (verb), and the context (noun) unless obvious from the context.\n\nAn example from the VS Code API is which is an event fired when the active text editor (noun) has been (onDid) changed (verb).\n\nThe VS Code API uses the and TypeScript types where appropriate to support strict null checking."
    },
    {
        "link": "https://geeksforgeeks.org/csharp-programming-language",
        "document": "C# (pronounced \"C-sharp\") is a modern, versatile, object-oriented programming language developed by Microsoft in 2000 that runs on the .NET Framework. Whether you're creating Windows applications, diving into Unity game development, or working on enterprise solutions, C# is one of the top choices for developers worldwide.\n• None C# originates from the C programming family and shares similarities with other widely-used languages like C++ Java\n• None Mainly used to develop the desktop apps, windows apps, games(with unity engine\n• None C# is the primary language for developing games using the Unity engine.\n• NET Core , C# applications can run on Windows, macOS, and Linux.\n\nThis C# tutorial covers everything from beginners to advanced level. We’ll start with the basics like setting up your environment, C# syntax, and writing \"Hello World\" program, data types, and loops etc. After that we will start with advanced topics like object-oriented programming, delegates, tuples, indexers, collections, multithreading, and LINQ etc.\n• None What is C#?\n• None Check whether a Thread is Alive or Not\n• None How to Use Multiple Catch Clause\n• None Nesting of Try and Catch Blocks\n• Simple: C# is a user-friendly language that offers a structured approach to problem-solving. it provides a wide range of library functions and data types to work.\n• Modern Programming Language: C# programming is a popular and powerful language that is for creating scalable, interoperable, and robust applications.\n• Object Oriented: C# is an object-oriented programming language, which makes development and maintenance easier. In contrast, with procedure-oriented programming languages, managing code becomes difficult as project size grows.\n• Type Safe: The code is type safe can only access memory locations that it has permission to execute. This feature significantly enhances program security.\n• Interoperability : The interoperability process allows C# programs to perform all the tasks that a native C++ application.\n• Scalable and Updateable: C# is a programming language that is scalable and can be updated automatically. To update our application, we remove the old files and replace them with new ones.\n• Component Oriented: It is widely used as a software development methodology to create applications that are more strong and can easily scale.\n• Structured Programming Language: C# is a structured programming language that allows us to divide programs into parts using functions, making it easy to understand and modify.\n• Fast Speed: The compilation and execution time of C# language is fast.\n\n1. What is C# programming language used for?\n\n2. What is the advantage of ‘using’ statement in C#?\n\n4. What are the four steps involved in the C# code compilation?\n\n5. How can I declare and initialize variables in C#?"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/typescript-in-5-minutes.html",
        "document": "TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.\n\nFor example, JavaScript provides language primitives like and , but it doesn’t check that you’ve consistently assigned these. TypeScript does.\n\nThis means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.\n\nThis tutorial provides a brief overview of TypeScript, focusing on its type system.\n\nTypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.\n\nBy understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that is a in the above example.\n\nYou may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.\n\nYou can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.\n\nFor example, to create an object with an inferred type which includes and , you can write:\n\nYou can explicitly describe this object’s shape using an declaration:\n\nYou can then declare that a JavaScript object conforms to the shape of your new by using syntax like after a variable declaration:\n\nIf you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:\n\nSince JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:\n\nYou can use interfaces to annotate parameters and return values to functions:\n\nThere is already a small set of primitive types available in JavaScript: , , , , , , and , which you can use in an interface. TypeScript extends this list with a few more, such as (allow anything), (ensure someone using this type declares what the type is), (it’s not possible that this type could happen), and (a function which returns or has no return value).\n\nYou’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer . Use when you need specific features.\n\nWith TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: unions and generics.\n\nWith a union, you can declare that a type could be one of many types. For example, you can describe a type as being either or :\n\nNote: If you hover over above, you’ll see that it is classed as . That’s a property of the Structural Type System. More on this below.\n\nA popular use-case for union types is to describe the set of or literals that a value is allowed to be:\n\nUnions provide a way to handle different types too. For example, you may have a function that takes an or a :\n\nTo learn the type of a variable, use :\n\nFor example, you can make a function return different values depending on whether it is passed a string or an array:\n\nGenerics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.\n\nYou can declare your own types that use generics:\n\nOne of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.\n\nIn a structural type system, if two objects have the same shape, they are considered to be of the same type.\n\nThe variable is never declared to be a type. However, TypeScript compares the shape of to the shape of in the type-check. They have the same shape, so the code passes.\n\nThe shape-matching only requires a subset of the object’s fields to match.\n\nThere is no difference between how classes and objects conform to shapes:\n\nIf the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.\n\nThis was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:\n• Read the full Handbook from start to finish"
    }
]