[
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/debugger/c-cpp-assertions?view=vs-2022",
        "document": "An assertion statement specifies a condition that you expect to be true at a point in your program. If that condition is not true, the assertion fails, execution of your program is interrupted, and the Assertion Failed dialog box appears.\n\nVisual Studio supports C++ assertion statements that are based on the following constructs:\n• None ATLASSERT for programs that use ATL.\n• None CRT assertions for programs that use the C run-time library.\n• None The ANSI assert function for other C/C++ programs. You can use assertions to catch logic errors, check results of an operation, and Test error conditions that should have been handled.\n\nWhen the debugger halts because of an MFC or C run-time library assertion, then if the source is available, the debugger navigates to the point in the source file where the assertion occurred. The assertion message appears in both the Output window and the Assertion Failed dialog box. You can copy the assertion message from the Output window to a text window if you want to save it for future reference. The Output window might contain other error messages as well. Examine these messages carefully, because they provide clues to the cause of the assertion failure.\n\nUse assertions to detect errors during development. As a rule, use one assertion for each assumption. For example, if you assume that an argument is not NULL, use an assertion to test that assumption.\n\nAssertion statements compile only if is defined. Otherwise, the compiler treats assertions as null statements. Therefore, assertion statements impose no overhead or performance cost in your final Release program, and allow you to avoid using directives.\n\nWhen you add assertions to your code, make sure the assertions do not have side effects. For example, consider the following assertion that modifies the value:\n\nBecause the expression is not evaluated in the Release version of your program, will have different values in the Debug and Release versions. To avoid this problem in MFC, you can use the VERIFY macro instead of . evaluates the expression in all versions but does not check the result in the Release version.\n\nBe especially careful about using function calls in assertion statements, because evaluating a function can have unexpected side effects.\n\ncalls in both the Debug and Release versions, so it is acceptable to use. However, using imposes the overhead of an unnecessary function call in the Release version.\n\nThe header file defines the and macros for assertion checking.\n\nis more powerful because it reports the asserted expression that turned out to be FALSE. This might be enough to identify the problem without referring to the source code. However, the Debug version of your application will contain a string constant for each expression asserted using . If you use many macros, these string expressions take up a significant amount of memory. If that proves to be a problem, use to save memory.\n\nWhen is defined, the macro is defined as follows:\n\nIf the asserted expression evaluates to FALSE, _CrtDbgReport is called to report the assertion failure (using a message dialog box by default). If you choose Retry in the message dialog box, returns 1 and calls the debugger through .\n\nIf you need to temporarily disable all assertions, use _CtrSetReportMode.\n\nThe following example uses _CrtCheckMemory to check for corruption of the heap:\n\nThe following example uses _CrtIsValidPointer to verify that a given memory range is valid for reading or writing.\n\nThe following example uses _CrtIsValidHeapPointer to verify a pointer points to memory in the local heap (the heap created and managed by this instance of the C run-time library — a DLL can have its own instance of the library, and therefore its own heap, outside of the application heap). This assertion catches not only null or out-of-bounds addresses, but also pointers to static variables, stack variables, and any other nonlocal memory.\n\nThe following example uses _CrtIsMemoryBlock to verify that a memory block is in the local heap and has a valid block type.\n\nMFC defines the ASSERT macro for assertion checking. It also defines the and methods for checking the internal state of a -derived object.\n\nIf the argument of the MFC macro evaluates to zero or false, the macro halts program execution and alerts the user; otherwise, execution continues.\n\nWhen an assertion fails, a message dialog box shows the name of the source file and the line number of the assertion. If you choose Retry in the dialog box, a call to AfxDebugBreak causes execution to break to the debugger. At that point, you can examine the call stack and use other debugger facilities to determine why the assertion failed. If you have enabled Just-in-time debugging, and the debugger was not already running, the dialog box can launch the debugger.\n\nThe following example shows how to use to check the return value of a function:\n\nYou can use ASSERT with the IsKindOf function to provide type checking of function arguments:\n\nThe macro produces no code in the Release version. If you need to evaluate the expression in the Release version, use the VERIFY macro instead of ASSERT.\n\nThe CObject::AssertValid method provides run-time checks of the internal state of an object. Although you are not required to override when you derive your class from , you can make your class more reliable by doing this. should perform assertions on all of the object's member variables to verify that they contain valid values. For example, it should check that pointer member variables are not NULL.\n\nThe following example shows how to declare an function:\n\nWhen you override , call the base class version of before you perform your own checks. Then use the ASSERT macro to check the members unique to your derived class, as shown here:\n\nIf any of your member variables store objects, you can use the macro to test their internal validity (if their classes override ).\n\nFor example, consider a class , which stores a CObList in one of its member variables. The variable, , stores a collection of objects. An abbreviated declaration of looks like this:\n\nThe override in looks like this:\n\nuses the mechanism to test the validity of the objects stored in its data member. The overriding of invokes the macro for its own m_pDataList member variable.\n\nValidity testing does not stop at this level because the class also overrides . This override performs additional validity testing on the internal state of the list. Thus, a validity test on a object leads to additional validity tests for the internal states of the stored list object.\n\nWith some more work, you could add validity tests for the objects stored in the list also. You could derive a class from and override . In the override, you would call and then iterate through the list, calling on each object stored in the list. The class shown at the beginning of this topic already overrides .\n\nThis is a powerful mechanism when you build for debugging. When you subsequently build for release, the mechanism is turned off automatically.\n\nA triggered assertion indicates that the object is definitely bad and execution will stop. However, a lack of assertion indicates only that no problem was found, but the object is not guaranteed to be good.\n\nYou can set an assertion on a condition that must be true according to the logic of your program. The assertion has no effect unless a logic error occurs.\n\nFor example, suppose you are simulating gas molecules in a container, and the variable represents the total number of molecules. This number cannot be less than zero, so you might include an MFC assertion statement like this:\n\nOr you might include a CRT assertion like this:\n\nThese statements do nothing if your program is operating correctly. If a logic error causes to be less than zero, however, the assertion halts the execution of your program and displays the Assertion Failed Dialog Box.\n\nAssertions are valuable for testing operations whose results are not obvious from a quick visual inspection.\n\nFor example, consider the following code, which updates the variable based on the contents of the linked list pointed to by :\n\nThe number of molecules counted by must always be less than or equal to the total number of molecules, . Visual inspection of the loop does not show that this will necessarily be the case, so an assertion statement is used after the loop to test for that condition.\n\nYou can use assertions to test for error conditions at a point in your code where any errors should have been handled. In the following example, a graphic routine returns an error code or zero for success.\n\nIf the error-handling code works properly, the error should be handled and reset to zero before the assertion is reached. If has another value, the assertion fails, the program halts, and the Assertion Failed Dialog Box appears.\n\nAssertion statements are not a substitute for error-handling code, however. The following example shows an assertion statement that can lead to problems in the final release code:\n\nThis code relies on the assertion statement to handle the error condition. As a result, any error code returned by will be unhandled in the final release code."
    },
    {
        "link": "https://stackoverflow.com/questions/48084042/debug-assertion-failed-invalid-heap-pointer-after-vs-upgrade",
        "document": "We recently upgrade our enterprise app from vs2015 to vs2017. This entailed quite a bit of upgrades:\n\nWindows SDK to the newest version to 16299 Newest C++ Runtime 2017 debug support others\n\nWe have 3 layers to our application: A C# UI layer, a VC++\\CLI middle layer, and a C system layer.\n\nWhen EITHER of the following happen: -malloc memory in C layer, free in C++ layer -malloc in C++, free in C\n\nI get the following debug assertion (IN RELEASE BUILDS ONLY!)\n\nAt first we thought we didnt properly upgrade some of the Windows SDK's, but it doesn't seem to be that (after I removed every SDK other than 16299 and it still reproduced). We did the same thing with debug support and the C++ runtime.\n\nFor some reason, it's like the C layer and the C++ layer are now using thier own heap. This worked before our upgrade, and I cannot figure out what changed."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-debug-heap-details?view=msvc-170",
        "document": "The CRT debug heap and related functions provide many ways to track and debug memory management issues in your code. You can use it to find buffer overruns, and to track and report on memory allocations and memory state. It also has support for creating your own debug allocation functions for your unique app needs.\n\nTwo of the most common and intractable problems that programmers encounter are overwriting the end of an allocated buffer and memory leaks (failing to free allocations after they're no longer needed). The debug heap provides powerful tools to solve memory allocation problems of this kind.\n\nThe Debug versions of the heap functions call the standard or base versions used in Release builds. When you request a memory block, the debug heap manager allocates from the base heap a slightly larger block of memory than you requested and returns a pointer to your portion of that block. For example, suppose your application contains the call: . In a Release build, would call the base heap allocation routine requesting an allocation of 10 bytes. In a Debug build, however, would call , which would then call the base heap allocation routine requesting an allocation of 10 bytes plus approximately 36 bytes of extra memory. All the resulting memory blocks in the debug heap are connected in a single linked list, ordered according to when they were allocated.\n\nThe extra memory allocated by the debug heap routines is used for bookkeeping information. It has pointers that link debug memory blocks together, and small buffers on either side of your data to catch overwrites of the allocated region.\n\nCurrently, the block header structure used to store the debug heap's bookkeeping information is declared in the header and defined in the CRT source file. Conceptually, it's similar to this structure:\n\nThe buffers on either side of the user data area of the block are currently 4 bytes in size, and are filled with a known byte value used by the debug heap routines to verify that the limits of the user's memory block haven't been overwritten. The debug heap also fills new memory blocks with a known value. If you elect to keep freed blocks in the heap's linked list, these freed blocks are also filled with a known value. Currently, the actual byte values used are as follows:\n\n(0xFD)\n\n The \"no_mans_land\" buffers on either side of the memory used by an application are currently filled with 0xFD.\n\nFreed blocks (0xDD)\n\n The freed blocks kept unused in the debug heap's linked list when the flag is set are currently filled with 0xDD.\n\nNew objects (0xCD)\n\n New objects are filled with 0xCD when they're allocated.\n\nTypes of blocks on the debug heap\n\nEvery memory block in the debug heap is assigned to one of five allocation types. These types are tracked and reported differently for purposes of leak detection and state reporting. You can specify a block's type by allocating it using a direct call to one of the debug heap allocation functions such as . The five types of memory blocks in the debug heap (set in the member of the structure) are as follows:\n\n\n\n A call to or creates a Normal block. If you intend to use Normal blocks only, and have no need for Client blocks, you may want to define . causes all heap allocation calls to be mapped to their debug equivalents in Debug builds. It allows storage of file name and line number information about each allocation call in the corresponding block header.\n\n\n\n The memory blocks allocated internally by many run-time library functions are marked as CRT blocks so they can be handled separately. As a result, leak detection and other operations may remain unaffected by them. An allocation must never allocate, reallocate, or free any block of CRT type.\n\n\n\n An application can keep special track of a given group of allocations for debugging purposes by allocating them as this type of memory block, using explicit calls to the debug heap functions. MFC, for example, allocates all objects as Client blocks; other applications might keep different memory objects in Client blocks. Subtypes of Client blocks can also be specified for greater tracking granularity. To specify subtypes of Client blocks, shift the number left by 16 bits and it with . For example:\n\nA client-supplied hook function for dumping the objects stored in Client blocks can be installed using , and will then be called whenever a Client block is dumped by a debug function. Also, can be used to call a given function supplied by the application for every Client block in the debug heap.\n\n\n\n Normally, blocks that are freed are removed from the list. To check that freed memory isn't written to, or to simulate low memory conditions, you can keep freed blocks on the linked list, marked as Free, and filled with a known byte value (currently 0xDD).\n\n\n\n It's possible to turn off the debug heap operations for some interval. During this time, memory blocks are kept on the list, but are marked as Ignore blocks.\n\nTo determine the type and subtype of a given block, use the function and the macros and . The macros are defined in as follows:\n\nMany of the debug heap's features must be accessed from within your code. The following section describes some of the features and how to use them.\n\n\n\n You can use a call to , for example, to check the heap's integrity at any point. This function inspects every memory block in the heap. It verifies that the memory block header information is valid, and confirms that the buffers haven't been modified.\n\n\n\n You can control how the debug heap keeps track of allocations using an internal flag, , which can be read and set using the function. By changing this flag, you can instruct the debug heap to check for memory leaks when the program exits and report any leaks that are detected. Similarly, you can tell the heap to leave freed memory blocks in the linked list, to simulate low-memory situations. When the heap is checked, these freed blocks are inspected in their entirety to ensure that they haven't been disturbed.\n\nThe flag contains the following bit fields:\n\nAll calls to heap functions such as , , , , , and resolve to debug versions of those functions that operate in the debug heap. When you free a memory block, the debug heap automatically checks the integrity of the buffers on either side of your allocated area and issues an error report if overwriting has occurred.\n\nTo use the debug heap\n• Link the debug build of your application with a debug version of the C runtime library.\n\nTo change one or more bit fields and create a new state for the flag\n• None Call with the parameter set to (to obtain the current state) and store the returned value in a temporary variable.\n• None Turn on any bits by using a bitwise operator (\"or\") on the temporary variable with the corresponding bitmasks (represented in the application code by manifest constants).\n• None Turn off the other bits by using a bitwise operator (\"and\") on the variable with a bitwise operator (\"not\" or complement) of the appropriate bitmasks.\n• None Call with the parameter set to the value stored in the temporary variable to create the new state for . For example, the following lines of code enable automatic leak detection and disable checks for blocks of type : // Get current flag int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG ); // Turn on leak-checking bit. tmpFlag |= _CRTDBG_LEAK_CHECK_DF; // Turn off CRT block checking bit. tmpFlag &= ~_CRTDBG_CHECK_CRT_DF; // Set flag to the new value. _CrtSetDbgFlag( tmpFlag );\n\n, , and allocations in the C++ debug heap\n\nThe debug versions of the C run-time library contain debug versions of the C++ and operators. If you use the allocation type, you must call the debug version of the operator directly or create macros that replace the operator in debug mode, as shown in the following example:\n\nThe Debug version of the operator works with all block types and requires no changes in your program when you compile a Release version.\n\nTo capture a summary snapshot of the state of the heap at a given time, use the structure defined in :\n\nThis structure saves a pointer to the first (most recently allocated) block in the debug heap's linked list. Then, in two arrays, it records how many of each type of memory block ( , , , and so on) are in the list and the number of bytes allocated in each type of block. Finally, it records the highest number of bytes allocated in the heap as a whole up to that point, and the number of bytes currently allocated.\n\nThe following functions report the state and contents of the heap, and use the information to help detect memory leaks and other problems.\n\nKnowing the source file name and line number of an assert or reporting macro is often useful in locating the cause of a problem. The same isn't as likely to be true of heap allocation functions. While you can insert macros at many appropriate points in an application's logic tree, an allocation is often buried in a function that's called from many different places at many different times. The question isn't what line of code made a bad allocation. Instead, it's which one of the thousands of allocations made by that line of code was bad, and why.\n\nThere's a simple way to identify the specific heap allocation call that went bad. It takes advantage of the unique allocation request number associated with each block in the debug heap. When information about a block is reported by one of the dump functions, this allocation request number is enclosed in braces (for example, \"{36}\").\n\nOnce you know the allocation request number of an improperly allocated block, you can pass this number to to create a breakpoint. Execution will break just before allocating the block, and you can backtrack to determine what routine was responsible for the bad call. To avoid recompiling, you can accomplish the same thing in the debugger by setting to the allocation request number you're interested in.\n\nA more complex approach is to create Debug versions of your own allocation routines, comparable to the versions of the heap allocation functions. You can then pass source file and line number arguments through to the underlying heap allocation routines, and you'll immediately be able to see where a bad allocation originated.\n\nFor example, suppose your application contains a commonly used routine similar to the following example:\n\nIn a header file, you could add code such as the following example:\n\nNext, you could change the allocation in your record-creation routine as follows:\n\nNow the source file name and line number where was called will be stored in each resulting block allocated in the debug heap and will be reported when that block is examined."
    },
    {
        "link": "https://stackoverflow.com/questions/11041189/heap-debugging-assert-failure-in-dbgdel-in-ms-vc-2005",
        "document": "I enabled Heap Debugging in my MS VC++ 2005 project and as the program exits out of the last destructor, I put a call to _CrtDumpMemoryLeaks() there (also enabled _CRTDBG_MAP_ALLOC. But then I saw the following debug assertion screen:\n\nFollowing that I hit Retry to debug it and it takes me to some code (this isn't mine) where I see stuff like:\n\nI am thinking to myself that perhaps name was allocated inside the get(..) function; anyway, my question is: from the screen shot is this a memory/heap bug? I probably have to dig into what cstub's get function is doing. Thanks for any ideas."
    },
    {
        "link": "https://forum.xojo.com/t/assertion-failed-microsoft-visual-c-runtime-library/32221",
        "document": "Building my project on Xojo 2016r1.1 (Windows 7) I get an Assertion Failed at the end of the build. The contents of the dialog are below.\n\n I have seen this once or twice, and re-installing the Windows Runtime seemed to fix it. That has not worked this time. I uninstalled Xojo and re-installed Xojo and still get the same problem. Any one have any ideas ?\n\nExpression: false && “These APIs should always be available”\n\nFor information on how your program can cause an assertion failure, see the Visual C++ documentation on asserts."
    },
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-and-or-new",
        "document": "If you're a C++ expert, please let me know any rules of thumb or conventions you follow in this regard.\n\nI see in C++ there are multiple ways to allocate and free data and I understand that when you call malloc you should call free and when you use the new operator you should pair with delete and it is a mistake to mix the two (e.g. Calling free() on something that was created with the new operator), but I'm not clear on when I should use malloc / free and when I should use new / delete in my real world programs.\n\nUnless you are forced to use C, you should never use . Always use . If you need a big chunk of data just do something like: Be careful though this is not correct: //This is incorrect - may delete only one element, may corrupt the heap, or worse... delete pBuffer; Instead you should do this when deleting an array of data: //This deletes all items in the array delete[] pBuffer; The keyword is the C++ way of doing it, and it will ensure that your type will have its constructor called. The keyword is also more type-safe whereas is not type-safe at all. The only way I could think that would be beneficial to use would be if you needed to change the size of your buffer of data. The keyword does not have an analogous way like . The function might be able to extend the size of a chunk of memory for you more efficiently. It is worth mentioning that you cannot mix / and / . Note: Some answers in this question are invalid. int* p_scalar = new int(5); // Does not create 5 elements, but initializes to 5 int* p_array = new int[5]; // Creates 5 elements\n\nThe short answer is: don't use for C++ without a really good reason for doing so. has a number of deficiencies when used with C++, which was defined to overcome. Deficiencies fixed by new for C++ code\n• None is not typesafe in any meaningful way. In C++ you are required to cast the return from . This potentially introduces a lot of problems:\n• None It's worse than that though. If the type in question is POD (plain old data) then you can semi-sensibly use to allocate memory for it, as does in the first example. It's not so obvious though if a type is POD. The fact that it's possible for a given type to change from POD to non-POD with no resulting compiler error and potentially very hard to debug problems is a significant factor. For example if someone (possibly another programmer, during maintenance, much later on were to make a change that caused to no longer be POD then no obvious error would appear at compile time as you'd hope, e.g.: would make the of also become bad, without any obvious diagnostics. The example here is trivial, but it's possible to accidentally introduce non-PODness much further away (e.g. in a base class, by adding a non-POD member). If you have C++11/boost you can use to check that this assumption is correct and produce an error if it's not: Although boost is unable to determine if a type is POD without C++11 or some other compiler extensions.\n• None returns if allocation fails. will throw . The behaviour of later using a pointer is undefined. An exception has clean semantics when it is thrown and it is thrown from the source of the error. Wrapping with an appropriate test at every call seems tedious and error prone. (You only have to forget once to undo all that good work). An exception can be allowed to propagate to a level where a caller is able to sensibly process it, where as is much harder to pass back meaningfully. We could extend our function to throw an exception or exit the program or call some handler: #include <type_traits> #include <stdlib.h> void my_malloc_failed_handler(); foo *safe_foo_malloc() { static_assert(std::is_pod<foo>::value, \"foo must be POD\"); foo *mem = static_cast<foo*>(malloc(sizeof(foo))); if (!mem) { my_malloc_failed_handler(); // or throw ... } return mem; }\n• None Fundamentally is a C feature and is a C++ feature. As a result does not play nicely with constructors, it only looks at allocating a chunk of bytes. We could extend our further to use placement : #include <stdlib.h> #include <new> void my_malloc_failed_handler(); foo *safe_foo_malloc() { void *mem = malloc(sizeof(foo)); if (!mem) { my_malloc_failed_handler(); // or throw ... } return new (mem)foo(); }\n• None Our function isn't very generic - ideally we'd want something that can handle any type, not just . We can achieve this with templates and variadic templates for non-default constructors: #include <functional> #include <new> #include <stdlib.h> void my_malloc_failed_handler(); template <typename T> struct alloc { template <typename ...Args> static T *safe_malloc(Args&&... args) { void *mem = malloc(sizeof(T)); if (!mem) { my_malloc_failed_handler(); // or throw ... } return new (mem)T(std::forward(args)...); } }; Now though in fixing all the issues we identified so far we've practically reinvented the default operator. If you're going to use and placement then you might as well just use to begin with!\n\n[16.4] Why should I use new instead of trustworthy old malloc()? FAQ: new/delete call the constructor/destructor; new is type safe, malloc is not; new can be overridden by a class. FQA: The virtues of new mentioned by the FAQ are not virtues, because constructors, destructors, and operator overloading are garbage (see what happens when you have no garbage collection?), and the type safety issue is really tiny here (normally you have to cast the void* returned by malloc to the right pointer type to assign it to a typed pointer variable, which may be annoying, but far from \"unsafe\"). Oh, and using trustworthy old malloc makes it possible to use the equally trustworthy & old realloc. Too bad we don't have a shiny new operator renew or something. Still, new is not bad enough to justify a deviation from the common style used throughout a language, even when the language is C++. In particular, classes with non-trivial constructors will misbehave in fatal ways if you simply malloc the objects. So why not use new throughout the code? People rarely overload operator new, so it probably won't get in your way too much. And if they do overload new, you can always ask them to stop.\n\nDynamic allocation is only required when the life-time of the object should be different than the scope it gets created in (This holds as well for making the scope smaller as larger) and you have a specific reason where storing it by value doesn't work. From C++11 on, we have for dealing with allocated memory, which contains the ownership of the allocated memory. was created for when you have to share ownership. (you'll need this less than you would expect in a good program) Creating an instance becomes really easy: C++17 also adds which can prevent you from requiring memory allocations As soon as 'instance' goes out of scope, the memory gets cleaned up. Transferring ownership is also easy: auto vector = std::vector<std::unique_ptr<Interface>>{}; auto instance = std::make_unique<Class>(); vector.push_back(std::move(instance)); // std::move -> transfer (most of the time) So when do you still need ? Almost never from C++11 on. Most of the you use until you get to a point where you hit an API that transfers ownership via raw pointers. auto instance = std::make_unique<Class>(); legacyFunction(instance.release()); // Ownership being transferred auto instance = std::unique_ptr<Class>{legacyFunction()}; // Ownership being captured in unique_ptr Update June 2024: C++23 introduces std::inout_ptr and std::out_ptr. These are intended for parameters of C functions: In C++98/03, you have to do manual memory management. If you are in this case, try upgrading to a more recent version of the standard. If you are stuck: Make sure that you track the ownership correctly to not have any memory leaks! Move semantics don't work yet either. So, when do we need malloc in C++? The only valid reason would be to allocate memory and initialize it later via placement new. auto instanceBlob = std::malloc(sizeof(Class)); // Allocate memory auto instance = new(instanceBlob)Class{}; // Initialize via constructor instance.~Class(); // Destroy via destructor std::free(instanceBlob); // Deallocate the memory Even though, the above is valid, this can be done via a new-operator as well. is a good example for this. Finally, we still have the elephant in the room: . If you have to work with a C-library where memory gets allocated in the C++ code and freed in the C code (or the other way around), you are forced to use malloc/free. If you are in this case, forget about virtual functions, member functions, classes ... Only structs with PODs in it are allowed. Some exceptions to the rules:\n• You are writing a standard library with advanced data structures where malloc is appropriate\n• You have to allocate big amounts of memory (In memory copy of a 10GB file?)\n• You have tooling preventing you to use certain constructs\n• You need to store an incomplete type\n\nThere is one big difference between and . allocates memory. This is fine for C, because in C, a lump of memory is an object. In C++, if you're not dealing with POD types (which are similar to C types) you must call a constructor on a memory location to actually have an object there. Non-POD types are very common in C++, as many C++ features make an object automatically non-POD. allocates memory and creates an object on that memory location. For non-POD types this means calling a constructor. If you do something like this: The pointer you obtain cannot be dereferenced because it does not point to an object. You'd need to call a constructor on it before you can use it (and this is done using placement ). If, on the other hand, you do: You get a pointer that is always valid, because created an object. Even for POD types, there's a significant difference between the two: This piece of code would print an unspecified value, because the POD objects created by are not initialised. With , you could specify a constructor to call, and thus get a well defined value. If you really want it, you can use use to obtain uninitialised POD objects. See this other answer for more information on that. Another difference is the behaviour upon failure. When it fails to allocate memory, returns a null pointer, while throws an exception. The former requires you to test every pointer returned before using it, while the later will always produce valid pointers. For these reasons, in C++ code you should use , and not . But even then, you should not use \"in the open\", because it acquires resources you need to release later on. When you use you should pass its result immediately into a resource managing class:\n\nI had played before with few C/C++ applications for computer graphics. After so many time, some things are vanished and I missed them a lot. The point is, that malloc and new, or free and delete, can work both, especially for certain basic types, which are the most common. For instance, a char array, can be allocated both with malloc, or new. A main difference is, with new you can instantiate a fixed array size. char* pWord = new char[5]; // allocation of char array of fixed size You cannot use a variable for the size of the array in this case. By the contrary, the malloc function could allow a variable size. In this case, it might be required a conversion cast operator. For the returned type from malloc it's a pointer to void, not char. And sometimes the compiler could not know, how to convert this type. After allocation the memory block, you can set the variable values. the memset function can be indeed slower for some bigger arrays. But all the bites must be set first to 0, before assigning a value. Because the values of an array could have an arbitrary content. Suppose, the array is assigned with another array of smaller size. Part of the array element could still have arbitrary content. And a call to a memset function would be recomended in this case. The allocation functions are available for all C packages. So, these are general functions, that must work for more C types. And the C++ libraries are extensions of the older C libraries. Therefore the malloc function returns a generic void* pointer. The sructures do not have defined a new, or a delete operator. In this case, a custom variable can be allocated with malloc. The new and delete keywords are actually some defined C operators. Maybe a custom union, or class, can have defined these operators. If new and delete are not defined in a class, these may not work. But if a class is derived from another, which has these operators, the new and delete keywords can have the basic class behavior. About freeing an array, free can be only used in pair with malloc. Cannot allocate a variable with malloc, and then free with delete. The simple delete operator references just first item of an array. Because the pWord array can be also written as: When an array must be deleted, use the delete[] operator instead: Casts are not bad, they just don't work for all the variable types. A conversion cast is also an operator function, that must be defined. If this operator is not defined for a certain type, it may not work. But not all the errors are because of this conversion cast operator. Also a cast to a void pointer must be used when using a free call. This is because the argument of the free function is a void pointer. Some errors can arise, because the size of the array is too small. But this is another story, it is not because of using the cast."
    },
    {
        "link": "https://stackoverflow.com/questions/79005467/how-do-i-safely-handle-memory-allocation-errors-in-c",
        "document": "The main problem in your code isn't really related to but that you take non-sanitized input and feed it directly to the program. You should check if failed or not. Or better yet, avoid entirely whenever possible.\n\nIn a professional program you need to sanity check that is within given boundaries. It also makes no sense at all to use a signed integer to express array size because it can never be negative.\n\nIt's good practice overall to:\n• Initialize all pointers that are to be used for dynamic memory to NULL.\n• Set every pointer to NULL immediately after calling .\n\nAlso for small amounts of memory there's usually no need to allocate memory dynamically in the first place. Data which is just some hundred bytes could safely be allocated on the stack in most cases.\n\nThere are tools for static analysis or dynamic analysis.\n\nStatic analyzers check your code at compile time (beyond what the compiler already may or may not check) for things like array out of bounds access, dangling pointer bug etc. Dynamic analyzers check the program for bugs as it is running and is able to spot memory leaks that way.\n\nExamples: gcc has some options both for static and dynamic analysis these days, check out Instrumentation Options. For example which can spot a lot of memory-related problems. For other free open source options, there's tools like Clang-Tidy, Valgrid, Frama-C and so on."
    },
    {
        "link": "https://developercommunity.visualstudio.com/idea/403088/overridable-crt-releasedebug-memory-functions-just.html",
        "document": "Sorry this browser is no longer supported\n\nPlease use any other modern browser like 'Microsoft Edge'."
    },
    {
        "link": "https://stevehanov.ca/blog?id=10",
        "document": "A while ago I had the problem of detecting memory leaks in my code, and I didn't want to spend lots of money on a brittle software package to do that. It's fairly simple to redefine malloc() and free() to your own functions, to track the file and line number of memory leaks. But what about the new() and delete() operators? It's a little more difficult with C++, if you want to figure out the exact line number of a resource leak.\n\nIn this article, I'll explain how you can get a stack trace for where your resource leaks occur. This method is for Microsoft Windows. Linux developers are better served with Valgrind.\n• We will use #define to replace the standard implementation of malloc() and free() with ones that record the file and line numbers where they are called. That way, we can track where memory leaks occur for allocations made using the standard C allocation functions.\n• We will overload the new() and delete() operators to track the address of the functions that they are called, by walking backwards up the stack.\n• Finally, we will parse the .map file generated by the linker. This will let us figure out where new() and delete() were called based on the return address information. The first thing we'll do is have an #ifdef, because memory tracking is inefficient. You'll want to cut it out in release versions of your code. Every *.cpp source file in your program should include this file. It's optional, of course. But if you allocate something in a memory-tracked module, and free it in another that doesn't, your program will crash, since it was allocated with _dbgmalloc() and free'd with free() instead of _dbgfree(). void* _dbgmalloc( const char* file, int line, size_t size ) { void* ptr; if ( !_init ) { return malloc( size ); } ptr = add_record( file, line, size ); if ( ptr == 0 ) { dbgprint(( DMEMORY, \"Out of memory.\" )); return 0; } dbgprint(( DMEMORY, \"%s:%d: malloc( %d ) [%p]\", file, line, size, ptr )); return ptr; } void _dbgfree( const char* file, int line, void* ptr ) { if ( ptr == 0 ) { return; } if ( !_init ) { free( ptr ); return; } MemBlock* block = (MemBlock*)ptr - 1; int size = block->size; del_record( file, line, ptr ); dbgprint(( DMEMORY, \"%s:%d: free( [%p], %d )\", file, line, ptr, size )); } The add_record() and del_record() functions perform the real work of memory tracking. They will allocate the requested amount of memory, but they will add space for extra tracking information. The tracking information is stored in the first few bytes of the memory block, and then the returned pointer offset by this amount. We will also reserve extra space at the end of the memory block, so we will be able to detect writes past the end of the array. We will write a specific sequence of bytes (Here, 0x12345678) at this location, and if when the block is free'd, the bytes have been modified, then your program has done something it shouldn't have, and the del_record() function will complain. void* add_record( const char* file, int line, size_t size ) { MemBlock* block; assert(_init); block = (MemBlock*)malloc( sizeof( MemBlock ) + size + 4 ); if ( block == 0 ) { dbgprint(( DMEMORY, \"Out of memory.\" )); return 0; } block->sentry = SENTRY; block->size = size; block->line = line; block->file = _strdup( file ); if ( 0 == block->file && file ) { free( block ); dbgprint(( DMEMORY, \"Out of memory.\" )); return 0; } memcpy( (char*)block + sizeof(*block) + size, &SENTRY, sizeof( SENTRY ) ); EnterCriticalSection(&_cs); list_add_tail( &_blockList, &block->list ); LeaveCriticalSection(&_cs); return block + 1; } What about new? That's all fine and good for malloc() and free(), and strdup() and _tcsdup() and calloc() and realloc(), but what about C++? When you call malloc() above, you see that the macro puts in the file and line number information, but this is not possible for the new operator. Instead, we will do it the hard way. We'll redefine the new operator and then search up the stack for the caller's address and store that. Later, we'll parse the linker's map file to figure out which function it was from the address. Here's the implementation for new() and delete(). They are almost the same as malloc() and free() above, except that they record the return address instead of the file and line information. void* operator new( size_t size ) throw ( std::bad_alloc ) { static bool recurse = false; void* ret; CrashPosition_t pos; if ( recurse || !_init) { return malloc( size ); } EnterCriticalSection(&_cs); pos = getFileLine(1); if ( pos.file == 0 ) { pos.file = pos.function; } ret = add_record( pos.file, pos.line, size ); if ( ret == 0 ) { dbgprint(( DMEMORY, \"Out of memory.\" )); LeaveCriticalSection(&_cs); return 0; } dbgprint(( DMEMORY, \"%s:%d: new( %d ) [%p]\", pos.file, pos.line, size, ret )); LeaveCriticalSection(&_cs); return ret; } /****************************************************************************** *****************************************************************************/ void operator delete( void* ptr ) throw () { CrashPosition_t pos; if ( !_init ) { free( ptr ); return; } if ( ptr == 0 ) { return; } EnterCriticalSection(&_cs); pos = getFileLine(2); LeaveCriticalSection(&_cs); dbgprint(( DMEMORY, \"%s:%d: delete [%p]\", pos.file, pos.line, ptr )); del_record( pos.file, pos.line, ptr ); } Here's where the magic happens. Because file and line number information is not available to the new operator, we will walk the stack in order to record the return address. Later on, we'll figure out the function name where they were called from. static int GetCallStack( unsigned* stack, int max ) { unsigned* my_ebp = 0; int i; __asm { mov eax, ebp mov dword ptr [my_ebp], eax; } // It is not safe to use this function in a WIN32 standard exception handler! if ( IsBadReadPtr( my_ebp + 1, 4 ) ) { return 0; } stack[0] = *(my_ebp + 1); for ( i = 1; i < max; i++ ) { unsigned addr; if ( IsBadReadPtr( my_ebp, 4 ) ) { break; } my_ebp = (unsigned*)(*my_ebp); if ( IsBadReadPtr( my_ebp + 1, 4 ) ) { break; } addr = *(my_ebp + 1); if ( addr ) { stack[i] = addr; } else { break; } } return i; } So far, for malloc() and free() calls, we have recorded the file and line number information, but for new() and delete() we have only the return address. How do we figure out which function called new() and delete()? We will induce the linker to create a .map file. Add these options to your makefile when calling link.exe. Replace example with the name of your executable output file. (The debug.cpp code will assume that the map file has the same base name as the executable). Note: For Microsoft Visual Studio 2005, Microsoft has removed the MAPINFO:LINES option. So you should either use an earlier version of the compiler, or be content without line numbers. You will still have function names. The Map file contains a list of every function in your program, and the exact addresses to which they are loaded. So, using a binary search, we are able to look up a function given an address. I have implemented this process in Mapfile.cpp, which is called diretly from debug.cpp. When your program exits, the debug.cpp module will automatically execute this cleanup code. The cleanup code will dump out any unfree'd memory chunks. static void dump_blocks() { list_entry_t* entry = list_head( &_blockList ); while( entry != &_blockList ) { MemBlock* block = list_entry( entry, MemBlock, list ); dbgprint(( DMEMLEAK, \"Leaked %d bytes from %s:%d [%08x]\", block->size, block->file, block->line, block + 1 )); entry = entry->next; } if ( list_empty(&_blockList ) ) { dbgprint(( DMEMLEAK, \"No memory leaks detected.\" )); } } To see the memory leaks, you will have to implement a debug message handler. I don't have time to explain this right now, but it should be pretty obvious from the source code. Or, you can replace dbgprint() with OutputDebugString(), or printf(), or MessageBox(), or whatever you want."
    }
]