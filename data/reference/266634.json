[
    {
        "link": "https://docs.px4.io/main/en/advanced_config/tuning_the_ecl_ekf.html",
        "document": "This tutorial answers common questions about use of the EKF algorithm used for navigation.\n\nPX4's Navigation filter uses an Extended Kalman Filter (EKF) algorithm to process sensor measurements and provide an estimate of the following states:\n• Quaternion defining the rotation from North, East, Down local navigation frame to X, Y, Z body frame\n• Velocity at the IMU - North, East, Down (m/s)\n\nTo improve stability, an \"error-state\" formulation is implemented This is especially relevant when estimating the uncertainty of a rotation which is a 3D vector (tangent space of SO(3)).\n\nThe EKF runs on a delayed 'fusion time horizon' to allow for different time delays on each measurement relative to the IMU. Data for each sensor is FIFO buffered and retrieved from the buffer by the EKF to be used at the correct time. The delay compensation for each sensor is controlled by the EKF2_*_DELAY parameters.\n\nA complementary filter is used to propagate the states forward from the 'fusion time horizon' to current time using the buffered IMU data. The time constant for this filter is controlled by the EKF2_TAU_VEL and EKF2_TAU_POS parameters.\n\nThe EKF uses the IMU data for state prediction only. IMU data is not used as an observation in the EKF derivation. The algebraic equations for the covariance prediction and measurement jacobians are derived using SymForce and can be found here: Symbolic Derivation. Covariance update is done using the Joseph Stabilized form to improve numerical stability and allow conditional update of independent states.\n\nThe position is estimated as latitude, longitude and altitude and the INS integration is performed using the WGS84 ellipsoid mode. However, the position uncertainty is defined in the local navigation frame at the current position (i.e.: NED error in meters).\n\nThe position and velocity states are adjusted to account for the offset between the IMU and the body frame before they are output to the control loops.\n\nThe position of the IMU relative to the body frame is set by the parameters.\n\nIn addition to the global position estimate in latitude/longitude/altitude, the filter also provides a local position estimate (NED in meters) by projecting the global position estimate using an azimuthal_equidistant_projection centred on an arbitrary origin. This origin is automatically set when global position measurements are fused but can also be specified manually. If no global position information is provided, only the local position is available and the INS integration is performed on a spherical Earth.\n\nThe default behaviour is to run a single instance of the EKF. In this case sensor selection and failover is performed before data is received by the EKF. This provides protection against a limited number of sensor faults, such as loss of data, but does not protect against the sensor providing inaccurate data that exceeds the ability of the EKF and control loops to compensate.\n\nThe parameter settings for running a single EKF instance are:\n\nDepending on the number of IMUs and magnetometers and the autopilot's CPU capacity, multiple instances of the EKF can be run. This provides protection against a wider range of sensor errors and is achieved by each EKF instance using a different sensor combination. By comparing the internal consistency of each EKF instance, the EKF selector is able to determine the EKF and sensor combination with the best data consistency. This enables faults such as sudden changes in IMU bias, saturation or stuck data to be detected and isolated.\n\nThe total number of EKF instances is the product of the number of IMU's and number of magnetometers selected by EKF2_MULTI_IMU and EKF2_MULTI_MAG and is given by the following formula:\n\nFor example an autopilot with 2 IMUs and 2 magnetometers could run with EKF2_MULTI_IMU = 2 and EKF2_MULTI_MAG = 2 for a total of 4 EKF instances where each instance uses the following combination of sensors:\n\nThe maximum number of IMU or magnetometer sensors that can be handled is 4 of each for a theoretical maximum of 4 x 4 = 16 EKF instances. In practice this is limited by available computing resources. During development of this feature, testing with STM32F7 CPU based HW demonstrated 4 EKF instances with acceptable processing load and memory utilisation margin.\n\nIf EKF2_MULTI_IMU >= 3, then the failover time for large rate gyro errors is further reduced because the EKF selector is able to apply a median select strategy for faster isolation of the faulty IMU.\n\nThe setup for multiple EKF instances is controlled by the following parameters:\n• None SENS_IMU_MODE: Set to 0 if running multiple EKF instances with IMU sensor diversity, ie EKF2_MULTI_IMU > 1. When set to 1 (default for single EKF operation) the sensor module selects IMU data used by the EKF. This provides protection against loss of data from the sensor but does not protect against bad sensor data. When set to 0, the sensor module does not make a selection.\n• None SENS_MAG_MODE: Set to 0 if running multiple EKF instances with magnetometer sensor diversity, ie EKF2_MULTI_MAG > 1. When set to 1 (default for single EKF operation) the sensor module selects Magnetometer data used by the EKF. This provides protection against loss of data from the sensor but does not protect against bad sensor data. When set to 0, the sensor module does not make a selection.\n• None EKF2_MULTI_IMU: This parameter specifies the number of IMU sensors used by the multiple EKF's. If <= 1, then only the first IMU sensor will be used. When SENS_IMU_MODE = 1, this will be the sensor selected by the sensor module. If >= 2, then a separate EKF instance will run for the specified number of IMU sensors up to the lesser of 4 or the number of IMU's present.\n• None EKF2_MULTI_MAG: This parameter specifies the number of magnetometer sensors used by the multiple EKF's If <= 1, then only the first magnetometer sensor will be used. When SENS_MAG_MODE = 1, this will be the sensor selected by the sensor module. If >= 2, then a separate EKF instance will run for the specified number of magnetometer sensors up to the lesser of 4 or the number of magnetometers present.\n\nWhat sensor measurements does it use? ​\n\nThe EKF has different modes of operation that allow for different combinations of sensor measurements. On start-up the filter checks for a minimum viable combination of sensors and after initial tilt, yaw and height alignment is completed, enters a mode that provides rotation, vertical velocity, vertical position, IMU delta angle bias and IMU delta velocity bias estimates.\n\nThis mode requires IMU data, a source of yaw (magnetometer or external vision) and a source of height data. This minimum data set is required for all EKF modes of operation. Other sensor data can then be used to estimate additional states.\n• Three axis body fixed Inertial Measurement unit delta angle and delta velocity data at a minimum rate of 100Hz. Note: Coning corrections should be applied to the IMU delta angle data before it is used by the EKF.\n\nThree axis body fixed magnetometer data at a minimum rate of 5Hz is required to be considered by the estimator.\n\nMagnetometer data fusion can be configured using EKF2_MAG_TYPE:\n• Automatic:\n• The magnetometer readings only affect the heading estimate before arming, and the whole attitude after arming.\n• Heading and tilt errors are compensated when using this method.\n• The magnetometer biases are estimated whenever observable.\n• Magnetic heading:\n• Only the heading is corrected. The tilt estimate is never affected by incorrect magnetic field measurements.\n• Tilt errors that could arise when flying without velocity/position aiding are not corrected when using this method.\n• The magnetometer biases are estimated whenever observable.\n• None:\n• Magnetometer data is never used. This is useful when the data can never be trusted (e.g.: high current close to the sensor, external anomalies).\n• The estimator will use other sources of heading: GPS heading or external vision.\n• When using GPS measurements without another source of heading, the heading can only be initialized after sufficient horizontal acceleration. See Estimate yaw from vehicle movement below.\n• Init only:\n• Magnetometer data is only used to initialize the heading estimate. This is useful when the data can be used before arming but not afterwards (e.g.: high current after the vehicle is armed).\n• After initialization, the heading is constrained using other observations.\n• Unlike mag type , when combined with GPS measurements, this method allows position controlled modes to run directly during takeoff.\n\nThe following selection tree can be used to select the right option:\n\nA source of height data - GPS, barometric pressure, range finder, external vision or a combination of those at a minimum rate of 5Hz is required.\n\nIf none of the selected measurements are present, the EKF will not start. When these measurements have been detected, the EKF will initialise the states and complete the tilt and yaw alignment. When tilt and yaw alignment is complete, the EKF can then transition to other modes of operation enabling use of additional sensor data:\n\nEach height source can be enabled/disabled using its dedicated control parameter:\n• External vision: Enabled when EKF2_HGT_REF is set to \"Vision\"\n\nOver the long term the height estimate follows the \"reference source\" of height data. This reference is defined by the EKF2_HGT_REF parameter.\n\nEnable/disable using EKF2_BARO_CTRL as a source for Height data.\n\nNote that data from only one barometer is fused, even if multiple barometers are available. The barometer with the highest CAL_BAROx_PRIO priority value is selected first, falling back to the next highest priority barometer if a sensor fault is detected. If barometers have equal-highest priorities, the first detected is used. A barometer can be completely disabled as a possible source by setting its value to (disabled).\n\nSee Height more details about the configuration of height sources.\n\nBarometric pressure altitude is subject to errors generated by aerodynamic disturbances caused by vehicle wind relative velocity and orientation. This is known in aeronautics as static pressure position error. The EKF2 module that uses the ECL/EKF2 estimator library provides a method of compensating for these errors, provided wind speed state estimation is active.\n\nFor vehicles operating in a fixed-wing mode, wind speed state estimation requires either Airspeed and/or Synthetic Sideslip fusion to be enabled.\n\nFor multi-rotors, fusion of Drag Specific Forces can be enabled and tuned to provide the required wind velocity state estimates.\n\nThe EKF2 module models the error as a body fixed ellipsoid that specifies the fraction of dynamic pressure that is added to/subtracted from the barometric pressure - before it is converted to a height estimate.\n\nA good tuning is obtained as follows:\n• None Fly once in Position mode repeatedly forwards/backwards/left/right/up/down between rest and maximum speed (best results are obtained when this testing is conducted in still conditions).\n• None Extract the log file using, for example, QGroundControl: Analyze > Log Download The same log file can be used to tune the multirotor wind estimator.\n• None Use the log with the baro_static_pressure_compensation_tuning.py Python script to obtain the optimal set of parameters.\n\nA barometer at a constant altitude is subject to drift in its measurements due to changes in the ambient pressure environment or variations of the sensor temperature. To compensate for this measurement error, EKF2 estimates the bias using GNSS height (if available) a \"non drifting\" reference. No tuning is required.\n\nGPS measurements will be used for position and velocity if the following conditions are met:\n• GPS use is enabled via setting of the EKF2_GPS_CTRL parameter.\n• GPS quality checks have passed. These checks are controlled by the EKF2_GPS_CHECK and parameters.\n\nFor more details about the configuration of height sources, click here.\n\nSome GPS receivers such as the Trimble MB-Two RTK GPS receiver can be used to provide a heading measurement that replaces the use of magnetometer data. This can be a significant advantage when operating in an environment where large magnetic anomalies are present, or at latitudes here the earth's magnetic field has a high inclination. Use of GPS yaw measurements is enabled by setting bit position 3 to 1 (adding 8) in the EKF2_GPS_CTRL parameter.\n\nThe EKF runs an additional multi-hypothesis filter internally that uses multiple 3-state Extended Kalman Filters (EKF's) whose states are NE velocity and yaw angle. These individual yaw angle estimates are then combined using a Gaussian Sum Filter (GSF). The individual 3-state EKF's use IMU and GPS horizontal velocity data (plus optional airspeed data) and do not rely on any prior knowledge of the yaw angle or magnetometer measurements. This provides a backup to the yaw from the main filter and is used to reset the yaw for the main 24-state EKF when a post-takeoff loss of navigation indicates that the yaw estimate from the magnetometer is bad. This will result in an message information message at the GCS.\n\nData from this estimator is logged when ekf2 replay logging is enabled and can be viewed in the message. The individual yaw estimates from the individual 3-state EKF yaw estimators are in the fields. The GSF combined yaw estimate is in the field. The variance for the GSF yaw estimate is in the field. All angles are in radians. Weightings applied by the GSF to the individual 3-state EKF outputs are in the fields.\n\nThis also makes it possible to operate without any magnetometer data or dual antenna GPS receiver for yaw provided some horizontal movement after takeoff can be performed to enable the yaw to become observable. To use this feature, set EKF2_MAG_TYPE to (5) to disable magnetometer use. Once the vehicle has performed sufficient horizontal movement to make the yaw observable, the main 24-state EKF will align it's yaw to the GSF estimate and commence use of GPS.\n\nData from GPS receivers can be blended using an algorithm that weights data based on reported accuracy (this works best if both receivers output data at the same rate and use the same accuracy). The mechanism also provides automatic failover if data from a receiver is lost (it allows, for example, a standard GPS to be used as a backup to a more accurate RTK receiver). This is controlled by the SENS_GPS_MASK parameter.\n\nThe SENS_GPS_MASK parameter is set by default to disable blending and always use the first receiver, so it will have to be set to select which receiver accuracy metrics are used to decide how much each receiver output contributes to the blended solution. Where different receiver models are used, it is important that the SENS_GPS_MASK parameter is set to a value that uses accuracy metrics that are supported by both receivers. For example do not set bit position 0 to unless the drivers for both receivers publish values in the field of the message that are comparable. This can be difficult with receivers from different manufacturers due to the different way that accuracy is defined, e.g. CEP vs 1-sigma, etc.\n\nThe following items should be checked during setup:\n• Verify that data for the second receiver is present. This will be logged as and can also be checked when connected via the nsh console using the command . The GPS_2_CONFIG parameter will need to be set correctly.\n• Check the , and data from each receiver and decide which accuracy metrics can be used. If both receivers output sensible and data, and GPS vertical position is not being used directly for navigation, then setting SENS_GPS_MASK to 3 is recommended. Where only data is available and both receivers do not output data, set SENS_GPS_MASK to 2. Bit position 2 would only be set if the GPS had been selected as the reference height source with the EKF2_HGT_REF parameter and both receivers output sensible data.\n• The output from the blended receiver data is logged as , and can be checked whilst connect via the nsh terminal using the command .\n• Where receivers output at different rates, the blended output will be at the rate of slower receiver. Where possible receivers should be configured to output at the same rate.\n\nFor the ECL to accept GNSS data for navigation, certain minimum requirements need to be satisfied over a period of time, defined by EKF2_REQ_GPS_H (10 seconds by default).\n\nMinima are defined in the EKF2REQ* parameters and each check can be enabled/disabled using the EKF2_GPS_CHECK parameter.\n\nThe table below shows the different metrics directly reported or calculated from the GNSS data, and the minimum required values for the data to be used by ECL. In addition, the Average Value column shows typical values that might reasonably be obtained from a standard GNSS module (e.g. u-blox M8 series) - i.e. values that are considered good/acceptable.\n\nRange finder distance to ground is used by a single state filter to estimate the vertical position of the terrain relative to the height datum.\n\nThe fusion modes of operation are controlled by EKF2_RNG_CTRL:\n\nFor more details about the configuration of height sources, click here.\n\nConditional range finder fusion (a.k.a. Conditional range aid) activates the range finder fusion for height estimation during low speed/low altitude operation (in addition to the other active height sources). If the range finder is set as the reference height source (using EKF2_HGT_REF), the other active height sources such as baro and GNSS altitude will adjust their measurement to match the readings of the range finder over time. When the conditions are not met to start range aiding, a secondary reference is automatically selected.\n\nIt is primarily intended for takeoff and landing, in cases where the barometer setup is such that interference from rotor wash is excessive and can corrupt EKF state estimates.\n\nRange aid may also be used to improve altitude hold when the vehicle is stationary.\n\nIt is further configured using the parameters:\n• EKF2_RNG_A_VMAX: Maximum horizontal speed, above which range aid is disabled.\n• EKF2_RNG_A_HMAX: Maximum height, above which range aid is disabled.\n• EKF2_RNG_A_IGATE: Range aid consistency checks \"gate\" (a measure of the error before range aid is disabled).\n\nPX4 allows you to continuously fuse the range finder as a source of height (in any flight mode/vehicle type). This may be useful for applications when the vehicle is guaranteed to only fly over a near-flat surface (e.g. indoors).\n\nWhen using a distance sensor as a height source, fliers should be aware:\n• None Flying over obstacles can lead to the estimator rejecting rangefinder data (due to internal data consistency checks), which can result in poor altitude holding while the estimator is relying purely on accelerometer estimates. This scenario might occur when a vehicle ascends a slope at a near-constant height above ground, because the rangefinder altitude does not change while that estimated from the accelerometer does. The EKF performs innovation consistency checks that take into account the error between measurement and current state as well as the estimated variance of the state and the variance of the measurement itself. If the checks fail the rangefinder data will be rejected, and the altitude will be estimated from the accelerometer and the other selected height sources (GNSS, baro, vision), if enabled and available After 5 seconds of inconsistent data if the distance sensor is the active source oh height data, the estimator resets the height state to match the current distance sensor data. If one or more other sources of height are active, the range finder is declared faulty and the estimator continues to estimate its height using the other sensors. The measurements might also become consistent again, for example, if the vehicle descends, or if the estimated height drifts to match the measured rangefinder height.\n• None The local NED origin will move up and down with ground level.\n• None Rangefinder performance over uneven surfaces (e.g. trees) can be very poor, resulting in noisy and inconsistent data. This again leads to poor altitude hold.\n\nThe feature is enabled by setting EKF2_RNG_CTRL to \"Enabled\" (2). To make the range finder the height reference when active, set: EKF2_HGT_REF to \"Range sensor\".\n\nThe EKF can detect whether the rangefinder path-to-ground is obstructed (perhaps by a payload) using a kinematic consistency check between the vertical velocity estimate and the numerical derivative of the range finder data. If the range finder is statistically inconsistent with EKF2, the sensor is rejected for the rest of the flight unless the statistical test passes again for at least 1 second at a vertical speed of 0.5m/s or more.\n\nThe check is only enabled when the rangefinder is not used as the primary height source, and is only active while the vehicle is not moving horizontally (as it assumes a static ground height).\n\nFor effective obstruction detection, the range finder noise parameter needs to be tightly tuned using flight data. The kinematic consistency gate parameter can then be adjusted to obtain the desired fault detection sensitivity.\n\nEquivalent Airspeed (EAS) data can be used to estimate wind velocity and reduce drift when GPS is lost by setting EKF2_ARSP_THR to a positive value. Airspeed data will be used when it exceeds the threshold set by a positive value for EKF2_ARSP_THR and the vehicle type is not rotary wing.\n\nFixed-wing platforms can take advantage of an assumed sideslip observation of zero to improve wind speed estimation and also enable wind speed estimation without an airspeed sensor. This is enabled by setting the EKF2_FUSE_BETA parameter to 1.\n\nMulti-rotor platforms can take advantage of the relationship between airspeed and drag force along the X and Y body axes to estimate North/East components of wind velocity. This can be enabled using EKF2_DRAG_CTRL.\n\nThe relationship between airspeed and specific force (IMU accelerometer measurements) along the X and Y body axes is controlled by the EKF2_BCOEF_X, EKF2_BCOEF_Y and EKF2_MCOEF parameters which set the ballistic coefficients for flight in the X and Y directions, and the momentum drag produced by the propellers, respectively. The amount of specific force observation noise is set by the EKF2_DRAG_NOISE parameter.\n\nA good tuning is obtained as follows:\n• Fly once in Position mode repeatedly forwards/backwards/left/right/up/down between rest and maximum speed (best results are obtained when this testing is conducted in still conditions).\n• Extract the .ulg log file using, for example, QGroundControl: Analyze > Log Download The same .ulg log file can also be used to tune the static pressure position error coefficients.\n• Use the log with the mc_wind_estimator_tuning.py Python script to obtain the optimal set of parameters.\n\nOptical flow data will be used if the following conditions are met:\n• The quality metric returned by the flow sensor is greater than the minimum requirement set by the EKF2_OF_QMIN parameter.\n\nFor better performance, set the location of the optical flow sensor as described here.\n\nIf a stable hover can be achieved at low altitude above ground (< 10m) but slow oscillations occur at higher altitude, consider adjusting the optical flow scale factor.\n\nPosition, velocity or orientation measurements from an external vision system, e.g. Vicon, can be used.\n\nThe measurements that are fused are configured by setting the appropriate bits of EKF2_EV_CTRL to :\n• : Vertical position data. Height sources may additionally be configured using EKF2_HGT_REF (see section Height).\n\nNote that if yaw data is used (bit 3) the heading is with respect to the external vision frame; otherwise the heading is relative to North.\n\nThe EKF considers uncertainty in the visual pose estimate. This uncertainty information can be sent via the covariance fields in the MAVLink ODOMETRY message or it can be set through the parameters EKF2_EVP_NOISE, EKF2_EVV_NOISE and EKF2_EVA_NOISE. You can choose the source of the uncertainty with EKF2_EV_NOISE_MD.\n\nHow do I use the 'ecl' library EKF? ​\n\nEKF2 is enabled by default (for more information see Switching State Estimators and EKF2_EN).\n\nWhat are the advantages and disadvantages of the ecl EKF over other estimators? ​\n\nLike all estimators, much of the performance comes from the tuning to match sensor characteristics. Tuning is a compromise between accuracy and robustness and although we have attempted to provide a tune that meets the needs of most users, there will be applications where tuning changes are required.\n\nFor this reason, no claims for accuracy relative to the legacy combination of + have been made and the best choice of estimator will depend on the application and tuning.\n• The ecl EKF is a complex algorithm that requires a good understanding of extended Kalman filter theory and its application to navigation problems to tune successfully. It is therefore more difficult for users that are not achieving good results to know what to change.\n• The ecl EKF uses more RAM and flash space.\n• The ecl EKF uses more logging space.\n• The ecl EKF is able to fuse data from sensors with different time delays and data rates in a mathematically consistent way which improves accuracy during dynamic maneuvers once time delay parameters are set correctly.\n• The ecl EKF is capable of fusing a large range of different sensor types.\n• The ecl EKF detects and reports statistically significant inconsistencies in sensor data, assisting with diagnosis of sensor errors.\n• For fixed-wing operation, the ecl EKF estimates wind speed with or without an airspeed sensor and is able to use the estimated wind in combination with airspeed measurements and sideslip assumptions to extend the dead-reckoning time available if GPS is lost in flight.\n• The ecl EKF estimates 3-axis accelerometer bias which improves accuracy for tailsitters and other vehicles that experience large attitude changes between flight phases.\n• The federated architecture (combined attitude and position/velocity estimation) means that attitude estimation benefits from all sensor measurements. This should provide the potential for improved attitude estimation if tuned correctly.\n\nHow do I check the EKF performance? ​\n\nEKF outputs, states and status data are published to a number of uORB topics which are logged to the SD card during flight. The following guide assumes that data has been logged using the .ulog file format. The .ulog format data can be parsed in python by using the PX4 pyulog library.\n\nMost of the EKF data is found in the EstimatorInnovations and EstimatorStatus uORB messages that are logged to the .ulog file.\n\nA python script that automatically generates analysis plots and metadata can be found here. To use this script file, cd to the directory and enter . This saves performance metadata in a csv file named <log_file>.mdat.csv and plots in a pdf file named .\n\nMultiple log files in a directory can be analysed using the batch_process_logdata_ekf.py script. When this has been done, the performance metadata files can be processed to provide a statistical assessment of the estimator performance across the population of logs using the batch_process_metadata_ekf.py script.\n• Attitude output data is found in the VehicleAttitude message.\n• Local position output data is found in the VehicleLocalPosition message.\n• Global (WGS-84) output data is found in the VehicleGlobalPosition message.\n• Wind velocity output data is found in the Wind.msg message.\n\nRefer to states[24] in EstimatorStates. The index map for states[24] is as follows:\n\nRefer to covariances[24] in EstimatorStates. The index map for covariances[24] is as follows:\n\nThe observation , , and message fields are defined in EstimatorInnovations.msg. The messages all have the same field names/types (but different units).\n\nSome of the observations are:\n\nIn addition, each sensor has its own fields for horizontal and vertical position and/or velocity values (where appropriate). These are largely self documenting, and are reproduced below:\n\nThe output complementary filter is used to propagate states forward from the fusion time horizon to current time. To check the magnitude of the angular, velocity and position tracking errors measured at the fusion time horizon, refer to in the message.\n\nThe index map is as follows:\n• [1] Velocity tracking error magnitude (m/s). The velocity tracking time constant can be adjusted using the EKF2_TAU_VEL parameter. Reducing this parameter reduces steady state errors but increases the amount of observation noise on the NED velocity outputs.\n• [2] Position tracking error magnitude (m). The position tracking time constant can be adjusted using the EKF2_TAU_POS parameter. Reducing this parameter reduces steady state errors but increases the amount of observation noise on the NED position outputs.\n\nThe EKF contains internal error checking for badly conditioned state and covariance updates. Refer to the in EstimatorStatus.\n\nThere are two categories of observation faults:\n• Loss of data. An example of this is a range finder failing to provide a return.\n• The innovation, which is the difference between the state prediction and sensor observation is excessive. An example of this is excessive vibration causing a large vertical position error, resulting in the barometer height measurement being rejected.\n\nBoth of these can result in observation data being rejected for long enough to cause the EKF to attempt a reset of the states using the sensor observations. All observations have a statistical confidence checks applied to the innovations. The number of standard deviations for the check are controlled by the parameter for each observation type.\n\nTest levels are available in EstimatorStatus as follows:\n• : ratio of the largest magnetometer innovation component to the innovation test limit\n• : ratio of the largest velocity innovation component to the innovation test limit\n• : ratio of the largest horizontal position innovation component to the innovation test limit\n• : ratio of the vertical position innovation to the innovation test limit\n• : ratio of the true airspeed innovation to the innovation test limit\n• : ratio of the height above ground innovation to the innovation test limit\n\nFor a binary pass/fail summary for each sensor, refer to innovation_check_flags in EstimatorStatus.\n\nThe EKF applies a number of GPS quality checks before commencing GPS aiding. These checks are controlled by the EKF2_GPS_CHECK and parameters. The pass/fail status for these checks is logged in the EstimatorStatus.gps_check_fail_flags message. This integer will be zero when all required GPS checks have passed. If the EKF is not commencing GPS alignment, check the value of the integer against the bitmask definition in EstimatorStatus.\n\nThe EKF uses single precision floating point operations for all of its computations and first order approximations for derivation of the covariance prediction and update equations in order to reduce processing requirements. This means that it is possible when re-tuning the EKF to encounter conditions where the covariance matrix operations become badly conditioned enough to cause divergence or significant errors in the state estimates.\n\nTo prevent this, every covariance and state update step contains the following error detection and correction steps:\n• If the innovation variance is less than the observation variance (this requires a negative state variance which is impossible) or the covariance update will produce a negative variance for any of the states, then:\n• The state and covariance update is skipped\n• The corresponding rows and columns in the covariance matrix are reset\n• The failure is recorded in the EstimatorStatus message\n• State variances (diagonals in the covariance matrix) are constrained to be non-negative.\n• An upper limit is applied to state variances.\n• Symmetry is forced on the covariance matrix.\n\nAfter re-tuning the filter, particularly re-tuning that involve reducing the noise variables, the value of should be checked to ensure that it remains zero.\n\nWhat should I do if the height estimate is diverging? ​\n\nThe most common cause of EKF height diverging away from GPS and altimeter measurements during flight is clipping and/or aliasing of the IMU measurements caused by vibration. If this is occurring, then the following signs should be evident in the data\n• EstimatorInnovations.vel_pos_innov[2] and EstimatorInnovations.vel_pos_innov[5] will both have the same sign.\n• EstimatorStatus.hgt_test_ratio will be greater than 1.0\n\nThe recommended first step is to ensure that the autopilot is isolated from the airframe using an effective isolation mounting system. An isolation mount has 6 degrees of freedom, and therefore 6 resonant frequencies. As a general rule, the 6 resonant frequencies of the autopilot on the isolation mount should be above 25Hz to avoid interaction with the autopilot dynamics and below the frequency of the motors.\n\nAn isolation mount can make vibration worse if the resonant frequencies coincide with motor or propeller blade passage frequencies.\n\nThe EKF can be made more resistant to vibration induced height divergence by making the following parameter changes:\n• Double the value of the innovation gate for the primary height sensor. If using barometric height this is EKF2_BARO_GATE.\n• Increase the value of EKF2_ACC_NOISE to 0.5 initially. If divergence is still occurring, increase in further increments of 0.1 but do not go above 1.0\n\nNote that the effect of these changes will make the EKF more sensitive to errors in GPS vertical velocity and barometric pressure.\n\nWhat should I do if the position estimate is diverging? ​\n\nThe most common causes of position divergence are:\n• High vibration levels.\n• Fix by improving mechanical isolation of the autopilot.\n• Increasing the value of EKF2_ACC_NOISE and EKF2_GYR_NOISE can help, but does make the EKF more vulnerable to GPS glitches.\n• Large gyro bias offsets.\n• Fix by re-calibrating the gyro. Check for excessive temperature sensitivity (> 3 deg/sec bias change during warm-up from a cold start and replace the sensor if affected of insulate to slow the rate of temperature change.\n• Bad yaw alignment\n• Check the heading shown QGC is within 15 deg truth\n\nDetermining which of these is the primary cause requires a methodical approach to analysis of the EKF log data:\n\nDuring normal operation, all the test ratios should remain below 0.5 with only occasional spikes above this as shown in the example below from a successful flight:\n\nThe following plot shows the EKF vibration metrics for a multirotor with good isolation. The landing shock and the increased vibration during takeoff and landing can be seen. Insufficient data has been gathered with these metrics to provide specific advice on maximum thresholds.\n\nThe above vibration metrics are of limited value as the presence of vibration at a frequency close to the IMU sampling frequency (1 kHz for most boards) will cause offsets to appear in the data that do not show up in the high frequency vibration metrics. The only way to detect aliasing errors is in their effect on inertial navigation accuracy and the rise in innovation levels.\n\nIn addition to generating large position and velocity test ratios of > 1.0, the different error mechanisms affect the other test ratios in different ways:\n\nHigh vibration levels normally affect vertical position and velocity innovations as well as the horizontal components. Magnetometer test levels are only affected to a small extent.\n\nLarge gyro bias offsets are normally characterised by a change in the value of delta angle bias greater than 5E-4 during flight (equivalent to ~3 deg/sec) and can also cause a large increase in the magnetometer test ratio if the yaw axis is affected. Height is normally unaffected other than extreme cases. Switch on bias value of up to 5 deg/sec can be tolerated provided the filter is given time settle before flying. Pre-flight checks performed by the commander should prevent arming if the position is diverging.\n\nBad yaw alignment causes a velocity test ratio that increases rapidly when the vehicle starts moving due inconsistency in the direction of velocity calculated by the inertial nav and the GPS measurement. Magnetometer innovations are slightly affected. Height is normally unaffected.\n\nPoor GPS accuracy is normally accompanied by a rise in the reported velocity error of the receiver in conjunction with a rise in innovations. Transient errors due to multipath, obscuration and interference are more common causes. Here is an example of a temporary loss of GPS accuracy where the multi-rotor started drifting away from its loiter location and had to be corrected using the sticks. The rise in EstimatorStatus.vel_test_ratio to greater than 1 indicates the GPs velocity was inconsistent with other measurements and has been rejected.\n\nThis is accompanied with rise in the GPS receivers reported velocity accuracy which indicates that it was likely a GPS error.\n\nIf we also look at the GPS horizontal velocity innovations and innovation variances, we can see the large spike in North velocity innovation that accompanies this GPS 'glitch' event.\n\nLoss of GPS data will be shown by the velocity and position innovation test ratios 'flat-lining'. If this occurs, check the other GPS status data in for further information.\n\nThe following plot shows the NED GPS velocity innovations , the GPS NE position innovations and the Baro vertical position innovation generated from a simulated VTOL flight using SITL Gazebo.\n\nThe simulated GPS was made to lose lock at 73 seconds. Note the NED velocity innovations and NE position innovations 'flat-line' after GPS is lost. Note that after 10 seconds without GPS data, the EKF reverts back to a static position mode using the last known position and the NE position innovations start to change again.\n\nIf the vehicle has the tendency during landing to climb back into the air when close to the ground, the most likely cause is barometer ground effect.\n\nThis is caused when air pushed down by the propellers hits the ground and creates a high pressure zone below the drone. The result is a lower reading of pressure altitude, leading to an unwanted climb being commanded. The figure below shows a typical situation where the ground effect is present. Note how the barometer signal dips at the beginning and end of the flight.\n\nYou can enable ground effect compensation to fix this problem:\n• From the plot estimate the magnitude of the barometer dip during takeoff or landing. In the plot above one can read a barometer dip of about 6 meters during landing.\n• Then set the parameter EKF2_GND_EFF_DZ to that value and add a 10 percent margin. Therefore, in this case a value of 6.6 meters would be a good starting point.\n\nIf a terrain estimate is available (e.g. the vehicle is equipped with a range finder) then you can additionally specify EKF2_GND_MAX_HGT, the above ground-level altitude below which ground effect compensation should be activated. If no terrain estimate is available this parameter will have no effect and the system will use heuristics to determine if ground effect compensation should be activated.\n• PX4 State Estimation Overview, PX4 Developer Summit 2019, Dr. Paul Riseborough): Overview of the estimator, and major changes from 2018/19, and the expected improvements through 2019/20."
    },
    {
        "link": "https://github.com/PX4/Firmware/issues/10517",
        "document": ""
    },
    {
        "link": "https://discuss.px4.io/t/unable-to-takeoff-in-jmavsim/21229",
        "document": "### Solved Problem When switching to a manual mode (Manual, Acro, Stabilized, A…ltitude, Position) without a stick input source it is currently possible to arm and stay in the mode. Fixes https://github.com/PX4/PX4-Autopilot/pull/20172#discussion_r988214569 ### Solution #### Requirements 1. **[untouched]** Stick input disabled and not required -> Nothing 2. **[untouched]** Stick input present but lost in flight -> Failsafe NAV_RCL_ACT (tested with RTL only!) 3. **[mandatory]** Manual mode (Manual, Acro, Stabilized, Altitude, Position) and disabled or unavailable stick input -> Error 4. **[nice to have]** Stick input enabled but not present when not required -> Warning | | RC required | RC not required | |---|---|---| | RC disabled | Error 3. | OK 1. | | RC enabled not present | Error 3. | Warn 4. | | RC enabled and present | OK | OK | #### Steps/commits - Establish manual control as mode requirement for manual modes working towards 3. - Make sure the manual control availability flag `manual_control_signal_lost` gets updated also when manual control is disabled and remove the existing manual control check to establish 3. - Minor reorder - Add back a revised second manual control check for 4. - Suggestion to allow a check to just publish a warning (no failure) but only for certain modes. Originally that's only possible for all modes see https://github.com/PX4/PX4-Autopilot/blob/c5dc1221b68352725630cbda5c04bc0f5c3c1617/src/modules/commander/HealthAndArmingChecks/Common.hpp#L239 https://github.com/PX4/PX4-Autopilot/blob/c5dc1221b68352725630cbda5c04bc0f5c3c1617/src/modules/commander/HealthAndArmingChecks/Common.cpp#L92-L95. Alternatively the condition outside the check could look at the mode and requirement mask but that's in my eyes worse. Not sure if you have a better idea to achieve 3. and 4. without having a duplicate event with RC enabled and required but not present: ### Alternatives - We can move on with just the first 3 commits and move 4. to a different pr. - We can move on with just the first 4 commits but then there's a duplicate even in the 4. case: <img width=\"177\" alt=\"warning and requirement\" src=\"https://user-images.githubusercontent.com/4668506/205116148-30f40268-4654-432e-86fa-292399602add.png\"> ### Test coverage I successfully tested the entire case table above in SITL with a joystick using: - RC disabled: `COM_RC_IN_MODE` Disabled - RC enabled not present: `COM_RC_IN_MODE` set to RC only - RC enabled and present: `COM_RC_IN_MODE` set to Joystick only The options mentioned under alternatives were also tested the same way."
    },
    {
        "link": "https://github.com/PX4/PX4-Autopilot/blob/main/src/modules/ekf2/EKF2.cpp",
        "document": "* Redistribution and use in source and binary forms, with or without\n\n* 3. Neither the name PX4 nor the names of its contributors may be\n\n* \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\n* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n\n* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n\nwind direction is given as azimuth where wind blows FROM\n\n* @description EKF2_DELAY_MAX({1}ms) is too small compared to the maximum sensor delay ({2})"
    },
    {
        "link": "https://docs.px4.io/v1.12/en/advanced_config/tuning_the_ecl_ekf.html",
        "document": "This tutorial answers common questions about use of the ECL EKF algorithm.\n\n# What is the ECL EKF?\n\nThe Estimation and Control Library (ECL) uses an Extended Kalman Filter (EKF) algorithm to process sensor measurements and provide an estimate of the following states:\n• Quaternion defining the rotation from North, East, Down local earth frame to X, Y, Z body frame\n• Velocity at the IMU - North, East, Down (m/s)\n• Position at the IMU - North, East, Down (m)\n\nThe EKF runs on a delayed 'fusion time horizon' to allow for different time delays on each measurement relative to the IMU. Data for each sensor is FIFO buffered and retrieved from the buffer by the EKF to be used at the correct time. The delay compensation for each sensor is controlled by the EKF2_*_DELAY parameters.\n\nA complementary filter is used to propagate the states forward from the 'fusion time horizon' to current time using the buffered IMU data. The time constant for this filter is controlled by the EKF2_TAU_VEL and EKF2_TAU_POS parameters.\n\nThe position and velocity states are adjusted to account for the offset between the IMU and the body frame before they are output to the control loops. The position of the IMU relative to the body frame is set by the parameters.\n\nThe EKF uses the IMU data for state prediction only. IMU data is not used as an observation in the EKF derivation. The algebraic equations for the covariance prediction, state update and covariance update were derived using the Matlab symbolic toolbox and can be found here: Matlab Symbolic Derivation (opens new window).\n\nThe default behaviour is to run a single instance of the EKF. In this case sensor selection and failover is performed before data is received by the EKF. This provides protection against a limited number of sensor faults, such as loss of data, but does not protect against the sensor providing inaccurate data that exceeds the ability of the EKF and control loops to compensate.\n\nThe parameter settings for running a single EKF instance are:\n\nDepending on the number of IMUs and magnetometers and the autopilot's CPU capacity, multiple instances of the EKF can be run. This provides protection against a wider range of sensor errors and is achieved by each EKF instance using a different sensor combination. By comparing the internal consistency of each EKF instance, the EKF selector is able to determine the EKF and sensor combination with the best data consistency. This enables faults such as sudden changes in IMU bias, saturation or stuck data to be detected and isolated.\n\nThe total number of EKF instances is the product of the number of IMU's and number of magnetometers selected by EKF2_MULTI_IMU and EKF2_MULTI_MAG and is given by the following formula:\n\nFor example an autopilot with 2 IMUs and 2 magnetometers could run with EKF2_MULTI_IMU = 2 and EKF2_MULTI_MAG = 2 for a total of 4 EKF instances where each instance uses the following combination of sensors:\n\nThe maximum number of IMU or magnetometer sensors that can be handled is 4 of each for a theoretical maximum of 4 x 4 = 16 EKF instances. In practice this is limited by available computing resources. During development of this feature, testing with STM32F7 CPU based HW demonstrated 4 EKF instances with acceptable processing load and memory utilisation margin.\n\nIf EKF2_MULTI_IMU >= 3, then the failover time for large rate gyro errors is further reduced because the EKF selector is able to apply a median select strategy for faster isolation of the faulty IMU.\n\nThe setup for multiple EKF instances is controlled by the following parameters:\n• None SENS_IMU_MODE: Set to 0 if running multiple EKF instances with IMU sensor diversity, ie EKF2_MULTI_IMU > 1. When set to 1 (default for single EKF operation) the sensor module selects IMU data used by the EKF. This provides protection against loss of data from the sensor but does not protect against bad sensor data. When set to 0, the sensor module does not make a selection.\n• None SENS_MAG_MODE: Set to 0 if running multiple EKF instances with magnetometer sensor diversity, ie EKF2_MULTI_MAG > 1. When set to 1 (default for single EKF operation) the sensor module selects Magnetometer data used by the EKF. This provides protection against loss of data from the sensor but does not protect against bad sensor data. When set to 0, the sensor module does not make a selection.\n• None EKF2_MULTI_IMU: This parameter specifies the number of IMU sensors used by the multiple EKF's. If <= 1, then only the first IMU sensor will be used. When SENS_IMU_MODE = 1, this will be the sensor selected by the sensor module. If >= 2, then a separate EKF instance will run for the specified number of IMU sensors up to the lesser of 4 or the number of IMU's present.\n• None EKF2_MULTI_MAG: This parameter specifies the number of magnetometer sensors used by the multiple EKF's. If <= 1, then only the first magnetometer sensor will be used. When SENS_MAG_MODE = 1, this will be the sensor selected by the sensor module. If >= 2, then a separate EKF instance will run for the specified number of magnetometer sensors up to the lesser of 4 or the number of magnetometers present.\n\n# What sensor measurements does it use?\n\nThe EKF has different modes of operation that allow for different combinations of sensor measurements. On start-up the filter checks for a minimum viable combination of sensors and after initial tilt, yaw and height alignment is completed, enters a mode that provides rotation, vertical velocity, vertical position, IMU delta angle bias and IMU delta velocity bias estimates.\n\nThis mode requires IMU data, a source of yaw (magnetometer or external vision) and a source of height data. This minimum data set is required for all EKF modes of operation. Other sensor data can then be used to estimate additional states.\n• Three axis body fixed Inertial Measurement unit delta angle and delta velocity data at a minimum rate of 100Hz. Note: Coning corrections should be applied to the IMU delta angle data before it is used by the EKF.\n\nThree axis body fixed magnetometer data (or external vision system pose data) at a minimum rate of 5Hz is required. Magnetometer data can be used in two ways:\n• Magnetometer measurements are converted to a yaw angle using the tilt estimate and magnetic declination. This yaw angle is then used as an observation by the EKF. This method is less accurate and does not allow for learning of body frame field offsets, however it is more robust to magnetic anomalies and large start-up gyro biases. It is the default method used during start-up and on ground.\n• The XYZ magnetometer readings are used as separate observations. This method is more accurate and allows body frame offsets to be learned, but assumes the earth magnetic field environment only changes slowly and performs less well when there are significant external magnetic anomalies.\n\nThe logic used to select these modes is set by the EKF2_MAG_TYPE parameter.\n\nThe option is available to operate without a magnetometer, either by replacing it using yaw from a dual antenna GPS or using the IMU measurements and GPS velocity data to estimate yaw from vehicle movement.\n\nA source of height data - either GPS, barometric pressure, range finder or external vision at a minimum rate of 5Hz is required.\n\nIf these measurements are not present, the EKF will not start. When these measurements have been detected, the EKF will initialise the states and complete the tilt and yaw alignment. When tilt and yaw alignment is complete, the EKF can then transition to other modes of operation enabling use of additional sensor data:\n\nBarometric pressure altitude is subject to errors generated by aerodynamic disturbances caused by vehicle wind relative velocity and orientation. This is known in aeronautics as static pressure position error. The EKF2 module that uses the ECL/EKF2 estimator library provides a method of compensating for these errors, provided wind speed state estimation is active.\n\nFor platforms operating in a fixed wing mode, wind speed state estimation requires either Airspeed and/or Synthetic Sideslip fusion to be enabled.\n\nFor multi-rotors, fusion of Drag Specific Forces can be enabled and tuned to provide the required wind velocity state estimates.\n\nThe EKF2 module models the error as a body fixed ellipsoid that specifies the fraction of dynamic pressure that is added to/subtracted from the barometric pressure - before it is converted to a height estimate. See the following parameter documentation for information on how to use this feature:\n\nGPS measurements will be used for position and velocity if the following conditions are met:\n• GPS use is enabled via setting of the EKF2_AID_MASK parameter.\n• GPS quality checks have passed. These checks are controlled by the EKF2_GPS_CHECK and parameters.\n• GPS height can be used directly by the EKF via setting of the EKF2_HGT_MODE parameter.\n\nSome GPS receivers such as the Trimble MB-Two RTK GPS receiver (opens new window) can be used to provide a heading measurement that replaces the use of magnetometer data. This can be a significant advantage when operating in an environment where large magnetic anomalies are present, or at latitudes here the earth's magnetic field has a high inclination. Use of GPS yaw measurements is enabled by setting bit position 7 to 1 (adding 128) in the EKF2_AID_MASK parameter.\n\nThe EKF runs an additional multi-hypothesis filter internally that uses multiple 3-state Extended Kalman Filters (EKF's) whose states are NE velocity and yaw angle. These individual yaw angle estimates are then combined using a Gaussian Sum Filter (GSF). The individual 3-state EKF's use IMU and GPS horizontal velocity data (plus optional airspeed data) and do not rely on any prior knowledge of the yaw angle or magnetometer measurements. This provides a backup to the yaw from the main filter and is used to reset the yaw for the main 24-state EKF when a post-takeoff loss of navigation indicates that the yaw estimate from the magnetometer is bad. This will result in an message information message at the GCS.\n\nData from this estimator is logged when ekf2 replay logging is enabled and can be viewed in the message. The individual yaw estimates from the individual 3-state EKF yaw estimators are in the fields. The GSF combined yaw estimate is in the field. The variance for the GSF yaw estimate is in the field. All angles are in radians. Weightings applied by the GSF to the individual 3-state EKF outputs are in the fields.\n\nThis also makes it possible to operate without any magnetometer data or dual antenna GPS receiver for yaw provided some horizontal movement after takeoff can be performed to enable the yaw to become observable. To use this feature, set EKF2_MAG_TYPE to (5) to disable magnetometer use. Once the vehicle has performed sufficient horizontal movement to make the yaw observable, the main 24-state EKF will align it's yaw to the GSF estimate and commence use of GPS.\n\nData from GPS receivers can be blended using an algorithm that weights data based on reported accuracy (this works best if both receivers output data at the same rate and use the same accuracy). The mechanism also provides automatic failover if data from a receiver is lost (it allows, for example, a standard GPS to be used as a backup to a more accurate RTK receiver). This is controlled by the SENS_GPS_MASK parameter.\n\nThe SENS_GPS_MASK parameter is set by default to disable blending and always use the first receiver, so it will have to be set to select which receiver accuracy metrics are used to decide how much each receiver output contributes to the blended solution. Where different receiver models are used, it is important that the SENS_GPS_MASK parameter is set to a value that uses accuracy metrics that are supported by both receivers. For example do not set bit position 0 to unless the drivers for both receivers publish values in the field of the message that are comparable. This can be difficult with receivers from different manufacturers due to the different way that accuracy is defined, e.g. CEP vs 1-sigma, etc.\n\nThe following items should be checked during setup:\n• Verify that data for the second receiver is present. This will be logged as and can also be checked when connected via the nsh console using the command . The GPS_2_CONFIG parameter will need to be set correctly.\n• Check the , and data from each receiver and decide which accuracy metrics can be used. If both receivers output sensible and data, and GPS vertical position is not being used directly for navigation, then setting SENS_GPS_MASK to 3 is recommended. Where only data is available and both receivers do not output data, set SENS_GPS_MASK to 2. Bit position 2 would only be set if the GPS had been selected as a primary height source with the EKF2_HGT_MODE parameter and both receivers output sensible data.\n• The output from the blended receiver data is logged as , and can be checked whilst connect via the nsh terminal using the command .\n• Where receivers output at different rates, the blended output will be at the rate of slower receiver. Where possible receivers should be configured to output at the same rate.\n\nFor the ECL to accept GNSS data for navigation, certain minimum requirements need to be satisfied over a period of time, defined by EKF2_REQ_GPS_H (10 seconds by default).\n\nMinima are defined in the EKF2_REQ_* parameters and each check can be en-/disabled using the EKF2_GPS_CHECK parameter.\n\nThe table below shows the different metrics directly reported or calculated from the GNSS data, and the minimum required values for the data to be used by ECL. In addition, the Average Value column shows typical values that might reasonably be obtained from a standard GNSS module (e.g. u-blox M8 series) - i.e. values that are considered good/acceptable.\n\nRange finder distance to ground is used by a single state filter to estimate the vertical position of the terrain relative to the height datum.\n\nIf operating over a flat surface that can be used as a zero height datum, the range finder data can also be used directly by the EKF to estimate height by setting the EKF2_HGT_MODE parameter to 2.\n\nEquivalent Airspeed (EAS) data can be used to estimate wind velocity and reduce drift when GPS is lost by setting EKF2_ARSP_THR to a positive value. Airspeed data will be used when it exceeds the threshold set by a positive value for EKF2_ARSP_THR and the vehicle type is not rotary wing.\n\nFixed wing platforms can take advantage of an assumed sideslip observation of zero to improve wind speed estimation and also enable wind speed estimation without an airspeed sensor. This is enabled by setting the EKF2_FUSE_BETA parameter to 1.\n\nMulti-rotor platforms can take advantage of the relationship between airspeed and drag force along the X and Y body axes to estimate North/East components of wind velocity. This is enabled by setting bit position 5 in the EKF2_AID_MASK parameter to true. The relationship between airspeed and specific force (IMU acceleration) along the X and Y body axes is controlled by the EKF2_BCOEF_X and EKF2_BCOEF_Y parameters which set the ballistic coefficients for flight in the X and Y directions respectively. The amount of specific force observation noise is set by the EKF2_DRAG_NOISE parameter.\n\nThese can be tuned by flying the vehicle in Position mode repeatedly forwards/backwards between rest and maximum speed, adjusting EKF2_BCOEF_X so that the corresponding innovation sequence in the log message is minimised. This is then repeated for right/left movement with adjustment of EKF2_BCOEF_Y to minimise the innovation sequence. Tuning is easier if this testing is conducted in still conditions.\n\nIf you are able to log data without dropouts from boot using SDLOG_MODE = 1 and SDLOG_PROFILE = 2, have access to the development environment, and are able to build code, then we recommended you fly once and perform the tuning via EKF2 Replay of the flight log.\n\nOptical flow data will be used if the following conditions are met:\n• Bit position 1 in the EKF2_AID_MASK parameter is true.\n• The quality metric returned by the flow sensor is greater than the minimum requirement set by the EKF2_OF_QMIN parameter.\n\nPosition, velocity or orientation measurements from an external vision system, e.g. Vicon, can be used:\n• External vision system horizontal position data will be used if bit position 3 in the EKF2_AID_MASK parameter is true.\n• External vision system vertical position data will be used if the EKF2_HGT_MODE parameter is set to 3.\n• External vision system velocity data will be used if bit position 8 in the EKF2_AID_MASK parameter is true.\n• External vision system orientation data will be used for yaw estimation if bit position 4 in the EKF2_AID_MASK parameter is true.\n• External vision reference frame offset will be estimated and used to rotate the external vision system data if bit position 6 in the EKF2_AID_MASK parameter is true.\n\nEither bit 4 ( ) or bit 6 ( ) should be set to true, but not both together. Following EKF2_AID_MASK values are supported when using with an external vision system.\n\nThe EKF considers uncertainty in the visual pose estimate. This uncertainty information can be sent via the covariance fields in the MAVLink ODOMETRY (opens new window) message or it can be set through the parameters EKF2_EVP_NOISE, EKF2_EVV_NOISE and EKF2_EVA_NOISE. You can choose the source of the uncertainty with EKF2_EV_NOISE_MD.\n\n# How do I use the 'ecl' library EKF?\n\nSet the SYS_MC_EST_GROUP parameter to 2 to use the ecl EKF.\n\n# What are the advantages and disadvantages of the ecl EKF over other estimators?\n\nLike all estimators, much of the performance comes from the tuning to match sensor characteristics. Tuning is a compromise between accuracy and robustness and although we have attempted to provide a tune that meets the needs of most users, there will be applications where tuning changes are required.\n\nFor this reason, no claims for accuracy relative to the legacy combination of + have been made and the best choice of estimator will depend on the application and tuning.\n• The ecl EKF is a complex algorithm that requires a good understanding of extended Kalman filter theory and its application to navigation problems to tune successfully. It is therefore more difficult for users that are not achieving good results to know what to change.\n• The ecl EKF uses more RAM and flash space.\n• The ecl EKF uses more logging space.\n• The ecl EKF is able to fuse data from sensors with different time delays and data rates in a mathematically consistent way which improves accuracy during dynamic maneuvers once time delay parameters are set correctly.\n• The ecl EKF is capable of fusing a large range of different sensor types.\n• The ecl EKF detects and reports statistically significant inconsistencies in sensor data, assisting with diagnosis of sensor errors.\n• For fixed wing operation, the ecl EKF estimates wind speed with or without an airspeed sensor and is able to use the estimated wind in combination with airspeed measurements and sideslip assumptions to extend the dead-reckoning time available if GPS is lost in flight.\n• The ecl EKF estimates 3-axis accelerometer bias which improves accuracy for tailsitters and other vehicles that experience large attitude changes between flight phases.\n• The federated architecture (combined attitude and position/velocity estimation) means that attitude estimation benefits from all sensor measurements. This should provide the potential for improved attitude estimation if tuned correctly.\n\n# How do I check the EKF performance?\n\nEKF outputs, states and status data are published to a number of uORB topics which are logged to the SD card during flight. The following guide assumes that data has been logged using the .ulog file format. The .ulog format data can be parsed in python by using the PX4 pyulog library (opens new window).\n\nMost of the EKF data is found in the estimator_innovations (opens new window) and estimator_status (opens new window) uORB messages that are logged to the .ulog file.\n\nA python script that automatically generates analysis plots and metadata can be found here (opens new window). To use this script file, cd to the directory and enter . This saves performance metadata in a csv file named <log_file>.mdat.csv and plots in a pdf file named .\n\nMultiple log files in a directory can be analysed using the batch_process_logdata_ekf.py (opens new window) script. When this has been done, the performance metadata files can be processed to provide a statistical assessment of the estimator performance across the population of logs using the batch_process_metadata_ekf.py (opens new window) script.\n• Attitude output data is found in the vehicle_attitude message.\n• Local position output data is found in the vehicle_local_position message.\n• Global (WGS-84) output data is found in the vehicle_global_position message.\n• Wind velocity output data is found in the wind_estimate message.\n\nRefer to states[32] in estimator_status (opens new window). The index map for states[32] is as follows:\n\nRefer to covariances[28] in estimator_status (opens new window). The index map for covariances[28] is as follows:\n\nThe observation , , and message fields are defined in estimator_innovations.msg (opens new window). The messages all have the same field names/types (but different units).\n\nSome of the observations are:\n\nIn addition, each sensor has its own fields for horizontal and vertical position and/or velocity values (where appropriate). These are largely self documenting, and are reproduced below:\n\nThe output complementary filter is used to propagate states forward from the fusion time horizon to current time. To check the magnitude of the angular, velocity and position tracking errors measured at the fusion time horizon, refer to in the message.\n\nThe index map is as follows:\n• [1] Velocity tracking error magnitude (m/s). The velocity tracking time constant can be adjusted using the EKF2_TAU_VEL parameter. Reducing this parameter reduces steady state errors but increases the amount of observation noise on the NED velocity outputs.\n• [2] Position tracking error magnitude (m). The position tracking time constant can be adjusted using the EKF2_TAU_POS parameter. Reducing this parameter reduces steady state errors but increases the amount of observation noise on the NED position outputs.\n\nThe EKF contains internal error checking for badly conditioned state and covariance updates. Refer to the filter_fault_flags in estimator_status (opens new window).\n\nThere are two categories of observation faults:\n• Loss of data. An example of this is a range finder failing to provide a return.\n• The innovation, which is the difference between the state prediction and sensor observation is excessive. An example of this is excessive vibration causing a large vertical position error, resulting in the barometer height measurement being rejected.\n\nBoth of these can result in observation data being rejected for long enough to cause the EKF to attempt a reset of the states using the sensor observations. All observations have a statistical confidence checks applied to the innovations. The number of standard deviations for the check are controlled by the parameter for each observation type.\n\nTest levels are available in estimator_status (opens new window) as follows:\n• : ratio of the largest magnetometer innovation component to the innovation test limit\n• : ratio of the largest velocity innovation component to the innovation test limit\n• : ratio of the largest horizontal position innovation component to the innovation test limit\n• : ratio of the vertical position innovation to the innovation test limit\n• : ratio of the true airspeed innovation to the innovation test limit\n• : ratio of the height above ground innovation to the innovation test limit\n\nFor a binary pass/fail summary for each sensor, refer to innovation_check_flags in estimator_status (opens new window).\n\nThe EKF applies a number of GPS quality checks before commencing GPS aiding. These checks are controlled by the EKF2_GPS_CHECK and parameters. The pass/fail status for these checks is logged in the estimator_status (opens new window).gps_check_fail_flags message. This integer will be zero when all required GPS checks have passed. If the EKF is not commencing GPS alignment, check the value of the integer against the bitmask definition in estimator_status (opens new window).\n\nThe EKF uses single precision floating point operations for all of its computations and first order approximations for derivation of the covariance prediction and update equations in order to reduce processing requirements. This means that it is possible when re-tuning the EKF to encounter conditions where the covariance matrix operations become badly conditioned enough to cause divergence or significant errors in the state estimates.\n\nTo prevent this, every covariance and state update step contains the following error detection and correction steps:\n• If the innovation variance is less than the observation variance (this requires a negative state variance which is impossible) or the covariance update will produce a negative variance for any of the states, then:\n• The state and covariance update is skipped\n• The corresponding rows and columns in the covariance matrix are reset\n• The failure is recorded in the estimator_status filter_fault_flags message\n• State variances (diagonals in the covariance matrix) are constrained to be non-negative.\n• An upper limit is applied to state variances.\n• Symmetry is forced on the covariance matrix.\n\nAfter re-tuning the filter, particularly re-tuning that involve reducing the noise variables, the value of should be checked to ensure that it remains zero.\n\n# What should I do if the height estimate is diverging?\n\nThe most common cause of EKF height diverging away from GPS and altimeter measurements during flight is clipping and/or aliasing of the IMU measurements caused by vibration. If this is occurring, then the following signs should be evident in the data\n• estimator_innovations .vel_pos_innov[2] and estimator_innovations .vel_pos_innov[5] will both have the same sign.\n• estimator_status .hgt_test_ratio will be greater than 1.0\n\nThe recommended first step is to ensure that the autopilot is isolated from the airframe using an effective isolation mounting system. An isolation mount has 6 degrees of freedom, and therefore 6 resonant frequencies. As a general rule, the 6 resonant frequencies of the autopilot on the isolation mount should be above 25Hz to avoid interaction with the autopilot dynamics and below the frequency of the motors.\n\nAn isolation mount can make vibration worse if the resonant frequencies coincide with motor or propeller blade passage frequencies.\n\nThe EKF can be made more resistant to vibration induced height divergence by making the following parameter changes:\n• Double the value of the innovation gate for the primary height sensor. If using barometric height this is EKF2_BARO_GATE.\n• Increase the value of EKF2_ACC_NOISE to 0.5 initially. If divergence is still occurring, increase in further increments of 0.1 but do not go above 1.0\n\nNote that the effect of these changes will make the EKF more sensitive to errors in GPS vertical velocity and barometric pressure.\n\n# What should I do if the position estimate is diverging?\n\nThe most common causes of position divergence are:\n• High vibration levels.\n• Fix by improving mechanical isolation of the autopilot.\n• Increasing the value of EKF2_ACC_NOISE and EKF2_GYR_NOISE can help, but does make the EKF more vulnerable to GPS glitches.\n• Large gyro bias offsets.\n• Fix by re-calibrating the gyro. Check for excessive temperature sensitivity (> 3 deg/sec bias change during warm-up from a cold start and replace the sensor if affected of insulate to slow the rate of temperature change.\n• Bad yaw alignment\n• Check the heading shown QGC is within 15 deg truth\n\nDetermining which of these is the primary cause requires a methodical approach to analysis of the EKF log data:\n\nDuring normal operation, all the test ratios should remain below 0.5 with only occasional spikes above this as shown in the example below from a successful flight:\n\nThe following plot shows the EKF vibration metrics for a multirotor with good isolation. The landing shock and the increased vibration during takeoff and landing can be seen. Insufficient data has been gathered with these metrics to provide specific advice on maximum thresholds.\n\nThe above vibration metrics are of limited value as the presence of vibration at a frequency close to the IMU sampling frequency (1 kHz for most boards) will cause offsets to appear in the data that do not show up in the high frequency vibration metrics. The only way to detect aliasing errors is in their effect on inertial navigation accuracy and the rise in innovation levels.\n\nIn addition to generating large position and velocity test ratios of > 1.0, the different error mechanisms affect the other test ratios in different ways:\n\nHigh vibration levels normally affect vertical position and velocity innovations as well as the horizontal components. Magnetometer test levels are only affected to a small extent.\n\nLarge gyro bias offsets are normally characterised by a change in the value of delta angle bias greater than 5E-4 during flight (equivalent to ~3 deg/sec) and can also cause a large increase in the magnetometer test ratio if the yaw axis is affected. Height is normally unaffected other than extreme cases. Switch on bias value of up to 5 deg/sec can be tolerated provided the filter is given time settle before flying. Pre-flight checks performed by the commander should prevent arming if the position is diverging.\n\nBad yaw alignment causes a velocity test ratio that increases rapidly when the vehicle starts moving due inconsistency in the direction of velocity calculated by the inertial nav and the GPS measurement. Magnetometer innovations are slightly affected. Height is normally unaffected.\n\nPoor GPS accuracy is normally accompanied by a rise in the reported velocity error of the receiver in conjunction with a rise in innovations. Transient errors due to multipath, obscuration and interference are more common causes. Here is an example of a temporary loss of GPS accuracy where the multi-rotor started drifting away from its loiter location and had to be corrected using the sticks. The rise in estimator_status (opens new window).vel_test_ratio to greater than 1 indicates the GPs velocity was inconsistent with other measurements and has been rejected.\n\nThis is accompanied with rise in the GPS receivers reported velocity accuracy which indicates that it was likely a GPS error.\n\nIf we also look at the GPS horizontal velocity innovations and innovation variances, we can see the large spike in North velocity innovation that accompanies this GPS 'glitch' event.\n\nLoss of GPS data will be shown by the velocity and position innovation test ratios 'flat-lining'. If this occurs, check the other GPS status data in for further information.\n\nThe following plot shows the NED GPS velocity innovations , the GPS NE position innovations and the Baro vertical position innovation generated from a simulated VTOL flight using SITL Gazebo.\n\nThe simulated GPS was made to lose lock at 73 seconds. Note the NED velocity innovations and NE position innovations 'flat-line' after GPS is lost. Note that after 10 seconds without GPS data, the EKF reverts back to a static position mode using the last known position and the NE position innovations start to change again.\n\nIf the vehicle has the tendency during landing to climb back into the air when close to the ground, the most likely cause is barometer ground effect.\n\nThis is caused when air pushed down by the propellers hits the ground and creates a high pressure zone below the drone. The result is a lower reading of pressure altitude, leading to an unwanted climb being commanded. The figure below shows a typical situation where the ground effect is present. Note how the barometer signal dips at the beginning and end of the flight.\n\nYou can enable ground effect compensation to fix this problem:\n• From the plot estimate the magnitude of the barometer dip during takeoff or landing. In the plot above one can read a barometer dip of about 6 meters during landing.\n• Then set the parameter EKF2_GND_EFF_DZ to that value and add a 10 percent margin. Therefore, in this case a value of 6.6 meters would be a good starting point.\n\nIf a terrain estimate is available (e.g. the vehicle is equipped with a range finder) then you can additionally specify EKF2_GND_MAX_HGT, the above ground-level altitude below which ground effect compensation should be activated. If no terrain estimate is available this parameter will have no effect and the system will use heuristics to determine if ground effect compensation should be activated.\n• PX4 State Estimation Overview , PX4 Developer Summit 2019, Dr. Paul Riseborough): Overview of the estimator, and major changes from 2018/19, and the expected improvements through 2019/20."
    },
    {
        "link": "https://discuss.px4.io/t/input-output-update-frequencies-between-flightcontroller-and-sensors-actors/1134",
        "document": "How to get information about the update Frequencies between the flight controlling uC and the sensors/actors?\n\nHi there! I am having a hard time to find any documentation about how frequently px4 requests information from its sensors.\n\n I also cloned the repository GitHub - PX4/PX4-Autopilot: PX4 Autopilot Software and tried to understand the firmware enough to ‘grep’ through the source to find the update rates. I always end up in a dead end after passing some macros leading to an _IOC instruction with a hard-coded memory address without any comment about what’s behind the address.\n\n I can not believe, I am the only person who is interested in this very important part of PX4s system design, what information did I overlook?\n\nCan anybody give me a hint that helps me to find the update rates? I am especially interested in:\n\nGPS update rate?\n\n IMU(s) update rate?\n\n ESC signal update rate? (I have often read that it is configurable 50-400Hz and default is 400Hz)\n\n Magnetometer update rate?\n\n Barometer update rate?\n\nAlso this thread did not help me very much: IMU publish rate on Snapdragon board\n\nThank You for your help"
    },
    {
        "link": "https://docs.px4.io/main/en/config/firmware.html",
        "document": "QGroundControl desktop versions can be used to install PX4 firmware onto Pixhawk-series flight-controller boards.\n\nBefore you start installing Firmware all USB connections to the vehicle must be disconnected (both direct or through a telemetry radio). The vehicle must not be powered by a battery.\n\nGenerally you should use the most recent released version of PX4, in order to benefit from bug fixes and get the latest and greatest features.\n• None Connect the flight controller directly to your computer via USB. Connect directly to a powered USB port on your machine (do not connect through a USB hub).\n• None Select the PX4 Pro Stable Release vX.x.x option to install the latest stable version of PX4 for your flight controller (autodetected).\n• None Click the OK button to start the update. The firmware will then proceed through a number of upgrade steps (downloading new firmware, erasing old firmware etc.). Each step is printed to the screen and overall progress is displayed on a progress bar. Once the firmware has completed loading, the device/vehicle will reboot and reconnect. If QGroundControl installs the FMUv2 target (see console during installation) and you have a newer board, you may need to update the bootloader in order to access all the memory on your flight controller.\n\nNext you will need to specify the vehicle airframe (and then sensors, radio, etc.)\n\nTo install a different version of PX4:\n• Connect the vehicle as above, and select PX4 Pro Stable Release vX.x.x.\n• Check Advanced settings and select the version from the dropdown list:\n• Standard Version (stable): The default version (i.e. no need to use advanced settings to install this!)\n• Beta Testing (beta): A beta/candidate release. Only available when a new release is being prepared.\n• Custom Firmware file...: A custom firmware file (e.g. that you have built locally). If you select this you will have to choose the custom firmware from the file system in the next step.\n\nFirmware update then continues as before.\n\nPixhawk hardware usually comes with an appropriate bootloader version pre-installed.\n\nA case where you may need to update is newer Pixhawk boards that install FMUv2 firmware. If QGroundControl installs the FMUv2 target (see console during installation), and you have a newer board, you may need to update the bootloader in order to access all the memory on your flight controller.\n\nYou can update it by following the instructions in Bootloader update > FMUv2 Bootloader Update."
    },
    {
        "link": "https://discuss.px4.io/t/px4-sync-q-a-sep-18-2024/40762",
        "document": "High Level About this Pull Request ============================= As previously… discussed with @dagar, this pull request seeks to further couple the relationship between the PX4 flight controller and [Vertiq modules](https://www.vertiq.co/). At its core, this PR introduces the IQUART serial protocol into PX4, and in doing so provides the flight controller with the ability to control and configure connected Vertiq modules IQUART and its Clients ------------------------- The IQUART serial protocol is built around its ability to communicate with a series of Clients and Entries available on Vertiq modules. All [IQUART messages](https://iqmotion.readthedocs.io/en/latest/intro.html) specify a target module ID, type ID, and type sub-ID. Type IDs refer to unique identification values given to each different IQUART client. Sub-IDs refer to specific entries within the client. For example, the Serial Interface Client (type ID 16) provides one entry with sub-ID 0. ![Screenshot 2024-03-07 125725](https://github.com/PX4/PX4-Autopilot/assets/120586722/6da96606-215f-450e-a10f-104fb8414fbd) A key portion of this PR is the inclusion of [Vertiq’s C++ library](https://github.com/iq-motion-control/iq-module-communication-cpp) as a git submodule. The library provides a C++ representation of all possible Veritq clients as well as functions for packaging proper IQUART messages. What We’ve Added to PX4 ================== Basic User Interface ------------------------ The following examples are performed using a Pixhawk 6c using the Generic Quadcopter airframe. These serve to help in understanding the structure of the backend Vertiq support. Boardconfig Options **************************** ![Screenshot 2024-03-07 143926](https://github.com/PX4/PX4-Autopilot/assets/120586722/b16453d5-8f19-418b-8552-178ca443c01b) ![Screenshot 2024-03-07 143942](https://github.com/PX4/PX4-Autopilot/assets/120586722/c8ec0d1c-0531-4793-a254-18d5317f0b59) ![Screenshot 2024-03-07 143954](https://github.com/PX4/PX4-Autopilot/assets/120586722/ed5900ee-1796-466b-97e8-3191d7d198b6) - Vertiq IO Provides access to basic Vertiq module configuration through PX4 parameters. This configuration alone is not enough for flight through the IQUART protocol, but could be helpful in configuration where other protocols, such as DroneCAN, are being used to send throttle commands. - Include IFCI Configuration Parameters Provides access to parameters specific to the IQUART Flight Controller Interface. Enabling this configuration allows users to control a vehicle and receive telemetry from Vertiq modules through the serial port configured to vertiq_io. - Include Pulsing Module Configuration Parameters Provides access to specialized parameters available only for “pulsing modules.” These are modules equipped with specialized Vertiq firmware and our [Vertiq UP12 propeller](https://www.vertiq.co/up12). Configuration with QGroundControl ******************************************************* At the moment, the easiest way for users to interact with and configure our modules is through Vertiq’s [IQ Control Center software](https://github.com/iq-motion-control/iq-control-center). As you can imagine, having to unplug serial connections from PX4 and reconnect them to the Control Center is a laborious process. While users could add an extra serial connection to use serial passthrough, this is not always possible. Therefore, by providing module configuration functionality directly to the flight controller, we make our users’ lives much easier. ![Screenshot 2024-03-07 145720](https://github.com/PX4/PX4-Autopilot/assets/120586722/b1f1c739-0dbc-4090-968b-1848dced63c3) After selecting a serial port ![Screenshot 2024-03-07 145812](https://github.com/PX4/PX4-Autopilot/assets/120586722/a75c649e-688a-449c-8206-7afafb1b0783) When the matching baud rate is set, we see the module with the matching Module ID to TARGET_MODULE_ID’s parameters appear. With this configuration, those parameters are MAX_VELOCITY, MAX_VOLTS, CONTROL_MODE, THROTTLE_CVI, VERTIQ_FC_DIR, and VERTIQ_MOTOR_DIR. The parameters that change based on the value of TARGET_MODULE_ID are those managed by the Vertiq Configuration Handler class. Target Module ID 0 ![Screenshot 2024-03-07 151858](https://github.com/PX4/PX4-Autopilot/assets/120586722/616a982e-da7a-4301-9d8e-e30033e35894) Target Module ID 1 ![Screenshot 2024-03-07 152106](https://github.com/PX4/PX4-Autopilot/assets/120586722/949deb91-e9fe-4f7a-b568-07189fd3abf8) I did not change any values besides the TARGET_MODULE_ID, and you can see that the other Vertiq parameters were updated with values gotten from the module with ID 1. Code Structure ------------------------ ![image](https://github.com/PX4/PX4-Autopilot/assets/120586722/cfacd017-166d-4fc3-99da-ac517d287250) Class Descriptions ************************* Vertiq IO - Responsible for spawning our task, and contains our run() - Contains our updateOutputs function for motor control - Contains 3 Vertiq Clients used as part of motor control: a Propeller Motor Control Client, an Arming Handler Client, and an IFCI - Client all set to broadcast to all connected modules - Creates and updates all other objects used in the module Vertiq Serial Interface - Responsible for configuring the selected hardware serial port - Responsible for reading data from the serial peripheral and passes it to the active Vertiq clients - Responsible for taking data written by the active Vertiq clients, and writing out data to the serial peripheral Vertiq Client Manager - Can be given new Vertiq clients of any type to manage by any external object - Manages a list of clients up to a predefined maximum amount - Handles client communication by periodically telling the serial interface to transmit queued messages and to have each client process received data Vertiq Configuration Handler - Responsible for maintaining any Vertiq client objects which are created and destroyed as TARGET_MODULE_ID changes - Responsible for managing a list of EntryWrapper objects EntryWrappers are used to link together a PX4 parameter and a Vertiq Client’s Entry, and are covered in more detail later Vertiq Telemetry Manager - Responsible for maintaining an IQUART Flight Controller Interface client which gets created and destroyed as the Module ID for telemetry changes - Responsible for generating the correct Module ID for the next module whose telemetry we want - Responsible for publishing to the esc_status uORB topic the data received from modules About EntryWrapper Objects ************************************** As mentioned above, an EntryWrapper is an object meant to connect a PX4 parameter with a Vertiq Client Entry. The goal is to ensure that when an EntryWrapper’s PX4 parameter changes, that the same change is reflected on the connected motor with the module ID TARGET_MODULE_ID. The process for updating EntryWrappers is described by the following diagrams. The top describes what happens at a higher level when any Vertiq parameter is changed, and the bottom describes the decisions made by the EntryWrapper itself during its update. High Level [<img src=\"https://github.com/PX4/PX4-Autopilot/assets/120586722/d5fb4044-4cfc-4c3d-9603-46bef27939ea\" width=\"300\"/>](https://github.com/PX4/PX4-Autopilot/assets/120586722/d5fb4044-4cfc-4c3d-9603-46bef27939ea) Entry Wrapper [<img src=\"https://github.com/PX4/PX4-Autopilot/assets/120586722/140ea73c-4ec3-4249-80bc-6db74f6bf64e\" width =\"300\"/>](https://github.com/PX4/PX4-Autopilot/assets/120586722/140ea73c-4ec3-4249-80bc-6db74f6bf64e) Parameters ------------------- Different PX4 parameters become available depending on the build configuration set at the kconfig level. Any configuration listed also includes all parameters available in the configuration above it. Vertiq IO Enabled ************************ - VERTIQ_IO_CFG The serial port mapped to our module - VERTIQ_BAUD The baud rate to use on the serial port we open and manage - TARGET_MODULE_ID This is the module ID of the module that you would like to communicate with at the parameter level. All clients in the Vertiq Configuration Handler will be deleted and recreated with this module ID in their reinitialization - TRIGGER_READ A boolean parameter that allows you to refresh responses from the module with module ID TARGET_MODULE_ID - CONTROL_MODE This parameter is part of an EntryWrapper. This means that it acts as both a PX4 parameter and a Vertiq Client Entry. Specifically, this parameter interacts with the mode entry in the [ESC Propeller Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#epip-message-table) - MAX_VELOCITY This parameter is part of an EntryWrapper that interacts with the velocity_max entry in the [ESC Propeller Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#epip-message-table) - MAX_VOLTS This parameter is part of an EntryWrapper that interacts with the volts_max entry in the [ESC Propeller Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#epip-message-table) - VERTIQ_MOTOR_DIR This parameter is part of an EntryWrapper that interacts with the sign entry in the [ESC Propeller Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#epip-message-table) - VERTIQ_FC_DIR This parameter is part of an EntryWrapper that interacts with the flip_negative entry in the [ESC Propeller Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#epip-message-table) IFCI Configuration Enabled *********************************** - VERTIQ_NUM_CVS The number of Control Values (discussed more [here](https://iqmotion.readthedocs.io/en/latest/manual/manual_ifci_control.html#iquart-flight-controller-interface)) that will be transmitted during each updateOutputs call - DISARM_TRIGGER This specifies the behavior to be used when the mixer disarms. The choices are enumerated as the following - USER_MIXER_VALUE Specifies that the output control values should match the value set as the mixer’s disarmed value for each ESC channel - TRIGGER_MOTOR_DISARM Sends an explicit disarm command to all connected motors - COAST_MOTOR Sends an explicit coast command to all connected motors. When coasted, Vertiq ESCs stop sending control voltages allowing the motor to spin freely - SEND_PREDEFINED_VELOCITY Sends an explicit [control velocity](https://iqmotion.readthedocs.io/en/latest/manual/manual_velocity_control_mechanisms.html#control-velocity) command to all connected motors - ARMING_BEHAVE This specifies the behavior to be used when the mixer arms. The choices are enumerated as the following - FORCE_ARMING Sends an explicit arm command to all connected motors - USE_MOTOR_ARMING Uses each of the connected modules’ [unique arming configurations](https://iqmotion.readthedocs.io/en/latest/manual/manual_advanced_arming.html) to decide its own behavior based on the output throttle - THROTTLE_CVI This parameter is part of an EntryWrapper that interacts with the throttle_cvi entry in the [IQUART Flight Controller Interface Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#ifci-message-table) - TELEM_IDS_1 This is a 32 bit bitmask with values 0-31 that allows users to easily select the module IDs from which they would like to receive telemetry. Combines with TELEM_IDS_2 to create a 64-bit bitmask of all possible Vertiq module IDs - TELEM_IDS_2 This is a 32 bit bitmask with values 32-62 that allows users to easily select the module IDs from which they would like to receive telemetry. Combines with TELEM_IDS_1 to create a 64-bit bitmask of all possible Vertiq module IDs Pulsing Configuration Enabled **************************************** - PULSE_VOLT_MODE This parameter is part of an EntryWrapper that interacts with the pulsing_voltage_mode entry in the [Pulsing Rectangular Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#prip-message-table) - PULSE_VOLT_LIMIT This parameter is part of an EntryWrapper that interacts with the pulsing_voltage_limit entry in the [Pulsing Rectangular Input Parser Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#prip-message-table) - X_CVI This parameter is part of an EntryWrapper that interacts with the x_cvi entry in the [IQUART Flight Controller Interface Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#ifci-message-table) - Y_CVI This parameter is part of an EntryWrapper that interacts with the y_cvi entry in the [IQUART Flight Controller Interface Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#ifci-message-table) - ZERO_ANGLE This parameter is part of an EntryWrapper that interacts with the zero_angle entry in the [Voltage Superposition Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#id350) - VELOCITY_CUTOFF This parameter is part of an EntryWrapper that interacts with the velocity_cutoff entry in the [Voltage Superposition Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#id350) - TORQUE_OFF_ANGLE This parameter is part of an EntryWrapper that interacts with the propeller_torque_offset_angle entry in the [Voltage Superposition Client](https://iqmotion.readthedocs.io/en/latest/modules/vertiq_2306_2200.html#id350) Telemetry ----------------- With IFCI enabled, telemetry is requested from the Module IDs specified in the TELEM_IDS_1/2 in a round robin fashion. The data returned are described in the following struct: ![image](https://github.com/PX4/PX4-Autopilot/assets/120586722/9d34648a-88a5-461c-801a-b763c81d0ce6) Using the response, we fill in the esc_status publication’s esc_rpm, esc_voltage, esc_current, esc_power, and esc_temperature. The esc_armed_flags and esc_online_flags are set high for each ESC after the first successfully received telemetry response from each expected motor. Non-Pulsing Flight Configuration Example with a Pixhawk 6c ========================================== In this example, our connected modules are set to a 921600 baud with module IDs 0, 26, 42, and 62 (configured using the [IQ Control Center software](https://github.com/iq-motion-control/iq-control-center)) 1. Run boardconfig in order to turn on Vertiq IO and IFCI Configuration 2. Build and flash the firmware 3. Select Generic Quadcopter airframe and run sensor calibration 4. Set the VERTIQ_IO_CFG to TELEM 2 for this example. Save and reboot 5. Set the VERTIQ_BAUD parameter to 921600, and reboot 6. Connect the 4 modules to the Pixhawk in this configuration ![image](https://github.com/PX4/PX4-Autopilot/assets/120586722/32cd55ea-3438-4e0c-8979-b6a9e3c0f430) 7. Set VERTIQ_NUM_CVS to 4, TELEM_IDS_1 check 0 and 26, TELEM_IDS_2 check 42 and 62, and reboot In this case, we have 4 modules connected, each of which supports only the Throttle Control Value. In order for each of the modules to receive their own unique throttle command, we must send 4 Control Values (CVs) 8. Set TARGET_MODULE_ID to 0, and set THROTTLE_CVI to 0, CONTROL_MODE to Voltage, and MAX_VOLTS to 12. Do the same to all MODULE_IDS where each CVI is one greater than the next (TARGET_MODULE_ID 26 should have THROTTLE_CVI 1) 9. Use the Identify & Assign Motors tool to configure the ESCs correctly for their position 10. Ensure that each VERTIQ_MOTOR_DIR is correct for the module’s vehicle position. If not, change it to either 2D Clockwise or 2D Counter Clockwise to make it correct 11. For this example, I want to use Send Explicit Disarm as DISARM_TRIGGER so that we can hear the disarming sound 12. Configure your Radio, and you are ready to fly Attached to this PR as well as below are a video of a hover flight as well as the log from it using the configuration described here. [vertiq_io_flight_sample.MOV](https://drive.google.com/file/d/1Bq7Sy9mv1MScE1xmjAtSksE275PnTUAN/view?usp=drive_link) [Link to Log](https://drive.google.com/file/d/13eH0guxELt_3NYcMXRza0fIbWoi-up3p/view?usp=sharing)"
    },
    {
        "link": "https://github.com/mavlink/qgroundcontrol/issues/11252",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://forum.modalai.com/topic/2305/sentinel-px4-firmware-update",
        "document": "I've got some Sentinels that have been sitting on a shelf since last fall that I'm trying to get up and running for indoor flight tests. I've been running into some errors when trying to arm them via qgroundcontrol. For reference these are running with the microhard carrier add-on and two pMDDL2450 radios to communicate back and forth.\n\nI'm unable to enable GPS even after updating the EKF2_AID_MASK parameter, I get frequent MAG#0 Timeout warnings and I have a pretty high loss rate over MAVLink. Also when the vehicles are ready to arm and I can get the motors to spin for a second and then some failsafe is enable that shuts everything down and forces the vehicle to reboot. When that happens I get the following logs in the QGC console:\n\nI also get the following error when navigating around the vehicle settings in QGC:\n\n\"Parameters are missing from firmware. You may be running a version of firmware which is not fully supported or your firmware has a bug in it. Missing paramsL 1:SDLOG_MODE\"\n\nI'm wondering if any of this has to do with the voxl-px4 firmware and whether updating it would help. These are running voxl-px4 version 1.4.16a. Is there a more recent firmware release that I can update to? Should I try flashing a system image update? Current system image is version 1.3.1"
    },
    {
        "link": "https://discuss.px4.io/t/increase-imu-sampling-rate-logging-rate/1417",
        "document": "I’m using Pixhawk with PX4. I’m looking for a way to increase the IMU sampling rate so that I can get better data in the log files.\n\nI couldn’t find any way to do this, especially using only the Pixhawk."
    },
    {
        "link": "https://discuss.px4.io/t/how-to-adjust-the-sample-rate-of-distance-sensor-rangefinder/30575",
        "document": "### Issue details I need to change the update rate of my 3DR Pixhawk IMU from… 50 Hz to 100 Hz. I've tried with `rosrun mavros mavsys rate --all 100` from terminal but it still remains at 50. Can somebody show me how to do this? Thanks. ### MAVROS version and platform Mavros: ?0.18.4? ROS: Melodic Ubuntu: 18.04 ### Autopilot type and version [ ] ArduPilot [ X ] PX4 Version: Fimware 1.9.2 ### Node logs ``` $ roslaunch mavros px4.launch ... logging to /home/francesco/.ros/log/9f8841d2-0631-11ea-bf51-7cb0c2639a2f/roslaunch-Enterprise-Ubuntu-5233.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is <1GB. /opt/ros/melodic/lib/python2.7/dist-packages/roslaunch/loader.py:412: YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details. data = yaml.load(text) started roslaunch server http://Enterprise-Ubuntu:42721/ SUMMARY ======== CLEAR PARAMETERS * /mavros/ PARAMETERS * /mavros/cmd/use_comp_id_system_control: False * /mavros/conn/heartbeat_rate: 1.0 * /mavros/conn/system_time_rate: 1.0 * /mavros/conn/timeout: 10.0 * /mavros/conn/timesync_rate: 10.0 * /mavros/distance_sensor/hrlv_ez4_pub/field_of_view: 0.0 * /mavros/distance_sensor/hrlv_ez4_pub/frame_id: hrlv_ez4_sonar * /mavros/distance_sensor/hrlv_ez4_pub/id: 0 * /mavros/distance_sensor/hrlv_ez4_pub/orientation: PITCH_270 * /mavros/distance_sensor/hrlv_ez4_pub/send_tf: True * /mavros/distance_sensor/hrlv_ez4_pub/sensor_position/x: 0.0 * /mavros/distance_sensor/hrlv_ez4_pub/sensor_position/y: 0.0 * /mavros/distance_sensor/hrlv_ez4_pub/sensor_position/z: -0.1 * /mavros/distance_sensor/laser_1_sub/id: 3 * /mavros/distance_sensor/laser_1_sub/orientation: PITCH_270 * /mavros/distance_sensor/laser_1_sub/subscriber: True * /mavros/distance_sensor/lidarlite_pub/field_of_view: 0.0 * /mavros/distance_sensor/lidarlite_pub/frame_id: lidarlite_laser * /mavros/distance_sensor/lidarlite_pub/id: 1 * /mavros/distance_sensor/lidarlite_pub/orientation: PITCH_270 * /mavros/distance_sensor/lidarlite_pub/send_tf: True * /mavros/distance_sensor/lidarlite_pub/sensor_position/x: 0.0 * /mavros/distance_sensor/lidarlite_pub/sensor_position/y: 0.0 * /mavros/distance_sensor/lidarlite_pub/sensor_position/z: -0.1 * /mavros/distance_sensor/sonar_1_sub/id: 2 * /mavros/distance_sensor/sonar_1_sub/orientation: PITCH_270 * /mavros/distance_sensor/sonar_1_sub/subscriber: True * /mavros/fake_gps/eph: 2.0 * /mavros/fake_gps/epv: 2.0 * /mavros/fake_gps/fix_type: 3 * /mavros/fake_gps/geo_origin/alt: 408.0 * /mavros/fake_gps/geo_origin/lat: 47.3667 * /mavros/fake_gps/geo_origin/lon: 8.55 * /mavros/fake_gps/gps_rate: 5.0 * /mavros/fake_gps/mocap_transform: True * /mavros/fake_gps/satellites_visible: 5 * /mavros/fake_gps/tf/child_frame_id: fix * /mavros/fake_gps/tf/frame_id: map * /mavros/fake_gps/tf/listen: False * /mavros/fake_gps/tf/rate_limit: 10.0 * /mavros/fake_gps/tf/send: False * /mavros/fake_gps/use_mocap: True * /mavros/fake_gps/use_vision: False * /mavros/fcu_protocol: v2.0 * /mavros/fcu_url: /dev/ttyACM0:57600 * /mavros/gcs_url: * /mavros/global_position/child_frame_id: base_link * /mavros/global_position/frame_id: map * /mavros/global_position/gps_uere: 1.0 * /mavros/global_position/rot_covariance: 99999.0 * /mavros/global_position/tf/child_frame_id: base_link * /mavros/global_position/tf/frame_id: map * /mavros/global_position/tf/global_frame_id: earth * /mavros/global_position/tf/send: False * /mavros/global_position/use_relative_alt: True * /mavros/image/frame_id: px4flow * /mavros/imu/angular_velocity_stdev: 0.0003490659 // 0... * /mavros/imu/frame_id: base_link * /mavros/imu/linear_acceleration_stdev: 0.0003 * /mavros/imu/magnetic_stdev: 0.0 * /mavros/imu/orientation_stdev: 1.0 * /mavros/landing_target/camera/fov_x: 2.0071286398 * /mavros/landing_target/camera/fov_y: 2.0071286398 * /mavros/landing_target/image/height: 480 * /mavros/landing_target/image/width: 640 * /mavros/landing_target/land_target_type: VISION_FIDUCIAL * /mavros/landing_target/listen_lt: False * /mavros/landing_target/mav_frame: LOCAL_NED * /mavros/landing_target/target_size/x: 0.3 * /mavros/landing_target/target_size/y: 0.3 * /mavros/landing_target/tf/child_frame_id: camera_center * /mavros/landing_target/tf/frame_id: landing_target * /mavros/landing_target/tf/listen: False * /mavros/landing_target/tf/rate_limit: 10.0 * /mavros/landing_target/tf/send: True * /mavros/local_position/frame_id: map * /mavros/local_position/tf/child_frame_id: base_link * /mavros/local_position/tf/frame_id: map * /mavros/local_position/tf/send: False * /mavros/local_position/tf/send_fcu: False * /mavros/mission/pull_after_gcs: True * /mavros/mocap/use_pose: True * /mavros/mocap/use_tf: False * /mavros/odometry/in/child_frame_id: base_link * /mavros/odometry/in/frame_id: odom * /mavros/odometry/in/frame_tf/body_frame_orientation: flu * /mavros/odometry/in/frame_tf/local_frame: local_origin_ned * /mavros/odometry/out/frame_tf/body_frame_orientation: frd * /mavros/odometry/out/frame_tf/local_frame: vision_ned * /mavros/plugin_blacklist: ['safety_area', '... * /mavros/plugin_whitelist: [] * /mavros/px4flow/frame_id: px4flow * /mavros/px4flow/ranger_fov: 0.118682 * /mavros/px4flow/ranger_max_range: 5.0 * /mavros/px4flow/ranger_min_range: 0.3 * /mavros/safety_area/p1/x: 1.0 * /mavros/safety_area/p1/y: 1.0 * /mavros/safety_area/p1/z: 1.0 * /mavros/safety_area/p2/x: -1.0 * /mavros/safety_area/p2/y: -1.0 * /mavros/safety_area/p2/z: -1.0 * /mavros/setpoint_accel/send_force: False * /mavros/setpoint_attitude/reverse_thrust: False * /mavros/setpoint_attitude/tf/child_frame_id: target_attitude * /mavros/setpoint_attitude/tf/frame_id: map * /mavros/setpoint_attitude/tf/listen: False * /mavros/setpoint_attitude/tf/rate_limit: 100.0 * /mavros/setpoint_attitude/use_quaternion: False * /mavros/setpoint_position/mav_frame: LOCAL_NED * /mavros/setpoint_position/tf/child_frame_id: target_position * /mavros/setpoint_position/tf/frame_id: map * /mavros/setpoint_position/tf/listen: False * /mavros/setpoint_position/tf/rate_limit: 100.0 * /mavros/setpoint_raw/thrust_scaling: 1.0 * /mavros/setpoint_velocity/mav_frame: LOCAL_NED * /mavros/startup_px4_usb_quirk: True * /mavros/sys/disable_diag: False * /mavros/sys/min_voltage: 10.0 * /mavros/target_component_id: 1 * /mavros/target_system_id: 1 * /mavros/tdr_radio/low_rssi: 40 * /mavros/time/time_ref_source: fcu * /mavros/time/timesync_avg_alpha: 0.6 * /mavros/time/timesync_mode: MAVLINK * /mavros/vibration/frame_id: base_link * /mavros/vision_pose/tf/child_frame_id: vision_estimate * /mavros/vision_pose/tf/frame_id: map * /mavros/vision_pose/tf/listen: False * /mavros/vision_pose/tf/rate_limit: 10.0 * /mavros/vision_speed/listen_twist: True * /mavros/vision_speed/twist_cov: True * /mavros/wheel_odometry/child_frame_id: base_link * /mavros/wheel_odometry/count: 2 * /mavros/wheel_odometry/frame_id: map * /mavros/wheel_odometry/send_raw: True * /mavros/wheel_odometry/send_twist: False * /mavros/wheel_odometry/tf/child_frame_id: base_link * /mavros/wheel_odometry/tf/frame_id: map * /mavros/wheel_odometry/tf/send: True * /mavros/wheel_odometry/use_rpm: False * /mavros/wheel_odometry/vel_error: 0.1 * /mavros/wheel_odometry/wheel0/radius: 0.05 * /mavros/wheel_odometry/wheel0/x: 0.0 * /mavros/wheel_odometry/wheel0/y: -0.15 * /mavros/wheel_odometry/wheel1/radius: 0.05 * /mavros/wheel_odometry/wheel1/x: 0.0 * /mavros/wheel_odometry/wheel1/y: 0.15 * /rosdistro: melodic * /rosversion: 1.14.3 NODES / mavros (mavros/mavros_node) auto-starting new master process[master]: started with pid [5243] ROS_MASTER_URI=http://localhost:11311 setting /run_id to 9f8841d2-0631-11ea-bf51-7cb0c2639a2f process[rosout-1]: started with pid [5254] started core service [/rosout] process[mavros-2]: started with pid [5262] [ INFO] [1573662079.656099451]: FCU URL: /dev/ttyACM0:57600 [ INFO] [1573662079.657818878]: serial0: device: /dev/ttyACM0 @ 57600 bps [ INFO] [1573662079.658671139]: GCS bridge disabled [ INFO] [1573662079.668287823]: Plugin 3dr_radio loaded [ INFO] [1573662079.670016509]: Plugin 3dr_radio initialized [ INFO] [1573662079.670234880]: Plugin actuator_control loaded [ INFO] [1573662079.673824565]: Plugin actuator_control initialized [ INFO] [1573662079.676823138]: Plugin adsb loaded [ INFO] [1573662079.679591729]: Plugin adsb initialized [ INFO] [1573662079.679736826]: Plugin altitude loaded [ INFO] [1573662079.680577553]: Plugin altitude initialized [ INFO] [1573662079.680694493]: Plugin cam_imu_sync loaded [ INFO] [1573662079.681215995]: Plugin cam_imu_sync initialized [ INFO] [1573662079.681369384]: Plugin command loaded [ INFO] [1573662079.686094142]: Plugin command initialized [ INFO] [1573662079.686310664]: Plugin companion_process_status loaded [ INFO] [1573662079.688988588]: Plugin companion_process_status initialized [ INFO] [1573662079.689143500]: Plugin debug_value loaded [ INFO] [1573662079.692692067]: Plugin debug_value initialized [ INFO] [1573662079.692721989]: Plugin distance_sensor blacklisted [ INFO] [1573662079.692852557]: Plugin fake_gps loaded [ INFO] [1573662079.703168760]: Plugin fake_gps initialized [ INFO] [1573662079.703309628]: Plugin ftp loaded [ INFO] [1573662079.709523824]: Plugin ftp initialized [ INFO] [1573662079.709638065]: Plugin global_position loaded [ INFO] [1573662079.720811903]: Plugin global_position initialized [ INFO] [1573662079.720962746]: Plugin gps_rtk loaded [ INFO] [1573662079.722741699]: Plugin gps_rtk initialized [ INFO] [1573662079.722921430]: Plugin hil loaded [ INFO] [1573662079.731383343]: Plugin hil initialized [ INFO] [1573662079.731495199]: Plugin home_position loaded [ INFO] [1573662079.733835446]: Plugin home_position initialized [ INFO] [1573662079.733994260]: Plugin imu loaded [ INFO] [1573662079.739424375]: Plugin imu initialized [ INFO] [1573662079.739531799]: Plugin landing_target loaded [ INFO] [1573662079.747782105]: Plugin landing_target initialized [ INFO] [1573662079.747929336]: Plugin local_position loaded [ INFO] [1573662079.753258482]: Plugin local_position initialized [ INFO] [1573662079.753415197]: Plugin log_transfer loaded [ INFO] [1573662079.756249202]: Plugin log_transfer initialized [ INFO] [1573662079.756393930]: Plugin manual_control loaded [ INFO] [1573662079.759077952]: Plugin manual_control initialized [ INFO] [1573662079.759176190]: Plugin mocap_pose_estimate loaded [ INFO] [1573662079.761567698]: Plugin mocap_pose_estimate initialized [ INFO] [1573662079.761662659]: Plugin mount_control loaded [ INFO] [1573662079.763184661]: Plugin mount_control initialized [ INFO] [1573662079.763270277]: Plugin obstacle_distance loaded [ INFO] [1573662079.764577824]: Plugin obstacle_distance initialized [ INFO] [1573662079.764663047]: Plugin odom loaded [ INFO] [1573662079.769220272]: Plugin odom initialized [ INFO] [1573662079.769407834]: Plugin param loaded [ INFO] [1573662079.771911625]: Plugin param initialized [ INFO] [1573662079.772008356]: Plugin px4flow loaded [ INFO] [1573662079.777775497]: Plugin px4flow initialized [ INFO] [1573662079.777832945]: Plugin rangefinder blacklisted [ INFO] [1573662079.778001135]: Plugin rc_io loaded [ INFO] [1573662079.782147715]: Plugin rc_io initialized [ INFO] [1573662079.782185354]: Plugin safety_area blacklisted [ INFO] [1573662079.782305933]: Plugin setpoint_accel loaded [ INFO] [1573662079.785404626]: Plugin setpoint_accel initialized [ INFO] [1573662079.785592574]: Plugin setpoint_attitude loaded [ INFO] [1573662079.793386243]: Plugin setpoint_attitude initialized [ INFO] [1573662079.793545462]: Plugin setpoint_position loaded [ INFO] [1573662079.801512386]: Plugin setpoint_position initialized [ INFO] [1573662079.801628355]: Plugin setpoint_raw loaded [ INFO] [1573662079.807218690]: Plugin setpoint_raw initialized [ INFO] [1573662079.807359336]: Plugin setpoint_velocity loaded [ INFO] [1573662079.811608805]: Plugin setpoint_velocity initialized [ INFO] [1573662079.811879909]: Plugin sys_status loaded [ INFO] [1573662079.818481006]: Plugin sys_status initialized [ INFO] [1573662079.818604306]: Plugin sys_time loaded [ INFO] [1573662079.822532412]: TM: Timesync mode: MAVLINK [ INFO] [1573662079.823434894]: Plugin sys_time initialized [ INFO] [1573662079.823557027]: Plugin trajectory loaded [ INFO] [1573662079.827016129]: Plugin trajectory initialized [ INFO] [1573662079.827122485]: Plugin vfr_hud loaded [ INFO] [1573662079.827564281]: Plugin vfr_hud initialized [ INFO] [1573662079.827587796]: Plugin vibration blacklisted [ INFO] [1573662079.827679201]: Plugin vision_pose_estimate loaded [ INFO] [1573662079.832146564]: Plugin vision_pose_estimate initialized [ INFO] [1573662079.832230922]: Plugin vision_speed_estimate loaded [ INFO] [1573662079.834574641]: Plugin vision_speed_estimate initialized [ INFO] [1573662079.834694576]: Plugin waypoint loaded [ INFO] [1573662079.839075768]: Plugin waypoint initialized [ INFO] [1573662079.839138598]: Plugin wheel_odometry blacklisted [ INFO] [1573662079.839311319]: Plugin wind_estimation loaded [ INFO] [1573662079.839938926]: Plugin wind_estimation initialized [ INFO] [1573662079.840002397]: Autostarting mavlink via USB on PX4 [ INFO] [1573662079.840114082]: Built-in SIMD instructions: SSE, SSE2 [ INFO] [1573662079.840133882]: Built-in MAVLink package version: 2019.9.9 [ INFO] [1573662079.840199602]: Known MAVLink dialects: common ardupilotmega ASLUAV autoquad icarous matrixpilot paparazzi slugs standard uAvionix ualberta [ INFO] [1573662079.840240252]: MAVROS started. MY ID 1.240, TARGET ID 1.1 [ INFO] [1573662079.935933482]: IMU: Scaled IMU message used. [ERROR] [1573662079.944128361]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ INFO] [1573662080.004054503]: IMU: High resolution IMU detected! [ INFO] [1573662080.005016911]: IMU: Attitude quaternion IMU detected! [ INFO] [1573662080.487696816]: CON: Got HEARTBEAT, connected. FCU: PX4 Autopilot [ INFO] [1573662080.514897068]: IMU: High resolution IMU detected! [ INFO] [1573662080.515470700]: IMU: Attitude quaternion IMU detected! [ERROR] [1573662080.814692169]: FCU: Data link lost [ INFO] [1573662080.906314290]: FCU: Onboard controller regained [ERROR] [1573662080.980156568]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ INFO] [1573662081.493774084]: VER: 1.1: Capabilities 0x000000000000e4ef [ INFO] [1573662081.493921415]: VER: 1.1: Flight software: 010902ff (106905871d000000) [ INFO] [1573662081.493999177]: VER: 1.1: Middleware software: 010902ff (106905871d000000) [ INFO] [1573662081.494088606]: VER: 1.1: OS software: 071c00ff (423371c7d4012e72) [ INFO] [1573662081.494167688]: VER: 1.1: Board hardware: 00000011 [ INFO] [1573662081.494232908]: VER: 1.1: VID/PID: 26ac:0011 [ INFO] [1573662081.494285964]: VER: 1.1: UID: 3034510736353832 [ WARN] [1573662081.496977880]: CMD: Unexpected command 520, result 0 [ERROR] [1573662081.996994591]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662083.027204250]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662084.027444532]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662085.061106727]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662086.095190534]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662087.096480620]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662088.097932593]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662089.128315701]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ERROR] [1573662090.129052823]: ODOM: Ex: Could not find a connection between 'local_origin_ned' and 'fcu' because they are not part of the same tree.Tf has two or more unconnected trees. [ INFO] [1573662090.488257328]: HP: requesting home position ``` ### Diagnostics ``` header: seq: 8 stamp: secs: 1573662083 nsecs: 341054933 frame_id: '' status: - level: 0 name: \"mavros: FCU connection\" message: \"connected\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Received packets:\" value: \"1175\" - key: \"Dropped packets:\" value: \"0\" - key: \"Buffer overruns:\" value: \"0\" - key: \"Parse errors:\" value: \"0\" - key: \"Rx sequence number:\" value: \"128\" - key: \"Tx sequence number:\" value: \"71\" - key: \"Rx total bytes:\" value: \"66885\" - key: \"Tx total bytes:\" value: \"1896\" - key: \"Rx speed:\" value: \"34703.000000\" - key: \"Tx speed:\" value: \"835.000000\" - level: 2 name: \"mavros: GPS\" message: \"No satellites\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Satellites visible\" value: \"0\" - key: \"Fix type\" value: \"0\" - key: \"EPH (m)\" value: \"Unknown\" - key: \"EPV (m)\" value: \"Unknown\" - level: 0 name: \"mavros: Heartbeat\" message: \"Normal\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Heartbeats since startup\" value: \"3\" - key: \"Frequency (Hz)\" value: \"0.850095\" - key: \"Vehicle type\" value: \"Quadrotor\" - key: \"Autopilot type\" value: \"PX4 Autopilot\" - key: \"Mode\" value: \"MANUAL\" - key: \"System status\" value: \"Standby\" - level: 2 name: \"mavros: System\" message: \"Sensor health\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Sensor present\" value: \"0x0006002F\" - key: \"Sensor enabled\" value: \"0x0021000F\" - key: \"Sensor health\" value: \"0x0006002F\" - key: \"3D gyro\" value: \"Ok\" - key: \"3D accelerometer\" value: \"Ok\" - key: \"3D magnetometer\" value: \"Ok\" - key: \"absolute pressure\" value: \"Ok\" - key: \"rc receiver\" value: \"Fail\" - key: \"AHRS subsystem health\" value: \"Fail\" - key: \"CPU Load (%)\" value: \"47.9\" - key: \"Drop rate (%)\" value: \"0.0\" - key: \"Errors comm\" value: \"0\" - key: \"Errors count #1\" value: \"0\" - key: \"Errors count #2\" value: \"0\" - key: \"Errors count #3\" value: \"0\" - key: \"Errors count #4\" value: \"0\" - level: 0 name: \"mavros: Battery\" message: \"Normal\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Voltage\" value: \"65.54\" - key: \"Current\" value: \"-0.0\" - key: \"Remaining\" value: \"-1.0\" - level: 0 name: \"mavros: Time Sync\" message: \"Normal\" hardware_id: \"/dev/ttyACM0:57600\" values: - key: \"Timesyncs since startup\" value: \"35\" - key: \"Frequency (Hz)\" value: \"9.936432\" - key: \"Last RTT (ms)\" value: \"1.598668\" - key: \"Mean RTT (ms)\" value: \"1.001017\" - key: \"Last remote time (s)\" value: \"392.844721000\" - key: \"Estimated time offset (s)\" value: \"1573661690.480628252\" --- ``` ### Check ID ``` OK. I got messages from 1:1. --- Received 6075 messages, from 1 addresses sys:comp list of messages 1:1 0, 1, 2, 4, 140, 141, 147, 26, 30, 31, 32, 36, 74, 331, 77, 83, 340, 230, 105, 111, 241, 116, 245 ```"
    },
    {
        "link": "https://discuss.px4.io/t/what-is-imu-sampling-frequency-time-in-pixhawk-4/37362",
        "document": "I am using a PX4 Vision v1 quadrotor. Its flight controller (FC) is Pixhawk 4. Onboard IMU is ICM-20689 and/or BMI055. Are both of these IMUs in FC or just one, then which one? I need FFT of accel and gyro data for which I am not sure what is the sampling frequency or time. Is the sampling frequency the same as IMU_GYRO_RATEMAX or IMU_INTEG_RATE? I kept IMU_GYRO_RATEMAX 400 Hz; it also says note that sensor data is always read and filtered at the full raw rate (eg commonly 8 kHz) regardless of this setting. IMU_INTEG_RATE is 200 kHz. So what is the IMU sampling frequency or time?\n\nI appreciate your help. Thank you!"
    },
    {
        "link": "https://docs.px4.io/main/en/config_mc/filter_tuning.html",
        "document": "Filters can be used to trade off control latency, which affects flight performance, and noise filtering, which impacts both flight performance and motor health.\n\nThis topic provides an overview of control latency and PX4 filter tuning.\n\nThe control latency is the delay from a physical disturbance of the vehicle until the motors react to the change.\n• A soft airframe or soft vibration mounting increases latency (they act as a filter).\n• Low-pass filters in software and on the sensor chip trade off increased latency for improved noise filtering.\n• PX4 software internals: the sensor signals need to be read in the driver and then pass through the controller to the output driver.\n• The maximum gyro publication rate (configured with IMU_GYRO_RATEMAX). A higher rate reduces latency but is computationally intensive/can starve other processes. 4 kHz or higher is only recommended for controllers with STM32H7 processor or newer (2 kHz value is near the limit for less capable processors).\n• The IO chip (MAIN pins) adds about 5.4 ms latency compared to using the AUX pins (this does not apply to a Pixracer or Omnibus F4, but does apply to a Pixhawk). To avoid the IO delay attach the motors to the AUX pins instead.\n• PWM output signal: enable Dshot by preference to reduce latency (or One-Shot if DShot is not supported). The protocol is selected for a group of outputs during Actuator Configuration.\n\nBelow we look at the impact of the low pass filters.\n\nThe filtering pipeline for the controllers in PX4 is described below.\n\nThis is disabled on all chips where it can be disabled (if not, cutoff frequency is set to the highest level of the chip).\n\nSetups that have a significant lower-frequency noise spike (e.g. due to harmonics at the rotor blade pass frequency) can benefit from using the notch filter to clean the signal before it is passed to the low pass filter (these harmonics have a similar detrimental impact on motors as other sources of noise).\n\nWithout the notch filter you'd have to set the low pass filter cutoff much lower (increasing the phase lag) in order to avoid passing this noise to the motors.\n\nOne or two static notch filters on the gyro sensor data that are used to filter out narrow band noise, for example a bending mode of the airframe.\n\nThe static notch filters can be configured using:\n\nDynamic notch filters use ESC RPM feedback and/or the onboard FFT analysis. The ESC RPM feedback is used to track the rotor blade pass frequency and its harmonics, while the FFT analysis can be used to track a frequency of another vibration source, such as a fuel engine.\n\nESC RPM feedback requires ESCs capable of providing RPM feedback such as DShot with telemetry connected, a bidirectional DShot set up (work in progress), or UAVCAN/DroneCAN ESCs. Before enabling, make sure that the ESC RPM is correct. You might have to adjust the pole count of the motors.\n\nThe following parameters should be set to enable and configure dynamic notch filters:\n\nA low pass filter on the gyro data can be configured with the IMU_GYRO_CUTOFF parameter.\n\nTo reduce the control latency, we want to increase the cutoff frequency for the low-pass filters. The effect on latency of increasing is approximated below.\n\nHowever this is a trade-off as increasing will also increase the noise of the signal that is fed to the motors. Noise on the motors has the following consequences:\n• Motors and ESCs can get hot, to the point where they get damaged.\n• Reduced flight time because the motors continuously change their speed.\n\nThe D-term is most susceptible to noise while slightly increased latency does not negatively affect performance. For this reason the D-term has a separately-configurable low-pass filter, IMU_DGYRO_CUTOFF.\n\nAn optional slew-rate filter on the motor outputs. This rate may be configured as part of the Multicopter Geometry when configuring actuators (which in turn modifies the CA_Rn_SLEW parameters for each motor ).\n\nFirst make sure to have the high-rate logging profile activated (SDLOG_PROFILE parameter). Flight Review will then show an FFT plot for the roll, pitch and yaw controls.\n\nFilter tuning is best done by reviewing flight logs. You can do multiple flights right after each other with different parameters and then inspect all logs, but make sure to disarm in between so that separate log files are created.\n\nThe performed flight manoeuvre can simply be hovering in Stabilized mode with some rolling and pitching to all directions and some increased throttle periods. The total duration does not need to be more than 30 seconds. In order to better compare, the manoeuvre should be similar in all tests.\n\nFirst tune the gyro filter IMU_GYRO_CUTOFF by increasing it in steps of 10 Hz while using a low D-term filter value (IMU_DGYRO_CUTOFF = 30). Upload the logs to Flight Review and compare the Actuator Controls FFT plot. Set the cutoff frequency to a value before the noise starts to increase noticeably (for frequencies around and above 60 Hz).\n\nThen tune the D-term filter ( ) in the same way. Note that there can be negative impacts on performance if and are set too far apart (the differences have to be significant though - e.g. D=15, gyro=80).\n\nBelow is an example for three different filter values (40Hz, 70Hz, 90Hz). At 90 Hz the general noise level starts to increase (especially for roll), and thus a cutoff frequency of 70 Hz is a safe setting.\n\nIf the flight plots shows significant low frequency spikes, like the one shown in the diagram below, you can remove it using a notch filter. In this case you might use the settings: IMU_GYRO_NF0_FRQ=32 and IMU_GYRO_NF0_BW=5 (note, this spike is narrower than usual). The low pass filters and the notch filter can be tuned independently (i.e. you don't need to set the notch filter before collecting the data for tuning the low pass filter).\n• None Acceptable latency depends on vehicle size and expectations. FPV racers typically tune for the absolute minimal latency (as a ballpark around 120, of 50 to 80). For bigger vehicles latency is less critical and of around 80 might be acceptable.\n• None You can start tuning at higher values (e.g. 100Hz), which might be desirable because the default tuning of is set very low (30Hz). The only caveat is that you must be aware of the risks:\n• Don't fly for more than 20-30 seconds\n• Check that the motors are not getting to hot\n• Listen for odd sounds and symptoms of excessive noise, as discussed above."
    },
    {
        "link": "https://discuss.ardupilot.org/t/how-to-adjust-the-sample-rate-of-distance-sensor-rangefinder/95567",
        "document": "Thank you very much for the information.\n\n I tried several ways ref: How to adjust the sample rate of distance sensor (rangefinder) - #13 by AlexWUrobot - PX4 Autopilot - Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink\n\n but the sampling rate is still about 2.444 Hz, by rostopic hz /mavros/distance_sensor/lidarlite_pub.\n\n\n\nI feel confused why the sampling rate is fluctuated from 1.69~2.44 Hz andwhy the default sampling is not 10 Hz,Thank you very much for your help\n\nI follow the configuration with two batteries (1 for pixhawk and motors, 2 for rangefinder) like\n\n \n\n ref: LIDAR-Lite Rangefinder — Copter documentation\n\nI also exam the sampling rate by arduino UNO and find the sampling rate of the distance sensor is 80 ~90 Hz.\n\n\n\nref: How to adjust the sample rate of distance sensor (rangefinder) - #13 by AlexWUrobot - PX4 Autopilot - Discussion Forum for PX4, Pixhawk, QGroundControl, MAVSDK, MAVLink\n\nTherefore, I feel confused about the sampling rate of /mavros/distance_sensor/lidarlite_pub is only 2Hz.\n\nI am thinking about the possible reasons:\n• try to provide the distance sensor and pixhawk with the same battery, instead of two separate batteries\n• try to use 9600 baud rate, instead of 115200. Currently, I use roslaunch mavros px4.launch fcu_url:=/dev/ttyUSB0:115200 on the linux terminal in the Jetson TX1 computer, which communicate with Pixhawk4 (fmu-v5).\n\nThe Jetson TX1 computer use the USB cable to telem2 port of the Pixhawk.\n\n The distance sensor use the I2C port of the Pixhawk."
    }
]