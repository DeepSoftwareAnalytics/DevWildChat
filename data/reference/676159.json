[
    {
        "link": "https://discourse.libsdl.org/t/what-functions-does-sdl-getticks-use-on-each-platform/14208",
        "document": "I’ve been trying to find a remedy to my current problem with\n\n SDL_GetTicks under Linux and failing. The only thing I can figure is\n\n that it uses gettimeofday under Linux and timegettime under Windows\n\n which both return the amount in milliseconds but lack a sufficient\n\n level of accuracy for games. This would also explain the unfortunate\n\n hiccups I can’t seem to get rid of in Linux programs using OpenGL. What I will do for the time being is using my own code through\n\n QueryPertormanceCounter and clock_gettime, but are my assumptions\n\n correct and, if so, why is this the case? “Duct tape is like the Force. It has a dark side, it has a\n\n light side, and it holds the Universe together.”\n\n -Carl Zwanig____________________________________________________________________________________\n\n Never Miss an Email\n\n Stay connected with Yahoo! Mail on your mobile. Get started!\n\n http://mobile.yahoo.com/services?promote=mail\n\nYou know SDL is open source right? Doing this from the top level of SDL sources: tells you where the different implementations for the different OSs are.\n\n You can use any “find in files” search you like btw. Looking at the implementation in ./src/timer/unix/SDL_systimer.c you can\n\n see that it is either using clock_gettime or gettimeofday based on the\n\n HAVE_CLOCK_GETTIME define. From: sdl-bounces+kos=climaxgroup.com@libsdl.org\n\n [mailto:sdl-bounces+kos=climaxgroup.com at libsdl.org] On Behalf Of Paul Duffy\n\n Sent: 17 January 2007 14:08\n\n To: sdl at libsdl.org\n\n Subject: [SDL] What functions does SDL_GetTicks use on each platform? I’ve been trying to find a remedy to my current problem with\n\n SDL_GetTicks under Linux and failing. The only thing I can figure is\n\n that it uses gettimeofday under Linux and timegettime under Windows\n\n which both return the amount in milliseconds but lack a sufficient\n\n level of accuracy for games. This would also explain the unfortunate\n\n hiccups I can’t seem to get rid of in Linux programs using OpenGL. What I will do for the time being is using my own code through\n\n QueryPertormanceCounter and clock_gettime, but are my assumptions\n\n correct and, if so, why is this the case? “Duct tape is like the Force. It has a dark side, it has a\n\n light side, and it holds the Universe together.”\n\n -Carl Zwanig Never Miss an Email\n\n Stay connected with Yahoo! Mail on your mobile. Get started!\n\n http://mobile.yahoo.com/services?promote=mail\n\nI’ve been trying to find a remedy to my current problem with\n\n SDL_GetTicks under Linux and failing. The only thing I can figure is\n\n that it uses gettimeofday under Linux and timegettime under Windows\n\n which both return the amount in milliseconds but lack a sufficient\n\n level of accuracy for games. This would also explain the unfortunate\n\n hiccups I can’t seem to get rid of in Linux programs using OpenGL. Have you analyzed the timestamps you get from SDL_GetTicks() - or\n\n rather, the deltas? Unless you’re running SCHED_FIFO or similar on a\n\n realtime OS (which usually requires root/sysadmin privileges and\n\n doesn’t mix well, if at all, with the video subsystem), you should\n\n expect jittering of a few ms. For perfectly smooth animation, you’ll need to apply som filtering\n\n before you inject the timestamps into the game logic. If you know the\n\n display refresh rate, you could essentially calculate a fixed\n\n per-frame delta, and just keep track of missed frames. After all,\n\n there are no such things as “fractional frames” on current CRT and\n\n TFT displays. Are you using proper page flipping with retrace sync? If not, there\n\n are two major issues that make smooth animation pretty much\n\n impossible:\n\n 1) Since you never sleep and just pump out frames\n\n as fast as possible (most of which will never\n\n be seen), the OS will consider your program a\n\n CPU hog, and will gladly hand the CPU to any\n\n background process that has work to do, and\n\n more seriously; you may not get the CPU back\n\n in a (relatively speaking) long time. 2) Animation without retrace sync invariably results in tearing and unstable, hard to track timing. You can get a reasonably approximation of smooth animation if you do things correctly, and if you get an insane frame rate (a few hundred fps or more), you'll even reduce the tearing quite a bit, but for all practical matters, it can never be perfectly smooth, nor tearing free. Now, before starting the serious hair pulling, do any games run\n\n perfectly smooth on your system? BTW, note that scrolling 2D games are generally much more sensitive\n\n than first person 3D games. The difference in scale and perspective\n\n generally makes tearing, low frame rates and dropped frames a bit\n\n less obvious in 3D games. What I will do for the time being is using my own code through\n\n QueryPertormanceCounter and clock_gettime, but are my assumptions\n\n correct and, if so, why is this the case? Well, you can try it, but unless there’s something wrong with\n\n SDL_GetTicks() or the underlying API on your system, I don’t think\n\n it’s going to help. It’s not going to eliminate the scheduling latency jitter, and even if\n\n there was no jitter, improving on a timing accuracy of 10+ units per\n\n display refresh wouldn’t make all that much of a difference. If it does help, I suspect SDL_GetTicks() is broken on your system. BTW, QueryPertormanceCounter and similar APIs are usually based on\n\n RDTSC and corresponding CPU instructions, and they tend to have\n\n problems on SMP systems, due to the CPUs not booting at the same\n\n time, and/or drifting out of sync over time. Oh, and then there’s\n\n thermothrottling… Technically, these issues can be dealt with by\n\n the OS - but certain versions of Windows and Linux (AFAIK) fail to do\n\n so, rendering these benchmarking APIs pretty much useless for\n\n production code.\n\nHave you analyzed the timestamps you get from SDL_GetTicks() - or\n\n rather, the deltas? Unless you’re running SCHED_FIFO or similar on a\n\n realtime OS (which usually requires root/sysadmin privileges and\n\n doesn’t mix well, if at all, with the video subsystem), you should\n\n expect jittering of a few ms. That, I expect and have compensated for. What I get is a visible pause\n\n for a sizeable fraction of a second and, of course, a jump of all\n\n animation as I’m basing all animation time on SDL_GetTicks. My output for values of time difference are usually around 3-7 ticks,\n\n but every few seconds I’ll get one of about 56, 76 or even 136. While\n\n this is happening, my CPU utilisation is between 0% and 9% so it’s\n\n hardly a processor hog. Right, I’m still a little fuzzy on the different behaviour on different\n\n platforms for various functions. Are you using proper page flipping with retrace sync? Well, I’m using proper OpenGL double buffering but I’m not using vSync. However, using something like SDL_Delay has no effect as this is quite\n\n the sizeable pause. What I was hoping, was that the problem was\n\n something to do with using a time function which was being\n\n insufficiently accurate. This does not, however, appear to be the case. Now, before starting the serious hair pulling, do any games run\n\n perfectly smooth on your system? Oh yes. Neverball, which is programmed with SDL so far as I’m away, runs\n\n dandy, and it does a bit more than my effort to boot. If it does help, I suspect SDL_GetTicks() is broken on your system. Oh joy. I’ve been spending all this time thinking I was missing\n\n something. I did post about this problem sometime back to no avail. I\n\n thought this was a Linux problem as I have no such issue in Windows. It seems the other reply may have the answer as to why I’m having this\n\n problem. I might see if swapping SuSE 10.0 for 10.2 makes any difference. Thanks for your help.On Wed, 2007-01-17 at 15:56 +0100, David Olofson wrote: All new Yahoo! Mail “The new Interface is stunning in its simplicity and ease of use.” - PC Magazine\n\n http://uk.docs.yahoo.com/nowyoucan.html\n\nMy output for values of time difference are usually around 3-7\n\n ticks, but every few seconds I’ll get one of about 56, 76 or even\n\n 136. While this is happening, my CPU utilisation is between 0% and\n\n 9% so it’s hardly a processor hog. That is strange, indeed - especially if throwing in an SDL_Delay(10)\n\n doesn’t help. That usually makes a bigger difference on Linux than it\n\n does on Windows, probably because Linux counts actual CPU time,\n\n whereas Windows apparently bases in’s “CPU usage” on the frequency of\n\n certain system calls. Now, before starting the serious hair pulling, do any games run\n\n perfectly smooth on your system? Oh yes. Neverball, which is programmed with SDL so far as I’m away,\n\n runs dandy, and it does a bit more than my effort to boot. …and it runs fine on the very machine and operating system where\n\n your code has problems? If so, maybe it’s worth a try recompiling\n\n Neverball, making sure it’s really using the same SDL library that\n\n you’re using, and see if it still runs smoothly. If it does help, I suspect SDL_GetTicks() is broken on your\n\n system. Oh joy. I’ve been spending all this time thinking I was missing\n\n something. Well, it could be something seemingly unrelated, such as event\n\n handling, och code that doesn’t even use SDL. Have you located the\n\n exact spot where time is “lost”? Could it be some unintentionally\n\n blocking system call or something? Have you tried commenting out stuff from the main loop until you have\n\n virtually nothing but the timing code left, and/or until the problem\n\n goes away? I did post about this problem sometime back to no avail. I\n\n thought this was a Linux problem as I have no such issue in Windows. Any platform specific #ifdefs in your code…? It seems the other reply may have the answer as to why I’m having\n\n this problem. I might see if swapping SuSE 10.0 for 10.2 makes any difference.\n\nRight; I almost forgot: Have you tried removing the SDL_Delay()\n\n altogether, and/or using a fixed time delta for the animation?\n\n That is, is your application stalled for 100+ ms every now and\n\n then, or is is “just” getting bogus timestamps? The latter. It’ll run fine for a few seconds then blip, fine for\n\n some other random interval, blip. It’s not really a case of bogus\n\n timestamps though as that’s how long it actually takes the function\n\n to return a value. So, the application is actually stalling, then? Are you sure it’s SDL_GetTicks()? (I have a hard time seeing how it\n\n could block or otherwise take a long time to return…) I’d suggest removing all timing code to see if you rendering loop runs\n\n full speed without it. That is, use the rendering to make it possible\n\n to see what’s going on, as you obviously cannot trust the\n\n timestamps. Then you can insert the SDL_Delay(10) and see if that causes problems.\n\n If not, try removing it and throwing in a dummy SDL_GetTicks(). If either call causes the problem to return, the problem is indeed\n\n that one of these calls indeed runs off to do something weird every\n\n now and then. The majority time interval is 12 microseconds\n\n with SDL_Delay(10). This, as mentioned elsewhere, is probably because the SDL libs I’m\n\n relying are muntered and so end up only able to use gettimeofday\n\n rather than clock_gettime and, through this, are relying on RDTSC\n\n which is based on the CPUs ability to answer such a query at any\n\n given time. RDTSC is a very fast instruction that just reads the value of a 64 bit\n\n counter that’s incremented by the core clock. AFAIK, there’s no way\n\n it could possibly make the CPU stall, cause a context switch or\n\n whatever - but if the motherboard is throttling the CPU core clock\n\n (for heat protection and/or power saving), you may have a hard time\n\n getting anything sensible out of the values… For some reason, I don’t know, this makes it inherently\n\n unreliable as has been said of QueryPerformanceTimer from the\n\n Microsoft Multimedia SDK which uses the same method. Like I said, the reason for these problems is that thermothrottling\n\n causes the core clock (and thus, the TSC “speed”) to\n\n change “randomly”, and at that, SMP systems have issues with the core\n\n clocks differing between CPUs. Newer versions of the lib seem to handle this stuff properly so I’ll\n\n be moving substantially from 1.2.8-8 to 1.2.11-22; been meaning to\n\n install SuSE 10.2 on my proper box for a few weeks now. Well, that’s probably a good idea either way. It definitely seems like\n\n something’s broken in the version you’re using. <stdio.h>\n\n “SDL.h”\n\n int main(int argc, char *argv )\n\n {\n\n Uint32 next = SDL_GetTicks() + 10;\n\n while(1)\n\n {\n\n Uint32 tick = SDL_GetTicks();\n\n if(tick > next + 1)\n\n printf(“Late by %d ms!\n\n”, tick - next);\n\n next = tick + 10;\n\n SDL_Delay(10);\n\n }\n\n } Ah, you mean SDL doesn’t choke if you don’t provide a surface or\n\n open a window? Didn’t know that. Generally, you’re not supposed to use any SDL calls before you’ve\n\n initialized SDL. Some calls may not work or could even crash on some\n\n platforms, unless you have a display up, for example. However, many calls are pretty much wired directly to the underlying\n\n OS, and don’t care whether or not SDL has been initialized. Even so, I wouldn’t really recommend doing this sort of stuff in\n\n production code, as it may well break with future versions of SDL.\n\nIn this particular vein, you might very well be right. There are delays,\n\n but they’re substantially less noticable without SDL_GetTicks involved\n\n so either these ones are occurring for a different reason or\n\n SDL_GetTicks somehow amplifies the effect. Unfortunately, I can’t pin it down to one function. I got a delay of 77\n\n from: gltActorTransform is taken (as is the tutorial I’m trying to adapt) from the OpenGL\n\n SuperBible 3rd Edition. Some necessary files are availble at\n\n http://www.starstonesoftware.com/OpenGL/articles.htm under ‘common.zip’. The delays have no particular favourite place occuring at the start, end, middle and\n\n outside assorted functions. I might try to update the nVidia drivers (and by extension\n\n the GL headers and libs) and see if that achieves anything as, asdes from GetTicks,\n\n that particular function is all GL and some basic maths.On Wed, 2007-01-17 at 22:23 +0100, David Olofson wrote: Right; I almost forgot: Have you tried removing the SDL_Delay()\n\n altogether, and/or using a fixed time delta for the animation?\n\n That is, is your application stalled for 100+ ms every now and\n\n then, or is is “just” getting bogus timestamps? The latter. It’ll run fine for a few seconds then blip, fine for\n\n some other random interval, blip. It’s not really a case of bogus\n\n timestamps though as that’s how long it actually takes the function\n\n to return a value. So, the application is actually stalling, then? Are you sure it’s SDL_GetTicks()? (I have a hard time seeing how it\n\n could block or otherwise take a long time to return…) I’d suggest removing all timing code to see if you rendering loop runs\n\n full speed without it. That is, use the rendering to make it possible\n\n to see what’s going on, as you obviously cannot trust the\n\n timestamps. The all-new Yahoo! Mail goes wherever you go - free your email address from your Internet provider. Yahoo is part of the Yahoo family of brands"
    },
    {
        "link": "https://stackoverflow.com/questions/56386995/sdl-2-how-use-the-event-system-and-draw-asynchronously",
        "document": "You can only use the event system and the drawing system where it's initialized, and they have to be on the same thread,\n\nwondering how if the polling system yields until an event is fired via\n\nhow would I say, draw something at 60fps whilst still being able to take input from the user? I assume there's a timer event? Or are you not even supposed to use SDL_WaitEvent....\n\nWondering how I should structure my game"
    },
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_GetTicks",
        "document": "(Uint32) Returns an unsigned 32-bit value representing the number of milliseconds since the SDL library initialized.\n\nThis function is not recommended as of SDL 2.0.18; use SDL_GetTicks64() instead, where the value doesn't wrap every ~49 days. There are places in SDL where we provide a 32-bit timestamp that can not change without breaking binary compatibility, though, so this function isn't officially deprecated."
    },
    {
        "link": "https://github.com/libsdl-org/SDL/blob/main/docs/README-migration.md",
        "document": "This guide provides useful information for migrating applications from SDL 2.0 to SDL 3.0.\n\nDetails on API changes are organized by SDL 2.0 header below.\n\nThe file with your main() function should include <SDL3/SDL_main.h>, as that is no longer included in SDL.h.\n\nCode that used to look like this:\n\nshould be changed to:\n\nThis only applies to camel case functions, e.g. . Lower case functions like SDL_strcmp() and SDL_memcmp() are unchanged, matching their C runtime counterpart.\n\nMany functions and symbols have been renamed. We have provided a handy Python script rename_symbols.py to rename SDL2 functions to their SDL3 counterparts:\n\nIt's also possible to apply a semantic patch to migrate more easily to SDL3: SDL_migration.cocci\n\nSDL headers should now be included as . Typically that's the only SDL header you'll need in your application unless you are using OpenGL or Vulkan functionality. SDL_image, SDL_mixer, SDL_net, SDL_ttf and SDL_rtf have also their preferred include path changed: for SDL_image, it becomes . We have provided a handy Python script rename_headers.py to rename SDL2 headers to their SDL3 counterparts:\n\nSome macros are renamed and/or removed in SDL3. We have provided a handy Python script rename_macros.py to replace these, and also add fixme comments on how to further improve the code:\n\nCMake users should use this snippet to include SDL support in their project:\n\nAutotools users should use this snippet to include SDL support in their project:\n\nand then add to their project and to their project .\n\nMakefile users can use this snippet to include SDL support in their project:\n\nThe SDL3test library has been renamed SDL3_test.\n\nThe SDLmain library has been removed, it's been entirely replaced by SDL_main.h.\n\nThe vi format comments have been removed from source code. Vim users can use the editorconfig plugin to automatically set tab spacing for the SDL coding style.\n\nInstalled SDL CMake configuration files no longer define , , , , or . Users are expected to use CMake generator expressions with , , or . By no longer defining these CMake variables, using a system SDL3 or using a vendoring SDL3 behave in the same way.\n\nThe following structures have been renamed:\n\nThe following functions have been renamed:\n\nThe audio subsystem in SDL3 is dramatically different than SDL2. The primary way to play audio is no longer an audio callback; instead you bind SDL_AudioStreams to devices; however, there is still a callback method available if needed.\n\nThe SDL 1.2 audio compatibility API has also been removed, as it was a simplified version of the audio callback interface.\n\nSDL3 will not implicitly initialize the audio subsystem on your behalf if you open a device without doing so. Please explicitly call SDL_Init(SDL_INIT_AUDIO) at some point.\n\nSDL2 referred to audio devices that record sound as \"capture\" devices, and ones that play sound to speakers as \"output\" devices. In SDL3, we've changed this terminology to be \"recording\" devices and \"playback\" devices, which we hope is more clear.\n\nSDL3's audio subsystem offers an enormous amount of power over SDL2, but if you just want a simple migration of your existing code, you can ignore most of it. The simplest migration path from SDL2 looks something like this:\n\nIn SDL2, you might have done something like this to play audio...\n\n...in SDL3, you can do this...\n\nIf you used SDL_QueueAudio instead of a callback in SDL2, this is also straightforward.\n\n...these same migration examples apply to audio recording, just using SDL_GetAudioStreamData instead of SDL_PutAudioStreamData.\n\nSDL_AudioInit() and SDL_AudioQuit() have been removed. Instead you can call SDL_InitSubSystem() and SDL_QuitSubSystem() with SDL_INIT_AUDIO, which will properly refcount the subsystems. You can choose a specific audio driver using SDL_AUDIO_DRIVER hint.\n\nThe symbols have been removed; now one may request the format they desire from the audio device, but ultimately SDL_AudioStream will manage the difference. One can use SDL_GetAudioDeviceFormat() to see what the final format is, if any \"allowed\" changes should be accomodated by the app.\n\nSDL_AudioDeviceID now represents both an open audio device's handle (a \"logical\" device) and the instance ID that the hardware owns as long as it exists on the system (a \"physical\" device). The separation between device instances and device indexes is gone, and logical and physical devices are almost entirely interchangeable at the API level.\n\nDevices are opened by physical device instance ID, and a new logical instance ID is generated by the open operation; This allows any device to be opened multiple times, possibly by unrelated pieces of code. SDL will manage the logical devices to provide a single stream of audio to the physical device behind the scenes.\n\nDevices are not opened by an arbitrary string name anymore, but by device instance ID (or magic numbers to request a reasonable default, like a NULL string would do in SDL2). In SDL2, the string was used to open both a standard list of system devices, but also allowed for arbitrary devices, such as hostnames of network sound servers. In SDL3, many of the backends that supported arbitrary device names are obsolete and have been removed; of those that remain, arbitrary devices will be opened with a default device ID and an SDL_hint, so specific end-users can set an environment variable to fit their needs and apps don't have to concern themselves with it.\n\nMany functions that would accept a device index and an parameter now just take an SDL_AudioDeviceID, as they are unique across all devices, instead of separate indices into playback and recording device lists.\n\nRather than iterating over audio devices using a device index, there are new functions, SDL_GetAudioPlaybackDevices() and SDL_GetAudioRecordingDevices(), to get the current list of devices, and new functions to get information about devices from their instance ID:\n\nSDL_LockAudioDevice() and SDL_UnlockAudioDevice() have been removed, since there is no callback in another thread to protect. SDL's audio subsystem and SDL_AudioStream maintain their own locks internally, so audio streams are safe to use from any thread. If the app assigns a callback to a specific stream, it can use the stream's lock through SDL_LockAudioStream() if necessary.\n\nSDL_PauseAudioDevice() no longer takes a second argument; it always pauses the device. To unpause, use SDL_ResumeAudioDevice().\n\nAudio devices, opened by SDL_OpenAudioDevice(), no longer start in a paused state, as they don't begin processing audio until a stream is bound.\n\nSDL_GetAudioDeviceStatus() has been removed; there is now SDL_AudioDevicePaused().\n\nSDL_QueueAudio(), SDL_DequeueAudio, and SDL_ClearQueuedAudio and SDL_GetQueuedAudioSize() have been removed; an SDL_AudioStream bound to a device provides the exact same functionality.\n\nAPIs that use channel counts used to use a Uint8 for the channel; now they use int.\n\nSDL_AudioSpec has been reduced; now it only holds format, channel, and sample rate. SDL_GetSilenceValueForFormat() can provide the information from the SDL_AudioSpec's removed field. SDL3 now manages the removed field; apps that want more control over device latency and throughput can force a newly-opened device's sample count with the SDL_HINT_AUDIO_DEVICE_SAMPLE_FRAMES hint, but most apps should not risk messing with the defaults. The other SDL2 SDL_AudioSpec fields aren't relevant anymore.\n\nSDL_GetAudioDeviceSpec() is removed; use SDL_GetAudioDeviceFormat() instead.\n\nSDL_GetDefaultAudioInfo() is removed; SDL_GetAudioDeviceFormat() with SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or SDL_AUDIO_DEVICE_DEFAULT_RECORDING. There is no replacement for querying the default device name; the string is no longer used to open devices, and SDL3 will migrate between physical devices on the fly if the system default changes, so if you must show this to the user, a generic name like \"System default\" is recommended.\n\nSDL_MixAudioFormat() and SDL_MIX_MAXVOLUME have been removed in favour of SDL_MixAudio(), which now takes the audio format, and a float volume between 0.0 and 1.0.\n\nSDL_FreeWAV has been removed and calls can be replaced with SDL_free.\n\nSDL_LoadWAV() is a proper function now and no longer a macro (but offers the same functionality otherwise).\n\nSDL_LoadWAV_IO() and SDL_LoadWAV() return an bool now, like most of SDL. They no longer return a pointer to an SDL_AudioSpec.\n\nSDL_AudioCVT interface has been removed, the SDL_AudioStream interface (for audio supplied in pieces) or the new SDL_ConvertAudioSamples() function (for converting a complete audio buffer in one call) can be used instead.\n\nCode that used to look like this:\n\nshould be changed to:\n\nAUDIO_U16, AUDIO_U16LSB, AUDIO_U16MSB, and AUDIO_U16SYS have been removed. They were not heavily used, and one could not memset a buffer in this format to silence with a single byte value. Use a different audio format.\n\nIf you need to convert U16 audio data to a still-supported format at runtime, the fastest, lossless conversion is to SDL_AUDIO_S16:\n\nAll remaining symbols have been renamed to for API consistency, but othewise are identical in value and usage.\n\nIn SDL2, SDL_AudioStream would convert/resample audio data during input (via SDL_AudioStreamPut). In SDL3, it does this work when requesting audio (via SDL_GetAudioStreamData, which would have been SDL_AudioStreamGet in SDL2). The way you use an AudioStream is roughly the same, just be aware that the workload moved to a different phase.\n\nIn SDL2, SDL_AudioStreamAvailable() returns 0 if passed a NULL stream. In SDL3, the equivalent SDL_GetAudioStreamAvailable() call returns -1 and sets an error string, which matches other audiostream APIs' behavior.\n\nIn SDL2, SDL_AUDIODEVICEREMOVED events would fire for open devices with the field set to the SDL_AudioDeviceID of the lost device, and in later SDL2 releases, would also fire this event with a field of zero for unopened devices, to signify that the app might want to refresh the available device list. In SDL3, this event works the same, except it won't ever fire with a zero; in this case it'll return the physical device's SDL_AudioDeviceID. Any still-open SDL_AudioDeviceIDs generated from this device with SDL_OpenAudioDevice() will also fire a separate event.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been renamed:\n\nThe following symbols have been removed:\n• SDL_MIX_MAXVOLUME - mixer volume is now a float between 0.0 and 1.0\n\nThe intrinsics headers (mmintrin.h, etc.) have been moved to and are no longer automatically included in SDL.h.\n\nSDL_Has3DNow() has been removed; there is no replacement.\n\nSDL_HasRDTSC() has been removed; there is no replacement. Don't use the RDTSC opcode in modern times, use SDL_GetPerformanceCounter and SDL_GetPerformanceFrequency instead.\n\nSDL_SIMDAlloc(), SDL_SIMDRealloc(), and SDL_SIMDFree() have been removed. You can use SDL_aligned_alloc() and SDL_aligned_free() with SDL_GetSIMDAlignment() to get the same functionality.\n\nThe following functions have been renamed:\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n• SDL_GetErrorMsg() - Can be implemented as\n\nSDL_PRESSED and SDL_RELEASED have been removed. For the most part you can replace uses of these with true and false respectively. Events which had a field to represent these values have had those fields changed to bool , e.g. is now .\n\nThe timestamp member of the SDL_Event structure now represents nanoseconds, and is populated with SDL_GetTicksNS()\n\nThe timestamp_us member of the sensor events has been renamed sensor_timestamp and now represents nanoseconds. This value is filled in from the hardware, if available, and may not be synchronized with values returned from SDL_GetTicksNS().\n\nYou should set the event.common.timestamp field before passing an event to SDL_PushEvent(). If the timestamp is 0 it will be filled in with SDL_GetTicksNS().\n\nEvent memory is now managed by SDL, so you should not free the data in SDL_EVENT_DROP_FILE, and if you want to hold onto the text in SDL_EVENT_TEXT_EDITING and SDL_EVENT_TEXT_INPUT events, you should make a copy of it. SDL_TEXTINPUTEVENT_TEXT_SIZE is no longer necessary and has been removed.\n\nMouse events use floating point values for mouse coordinates and relative motion values. You can get sub-pixel motion depending on the platform and display scaling.\n\nThe SDL_DISPLAYEVENT_* events have been moved to top level events, and SDL_DISPLAYEVENT has been removed. In general, handling this change just means checking for the individual events instead of first checking for SDL_DISPLAYEVENT and then checking for display events. You can compare the event >= SDL_EVENT_DISPLAY_FIRST and <= SDL_EVENT_DISPLAY_LAST if you need to see whether it's a display event.\n\nThe SDL_WINDOWEVENT_* events have been moved to top level events, and SDL_WINDOWEVENT has been removed. In general, handling this change just means checking for the individual events instead of first checking for SDL_WINDOWEVENT and then checking for window events. You can compare the event >= SDL_EVENT_WINDOW_FIRST and <= SDL_EVENT_WINDOW_LAST if you need to see whether it's a window event.\n\nThe SDL_EVENT_WINDOW_RESIZED event is always sent, even in response to SDL_SetWindowSize().\n\nThe SDL_EVENT_WINDOW_SIZE_CHANGED event has been removed, and you can use SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED to detect window backbuffer size changes.\n\nThe keysym field of key events has been removed to remove one level of indirection, and has been renamed .\n\nCode that used to look like this:\n\nshould be changed to:\n\nThe gamepad event structures caxis, cbutton, cdevice, ctouchpad, and csensor have been renamed gaxis, gbutton, gdevice, gtouchpad, and gsensor.\n\nThe mouseX and mouseY fields of SDL_MouseWheelEvent have been renamed mouse_x and mouse_y.\n\nThe touchId and fingerId fields of SDL_TouchFingerEvent have been renamed touchID and fingerID.\n\nThe level field of SDL_JoyBatteryEvent has been split into state and percent.\n\nThe iscapture field of SDL_AudioDeviceEvent has been renamed recording.\n\nSDL_QUERY, SDL_IGNORE, SDL_ENABLE, and SDL_DISABLE have been removed. You can use the functions SDL_SetEventEnabled() and SDL_EventEnabled() to set and query event processing state.\n\nSDL_AddEventWatch() now returns false if it fails because it ran out of memory and couldn't add the event watch callback.\n\nSDL_RegisterEvents() now returns 0 if it couldn't allocate any user events.\n\nThe following symbols have been renamed:\n\nThe following symbols have been removed:\n• SDL_SYSWMEVENT - you can use SDL_SetWindowsMessageHook() and SDL_SetX11EventHook() to watch and modify system events before SDL sees them.\n\nThe following structures have been renamed:\n\nThe following functions have been removed:\n\nThe following enums have been renamed:\n\nThe following functions have been renamed:\n\nSDL_gamecontroller.h has been renamed SDL_gamepad.h, and all APIs have been renamed to match.\n\nThe SDL_EVENT_GAMEPAD_ADDED event now provides the joystick instance ID in the which member of the cdevice event structure.\n\nThe functions SDL_GetGamepads(), SDL_GetGamepadNameForID(), SDL_GetGamepadPathForID(), SDL_GetGamepadPlayerIndexForID(), SDL_GetGamepadGUIDForID(), SDL_GetGamepadVendorForID(), SDL_GetGamepadProductForID(), SDL_GetGamepadProductVersionForID(), and SDL_GetGamepadTypeForID() have been added to directly query the list of available gamepads.\n\nThe gamepad face buttons have been renamed from A/B/X/Y to North/South/East/West to indicate that they are positional rather than hardware-specific. You can use SDL_GetGamepadButtonLabel() to get the labels for the face buttons, e.g. A/B/X/Y or Cross/Circle/Square/Triangle. The hint SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS is ignored, and mappings that use this hint are translated correctly into positional buttons. Applications should provide a way for users to swap between South/East as their accept/cancel buttons, as this varies based on region and muscle memory. You can use an approach similar to the following to handle this:\n\nSDL_GameControllerGetSensorDataWithTimestamp() has been removed. If you want timestamps for the sensor data, you should use the sensor_timestamp member of SDL_EVENT_GAMEPAD_SENSOR_UPDATE events.\n\nSDL_CONTROLLER_TYPE_VIRTUAL has been removed, so virtual controllers can emulate other gamepad types. If you need to know whether a controller is virtual, you can use SDL_IsJoystickVirtual().\n\nSDL_CONTROLLER_TYPE_AMAZON_LUNA has been removed, and can be replaced with this code:\n\nSDL_CONTROLLER_TYPE_GOOGLE_STADIA has been removed, and can be replaced with this code:\n\nSDL_CONTROLLER_TYPE_NVIDIA_SHIELD has been removed, and can be replaced with this code:\n\nThe inputType and outputType fields of SDL_GamepadBinding have been renamed input_type and output_type.\n\nSDL_GetGamepadTouchpadFinger() takes a pointer to bool for the finger state instead of a pointer to Uint8.\n\nThe following enums have been renamed:\n\nThe following structures have been renamed:\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been renamed:\n\nThe gesture API has been removed. There is no replacement planned in SDL3. However, the SDL2 code has been moved to a single-header library that can be dropped into an SDL3 or SDL2 program, to continue to provide this functionality to your app and aid migration. That is located in the SDL_gesture GitHub repository.\n\nSDL_GUIDToString() returns a const pointer to the string representation of a GUID.\n\nThe following functions have been renamed:\n\nGamepads with simple rumble capability no longer show up in the SDL haptics interface, instead you should use SDL_RumbleGamepad().\n\nRather than iterating over haptic devices using device index, there is a new function SDL_GetHaptics() to get the current list of haptic devices, and new functions to get information about haptic devices from their instance ID:\n\nSDL_GetHapticEffectStatus() now returns bool instead of an int result. You should call SDL_GetHapticFeatures() to make sure effect status is supported before calling this function.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nCalling SDL_GetHint() with the name of the hint being changed from within a hint callback will now return the new value rather than the old value. The old value is still passed as a parameter to the hint callback.\n\nThe environment variables SDL_VIDEODRIVER and SDL_AUDIODRIVER have been renamed to SDL_VIDEO_DRIVER and SDL_AUDIO_DRIVER, but the old names are still supported as a fallback.\n\nThe environment variables SDL_VIDEO_X11_WMCLASS and SDL_VIDEO_WAYLAND_WMCLASS have been removed and replaced by either using the appindentifier param to SDL_SetAppMetadata() or setting SDL_PROP_APP_METADATA_IDENTIFIER_STRING with SDL_SetAppMetadataProperty()\n\nThe environment variable AUDIODEV is used exclusively to specify the audio device for the OSS and NetBSD audio drivers. Its use in the ALSA driver has been replaced with the hint SDL_HINT_AUDIO_ALSA_DEFAULT_DEVICE and in the sndio driver with the environment variable AUDIODEVICE.\n\nThe following hints have been renamed:\n\nThe following hints have been removed:\n• SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO - the audio will be paused when the application is paused, and SDL_HINT_ANDROID_BLOCK_ON_PAUSE can be used to control that\n• SDL_HINT_AUDIO_DEVICE_APP_NAME - replaced by either using the appname param to SDL_SetAppMetadata() or setting SDL_PROP_APP_METADATA_NAME_STRING with SDL_SetAppMetadataProperty()\n• SDL_HINT_MOUSE_RELATIVE_MODE_WARP - relative mode is always implemented at the hardware level or reported as unavailable\n• SDL_HINT_MOUSE_RELATIVE_SCALING - mouse coordinates are no longer automatically scaled by the SDL renderer\n• SDL_HINT_RENDER_BATCHING - Render batching is always enabled, apps should call SDL_FlushRenderer() before calling into a lower-level graphics API.\n• SDL_HINT_RENDER_LOGICAL_SIZE_MODE - the logical size mode is explicitly set with SDL_SetRenderLogicalPresentation()\n• SDL_HINT_RENDER_OPENGL_SHADERS - shaders are always used if they are available\n• SDL_HINT_RENDER_SCALE_QUALITY - textures now default to linear filtering, use SDL_SetTextureScaleMode(texture, SDL_SCALEMODE_NEAREST) if you want nearest pixel mode instead\n• SDL_HINT_THREAD_STACK_SIZE - the stack size can be specified using SDL_CreateThreadWithProperties()\n• SDL_HINT_VIDEO_X11_XINERAMA - Xinerama no longer supported by the X11 backend\n• SDL_HINT_VIDEO_X11_XVIDMODE - Xvidmode no longer supported by the X11 backend\n• SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING - SDL now properly handles the 0x406D1388 Exception if no debugger intercepts it, preventing its propagation.\n• SDL_HINT_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS - Slim Reader/Writer Locks are always used if available\n\nThe following environment variables have been renamed:\n\nThe following environment variables have been removed:\n• SDL_AUDIO_ALSA_DEBUG - replaced by setting the hint SDL_HINT_LOGGING to \"audio=debug\"\n• SDL_DISKAUDIODELAY - replaced with the hint SDL_HINT_AUDIO_DISK_TIMESCALE which allows scaling the audio time rather than specifying an absolute delay.\n• SDL_DUMMYAUDIODELAY - replaced with the hint SDL_HINT_AUDIO_DUMMY_TIMESCALE which allows scaling the audio time rather than specifying an absolute delay.\n\nThe following functions have been removed:\n\nThe following functions have been renamed:\n\nOn Haiku OS, SDL no longer sets the current working directory to the executable's path during SDL_Init(). If you need this functionality, the fastest solution is to add this code directly after the call to SDL_Init:\n\nThe following symbols have been renamed:\n\nThe following symbols have been removed:\n• SDL_INIT_EVERYTHING - you should only initialize the subsystems you are using\n\nSDL_JoystickID has changed from Sint32 to Uint32, with an invalid ID being 0.\n\nRather than iterating over joysticks using device index, there is a new function SDL_GetJoysticks() to get the current list of joysticks, and new functions to get information about joysticks from their instance ID:\n\nThe SDL_EVENT_JOYSTICK_ADDED event now provides the joystick instance ID in the member of the jdevice event structure.\n\nThe functions SDL_GetJoysticks(), SDL_GetJoystickNameForID(), SDL_GetJoystickPathForID(), SDL_GetJoystickPlayerIndexForID(), SDL_GetJoystickGUIDForID(), SDL_GetJoystickVendorForID(), SDL_GetJoystickProductForID(), SDL_GetJoystickProductVersionForID(), and SDL_GetJoystickTypeForID() have been added to directly query the list of available joysticks.\n\nSDL_AttachVirtualJoystick() now returns the joystick instance ID instead of a device index, and returns 0 if there was an error.\n\nSDL_VirtualJoystickDesc version should not be set to SDL_VIRTUAL_JOYSTICK_DESC_VERSION, instead the structure should be initialized using SDL_INIT_INTERFACE().\n\nThe following functions have been renamed:\n\nThe following symbols have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been removed:\n\nThe following structures have been renamed:\n\nText input is no longer automatically enabled when initializing video, you should call SDL_StartTextInput() when you want to receive text input and call SDL_StopTextInput() when you are done. Starting text input may shown an input method editor (IME) and cause key up/down events to be skipped, so should only be enabled when the application wants text input.\n\nThe text input state hase been changed to be window-specific. SDL_StartTextInput(), SDL_StopTextInput(), SDL_TextInputActive(), and SDL_ClearComposition() all now take a window parameter.\n\nSDL_GetDefaultKeyFromScancode(), SDL_GetKeyFromScancode(), and SDL_GetScancodeFromKey() take an SDL_Keymod parameter and use that to provide the correct result based on keyboard modifier state.\n\nSDL_GetKeyboardState() returns a pointer to bool instead of Uint8.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following structures have been removed:\n\nSDL_Keycode is now Uint32 and the SDLK_* constants are now defines instead of an enum, to more clearly reflect that they are a subset of the possible values of an SDL_Keycode.\n\nIn addition to the bit found on key codes that directly map to scancodes, there is now the bit used to denote key codes that don't have a corresponding scancode, and aren't a unicode value.\n\nThe following symbols have been removed:\n• KMOD_RESERVED - No replacement. A bit named \"RESERVED\" probably shouldn't be used in an app, but if you need it, this was equivalent to KMOD_SCROLL (0x8000) in SDL2.\n\nThe following symbols have been renamed:\n\nShared object handles are now , an opaque type, instead of . This is just for type-safety and there is no functional difference.\n\nSDL_LoadFunction() now returns instead of , and should be cast to the appropriate function type. You can define SDL_FUNCTION_POINTER_IS_VOID_POINTER in your project to restore the previous behavior.\n\nSDL_Log() no longer prints a log prefix by default for SDL_LOG_PRIORITY_INFO and below. The log prefixes can be customized with SDL_SetLogPriorityPrefix().\n\nThe following macros have been removed:\n• SDL_MAX_LOG_MESSAGE - there's no message length limit anymore. If you need an artificial limit, this used to be 4096 in SDL versions before 2.0.24.\n\nThe following functions have been renamed:\n\nThe following symbols have been renamed:\n\nSDL3 doesn't have a static libSDLmain to link against anymore. Instead SDL_main.h is now a header-only library and not included by SDL.h anymore.\n\nUsing it is really simple: Just in the source file with your standard function. See docs/README-main-functions.md for details.\n\nSeveral platform-specific entry point functions have been removed as unnecessary. If for some reason you explicitly need them, here are easy replacements:\n\nThe following functions have been removed:\n\nThe buttonid field of SDL_MessageBoxButtonData has been renamed buttonID.\n\nThe following symbols have been renamed:\n\nSDL_Metal_GetDrawableSize() has been removed. SDL_GetWindowSizeInPixels() can be used in its place.\n\nSDL_ShowCursor() has been split into three functions: SDL_ShowCursor(), SDL_HideCursor(), and SDL_CursorVisible()\n\nSDL_GetMouseState(), SDL_GetGlobalMouseState(), SDL_GetRelativeMouseState(), SDL_WarpMouseInWindow(), and SDL_WarpMouseGlobal() all use floating point mouse positions, to provide sub-pixel precision on platforms that support it.\n\nSDL_SystemCursor's items from SDL2 have been renamed to match CSS cursor names.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been renamed:\n\nSDL_MUTEX_MAXWAIT has been removed; it suggested there was a maximum timeout one could outlive, instead of an infinite wait. Instead, pass a -1 to functions that accepted this symbol.\n\nSDL_MUTEX_TIMEDOUT has been removed, the wait functions return true if the operation succeeded or false if they timed out.\n\nSDL_LockMutex(), SDL_UnlockMutex(), SDL_WaitSemaphore(), SDL_SignalSemaphore(), SDL_WaitCondition(), SDL_SignalCondition(), and SDL_BroadcastCondition() now return void; if the object is valid (including being a NULL pointer, which returns immediately), these functions never fail. If the object is invalid or the caller does something illegal, like unlock another thread's mutex, this is considered undefined behavior.\n\nSDL_TryWaitSemaphore(), SDL_WaitSemaphoreTimeout(), and SDL_WaitConditionTimeout() now return true if the operation succeeded or false if they timed out.\n\nThe following functions have been renamed:\n\nThe following symbols have been renamed:\n\nSDL_PixelFormat has been renamed SDL_PixelFormatDetails and just describes the pixel format, it does not include a palette for indexed pixel types.\n\nSDL_PixelFormatEnum has been renamed SDL_PixelFormat and is used instead of Uint32 for API functions that refer to pixel format by enumerated value.\n\nSDL_MapRGB(), SDL_MapRGBA(), SDL_GetRGB(), and SDL_GetRGBA() take an optional palette parameter for indexed color lookups.\n\nCode that used to look like this:\n\nshould be changed to:\n\nCode that used to look like this:\n\nshould be changed to:\n\nSDL_CalculateGammaRamp has been removed, because SDL_SetWindowGammaRamp has been removed as well due to poor support in modern operating systems (see SDL_video.h).\n\nThe following functions have been renamed:\n\nThe following symbols have been renamed:\n\nThe following functions have been removed:\n\nThe following macros have been removed:\n\nThe following structures have been renamed:\n\nThe following platform preprocessor macros have been renamed:\n\nYou can use the Python script rename_macros.py to automatically rename these in your source code.\n\nA new macro has been added that is true for all Windows platforms, including Xbox, GDK, etc.\n\nThe following platform preprocessor macros have been removed:\n\nSDL_quit.h has been completely removed. It only had one symbol in it--SDL_QuitRequested--and if you want it, you can just add this to your app...\n\n...but this macro is sort of messy, calling two functions in sequence in an expression.\n\nThe following macros have been removed:\n\nThe following functions have been renamed:\n\nThe 2D renderer API always uses batching in SDL3. There is no magic to turn it on and off; it doesn't matter if you select a specific renderer or try to use any hint. This means that all apps that use SDL3's 2D renderer and also want to call directly into the platform's lower-layer graphics API must call SDL_FlushRenderer() before doing so. This will make sure any pending rendering work from SDL is done before the app starts directly drawing.\n\nSDL_GetRenderDriverInfo() has been removed, since most of the information it reported were estimates and could not be accurate before creating a renderer. Often times this function was used to figure out the index of a driver, so one would call it in a for-loop, looking for the driver named \"opengl\" or whatnot. SDL_GetRenderDriver() has been added for this functionality, which returns only the name of the driver.\n\nSDL_CreateRenderer()'s second argument is no longer an integer index, but a representing a renderer's name; if you were just using a for-loop to find which index is the \"opengl\" or whatnot driver, you can just pass that string directly here, now. Passing NULL is the same as passing -1 here in SDL2, to signify you want SDL to decide for you.\n\nSDL_CreateRenderer()'s flags parameter has been removed. See specific flags below for how to achieve the same functionality in SDL 3.0.\n\nSDL_CreateWindowAndRenderer() now takes the window title as the first parameter.\n\nSDL_GetRendererInfo() has been removed. The name of a renderer can be retrieved using SDL_GetRendererName(), and the other information is available as properties on the renderer.\n\nTextures are created with SDL_SCALEMODE_LINEAR by default, and use SDL_BLENDMODE_BLEND by default if they are created with a format that has an alpha channel.\n\nSDL_QueryTexture() has been removed. The properties of the texture can be queried using SDL_PROP_TEXTURE_FORMAT_NUMBER, SDL_PROP_TEXTURE_ACCESS_NUMBER, SDL_PROP_TEXTURE_WIDTH_NUMBER, and SDL_PROP_TEXTURE_HEIGHT_NUMBER. A function SDL_GetTextureSize() has been added to get the size of the texture as floating point values.\n\nMouse and touch events are no longer filtered to change their coordinates, instead you can call SDL_ConvertEventToRenderCoordinates() to explicitly map event coordinates into the rendering viewport.\n\nSDL_RenderWindowToLogical() and SDL_RenderLogicalToWindow() have been renamed SDL_RenderCoordinatesFromWindow() and SDL_RenderCoordinatesToWindow() and take floating point coordinates in both directions.\n\nThe viewport, clipping state, and scale for render targets are now persistent and will remain set whenever they are active.\n\nSDL_Vertex has been changed to use floating point colors, in the range of [0..1] for SDR content.\n\nSDL_RenderReadPixels() returns a surface instead of filling in preallocated memory.\n\nSDL_RenderSetLogicalSize() (now called SDL_SetRenderLogicalPresentation()) in SDL2 would modify the scaling and viewport state. In SDL3, logical presentation maintains its state separately, so the app can use its own viewport and scaling while also setting a logical size.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n• SDL_GL_BindTexture() - use SDL_GetTextureProperties() to get the OpenGL texture ID and bind the texture directly\n• SDL_GL_UnbindTexture() - use SDL_GetTextureProperties() to get the OpenGL texture ID and unbind the texture directly\n• SDL_RenderSetIntegerScale() - this is now explicit with SDL_LOGICAL_PRESENTATION_INTEGER_SCALE\n\nThe following enums have been renamed:\n\nThe following symbols have been renamed:\n\nThe following symbols have been removed:\n• SDL_RENDERER_ACCELERATED - all renderers except are accelerated\n• SDL_RENDERER_PRESENTVSYNC - replaced with SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER during renderer creation and SDL_PROP_RENDERER_VSYNC_NUMBER after renderer creation\n• SDL_RENDERER_SOFTWARE - you can check whether the name of the renderer is\n\nThe following symbols have been renamed:\n\nSDL_RWops is now an opaque structure, and has been renamed to SDL_IOStream. The SDL3 APIs to create an SDL_IOStream (SDL_IOFromFile, etc) are renamed but otherwise still function as they did in SDL2. However, to make a custom SDL_IOStream with app-provided function pointers, call SDL_OpenIO and provide the function pointers through there. To call into an SDL_IOStream's functionality, use the standard APIs (SDL_ReadIO, etc), as the function pointers are internal.\n\nSDL_IOStream is not to be confused with the unrelated standard C++ iostream class!\n\nThe RWops function pointers are now in a separate structure called SDL_IOStreamInterface, which is provided to SDL_OpenIO when creating a custom SDL_IOStream implementation. All the functions now take a userdata argument for their first parameter instead of an SDL_IOStream, since that's now an opaque structure.\n\nSDL_RWread and SDL_RWwrite (and the read and write function pointers) have a different function signature in SDL3, in addition to being renamed.\n\nPreviously they looked more like stdio:\n\nBut now they look more like POSIX:\n\nCode that used to look like this:\n\nshould be changed to:\n\nSDL_RWops::type was removed; it wasn't meaningful for app-provided implementations at all, and wasn't much use for SDL's internal implementations, either. If you have to identify the type, you can examine the SDL_IOStream's properties to detect built-in implementations.\n\nSDL_IOStreamInterface::close implementations should clean up their own userdata, but not call SDL_CloseIO on themselves; now the contract is always that SDL_CloseIO is called, which calls before freeing the opaque object.\n\nSDL_AllocRW(), SDL_FreeRW(), SDL_RWclose() and direct access to the function pointer have been removed from the API, so there's only one path to manage RWops lifetimes now: SDL_OpenIO() and SDL_CloseIO().\n\nSDL_RWFromFP has been removed from the API, due to issues when the SDL library uses a different C runtime from the application.\n\nYou can implement this in your own code easily:\n\nThe internal is available through a standard SDL_IOStream property, for streams made through SDL_IOFromFile() that use stdio behind the scenes; apps use this pointer at their own risk and should make sure that SDL and the app are using the same C runtime.\n\nOn Apple platforms, SDL_RWFromFile (now called SDL_IOFromFile) no longer tries to read from inside the app bundle's resource directory, instead now using the specified path unchanged. One can use SDL_GetBasePath() to find the resource directory on these platforms.\n\nThe functions SDL_ReadU8(), SDL_ReadU16LE(), SDL_ReadU16BE(), SDL_ReadU32LE(), SDL_ReadU32BE(), SDL_ReadU64LE(), and SDL_ReadU64BE() now return true if the read succeeded and false if it didn't, and store the data in a pointer passed in as a parameter.\n\nThe following functions have been renamed:\n\nThe following structures have been renamed:\n\nThe following symbols have been removed:\n\nThe following symbols have been renamed:\n\nSDL_SensorID has changed from Sint32 to Uint32, with an invalid ID being 0.\n\nRather than iterating over sensors using device index, there is a new function SDL_GetSensors() to get the current list of sensors, and new functions to get information about sensors from their instance ID:\n\nRemoved SDL_SensorGetDataWithTimestamp(), if you want timestamps for the sensor data, you should use the sensor_timestamp member of SDL_EVENT_SENSOR_UPDATE events.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThis header has been removed and a simplified version of this API has been added as SDL_SetWindowShape() in SDL_video.h. See test/testshape.c for an example.\n\nThe standard C headers like stdio.h and stdlib.h are no longer included, you should include them directly in your project if you use non-SDL C runtime functions. M_PI is no longer defined in SDL_stdinc.h, you can use the new symbols SDL_PI_D (double) and SDL_PI_F (float) instead.\n\nbool is now defined as bool, and is 1 byte instead of the size of an int.\n\nSDL3 attempts to apply consistency to case-insensitive string functions. In SDL2, things like SDL_strcasecmp() would usually only work on English letters, and depending on the user's locale, possibly not even those. In SDL3, consistency is applied:\n• Many things that don't care about case-insensitivity, like SDL_strcmp(), continue to work with any null-terminated string of bytes, even if it happens to be malformed UTF-8.\n• SDL_strcasecmp() expects valid UTF-8 strings, and will attempt to support most Unicode characters with a technique known as \"case-folding,\" which is to say it can match 'A' and 'a', and also 'Η' and 'η', but ALSO 'ß' and \"ss\". This is probably how most apps assumed it worked in SDL2 and won't need any changes.\n• SDL_strncasecmp() works the same, but the third parameter takes bytes, as before, so SDL_strlen() can continue to be used with it. If a string hits the limit in the middle of a codepoint, the half-processed bytes of the codepoint will be treated as a collection of U+0xFFFD (REPLACEMENT CHARACTER) codepoints, which you probably don't want.\n• SDL_wcscasecmp() and SDL_wcsncasecmp() work the same way but operate on UTF-16 or UTF-32 encoded strings, depending on what the platform considers \"wchar_t\" to be. SDL_wcsncasecmp's third parameter is number of wchar_t values, not bytes, but UTF-16 has the same concerns as UTF-8 for variable-length codepoints.\n• SDL_strcasestr() expects valid UTF-8 strings, and will compare codepoints using case-folding.\n• SDL_tolower() and SDL_toupper() continue to only work on single bytes (even though the parameter is an ) and only converts low-ASCII English A through Z.\n• SDL_strlwr() and SDL_strupr() operates on individual bytes (not UTF-8 codepoints) and only change low-ASCII English 'A' through 'Z'. These functions do not check the string for valid UTF-8 encoding.\n• The ctype.h replacement SDL_is*() functions (SDL_isalpha, SDL_isdigit, etc) only work on low-ASCII characters and ignore user locale, assuming English. This makes these functions consistent in SDL3, but applications need to be careful to understand their limits.\n\nPlease note that the case-folding technique used by SDL3 will not produce correct results for the \"Turkish 'I'\"; this one letter is a surprisingly hard problem in the Unicode world, and since these functions do not specify the human language in use, we have chosen to ignore this problem.\n\nSDL_strtoll(), SDL_strtoull(), SDL_lltoa(), and SDL_ulltoa() use long long values instead of 64-bit values, to match their C runtime counterparts.\n\nSDL_setenv() is not thread-safe and has been renamed SDL_setenv_unsafe().\n\nThe following macros have been removed:\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been renamed:\n\nSDL_Surface has been simplified and internal details are no longer in the public structure.\n\nThe member of SDL_Surface is now an enumerated pixel format value. You can get the full details of the pixel format by calling . You can get the palette associated with the surface by calling SDL_GetSurfacePalette(). You can get the clip rectangle by calling SDL_GetSurfaceClipRect().\n\nThe userdata member of SDL_Surface has been replaced with a more general properties interface, which can be queried with SDL_GetSurfaceProperties()\n\nIndexed format surfaces no longer have a palette by default. Surfaces without a palette will copy the pixels untranslated between surfaces.\n\nCode that used to look like this:\n\nshould be changed to:\n\nSDL_CreateRGBSurface() and SDL_CreateRGBSurfaceWithFormat() have been combined into a new function SDL_CreateSurface(). SDL_CreateRGBSurfaceFrom() and SDL_CreateRGBSurfaceWithFormatFrom() have been combined into a new function SDL_CreateSurfaceFrom(), and the parameter order has changed for consistency with SDL_CreateSurface().\n\nYou can implement the old functions in your own code easily:\n\nBut if you're migrating your code which uses masks, you probably have a format in mind, possibly one of these:\n\nSDL_BlitSurface() and SDL_BlitSurfaceScaled() now have a const parameter and do not fill it in with the final destination rectangle.\n\nSDL_BlitSurfaceScaled() and SDL_BlitSurfaceUncheckedScaled() now take a scale parameter.\n\nSDL_PixelFormat is used instead of Uint32 for API functions that refer to pixel format by enumerated value.\n\nSDL_SetSurfaceColorKey() takes an bool to enable and disable colorkey. RLE acceleration isn't controlled by the parameter, you should use SDL_SetSurfaceRLE() to change that separately.\n\nSDL_SetSurfaceRLE() takes an bool to enable and disable RLE acceleration.\n\nThe following functions have been renamed:\n\nThe following symbols have been removed:\n\nThe following functions have been removed:\n• SDL_SetYUVConversionMode() - use SDL_SetSurfaceColorspace() to set the surface colorspace and SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER with SDL_CreateTextureWithProperties() to set the texture colorspace. The default colorspace for YUV pixel formats is SDL_COLORSPACE_JPEG.\n\nThe following symbols have been renamed:\n\nSDL_WindowsMessageHook has changed signatures so the message may be modified and it can block further message processing.\n\nSDL_RequestAndroidPermission is no longer a blocking call; the caller now provides a callback function that fires when a response is available.\n\nSDL_iPhoneSetAnimationCallback() and SDL_iPhoneSetEventPump() have been renamed to SDL_SetiOSAnimationCallback() and SDL_SetiOSEventPump(), respectively. SDL2 has had macros to provide this new name with the old symbol since the introduction of the iPad, but now the correctly-named symbol is the only option.\n\nSDL_IsAndroidTV() has been renamed SDL_IsTV() and is no longer Android-specific; an app running on an Apple TV device will also return true, for example.\n\nThe following functions have been removed:\n\nThe following functions have been renamed:\n\nThis header has been removed.\n\nThe Windows and X11 events are now available via callbacks which you can set with SDL_SetWindowsMessageHook() and SDL_SetX11EventHook().\n\nThe information previously available in SDL_GetWindowWMInfo() is now available as window properties, e.g.\n\nSDL_CreateThreadWithStackSize has been replaced with SDL_CreateThreadWithProperties.\n\nSDL_CreateThread and SDL_CreateThreadWithProperties now take beginthread/endthread function pointers on all platforms (ignoring them on most), and have been replaced with macros that hide this detail on all platforms. This works the same as before at the source code level, but the actual function signature that is called in SDL has changed. The library's exported symbol is SDL_CreateThreadRuntime, and looking for \"SDL_CreateThread\" in the DLL/Shared Library/Dylib will fail. You should not call this directly, but instead always use the macro!\n\nSDL_GetTLS() and SDL_SetTLS() take a pointer to a TLS ID, and will automatically initialize it in a thread-safe way as needed.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n\nThe following symbols have been renamed:\n\nSDL_GetTicks() now returns a 64-bit value. Instead of using the SDL_TICKS_PASSED macro, you can directly compare tick values, e.g.\n\nIf you were using this macro for other things besides SDL ticks values, you can define it in your own code as:\n\nThe callback passed to SDL_AddTimer() has changed parameters to:\n\nSDL_GetTouchName is replaced with SDL_GetTouchDeviceName(), which takes an SDL_TouchID instead of an index.\n\nSDL_TouchID and SDL_FingerID are now Uint64 with 0 being an invalid value.\n\nRather than iterating over touch devices using an index, there is a new function SDL_GetTouchDevices() to get the available devices.\n\nRather than iterating over touch fingers using an index, there is a new function SDL_GetTouchFingers() to get the current set of active fingers.\n\nThe following functions have been removed:\n\nSDL_GetRevisionNumber() has been removed from the API, it always returned 0 in SDL 2.0.\n\nSDL_GetVersion() returns the version number, which can be directly compared with another version wrapped with SDL_VERSIONNUM().\n\nThe following structures have been removed:\n\nThe following symbols have been renamed:\n\nSeveral video backends have had their names lower-cased (\"kmsdrm\", \"rpi\", \"android\", \"psp\", \"ps2\", \"vita\"). SDL already does a case-insensitive compare for SDL_HINT_VIDEO_DRIVER tests, but if your app is calling SDL_GetVideoDriver() or SDL_GetCurrentVideoDriver() and doing case-sensitive compares on those strings, please update your code.\n\nSDL_VideoInit() and SDL_VideoQuit() have been removed. Instead you can call SDL_InitSubSystem() and SDL_QuitSubSystem() with SDL_INIT_VIDEO, which will properly refcount the subsystems. You can choose a specific video driver using SDL_HINT_VIDEO_DRIVER.\n\nRather than iterating over displays using display index, there is a new function SDL_GetDisplays() to get the current list of displays, and functions which used to take a display index now take SDL_DisplayID, with an invalid ID being 0.\n\nSDL_CreateWindow() has been simplified and no longer takes a window position. You can use SDL_CreateWindowWithProperties() if you need to set the window position when creating it, e.g.\n\nThe SDL_WINDOWPOS_UNDEFINED_DISPLAY() and SDL_WINDOWPOS_CENTERED_DISPLAY() macros take a display ID instead of display index. The display ID 0 has a special meaning in this case, and is used to indicate the primary display.\n\nThe SDL_WINDOW_SHOWN flag has been removed. Windows are shown by default and can be created hidden by using the SDL_WINDOW_HIDDEN flag.\n\nThe SDL_WINDOW_SKIP_TASKBAR flag has been replaced by the SDL_WINDOW_UTILITY flag, which has the same functionality.\n\nSDL_DisplayMode now includes the pixel density which can be greater than 1.0 for display modes that have a higher pixel size than the mode size. You should use SDL_GetWindowSizeInPixels() to get the actual pixel size of the window back buffer.\n\nThe refresh rate in SDL_DisplayMode is now a float, as well as being represented as a precise fraction with numerator and denominator.\n\nRather than iterating over display modes using an index, there is a new function SDL_GetFullscreenDisplayModes() to get the list of available fullscreen modes on a display.\n\nSDL_GetDesktopDisplayMode() and SDL_GetCurrentDisplayMode() return pointers to display modes rather than filling in application memory.\n\nWindows now have an explicit fullscreen mode that is set, using SDL_SetWindowFullscreenMode(). The fullscreen mode for a window can be queried with SDL_GetWindowFullscreenMode(), which returns a pointer to the mode, or NULL if the window will be fullscreen desktop. SDL_SetWindowFullscreen() just takes a boolean value, setting the correct fullscreen state based on the selected mode.\n\nSDL_WINDOW_FULLSCREEN_DESKTOP has been removed, and you can call SDL_GetWindowFullscreenMode() to see whether an exclusive fullscreen mode will be used or the borderless fullscreen desktop mode will be used when the window is fullscreen.\n\nSDL_SetWindowBrightness(), SDL_GetWindowBrightness, SDL_SetWindowGammaRamp(), and SDL_GetWindowGammaRamp have been removed from the API, because they interact poorly with modern operating systems and aren't able to limit their effects to the SDL window.\n\nPrograms which have access to shaders can implement more robust versions of those functions using custom shader code rendered as a post-process effect.\n\nRemoved SDL_GL_CONTEXT_EGL from OpenGL configuration attributes. You can instead use\n\nSDL_GL_GetProcAddress() and SDL_EGL_GetProcAddress() now return instead of , and should be cast to the appropriate function type. You can define SDL_FUNCTION_POINTER_IS_VOID_POINTER in your project to restore the previous behavior.\n\nSDL_GL_DeleteContext() has been renamed to SDL_GL_DestroyContext to match SDL naming conventions (and glX/EGL!).\n\nSDL_GL_GetSwapInterval() takes the interval as an output parameter and returns true if the function succeeds or false if there was an error.\n\nSDL_GL_GetDrawableSize() has been removed. SDL_GetWindowSizeInPixels() can be used in its place.\n\nThe SDL_WINDOW_TOOLTIP and SDL_WINDOW_POPUP_MENU window flags are now supported on Windows, Mac (Cocoa), X11, and Wayland. Creating windows with these flags must happen via the function. This function requires passing in the handle to a valid parent window for the popup, and the popup window is positioned relative to the parent.\n\nSDL_WindowFlags is used instead of Uint32 for API functions that refer to window flags, and has been extended to 64 bits.\n\nSDL_GetWindowOpacity() directly returns the opacity instead of using an out parameter.\n\nThe following functions have been renamed:\n\nThe following functions have been removed:\n• SDL_GetDisplayDPI() - not reliable across platforms, approximately replaced by multiplying SDL_GetWindowDisplayScale() times 160 on iPhone and Android, and 96 on other platforms.\n• SDL_SetWindowGrab() - use SDL_SetWindowMouseGrab() instead, along with SDL_SetWindowKeyboardGrab() if you also set SDL_HINT_GRAB_KEYBOARD.\n• SDL_GetWindowGrab() - use SDL_GetWindowMouseGrab() instead, along with SDL_GetWindowKeyboardGrab() if you also set SDL_HINT_GRAB_KEYBOARD.\n• SDL_GetWindowData() - use SDL_GetPointerProperty() instead, along with SDL_GetWindowProperties()\n• SDL_SetWindowData() - use SDL_SetPointerProperty() instead, along with SDL_GetWindowProperties()\n• SDL_CreateWindowFrom() - use SDL_CreateWindowWithProperties() with the properties that allow you to wrap an existing window\n• SDL_SetWindowModalFor() - use SDL_SetWindowParent() with SDL_SetWindowModal() instead\n• SDL_SetWindowBrightness() - use a shader or other in-game effect.\n• SDL_GetWindowBrightness() - use a shader or other in-game effect.\n• SDL_SetWindowGammaRamp() - use a shader or other in-game effect.\n• SDL_GetWindowGammaRamp() - use a shader or other in-game effect.\n\nThe following environment variables have been removed:\n\nThe following symbols have been renamed:\n\nThe following symbols have been removed:\n• SDL_WINDOWEVENT_SIZE_CHANGED - handle the SDL_EVENT_WINDOW_RESIZED and SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED events instead\n\nThe following window operations are now considered to be asynchronous requests and should not be assumed to succeed unless a corresponding event has been received:\n\nIf it is required that operations be applied immediately after one of the preceding calls, the function will attempt to wait until all pending window operations have completed. The hint can also be set to automatically synchronize after all calls to an asynchronous window operation, mimicking the behavior of SDL 2. Be aware that synchronizing can potentially block for long periods of time, as it may have to wait for window animations to complete. Also note that windowing systems can deny or not precisely obey these requests (e.g. windows may not be allowed to be larger than the usable desktop space or placed offscreen), so a corresponding event may never arrive or not contain the expected values.\n\nSDL_Vulkan_GetInstanceExtensions() no longer takes a window parameter, and no longer makes the app allocate query/allocate space for the result, instead returning a static const internal string.\n\nSDL_Vulkan_GetVkGetInstanceProcAddr() now returns instead of , and should be cast to PFN_vkGetInstanceProcAddr.\n\nSDL_Vulkan_CreateSurface() now takes a VkAllocationCallbacks pointer as its third parameter. If you don't have an allocator to supply, pass a NULL here to use the system default allocator (SDL2 always used the system default allocator here).\n\nSDL_Vulkan_GetDrawableSize() has been removed. SDL_GetWindowSizeInPixels() can be used in its place.\n\nSDL_vulkanInstance and SDL_vulkanSurface have been removed. They were for compatibility with Tizen, who had built their own Vulkan interface into SDL2, but these apps will need changes for the SDL3 API if they are upgraded anyhow."
    },
    {
        "link": "https://stackoverflow.com/questions/7747008/sdl-getticks-based-movement",
        "document": "I solved it by creating my own Timer class. Technically, what you do is that at constructor you assign a start miliseconds value by using GetTicks()\n\nNow you implement an update() function, in wich you save current ticks every time\n\nThis is not all code but it should give you a point like how to implement it. Since the SDL_ticks are counting miliseconds, you can also implement some convert function for setting time in seconds or so.\n\nIn your game mechanism, whenewer you need to wait, create an instance. Then, call Update() of timer. Good thing is that it does not have to be called regularily, as SDL_getTicks does give you the value every time.\n\nThe thing is to set a callback to a function, depends whether it is member function, then you should use some wrapper. In case of static function, there is nothing to fear and just use classic pointer to function. Lambda and many other things, stoppin, pausding timer can also be implemented, just be creative :]\n\nTo finally answer your question on HOW to make the ball move, you can call some\n\nfunction as callback every single time the time is up. When moving the ball, you should, however, restart the timer. :]"
    },
    {
        "link": "https://stackoverflow.com/questions/31502440/sdl-event-handling-delay",
        "document": "I am fairly sure that it is not a stack, but a queue. The has a somewhat misleading name there; what it really does is shove the event back into the queue from the \"wrong\" end. (It might be implemented internally as a stack, but it's behaviour is that of a queue.)\n\nStill, Qualia's answer is the right way to go.\n\nHowever, I don't agree that it is necessarily bad to have multiple event loops - they can be very useful. 2 scenarios:\n\n1) You catch something like a resize event in your main event loop. If the ensuing operations are very time-consuming the event queue will be flooded with more resize events as long as the user keeps resizing the window.\n\nIn this case, on can have a separate event loop after the time-consuming repaint, which simply loops until it finds the first non-resize event, then pushes the last 2 events it saw back into the queue, and returns control to the main loop. That way you can discard the accumulated resize events. (It can be done more elegantly using the function, especially if there is a really huge pile-up of events in the queue.)\n\n2) The action your program takes after catching a specific event will trigger other events, like when using , which may trigger a multitude of focus and window related subsequent events, especially if you have more than one SDL window. Here, having a separate event loop can be used to deal with these triggered events, especially if the response to these events should be suppressed.\n\nOn the issue of delays, I have also encountered all sorts of strange behaviour with the event, usually the event being triggered multiple times, and definitely not related to OS key repetition. This seems to occur only when using ; , even with the timeout delay set to just '1', seems to inhibit this strange behaviour. Interestingly, the event does not exhibit this behaviour."
    },
    {
        "link": "https://stackoverflow.com/questions/4175362/what-is-the-best-way-to-handle-event-with-sdl-c",
        "document": "Don't bother with another thread. What's the point?\n\nWhat does your main thread do? I imagine something like this:\n\nIf you receive input after (or during) the update cycle then you have to wait till the next update cycle before you'll see the effects. The same is true during rendering. You might as well just check for input before the update cycle and do it all singlethreaded.\n\nMultithreading gains nothing here and just increases complexity.\n\nFor some added reading, check out Christer Ericson's blog post about input latency (he's the director of technology for the team that makes God of War)."
    },
    {
        "link": "https://forums.libsdl.org/viewtopic.php?p=37856",
        "document": "How to poll for SDL events and socket IO? \n\n \n\n I'm trying to write a networked app with OCamlSDL. For the purpose of\n\n the question lets make it something real simple.\n\n \n\n ./sdl-wget \n\n \n\n This connects to the host and sends a GET command to download the\n\n file. While it downloads it should display a progress bar and have a\n\n cancel button.\n\n \n\n So the main loop needs to do 2 things:\n\n \n\n 1) poll the socket for downloaded data\n\n 2) poll SDL for events\n\n \n\n But it seems, and that might be a shortcoming of the ocaml bindings,\n\n that there is no way to poll both. I don't want to set a 0.1s timeout\n\n and switch between the two all the time.\n\n \n\n So how would you do this in C? How do you poll a socket and SDL with a\n\n single blocking call?\n\n \n\n Or does that require using one thread for the SDL part and one for the\n\n socket? And if so can the socket thread update the progress bar while\n\n the SDL thread is blocked in poll?\n\n \n\n MfG\n\n Goswin\n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org Hi,I'm trying to write a networked app with OCamlSDL. For the purpose ofthe question lets make it something real simple../sdl-wget http://host/file This connects to the host and sends a GET command to download thefile. While it downloads it should display a progress bar and have acancel button.So the main loop needs to do 2 things:1) poll the socket for downloaded data2) poll SDL for eventsBut it seems, and that might be a shortcoming of the ocaml bindings,that there is no way to poll both. I don't want to set a 0.1s timeoutand switch between the two all the time.So how would you do this in C? How do you poll a socket and SDL with asingle blocking call?Or does that require using one thread for the SDL part and one for thesocket? And if so can the socket thread update the progress bar whilethe SDL thread is blocked in poll?MfGGoswin_______________________________________________SDL mailing list How to poll for SDL events and socket IO? \n\n \n\n \n\n On Sun, Jul 7, 2013 at 5:26 PM, Goswin von Brederlow wrote:\n\n Hi,\n\n \n\n I'm trying to write a networked app with OCamlSDL. For the purpose of\n\n the question lets make it something real simple.\n\n \n\n ./sdl-wget http://host/file\n\n \n\n This connects to the host and sends a GET command to download the\n\n file. While it downloads it should display a progress bar and have a\n\n cancel button.\n\n \n\n So the main loop needs to do 2 things:\n\n \n\n 1) poll the socket for downloaded data\n\n 2) poll SDL for events\n\n \n\n But it seems, and that might be a shortcoming of the ocaml bindings,\n\n that there is no way to poll both. I don't want to set a 0.1s timeout\n\n and switch between the two all the time.\n\n \n\n So how would you do this in C? How do you poll a socket and SDL with a\n\n single blocking call?\n\n \n\n Or does that require using one thread for the SDL part and one for the\n\n socket? And if so can the socket thread update the progress bar while\n\n the SDL thread is blocked in poll?\n\n \n\n MfG\n\n Â Â Â Â Goswin\n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org\n\n Doing the download in a thread might be the best way to handle that. Â The download thread can post custom progress messages to the SDL event queue as well, if the SDL thread is doing the UI.On Sun, Jul 7, 2013 at 5:26 PM, Goswin von Brederlow wrote: How to poll for SDL events and socket IO? \n\n \n\n Doing the download in a thread might be the best way to handle that. The download thread can post custom progress messages to the SDL event queue as well, if the SDL thread is doing the UI.\n\n \n\n [note Ocaml cannot handle concurrent threads in Ocaml code,\n\n works fine in C callouts though]\n\n \n\n There is nothing wrong with polling loops with delays.\n\n You can do async I/O with that (in Ocaml AFAIK).\n\n \n\n Another alternative is to switch to Felix. This has much of\n\n Ocaml stuff in it (variants, gc, strong typing) but is C/C++\n\n compatible and has SDL binding (work in progress).\n\n \n\n Felix also provides automatic async I/O with event notifications\n\n for most major OS (epoll, poll, select, kqueue, Win32 and Solaris)\n\n [fully transparent]\n\n \n\n \n\n --\n\n john skaller\n\n \n\n http://felix-lang.org\n\n \n\n \n\n \n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On 08/07/2013, at 10:29 AM, Sam Lantinga wrote:[note Ocaml cannot handle concurrent threads in Ocaml code,works fine in C callouts though]There is nothing wrong with polling loops with delays.You can do async I/O with that (in Ocaml AFAIK).Another alternative is to switch to Felix. This has much ofOcaml stuff in it (variants, gc, strong typing) but is C/C++compatible and has SDL binding (work in progress).Felix also provides automatic async I/O with event notificationsfor most major OS (epoll, poll, select, kqueue, Win32 and Solaris)[fully transparent]--john skaller_______________________________________________SDL mailing list How to poll for SDL events and socket IO? So the main loop needs to do 2 things:\n\n \n\n 1) poll the socket for downloaded data\n\n 2) poll SDL for events\n\n \n\n The problem is that, since SDL works with a lot of different APIs on a \n\n lot of different platforms, we can't reasonably select() on a file \n\n handle (or whatever) when polling for events. Some of the targets don't \n\n offer any such thing at all, others offer incompatible ways so you can't \n\n just pile them all into one big call.\n\n \n\n With that in mind, we can't give you a file handle (or several file \n\n handles) to select() on, nor accept a handle from you to add to our \n\n select().\n\n \n\n It has come up before, though, that this would be nice to offer in terms \n\n of power consumption if nothing else, and I think we _could_ get 90% \n\n there (and maybe 100% there in uncomplicated use cases), but it would \n\n take a lot of reworking of SDL's internals...since most things that use \n\n SDL don't actually want to block until there's new data (since they want \n\n to redraw the screen 60 times a second, etc), the gains of reworking \n\n this are questionable...or at least very low priority.\n\n \n\n --ryan.\n\n \n\n \n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org The problem is that, since SDL works with a lot of different APIs on alot of different platforms, we can't reasonably select() on a filehandle (or whatever) when polling for events. Some of the targets don'toffer any such thing at all, others offer incompatible ways so you can'tjust pile them all into one big call.With that in mind, we can't give you a file handle (or several filehandles) to select() on, nor accept a handle from you to add to ourselect().It has come up before, though, that this would be nice to offer in termsof power consumption if nothing else, and I think we _could_ get 90%there (and maybe 100% there in uncomplicated use cases), but it wouldtake a lot of reworking of SDL's internals...since most things that useSDL don't actually want to block until there's new data (since they wantto redraw the screen 60 times a second, etc), the gains of reworkingthis are questionable...or at least very low priority.--ryan._______________________________________________SDL mailing list How to poll for SDL events and socket IO? \n\n \n\n \n\n So the main loop needs to do 2 things:\n\n \n\n 1) poll the socket for downloaded data\n\n 2) poll SDL for events\n\n \n\n The problem is that, since SDL works with a lot of different APIs on a lot of different platforms, we can't reasonably select() on a file handle (or whatever) when polling for events. Some of the targets don't offer any such thing at all, others offer incompatible ways so you can't just pile them all into one big call.\n\n \n\n What do iOS and Android do?\n\n \n\n [I have code that does async I/O on Windows, Solaris, Linux, BSD, OSX, generic Unix,\n\n but not iOS or Android support. However .. it is C++ :]\n\n \n\n --\n\n john skaller\n\n \n\n http://felix-lang.org\n\n \n\n \n\n \n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On 09/07/2013, at 2:12 AM, Ryan C. Gordon wrote:What do iOS and Android do?[I have code that does async I/O on Windows, Solaris, Linux, BSD, OSX, generic Unix,but not iOS or Android support. However .. it is C++ :]--john skaller_______________________________________________SDL mailing list How to poll for SDL events and socket IO? What do iOS and Android do?\n\n \n\n I don't know what Android does; iOS eventually uses Apple's CFRunLoop, \n\n which isn't a select()able object (and maybe we can wrap select()able \n\n things in CFWhatevers, but now it's getting complicated).\n\n \n\n --ryan.\n\n \n\n \n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org I don't know what Android does; iOS eventually uses Apple's CFRunLoop,which isn't a select()able object (and maybe we can wrap select()ablethings in CFWhatevers, but now it's getting complicated).--ryan._______________________________________________SDL mailing list How to poll for SDL events and socket IO? What do iOS and Android do?\n\n \n\n \n\n I don't know what Android does; iOS eventually uses Apple's CFRunLoop, which isn't a select()able object (and maybe we can wrap select()able things in CFWhatevers, but now it's getting complicated).\n\n \n\n \n\n \n\n I think the best way to do this in a cross-platform way, using as low \"power\" as possible, and compatibile with every SDL target is to spawn a new thread and do your network I/O there with a select() call or if you have a single socket with blocking send()/recv(), then you can forward to the SDL loop your events using SDL_USEREVENT.\n\n \n\n \n\n The only penality I see is that to avoid using semaphores or other locking methods you'll have to allocate a buffer for every packet you receive to be passed in your SDL_UserEvent struct Â (the SDL main thread will free the buffer once it processes it).\n\n \n\n \n\n -- \n\n Bye,Â Gabry I think the best way to do this in a cross-platform way, using as low \"power\" as possible, and compatibile with every SDL target is to spawn a new thread and do your network I/O there with a select() call or if you have a single socket with blocking send()/recv(), then you can forward to the SDL loop your events using SDL_USEREVENT.The only penality I see is that to avoid using semaphores or other locking methods you'll have to allocate a buffer for every packet you receive to be passed in your SDL_UserEvent struct Â (the SDL main thread will free the buffer once it processes it).--Bye,Â Gabry How to poll for SDL events and socket IO? \n\n \n\n \n\n \n\n What do iOS and Android do?\n\n \n\n I don't know what Android does; iOS eventually uses Apple's CFRunLoop, which isn't a select()able object (and maybe we can wrap select()able things in CFWhatevers, but now it's getting complicated).\n\n \n\n I think the best way to do this in a cross-platform way, using as low \"power\" as possible, and compatibile with every SDL target is to spawn a new thread and do your network I/O there with a select() call or if you have a single socket with blocking send()/recv(), then you can forward to the SDL loop your events using SDL_USEREVENT.\n\n \n\n The only penality I see is that to avoid using semaphores or other locking methods you'll have to allocate a buffer for every packet you receive to be passed in your SDL_UserEvent struct (the SDL main thread will free the buffer once it processes it).\n\n \n\n Actually you don't. It can work like this:\n\n \n\n (a) client allocates a buffer and intends it be filled from some socket\n\n (b) client posts request to I/O thread\n\n (c) I/O thread monitors socket and fills buffer\n\n (d) I/O threads posts completion notice to client\n\n \n\n Step (d) can use SDL event queue which is already thread safe, so no (additional)\n\n locking is required. Step (b) requires some protocol such as a thread safe\n\n request queue to send the request. Although this can be done with locks\n\n it isn't necessary if you have CAS: queues can be done without locks.\n\n This actually suggests SDL could use a thread safe queue for portability.\n\n \n\n Of course select is a pretty bad way to monitor sockets.\n\n Might be OK for a game client but I'd hate to use it for a server ;(\n\n \n\n \n\n --\n\n john skaller\n\n \n\n http://felix-lang.org\n\n \n\n \n\n \n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On 09/07/2013, at 6:06 PM, Gabriele Greco wrote:Actually you don't. It can work like this:(a) client allocates a buffer and intends it be filled from some socket(b) client posts request to I/O thread(c) I/O thread monitors socket and fills buffer(d) I/O threads posts completion notice to clientStep (d) can use SDL event queue which is already thread safe, so no (additional)locking is required. Step (b) requires some protocol such as a thread saferequest queue to send the request. Although this can be done with locksit isn't necessary if you have CAS: queues can be done without locks.This actually suggests SDL could use a thread safe queue for portability.Of course select is a pretty bad way to monitor sockets.Might be OK for a game client but I'd hate to use it for a server ;(--john skaller_______________________________________________SDL mailing list How to poll for SDL events and socket IO? \n\n \n\n On 08/07/2013, at 10:29 AM, Sam Lantinga wrote:\n\n \n\n Doing the download in a thread might be the best way to handle that. The download thread can post custom progress messages to the SDL event queue as well, if the SDL thread is doing the UI.\n\n \n\n [note Ocaml cannot handle concurrent threads in Ocaml code,\n\n works fine in C callouts though]\n\n \n\n There is nothing wrong with polling loops with delays.\n\n You can do async I/O with that (in Ocaml AFAIK).\n\n \n\n There is everything wrong with polling loops. They needlessly cause\n\n cpu load cause added noise (fan speed increase), heat and battery\n\n drain. Esspecially battery drain is noticable.\n\n \n\n MfG\n\n Goswin\n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On Tue, Jul 09, 2013 at 12:04:24AM +1000, john skaller wrote:There is everything wrong with polling loops. They needlessly causecpu load cause added noise (fan speed increase), heat and batterydrain. Esspecially battery drain is noticable.MfGGoswin_______________________________________________SDL mailing list How to poll for SDL events and socket IO? \n\n \n\n On 09/07/2013, at 6:06 PM, Gabriele Greco wrote:\n\n \n\n \n\n \n\n What do iOS and Android do?\n\n \n\n I don't know what Android does; iOS eventually uses Apple's CFRunLoop, which isn't a select()able object (and maybe we can wrap select()able things in CFWhatevers, but now it's getting complicated).\n\n \n\n I think the best way to do this in a cross-platform way, using as low \"power\" as possible, and compatibile with every SDL target is to spawn a new thread and do your network I/O there with a select() call or if you have a single socket with blocking send()/recv(), then you can forward to the SDL loop your events using SDL_USEREVENT.\n\n \n\n The only penality I see is that to avoid using semaphores or other locking methods you'll have to allocate a buffer for every packet you receive to be passed in your SDL_UserEvent struct (the SDL main thread will free the buffer once it processes it).\n\n \n\n Actually you don't. It can work like this:\n\n \n\n (a) client allocates a buffer and intends it be filled from some socket\n\n (b) client posts request to I/O thread\n\n (c) I/O thread monitors socket and fills buffer\n\n (d) I/O threads posts completion notice to client\n\n \n\n Step (d) can use SDL event queue which is already thread safe, so no (additional)\n\n locking is required. Step (b) requires some protocol such as a thread safe\n\n request queue to send the request. Although this can be done with locks\n\n it isn't necessary if you have CAS: queues can be done without locks.\n\n This actually suggests SDL could use a thread safe queue for portability.\n\n \n\n This is a nice idea but often not that usable. Specifically the server\n\n might send data to the client at any time. Like \"player foo has moved\n\n unit bar to baz\". The client would have to blindly allocate buffers\n\n and request IO in the assumption that something probably will happen.\n\n \n\n I think a better design is for the I/O thread to allocate buffers as\n\n needed, fill them and pass them to the main thread. The main thread\n\n can then either free them when it is done or hand them back to the I/O\n\n thread for reuse.\n\n \n\n Of course select is a pretty bad way to monitor sockets.\n\n Might be OK for a game client but I'd hate to use it for a server ;(\n\n \n\n You would be using poll or epoll where available for scalability\n\n reasons on a server.\n\n \n\n But on a client where you probably only have one socket (and a pipe,\n\n see below) select is perfectly fine.\n\n \n\n \n\n I've implemented the solution with a GUI thread and an IO thread. But\n\n that exposed another kind of problem. The socket can close and then\n\n the IO thread sends a signal to the GUI thread via the sdl event loop.\n\n But the GUI can close too (user hitting the close button). Then the\n\n GUI thread terminates while the IO thread remains stuck in the select\n\n loop.\n\n \n\n Usualy the OS has some way to kill threads or send signals to abort\n\n the select loop. But that seems to have protability problems. So I\n\n came up with another simple solution: a pipe.\n\n \n\n At the start I create a pipe, named kill_pipe. The reading side goes\n\n to the IO thread while the writing side remains with the GUI thread.\n\n The IO thread includes the pipe in the select/poll/epoll call waiting\n\n for read to be possible. When quiting the GUI thread simply closes the\n\n writing end of the pipe. This causes the reading end of the pipe to\n\n become ready for read and wakes up the select/poll/epoll. And the IO\n\n thread detects that the FD ready to read is the kill_pipe and quits\n\n too.\n\n \n\n The same pipe could also be used to send other things, like to return\n\n buffers. Simply write the address of the buffer to it and let the IO\n\n thread read them back. Only on EOF on the pipe the IO thread would\n\n terminate. Instant threadsafe queue.\n\n \n\n MfG\n\n Goswin\n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On Tue, Jul 09, 2013 at 10:02:58PM +1000, john skaller wrote:This is a nice idea but often not that usable. Specifically the servermight send data to the client at any time. Like \"player foo has movedunit bar to baz\". The client would have to blindly allocate buffersand request IO in the assumption that something probably will happen.I think a better design is for the I/O thread to allocate buffers asneeded, fill them and pass them to the main thread. The main threadcan then either free them when it is done or hand them back to the I/Othread for reuse.You would be using poll or epoll where available for scalabilityreasons on a server.But on a client where you probably only have one socket (and a pipe,see below) select is perfectly fine.I've implemented the solution with a GUI thread and an IO thread. Butthat exposed another kind of problem. The socket can close and thenthe IO thread sends a signal to the GUI thread via the sdl event loop.But the GUI can close too (user hitting the close button). Then theGUI thread terminates while the IO thread remains stuck in the selectloop.Usualy the OS has some way to kill threads or send signals to abortthe select loop. But that seems to have protability problems. So Icame up with another simple solution: a pipe.At the start I create a pipe, named kill_pipe. The reading side goesto the IO thread while the writing side remains with the GUI thread.The IO thread includes the pipe in the select/poll/epoll call waitingfor read to be possible. When quiting the GUI thread simply closes thewriting end of the pipe. This causes the reading end of the pipe tobecome ready for read and wakes up the select/poll/epoll. And the IOthread detects that the FD ready to read is the kill_pipe and quitstoo.The same pipe could also be used to send other things, like to returnbuffers. Simply write the address of the buffer to it and let the IOthread read them back. Only on EOF on the pipe the IO thread wouldterminate. Instant threadsafe queue.MfGGoswin_______________________________________________SDL mailing list How to poll for SDL events and socket IO? \n\n \n\n So the main loop needs to do 2 things:\n\n \n\n 1) poll the socket for downloaded data\n\n 2) poll SDL for events\n\n \n\n The problem is that, since SDL works with a lot of different APIs on\n\n a lot of different platforms, we can't reasonably select() on a file\n\n handle (or whatever) when polling for events. Some of the targets\n\n don't offer any such thing at all, others offer incompatible ways so\n\n you can't just pile them all into one big call.\n\n \n\n With that in mind, we can't give you a file handle (or several file\n\n handles) to select() on, nor accept a handle from you to add to our\n\n select().\n\n \n\n It has come up before, though, that this would be nice to offer in\n\n terms of power consumption if nothing else, and I think we _could_\n\n get 90% there (and maybe 100% there in uncomplicated use cases), but\n\n it would take a lot of reworking of SDL's internals...since most\n\n things that use SDL don't actually want to block until there's new\n\n data (since they want to redraw the screen 60 times a second, etc),\n\n the gains of reworking this are questionable...or at least very low\n\n priority.\n\n \n\n --ryan.\n\n \n\n I noticed that too when I straced my binary. Even the event wait\n\n function simply polls 100 times a second in a busy loop. Which makes\n\n my question a bit of a mood point.\n\n \n\n So I've thrown my 2 thread solution with GUI thread and IO thread out\n\n and implemented a simple bussy loop myself:\n\n \n\n let timeout = 0.01\n\n \n\n while true do\n\n (match Sdlevent.poll () with\n\n | None -> ()\n\n | Some event -> ...);\n\n \n\n Net.wait_for_io timeout;\n\n done\n\n \n\n So now I check for some SDL event and then wait up to timeout seconds\n\n for some IO to happen, again and again and again.\n\n \n\n MfG\n\n Goswin\n\n _______________________________________________\n\n SDL mailing list\n\n \n\n http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org On Mon, Jul 08, 2013 at 12:12:57PM -0400, Ryan C. Gordon wrote:I noticed that too when I straced my binary. Even the event waitfunction simply polls 100 times a second in a busy loop. Which makesmy question a bit of a mood point.So I've thrown my 2 thread solution with GUI thread and IO thread outand implemented a simple bussy loop myself:let timeout = 0.01while true do(match Sdlevent.poll () with| None -> ()| Some event -> ...);Net.wait_for_io timeout;doneSo now I check for some SDL event and then wait up to timeout secondsfor some IO to happen, again and again and again.MfGGoswin_______________________________________________SDL mailing list \n\n Design by \n\n Content © SDL\n\n Powered by phpBB © phpBB GroupDesign by Vjacheslav Trushkin for phpBBStyles.com Content © SDL"
    },
    {
        "link": "https://studyplan.dev/sdl2/sdl2-timers",
        "document": "In this lesson, we’ll introduce SDL’s timer mechanisms, which interact with function pointers to implement commonly required functionality. The capabilities this unlocks primarily fall into two categories:\n• Performing an action after a delay, such as restricting the use of an ability until some time has passed\n• Performing an action on a repeating interval, such as spawning a new enemy every few seconds\n\nTo use SDL timers, we should pass the flag to :\n\nWe can combine multiple initialization flags using the bitwise operator:\n\nFor this lesson, let’s imagine we have some object, responsible for adding enemy monsters into the world.\n\nAs a starting point, we’ll create a basic application loop that forwards keydown events to a object:\n\nOur class currently looks like this, which we’ll expand with timers throughout this lesson.\n\nAfter running our program and pressing some keyboard buttons, we should see our responding to events:\n\nis the main way we create timers. It requires three arguments - an unsigned integer representing a time delay in milliseconds, a function pointer we want to call after that delay, and a void pointer ( ).\n\nTo create a timer that invokes after 1,000 milliseconds (one second), our call would look like the following. We’ll discuss what the void pointer is for later - for now, let’s just pass a there:\n\nOur callback should return a and accept and arguments. We’ll discuss what these values represent later - for now, let’s just ignore the parameters and return :\n\nLet’s make our objects invoke one second (1,000 milliseconds) after the space bar is pressed:\n\nRunning our program and pressing the spacebar should generate the expected output after a second:\n\nOur previous example invoked the callback a single time, but allows us to call a function repeatedly based on some time interval.\n\nThe value returned by our callback lets us specify the delay until the function is called again, or we can if we don’t want it to be called again.\n\nLet’s update our program to call every second, by having the function return :\n\nNow, every time we press the spacebar, we kick off an endless sequence that spawns a goblin every second:\n\nRepeated presses of the spacebar will cause multiple timers to run concurrently. We can prevent that if needed:\n\nThe argument passed to our callback represents the current value of the interval. As such, we can improve our previous implementation by returning this value, rather than fixing it to :\n\nOf course, we can use this parameter in any way we want - we don’t just have to return it. In the following example, we halve the interval on every invocation, causing our Goblins to spawn faster over time, capping at every 200 milliseconds:\n\nThe third argument to allows us to pass any arbitrary data to the callback function. The callback receives this as its second argument:\n\nAs usual, we need to the void pointer to the correct type before we can use it. One of our previous examples invoked our callback on a decreasing interval, down to a minimum value of 200 milliseconds.\n\nLet’s update this to allow the caller to specify this minimum value through the void pointer:\n\nGiven the argument is a void pointer, it can point to any type of data we need, including custom data. We just need to update our call to specify the correct type.\n\nLet's define a custom struct that provides both the interval multiplier and minimum value:\n\nAs usual, we should be careful with memory management here. Specifically, we should ensure the memory location being pointing at remains alive as long as the callback still needs it.\n\nThe function returns a timer identifier, which is a simple integer aliased to . This value has two uses. Firstly, we can store it and use it later to cancel the timer. We cover this in the next section Secondly, we can examine its value to check if the timer was created successfully. If the value is , the creation of the timer failed, and we can call to find out why: Let’s update our objects to keep track of the they’re managing: If we need to cancel a timer, we call , and pass the that was returned by the call that we want to cancel. Let’s update our program to allow a timer to be canceled using the escape key: It is safe to pass , or any other integer to this function. It will return if it was able to find and remove the timer, or if no timer was found with the provided ID: If an object is managing a timer and it is no longer relevant after the object is destroyed, we should ensure we remove that timer in the destructor: Example 1 - Interaction with the Event Queue In many scenarios where we’re using a timer, the expiration of that timer represents some event that may be meaningful to other components within our game. As such, objects that create timers will often also broadcast that expiration to our event system. The following example creates and pushes an to SDL’s event queue every time our timer expires: Our previous examples spawned enemies at some regular interval, meaning we have an endless stream of monsters being created. That may be what we want, a common alternative requirement is to respawn enemies some time after they have been defeated. There are a few ways to set this up, but they commonly require the defeated object to notify the relevant spawner that it has been defeated. This can be done through the event queue, or simply by having the enemy remember what spawner created it, and then invoking some function on that spawner at the appropriate time: Our holds a to the it is managing. When that enemy calls its spawner’s method, the spawner will delete the enemy, and create a new one 10 seconds later: We start the by calling : When the it is managing is defeated, it will automatically respawn it: Finally, let’s see a more advanced example. Below, our class is managing two timers:\n• A longer timer called , which changes the behavior of the spawner on a longer interval. Every 30 seconds, the spawner upgrades to spawn more powerful enemies at a shorter interval. To start spawning enemies, we call the method: In this lesson, we've covered SDL's timer functionality and how it integrates with games. Let's recap what we've covered:\n• Managing timer intervals for both one-time and repeating events"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/b80m1v/how_can_i_make_game_run_smooth_in_c",
        "document": "I am making game in c++ using SDL library and I have encountered huge problem that I can't solve for more than month and it absolutely stopped me. Game starts jittering / stuttering every 10 seconds for about 2 seconds.\n\nI have tried several solutions I found anywhere on the internet. First solution was delay, which is the worst solution I have ever encountered since it makes game jitter the most(Delay is very inconsistent), tried: SDL_Delay() and this_thread_sleep_for(). Second solution was vSync which works perfectly except the fact that it works correctly only on 60Hz monitors since loop will run faster on 144Hz and the movement has to be frame based since calculating time in vSync is really weird. Last solution is delta time which I am currently using but it just isn't always smooth which should be in the game that is so simple even I could calculate it myself. I will post code of current deltatime I am using but of course I have tried more than 10+ types of it.\n\nI would like to hear some ideas or just the fact how it's done in games. I have never expected to be stopped by something like this :(\n\nEdit: I have done some changes to the code as some of you advices. I have done profiling with no special results, everything is consistent, performance of CPU, GPU and RAM is same troughout the whole program. I will post my game so that you could see how exactly the problem looks: game."
    }
]