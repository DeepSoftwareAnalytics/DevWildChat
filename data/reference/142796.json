[
    {
        "link": "https://core.telegram.org/method/messages.sendMessage",
        "document": "Groups can be associated to a channel as a discussion group, to allow users to discuss about posts."
    },
    {
        "link": "https://telegram-bot-sdk.readme.io/reference/sendmessage",
        "document": "Use this method to send text messages. On success, the sent Message is returned.\n\nSee sendMessage official docs for a list of supported parameters and other info.\n\nThe Bot API supports basic formatting for messages. You can use bold and italic text, as well as inline links and pre-formatted code in your bots' messages. Telegram clients will render them accordingly. You can use either markdown-style or HTML-style formatting.\n\nNote that Telegram clients will display an alert to the user before opening an inline link (‘Open this link?’ together with the full URL).\n\nTo use this mode, pass Markdown in the parse_mode field when using sendMessage. Use the following syntax in your message:\n\nTo use this mode, pass HTML in the parse_mode field when using sendMessage. The following tags are currently supported:"
    },
    {
        "link": "https://stackoverflow.com/questions/63272437/how-can-i-send-a-message-to-someone-with-telegram-api-using-my-own-account",
        "document": "It's awesome how google something can be annoying when you can't find the right words. I found a million answers on how about to create a Telegram Bot to send and receive messages, and it's easy as write maybe five code lines.\n\nBut how about managing my own account? I want to know if it it's posible, using Python (telepot or other library), to retrieve my personal messages and send messages from my PERSONAL account, not using a bot.\n\nIf it's possible, where can I find more information about that"
    },
    {
        "link": "https://core.telegram.org/bots/api",
        "document": "All queries to the Telegram Bot API must be served over HTTPS and need to be presented in this form: . Like this for example:\n\nThe boost was obtained by the creation of a Telegram Premium or a Telegram Star giveaway. This boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription for Telegram Premium giveaways and prize_star_count / 500 times for one year for Telegram Star giveaways.\n• Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.\n\nUse this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link , where is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.\n\nUse this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success."
    },
    {
        "link": "https://stackoverflow.com/questions/31197659/how-to-send-request-to-telegram-bot-api",
        "document": "You just send a POST request to:\n\nIn the body of the request, you URL encode the parameters:\n\nFor example, in Python using the module:\n\nWhen a user chats with your bot, you get a object that has a chat id (and a user id, which you can substitute for a chat id). There's no way to initiate a chat with a user unless you already know their user id, so you have to wait for a user to talk to you. You can simplify that by using deep linking and having the user click on a link that sends a pre-made message when they hit the Start button.\n\nEdit: for those struggling to find chat_id, here's a way:\n\n1.- Create a bot: on Telegram's search look for @BotFather. Click start, write /newbot, give it a name and a username. You should get a token to access the HTTP API. Save this token.\n\n2.- Find your bot on Telegram with its username. Write something to it e.g. 'test'. This will come in handy later.\n\n3.- Print chat_id. Before running this function, make sure that you have at least written one message to your bot on Telegram (step 2)"
    },
    {
        "link": "https://core.telegram.org/bots/samples",
        "document": ""
    },
    {
        "link": "https://medium.com/@moraneus/building-telegram-bot-with-python-telegram-bot-a-comprehensive-guide-7e33f014dc79",
        "document": "Creating a Telegram bot can significantly extend the functionality of your messaging experience, allowing for everything from automated responses to sophisticated interactions. This comprehensive guide will walk you through the process of building a basic Telegram bot with Python, incorporating user commands, message handling, and custom keyboards. We’ll use the library for its simplicity and powerful features.\n\nIn this article, I will demonstrate a very simple Car Sales Listing Bot that is designed to streamline the process of gathering some necessary information from users wishing to list their cars for sale. By engaging in a structured conversation, the bot collects details such as the car’s type, color, and mileage, and even allows for photo uploads, culminating in a summary that confirms the listing’s details.\n• Ability to upload a photo of the car.\n• Summary of the listing details for confirmation.\n• Create Your Bot: Open Telegram and search for the “BotFather” account. Start a conversation and use the command to create a new bot. Follow the prompts to set up your bot's name and username. BotFather will then give you a token, which is crucial for accessing the Telegram Bot API. Keep this token secure and do not share it.\n\nNow, let’s dive into coding your bot. Please create a new Python file, e.g., and open it in your favorite text editor. Then, follow these steps to write your bot.\n\nStart by importing necessary modules and setting up logging to help with debugging:\n\nStates in a Telegram bot, especially when using a conversation handler, serve as a framework to manage the flow of interaction between the bot and the user. They are essentially markers or checkpoints that define what part of the conversation the user is currently engaged with and determine what the bot should do next based on the user’s input. Here’s a more general overview of the role and functionality of states in managing bot conversations. The purpose and functionality of states in the Telegram bot are:\n• Sequential Flow Management: States allow the bot to manage a sequential flow of conversation. By moving from one state to another, the bot can guide the user through a series of steps, questions, or options in a logical order.\n• Context Awareness: They help the bot maintain context in a conversation. By knowing the current state, the bot understands what information has been provided by the user and what information is still needed, enabling it to respond appropriately.\n• User Input Processing: Based on the current state, the bot can process user inputs differently. For example, an input in the “CAR_TYPE” state would be understood as the user specifying the type of car they’re selling, while the same input in the “CAR_COLOR” state would be interpreted as the color of the car.\n• Conditional Logic Implementation: States allow for the implementation of conditional logic in the conversation. Depending on user responses or choices, the bot can decide to skip certain states, repeat them, or take the user down a different conversational path.\n• Error Handling and Repetition: They facilitate error handling and the repetition of questions if the user provides unexpected or invalid responses. By keeping track of the current state, the bot can re-prompt the user for information correctly.\n• State Persistence: In more complex bots, states can be stored and persisted across sessions, allowing users to pick up the conversation where they left off, even if they temporarily leave the chat or if the bot restarts.\n\nLet’s enumerate the states for our bot to manage the flow:\n\nConversation handlers in Telegram bots, particularly when using libraries like , are powerful tools that manage the flow of conversations based on user inputs and predefined states. They are crucial for developing bots that require a sequence of interactions, such as collecting information, guiding users through menus, or executing commands in a specific order. Here's a closer look at how conversation handlers work and their role in bot development:\n• Managing Conversational States: Conversation handlers keep track of the current state of the dialogue with each user. They determine what the bot should do next based on the user’s input and the current state, allowing for a smooth and logical progression through different stages of interaction.\n• Routing User Inputs: They route user inputs to different callback functions based on the current state. This means that the same input can lead to different outcomes depending on where the user is in the conversation flow.\n• Handling Commands and Text: Conversation handlers can differentiate between commands (like or ) and regular text messages, allowing developers to specify distinct responses or actions for each type of input.\n• Integrating with Keyboards and Buttons: They work seamlessly with custom keyboards and inline buttons, enabling developers to create interactive and user-friendly interfaces within the conversation. Users can select options or navigate through the bot’s features using these UI elements.\n• Fallbacks and Timeouts: Conversation handlers support fallback functions, which can be triggered when the user sends unexpected input or when the conversation needs to be reset. They can also handle timeouts, ending a conversation automatically after a period of inactivity.\n• Entry Points: These are triggers that start the conversation. Commonly, the command is used as an entry point, but you can define multiple entry points for different conversation flows.\n• States: As discussed, states represent different points in the conversation. Each state is associated with one or more callback functions that define the bot’s behavior at that stage. Developers map states to these callbacks, dictating the flow of the conversation.\n• Fallbacks: Fallback functions are defined to handle unexpected situations or to provide a way to exit or reset the conversation. A common fallback is a command that allows users to stop the conversation at any point.\n\nFollowing, is the handler function initiates the conversation (entry point), presenting the user with a selection of car types:\n\nHere you can find the rest of the handlers:\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sport\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\nIn the function, set up the and , including entry points, states, and fallbacks. Start the bot with polling to listen for updates:\n\nComplete your script with a call to the function. Run your bot by executing the Python script in your terminal.\n\nHere you can find the whole code:\n\nimport logging\n\nfrom telegram import (ReplyKeyboardMarkup, ReplyKeyboardRemove, Update,\n\n InlineKeyboardButton, InlineKeyboardMarkup)\n\nfrom telegram.ext import (Application, CallbackQueryHandler, CommandHandler,\n\n ContextTypes, ConversationHandler, MessageHandler, filters)\n\n\n\n# Enable logging\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\n level=logging.INFO)\n\n\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Define states\n\nCAR_TYPE, CAR_COLOR, CAR_MILEAGE_DECISION, CAR_MILEAGE, PHOTO, SUMMARY = range(6)\n\n\n\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Starts the conversation and asks the user about their preferred car type.\"\"\"\n\n reply_keyboard = [['Sedan', 'SUV', 'Sports', 'Electric']]\n\n\n\n await update.message.reply_text(\n\n '<b>Welcome to the Car Sales Listing Bot!\n\n'\n\n 'Let\\'s get some details about the car you\\'re selling.\n\n'\n\n 'What is your car type?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True, resize_keyboard=True),\n\n )\n\n\n\n return CAR_TYPE\n\n\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"🚗\", \"SUV\": \"🚙\", \"Sports\": \"🏎️\", \"Electric\": \"⚡\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car 📷, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car 📷, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\n\n\n\n\ndef main() -> None:\n\n \"\"\"Run the bot.\"\"\"\n\n application = Application.builder().token(\"YOUR TOKEN HERE\").build()\n\n\n\n conv_handler = ConversationHandler(\n\n entry_points=[CommandHandler('start', start)],\n\n states={\n\n CAR_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_type)],\n\n CAR_COLOR: [CallbackQueryHandler(car_color)],\n\n CAR_MILEAGE_DECISION: [CallbackQueryHandler(car_mileage_decision)],\n\n CAR_MILEAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_mileage)],\n\n PHOTO: [\n\n MessageHandler(filters.PHOTO, photo),\n\n CommandHandler('skip', skip_photo)\n\n ],\n\n SUMMARY: [MessageHandler(filters.ALL, summary)]\n\n },\n\n fallbacks=[CommandHandler('cancel', cancel)],\n\n )\n\n\n\n application.add_handler(conv_handler)\n\n\n\n # Handle the case when a user sends /start but they're not in a conversation\n\n application.add_handler(CommandHandler('start', start))\n\n\n\n application.run_polling()\n\n\n\n\n\nif __name__ == '__main__':\n\n main()\n\nStep 3: Testing and Interacting with Your Bot\n\nAfter running your script, find your bot on Telegram and start interacting with it. You should now be able to use the command to start a conversation, which will guide you through listing a car for sale."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot",
        "document": "We have made you a wrapper you can't refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nThis library provides a pure Python, asynchronous interface for the Telegram Bot API. It's compatible with Python versions 3.9+.\n\nIn addition to the pure API implementation, this library features several convenience methods and shortcuts as well as a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the submodule.\n\nAfter installing the library, be sure to check out the section on working with PTB.\n\nAll types and methods of the Telegram Bot API 8.3 are natively supported by this library. In addition, Bot API functionality not yet natively included can still be used as described in our wiki.\n\nYou can install or upgrade via\n\nTo install a pre-release, use the flag in addition.\n\nYou can also install from source, though this is usually not necessary.\n\nTo enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures.\n\nStarting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value .\n\nEarlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format .\n\nIn addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix .\n\ntries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don't need the optional features.\n\nThe only required dependency is httpx ~= 0.27 for , the default networking backend.\n\nis most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out.\n\nPTB can be installed with optional dependencies:\n• installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• installs httpx[http2]. Use this, if you want to use HTTP/2.\n• installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• installs the tornado~=6.4 library. Use this, if you want to use / .\n• installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the .\n\nTo install multiple optional dependencies, separate them by commas, e.g. .\n• installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let's get started!\n\nOur Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• The official Telegram Bot API documentation is of course always worth a read.\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n• We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• You can even ask for help on Stack Overflow using the python-telegram-bot tag.\n\nSince v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• all classes in the module that allow to add/remove allowed users/chats at runtime\n\nContributions of all sizes are welcome. Please review our contribution guidelines to get started. You can also help by reporting bugs or feature requests.\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be."
    },
    {
        "link": "https://docs.python-telegram-bot.org/en/v21.10/examples.html",
        "document": "In this section we display small examples to show what a bot written with looks like. Some bots focus on one specific aspect of the Telegram Bot API while others focus on one of the mechanics of this library. Except for the rawapibot.py example, they all use the high-level framework this library provides with the submodule.\n\nAll examples are licensed under the CC0 License and are therefore fully dedicated to the public domain. You can use them as the base for your own bots without worrying about copyrights.\n\nDo note that we ignore one pythonic convention. Best practice would dictate, in many handler callbacks function signatures, to replace the argument with an underscore, since is an unused local variable in those callbacks. However, since these are examples and not having a name for that argument confuses beginners, we decided to have it present.\n\nThis bot uses the class to send timed messages. The user sets a timer by using command with a specific time, for example . The bot then sets up a job to send a message to that user after 30 seconds. The user can also cancel the timer by sending . To learn more about the , read this wiki article. Note: To use , you must install PTB via\n\nA common task for a bot is to ask information from the user. In v5.0 of this library, we introduced the for that exact purpose. This example uses it to retrieve user-information in a conversation-like style. To get a better understanding, take a look at the state diagram.\n\nA even more complex example of a bot that uses the nested s. While it’s certainly not that complex that you couldn’t built it without nested s, it gives a good impression on how to work with them. Of course, there is a fancy state diagram for this example, too!\n\nA basic example of how Telegram WebApps can be used. Use in combination with the HTML page. For your convenience, this file is hosted by the PTB team such that you don’t need to host it yourself. Uses the iro.js JavaScript library to showcase a user interface that is hard to achieve with native Telegram functionality."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-create-a-telegram-bot-using-python",
        "document": "Automated chatbots are quite useful for stimulating interactions. We can create chatbots for Slack, Discord, and other platforms.\n\nIn this article, I'll teach you how to build a Telegram chatbot that will tell you your horoscope. So, let’s get started!\n\nHow to Get Your Bot Token\n\nTo set up a new bot, you will need to talk to BotFather. No, he’s not a person – he’s also a bot, and he's the boss of all the Telegram bots.\n• Start a conversation with BotFather by clicking on the Start button.\n• Type , and follow the prompts to set up a new bot. The BotFather will give you a token that you will use to authenticate your bot and grant it access to the Telegram API.\n\nNote: Make sure you store the token securely. Anyone with your token access can easily manipulate your bot.\n\nHow to Set Up Your Coding Environment\n\nLet’s set up the coding environment. While there are various libraries available to create a Telegram bot, we’ll use the pyTelegramBotAPI library. It is a simple but extensible Python implementation for the Telegram Bot API with both synchronous and asynchronous capabilities.\n\nNext, open your favorite code editor and create a file to store your token as below:\n\nAfter that, run the command to read the environment variables from the file.\n\nHow to Create Your First Bot\n\nAll the API implementations are stored in a single class called . It offers many ways to listen for incoming messages as well as functions like , , and others to send messages.\n\nCreate a new file and paste the following code there:\n\nIn the above code, we use the library in order to read the environment variables stored in our system.\n\nIf you remember, we exported an environment variable called in the previous step. The value of is read in a variable called . Further, we use the class to create a bot instance and passed the to it.\n\nWe then need to register message handlers. These message handlers contain filters that a message must pass. If a message passes the filter, the decorated function is called and the incoming message is supplied as an argument.\n\nAny name is acceptable for a function that is decorated by a message handler, but it can only have one parameter (the message).\n\nLet’s add another handler that echoes all incoming text messages back to the sender.\n\nThe above code uses a expression to test a message. Since we need to echo all the messages, we always return from the function.\n\nYou now have a simple bot that responds to the and commands with a static message and echoes all the other sent messages. Add the following to the end of your file to launch the bot:\n\nThat’s it! We have a Telegram bot ready. Let’s run the Python file and go to Telegram to test the bot.\n\nSearch for the bot using its username if you’re unable to find it. You can test it by sending the commands like and and other random texts.\n\nNote: All the message handlers are tested in the order in which they were declared in the source file.\n\nFor more information on using the pyTelegramBotAPI library, you can refer to their documentation.\n\nHow to Code the Horoscope Bot\n\nLet’s shift our attention to building our Horoscope Bot now. We will use message chaining in the bot. The bot will first ask for your zodiac sign, and then the day, and then it will respond with the horoscope for that particular day.\n\nUnder the hood, the bot interacts with an API to get the horoscope data.\n\nWe are going to use the Horoscope API that I built in another tutorial. If you wish to learn how to build one, you can go through this tutorial. Make sure you explore the APIs here before getting started.\n\nHow to fetch the horoscope data\n\nLet’s create a utility function to fetch the horoscope data for a particular day.\n\nIn the above Python code, we created a function that accepts two string arguments – and – and returns JSON data. We send a GET request on the API URL and pass and as the query parameters.\n\nIf you test the function, you will get an output similar to below:\n\nNote: You can explore more about the library in Python in this tutorial.\n\nNow that we have a function that returns the horoscope data, let’s create a message handler in our bot that asks for the zodiac sign of the user.\n\nThe above function is a bit different from the other functions we defined earlier. The bot’s horoscope functionality will be invoked by the command. We are sending a text message to the user, but notice that we have set the to Markdown while sending the message.\n\nSince we’ll use message chaining, we used the method. This method accepts two parameters: the message sent by the user and the callback function which should be called after the message. Thus, we pass the variable and a new function that we’ll define next.\n\nLet’s define the function that accepts the message.\n\nWe fetch the zodiac sign from the attribute. Similar to the previous function, it also asks the day for which you want to know the horoscope.\n\nIn the end, we use the same method and pass the , the callback function, and the .\n\nLet’s now define the function that accepts the message and the sign.\n\nThis is the final function where we get the sign from the function parameter and the day from the attribute.\n\nNext, we fetch the horoscope using the function and construct our message. In the end, we send the message with the horoscope data.\n\nOnce you run the Python file, you can test this functionality. Here’s the demo:\n\nAs of now, the bot stops working as soon as we stop our Python application. In order to make it run always, you can deploy the bot on platforms like Heroku, Render, and so on.\n\nHere's a link to the GitHub repo for this project - feel free to check it out.\n\nYou can also add more functionalities to the bot by exploring the Telegram APIs.\n\nThanks for reading! You can follow me on Twitter."
    }
]