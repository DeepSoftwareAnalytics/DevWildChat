[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/library/builtins.html",
        "document": "This module provides direct access to all ‘built-in’ identifiers of Python; for example, is the full name for the built-in function .\n\nThis module is not normally accessed explicitly by most applications, but can be useful in modules that provide objects with the same name as a built-in value, but in which the built-in of that name is also needed. For example, in a module that wants to implement an function that wraps the built-in , this module can be used directly:\n\nAs an implementation detail, most modules have the name made available as part of their globals. The value of is normally either this module or the value of this module’s attribute. Since this is an implementation detail, it may not be used by alternate implementations of Python."
    },
    {
        "link": "https://docs.python.org",
        "document": "What's new in Python 3.13?\n\n Or all \"What's new\" documents since Python 2.0\n\nTutorial\n\n Start here: a tour of Python's syntax and features\n\nPython setup and usage\n\n How to install, configure, and use Python"
    },
    {
        "link": "https://docs.python.org/3/whatsnew/3.10.html",
        "document": "This article explains the new features in Python 3.10, compared to 3.9. Python 3.10 was released on October 4, 2021. For full details, see the changelog.\n\nUsing enclosing parentheses for continuation across multiple lines in context managers is now supported. This allows formatting a long collection of context managers in multiple lines in a similar way as it was previously possible with import statements. For instance, all these examples are now valid: it is also possible to use a trailing comma at the end of the enclosed group: This new syntax uses the non LL(1) capacities of the new parser. Check PEP 617 for more details. When parsing code that contains unclosed parentheses or brackets the interpreter now includes the location of the unclosed bracket of parentheses instead of displaying SyntaxError: unexpected EOF while parsing or pointing to some incorrect location. For instance, consider the following code (notice the unclosed ‘{‘): Previous versions of the interpreter reported confusing places as the location of the syntax error: but in Python 3.10 a more informative error is emitted: In a similar way, errors involving unclosed string literals (single and triple quoted) now point to the start of the string instead of reporting EOF/EOL. These improvements are inspired by previous work in the PyPy interpreter. exceptions raised by the interpreter will now highlight the full error range of the expression that constitutes the syntax error itself, instead of just where the problem is detected. In this way, instead of displaying (before Python 3.10): now Python 3.10 will display the exception as: This improvement was contributed by Pablo Galindo in bpo-43914. A considerable amount of new specialized messages for exceptions have been incorporated. Some of the most notable ones are as follows:\n• File , line : did you forget parentheses around the comprehension target?\n• None Missing commas in collection literals and between expressions:\n• None Usage of instead of in comparisons: File , line : cannot assign to attribute here. Maybe you meant '==' instead of '='?\n• File , line : f-string: cannot use starred expression here Many exceptions now have more context regarding what kind of block was expecting an indentation, including the location of the statement: File , line : expected an indented block after 'if' statement in line 2 When printing , will offer suggestions of similar attribute names in the object that the exception was raised from: File , line , in : module 'collections' has no attribute 'namedtoplo'. Did you mean: namedtuple? Notice this won’t work if is not called to display the error which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. When printing raised by the interpreter, will offer suggestions of similar variable names in the function that the exception was raised from: File , line , in : name 'schwarschild_black_hole' is not defined. Did you mean: schwarzschild_black_hole? Notice this won’t work if is not called to display the error, which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. Structural pattern matching has been added in the form of a match statement and case statements of patterns with associated actions. Patterns consist of sequences, mappings, primitive data types as well as class instances. Pattern matching enables programs to extract information from complex data types, branch on the structure of data, and apply specific actions based on different forms of data. The generic syntax of pattern matching is: A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. Specifically, pattern matching operates by:\n• None using data with type and shape (the )\n• None evaluating the in the statement\n• None comparing the subject with each pattern in a statement from top to bottom until a match is confirmed.\n• None executing the action associated with the pattern of the confirmed match\n• None If an exact match is not confirmed, the last case, a wildcard , if provided, will be used as the matching case. If an exact match is not confirmed and a wildcard case does not exist, the entire match block is a no-op. Readers may be aware of pattern matching through the simple example of matching a subject (data object) to a literal (pattern) with the switch statement found in C, Java or JavaScript (and many other languages). Often the switch statement is used for comparison of an object/expression with case statements containing literals. More powerful examples of pattern matching can be found in languages such as Scala and Elixir. With structural pattern matching, the approach is “declarative” and explicitly states the conditions (the patterns) for data to match. While an “imperative” series of instructions using nested “if” statements could be used to accomplish something similar to structural pattern matching, it is less clear than the “declarative” approach. Instead the “declarative” approach states the conditions to meet for a match and is more readable through its explicit patterns. While structural pattern matching can be used in its simplest form comparing a variable to a literal in a case statement, its true value for Python lies in its handling of the subject’s type and shape. Let’s look at this example as pattern matching in its simplest form: a value, the subject, being matched to several literals, the patterns. In the example below, is the subject of the match statement. The patterns are each of the case statements, where literals represent request status codes. The associated action to the case is executed after a match: If the above function is passed a of 418, “I’m a teapot” is returned. If the above function is passed a of 500, the case statement with will match as a wildcard, and “Something’s wrong with the internet” is returned. Note the last block: the variable name, , acts as a wildcard and insures the subject will always match. The use of is optional. You can combine several literals in a single pattern using (“or”): If we modify the above example by removing the last case block, the example becomes: Without the use of in a case statement, a match may not exist. If no match exists, the behavior is a no-op. For example, if of 500 is passed, a no-op occurs. Patterns can look like unpacking assignments, and a pattern may be used to bind variables. In this example, a data point can be unpacked to its x-coordinate and y-coordinate: The first pattern has two literals, , and may be thought of as an extension of the literal pattern shown above. The next two patterns combine a literal and a variable, and the variable binds a value from the subject ( ). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment . If you are using classes to structure your data, you can use as a pattern the class name followed by an argument list resembling a constructor. This pattern has the ability to capture class attributes into variables: and the point is on the y-axis.\" and the point is on the x-axis.\" \"The point is located somewhere else on the plane.\" You can use positional parameters with some builtin classes that provide an ordering for their attributes (e.g. dataclasses). You can also define a specific position for attributes in patterns by setting the special attribute in your classes. If it’s set to (“x”, “y”), the following patterns are all equivalent (and all bind the attribute to the variable): Patterns can be arbitrarily nested. For example, if our data is a short list of points, it could be matched like this: \"The origin is the only point in the list.\" \"Two points on the Y axis at \"Something else is found in the list.\" To this point, the examples have used alone in the last case statement. A wildcard can be used in more complex patterns, such as . For example: In the above case, will match for (‘error’, code, 100) and (‘error’, code, 800). We can add an clause to a pattern, known as a “guard”. If the guard is false, goes on to try the next case block. Note that value capture happens before the guard is evaluated: \"The point is located on the diagonal Y=X at \"Point is not on the diagonal.\"\n• None Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. Technically, the subject must be a sequence. Therefore, an important exception is that patterns don’t match iterators. Also, to prevent a common mistake, sequence patterns don’t match strings.\n• None Sequence patterns support wildcards: and work similar to wildcards in unpacking assignments. The name after may also be , so matches a sequence of at least two items without binding the remaining items.\n• None Mapping patterns: captures the and values from a dict. Unlike sequence patterns, extra keys are ignored. A wildcard is also supported. (But would be redundant, so is not allowed.)\n• None Subpatterns may be captured using the keyword: This binds x1, y1, x2, y2 like you would expect without the clause, and p2 to the entire second item of the subject.\n• None Most literals are compared by equality. However, the singletons , and are compared by identity.\n• None Named constants may be used in patterns. These named constants must be dotted names to prevent the constant from being interpreted as a capture variable: For the full specification see PEP 634. Motivation and rationale are in PEP 635, and a longer tutorial is in PEP 636. The default encoding of and is platform and locale dependent. Since UTF-8 is used on most Unix platforms, omitting option when opening UTF-8 files (e.g. JSON, YAML, TOML, Markdown) is a very common bug. For example: # BUG: \"rb\" mode or encoding=\"utf-8\" should be used. To find this type of bug, an optional is added. It is emitted when is true and locale-specific default encoding is used. option and are added to enable the warning. See Text Encoding for more information.\n• None Currently Python accepts numeric literals immediately followed by keywords, for example , , . It allows confusing and ambiguous expressions like (which can be interpreted as or ). Starting in this release, a deprecation warning is raised if the numeric literal is immediately followed by one of keywords , , , , , and . In future releases it will be changed to syntax warning, and finally to syntax error. (Contributed by Serhiy Storchaka in bpo-43833.)\n• None Starting in this release, there will be a concerted effort to begin cleaning up old import semantics that were kept for Python 2.7 compatibility. Specifically, / (superseded by ), (superseded by ), (which the import system takes care of for you), the attribute (superseded by ), the attribute (superseded by ), and the attribute (superseded by ) will slowly be removed (as well as other classes and methods in ). and/or will be raised as appropriate to help identify code which needs updating during this transition.\n• None The entire namespace is deprecated, to be removed in Python 3.12. Refer to the module changes section for more information.\n• None Non-integer arguments to are deprecated. The is deprecated in favor of a . (Contributed by Serhiy Storchaka and Raymond Hettinger in bpo-37319.)\n• None The various methods of have been documented as deprecated since Python 3.6, but will now also trigger a . Use instead. (Contributed by Brett Cannon in bpo-26131.)\n• None has been deprecated in preference for . (Contributed by Brett Cannon in bpo-26131.)\n• None The use of by the import system now triggers an as is preferred. (Contributed by Brett Cannon in bpo-26131.)\n• None The use of and by the import system now trigger an as and are preferred, respectively. You can use to help in porting. (Contributed by Brett Cannon in bpo-42134.)\n• None The use of by the import system now triggers an as is preferred. You can use to help in porting. (Contributed by Brett Cannon in bpo-43672.)\n• None The various implementations of ( , , , , ), ( ), and ( ) now raise and are slated for removal in Python 3.12 (previously they were documented as deprecated in Python 3.4). (Contributed by Brett Cannon in bpo-42135.)\n• None is deprecated (including its sole method, ). Both and no longer inherit from the class. Users should inherit from one of these two classes as appropriate instead. (Contributed by Brett Cannon in bpo-42135.)\n• None The deprecations of , , , , , , and have all been updated to list Python 3.12 as the slated version of removal (they began raising in previous versions of Python). (Contributed by Brett Cannon in bpo-43720.)\n• None The import system now uses the attribute on modules before falling back on for a module’s method. Removal of the use of is scheduled for Python 3.12. (Contributed by Brett Cannon in bpo-42137.)\n• None , , and are deprecated and slated for removal in Python 3.12. (Contributed by Brett Cannon in bpo-42136.)\n• None has been undocumented and obsolete since Python 3.3, when it was made an alias to . It is now deprecated, scheduled for removal in Python 3.12. (Contributed by Erlend E. Aasland in bpo-42264.)\n• None The undocumented built-in function is now deprecated, scheduled for removal in Python 3.12. Its use is strongly discouraged by the SQLite3 documentation. See the SQLite3 docs for more details. If a shared cache must be used, open the database in URI mode using the query parameter. (Contributed by Erlend E. Aasland in bpo-24464.)\n• None The following methods are now deprecated:\n• None is deprecated and slated for removal in Python 3.12. Use instead. (Contributed by Barney Gale in bpo-39950.)\n• None is deprecated and slated for removal in Python 3.12. (Contributed by Inada Naoki in bpo-41139.)\n• None The following features have been deprecated since Python 3.6, Python 3.7, or OpenSSL 1.1.0 and will be removed in 3.11:\n• None , , , , , and are replaced by and .\n• None , , , , , , and are deprecated in favor of and\n• None NPN features like and are replaced by ALPN.\n• None The threading debug ( environment variable) is deprecated in Python 3.10 and will be removed in Python 3.12. This feature requires a debug build of Python. (Contributed by Victor Stinner in bpo-44584.)\n• None Importing from the and submodules will now emit . These submodules will be removed in a future version of Python. Anything belonging to these submodules should be imported directly from instead. (Contributed by Sebastian Rittau in bpo-38291.)"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/7axje4/how_to_read_the_documentation_of_python_3",
        "document": "I know this a rather stupid question, but I am really having a problem reading the documentation. Instead of googling, I am trying to read the official documentation instead.\n\nNow, I am trying to lookup regarding the type(). I want to know what data format is the output in. I want to check is the variable is of type int. I want to know when I pass type(<var>), what will I be returned. If it will return int or int32 or integer.\n\nI want to know how to properly search the documentation.\n• Then I even tried type object.\n\nI am still clueless. So I decided to google. At tutorialspoint, the example also does not work.\n\nI want to learn how to search effectively the official manual and not depend on some code written in some blog post or forums.\n\nHow will a pro research? Please take me through the steps."
    },
    {
        "link": "https://geeksforgeeks.org/read-a-file-line-by-line-in-python",
        "document": "Python provides built-in functions for creating, writing, and reading files. Two types of files can be handled in Python, normal text files and binary files (written in binary language, 0s, and 1s). In this article, we are going to study reading line by line from a file.\n\nAn iterable object is returned by open() function while opening a file. This final way of reading a file line-by-line includes iterating over a file object in a loop. In doing this we are taking advantage of a built-in Python function that allows us to iterate over the file object implicitly using a for loop in combination with using the iterable object.\n\nA list comprehension consists of brackets containing the expression, which is executed for each element along with the for loop to iterate over each element. Here, we will read the text file and print the raw data including the new line character in another output we removed all the new line characters from the list.\n\nPython readlines() is used to read all the lines at a single go and then return them as each line a string element in a list. This function can be used for small files, as it reads the whole file content to the memory, then split it into separate lines. We can iterate over the list and strip the newline ‘\n\n’ character using strip() function.\n\nUsing Python With statement, the file must be explicitly closed, and forgetting to do so can cause bugs, as changes may not take effect. To prevent this, the statement can be used. It simplifies resource management like file streams, ensuring proper handling and making the code cleaner by automatically closing the file, without needing .\n\nHow to read lines in a file in Python?\n\nHow to read file line by line using while in Python?\n\nHow to read file line by line using while in Python?\n\nWhat does readline() do in Python?\n\nHow to read a specific portion of a file in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/53283718/reading-a-file-line-by-line-in-python",
        "document": "I am pretty new to Python. So I was trying out my first basic piece of code. So i was trying to read a file and print it line by line in Python. Here is my code:\n\nNow When I run it, I get no output. So I tried debugging it. I see the control jumps from one method to another (main --> printData) and then exists. Its doesn't execute anything within the method. Can you tell me what am I doing wrong here? I am new, so a little insight as to why the code is behaving this way would be nice as well."
    },
    {
        "link": "https://stackoverflow.com/questions/3277503/how-to-read-a-file-line-by-line-into-a-list",
        "document": "To read a file into a list you need to do three things:\n\nFortunately Python makes it very easy to do these things so the shortest way to read a file into a list is:\n\nHowever I'll add some more explanation.\n\nI assume that you want to open a specific file and you don't deal directly with a file-handle (or a file-like-handle). The most commonly used function to open a file in Python is , it takes one mandatory argument and two optional ones in Python 2.7:\n• Buffering (I'll ignore this argument in this answer)\n\nThe filename should be a string that represents the path to the file. For example:\n\nNote that the file extension needs to be specified. This is especially important for Windows users because file extensions like or , etc. are hidden by default when viewed in the explorer.\n\nThe second argument is the , it's by default which means \"read-only\". That's exactly what you need in your case.\n\nBut in case you actually want to create a file and/or write to a file you'll need a different argument here. There is an excellent answer if you want an overview.\n\nFor reading a file you can omit the or pass it in explicitly:\n\nBoth will open the file in read-only mode. In case you want to read in a binary file on Windows you need to use the mode :\n\nOn other platforms the (binary mode) is simply ignored.\n\nNow that I've shown how to the file, let's talk about the fact that you always need to it again. Otherwise it will keep an open file-handle to the file until the process exits (or Python garbages the file-handle).\n\nWhile you could use:\n\nThat will fail to close the file when something between and throws an exception. You could avoid that by using a and :\n\nHowever Python provides context managers that have a prettier syntax (but for it's almost identical to the and above):\n\nThe last approach is the recommended approach to open a file in Python!\n\nOkay, you've opened the file, now how to read it?\n\nThe function returns a object and it supports Pythons iteration protocol. Each iteration will give you a line:\n\nThis will print each line of the file. Note however that each line will contain a newline character at the end (you might want to check if your Python is built with universal newlines support - otherwise you could also have on Windows or on Mac as newlines). If you don't want that you can could simply remove the last character (or the last two characters on Windows):\n\nBut the last line doesn't necessarily has a trailing newline, so one shouldn't use that. One could check if it ends with a trailing newline and if so remove it:\n\nBut you could simply remove all whitespaces (including the character) from the end of the string, this will also remove all other trailing whitespaces so you have to be careful if these are important:\n\nHowever if the lines end with (Windows \"newlines\") that will also take care of the !\n\nNow that you know how to open the file and read it, it's time to store the contents in a list. The simplest option would be to use the function:\n\nIn case you want to strip the trailing newlines you could use a list comprehension instead:\n\nOr even simpler: The method of the object by default returns a of the lines:\n\nThis will also include the trailing newline characters, if you don't want them I would recommend the approach because it avoids keeping two lists containing all the lines in memory.\n\nThere's an additional option to get the desired output, however it's rather \"suboptimal\": the complete file in a string and then split on newlines:\n\nThese take care of the trailing newlines automatically because the character isn't included. However they are not ideal because you keep the file as string and as a list of lines in memory!\n• Use when opening files because you don't need to take care of closing the file yourself and it closes the file even if some exception happens.\n• objects support the iteration protocol so reading a file line-by-line is as simple as .\n• Always browse the documentation for the available functions/classes. Most of the time there's a perfect match for the task or at least one or two good ones. The obvious choice in this case would be but if you want to process the lines before storing them in the list I would recommend a simple list-comprehension."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-read-a-file-line-by-line-in-python",
        "document": "When coding in Python, there may be times when you need to open and read the contents of a text file.\n\nLuckily enough, there are several ways to do this in Python.\n\nThe language has many built-in functions, methods, and keywords that you can use to create, write, read and delete text files.\n\nIn this article, you'll learn the most common ways of reading a file. With the help of coding examples, you will know how to read a text file line by line.\n\nHere is what we will cover:\n• How to open a text file using the function\n• How to read a text file using the method\n• How to read a text file using the method\n• How to Read a text file using the method\n• How to read a text file using a loop\n\nHow to Open a Text File Using the Function in Python\n\nBefore you start reading a text file in Python, you first need to open it.\n\nTo open a text file, use the built-in function.\n\nThe general syntax for the function looks like this:\n\nThe function accepts multiple arguments, but in this example, I'm focusing only on two: and .\n\nThe first required argument that the function accepts is , which represents the full path of the file name you want to open.\n\nWhen specifying the path of the file you want to open, you need to be aware of where that file is located in your folder structure.\n\nFor example, if the text file you want to open and your current file with Python code are in the same folder, you only need to reference its name and extension.\n\nSay you have a folder with the name .\n\nInside it, you have two files, , which is the file where you write your Python code, and , which is the file you would like to open. That file contains the following contents:\n\nBoth files are on the same level in the folder, so here is how you would reference when using the function:\n\nThe second optional argument that the function accepts is . It specifies whether you want to read ( ), write ( ), or append ( ) to .\n\nThe default mode is the read ( ) mode.\n\nSo, to open and read , you could optionally use to represent the mode you want to use:\n\nWith that said, you don't need to write the keyword .\n\nInstead, you can omit it and only use the letter - it would still have the same result:\n\nLastly, you can omit the letter altogether as it is the default mode:\n\nWhen you run the code from the example above, it doesn't do anything.\n\nYou completed the first step, which is opening the text file, but you haven't read it and seen its contents.\n\nHow to Read a Text File Using the Method in Python\n\nTo read the contents of , let's first store the code we wrote in the previous section in a variable named :\n\nThen, let's call the method on and print the result to the console:\n\nNow, you can read the contents of !\n\nThe method reads all the contents as a single string, which is useful when working with smaller files that don't have a lot of content in the text file.\n\nWith that said, the code above is missing something.\n\nOnce you have finished reading the text file, you need to close it. To do that, use the method. Make sure not to skip this step because forgetting to close the file may introduce bugs in your code!\n\nNow, closing the text file is a good practice, but it is something that you can easily forget to do - you may not always remember to call the method on the file.\n\nThere is an alternative available.\n\nThe keyword ensures that the file is automatically closed upon code execution.\n\nThe general syntax for the keyword when used with the function is the following:\n\nSo, here is how you would rewrite the code from the previous example using the keyword instead of the method:\n\nHow to Read a Text File Using the Method in Python\n\nIf you want to read only one single individual line from a text file, use the method:\n\nThe text file has two lines inside it, but the method only reads one line from the file and returns it.\n\nThe method also adds a trailing newline character at the end of the string.\n\nYou can optionally pass a argument to the method, which specifies the length of the returned line and the maximum number of bytes it will read.\n\nHow to Read a Text File Using the Method in Python\n\nThe method reads all the lines from a file, going through the file line by line.\n\nIt then returns a list of strings:\n\nThe method read all the lines in one go and stored each line from the text file as a single list item inside a list. The method also added a newline character at the end of each line.\n\nHow to Read a Text File Using a Loop in Python\n\nAn alternative way of reading a file line by line in Python is using a loop, which is the most Pythonic approach to reading a file:\n\nThe loop gets paired with the keyword - they iterate over the returned iterable file object and read each line inside it.\n\nHopefully, this article helped you understand how to read a file line by line in Python using the , , and methods and a loop.\n\nThank you for reading, and happy coding!"
    },
    {
        "link": "https://pythonmorsels.com/reading-files-line-line",
        "document": "Here we're calling the method on a file object (for a file called ):\n\nWhen you call the method on a file object, Python will read the entire file into memory all at once. But that could be a bad idea if you're working with a really big file.\n\nThere's another common way to process files in Python: you can loop over a file object to read it line-by-line:\n\nHere, we're printing out a number (counting upward) in each line in our file:\n\nNotice that as we print, Python isn't just printing out the line, but an extra blank line in between each line in our file. By default, Python's function prints a newline character ( ) after whatever else that it prints (see the function's argument). But each of our lines also end in a newline character, because newline characters are what separate lines in a file:\n\nGetting rid of the newline character when reading line-by-line\n\nSo we either need to suppress the newline character that the function prints out or we need to remove the newline characters from each line in our file as we print them out:\n\n5 Meaning every class is an instance of a metaclass. 8 Classes control features (like string representations) of all their instances. 9 Metaclasses can control similar features for their classes. 11 I doubt I'll ever need to make a metaclass, at least not for production code.\n\nWe're using the string method here to \"strip\" newline characters from the right-hand side (the end) of each of our strings just before we print each line.\n\nFile objects in Python are lazy iterables, which means we can treat them pretty much the same way as any other iterable.\n\nSo instead of manually counting upward, we could pass our file object to the built-in function. The function could then do the counting for us as we loop:\n\nWe've remove two lines of code but we get the same output as before:\n\nLoop over files to read them line-by-line\n\nFiles are lazy iterables, and as we loop over a file object, we'll get lines from that file.\n\nWhen Python reads a file line-by-line, it doesn't store the whole file in memory all at once. Instead, it stores a small buffer of upcoming lines in that file, so it's more memory-efficient.\n\nThat means looping over files line-by-line is especially important if you're working with really big files."
    }
]