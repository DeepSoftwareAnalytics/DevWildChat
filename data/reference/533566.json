[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://geeksforgeeks.org/python-3-input-function",
        "document": "In Python, we use the input() function to take input from the user. Whatever you enter as input, the input function converts it into a string. If you enter an integer value still input() function converts it into a string.\n\nIn this example, we are using input() function to input user data as a string in Python.\n\nIn this example, we are using the Python input() function to input user data as a string in Python, which takes input from the user and prints it.\n\nIn this example, we are taking input from the user and input user data as a string in Python with a prompt and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converting it into an integer adding 1 to the integer, and printing it.\n\nIn this example, we are using the Python input() function which takes input from the user in string format converts it into float adds 1 to the float, and prints it.\n\nIn this example, we are taking input from the user in string format converting it into a list, and printing it.\n\nTake User Input for Tuples and Sets\n\nIn this example, we are taking input from the user in string format converting it into a tuple, and printing it.\n\nIn this example, we are taking the words separated by space to input user data as a string in Python, and we make a dictionary of the word as the key with their length as the value."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-define-functions-in-python-3",
        "document": "A function is a block of instructions that performs an action and, once defined, can be reused. Functions make code more modular, allowing you to use the same code over and over again.\n\nPython has a number of built-in functions that you may be familiar with, including:\n• which will print an object to the terminal\n• which will convert a string or number data type to an integer data type\n• which returns the length of an object\n\nIn this tutorial, we’ll go over how to define your own functions to use in your coding projects.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nLet’s start with turning the classic “Hello, World!” program into a function.\n\nWe’ll create a new text file in our text editor of choice, and call the program . Then, we’ll define the function.\n\nA function is defined by using the keyword, followed by a name of your choosing, followed by a set of parentheses which hold any parameters the function will take (they can be empty), and ending with a colon.\n\nThis sets up the initial statement for creating a function.\n\nFrom here, we’ll add a second line with a 4-space indent to provide the instructions for what the function does. In this case, we’ll be printing to the console:\n\nOur function is now fully defined, but if we run the program at this point, nothing will happen since we didn’t call the function.\n\nSo, outside of our defined function block, let’s call the function with :\n\nYou should receive the following output:\n\nFunctions can be more complicated than the function we defined above. For example, we can use loops, conditional statements, and more within our function block.\n\nFor example, the function defined below utilizes a conditional statement to check if the input for the variable contains a vowel, then uses a loop to iterate over the letters in the string.\n\nThe function we defined above sets up a conditional statement and a loop, showing how code can be organized within a function definition. However, depending on what we intend with our program and how we want to set up our code, we may want to define the conditional statement and the loop as two separate functions.\n\nDefining functions within a program makes our code modular and reusable so that we can call the same functions without rewriting them.\n\nSo far we have looked at functions with empty parentheses that do not take arguments, but we can define parameters in function definitions within their parentheses.\n\nA parameter is a named entity in a function definition, specifying an argument that the function can accept.\n\nLet’s create a small program that takes in parameters , , and . We’ll create a function that adds the parameters together in different configurations. The sums of these will be printed by the function. Then we’ll call the function and pass numbers into the function.\n\nWe passed the number in for the parameter, in for the parameter, and in for the parameter. These values correspond with each parameter in the order they are given.\n\nThe program is essentially doing the following math based on the values we passed to the parameters:\n\nThe function also prints , , and , and based on the math above we would expect to be equal to , to be , and to be . Let’s run the program:\n\nWhen we pass , , and as parameters to the function, we receive the expected output.\n\nParameters are arguments that are typically defined as variables within function definitions. They can be assigned values when you run the method, passing the arguments into the function.\n\nIn addition to calling parameters in order, you can use keyword arguments in a function call, in which the caller identifies the arguments by the parameter name.\n\nWhen you use keyword arguments, you can use parameters out of order because the Python interpreter will use the keywords provided to match the values to the parameters.\n\nLet’s create a function that will show us profile information for a user. We’ll pass parameters to it in the form of (intended as a string), and (intended as an integer).\n\nWithin the function definition statement, and are contained in the parentheses of the function. The block of the function prints out information about the user as strings, making use of the two parameters.\n\nNow, we can call the function and assign parameters to it:\n\nIn the first function call, we have filled in the information with a username of and followers being , in the second function call we used keyword arguments, assigning values to the argument variables.\n\nThe output shows us the usernames and numbers of followers for both users.\n\nThis also permits us to modify the order of the parameters, as in this example of the same program with a different call:\n\nWhen we run the program again with the command, we’ll receive the following output:\n\nBecause the function definition maintains the same order of statements, if we use keyword arguments, it does not matter which order we pass them into the function call.\n\nWe can also provide default values for one or both of the parameters. Let’s create a default value for the parameter with a value of :\n\nNow, we can run the function with only the username function assigned, and the number of followers will automatically default to 1. We can also still change the number of followers if we would like.\n\nWhen we run the program with the command, we’ll receive the following output:\n\nProviding default parameters with values can let us skip defining values for each argument that already has a default.\n\nYou can pass a parameter value into a function, and a function can also produce a value.\n\nA function can produce a value with the statement, which will exit a function and optionally pass an expression back to the caller. If you use a statement with no arguments, the function will return .\n\nSo far, we have used the statement instead of the statement in our functions. Let’s create a program that instead of printing will return a variable.\n\nIn a new text file called , we’ll create a program that squares the parameter and returns the variable . We issue a call to print the variable, which is formed by running the function with passed into it.\n\nWe can run the program and receive the output:\n\nThe integer is returned as output, which is what we would expect by asking Python to find the square of 3.\n\nTo further understand how the statement works, we can comment out the statement in the program:\n\nNow, let’s run the program again:\n\nWithout using the statement here, the program cannot return a value so the value defaults to .\n\nAs another example, in the program above, we could swap out the statement for a statement.\n\nOutside of the function, we set the variable equal to the result of the function taking in , , and as we did above. Then we called a print of the variable.\n\nLet’s run the program again now that it has the statement:\n\nWe receive the same numbers , , and as output that we received previously by using the statement in the function. This time it is delivered as a tuple because the statement’s expression list has at least one comma.\n\nFunctions exit immediately when they hit a statement, whether or not they’re returning a value.\n\nUsing the statement within the loop ends the function, so the line that is outside of the loop will not run. If, instead, we had used a statement, only the loop would have exited at that time, and the last line would run.\n\nThe statement exits a function, and may return a value when issued with a parameter.\n\nAlthough in Python you can call the function at the bottom of your program and it will run (as we have done in the examples above), many programming languages (like C++ and Java) require a function in order to execute. Including a function, though not required, can structure our Python programs in a logical way that puts the most important components of the program into one function. It can also make our programs easier for non-Python programmers to read.\n\nWe’ll start with adding a function to the program above. We’ll keep our function, and then define a function:\n\nWithin the function, let’s include a statement to let us know that we’re in the function. Additionally, let’s call the function within the function:\n\nFinally, at the bottom of the program we’ll call the function:\n\nAt this point, we can run our program:\n\nBecause we called the function within and then only called to run, the text printed only once, after the string that told us we were in the main function.\n\nNext we’re going to be working with multiple functions, so it is worth reviewing the variable scope of global and local variables. If you define a variable within a function block, you’ll only be able to use that variable within that function. If you would like to use variables across functions it may be better to declare a global variable.\n\nIn Python, is the name of the scope where top-level code will execute. When a program is run from standard input, a script, or from an interactive prompt, its is set equal to .\n\nBecause of this, there is a convention to use the following construction:\n\nThis lets program files be used either:\n• as the main program and run what follows the statement\n• as a module and not run what follows the statement.\n\nAny code that is not contained within this statement will be executed upon running. If you’re using your program file as a module, the code that is not in this statement will also execute upon its import while running the secondary file.\n\nLet’s expand on our program above, and create a new file called . In this program we’ll declare a global variable and modify our original function so that the instructions are in two discrete functions.\n\nThe first function, will check to see if the string contains a vowel.\n\nThe second function will print each letter of the string.\n\nWith this set up, let’s define the function which will contain a call to both the and the functions.\n\nFinally, we’ll add the construction at the bottom of the file. For our purposes, since we have put all the functions we would like to do in the function, we’ll call the function following this statement.\n\nWe can now run the program:\n\nThe program will show the same output as the program, but here the code is more organized and can be used in a modular way without modification.\n\nIf you did not want to declare a function, you alternatively could have ended the program like this:\n\nUsing as a function and the statement can organize your code in a logical way, making it more readable and modular.\n\nFunctions are code blocks of instructions that perform actions within a program, helping to make our code reusable and modular.\n\nTo learn more about how to make your code more modular, you can read our guide on How To Write Modules in Python 3."
    },
    {
        "link": "https://docs.python.org/3/tutorial/index.html",
        "document": "Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.\n\nThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.\n\nThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.\n\nThis tutorial introduces the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line as well.\n\nFor a description of standard objects and modules, see The Python Standard Library. The Python Language Reference gives a more formal definition of the language. To write extensions in C or C++, read Extending and Embedding the Python Interpreter and Python/C API Reference Manual. There are also several books covering Python in depth.\n\nThis tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules and programs, and you will be ready to learn more about the various Python library modules described in The Python Standard Library.\n\nThe Glossary is also worth going through."
    },
    {
        "link": "https://llego.dev/posts/error-handling-strategies-best-practices-python",
        "document": "Error handling is a critical component of writing robust and production-ready Python code. Properly handling errors and exceptions helps make programs more reliable, user-friendly, and secure. This comprehensive guide examines key principles, strategies, and best practices for effective error handling in Python.\n\nErrors and exceptions are an inevitable part of writing programs. Bugs in code, unexpected user input, network interruptions, and many other factors can trigger exceptions and runtime errors. Without proper error handling, programs may crash unexpectedly or expose sensitive system information through tracebacks.\n\nRobust error handling improves overall code quality. It prevents crashes, provides useful feedback to users, secures sensitive system data, and facilitates diagnosing and fixing bugs during development. This guide explores error handling best practices using tools built into Python and supplemental libraries.\n• Handling various exception types and use cases\n• Best practices for writing clean and user-friendly error messages\n\nFollow these evidence-based guidelines and strategies to write Python code that gracefully handles errors and provides excellent user experiences.\n\nApproaching error handling systematically and deliberately is key to writing robust Python programs. Keep these core principles in mind:\n\nFail Fast, Fail Early - Check for potential errors as early as possible and raise exceptions immediately when issues occur. This helps locate the root cause quickly and prevents propagating bad data or issues further in the program.\n\nDon’t Ignore Errors - Do not suppress or ignore errors without considering the implications. Handle exceptions appropriately based on context and severity.\n\nDocument Expected Errors - Document what errors could occur and how the program handles them with docstrings and comments. This helps other developers use your code.\n\nPrioritize Clarity - Error messages should clearly explain what went wrong and how to resolve issues to users and developers. Avoid opaque errors and tracebacks with generic exception names like or .\n\nSecure Sensitive Data - Do not expose system paths, database credentials, or other sensitive data in error messages. Log errors securely and show users generalized messages.\n\nFail Gracefully - If the error does not critically break code execution, catch the exception and fail gracefully to allow continued program functioning rather than crashing entirely.\n\nMinimize Scope - Only handle exceptions that the immediate code block can properly resolve. Re-raising exceptions propagates them to outer scopes that may have more context to handle the issue.\n\nKeeping these principles in mind while programming and debugging helps developers write more robust error handling suitable for production systems.\n\nPython has several built-in mechanisms for error handling:\n\nExceptions indicate an error occurred during execution. Python generates a variety of built-in exception types like , , and that indicate what went wrong. Custom exceptions can also subclass the base class.\n\n/ blocks handle exceptions in Python. The block contains code that may raise an exception. The block catches and handles the exception. Multiple blocks can handle different exception types.\n\nA block executes after a / block completes but before leaving the scope. This is useful for cleanup like closing files.\n\nAn block after / runs only if no exceptions occurred. This avoids needing to track success with a boolean flag:\n\nThis covers Python’s basic error handling tools. Robust error handling also requires knowledge of common exception hierarchies and types.\n\nPython defines various exceptions for errors in code, I/O, imports, system issues, and more. Here are best practices for handling some common exceptions:\n\nA occurs when a function receives an argument of the expected type but an inappropriate value. Handle by validating arguments and inputs before passing to functions:\n\nA happens when an operation or function is applied to an incompatible type. Adding extra type checking helps avoid :\n\nAn occurs when Python cannot import a module. Catching this exception allows gracefully handling missing dependencies:\n\nAn happens when a system operation fails, like unable to open a file, reach a network resource, or find a path. The error message usually indicates the underlying reason:\n\nAn indicates trying to access an element in a sequence that is out-of-bounds. Check array sizes before accessing elements to avoid this exception:\n\nError messages should clearly communicate issues to users without exposing sensitive system information. Follow these best practices for writing good error messages:\n• Be Specific - Avoid generic error messages like “An error occurred”. Provide details about what failed, such as citing invalid user inputs or missing files.\n• Be Actionable - Tell users how to resolve issues when possible. For invalid credentials, suggest signing up or resetting password.\n• Be User-Focused - Avoid technical jargon and discuss problems from the user’s perspective. For example, “File not found” rather than “IOError: [Errno 2] No such file or directory”.\n• Keep Sensitive Data Private - Do not reveal system paths, code snippets, or network details. Log them separately for debugging instead.\n• Use Proper Grammar and Formatting - Messages should be written concisely with proper spelling, grammar, and formatting. Follow style guidelines like capitalizing first word and no period at end.\n• Provide Context - Where possible include context like which function failed, the argument types, and valid value examples. But strive for brevity.\n• Use Built-in Parameters - Some exceptions like and allow passing a descriptive message as a parameter.\n• Do Not Fail Silently - Never fail with a generic exception or fail without an error. The lack of errors can make issues harder to debug.\n\nBelow is an example illustrating some recommended practices for clear, user-friendly error messages:\n\nExceptions provide important clues during debugging by signaling when and where code failures occur. Strategically raising and handling exceptions helps isolate bugs.\n\nFollow these best practices to leverage exceptions for debugging:\n• Add Debug Prints - Print variable values at strategic points before exception handlers to inspect program state.\n• Handle Exceptions Granularly - Divide code into smaller functions and handle exceptions locally to pinpoint where issues arise.\n• Log Exceptions - Keep a detailed audit trail by logging caught exceptions along with relevant context like time, user, call stack, and system details.\n• ** Raise Exceptions Early** - Validate prerequisites of functions at start and raise exceptions immediately if failure conditions found. Avoid masking underlying issues.\n• Create Reproducible Test Cases - Isolate the minimum steps to recreate exceptions in unit tests and document the steps. Simpler test cases help isolate causes.\n• Use Debugger - Debuggers like allow stepping through code line-by-line after an exception occurs to inspect stack and variables.\n• Catch Narrow Exceptions First - In exception handling, catch specific exceptions before broad ones to differentiate error causes.\n\nUsing exceptions effectively speeds up debugging by signaling failures immediately and clearly highlighting where issues occur within the program logic.\n\nHow code is structured also impacts error handling. These guidelines help better organize code for managing errors:\n\nEncapsulate complex operations prone to failure in functions instead of spreading across code. Localize error handling to these functions.\n\nKeep the main business logic separate from error handling code. Extract error handling into helper functions and classes to avoid cluttering application logic.\n\nNote exceptions that functions may raise in docstrings and comments. This helps developers who use your code handle errors properly.\n\nUse multiple / blocks each handling specific exceptions rather than overbroad blocks. This makes error handling more precise.\n\nHave functions raise exceptions as soon as errors occur. Catch and handle exceptions at the highest level scope possible. This avoids repetition.\n\nFor common error cases, define custom exception classes with clear names that explain the errors. This makes handling across the program consistent.\n\nFollowing these guidelines helps organize code in a maintainable way that keeps error handling responsibility clear and simple.\n\nIn addition to built-in Python error handling mechanisms, several libraries provide useful supplemental features:\n\nRobust logging using the module helps track handled and unhandled exceptions. The call stack tracks where errors originated.\n\nSentry aggregates and analyzes exceptions across systems providing alerts and context about crashes in production.\n\nThe function extracts exception details into a chained exception to avoid losing context from original failures.\n\nDecorator functions like can automatically re-execute functions that failed, simplifying some types of error handling.\n\nWeb frameworks like Flask-RESTful have exception handling mechanisms tailored for web APIs. HTTP status codes clearly convey API errors.\n\nExternal libraries help group related exceptions and enable handling them together. For example, groups all request-related exceptions.\n\nCareful attention to error handling helps create reliable and user-friendly Python programs. Following Python’s principles and best practices ensures errors get handled appropriately.\n\nLeverage built-in mechanisms like exceptions, / blocks, and informative error messages. Structure code strategically to localize and simplify error handling. Employ supplemental tools like debugging techniques and logging to build robust and resilient applications.\n\nEffective error handling requires adopting a conscientious mindset oriented around defensively writing code. Failing fast, documenting expectations, and guiding users through errors leads to correct and graceful failure handling. This allows Python developers to write code that remains resilient in the face of inevitable real-world exceptions and edge cases."
    },
    {
        "link": "https://geeksforgeeks.org/python-exception-handling",
        "document": "Python Exception Handling handles errors that occur during the execution of a program. Exception handling allows to respond to the error, instead of crashing the running program. It enables you to catch and manage errors, making your code more robust and user-friendly.\n\nExample: Trying to divide a number by zero will cause an exception.\n\nExplanation: In this example, dividing number by 0 raises a ZeroDivisionError. The try block contains the code that might cause an exception and the except block handles the exception, printing an error message instead of stopping the program.\n• Error : Errors are serious issues that a program should not try to handle. They are usually problems in the code’s logic or configuration and need to be fixed by the programmer. Examples include syntax errors and memory errors.\n• Exception : Exceptions are less severe than errors and can be handled by the program. They occur due to situations like invalid input, missing files or network issues.\n\nExplanation: A syntax error is a coding mistake that prevents the code from running. In contrast, an exception like ZeroDivisionError can be managed during the program’s execution using exception handling.\n\nException handling in Python is done using the try, except, else and finally blocks.\n\ntry, except, else and finally Blocks\n• try Block lets us test a block of code for errors. Python will “try” to execute the code in this block. If an exception occurs, execution will immediately jump to the except block.\n• except Block: enables us to handle the error or exception. If the code inside the try block throws an error, Python jumps to the except block and executes it. We can handle specific exceptions or use a general except to catch all exceptions.\n• else Block: is optional and if included, must follow all except blocks. The else block runs only if no exceptions are raised in the try block. This is useful for code that should execute if the try block succeeds.\n• finally Block: always runs, regardless of whether an exception occurred or not. It is typically used for cleanup operations (closing files, releasing resources).\n• try block asks for user input and tries to divide 100 by the input number.\n• else block runs if no exception occurs, displaying the result.\n• finally block runs regardless of the outcome, indicating the completion of execution.\n\nPython has many built-in exceptions, each representing a specific error condition. Some common ones include:\n\nThe base class for all built-in exceptions. The base class for all non-exit exceptions. Base class for all errors related to arithmetic operations. Raised when a division or modulo operation is performed with zero as the divisor. Raised when a numerical operation exceeds the maximum limit of a data type. Raised when an attribute reference or assignment fails. Raised when a sequence subscript is out of range. Raised when a dictionary key is not found. Raised when an operation runs out of memory. Raised when a local or global name is not found. Raised when an operation or function is applied to an object of inappropriate type. Raised when a function receives an argument of the right type but inappropriate value. Raised when an import statement has issues. Raised when a module cannot be found.\n\nWhen working with exceptions in Python, we can handle errors more efficiently by specifying the types of exceptions we expect. This can make code both safer and easier to debug.\n\nCatching specific exceptions makes code to respond to different exception types differently.\n• None The ValueError is caught because the string “str” cannot be converted to an integer.\n• None If x were 0 and conversion successful, the ZeroDivisionError would be caught when attempting to calculate its inverse.\n\nWe can catch multiple exceptions in a single block if we need to handle them in the same way or we can separate them if different types of exceptions require different handling.\n• None The ValueError is caught when trying to convert “twenty” to an integer.\n• None TypeError might occur if the operation was incorrectly applied to non-integer types, but it’s not triggered in this specific setup.\n• None IndexError would be caught if an index outside the range of the list was accessed, but in this scenario, it’s under control.\n\nHere’s a simple calculation that may fail due to various reasons.\n• None An ArithmeticError (more specific like ZeroDivisionError) might be caught if this were a number-to-number division error. However, TypeError is actually triggered here due to attempting to divide a string by a number.\n• catch-all except: is used to catch the TypeError, demonstrating the risk that the programmer might not realize the actual cause of the error (type mismatch) without more detailed error logging.\n\nWe raise an exception in Python using the raise keyword followed by an instance of the exception class that we want to trigger. We can choose from built-in exceptions or define our own custom exceptions by inheriting from Python’s built-in Exception class.\n• None The function set checks if the age is negative. If so, it raises a ValueError with a message explaining the issue.\n• None This ensures that the age attribute cannot be set to an invalid state, thus maintaining the integrity of the data.\n• Improved program reliability : By handling exceptions properly, you can prevent your program from crashing or producing incorrect results due to unexpected errors or input.\n• Simplified error handling : Exception handling allows you to separate error handling code from the main program logic, making it easier to read and maintain your code.\n• Cleaner code: With exception handling, you can avoid using complex conditional statements to check for errors, leading to cleaner and more readable code.\n• Easier debugging : When an exception is raised, the Python interpreter prints a traceback that shows the exact location where the exception occurred, making it easier to debug your code.\n• Performance overhead: Exception handling can be slower than using conditional statements to check for errors, as the interpreter has to perform additional work to catch and handle the exception.\n• Increased code complexity : Exception handling can make your code more complex, especially if you have to handle multiple types of exceptions or implement complex error handling logic.\n• Possible security risks: Improperly handled exceptions can potentially reveal sensitive information or create security vulnerabilities in your code, so it’s important to handle exceptions carefully and avoid exposing too much information about your program."
    },
    {
        "link": "https://linkedin.com/advice/0/what-best-practices-error-handling-python-obrkc",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/8678428/best-practices-for-coding-simple-mathematical-calculations-in-python",
        "document": "I need to perform simple mathematical calculations in Python 2.7 with sums, subtractions, divisions, multiplications, sums over lists of numbers etc.\n\nI want to write elegant, bullet-proof, and efficient code but I must admit I got confused by several things, for example:\n• if I have in my equation should I just code or maybe , or any other combination of these?\n• for division, should I use or with ?\n• what practices such as \"using for concatenating a list of floats\" are out there?\n• should I assume that input numbers are float or do the conversion just in case (maybe risking drop of efficiency on many operations)?\n\nSo what are the best practices for writing a code for simple mathematical calculations in Python that is\n• bullet-proof to issues like uncertainty in exact number type of input data (float vs integer) ?"
    },
    {
        "link": "https://freecodecamp.org/news/error-handling-in-python-introduction",
        "document": "Just recently, my manager tasked me to create an automatic report. I designed the report to be simple. It included a few numbers from a database and some basic mathematical operations. I was excited to finally be able to show off my amazing Python skills to the company.\n\nI finished and shipped the product. Everything was great. At least, until about two weeks later. My report began failing randomly due to a divide-by-zero error. Cue the laugh track.\n\nMy short story is absent details, but it should highlight the importance of handling edge cases and errors when composing programs. This report should have been an opportunity to show off my Python prowess. Yet, it turned into a bit of an embarrassing, fall-on-my-face moment.\n\nSo, let’s take a moment to learn the basics of error handling using Python’s standard library. I’m going to highlight some of the things you need to get started.\n\nBefore you start handling exceptions, you should have a good grasp of Python fundamentals. You’ll need to know why the exceptions are being thrown to deal with them!\n• Try and Except Statements in Python\n• Conditional Execution with the Else Clause\n\nTry and Except Statements in Python\n\nThe and statements are the primary method of dealing with exceptions. They look something like this:\n\nLet’s review the above code so we are on the same page:\n• Line 1 assigns the value 0 to a variable\n• Lines 2 and 3 open a clause and attempt to divide 5 by the variable\n• Lines 4 and 5 open an clause for any and instruct the program to print a message should we try to divide anything by 0\n\nYou likely notice the issue. My variable has the value 0, and I am trying to divide 5 by . The best mathematicians in the world can’t divide by 0, and neither can Python. So, what happens?\n\nIf we do not handle the error, the program will immediately terminate upon trying to divide 5 by . Since programs do not know what to do with exceptions without explicit instructions, we created the clause on line 4 and provided the steps for the program to take in the event of dividing something by 0.\n\nThat’s the whole idea behind handling exceptions: you need to tell the program what to do when it has an error that it cannot simply ignore. Let’s look at how the and clauses work.\n\nBreaking Down the Try Statement\n\nand statements follow a pattern that allows you to reliably handle problems in your code. Let’s go over the pattern.\n\nThe first step that happens is, the code in the clause attempts to execute.\n\nAfter that, we have three possibilities:\n\nNo Errors in the Try Clause\n\nIf the code in the clause executes without any errors, the program will:\n\nYou can see that, in this modified example, there are no issues in the clause (Lines 3 and 4). The code will execute, the clause will be skipped, and the program will resume execution after the and statements conclude.\n\nErrors in the Try Clause and the Exception is Specified\n\nIf the code in the clause does throw an exception and the type of exception is specified after any keyword, the program will:\n• Skip the remaining code in the clause\n• Execute any code in the matching clause\n\nBack to my first example, I changed our variable back to the value 0 and tried to divide 5 by . This produces a . Since my statement specifies this type of exception, the code in that clause executes before the program resumes running as normal.\n\nErrors in the Try Clause and the Exception is not Specified\n\nFinally, if the program throws an exception in the clause, but the exception is not specified in any statements, then the program will:\n• Stop the execution of the program and throw the error\n\nIn the above example, I’m trying to divide 5 by the variable , which does not exist. This raises a . I don’t specify to the program how to handle s, so the only option is to terminate itself.\n\nand are the main tools in handling errors, but an optional clause that you can use is named . The clause will always execute, whether there is an error or not.\n\nIn this example, I have created our favorite . You can see that the order of execution is:\n\nOnce we fix the clause to no longer throw an error, you’ll still see a similar order of execution. Instead of the clause running, the clause will execute.\n\nYou’ll notice that the only difference is that clause is successfully executed because there are no exceptions thrown. The clause and the code afterwards execute as you would expect.\n\nThis is useful for some cases when you want to clean up no matter the outcome of your and clauses. Actions such as closing connections, closing files, and logging are great candidates for the clause.\n\nConditional Execution with the Else Clause\n\nThe other optional clause is the clause. The clause is simple: if the code in the clause executes without throwing an error, then the code in the clause will also execute.\n\nThe order of execution for this example is:\n\nIf we were to experience an exception or error in the clause, the clause would be ignored.\n\nYou’ve seen me write about two different named exceptions so far: and . What if I needed other exceptions?\n\nThere is an entire list of Python’s exceptions that come with the standard library. These will probably suit almost every need that you have in handling any errors or exceptions.\n\nHere are just a few that might be important:\n• – A key cannot be found in a dictionary\n• – The index is out-of-bounds on an iterable object\n• – A function or operation was used on the wrong type of object\n\nThere are a whole lot more, which can be found in the Python documentation. I encourage to take a look. Not only will you be better at handling errors, but you will also explore what actually can go wrong with your Python programs.\n\nIf you need extended functionality, you can also define custom exceptions.\n\nIn the above example, I create a new class and extend it from the Exception class. Now, I can write custom functionality and treat this exception as any other object.\n\nHere, I raise my new on purpose. I catch the and give it an alias of . Now, I can access my method that I built into the class that I created.\n\nThis opens a whole plethora of possibilities when dealing with errors. Custom logging, more in-depth tracking, or whatever else you need can all be coded and created.\n\nNow that you understand the basics of , , and exception objects, you can start considering using them in your code to gracefully handle errors. Are there any considerable impacts to code performance, though?\n\nThe short answer is no. With the release of Python 3.11, there is practically no speed reduction from using and statements when there are no thrown exceptions.\n\nCatching errors did cause some slowdowns. But generally, catching these errors is better than having the entire program crash and burn.\n\nIn earlier versions of Python, using and clauses did cause some extra execution time. Keep this in mind if you’re not up to date.\n\nThank you for reading this far. Your future self and customers will thank you for your error handling.\n\nWe went over the , , , and clauses and their execution order and under what circumstances they are executed. We also reviewed the basics of creating custom exceptions.\n\nThe most important thing to remember is that the and clauses are the primary ways to catch errors, and you should be using them whenever you have risky, error-prone code.\n\nAlso, keep in mind that catching errors will make your code more resilient, and make you look like a much better coder."
    }
]