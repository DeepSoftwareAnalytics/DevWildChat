[
    {
        "link": "https://geeksforgeeks.org/variadic-functions-in-c",
        "document": "In C, variadic functions are functions that can take a variable number of arguments. This feature is useful when the number of arguments for a function is unknown. It takes one fixed argument and then any number of arguments can be passed.\n\nLet’s take a look at an example:\n\nExplanation: In this example, the print() function takes a fixed first parameter n and the rest parameters vary. We have called this function with 1, 2, 3, 4, and 5 arguments and it was able to work for both.\n\nA variadic function takes at least one fixed argument an ellipsis(…) as the last parameter.\n\nThe above syntax allows users to pass the variable arguments, but to access the variable arguments inside the function, we have to use the methods specified in the <stdarg.h> library. The step-by-step process for this is as follows:\n\nUse the va_list type to declare a variable that will store the information needed to retrieve the additional arguments.\n\nThis macro initializes the va_list to retrieve arguments from the variable arguments section.\n• fixed_arg : The last fixed argument before the variable arguments (…).\n\nThis macro returns the next argument from the list. It must be used repeatedly to access all arguments.\n\nThe number of times it should be called should not exceed the number of parameters passed. Due to this, the count of variable arguments passed is also passed as fixed parameters.\n• type : The type of the argument to retrieve.\n\nNote: It is important to not mix up the type of the arguments.\n\nOnce all the arguments are processed, use va_end() to clean up the va_list. This ensures that resources associated with va_list are properly released.\n\nThe below examples demonstrate the use of variadic functions in C language:\n\nFind the Sum of Given Numbers\n\nExplanation: The getSum() function calculates the sum of n variable arguments by iterating through the list of arguments and adding each one to a sum. It uses va_list, va_start, and va_arg to handle the variable arguments and returns the sum.\n\nExplanation: In this example, print() takes an integer count as the first parameter, followed by a variable number of arguments. We use va_arg to print integers and floats alternately, based on their position in the argument list.\n\nCan variadic functions accept arguments of different data types?\n\nIs it necessary to have a fixed parameter in a variadic function?\n\nWhat happens if the number of arguments passed doesn’t match the expected count in a variadic function?\n\nCan we only have one fixed parameter in a variadic function?"
    },
    {
        "link": "https://onepunchcoder.medium.com/variadic-functions-explained-fd3b4ab6fd84",
        "document": "In this blog post, we will delve into the intricacies of variadic functions in C programming language. We will examine the functionality of built-in variadic functions such as and , and explore how to effectively utilize them in our code. Additionally, we will delve into the process of creating custom variadic functions using the , , , and macros, and learn how to manage a variable number of arguments passed to the function.\n\nFurthermore, this post will examine real-world use cases for variadic functions, such as determining the sum of an undetermined number of integers or displaying a variable number of strings to the console. Through the use of examples and clear explanations, we aim to impart a comprehensive understanding of variadic functions and their potential for enhancing the functionality of our code.\n\nAs we embark on this technical exploration of variadic functions in C programming language, we recommend taking a few moments to relax and enjoy the memes included in the post. Let us begin!\n\nA variadic function is a function in C programming language that can take a variable number of arguments. These functions are particularly useful in situations where the number of arguments needed is not known beforehand.\n\nVariadic functions are supported in C through the use of a special set of macros defined in the header file. These macros include , , and , and they allow the programmer to access and manipulate the variable arguments passed to the function.\n\nThe syntax for creating a variadic function in C is as follows:\n\nThe ellipsis ( ) in the function parameter list is used to indicate that the function can take a variable number of arguments of any type. The types and names of the first N arguments are specified as usual, while the variable number of arguments are accessed using the , , , and macros.\n\nOne of the most commonly used built-in variadic functions in C is the function. The function allows us to print a formatted string to the console, and it can take a variable number of arguments depending on the format specifiers used in the string passed to the function.\n\nFor example, the following code demonstrates the use of function to print a string, an integer, and a floating-point number:\n\nAs shown in the example, the function is passed a string that contains two format specifiers: and . These specifiers indicate that the next argument passed to the function should be an integer and a floating-point number respectively. The function then replaces the format specifiers with the corresponding values of the variables and . This allows us to easily print a string with dynamic values in a clean and readable format.\n\nAnother most commonly used built-in variadic functions in C is the function. This function can be used to read input from the user and store it in a variable of a specified data type.\n\nHere is an example of how the scanf function can be used:\n\nThe output of this code would be:\n\nIn this example, the scanf function is used to read an integer from the user and store it in the “age” variable. The “%d” is a format specifier that tells the function to expect an integer as input. The “&” symbol is used to pass the address of the variable to the function so that the value entered by the user can be stored in it.\n\nAs we can see, the scanf function is a powerful tool for reading input from the user, and with the use of format specifiers, it can be used to read a variety of data types. This is the power of variadic functions, they can take any number of arguments and handle them accordingly.\n\nCreating custom variadic functions in C requires the use of four macros: va_list, va_start, va_arg, and va_end.\n\nThe macro is used to declare a variable that will hold the list of arguments passed to the function. This variable is typically named .\n\nThe macro is used to initialize the variable, and must be passed the last non-variadic argument of the function.\n\nThe macro is used to retrieve the next argument from the . It must be passed the variable, and the type of the argument being retrieved.\n\nFinally, the macro must be called to clean up the variable after all arguments have been retrieved.\n\nUsing these macros, we can create a custom variadic function that can handle a variable number of arguments.\n\nFor example, a function that calculates the sum of a variable number of integers:\n\nThis function can be called with any number of integer arguments, and will calculate their sum. For example:\n\nIt is important to note that the va_list, va_start, va_arg, and va_end macros are defined in the <stdarg.h> header file, which must be included in the program for the above code to work.\n\nExample of variadic functions implementation to print strings:\n\nThe output of the above code will be:\n\nThe function starts by initializing a variable using the macro, and passing the last non-variadic argument as the parameter. Then, it enters a for loop that runs times. In each iteration of the loop, the function uses the macro to extract the next argument from the , which it assigns to the char pointer .\n\nIf the separator is not null and the iterator is greater than 0, the function prints the separator. If the pointer is null, the function prints otherwise it prints the string.\n\nAfter the loop, the function uses the va_end macro to clean up the . Finally, it prints a new line and exits the function.\n\nIn conclusion, this blog post has explored the intricacies of variadic functions in C programming language. We have examined the functionality of built-in variadic functions such as printf and scanf, and explored how to effectively utilize them in our code.\n\nAdditionally, we delved into the process of creating custom variadic functions using the va_list, va_start, va_arg, and va_end macros, and learned how to manage a variable number of arguments passed to the function.\n\nReal-world use cases for variadic functions were also discussed, such as determining the sum of an undetermined number of integers or displaying a variable number of strings to the console. Through the use of examples and clear explanations, we hope to have imparted a comprehensive understanding of variadic functions and their potential for enhancing the functionality of our code."
    },
    {
        "link": "https://stackoverflow.com/questions/77300562/variadic-functions-in-c-concept",
        "document": "In the early days of C language, the passing parameters contract was that parameters were put into the stack in reverse order. And neither the type nor the number of parameters were part of the function declaration, only its return value type. It was then easy to handle a variable number of parameters (at least in assembly code) provided that number could be deduced from the fix part. As already said in comments, it is exactly the way the and functions from the standard library work.\n\nThe things from were later added as a portable way to handle those variadic functions directly in C language, and they were designated as opaque macros. The rationale was that the the gory details of passing parameters were details for the language implementations, and the implementation only had to provide a way for the C programmer to be able to access the parameters the hard way meaning here knowing their order and type at run time instead of at compile time.\n\nIn common implementations, they are just a way to extract a pointer in the program stack to the frame containing the parameters and to iterate that frame.\n\nFor an example of usage, you could have a look the the excellent cppreference site"
    },
    {
        "link": "https://en.cppreference.com/w/c/variadic",
        "document": "Variadic functions are functions (e.g. printf) which take a variable number of arguments.\n\nThe declaration of a variadic function uses an ellipsis as the last parameter, e.g. int printf(const char* format, ...);. See variadic arguments for additional detail on the syntax and automatic argument conversions.\n\nAccessing the variadic arguments from the function body uses the following library facilities:\n\nsimple_printf fmt, ... va_list args va_start args, fmt fmt fmt fmt i va_arg args, , i // A 'char' variable will be promoted to 'int' // A character literal in C is already 'int' by itself c va_arg args, , c d va_arg args, , d END END va_end args main simple_printf , , , ,"
    },
    {
        "link": "https://tutorialspoint.com/c_standard_library/c_macro_va_start.htm",
        "document": "The C stdarg library va_start() macro enables access to the variable arguments following the named argument parmN. It is used to initialize a 'va_list' variable, which is then used to retrieve the additional arguments passed to the function.\n\nThe va_start should be called with an instance to a valid va_list (variable list) object ap before any calls to va_arg (variable argument).\n\nThis macro is useful for creating a variadic function, allowing us to create a function that can take variable number of arguments. It contains at least one fixed argument followed by an ellipsis (...).\n\nFollowing is the C library syntax of the va_start() macro −\n• ap − It is a va_list type variable that will be initialize by 'va_start'. This variable is used to traverse the list of arguments.\n• None parmN − It is name of the last named parameter in the function definition.\n\nThis macro does not returns any value.\n\nThe following is the basic c example that demonstrate the use of va_start().\n\nFollowing is the output −\n\nIn this example, we use the va_start() to count the number of passed argument in the user-defined function.\n\nFollowing is the output −\n\nLet's see the another example, here we create a function that concatenates a variable number of strings into a single result string.\n\nFollowing is the output −"
    },
    {
        "link": "https://stackoverflow.com/questions/26011294/why-is-vsnprintf-safe",
        "document": "What happens in these 2 cases ?\n\nIn case 1, if the string you're formatting has a length of 3 or greater, you have a buffer overrun, vsprintf might write to memory past the storage of the buf array, which is undefined behavior, possibly causing havoc/security concerns/crashes/etc.\n\nIn case 2. vsnprintf knows how big the buffer that will contain the result is, and it will make sure not to go past that(instead truncating the result to fit within )."
    },
    {
        "link": "https://stackoverflow.com/questions/37788305/how-do-you-call-vsnprintf-safely",
        "document": "I'm porting some very old (> 10y) C code to modern Linuxes. I'm getting segmentation faults within a custom-written vsnprintf() wrapper (apparently its task is to detect duplicate output strings and intern them):\n\nThe author seems to have assumed that the standard function returns the number of characters written, and simply returns a sentinel value if it doesn't receive enough space to format all args. This means that you can just guess a buffer size and increase it if necessary.\n\nBut on my system (Ubuntu 14.04, glibc 2.19) vnprintf causes a segmentation fault when called with too many arguments for the provided space. Did the semantics of the family change that drastically in the meantime? And what is the modern way of ensuring you hand it enough buffer space?"
    },
    {
        "link": "https://security.stackexchange.com/questions/43574/how-is-printf-in-c-c-a-buffer-overflow-vulnerability",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://dev.to/ashok83/snprintf-vs-sprintf-a-deep-dive-into-buffer-overflows-prevention-59hg",
        "document": "C features are programming functions that make it easy to organize and structure code. They enable modular programming, wherein code can be reused to make it easy to start and complete projects. Programmers can also separate complex tasks into smaller code units, which are easier to manage and are only executed when needed.\n\nThese functions, however, can pose issues and security risks. The sprintf() function, in particular, can result in a buffer overflow vulnerability. Many C programmers like using this function because of its simplicity and familiarity. Its syntax is rather straightforward, which makes it preferable when it comes to simple string formatting tasks. It is associated with an issue that is hard to ignore, though.\n\nSprintf() makes it possible to write formatted data into a string buffer. It is designed to accept a format string as its initial argument, prepending other arguments that specify what to write into the formatted string. As such, it is usually employed in formatting strings that entail the merger of texts with numbers, variables, and other arguments. Sprintf() is similar to printf (), except that it writes the data into a string instead of having it printed.\n\nSprintf() is usually used in string composition, custom output formatting, variable substitution, and string building. It provides a simple and flexible way to compose strings and control output formatting. However, as indicated earlier, it can bring about buffer overflows, which are a security risk.\n\nThis is where snprintf() comes in. It helps secure the formatting of strings by putting a cap on the maximum number of characters allowed on the buffer. It is essentially a secure alternative to the sprintf() function.\n\nUnderstanding the differences between snprintf vs sprintf and their use cases are two vital points every C programmer should know. It would be inexpedient to choose one simply because it is easier to use or because it is more familiar.\n\nThe snprintf() function is inherently intolerant of buffer overflow. It also comes with its error detection mechanism, which promptly detects possible truncation. Snprintf() routinely compares the return value with the actual buffer size to detect truncation errors. This function is generally the secure option.\n\nHowever, it may be unnecessary to use snprintf() if the data sizes are already known and controlled. Also, if there are already existing controls on input data size and formatting, it would be acceptable to stick to the simple and familiar function.\n\nBuffer overflow sounds like a benign term, but it is among the biggest vulnerabilities. At some point, nearly a fifth of all security vulnerabilities reported to the Computer Emergency Response Team (CERT) were buffer overflows.\n\nAlso known as buffer overruns, buffer overflows take place when programs write data beyond the capacity or allocation of a buffer or array. In C programming, buffers are contiguous or connected blocks of memory with definite memory allocations. They can only accommodate a certain amount of data. Thus, if a buffer that only has an allocation of 50 characters receives data worth 500 characters, only 50 characters will be written on the target buffer. The rest will overflow into other areas of memory.\n\nThe Open Worldwide Application Security Project (OWASP) includes injection in its Top Ten list of most common web application security risks. The exploitation of buffer overflow vulnerabilities falls under the injection category, wherein threat actors can introduce malicious commands to programs that lack buffer overflow controls.\n\nThere is no automatic rejection for excessive data written to a buffer. The restriction on the maximum amount of data that can be taken in has to be specified. The absence of a cap provides opportunities for threat actors to write data on other memory spaces, creating security compromises that may not be detected by most security controls.\n\nThe outcomes of a buffer overflow attack are usually unpredictable. No attacker can be certain as to what happens when they exploit the buffer overflow vulnerabilities they discover. An app or program may crash. It can also become dysfunctional or exhibit unexpected behavior. Worse, it may facilitate the execution of malicious code. Cybercriminals observe what happens to their attacks and tweak them until they achieve the outcomes they prefer.\n\nTo avoid buffer overflow security weaknesses, it is advisable to use the snprintf() function in cases when either snprintf() or sprintf() are usable. While the latter is easier, the former is more secure. There is no dilemma here—security is non-negotiable. No amount of ease or convenience can justify a security compromise.\n\nTake note, though, that simply using snprintf() does not automatically mean that a program becomes secure. It is important to examine the buffer size to make sure that the allocated buffer size is enough for the expected inputs and that a limit on the maximum size is enforced. Additionally, the return value should be checked to ascertain that it does not exceed the buffer size and prevent instances of data truncation.\n\nHowever, there are instances when programmers have no other choice but to stick with sprintf(). Most legacy devices do not support the snprintf() function. Organizations may not be prepared to retire and replace these devices, so it makes sense to use sprintf(). In such cases, it is advisable to use other security measures.\n\nWhen securing low-resource IoT and embedded devices, for example, it helps to use deterministic security solutions. There are security tools capable of deterministically stopping memory and code manipulation. They can provide effective protection from injection attacks, including those that exploit buffer overflow vulnerabilities attributable to the use of sprintf().\n\nBuffer overflows pose serious security risks, and they can cause unthinkable damage. As such, it is important to be keen on the proper string formatting functions to use. These functions have their respective advantages or benefits, but they can also be the cause of serious security weaknesses. The snprintf() vs sprintf() faceoff logically ends up with snprintf() becoming the preferred option. However, it is still possible to use sprintf() securely with the help of other security controls or solutions and by observing secure coding best practices. Understandably, there are situations when using the less secure function is inevitable, but they are not an excuse not to find ways to ascertain security."
    },
    {
        "link": "https://ask.metafilter.com/64414/How-can-I-avoid-buffer-overflows-with-C",
        "document": "I am sure this is embarrassingly simple, but all the tutorials I read always gloss over this aspect of sscanf and sprintf. How do I go about ensuring I don't encounter buffer overflows when using these two functions? I've read links like these that suggest truncating the data, but I don't want to do this. This link suggests using the \"a\" flag, but also says it's a GNU-only addition.How do programmes that don't have fixed-length strings operate? Surely our chat clients don't use fixed-length buffers? Help, Mefi!"
    }
]