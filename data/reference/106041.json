[
    {
        "link": "https://stackoverflow.com/questions/14570297/what-does-it-mean-to-have-a-block-of-c-code-with-a-backslash-after-each-semico",
        "document": "A backslash as last character in a line causes this line to be joined with the next for preprocessing. For regular C++ parsing newlines are simply whitespace, so this does not matter. But preprocessor directives, in particular macro definitions end at the end of line.\n\nUsing a backslash for line continuation allows formatting long macro bodies across multiple source text lines."
    },
    {
        "link": "https://stackoverflow.com/questions/7059549/c-multi-line-comments-using-backslash",
        "document": "Yes. Lines terminated by a are spliced together with the next line very early in the process of translation. It happens at phase 2 of translation, before comment removal and before preprocessor has a chance to do its work.\n\nComment recognition and removal takes place at phase 3. For this reason you can turn a comment into what looks like a multi-line comment by using the . This usually fools most syntax-highlighting source code parsers.\n\nThis all means that you can \"multiline\" virtually anything using the , including comments and preprocessor directives\n\nP.S. Please note that the terminating does not introduce any whitespace into the spliced line. This should be taking onto account when writing multi-line comments using the feature. For example, the following comment\n\nstands for the single word \"together\" and not for three separate words \"to get her\". Obviously, incorrect use of in comments might drastically obfuscate and even distort their intended meaning."
    },
    {
        "link": "https://gnu.org/software/c-intro-and-ref/manual/html_node/Line-Continuation.html",
        "document": "The sequence of a backslash and a newline is ignored absolutely anywhere in a C program. This makes it possible to split a single source line into multiple lines in the source file. GNU C tolerates and ignores other whitespace between the backslash and the newline. In particular, it always ignores a CR (carriage return) character there, in case some text editor decided to end the line with the CRLF sequence.\n\nThe main use of line continuation in C is for macro definitions that would be inconveniently long for a single line (see Macros).\n\nIt is possible to continue a line comment onto another line with backslash-newline. You can put backslash-newline in the middle of an identifier, even a keyword, or an operator. You can even split ‘ ’, ‘ ’, and ‘ ’ onto multiple lines with backslash-newline. Here’s an ugly example:\n\nDon’t do those things in real programs, since they make code hard to read.\n\nNote: For the sake of using certain tools on the source code, it is wise to end every source file with a newline character which is not preceded by a backslash, so that it really ends the last line."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/276522/is-there-a-line-continuation-character-in-vc",
        "document": "It is not clear to me whether you are asking about backslashes for VB or C++. I will answer the question in which context do you need continuation characters in C++?\n\nFor C and C++ it is highly beneficial to understand the concept of White Space. In C and C++ White Space refers to blanks, horizontal and vertical tabs, newlines, formfeeds, and comments. And newlines refers to the end of lines. In C and C++ all White Space is the same. A newline is seen as the same as a space to the compiler. I could post a link to a (draft) version of the C++ language but it is a large document and I assume it would just be too confusing. Look in C++ language references and tutorials for descriptions of White Space.\n\nAlso note that the VB language syntax is the result of the syntax of the Basic language that was designed when computers were extremely limited compared to what they are capable of now."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/38985",
        "document": "Today my question is a bit C-oriented (although it applies for C++)...\n\n I know line break or new line is '\n\n', but how do you break line in code?\n\n Like in VB.NET, you can put an underscore '_' at the end of a line and the next line will be continued from the previous...\n\n Likewise, if a specific LOC in my code takes more than one line in the editor, how to tell compiler to continue the line with the next line in the editor?\n\nAs far as I am aware, you can just press enter and continue on the next line as normal. C++ ignores whitespace so the line will go on until you terminate it with a semicolon.\n\n \n\n The only exception that I'm aware of is string literals (e.g. ): you can't start a new line in the middle of one of those.\n\n\n\n You can even insert a newline inside any token if you prepend it with a backslash:\n\n \n\n \n\n In VB statements are delimited by newlines but in C/C++ they are delimited by semicolons so newlines don't matter at all ( unless you are in some preprocessor directive ) In C/C++ you can put newlines everywhere you can put a space:You can even insert a newline inside any token if you prepend it with a backslash:In VB statements are delimited by newlines but in C/C++ they are delimited by semicolons so newlines don't matter at all ( unless you are in some preprocessor directive )\n\n\n\n Normally you don't need to tell the compiler anything, it will just read for more input until the current input construct is satisfied or it meets a semi-colon (;).\n\n \n\n What are you trying to do?\n\n \n\n It is normally a \\ character which is applied to instruct the C Preprocessor that the current definition extends to the line beyond. \n\n The same \\ character is also used for continuing string literals.\n\n \n\n Examples:\n\n \n\n *str = \"A string... \\ which continues to this line\\ and this line too.\" ; C is rather flexible when it comes to how things are arranged.Normally you don't need to tell the compiler anything, it will just read for more input until the current input construct is satisfied or it meets a semi-colon (;).What are you trying to do?It is normally a \\ character which is applied to instruct the C Preprocessor that the current definition extends to the line beyond.The same \\ character is also used for continuing string literals.Examples:\n\nThanks for clearing that up. Well, not that I usually have string literals that are that long anyways :O"
    },
    {
        "link": "https://stackoverflow.com/questions/72135662/manipulating-the-standard-output-stream-to-print-multiline-strings-horizontally",
        "document": "If you are certain that your output will always be displayed on a modern terminal supporting “ANSI Escape Codes” then you can use that to your advantage.\n\nThe addition of spacing is, of course, entirely optional and only added for demonstrative purposes.\n\nThe advantage to this method is that you do not have to store or otherwise take any special care for strings containing multi-byte characters (UTF-8, as yours does) or any additional information like terminal color sequences.\n\nThat is, you could color each of your blocks differently by adding a color sequence to each variable! (The caveat is that you must repeat a color sequence after every newline. This is a known problem with various terminals...)\n\nThe other caveat to this particular example is that you must be aware of where the text caret (“cursor”) ends-up after each output. You could also use terminal escape sequences to absolutely position the caret before every output.\n\nThen you wouldn’t have to care where the caret ends up. Just specify an absolute position before printing. Just don’t let the text scroll!\n\nFinally, if you are on Windows and using the old Windows Console, you must initialize the terminal for ANSI terminal sequences and for UTF-8 output:\n\nThis does no harm to the new Windows Terminal. I recommend you do it either way just because you do not know which of the two your user will use to run your program, alas."
    },
    {
        "link": "https://stackoverflow.com/questions/53425475/write-a-multi-line-string-with-variable-values-included",
        "document": "I have program parameters which require me to have a single formatted string containing the values of variables input during the course of the program. Because of the amount of data involved, newlines for each new point of data would be ideal.\n\nI'm using Visual Studio's C++ compiler, and have the following headers already:\n\nI tried to concatenate the values and string fragments like this:\n\nbut I keep getting this error: \"expression must have integral or unscoped enum type\".\n\nI'm basing this format on how a cout statement works, and replaced all '<<' with '+' to concatenate on, rather than the 'next statement' the double carrots mean.\n\nAm I on the right track? Missing something obvious? Can this be done, at all?"
    },
    {
        "link": "https://fluentcpp.com/2017/12/19/build-strings-from-plain-string-up-to-boost-karma",
        "document": "The Complete Guide to Building Strings In C++: From “Hello World” Up To Boost Karma\n\nBuilding strings sounds like one of the most basic things a programmer can do in any language. But in fact there is a lot of ways to go about it in C++, depending on how complex your need is. Here we see a span of alternatives, ranging from the basic of ‘s constructor all the way up to Boost Karma that lets you express complex string building in very concise code.\n\nAs this is a relatively long post, here is its outline:\n• Building a string out of TWO strings\n• Throwing everything but the kitchen *string* at it\n• Boost Karma, there we are\n• Let’s go out and build strings now\n\nThe most basic way to build a string, that you quite certainly already know, is this:\n\nWhat is a little less known though, is that long strings can be broken over lines, without any special syntax except quotes:\n\nThis is useful for example for writing SQL requests in your code, because they can sometimes be more readable if wrapped over several lines. And don’t forget to put a space at the end of each substring if needed, otherwise the first word of a given line will be stuck onto the last one of the previous line.\n\nThis trick also lets you create straight strings but with code indented and spread over several lines. The following string for example:\n\ncan be expanded into a more structured code, but keeping the same exact value:\n\nI found this helpful more than once.\n\nThe end of a string literal in code is delimited by a quote ( ). But what if you want your string to actually contain a quote? It needs to be escaped with a backslash ( ):\n\nPrinting out that string indeed gives:\n\nIn C++11, raw strings literals allow to treat every character as part of the string. An marks a raw string, and it is surrounded by parentheses the following way:\n\nThis creates the same string as above. Note how the quotes are no longer escaped.\n\nEvery character inside a raw string counts as part of the string, and this includes new lines and other blank space. For instance the following raw string literal:\n\nlooks like this when printed out:\n\nThe whitespace comes from the fact that the second line inside the raw string literal is away from the left margin of the text editor of the IDE. So you need to be careful with that. If you want several lines of a raw string to be aligned, you need to align them against the left margin in the source code itself:\n\nwhich can seem a curious form of indentation.\n\nOne last thing about ‘s constructor: you can build a string that consists of the repetition of one character. For example the following code:\n\nwh ich is the savage sound emitted by a software developer who lost part of its humanity by spending hours chasing a non-reproducible bug caused by an incorrect . More on later.\n\nBuilding a string out of TWO strings\n\nThe most simple way to concatenate strings in C++ is by using the + (or +=) operator:\n\nThese operators have several overloads, including one taking a to append string literals:\n\nNow you may wonder what the performance cost of these operations is. Is it better to use or ? I have thrown the comparative cases of building a single string into a Google Benchmark, testing the difference between:\n\nfor strings of various sizes, and on my tests the difference was not significant for long strings, and was slightly faster for small strings. In this case I suspect that the Return Value Optimization plays a role in this. But this can vary widely between compilers, so if you want to know for sure on your platform you’d still need to run a test I’m afraid.\n\nNote that you can call the method on the result string before performing the concatenation, to let it know how much data is going to come in and let it allocate. But this can have surprising performance results, and it will be the topic of a dedicated post.\n\nImagine the following scenario: you have a bunch of strings, and you want to concatenate them all into one big string. How to do this in C++?\n\nOne way to go about this in a one liner is by a direct use of :\n\nIndeed, takes a collection and an initial value, and successively applies on the value and each element of the collection, each times updating the value with the result of the sum. And, as we saw just above, concatenates two strings.\n\nNote here that the initial value has to be and not simply because takes a template parameter for the value. And since there is no implicit conversion in template type deduction, the algorithm will consider that it is operating on (which is the type of ) and this conflicts with the outcome of which is an and can’t be assigned back into the accumulator.\n\nAlthough this method is very concise, it’s not the fastest you can get. Indeed, lots of strings are constructed and destroyed during the traversal of the collection. To use the same string all along the traversal of the collection, you can roll out a simple loop:\n\nI’ve compared the two pieces of code with Google Benchmark, and the second one (without algorithms) came out 4.5x faster than the first one in my test.\n\nAnd to make the test fairer I haven’t added a with the total size of the concatenated string, but in practice you would probably want to add this before the loop:\n\nSo the algorithm version is more concise, but slower. STL algorithms generally lead to better code, but in this case I haven’t found what algorithm would be superior to the for loop on all criteria including performance. If you see how, please leave a comment.\n\nReading all the contents of a file into a string can be achieved the following way:\n\nis an output stream made for building strings (see the following section). is an input stream that reads from a file and stores its contents into its internal buffer. This internal buffer can be accessed through the method, and is read until exhaustion by the of the output stream.\n\nThrowing everything but the kitchen *string* at it\n\nSo far we’ve covered how to make strings out of other strings. But often comes up the need of pushing other things like numbers or even custom types into a string.\n\nTo just convert a numeric value into a string, use the set of overload:\n\nAnd it also works for floating point numbers.\n\nNote that this method can’t be directly overloaded with custom types, because it lives in the namespace, and we as C++ developers (and not library implementers) are not allowed to add anything to the namespace.\n\nThere are ways to end up using for your types though, but it requires some work explained in a dedicated article.\n\nNow let’s get to the main component that lets you push various types objects into a string: .\n\nAn is an output stream, that is to say it offers an through which you can send it data. And when called on its method, the produces the concatenation of all the data it was sent.\n\nWhat makes it really powerful is that has overloads on various types. The standard offers overloads on native types, like those used in the following code:\n\nNote that I recommend that you DON’T name your ostringstreams “oss”, because it doesn’t carry any information about what they represent. Naming is an important topic that is crucial for keeping code expressive, so it’s worth making the extra effort to figure out what variables represent.\n\ncan also be used on custom types, if they overload :\n\n(in this case I do use as a name for the stream because here there isn’t much to say about it, apart that it is an output stream).\n\nHere is customized on and not but it works because the latter derives from the former, and this way we get an implementation for the other types of outputs streams (e.g. file output stream) for free.\n\nIt can be used like in this code:\n\nNote that the method outputs a temporary , that is destroyed at the end of the statement it is invoked in (unless it is bound to a const reference, see Herb Sutter’s Most important const). So you can’t hold a reference to something that belongs to this particular string:\n\ncan be handily connected to an output iterator especially designed for pushing into output streams: , which can itself be used in STL algorithms. This is a very symmetric construction to the first one in How to split a string in C++. The following code:\n\noffers the possibility to add a delimiting string between the various values sent to the it is connected to:\n\nwhich creates a string that contains:\n\nGranted, there is a trailing delimiter at the end, but this overload can be very handy to quickly send space delimited values to a human readable display, at least for debugging purposes.\n\nThis is an example using which is extremely simple, but this technique works just as well with all the other algorithms in the STL.\n\nStreams are vast. It’s a seldom explored region of the standard library, but it resembles a little world populated by objects, functions and other tags and sentries that interact together. I certainly don’t claim to know it in depth, but I’ve fished out a bunch of its inhabitants for you, that let you do formatting.\n\nThese objects can be pushed into an output stream (and in particular into an ) with . While these operations don’t output characters by themselves, they indicate to the stream how you want the actual characters to be formatted.\n\ncan be used to indicate the amount of space that a piece of data should occupy in the string. If this data is smaller, then the rest of the space is padded. The padding is done after the data when using , and before the data when using :\n\nleads to a string that contains:\n\nIt’s a bit of a mouthful of code to not say that much, but we will take care or making it more expressive at a later time (spoiler alert: I’ll ask you to participate).\n\nBy default the padding is done with whitespace, but this can be changed with the method. For instance the following code:\n\nNote that while only affect the next data coming into the stream (which does not include and such), all the others we’ve seen here maintain their effect until encountering a counter-order further down the stream.\n\nFinally, can force a maximum number of digits to a displayed number. It can be used in conjunction with to fix an exact number of decimals (and no longer digits):\n\nTo save you some time searching for the right headers, note that those formatting components are included in two headers:\n• It is in that you will find:\n• And in that you will find:\n\nThanks to Patrice Roy for pointing out this clarification.\n\nSpeaking about formatting, this is what Boost Format is made for.\n\nNote: the following Boost libraries can make an intensive use of templates, which can result in slower compilation times.\n\nThe point here isn’t to duplicate the library’s official documentation, which is quite clear by the way, but rather to let you how what kind of things this library can let you do.\n\nThe approach of Boost Format is to separate the formatting instructions from the actual contents that are to be formatted. You start by first specifying how the whole string should look like, and then fill in the contents (potentially at a later time). This contrasts with where formatting information alternates with the content to be formatted.\n\nBoost Format takes a string that describes the format that the output should take, and uses to feed in the contents to be formatted. It offers an that takes an standard output stream (like or an ) and pushes the formatted content into it.\n\nHere is what a usage of Boost Format looks like:\n\nThe string then produced will look like this:\n\n“Huh?” I can hear you wonder. “Isn’t this just like printf?!”.\n\nBoost Format has indeed in common with printf that formatting is decoupled from filling contents, but the comparison pretty much stops here.\n\nIn fact, consider the story of the Titanic meeting the Iceberg in those 3 aspects:\n• you can get into real trouble if you were in the Titanic,\n• the iceberg is much stronger,\n• there is a lot more to the iceberg than meets the eye.\n\nHere we have a very similar story between printf and Boost Format. I let you figure out which one plays the role of the Titanic.\n\nThe advantages of Boost Format over printf include:\n• More safety: while printf can sliently cause a memory corruption if the contents to be formatted do not correspond to the formatting string, Boost Format will throw exceptions.\n• More formatting features: the formatting possibilities of Boost Format are much richer. For example, amongst many other things, they include the reordering of the contents passed:\n• More flexibility: you can even pass in your own types as long as they have an . By using the class from above:\n\nTo start using Boost Format, simply , and off you go.\n\nBoost Karma, there we are\n\nThis is the final step of our voyage through string building in C++.\n\nBoost Karma, which is a part of the larger Boost Spirit library, provides more powerful features than the other components seen above, and comes with an arguably less direct syntax. Once again, the purpose here is not to replicate the well-done official documentation, but rather to give you an overview of its concepts.\n\nEssentially, Boost Karma revolves about two types of components: generators and generating functions.\n\nGenerating functions are provided by the library. They are not too many of them. They take an input, a generator and an output, and format the input with the generator in order to put the result in the output.\n\nAnd the library provides basic generators that can be combined into arbitrarily elaborate constructions.\n\nHere is a very simple usage of Boost Karma:\n\nAt the end of this code, contains the string “ “.\n\nBut the generators can be combined into more complex structures, and some generation functions accept a collection of parameters.\n\nHere is an how to display the contents of a vector, separated by commas and without a trailing comma at the end:\n\nThis interesting bit here is the generator. It can be interpreted this way:\n• : print the first element (if there is one) with the format of an integer,\n• : “and then”: combine with another generator that will take care of the rest of the elements,\n• : repeat the following as many times as possible. It looks like the * in regex except the C++ syntax forces this to be at the beginning since this is implemented as an overload of unary ,\n• print the next element as an integer.\n\nWith the above code, contains the string “ “.\n\nAs a final example, generators can implement a logic combined to the elements taken by the generating function. This example is directly taken from the official documentation. It aims at formatting a complex number with the following logic:\n• if the imaginary part is null, just print the real part,\n• if not, print the number between brackets, with the real part and the imaginary part separated by a comma.\n\nFirst have a look at the input:\n\nNow let’s see what this generator does in details:\n• : if the first input parameter ( ) is equal to zero, this part of the generator “fails”. This mean that the rest of the generator until the next part (starting after the pipe ( character) is ignored. A new trial will be done with the next part of the generator,\n• : and then print the complex number is the expected format, with the second ( ) and third ( ) argument of the input,\n• : if the previous generator succeeded then ignore the following, otherwise try the following,\n• : and then print the second input argument ( ).\n\nWith the above code, contains .\n\nLet’s go out and build strings now\n\nNow your C++ toolbox is bursting with tools to build strings. You can pick the ones that fit best each of your needs.\n\nOf course, the simpler is always the better so the tools at the top of the page are used quite extensively, and those deeper down the page bring the power and complexity that are needed in rarer contexts. Hopefully. But it is still interesting to see various designs to generate arbitrarily complex strings!\n\nI hope this has been helpful to you and, as always, your feedback is more than welcome. In particular if you see something you think should be included in this guide – do let me know!\n\nDon't want to miss out ? Share this post!"
    },
    {
        "link": "https://geeksforgeeks.org/printing-output-in-multiple-lines-in-cpp",
        "document": "This article focuses on discussing how to use cout for multi-line printing. This can be easily done using any of these two methods:\n\nLet’s discuss each of these methods in detail.\n\nThe endl statement can be used to print the multi-line string in a single cout statement. Below is the C++ program to show the same:\n\n‘\n\n’ can be used instead of endl to print multi-line strings. Below is the C++ program to implement the above approach:"
    },
    {
        "link": "https://cppstories.com/2023/six-handy-ops-for-string-processing",
        "document": "In this article, we’ll explore six practical string processing operations introduced in C++20 and C++23. These features represent an evolution in this crucial area, covering a spectrum of operations from searching and appending to creation and stream handling.\n\nFinally, after decades of standardization, we have a super easy way to check if there’s one string inside the other. No need to use !\n\nAnd now, thanks to the proposal: P1679R3:\n\nAs you can see, the new approach with is more straightforward and intuitive.\n\nWhile checks the whole string, in C++20, we got functions targeted for prefixes and suffixes. Have a look:\n\nIt’s good to know that in C++23, those algorithms are also extended to ranges, so you’ll be able to write:\n\nThe range versions are interesting, as they allow passing projections, and thus, we can be more flexible about the check between separate letters/elements.\n\nAnd you can see more about the string functions in my separate article: starts_with() and ends_with() for Strings in C++20 - C++ Stories\n\nThanks to , many containers from the Standard Library got new ways to assign, append, or insert ranges.\n\nThe string class got the following members:\n\nFor example (stealing a cool example from C++Reference):\n\nSee more in the paper P1206R7\n\nWe can also write a bit convoluted example with :\n\nIf you have to work with streams, and in particular, you may already know they might be pretty slow. Yet, in Modern C++, there are a couple of ways to speed things up a bit. For example, in C++20, you have the member function. This can be used as an alternative to . In short, rather than creating a copy of the internal string, you’ll get a view, so there is no need to dynamically allocate memory.\n\nWhen the example calls , you can see that there’s extra memory allocation for 36 bytes. But in the line with , there’s no allocation.\n\nBut there’s more to in C++20! For example, there’s an extra constructor that can take an rvalue reference to the string object, and thus it might not require an additional copy:\n\nWhen we compile the code with the C++17 mode (See at Compiler Explorer) you’ll see the following output:\n\nThere’s clearly a copy of the string.\n\nBut try compiling that with the flag….\n\nIf you need to use , and the previous techniques didn’t bring you any gains, and you want complete control over the internal memory, in C++23, you can easily update your code with !\n\nIn short, this is a stream class that operates on spans (also from C++20). Have a look at this simplistic example:\n\nIn the first part - - the example shows a regular . Our simplistic memory allocation tracker points out 513 bytes had to be allocated.\n\nOn the other hand, in the second part, we have the new type, , which uses a preallocated buffer (a regular array), and this buffer is used as the internal memory for the stream object.\n\nIn this text, we explored a range of functionalities, from basic searching with to sophisticated stream operations with , each bringing its unique advantage to the table. These enhancements can significantly simplify everyday programming tasks.\n\nBut there’s more in C++20/23:\n• What string operations do you use the most often?\n• Have you played with the latest additions to string/stream processing in C++20/23?"
    }
]