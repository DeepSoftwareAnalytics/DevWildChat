[
    {
        "link": "https://developer.android.com/guide/components/activities/activity-lifecycle",
        "document": "As a user navigates through, out of, and back to your app, the instances in your app transition through different states in their lifecycle. The class provides a number of callbacks that let the activity know when a state changes or that the system is creating, stopping, or resuming an activity or destroying the process the activity resides in.\n\nWithin the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. When the user returns, you can reconnect to the network and let the user resume the video from the same spot.\n\nEach callback lets you perform specific work that's appropriate to a given change of state. Doing the right work at the right time and handling transitions properly make your app more robust and performant. For example, good implementation of the lifecycle callbacks can help your app avoid the following:\n• Crashing if the user receives a phone call or switches to another app while using your app.\n• Consuming valuable system resources when the user is not actively using it.\n• Losing the user's progress if they leave your app and return to it at a later time.\n• Crashing or losing the user's progress when the screen rotates between landscape and portrait orientation.\n\nThis document explains the activity lifecycle in detail. The document begins by describing the lifecycle paradigm. Next, it explains each of the callbacks: what happens internally while they execute and what you need to implement during them.\n\nIt then briefly introduces the relationship between activity state and a process’s vulnerability to being killed by the system. Finally, it discusses several topics related to transitions between activity states.\n\nFor information about handling lifecycles, including guidance about best practices, see Handling Lifecycles with Lifecycle-Aware Components and Save UI states. To learn how to architect a robust, production-quality app using activities in combination with architecture components, see Guide to app architecture.\n\nTo navigate transitions between stages of the activity lifecycle, the class provides a core set of six callbacks: , , , , , and . The system invokes each of these callbacks as the activity enters a new state.\n\nAs the user begins to leave the activity, the system calls methods to dismantle the activity. In some cases, the activity is only partially dismantled and still resides in memory, such as when the user switches to another app. In these cases, the activity can still come back to the foreground.\n\nIf the user returns to the activity, it resumes from where the user left off. With a few exceptions, apps are restricted from starting activities when running in the background.\n\nThe system’s likelihood of killing a given process, along with the activities in it, depends on the state of the activity at the time. For more information on the relationship between state and vulnerability to ejection, see the section about activity state and ejection from memory.\n\nDepending on the complexity of your activity, you probably don't need to implement all the lifecycle methods. However, it's important that you understand each one and implement those that make your app behave the way users expect.\n\nThis section provides conceptual and implementation information about the callback methods used during the activity lifecycle.\n\nSome actions belong in the activity lifecycle methods. However, place code that implements the actions of a dependent component in the component, rather than the activity lifecycle method. To achieve this, you need to make the dependent component lifecycle-aware. To learn how to make your dependent components lifecycle-aware, see Handling Lifecycles with Lifecycle-Aware Components.\n\nYou must implement this callback, which fires when the system first creates the activity. On activity creation, the activity enters the Created state. In the method, perform basic application startup logic that happens only once for the entire life of the activity.\n\nFor example, your implementation of might bind data to lists, associate the activity with a , and instantiate some class-scope variables. This method receives the parameter , which is a object containing the activity's previously saved state. If the activity has never existed before, the value of the object is null.\n\nIf you have a lifecycle-aware component that is hooked up to the lifecycle of your activity, it receives the event. The method annotated with is called so your lifecycle-aware component can perform any setup code it needs for the created state.\n\nThe following example of the method shows fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI. In this example, the XML layout file passes the file’s resource ID to .\n\nAs an alternative to defining the XML file and passing it to , you can create new objects in your activity code and build a view hierarchy by inserting new objects into a . You then use that layout by passing the root to . For more information about creating a user interface, see the user interface documentation.\n\nYour activity does not remain in the Created state. After the method finishes execution, the activity enters the Started state and the system calls the and methods in quick succession.\n\nWhen the activity enters the Started state, the system invokes . This call makes the activity visible to the user as the app prepares for the activity to enter the foreground and become interactive. For example, this method is where the code that maintains the UI is initialized.\n\nWhen the activity moves to the Started state, any lifecycle-aware component tied to the activity's lifecycle receives the event.\n\nThe method completes quickly and, as with the Created state, the activity does not remain in the Started state. Once this callback finishes, the activity enters the Resumed state and the system invokes the method.\n\nWhen the activity enters the Resumed state, it comes to the foreground, and the system invokes the callback. This is the state in which the app interacts with the user. The app stays in this state until something happens to take focus away from the app, such as the device receiving a phone call, the user navigating to another activity, or the device screen turning off.\n\nWhen the activity moves to the Resumed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can enable any functionality that needs to run while the component is visible and in the foreground, such as starting a camera preview.\n\nWhen an interruptive event occurs, the activity enters the Paused state and the system invokes the callback.\n\nIf the activity returns to the Resumed state from the Paused state, the system once again calls the method. For this reason, implement to initialize components that you release during and to perform any other initializations that must occur each time the activity enters the Resumed state.\n\nHere is an example of a lifecycle-aware component that accesses the camera when the component receives the event:\n\nThe preceding code initializes the camera once the receives the event. In multi-window mode, however, your activity might be fully visible even when it is in the Paused state. For example, when the app is in multi-window mode and the user taps the window that does not contain your activity, your activity moves to the Paused state.\n\nIf you want the camera active only when the app is Resumed (visible and active in the foreground), then initialize the camera after the event demonstrated previously. If you want to keep the camera active while the activity is Paused but visible, such as in multi-window mode, then initialize the camera after the event.\n\nHowever, having the camera active while your activity is Paused might deny access to the camera to another Resumed app in multi-window mode. Sometimes it is necessary to keep the camera active while your activity is Paused, but it might actually degrade the overall user experience if you do.\n\nFor this reason, think carefully about where in the lifecycle it is most appropriate to take control of shared system resources in the context of multi-window mode. To learn more about supporting multi-window mode, see Multi-window support.\n\nRegardless of which build-up event you choose to perform an initialization operation in, make sure to use the corresponding lifecycle event to release the resource. If you initialize something after the event, release or terminate it after the event. If you initialize after the event, release after the event.\n\nThe preceding code snippet places camera initialization code in a lifecycle-aware component. You can instead put this code directly into the activity lifecycle callbacks, such as and , but we don't recommend this. Adding this logic to an independent, lifecycle-aware component lets you reuse the component across multiple activities without having to duplicate code. To learn how to create a lifecycle-aware component, see Handling Lifecycles with Lifecycle-Aware Components.\n\nThe system calls this method as the first indication that the user is leaving your activity, though it does not always mean the activity is being destroyed. It indicates that the activity is no longer in the foreground, but it is still visible if the user is in multi-window mode. There are several reasons why an activity might enter this state:\n• An event that interrupts app execution, as described in the section about the onResume() callback, pauses the current activity. This is the most common case.\n• In multi-window mode, only one app has focus at any time, and the system pauses all the other apps.\n• The opening of a new, semi-transparent activity, such as a dialog, pauses the activity it covers. As long as the activity is partially visible but not in focus, it remains paused.\n\nWhen an activity moves to the Paused state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not in the foreground, such as stopping a camera preview.\n\nUse the method to pause or adjust operations that can't continue, or might continue in moderation, while the is in the Paused state, and that you expect to resume shortly.\n\nYou can also use the method to release system resources, handles to sensors (like GPS), or any resources that affect battery life while your activity is Paused and the user does not need them.\n\nHowever, as mentioned in the section about , a Paused activity might still be fully visible if the app is in multi-window mode. Consider using instead of to fully release or adjust UI-related resources and operations to better support multi-window mode.\n\nThe following example of a reacting to the event is the counterpart to the preceding event example, releasing the camera that initializes after the event is received:\n\nThis example places the camera release code after the event is received by the .\n\nexecution is very brief and does not necessarily offer enough time to perform save operations. For this reason, don't use to save application or user data, make network calls, or execute database transactions. Such work might not complete before the method completes.\n\nInstead, perform heavy-load shutdown operations during . For more information about suitable operations to perform during , see the next section. For more information about saving data, see the section about saving and restoring state.\n\nCompletion of the method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or it becomes completely invisible to the user. If the activity resumes, the system once again invokes the callback.\n\nIf the activity returns from the Paused state to the Resumed state, the system keeps the instance resident in memory, recalling that instance when the system invokes . In this scenario, you don’t need to re-initialize components created during any of the callback methods leading up to the Resumed state. If the activity becomes completely invisible, the system calls .\n\nWhen your activity is no longer visible to the user, it enters the Stopped state, and the system invokes the callback. This can occur when a newly launched activity covers the entire screen. The system also calls when the activity finishes running and is about to be terminated.\n\nWhen the activity moves to the Stopped state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not visible on the screen.\n\nIn the method, release or adjust resources that are not needed while the app is not visible to the user. For example, your app might pause animations or switch from fine-grained to coarse-grained location updates. Using instead of means that UI-related work continues, even when the user is viewing your activity in multi-window mode.\n\nAlso, use to perform relatively CPU-intensive shutdown operations. For example, if you can't find a better time to save information to a database, you might do so during . The following example shows an implementation of that saves the contents of a draft note to persistent storage:\n\nThe preceding code sample uses SQLite directly. However, we recommend using Room, a persistence library that provides an abstraction layer over SQLite. To learn more about the benefits of using Room and how to implement Room in your app, see the Room Persistence Library guide.\n\nWhen your activity enters the Stopped state, the object is kept resident in memory: it maintains all state and member information, but is not attached to the window manager. When the activity resumes, it recalls this information.\n\nYou don’t need to re-initialize components created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each object in the layout, so if the user enters text into an widget, that content is retained so you don't need to save and restore it.\n\nNote: Once your activity is stopped, the system might destroy the process that contains the activity if the system needs to recover memory. Even if the system destroys the process while the activity is stopped, the system still retains the state of the objects, such as text in an widget, in a —a blob of key-value pairs—and restores them if the user navigates back to the activity. For more information about restoring an activity to which a user returns, see the section about saving and restoring state.\n\nFrom the Stopped state, the activity either comes back to interact with the user, or the activity is finished running and goes away. If the activity comes back, the system invokes . If the is finished running, the system calls .\n\nis called before the activity is destroyed. The system invokes this callback for one of two reasons:\n• The activity is finishing, due to the user completely dismissing the activity or due to being called on the activity.\n• The system is temporarily destroying the activity due to a configuration change, such as device rotation or entering multi-window mode.\n\nWhen the activity moves to the destroyed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can clean up anything they need to before the is destroyed.\n\nInstead of putting logic in your to determine why it is being destroyed, use a object to contain the relevant view data for your . If the is recreated due to a configuration change, the does not have to do anything, since it is preserved and given to the next instance.\n\nIf the isn't recreated, then the has the method called, where it can clean up any data it needs to before being destroyed. You can distinguish between these two scenarios with the method.\n\nIf the activity is finishing, is the final lifecycle callback the activity receives. If is called as the result of a configuration change, the system immediately creates a new activity instance and then calls on that new instance in the new configuration.\n\nThe callback releases all resources not released by earlier callbacks, such as .\n\nThe system kills processes when it needs to free up RAM. The likelihood of the system killing a given process depends on the state of the process at the time. Process state, in turn, depends on the state of the activity running in the process. Table 1 shows the correlations among process state, activity state, and the likelihood of the system killing the process. This table only applies if a process is not running other types of application components.\n\nThe system never kills an activity directly to free up memory. Instead, it kills the process the activity runs in, destroying not only the activity but everything else running in the process as well. To learn how to preserve and restore your activity's UI state when system-initiated process death occurs, see the section about saving and restoring state.\n\nThe user can also kill a process by using the Application Manager, under Settings, to kill the corresponding app.\n\nFor more information about processes, see Processes and threads overview.\n\nA user expects an activity’s UI state to remain the same throughout a configuration change, such as rotation or switching into multi-window mode. However, the system destroys the activity by default when such a configuration change occurs, wiping away any UI state stored in the activity instance.\n\nSimilarly, a user expects UI state to remain the same if they temporarily switch away from your app to a different app and then come back to your app later. However, the system can destroy your application’s process while the user is away and your activity is stopped.\n\nWhen system constraints destroy the activity, preserve the user’s transient UI state using a combination of , , and/or local storage. To learn more about user expectations compared to system behavior and how to best preserve complex UI state data across system-initiated activity and process death, see Save UI states.\n\nThis section outlines what instance state is and how to implement the method, which is a callback on the activity itself. If your UI data is lightweight, you can use alone to persist the UI state across both configuration changes and system-initiated process death. But because incurs serialization/deserialization costs, in most cases you use both and , as outlined in Save UI states.\n\nNote: To learn more about configuration changes, how to restrict Activity recreation if needed, and how to react to those configuration changes from the View system and Jetpack Compose, check out the Handle configuration changes page.\n\nThere are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling the method.\n\nWhen your activity is destroyed because the user presses Back or the activity finishes itself, both the system's and the user's concept of that instance is gone forever. In these scenarios, the user's expectation matches the system's behavior, and you do not have any extra work to do.\n\nHowever, if the system destroys the activity due to system constraints (such as a configuration change or memory pressure), then although the actual instance is gone, the system remembers that it existed. If the user attempts to navigate back to the activity, the system creates a new instance of that activity using a set of saved data that describes the state of the activity when it was destroyed.\n\nThe saved data that the system uses to restore the previous state is called the instance state. It's a collection of key-value pairs stored in a object. By default, the system uses the instance state to save information about each object in your activity layout, such as the text value entered into an widget.\n\nSo, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.\n\nNote: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the attribute.\n\nA object isn't appropriate for preserving more than a trivial amount of data, because it requires serialization on the main thread and consumes system-process memory. To preserve more than a very small amount of data, take a combined approach to preserving data, using persistent local storage, the method, and the class, as outlined in Save UI states.\n\nAs your activity begins to stop, the system calls the method so your activity can save state information to an instance state bundle. The default implementation of this method saves transient information about the state of the activity's view hierarchy, such as the text in an widget or the scroll position of a widget.\n\nTo save additional instance state information for your activity, override and add key-value pairs to the object that is saved in the event that your activity is destroyed unexpectedly. When you override , you need to call the superclass implementation if you want the default implementation to save the state of the view hierarchy. This is shown in the following example:\n\nNote: is not called when the user explicitly closes the activity or in other cases when is called.\n\nTo save persistent data, such as user preferences or data for a database, take appropriate opportunities when your activity is in the foreground. If no such opportunity arises, save persistent data during the method.\n\nWhen your activity is recreated after it was previously destroyed, you can recover your saved instance state from the that the system passes to your activity. Both the and callback methods receive the same that contains the instance state information.\n\nBecause the method is called whether the system is creating a new instance of your activity or recreating a previous one, you need to check whether the state is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.\n\nThe following code snippet shows how you can restore some state data in :\n\nInstead of restoring the state during , you can choose to implement , which the system calls after the method. The system calls only if there is a saved state to restore, so you do not need to check whether the is null.\n\nCaution: Always call the superclass implementation of so the default implementation can restore the state of the view hierarchy.\n\nAn app is likely to enter and exit an activity, perhaps many times, during the app’s lifetime, such as when the user taps the device’s Back button or the activity launches a different activity.\n\nThis section covers topics you need to know to implement successful activity transitions. These topics include starting an activity from another activity, saving activity state, and restoring activity state.\n\nStarting one activity from another\n\nAn activity often needs to start another activity at some point. This need arises, for instance, when an app needs to move from the current screen to a new one.\n\nDepending on whether or not your activity wants a result back from the new activity it’s about to start, you start the new activity using either the method or the method. In either case, you pass in an object.\n\nThe object specifies either the exact activity you want to start or describes the type of action you want to perform. The system selects the appropriate activity for you, which can even be from a different application. An object can also carry small amounts of data to be used by the activity that is started. For more information about the class, see Intents and Intent Filters.\n\nIf the newly started activity does not need to return a result, the current activity can start it by calling the method.\n\nWhen working within your own application, you often need to simply launch a known activity. For example, the following code snippet shows how to launch an activity called .\n\nYour application might also want to perform some action, such as send an email, text message, or status update, using data from your activity. In this case, your application might not have its own activities to perform such actions, so you can instead leverage the activities provided by other applications on the device, which can perform the actions for you.\n\nThis is where intents are really valuable. You can create an intent that describes an action you want to perform, and the system launches the appropriate activity from another application. If there are multiple activities that can handle the intent, then the user can select which one to use. For example, if you want to let the user send an email message, you can create the following intent:\n\nThe extra added to the intent is a string array of email addresses the email is to be sent to. When an email application responds to this intent, it reads the string array provided in the extra and places the addresses in the \"to\" field of the email composition form. In this situation, the email application's activity starts, and when the user is done, your activity resumes.\n\nSometimes you want to get a result back from an activity when it ends. For example, you might start an activity that lets the user pick a person in a list of contacts. When it ends, it returns the person that was selected. To do this, you call the method, where the integer parameter identifies the call.\n\nThis identifier is meant to distinguish between multiple calls to from the same activity. It's not a global identifier and is not at risk of conflicting with other apps or activities. The result comes back through your method.\n\nWhen a child activity exits, it can call to return data to its parent. The child activity must supply a result code, which can be the standard results , , or any custom values starting at .\n\nIn addition, the child activity can optionally return an object containing any additional data it wants. The parent activity uses the method, along with the integer identifier the parent activity originally supplied, to receive the information.\n\nIf a child activity fails for any reason, such as crashing, the parent activity receives a result with the code .\n\nWhen one activity starts another, they both experience lifecycle transitions. The first activity stops operating and enters the Paused or Stopped state, while the other activity is created. In case these activities share data saved to disc or elsewhere, it's important to understand that the first activity is not completely stopped before the second one is created. Rather, the process of starting the second one overlaps with the process of stopping the first one.\n\nThe order of lifecycle callbacks is well defined, particularly when the two activities are in the same process—in other words, the same app—and one is starting the other. Here's the order of operations that occur when Activity A starts Activity B:\n• Activity B's , , and methods execute in sequence. Activity B now has user focus.\n• If Activity A is no longer visible on screen, its method executes.\n\nThis sequence of lifecycle callbacks lets you manage the transition of information from one activity to another."
    },
    {
        "link": "https://developer.android.com/guide/components/activities/state-changes",
        "document": "Different events, some user-triggered and some system-triggered, can cause an to transition from one state to another. This document describes some common cases in which such transitions happen and how to handle those transitions.\n\nFor more information about activity states, see The activity lifecycle. To learn about how the class can help you manage the activity lifecycle, see the ViewModel overview.\n\nThere are a number of events that can trigger a configuration change. Perhaps the most prominent example is a change between portrait and landscape orientations. Other cases that can cause configuration changes include changes to language settings or input device.\n\nWhen a configuration change occurs, the activity is destroyed and recreated. This triggers the following callbacks in the original activity instance:\n\nA new instance of the activity is created, and the following callbacks are triggered:\n\nUse a combination of instances, the method, or persistent local storage to preserve an activity’s UI state across configuration changes. Deciding how to combine these options depends on the complexity of your UI data, use cases for your app, and consideration of the speed of retrieval versus memory usage. For more information about saving your activity UI state, see Save UI states.\n\nWhen an app enters multi-window mode, available in Android 7.0 (API level 24)and higher, the system notifies the running activity of a configuration change, thus going through the lifecycle transitions described previously.\n\nThis behavior also occurs if an app already in multi-window mode gets resized. Your activity can handle the configuration change itself, or it can allow the system to destroy the activity and recreate it with the new dimensions.\n\nFor more information about the multi-window lifecycle, see the explanation of the multi-window lifecycle in the Multi-window support page.\n\nIn multi-window mode, although there are two apps that are visible to the user, only the one the user is interacting with is in the foreground and has focus. That activity is in the Resumed state, while the app in the other window is in the Paused state.\n\nWhen the user switches from app A to app B, the system calls on app A and on app B. It switches between these two methods each time the user toggles between apps.\n\nFor more details about multi-window mode, refer to Multi-window support.\n\nIf a new activity or dialog appears in the foreground, taking focus and partially covering the activity in progress, the covered activity loses focus and enters the Paused state. Then, the system calls on it.\n\nWhen the covered activity returns to the foreground and regains focus, the system calls .\n\nIf a new activity or dialog appears in the foreground, taking focus and completely covering the activity in progress, the covered activity loses focus and enters the Stopped state. The system then, in rapid succession, calls and .\n\nWhen the same instance of the covered activity returns to the foreground, the system calls , , and on the activity. If it is a new instance of the covered activity that comes to the background, the system does not call , only and .\n\nIf an activity is in the foreground and the user taps or gestures Back, the activity transitions through the , , and callbacks. The activity is destroyed and removed from the back stack.\n\nBy default, the callback does not fire in this case. This behavior assumes the user taps Back with no expectation of returning to the same instance of the activity.\n\nHowever, you can override the method to implement custom behavior, such as displaying a dialog that asks the user to confirm that they want to exit your app.\n\nIf you override the method, we highly recommend that you still invoke from your overridden method. Otherwise the system Back behavior might be jarring to the user.\n\nIf an app is in the background and the system needs to free up memory for a foreground app, the system can kill the background app. When the system kills an app, there is no guarantee that is called in the app.\n\nTo learn more about how the system decides which processes to destroy, read Activity state and ejection from memory and Processes and app lifecycle.\n\nTo learn how to save your activity UI state when the system kills your app process, see Saving and restoring transient UI state."
    },
    {
        "link": "https://google-developer-training.github.io/android-developer-fundamentals-course-concepts/en/Unit%201/22_c_the_activity_lifecycle_and_managing_state.html",
        "document": "In this chapter you'll learn about the activity lifecycle, the callback events you can implement to perform tasks in each stage of the lifecycle, and how to handle activity instance states throughout the activity lifecycle.\n\nThe activity lifecycle is the set of states an activity can be in during its entire lifetime, from the time it is initially created to when it is destroyed and the system reclaims that activity's resources. As the user interacts with your app and other apps on the device, the different activities move into different states.\n\nFor example, when you start an app, the app's main activity (Activity 1) is started, comes to the foreground, and receives the user focus. When you start a second activity (Activity 2), that new activity is also created and started, and the main activity is stopped. When you're done with the second activity and navigate back, the first activity resumes. The second activity stops and is no longer needed; if the user does not resume the second activity, it is eventually destroyed by the system.\n\nWhen an activity transitions into and out of the different lifecycle states as it runs, the Android system calls several lifecycle callback methods at each stage. All of the callback methods are hooks that you can override in each of your Activity classes to define how that activity behaves when the user leaves and re-enters the activity. Keep in mind that the lifecycle states (and callbacks) are per activity, not per app, and you may implement different behavior at different points in the lifecycle for different activities in your app.\n\nThis figure shows each of the activity states and the callback methods that occur as the activity transitions between different states:\n\nDepending on the complexity of your activity, you probably don't need to implement all the lifecycle callback methods in your activities. However, it's important that you understand each one and implement those that ensure your app behaves the way users expect. Managing the lifecycle of your activities by implementing callback methods is crucial to developing a strong and flexible application.\n\nYour activity enters into the created state when it is started for the first time. When an activity is first created the system calls the onCreate() method to initialize that activity. For example, when the user taps your app icon from the Home screen to start that app, the system calls the onCreate() method for the activity in your app that you've declared to be the \"launcher\" or \"main\" activity. In this case the main activity's onCreate() method is analogous to the main() method in other programs.\n\nSimilarly, if your app starts another activity with an intent (either explicit or implicit), the system matches your intent request with an activity and calls onCreate() for that new activity.\n\nThe onCreate() method is the only required callback you must implement in your activity class. In your onCreate() method you perform basic application startup logic that should happen only once, such as setting up the user interface, assigning class-scope variables, or setting up background tasks.\n\nCreated is a transient state; the activity remains in the created state only as long as it takes to run onCreate(), and then the activity moves to the started state.\n\nAfter your activity is initialized with onCreate(), the system calls the onStart() method, and the activity is in the started state. The onStart() method is also called if a stopped activity returns to the foreground, such as when the user clicks the back or up buttons to navigate to the previous screen. While onCreate() is called only once when the activity is created, the onStart() method may be called many times during the lifecycle of the activity as the user navigates around your app.\n\nWhen an activity is in the started state and visible on the screen, the user cannot interact with it until onResume() is called, the activity is running, and the activity is in the foreground.\n\nTypically you implement onStart() in your activity as a counterpart to the onStop() method. For example, if you release hardware resources (such as GPS or sensors) when the activity is stopped, you can re-register those resources in the onStart() method.\n\nStarted, like created, is a transient state. After starting the activity moves into the resumed (running) state.\n\nYour activity is in the resumed state when it is initialized, visible on screen, and ready to use. The resumed state is often called the running state, because it is in this state that the user is actually interacting with your app.\n\nThe first time the activity is started the system calls the onResume() method just after onStart(). The onResume() method may also be called multiple times, each time the app comes back from the paused state.\n\nAs with the onStart() and onStop() methods, which are implemented in pairs, you typically only implement onResume() as a counterpart to onPause(). For example, if in the onPause() method you halt any onscreen animations, you would start those animations again in onResume().\n\nThe activity remains in the resumed state as long as the activity is in the foreground and the user is interacting with it. From the resumed state the activity can move into the paused state.\n\nThe paused state can occur in several situations:\n• The activity is going into the background, but has not yet been fully stopped. This is the first indication that the user is leaving your activity.\n• The activity is only partially visible on the screen, because a dialog or other transparent activity is overlaid on top of it.\n• In multi-window or split screen mode (API 24), the activity is displayed on the screen, but some other activity has the user focus.\n\nThe system calls the onPause() method when the activity moves into the paused state. Because the onPause() method is the first indication you get that the user may be leaving the activity, you can use onPause() to stop animation or video playback, release any hardware-intensive resources, or commit unsaved activity changes (such as a draft email).\n\nThe onPause() method should execute quickly. Don't use onPause() for for CPU-intensive operations such as writing persistent data to a database. The app may still be visible on screen as it passed through the paused state, and any delays in executing onPause() can slow the user's transition to the next activity. Implement any heavy-load operations when the app is in the stopped state instead.\n\nNote that in multi-window mode (API 24), your paused activity may still fully visible on the screen. In this case you do not want to pause animations or video playback as you would for a partially visible activity. You can use the inMultiWindowMode() method in the Activity class to test whether your app is running in multiwindow mode.\n\nYour activity can move from the paused state into the resumed state (if the user returns to the activity) or to the stopped state (if the user leaves the activity altogether).\n\nAn activity is in the stopped state when it is no longer visible on the screen at all. This is usually because the user has started another activity, or returned to the home screen. The system retains the activity instance in the back stack, and if the user returns to that activity it is restarted again. Stopped activities may be killed altogether by the Android system if resources are low.\n\nThe system calls the onStop() method when the activity stops. Implement the onStop() method to save any persistent data and release any remaining resources you did not already release in onPause(), including those operations that may have been too heavyweight for onPause().\n\nWhen your activity is destroyed it is shut down completely, and the Activity instance is reclaimed by the system. This can happen in several cases:\n• You call finish() in your activity to manually shut it down.\n• The user navigates back to the previous activity.\n• The device is in a low memory situation where the system reclaims stopped activities to free more resources.\n• A device configuration change occurs. You'll learn more about configuration changes later in this chapter.\n\nUse onDestroy() to fully clean up after your activity so that no component (such as a thread) is running after the activity is destroyed.\n\nNote that there are situations where the system will simply kill the activity's hosting process without calling this method (or any others), so you should not rely on onDestroy() to save any required data or activity state. Use onPause() or onStop() instead.\n\nThe restarted state is a transient state that only occurs if a stopped activity is started again. In this case the onRestart() method is called in between onStop() and onStart(). If you have resources that need to be stopped or started you typically implement that behavior in onStop() or onStart() rather than onRestart().\n\nEarlier in the section onDestroy() you learned that your activities may be destroyed when the user navigates back, by you with the finish() method, or by the system when it needs to free resources. The fourth time your activities are destroyed is when the device undergoes a configuration change.\n\nConfiguration changes occur on the device, in runtime, and invalidate the current layout or other resources in your activity The most common form of a configuration change is when the device is rotated. When the device rotates from portrait to landscape, or vice versa, the layout for your app also needs to change. The system recreates the activity to help that activity adapt to the new configuration by loading alternative resources (such as a landscape-specific layout).\n\nOther configuration changes can include a change in locale (the user chooses a different system language), or the user enters multi-window mode (Android 7). In multi-window mode, if you have configured your app to be resizeable, Android recreates your activities to use a layout definition for the new, smaller activity size.\n\nWhen a configuration change occurs Android system shuts down your activity (calling onPause(), onStop(), and onDestroy()), and then starts it over again from the start (calling onCreate(), onStart(), and onResume()).\n\nWhen an activity is destroyed and recreated, there are implications for the runtime state of that activity. When an activity is paused or stopped, the state of the activity is retained because that activity is still held in memory. When an activity is recreated, the state of the activity and any user progress in that activity is lost, with these exceptions:\n• Some activity state information is automatically saved by default. The state of views in your layout with a unique ID (as defined by the android:id attribute in the layout) are saved and restored when an activity is recreated. In this case, the user-entered values in EditText views are usually retained when the activity is recreated.\n• The intent that was used to start the activity, and the information stored in that intent's data or extras, remains available to that activity when it is recreated.\n\nThe activity state is stored as a set of key/value pairs in a Bundle object called the activity instance state. The system saves default state information to instance state bundle just before the activity is stopped, and passes that bundle to the new activity instance to restore.\n\nYou can add your own instance data to the instance state bundle by overriding the onSaveInstanceState() callback. The state bundle is passed to the onCreate() method, so you can restore that instance state data when your activity is created. There is also a corresponding onRestoreInstanceState() callback you can use to restore the state data.\n\nBecause device rotation is a common use case for you app, make sure you test that your activity behaves correctly in response to this configuration change, and implement instance state if you need to.\n\nNote: The activity instance state is particular to a specific instance of an activity, running in a single task. If the user force-quits the app, reboots the device, or if the Android system shuts down the entire app process to preserve memory, the activity instance state is lost. To keep state changes across app instances and device reboots, you need to write that data to shared preferences. You'll learn more about shared preferences in a later chapter.\n\nTo save information to the instance state bundle, use the onSaveInstanceState() callback. This is not a lifecycle callback method, but it is called when the user is leaving your activity (sometime before the onStop() method).\n\nThe onSaveInstanceState() method is passed a Bundle object (a collection of key/value pairs) when it is called. This is the instance state bundle to which you will add your own activity state information.\n\nYou learned about bundles in a previous chapter when you added keys and values to the intent extras. Add information to the instance state bundle in the same way, with keys you define and the various \"put\" methods defined in the Bundle class:\n\nDon't forget to call through to the superclass, to make sure the state of the view hierarchy is also saved to the bundle.\n\nOnce you've saved the activity instance state, you also need to restore it when the activity is recreated. You can do this one of two places:\n• The onCreate() callback method, which is called with the instance state bundle when the activity is created.\n• The onRestoreInstanceState() callback, which is called after onStart() after the activity is created.\n\nMost of the time the better place to restore the activity state is in onCreate(), to ensure that your user interface including the state is available as soon as possible.\n\nTo restore the saved instances state in onCreate(), test for the existence of a state bundle before you try to get data out of it. When your activity is started for the first time there will be no state and the bundle will be null.\n\nThe related exercises and practical documentation is in Android Developer Fundamentals: Practicals."
    },
    {
        "link": "https://developer.android.com/codelabs/basic-android-kotlin-compose-activity-lifecycle",
        "document": "In this codelab, you learn about a fundamental part of Android: the activity lifecycle. During its lifetime, an activity transitions through, and sometimes back to, various states. This transitioning of states is known as the activity lifecycle. In Android, an activity is the entry point for interacting with the user. In the past, one activity would display one screen in an app. With current best practices, one activity might display multiple screens by swapping them in and out as needed. The activity lifecycle extends from the creation of the activity to its destruction, when the system reclaims that activity's resources. As a user navigates in and out of an activity, each activity transitions between different states in the activity lifecycle. As an Android developer, you need to understand the activity lifecycle. If your activities do not correctly respond to lifecycle state changes, your app can generate strange bugs, confusing behavior for your users, or use too many Android system resources. Understanding the Android lifecycle and responding correctly to lifecycle state changes is an important part of Android development.\n• Knowledge of what an activity is and how to create one in your app\n• Knowledge of what an activity's method does and the kind of operations that are performed in that method\n• How to print logging information to the Logcat\n• The basics of the lifecycle and the callbacks that are invoked when the activity moves between states\n• How to override lifecycle callback methods to perform operations at different times in the activity lifecycle\n• Modify a starter app, called Dessert Clicker, to add logging information that's displayed in the Logcat.\n• Override lifecycle callback methods and log changes to the activity state.\n• Run the app and note the logging information that appears as the activity starts, stops, and resumes.\n• Implement to retain app data that may be lost if the device configuration changes.\n\nEvery activity has what is known as a lifecycle. This term is an allusion to plant and animal lifecycles, like the lifecycle of a butterfly—the different states of the butterfly show its growth from egg to caterpillar to pupa to butterfly to death. Similarly, the activity lifecycle consists of the different states that an activity can go through, from when the activity first initializes to its destruction, at which time the operating system (OS) reclaims its memory. Typically, the entry point of a program is the method. Android activities, however, begin with the method; this method would be the equivalent of the egg stage in the above example. You have used activities already, many times throughout this course, and you might recognize the method. As the user starts your app, navigates between activities, navigates inside and outside of your app, the activity changes state. The following diagram shows all the activity lifecycle states. As their names indicate, these states represent the status of the activity. Notice that, unlike the butterfly lifecycle, an activity can go back and forth between states throughout the lifecycle, instead of only moving in a single direction. Note: An Android app can have multiple activities. However, it is recommended to have a single activity, and so far that is what you have been implementing in this course. Often, you want to change some behavior, or run some code, when the activity lifecycle state changes. Therefore, the class itself, and any subclasses of such as , implement a set of lifecycle callback methods. Android invokes these callbacks when the activity moves from one state to another, and you can override those methods in your own activities to perform tasks in response to those lifecycle state changes. The following diagram shows the lifecycle states along with the available overridable callbacks. Note: The asterisk on the method indicates that this method is not called every time the state transitions between Created and Started. It is only called if was called and the activity is subsequently restarted. It's important to know when Android invokes the overridable callbacks and what to do in each callback method, but both of these diagrams are complex and can be confusing. In this codelab, instead of just reading what each state and callback means, you're going to do some detective work and build your understanding of the Android activity lifecycle. To figure out what's going on with the Android lifecycle, it's helpful to know when the various lifecycle methods are called. This information helps you identify where things are going wrong in the Dessert Clicker app. A simple way to determine this information is to use the Android logging functionality. Logging enables you to write short messages to a console while the app runs and use it to see when different callbacks are triggered.\n• Run the Dessert Clicker app and tap several times on the picture of the dessert. Note how the value for Desserts sold and the total dollar amount changes.\n• Open and examine the method for this activity: In the activity lifecycle diagram, you may recognize the method, because you've used this callback before. It's the one method that every activity must implement. The method is where you should do any one-time initializations for your activity. For example, in , you call , which specifies the activity's UI layout. The lifecycle method is called once, just after the activity initializes—when the OS creates the new object in memory. After executes, the activity is considered created. Note: When you override the method, you must call the superclass implementation to complete the creation of the Activity, so within it, you must immediately call . The same is true for other lifecycle callback methods.\n• Add the following constant at the top level of the , above the class declaration . A good convention is to declare a constant in your file as its value will not change. To mark it as a compile-time constant, use when declaring the variable. A compile-time constant is a value that is known during compilation.\n• In the method, just after the call to , add the following line:\n• Import the class, if necessary (press , or on a Mac, and select Import.) If you enabled auto imports, this should happen automatically. The class writes messages to the Logcat. The Logcat is the console for logging messages. Messages from Android about your app appear here, including the messages you explicitly send to the log with the method or other class methods. There are three important aspects of the instruction:\n• The priority of the log message, that is, how important the message is. In this case, the logs verbose messages. method writes a debug message. Other methods in the class include for informational messages, for warnings, and for error messages.\n• The log (the first parameter), in this case . The tag is a string that lets you more easily find your log messages in the Logcat. The tag is typically the name of the class.\n• The actual log message, called (the second parameter), is a short string, which in this case is .\n• Compile and run the Dessert Clicker app. You don't see any behavior differences in the app when you tap the dessert. In Android Studio, at the bottom of the screen, click the Logcat tab.\n• In the Logcat window, type into the search field. The Logcat can contain many messages, most of which aren't useful to you. You can filter the Logcat entries in many ways, but searching is the easiest. Because you used as the log tag in your code, you can use that tag to filter the log. Your log message includes the date and time, your log tag, the name of the package ( ), and the actual message. Because this message appears in the log, you know that was executed. The lifecycle method is called just after . After runs, your activity is visible on the screen. Unlike , which is called only once to initialize your activity, can be called by the system many times in the lifecycle of your activity. Note that is paired with a corresponding lifecycle method. If the user starts your app and then returns to the device's home screen, the activity is stopped and is no longer visible on screen.\n• In Android Studio, with open and the cursor within the class, select Code > Override Methods... or press . A dialog appears with a long list of all the methods you can override in this class.\n• Start entering to search for the correct method. To scroll to the next matching item, use the down arrow. Choose from the list and click OK to insert the boilerplate override code. The code looks like the following example:\n• Compile and run the Dessert Clicker app and open the Logcat pane.\n• Type into the search field to filter the log. Notice that both the and methods were called one after the other, and that your activity is visible on screen.\n• Press the Home button on the device and then use the Recents screen to return to the activity. Notice that the activity resumes where it left off, with all the same values, and that is logged a second time to Logcat. Notice also that the method is not called again. Note: As you experiment with your device and observe the lifecycle callbacks, you might notice unusual behavior when you rotate your device. You'll learn about that behavior later in this codelab. In this step, you implement logging for all the other lifecycle methods.\n• Override the remainder of the lifecycle methods in your and add log statements for each one, as shown in the following code:\n• Compile and run Dessert Clicker again and examine Logcat. Notice that this time, in addition to and , there's a log message for the lifecycle callback. When an activity starts from the beginning, you see all three of these lifecycle callbacks called in order:\n• when the system creates the app.\n• makes the app visible on the screen, but the user is not yet able to interact with it.\n• brings the app to the foreground, and the user is now able to interact with it. Despite the name, the method is called at startup, even if there is nothing to resume.\n\nNow that you have set up the Dessert Clicker app for logging, you're ready to start using the app and exploring how lifecycle callbacks are triggered. Use case 1: Opening and closing the activity You start with the most basic use case, which is to start your app for the first time and then close the app.\n• Compile and run the Dessert Clicker app, if it is not already running. As you've seen, the , , and callbacks are called when the activity starts for the first time.\n• Tap the Back button on the device. Notice in Logcat that and are called in that order. In this case, using the Back button causes the activity (and the app) to be removed from the screen and moved to the back of the activity stack. The Android OS might close your activity if your code manually calls the activity's method or if the user force-quits the app. For example, the user can force-quit or close the app in the Recents screen. The OS might also shut down your activity on its own if your app has not been onscreen for a long time. Android does so to preserve battery life and to reclaim the resources the app was using so they are available to other apps. These are just a few examples of why the Android system destroys your activity. There are additional cases when the Android system destroys your activity without providing a warning. Note: and , which this codelab teaches later, are only called once during the lifetime of a single activity instance: to initialize the app for the very first time, and to nullify, close, or destroy objects that the activity may have been using so that they don't continue to use resources, like memory. Use case 2: Navigating away from and back to the activity Now that you've started the app and closed it, you've seen most of the lifecycle states for when the activity gets created for the first time. You've also seen most of the lifecycle states that the activity goes through when it gets closed. But as users interact with their Android devices, they switch between apps, return home, start new apps, and handle interruptions by other activities such as phone calls. Your activity does not close down entirely every time the user navigates away from that activity:\n• When your activity is no longer visible on screen, the status is known as putting the activity into the background. The opposite of this is when the activity is in the foreground, or onscreen.\n• When the user returns to your app, that same activity is restarted and becomes visible again. This part of the lifecycle is called the app's visible lifecycle. When your app is in the background, it generally should not be actively running to preserve system resources and battery life. You use the lifecycle and its callbacks to know when your app is moving to the background so that you can pause any ongoing operations. You then restart the operations when your app comes into the foreground. In this step, you look at the activity lifecycle when the app goes into the background and returns again to the foreground.\n• With the Dessert Clicker app running, click the cupcake a few times.\n• Press the Home button on your device and observe the Logcat in Android Studio. Returning to the home screen puts your app into the background, rather than shutting down the app altogether. Notice that the and methods are called. When is called, the app no longer has focus. After , the app is no longer visible on screen. Although the activity is stopped, the object is still in memory in the background. The Android OS has not destroyed the activity. The user might return to the app, so Android keeps your activity resources around.\n• Use the Recents screen to return to the app. On the emulator, the Recents screen can be accessed by the square system button shown in the image below. Notice in Logcat that the activity restarts with and and then resumes with . Note: is only called by the system if the activity has already been created and eventually enters the Created state when is called, but returns back to the Started state instead of entering the Destroyed state. The method is a place to put code that you only want to call if your activity is not being started for the first time. When the activity returns to the foreground, the method is not called again. The activity object was not destroyed, so it doesn't need to be created again. Instead of , the method is called. Notice that this time when the activity returns to the foreground, the Desserts sold number is retained.\n• Start at least one app other than Dessert Clicker so that the device has a few apps in its Recents screen.\n• Bring up the Recents screen and open another recent activity. Then go back to recent apps and bring Dessert Clicker back to the foreground. Notice that you see the same callbacks in Logcat here as when you pressed the Home button. and are called when the app goes into the background, and then , , and are called when it comes back. Note: and are called multiple times as the user navigates to and from the activity. These methods are called when the app stops and moves into the background or when the app restarts and returns to the foreground. If you need to do some work in your app during these cases, then override the relevant lifecycle callback method. You've learned that when an app is started and is called, the app becomes visible on the screen. When is called, the app gains the user focus–that is, the user can interact with the app. The part of the lifecycle in which the app is fully onscreen and has user focus is called the foreground lifetime. When the app goes into the background, the focus is lost after , and the app is no longer visible after . The difference between focus and visibility is important. An activity can be partially visible on the screen but not have the user focus. In this step, you look at one case in which an activity is partially visible but doesn't have user focus.\n• With the Dessert Clicker app running, click the Share button in the top right of the screen. The sharing activity appears in the lower half of the screen, but the activity is still visible in the top half.\n• Examine Logcat and note that only was called. In this use case, is not called because the activity is still partially visible. But the activity does not have user focus, and the user can't interact with it—the \"share\" activity that's in the foreground has the user focus. Why is this difference important? The interruption with only usually lasts a short time before returning to your activity or navigating to another activity or app. You generally want to keep updating the UI so the rest of your app doesn't appear to freeze. Whatever code runs in blocks other things from displaying, so keep the code in lightweight. For example, if a phone call comes in, the code in may delay the incoming-call notification.\n• Click outside the share dialog to return to the app, and notice that is called. Both and have to do with focus. The method is called when the activity gains focus, and is called when the activity loses focus.\n\nThere's another case in managing the activity lifecycle that is important to understand: how configuration changes affect the lifecycle of your activities. A configuration change occurs when the state of the device changes so radically that the easiest way for the system to resolve the change is to completely shut down and rebuild the activity. For example, if the user changes the device language, the whole layout might need to change to accommodate different text directions and string lengths. If the user plugs the device into a dock or adds a physical keyboard, the app layout may need to take advantage of a different display size or layout. And if the device orientation changes—if the device is rotated from portrait to landscape or back the other way—the layout might need to change to fit the new orientation. Let's look at how the app behaves in this scenario. The last lifecycle callback to demonstrate is , which is called after . It is called just before the activity is destroyed. This can happen when the app's code calls , or the system needs to destroy and recreate the activity because of a configuration change. Configuration change causes to be called Screen rotation is one type of a configuration change that causes the activity to shutdown and restart. To simulate this configuration change and examine its effects, complete the following steps:\n• Ensure the screen rotation lock in the emulator is disabled.\n• Rotate the device or emulator to landscape mode. You can rotate the emulator left or right with the rotation buttons.\n• Examine Logcat and understand that as the activity shuts down, it calls , , and , in that order.\n• Compile and run your app and open Logcat.\n• Click the cupcake a few times and note that the desserts sold and total revenue are not zero.\n• Ensure the screen rotation lock in the emulator is disabled.\n• Rotate the device or emulator to landscape mode. You can rotate the emulator left or right with the rotation buttons.\n• Examine the output in Logcat. Filter the output on . Notice that when the device or emulator rotates the screen, the system calls all the lifecycle callbacks to shut down the activity. Then, as the activity is re-created, the system calls all the lifecycle callbacks to start the activity. When the device is rotated, and the activity is shut down and re-created, the activity re-starts with default values—the dessert image, number of desserts sold, and total revenue reset back to zero. To learn why these values are being reset and how to correct them, you need to learn about the lifecycle of a composable and how it knows to observe and retain its state. The UI of your app is initially built from running composable functions in a process called Composition. When the state of your app changes, a recomposition is scheduled. Recomposition is when Compose re-executes the composable functions whose state might have changed and creates an updated UI. The Composition is updated to reflect these changes. The only way to create or update a Composition is by its initial composition and subsequent recompositions. Composable functions have their own lifecycle that is independent of the Activity lifecycle. Its lifecycle is composed of the events: enters the Composition, recomposing 0 or more times, and then leaving the Composition. In order for Compose to track and trigger a recomposition, it needs to know when state has changed. To indicate to Compose that it should track an object's state, the object needs to be of type or . The type is immutable and can only be read. A type is mutable and allows reads and writes. You have already seen and used in the Lemonade app and the Tip Time app in prior codelabs. To create the mutable variable , you declare it using . is its initial default value. While this is enough to have Compose trigger a recomposition when the revenue value changes, it is not enough to retain its updated value. Each time the composable is reexecuted, it will reinitialize the revenue value to its initial default value of . To instruct Compose to retain and reuse its value during recompositions, you need to declare it with the API. If the value of changes, Compose schedules all composable functions that read this value for recomposition. While Compose remembers the revenue state during recompositions, it does not retain this state during a configuration change. For Compose to retain the state during a configuration change, you must use . For additional practice and information, please refer to Intro to state in Compose codelab. Use to save values across configuration changes You use the function to save values that you need if Android OS destroys and recreates the activity. To save values during recompositions, you need to use . Use to save values during recompositions AND configuration changes. Note: Sometimes Android shuts down an entire app process, which includes every activity associated with the app. Android does this kind of shutdown when the system is stressed and in danger of visually lagging, so no additional callbacks or code is run at this point. Your app's process is simply shut down silently in the background. But to the user, it doesn't look like the app is closed. When the user navigates back to an app that the Android system shuts down, Android restarts that app. You want to ensure that the user doesn't experience any data loss when this happens. Saving the value using ensures that it is available when the activity is restored, if it is needed.\n• In , update the group of five variables that currently use to .\n• Click the cupcake a few times and note that the desserts sold and total revenue are not zero.\n• Rotate the device or emulator to landscape mode.\n• Observe that after the activity is destroyed and recreated, the dessert image, desserts sold, and total revenue are restored to their previous values."
    },
    {
        "link": "https://medium.com/@himanshu_hc/understanding-the-android-activity-lifecycle-584602f18284",
        "document": "If you have ever developed an Android app or are interested in mobile app development, you might have come across the term “Activity Lifecycle.” The Activity Lifecycle is a crucial concept in Android development, as it governs the state transitions and behaviors of an Android activity throughout its existence. Understanding this lifecycle is fundamental to creating robust and responsive Android applications. In this blog, we will explore the Android Activity Lifecycle, step by step, and illustrate it with images to make it easier to grasp.\n\nWhat is an Activity?\n\nBefore diving into the lifecycle, let’s first understand what an Activity is in Android. An Activity represents a single screen with a user interface (UI). It serves as the building block for most Android apps and provides the window in which the app’s content is displayed.\n• : This method is called when the activity is first created. It is where you set up the initial UI, bind data, and initialize variables.\n• : The method is called when the activity is becoming visible to the user but is not yet in the foreground. At this point, the activity is visible but not interactive.\n• : When the activity is brought to the foreground and becomes interactive, the method is called. This is a crucial state where the app is ready to interact with the user.\n• : This method is called when the activity loses focus but remains visible on the screen. It is an opportunity to save data that should be retained, release resources, or perform other cleanup actions.\n• : When the activity is no longer visible to the user, the method is called. Here, you can release resources that are no longer needed.\n• : The method is called when the activity is about to be destroyed. This can happen either because the system is low on resources or because the user finished the activity. It is your last chance to perform cleanup before the activity is removed from memory.\n\nAn important aspect of the Activity Lifecycle is handling configuration changes, such as screen rotations. When a configuration change occurs, the activity is destroyed and recreated by default. To manage this effectively, you can use the method to save important data before the activity is destroyed and restore it using the or method after recreation.\n\nUnderstanding the Android Activity Lifecycle is vital for developing efficient and responsive Android applications. By knowing when each method is called and how to handle state changes, you can create smoother user experiences and properly manage resources. Always remember to release resources when they are no longer needed to optimize your app’s performance.\n\nI hope this blog helped you gain a better understanding of the Android Activity Lifecycle. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/2091465/how-do-i-pass-data-between-activities-in-android-application",
        "document": "On clicking sign-out , I will be passing the session id of the signed in user to sign-out. Can anyone guide me on how to keep session id available to all activities ?\n\nI have a scenario where, after logging in through a login page, there will be a sign-out button on each activity .\n\nYou just have to send extras while calling your intent. Intent intent = new Intent(getApplicationContext(), SecondActivity.class); intent.putExtra(\"Variable name\", \"Value you want to pass\"); startActivity(intent); Now on the method of your you can fetch the extras like this. If the value you sent was in : long value = getIntent().getLongExtra(\"Variable name which you sent as an extra\", defaultValue(you can give it anything)); If the value you sent was a : String value = getIntent().getStringExtra(\"Variable name which you sent as an extra\"); If the value you sent was a : Boolean value = getIntent().getBooleanExtra(\"Variable name which you sent as an extra\", defaultValue);\n\nUpdated Note that I had mentioned the use of SharedPreference. It has a simple API and is accessible across an application's activities. But this is a clumsy solution and is a security risk if you pass around sensitive data. It's best to use intents. It has an extensive list of overloaded methods that can be used to better transfer many different data types between activities. Have a look at intent.putExtra. This link presents the use of putExtra quite well. In passing data between activities, my preferred approach is to create a static method for the relevant activity that includes the required parameters to launch the intent. Which then provides easy setup and retrieval parameters. So it can look like this public class MyActivity extends Activity { public static final String ARG_PARAM1 = \"arg_param1\"; ... public static getIntent(Activity from, String param1, Long param2...) { Intent intent = new Intent(from, MyActivity.class); intent.putExtra(ARG_PARAM1, param1); intent.putExtra(ARG_PARAM2, param2); return intent; } .... // Use it like this. startActivity(MyActvitiy.getIntent(FromActivity.this, varA, varB, ...)); ... Then you can create an intent for the intended activity and ensure you have all the parameters. You can adapt for fragments too. A simple example above, but you get the idea.\n\nThe actual process of passing data has already been answered, however most of the answers use hard coded strings for the key name in the Intent. This is usually fine when used only within your app. However, the documentation recommends using the constants for standardized data types. Example 2: Defining your own key If one of the Strings does not suit your needs, you can define your own at the beginning of the first activity. Including the package name is just a convention if you are only using the key in your own app. But it is a necessity to avoid naming conflicts if you are creating some sort of service that other apps can call with an Intent. Although not mentioned in the documentation, this answer recommends using a String resource to avoid dependencies between activities.\n\nHere is my best practice and it helps a lot when the project is huge and complex. Suppose that I have 2 activities, and . I want to pass 2 parameters (username & password) from to . public class HomeIntent extends Intent { private static final String ACTION_LOGIN = \"action_login\"; private static final String ACTION_LOGOUT = \"action_logout\"; private static final String ARG_USERNAME = \"arg_username\"; private static final String ARG_PASSWORD = \"arg_password\"; public HomeIntent(Context ctx, boolean isLogIn) { this(ctx); //set action type setAction(isLogIn ? ACTION_LOGIN : ACTION_LOGOUT); } public HomeIntent(Context ctx) { super(ctx, HomeActivity.class); } //This will be needed for receiving data public HomeIntent(Intent intent) { super(intent); } public void setData(String userName, String password) { putExtra(ARG_USERNAME, userName); putExtra(ARG_PASSWORD, password); } public String getUsername() { return getStringExtra(ARG_USERNAME); } public String getPassword() { return getStringExtra(ARG_PASSWORD); } //To separate the params is for which action, we should create action public boolean isActionLogIn() { return getAction().equals(ACTION_LOGIN); } public boolean isActionLogOut() { return getAction().equals(ACTION_LOGOUT); } } Here is how I pass the data in my LoginActivity Final step, here is how I receive the data in public class HomeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); //This is how we receive the data from LoginActivity //Make sure you pass getIntent() to the HomeIntent constructor final HomeIntent homeIntent = new HomeIntent(getIntent()); Log.d(\"HomeActivity\", \"Is action login? \" + homeIntent.isActionLogIn()); Log.d(\"HomeActivity\", \"username: \" + homeIntent.getUsername()); Log.d(\"HomeActivity\", \"password: \" + homeIntent.getPassword()); } } Done! Cool :) I just want to share my experience. If you working on small project this shouldn't be the big problem. But when your working on big project, it really pain when you want to do refactoring or fixing bugs.\n\n1st way: In your current Activity, when you create an object of intent to open a new screen: Then in the nextActivity in the onCreate method, retrieve those values which you pass from the previous activity: if (getIntent().getExtras() != null) { String value = getIntent().getStringExtra(\"key\"); //The key argument must always match that used send and retrieve value from one activity to another. } 2nd way: You can create a bundle object and put values in a bundle and then put the bundle object in intent from your current activity - String value=\"xyz\"; Intent intent = new Intent(CurrentActivity.this, NextActivity.class); Bundle bundle = new Bundle(); bundle.putInt(\"key\", value); intent.putExtra(\"bundle_key\", bundle); startActivity(intent); Then in the nextActivity in the onCreate method, retrieve those values which you pass from the previous activity: if (getIntent().getExtras() != null) { Bundle bundle = getIntent().getStringExtra(\"bundle_key\"); String value = bundle.getString(\"key\"); //The key argument must always match that used send and retrieve value from one activity to another. } You can also use the bean class to pass data between classes using serialization.\n\nI recently released Vapor API, a jQuery flavored Android framework that makes all sorts of tasks like this simpler. As mentioned, is one way you could do this. is implemented as Singleton so that is one option, and in Vapor API it has a heavily overloaded method so you don't have to explicitly worry about the datatype you are committing - providing it is supported. It is also fluent, so you can chain calls: It also optionally autosaves changes, and unifies the reading and writing process under-the-hood so you don't need to explicitly retrieve an Editor like you do in standard Android. Alternatively you could use an . In Vapor API you can also use the chainable overloaded method on a : And pass it as an extra, as mentioned in the other answers. You can retrieve extras from your , and furthermore if you are using this is done for you automatically so you can use: To retrieve them at the other end in the you switch to. Hope that is of interest to some :)"
    },
    {
        "link": "https://stackoverflow.com/questions/15445182/passing-data-from-one-activity-to-another-using-bundle-not-displaying-in-secon",
        "document": "I'm currently trying to take data acquired through a REST API call, parse it for the information I need, and then pass that information to a new activity. I'm using the Asynchronous HTTP Client from loopj.com for the REST client, and then using the below code for my and for the current and future activities, respectively.\n\nEclipse does not pass me any errors for any of my code, but when I try to run in the emulator, I get nothing (i.e. blank white screen) when the new activity/view opens. I've tried to code with a different URL in my REST CLIENT, but I still see nothing. I even took the API call out of the equation by commenting out the try/catch in and changing in the to . Still, the new view comes up but nothing is displayed. What is not being passed, or what am I forgetting to make the second activity show the ?\n\nMethod in second activity that should receive the intent and bundle and display it:\n\nThanks for your help. Very much appreciated."
    },
    {
        "link": "https://geeksforgeeks.org/bundle-in-android-with-example",
        "document": "It is known that Intents are used in Android to pass to the data from one activity to another. But there is one another way, that can be used to pass the data from one activity to another in a better way and less code space ie by using Bundles in Android. Android Bundles are generally used for passing data from one activity to another. Basically here concept of key-value pair is used where the data that one wants to pass is the value of the map, which can be later retrieved by using the key. Bundles are used with intent and values are sent and retrieved in the same fashion, as it is done in the case of Intent. It depends on the user what type of values the user wants to pass, but bundles can hold all types of values (int, String, boolean, char) and pass them to the new activity.\n\nThe following are the major types that are passed/retrieved to/from a Bundle:\n\nUsing the Bundle in the Android App\n\nThe bundle is always used with Intent in Android. Now to use Bundle writes the below code in the MainActivity.\n\nNow create another empty activity named SecondActivity. Now to retrieve the data stored in the Bundle, write the following code in SecondActivity.\n\nAlternatively, if one does not want to use the default value too, one can do this but remember it gives an exception.\n\nIf there exists no mapping corresponding to the key, it may lead to NullPointerException. Hence it’s recommended to add default values for the Bundle.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK as per your need.\n\nNow add two Buttons into the app, one button will pass the data which is stored into the bundle, and another button will pass the empty bundle, ie clearing the bundle with bundle.clear() and then passing the Bundle to Intent. The complete code for the activity_main.xml file is given below. Here one can see that the first button is used to pass the non-empty bundle, while the second button is used to pass the empty bundle.\n\nStep 3: Create another activity and named it as SecondActivity\n\nNow create another empty activity names SecondActivity. Follow the procedure illustrated in the image given below to create another activity.\n\nIn this file add a TextView to display the text in the SecondActivity.\n\nThe complete code for the MainActivity is given below. Comments are added to understand the code easily.\n\nThe complete code for the SecondActivity is given below. Comments are added to understand the code easily."
    },
    {
        "link": "https://developer.android.com/guide/components/activities/parcelables-and-bundles",
        "document": "and objects are intended to be used across process boundaries such as with IPC/Binder transactions, between activities with intents, and to store transient state across configuration changes. This page provides recommendations and best practices for using and objects.\n\nNote: is not a general-purpose serialization mechanism, and you should never store any data on disk or send it over the network.\n\nWhen an app creates an object to use in in starting a new Activity, the app can pass in parameters using the method.\n\nThe following code snippet shows an example of how to perform this operation.\n\nThe OS parcels the underlying of the intent. Then, the OS creates the new activity, un-parcels the data, and passes the intent to the new activity.\n\nWe recommend that you use the class to set primitives known to the OS on objects. The class is highly optimized for marshalling and unmarshalling using parcels.\n\nIn some cases, you may need a mechanism to send composite or complex objects across activities. In such cases, the custom class should implement Parcelable, and provide the appropriate method. It must also provide a non-null field called that implements the interface, whose method is used for converting the back to the current object. For more information, see the reference documentation for the object.\n\nWhen sending data via an intent, you should be careful to limit the data size to a few KB. Sending too much data can cause the system to throw a exception.\n\nSending data between processes is similar to doing so between activities. However, when sending between processes, we recommend that you do not use custom parcelables. If you send a custom object from one app to another, you need to be certain that the exact same version of the custom class is present on both the sending and receiving apps. Typically this could be a common library used across both apps. An error can occur if your app tries to send a custom parcelable to the system, because the system cannot unmarshal a class that it has no knowledge of.\n\nFor example, an app might set an alarm using the class, and use a custom on the alarm intent. When the alarm goes off, the system modifies the intent's of extras to add a repeat count. This modification can result in the system's stripping the custom from the extras. This stripping, in turn, can result in the app's crashing when it receives the modified alarm intent, because the app expects to receive extra data that is no longer there.\n\nThe Binder transaction buffer has a limited fixed size, currently 1MB, which is shared by all transactions in progress for the process. Since this limit is at the process level rather than at the per activity level, these transactions include all binder transactions in the app such as onSaveInstanceState, startActivity and any interaction with the system. When the size limit is exceeded, a TransactionTooLargeException is thrown.\n\nFor the specific case of savedInstanceState, the amount of data should be kept small because the system process needs to hold on to the provided data for as long as the user can ever navigate back to that activity (even if the activity's process is killed). We recommend that you keep saved state to less than 50k of data.\n\nNote: In Android 7.0 (API level 24) and higher, the system throws a TransactionTooLargeException as a runtime exception. In lower versions of Android, the system only shows a warning in logcat."
    },
    {
        "link": "https://medium.com/@AryanBeast/pass-send-data-custom-models-from-one-activity-to-another-activity-84ffccb25803",
        "document": "If you are a android developer or just a casual guy developing some android apps. I am sure you had come in a situation where you have to share some data from one activity to another. (Hope you know what is activity :-) ).\n\nI will be writing code in java, if you want code or example in kotlin use some online converter and paste the java code and you will get kotlin code. Otherwise comment or mail me I will write another article for kotlin also.\n\nThere are many different ways to pass the data from one activity to another activity.\n\nShared Preferences and database are valid when we need to pass data and at the same time make this information persistent. This is the case of configuration parameter for example where we have to persist this information to not ask again it. We will cover this topic in another post, by now we are more interested on sharing data between activities without making them persistent. So we are in static classes and Intents.\n\nThis is the easiest way to achieve our goal. Exploiting the Android feature that an app runs in a single process we can use a static class to exchange data between activities. In this case we can create several static method to hold the data we want to share.\n\nOtherwise, we can use the singleton pattern that ensures we have only one instance of this class in all our JVM. In this case we create several method to hold the data.\n\nThis is the reason you are here, this is most versatile and used way. I can even say one of the most powerful when we don’t have to save the data and just send it.\n\nThere are 3 way we can send data using intents.\n\n> Bundle :- create a bundle and set the data here\n\n> Parcelable :- It is a way of “serializing” our object.\n\nTo see how to use them let take a example we have two activities with name firstActivity and secondActivity.\n\nIntent has several method called putExtra(String name, …..) that allows us to save inside the Intent our information. Reading the API Doc we know that we can add string, longs, CharSequence, int and so on. It behaves like a Map where there’s the key and the value. In the caller (firstActivity) we can pass data in this way:\n\nHere, each key should be different, it will send in map like structure to access any value we have to remember it’s key.\n\nTo check what can you send from this :- Click Here\n\nExamples :- String, any data-type(byte, int, float, double etc. ) value, ArrayList of any data-type, bundles (which I explain later.)\n\nMake sure to you are using correct key and variable data-type of receiving data is correct otherwise it will throw an expectation.\n\nAndroid has a class called Bundle, where we can store our data and supports several data types like strings, chars, boolean, integer and so on.\n\nInstead of using the Intent, as data container, we store our info directly into the bundle and then we save the bundle into the Intent. This approach is similar to the one described above.\n\nfirstActivity :-\n\nIt also support different data-type and arrayLists.\n\nThis is the most powerful and important for us. As above method can only send primitive data type using this we can send custom model from one activity to another.\n\nThe “parcelable” operation is like serialization in Java, but while the java serialization in android is inefficient the “parcelable” operation is much more faster.\n\nThis interface has two method that we have to implements: describeContent() that returns an int and writeToParcel(Parcel dest, int flags) that returns a void. More over a class that implements this interface must have a static field called CREATOR that is used by the OS to recreate the object.\n\nTo show how this work we will see a example where we have a model class of student which store some data.\n\nIf we want to pass model object from one activity to another, we have to make this model class parcelable.\n\nand then press alt + enter ( Most most important feature of android studio :-) ), to implements: describeContent() that returns an int and writeToParcel(Parcel dest, int flags) :-\n\nthen again do same thing.. alt + enter to implement static field called CREATOR :-\n\nNow you code will be something like this : -\n\nAll extra code will be written by android studio ( nice..! 👌👌)\n\nLet’s analyze the code shown above. The first thing we did is to declare that our class implements Parcelable, so we have to override two method as stated above. The first one is describeContents() where we simply return the hashcode of our class. The second is writeToParcel. In this method we write the attribute values into the Parcel class. We use the Parcel methods to store our information. The order used to write them isn’t important, but we have to use the same order when we have to read it.\n\nOnce we have declared that our class is Parcelable, we have to implement a static field called CREATOR. This field is used by OS to “unparcel” or “deserialize” our class. There are two other methods to override the most important one is createFromParcel where we receive a parcel and we have to build up our Object, in our case Person.\n\nIf you want to know about Parcelable and serialization more Click Here.\n\nTo give you brief explanation about this, we change the model variable to string/byte format so that we can use intent/bundle to store it and send it to other.\n\nAs you notice we simply put our object Student into the Intent.\n\nIf you are not able to understand or implement this concept. Please let me know I will make a simple project using this to show how to use this.\n\nTo use this feature in kotlin :-\n\nThanks for being a part of our community! Before you go:\n• 👏 Clap for the story and follow the author 👉"
    },
    {
        "link": "https://developer.android.com/training/data-storage/shared-preferences",
        "document": "If you have a relatively small collection of key-values that you'd like to save, you can use the APIs. A object points to a file containing key-value pairs and provides simple methods to read and write them. Each file is managed by the framework and can be private or shared.\n\nThis page shows you how to use the APIs to store and retrieve simple values.\n\nCaution: is a modern data storage solution that you should use instead of . It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of . is a modern data storage solution that you should use instead of. It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of Read the DataStore guide for more information.\n\nYou can create a new shared preference file or access an existing one by calling one of these methods:\n• : Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any in your app.\n• : Use this from an if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.\n\nFor example, the following code accesses the shared preferences file that's identified by the resource string and opens it using the private mode so the file is accessible by only your app:\n\nWhen naming your shared preference files, you should use a name that's uniquely identifiable to your app. A good way to do this is prefix the file name with your application ID. For example:\n\nAlternatively, if you need just one shared preference file for your activity, you can use the method:\n\nIf you're using the API to save app settings, you should instead use to get the default shared preference file for your entire app. For more information, see the Settings developer guide.\n\nTo write to a shared preferences file, create a by calling on your .\n\nPass the keys and values you want to write with methods such as: and . Then call or to save the changes. For example:\n\nchanges the in-memory object immediately but writes the updates to disk asynchronously. Alternatively, you can use to write the data to disk synchronously. But because is synchronous, you should avoid calling it from your main thread because it could pause your UI rendering.\n\nTo retrieve values from a shared preferences file, call methods such as and , providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:"
    },
    {
        "link": "https://stackoverflow.com/questions/8855069/android-sharedpreferences-best-practices",
        "document": "In an application I have been building we rely on SharedPreferences quite a bit, this got me thinking about what is best practice when it comes to accessing SharedPreferences. For instance many people say the appropriate way to access it is via this call:\n\nHowever it seems like this could be dangerous. If you have a large application that is relying on SharedPreferences you could have key duplication, especially in the case of using some third party library that relies on SharedPreferences as well. It seems to me that the better call to use would be:\n\nThis way if you have a class that heavily relies on SharedPreferences you can create a preference file that is used only by your class. You could use the fully qualified name of the class to ensure that the file will most likely not be duplicated by someone else.\n\nAlso based on this SO question: Should accessing SharedPreferences be done off the UI Thread?, it seems that accesses SharedPreferences should be done off the UI thread which makes sense.\n\nAre there any other best practices Android developers should be aware of when using SharedPreferences in their applications?"
    },
    {
        "link": "https://medium.com/@harmanpreet.khera/android-data-persistence-shared-preferences-room-and-files-a-comprehensive-guide-3573b9d03da0",
        "document": "It involves storing data on the device so that it can be accessed even after the app is closed or the device is restarted.\n\nAndroid offers various mechanisms for achieving data persistence, each with its strengths and weaknesses.\n\nThis article provides a comprehensive overview of three popular options: Shared Preferences, Room, and Files, exploring their use cases, implementation details and examples"
    },
    {
        "link": "https://medium.com/@EazSoftware/delving-into-android-data-storage-sharedpreferences-e39de269f7ba",
        "document": "Join us as we explore Android Data Storage. In this series, we delve into each data storage option for Android apps, uncovering their features, advantages, and ideal use cases for optimal data management in Android app development.\n\nEstablishing reliable data storage methods is crucial in Android development. While various options exist, such as Internal Storage, External Storage, and SQLite Databases, this discussion centers on SharedPreferences and its advanced alternatives: DataStore, SharedPreferences, and EncryptedSharedPreferences. Join us as we delve into these solutions, examining their intricacies, benefits, and practical applications within the Android landscape.\n\nSharedPreferences is a lightweight data storage mechanism in Android that stores key-value pairs persistently. It’s commonly used for storing small amounts of primitive data types, such as user preferences, settings, or application state. SharedPreferences provides a simple API for reading and writing data and is accessible across different components of an app. However, it lacks built-in encryption, making it less suitable for storing sensitive information.\n\nIt’s commonly used for storing user preferences, settings, or other app-related configurations. Here is some examples for it :\n\nFirst, we need to obtain an instance of SharedPreferences. We typically do this using the method, passing in a unique name for our SharedPreferences file and a mode (usually for private access within our app).\n\nis a unique identifier for the SharedPreferences file. Each SharedPreferences file is identified by a unique name, which allows multiple SharedPreferences files to coexist within the app or even across different apps on the same device. By providing a name for the SharedPreferences file, we can create separate instances of SharedPreferences to store different types of data or to maintain distinct sets of preferences/settings within the app.\n\nWe can use the interface to modify the contents of our SharedPreferences file. Let's say we want to save a user's name and email address:\n\nis used to persistently save the changes made to the SharedPreferences file. It applies the modifications asynchronously in the background and does not block the UI thread. Once is called, the changes are committed to the SharedPreferences file.\n\nIt’s important to note that is preferred over for asynchronous and non-blocking saving of SharedPreferences changes. is more efficient as it writes the changes to disk asynchronously, while writes the changes synchronously and may block the UI thread, causing potential performance issues, especially when dealing with larger datasets.\n\nTo retrieve data from SharedPreferences, we can use methods like , , , etc.\n\nThe second parameter in the method call represents the default value that will be returned if the specified preference key ( or ) is not found in the SharedPreferences file or if its value is null.\n\nTo modify existing data in SharedPreferences, we follow a similar process using the interface.\n\nIf we need to remove data from SharedPreferences, we can use the method.\n\nTo clear all data from SharedPreferences, we can use the method.\n\ncontains(): Checks if a preference with the specified key exists in the SharedPreferences file.\n\ngetAll(): Retrieves all key-value pairs from the SharedPreferences file as a Map.\n\nregisterOnSharedPreferenceChangeListener(): Registers a listener to be notified of changes to SharedPreferences values. in this example we will be updating UI based on Preference changes:\n\nHere are some additional usage patterns and best practices for working with SharedPreferences in Android development:\n\nUse Constants for Keys: Define constants for SharedPreferences keys to ensure consistency and avoid typos. This improves code readability and maintainability.\n\nEncapsulate SharedPreferences Access: Encapsulate SharedPreferences access within a dedicated class or object to abstract away implementation details and provide a clean interface for interacting with SharedPreferences.\n\nUse Default Values Effectively: Provide meaningful default values when retrieving SharedPreferences values. Avoid using empty strings ( ) or other default values that may not make sense in the context of your app.\n\nBatch Operations: If you need to perform multiple SharedPreferences operations together, batch them using a single call to minimize disk writes and improve efficiency.\n\nIf you like this post please don’t forget to follow me to get notify whenever there is new post in here :]"
    },
    {
        "link": "https://stackoverflow.com/questions/22437405/best-practices-for-sharedpreferences",
        "document": "I've wrote a little article that can also be found here.\n\nAndroid provides many ways of storing application data. One of those ways leads us to the SharedPreferences object which is used to store private primitive data in key-value pairs.\n\nAll logic are based only on three simple classes:\n\nis main of them. It's responsible for getting (parsing) stored data, provides interface for getting object and interfaces for adding and removing\n• To create you will need object (can be an application )\n• method parses Preference file and creates object for it\n• None You can create it in few modes provided by Context, it's strongly recommended to use MODE_PRIVATE because creating world-readable/writable files is very dangerous, and likely to cause security holes in applications // parse Preference file SharedPreferences preferences = context.getSharedPreferences(\"com.example.app\", Context.MODE_PRIVATE); // get values from Map preferences.getBoolean(\"key\", defaultValue) preferences.get..(\"key\", defaultValue) // you can get all Map but be careful you must not modify the collection returned by this // method, or alter any of its contents. Map<String, ?> all = preferences.getAll(); // get Editor object SharedPreferences.Editor editor = preferences.edit(); //add on Change Listener preferences.registerOnSharedPreferenceChangeListener(mListener); //remove on Change Listener preferences.unregisterOnSharedPreferenceChangeListener(mListener); // listener example SharedPreferences.OnSharedPreferenceChangeListener mOnSharedPreferenceChangeListener = new SharedPreferences.OnSharedPreferenceChangeListener() { @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) { } };\n\nis an Interface used for modifying values in a object. All changes you make in an editor are batched, and not copied back to the original until you call commit() or apply()\n• Use simple interface to put values in\n• Save values synchronous with or asynchronous with which is faster. In fact of using different threads using is safer. Thats why I prefer to use .\n• None Remove single value with or clear all values with // get Editor object SharedPreferences.Editor editor = preferences.edit(); // put values in editor editor.putBoolean(\"key\", value); editor.put..(\"key\", value); // remove single value by key editor.remove(\"key\"); // remove all values editor.clear(); // commit your putted values to the SharedPreferences object synchronously // returns true if success boolean result = editor.commit(); // do the same as commit() but asynchronously (faster but not safely) // returns nothing editor.apply();\n• None is a Singleton object so you can easily get as many references as you want, it opens file only when you call first time, or create only one reference for it. // There are 1000 String values in preferences SharedPreferences first = context.getSharedPreferences(\"com.example.app\", Context.MODE_PRIVATE); // call time = 4 milliseconds SharedPreferences second = context.getSharedPreferences(\"com.example.app\", Context.MODE_PRIVATE); // call time = 0 milliseconds SharedPreferences third = context.getSharedPreferences(\"com.example.app\", Context.MODE_PRIVATE); // call time = 0 milliseconds\n• None As is a Singleton object you can change any of It's instances and not be scared that their data will be different first.edit().putInt(\"key\",15).commit(); int firstValue = first.getInt(\"key\",0)); // firstValue is 15 int secondValue = second.getInt(\"key\",0)); // secondValue is also 15\n• None When you call method first time it parses value by key and adds this value to the map. So for second call it just gets it from map, without parsing.\n• None Remember the larger the Preference object is the longer , , , and operations will be. So it's highly recommended to separate your data in different small objects.\n• None Your Preferences will not be removed after Application update. So there are cases when you need to create some migration scheme. For example you have Application that parse local JSON in start of application, to do this only after first start you decided to save boolean flag . After some time you updated that JSON and released new application version. Users will update their applications but they will not load new JSON because they already done it in first application version.\n• None are stored in an xml file in the app data folder"
    }
]