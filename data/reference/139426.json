[
    {
        "link": "https://geeksforgeeks.org/python-opencv-cv2-imread-method",
        "document": "OpenCV-Python is a library of Python bindings designed to solve computer vision problems. cv2.imread() method loads an image from the specified file. If the image cannot be read (because of the missing file, improper permissions, or unsupported or invalid format) then this method returns an empty matrix.\n• None filename: The path to the image file.\n• None flag: The flag specifies the way how the image should be read.\n• cv2.IMREAD_COLOR – It specifies to load a color image. Any transparency of image will be neglected. It is the default flag. Alternatively, we can pass integer value 1\n• cv2.IMREAD_GRAYSCALE – It specifies to load an image in grayscale mode. Alternatively, we can pass integer value 0\n• cv2.IMREAD_UNCHANGED – It specifies to load an image as such including alpha channel. Alternatively, we can pass integer value -1 The cv2.imread() function return a NumPy array if the image is loaded successfully.\n\nIn this example, we are reading the image as a color image.\n\nIn this example, we are reading the image as a greyscale image. Both color and grayscale images are acceptable as input.\n\nIn this example, we are reading the image with the transparency channel.\n\nA NumPy array is produced after reading an image file with the cv2.imread() method. By default, the image is saved in the BGR color space. As a result, the blue, green, and red color channels, respectively, correspond to the first three channels of the NumPy array.\n\nWhat is the use of OpenCV in Python?\n\nWhat is the method used to read an image in OpenCV library?\n\nHow to load an image in Python OpenCV?\n\nTo load an image in Python using OpenCV, use the function and specify the path to the image file. \n\n\n\n\n\n \n\n\n\n \n\n \n\n\n\n # Wait for a key press and close the window \n\n\n\n\n\nWhat are the advantages of OpenCV in Python?"
    },
    {
        "link": "https://docs.opencv.org/3.4/d4/da8/group__imgcodecs.html",
        "document": "Reads an image from a buffer in memory. The function imdecode reads an image from the specified buffer in the memory. If the buffer is too short or contains invalid data, the function returns an empty matrix ( Mat::data==NULL ). See cv::imread for the list of supported formats and flags description. In the case of color images, the decoded images will have the channels stored in B G R order. The same flags as in cv::imread, see cv::ImreadModes.\n\nThis is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. The optional output placeholder for the decoded matrix. It can save the image reallocations when the function is called repeatedly for images of the same size.\n\nThe function imencode compresses the image and stores it in the memory buffer that is resized to fit the result. See cv::imwrite for the list of supported formats and flags description. File extension that defines the output format. Must include a leading period.\n\nThe function imread loads an image from the specified file and returns it. If the image cannot be read (because of missing file, improper permissions, unsupported or invalid format), the function returns an empty matrix ( Mat::data==NULL ). Currently, the following file formats are supported:\n• Raster and Vector geospatial data supported by GDAL (see the Note section)\n• The function determines the type of an image by the content, not by the file extension.\n• In the case of color images, the decoded images will have the channels stored in B G R order.\n• When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available. Results may differ to the output of cvtColor()\n• On Microsoft Windows* OS and MacOSX*, the codecs shipped with an OpenCV image (libjpeg, libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs, and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware that currently these native image loaders give images with different pixel values because of the color management embedded into MacOSX.\n• On Linux*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for codecs supplied with an OS image. Install the relevant packages (do not forget the development files, for example, \"libjpeg-dev\", in Debian* and Ubuntu*) to get the codec support or turn on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n• In the case you set WITH_GDAL flag to true in CMake and IMREAD_LOAD_GDAL to load the image, then the GDAL driver will be used in order to decode the image, supporting the following formats: Raster, Vector.\n• If EXIF information is embedded in the image file, the EXIF orientation will be taken into account and thus the image will be rotated accordingly except if the flags IMREAD_IGNORE_ORIENTATION or IMREAD_UNCHANGED are passed.\n• By default number of pixels must be less than 2^30. Limit can be set using system variable OPENCV_IO_MAX_IMAGE_PIXELS Name of file to be loaded. Flag that can take values of cv::ImreadModes\n\nSaves an image to a specified file. The function imwrite saves the image to the specified file. The image format is chosen based on the filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U) single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function, with these exceptions:\n• With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n• With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n• All images will be converted to 32-bit float (CV_32F).\n• With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).\n• With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n• With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U), 32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n• Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n• 32-bit float 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel) If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way. If the format, depth or channel order is different, use Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O functions to save the image to XML or YAML format. The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file. It also demonstrates how to save multiple images in a TIFF file: Name of the file. (Mat or vector of Mat) Image or Images to be saved."
    },
    {
        "link": "https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html",
        "document": "Prev Tutorial: Building OpenCV for Tegra with CUDA \n\n Next Tutorial: Writing documentation for OpenCV \n\n\n\nIn this tutorial you will learn how to:\n• Read an image from file (using cv::imread)\n• Display an image in an OpenCV window (using cv::imshow)\n• Write an image to a file (using cv::imwrite)\n\nIn OpenCV 3 we have multiple modules. Each one takes care of a different area or approach towards image processing. You could already observe this in the structure of the user guide of these tutorials itself. Before you use any of them you first need to include the header files where the content of each individual module is declared. You'll almost always end up using the:\n• core section, as here are defined the basic building blocks of the library\n• imgcodecs module, which provides functions for reading and writing\n• highgui module, as this contains the functions to show an image in a window We also include the iostream to facilitate console line output and input. By declaring , in the following, the library functions can be accessed without explicitly stating the namespace.\n\nAs a first step, the OpenCV python library is imported. The proper way to do this is to additionally assign it the name cv, which is used in the following to reference the library.\n\nNow, let's analyze the main code. As a first step, we read the image \"starry_night.jpg\" from the OpenCV samples. In order to do so, a call to the cv::imread function loads the image using the file path specified by the first argument. The second argument is optional and specifies the format in which we want the image. This may be:\n• IMREAD_COLOR loads the image in the BGR 8-bit format. This is the default that is used here.\n• IMREAD_UNCHANGED loads the image as is (including the alpha channel if present)\n• IMREAD_GRAYSCALE loads the image as an intensity one\n\nAfter reading in the image data will be stored in a cv::Mat object.\n\nAfterwards, a check is executed, if the image was loaded correctly.\n\nThen, the image is shown using a call to the cv::imshow function. The first argument is the title of the window and the second argument is the cv::Mat object that will be shown.\n\nBecause we want our window to be displayed until the user presses a key (otherwise the program would end far too quickly), we use the cv::waitKey function whose only parameter is just how long should it wait for a user input (measured in milliseconds). Zero means to wait forever. The return value is the key that was pressed.\n\nIn the end, the image is written to a file if the pressed key was the \"s\"-key. For this the cv::imwrite function is called that has the file path and the cv::Mat object as an argument."
    },
    {
        "link": "http://opencv24-python-tutorials.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html",
        "document": "Use the function cv2.imread() to read an image. The image should be in the working directory or a full path of image should be given. Second argument is a flag which specifies the way image should be read.\n• cv2.IMREAD_COLOR : Loads a color image. Any transparency of image will be neglected. It is the default flag. Instead of these three flags, you can simply pass integers 1, 0 or -1 respectively. Even if the image path is wrong, it won’t throw any error, but will give you\n\nUse the function cv2.imshow() to display an image in a window. The window automatically fits to the image size. First argument is a window name which is a string. second argument is our image. You can create as many windows as you wish, but with different window names. A screenshot of the window will look like this (in Fedora-Gnome machine): cv2.waitKey() is a keyboard binding function. Its argument is the time in milliseconds. The function waits for specified milliseconds for any keyboard event. If you press any key in that time, the program continues. If 0 is passed, it waits indefinitely for a key stroke. It can also be set to detect specific key strokes like, if key is pressed etc which we will discuss below. cv2.destroyAllWindows() simply destroys all the windows we created. If you want to destroy any specific window, use the function cv2.destroyWindow() where you pass the exact window name as the argument. There is a special case where you can already create a window and load image to it later. In that case, you can specify whether window is resizable or not. It is done with the function cv2.namedWindow(). By default, the flag is . But if you specify flag to be , you can resize window. It will be helpful when image is too large in dimension and adding track bar to windows.\n\nUse the function cv2.imwrite() to save an image. First argument is the file name, second argument is the image you want to save. This will save the image in PNG format in the working directory."
    },
    {
        "link": "https://media.readthedocs.org/pdf/opencv24-python-tutorials/stable/opencv24-python-tutorials.pdf",
        "document": ""
    },
    {
        "link": "https://numpy.org/doc/2.2/reference/generated/numpy.max.html",
        "document": "Return the maximum of an array or maximum along an axis.\n\naxis None or int or tuple of ints, optional Axis or axes along which to operate. By default, flattened input is used. If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before. Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output. See Output type determination for more details. If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then keepdims will not be passed through to the method of sub-classes of , however any non-default value will be. If the sub-class’ method does not implement keepdims any exceptions will be raised. The minimum value of an output element. Must be present to allow computation on empty slice. See for details. Elements to compare for the maximum. See for details. Maximum of a. If axis is None, the result is a scalar value. If axis is an int, the result is an array of dimension . If axis is a tuple, the result is an array of dimension .\n\nNaN values are propagated, that is if at least one item is NaN, the corresponding max value will be NaN as well. To ignore NaN values (MATLAB behavior), please use nanmax.\n\nDon’t use for element-wise comparison of 2 arrays; when is 2, is faster than .\n\nYou can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:\n\nNotice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Python’s max function, which is only used for empty iterables."
    },
    {
        "link": "https://numpy.org/doc/2.2/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    },
    {
        "link": "https://realpython.com/numpy-max-maximum",
        "document": "NumPy’s function efficiently finds maximum values within an array, making it a key tool for data analysis in Python. This tutorial guides you through using and , handling missing values, and explores advanced features like broadcasting for comparing arrays of different shapes.\n\nBy the end of this tutorial, you’ll understand that:\n• NumPy’s function finds the maximum value within a single array, working with both one-dimensional and multi-dimensional arrays.\n• Conversely, compares two arrays element-wise to find the maximum values.\n• and are equivalent in NumPy.\n• You can use to find the maximum value in an array while ignoring values, preventing them from affecting the result.\n\nThis tutorial includes a very short introduction to NumPy, so even if you’ve never used NumPy before, you should be able to jump right in.\n\nWith the background provided here, you’ll be ready to continue exploring the wealth of functionality to be found in the NumPy library.\n\nNumPy’s : The Maximum Element in an Array In this section, you’ll become familiar with , a versatile tool for finding maximum values in various circumstances. Note: NumPy has both a package-level function and an method named . They work in the same way, though the package function requires the target array name as its first parameter. In what follows, you’ll be using the function and the method interchangeably. Python also has a built-in function that can calculate maximum values of iterables. You can use this built-in to find the maximum element in a one-dimensional NumPy array, but it has no support for arrays with more dimensions. When dealing with NumPy arrays, you should stick to NumPy’s own maximum functions and methods. For the rest of this tutorial, will always refer to the NumPy version. is the tool that you need for finding the maximum value or values in a single array. Ready to give it a go? To illustrate the function, you’re going to create an array named containing the test scores obtained by the students in Professor Newton’s linear algebra class. Each row represents one student, and each column contains the scores on a particular test. So column contains all the student scores for the first test, column contains the scores for the second test, and so on. Here’s the array: You can copy and paste this code into your Python console if you want to follow along. To simplify the formatting before copying, click at the top right of the code block. You can do the same with any of the Python code in the examples. Once you’ve done that, the array is in memory. You can ask the interpreter for some of its attributes: The and attributes, as above, confirm that you have rows representing students and columns representing tests, for a total of test scores. Suppose now that you want to find the top score achieved by any student on any test. For Professor Newton’s little linear algebra class, you could find the top score fairly quickly just by examining the data. But there’s a quicker method that’ll show its worth when you’re dealing with much larger datasets, containing perhaps thousands of rows and columns. Try using the array’s method: The method has scanned the whole array and returned the largest element. Using this method is exactly equivalent to calling . But perhaps you want some more detailed information. What was the top score for each test? Here you can use the parameter: The new parameter tells NumPy to find the largest value out of all the rows. Since has five columns, NumPy does this for each column independently. This produces five numbers, each of which is the maximum value in that column. The parameter uses the standard convention for indexing dimensions. So refers to the rows of an array, and refers to the columns. The top score for each student is just as easy to find: This time, NumPy has returned an array with eight elements, one per student. The array contains one row per student. The parameter told NumPy to find the maximum value for each student, across the columns. Therefore, each element of the output contains the highest score attained by the corresponding student. Perhaps you want the top scores per student, but you’ve decided to exclude the first and last tests. Slicing does the trick: You can understand the slice notation as follows. The first index range, represented by the lone , selects all the rows in the slice. The second index range after the comma, , tells NumPy to take the columns, starting at column and ending column before the last. The result of the slice is stored in a new array named . With a bit of practice, you’ll learn to do array slicing on the fly, so you won’t need to create the intermediate array explicitly: Here you’ve performed the slice and the method call in a single line, but the result is the same. NumPy returns the per-student set of maximum for the restricted set of tests. So now you know how to find maximum values in any completely filled array. But what happens when a few array values are missing? This is pretty common with real-world data. To illustrate, you’ll create a small array containing a week’s worth of daily temperature readings, in Celsius, from a digital thermometer, starting on Monday: It seems the thermometer had a malfunction on Saturday, and the corresponding temperature value is missing, a situation indicated by the value. This is the special value Not a Number, which is commonly used to mark missing values in real-world data applications. So far, so good. But a problem arises if you innocently try to apply to this array: Since reports a missing value, NumPy’s default behavior is to flag this by reporting that the maximum, too, is unknown. For some applications, this makes perfect sense. But for your application, perhaps you’d find it more useful to ignore the Saturday problem and get a maximum value from the remaining, valid readings. NumPy has provided the function to take care of such situations: This function ignores any values and returns the largest numerical value, as expected. Notice that is a function in the NumPy library, not a method of the object. You’ve now seen the most common examples of NumPy’s maximum-finding capabilities for single arrays. But there are a few more NumPy functions related to maximum values that are worth knowing about. For example, instead the maximum values in an array, you might want the indices of the maximum values. Let’s say you want to use your array to identify the student who did best on each test. The method is your friend here: It appears that student obtained the top score on every test but one. Student did best on the fourth test. You’ll recall that you can also apply as a function of the NumPy package, rather than as a method of a NumPy array. In this case, the array must be supplied as the first argument of the function. For historical reasons, the package-level function has an alias, , which is identical in every respect apart from the name: In the code above, you’ve called as a method of the object, and as a stand-alone library function with as its first parameter. You’ve also called the alias in the same way. All three calls produce exactly the same results. Now you’ve seen how to use , , or to find maximum values for an array along various axes. You’ve also used to find the maximum values while ignoring values, as well as or to find the indices of the maximum values. You won’t be surprised to learn that NumPy has an equivalent set of minimum functions: , , , , , and . You won’t deal with those here, but they behave exactly like their maximum cousins.\n\nAnother common task in data science involves comparing two similar arrays. NumPy’s function is the tool of choice for finding maximum values across arrays. Since always involves two input arrays, there’s no corresponding method. The function expects the input arrays as its first two parameters. Continuing with the previous example involving class scores, suppose that Professor Newton’s colleague—and archrival—Professor Leibniz is also running a linear algebra class with eight students. Construct a new array with the values for Leibniz’s class: The new array, , has the same shape as . You’d like to compare the two classes, student by student and test by test, to find the higher score in each case. NumPy has a function, , specifically designed for comparing two arrays in an element-by-element manner. Check it out in action: If you visually check the arrays and , then you’ll see that has indeed picked out the higher of the two scores for each [row, column] pair of indices. What if you only want to compare the best test results in each class? You can combine and to get that effect: As before, each call to returns an array of maximum scores for all the students in the relevant class, one element for each test. But this time, you’re feeding those returned arrays into the function, which compares the two arrays and returns the higher score for each test across the arrays. You can combine those operations into one by dispensing with the intermediate arrays, and : This gives the same result as before, but with less typing. You can choose whichever method you prefer. Remember the array from an earlier example? If you use a second week’s temperature records with the function, you may spot a familiar problem. First, you’ll create a new array to hold the new temperatures: There are missing values in the data, too. Now see what happens if you apply the function to these two temperature arrays: All the values in both arrays have popped up as missing values in the output. There’s a good reason for NumPy’s approach to propagating . Often it’s important for the integrity of your results that you keep track of the missing values, rather than brushing them under the rug. But here, you just want to get the best view of the weekly maximum values. The solution, in this case, is another NumPy package function, : Now, two of the missing values have simply been ignored, and the remaining floating-point value at that index has been taken as the maximum. But the Saturday temperature can’t be fixed in that way, because both source values are missing. Since there’s no reasonable value to insert here, just leaves it as a . Just as and have the parallel minimum functions and , so too do and have corresponding functions, and , that mirror their functionality for minimum values.\n\nYou’ve now seen examples of all the basic use cases for NumPy’s and , plus a few related functions. Now you’ll investigate some of the more obscure optional parameters to these functions and find out when they can be useful. When you call a function in Python, a value or object is returned. You can use that result immediately by printing it or writing it to disk, or by feeding it directly into another function as an input parameter. You can also save it to a new variable for future reference. If you call the function in the Python REPL but don’t use it in one of those ways, then the REPL prints out the return value on the console so that you’re aware that something has been returned. All of this is standard Python stuff, and not specific to NumPy. NumPy’s array functions are designed to handle huge inputs, and they often produce huge outputs. If you call such a function many hundreds or thousands of times, then you’ll be allocating very large amounts of memory. This can slow your program down and, in an extreme case, might even cause a memory or stack overflow. This problem can be avoided by using the parameter, which is available for both and , as well as for many other NumPy functions. The idea is to pre-allocate a suitable array to hold the function result, and keep reusing that same chunk of memory in subsequent calls. You can revisit the temperature problem to create an example of using the parameter with the function. You’ll also use the parameter to control the type of the returned array: The initial values in don’t matter, since they’ll be overwritten. But the array’s shape is important in that it must match the output shape. The displayed result looks like the output that you received from the original example. So what’s changed? The difference is that you now have the same data stored in : The return value has been stored in the variable, which you previously created with the right shape to accept that return value. Since you also specified when you declared this buffer, NumPy will do its best to convert the output data to that type. Remember to use the buffer contents before they’re overwritten by the next call to this function. Another parameter that’s occasionally useful is . This applies a filter to the input array or arrays, so that only those values for which the condition is will be included in the comparison. The other values will be ignored, and the corresponding elements of the output array will be left unaltered. In most cases, this will leave them holding arbitrary values. For the sake of the example, suppose you’ve decided, for whatever reason, to ignore all scores less than for calculating the per-student maximum values in Professor Newton’s class. Your first attempt might go like this: ValueError: reduction operation 'maximum' does not have an identity, so to use a where mask one has to specify 'initial' The problem here is that NumPy doesn’t know what to do with the students in rows and , who didn’t achieve a single test score of or better. The solution is to provide an parameter: With the two new parameters, and , considers only the elements greater than or equal to . For the rows where there is no such element, it returns the value of instead. So the lucky students at indices and got their best score boosted to by this operation! The original array is untouched. You’ve learned how to use to compare arrays with identical shapes. But it turns out that this function, along with many others in the NumPy library, is much more versatile than that. NumPy has a concept called broadcasting that provides a very useful extension to the behavior of most functions involving two arrays, including . Whenever you call a NumPy function that operates on two arrays, and , it checks their properties to see if they’re compatible. If they have exactly the same , then NumPy just matches the arrays element by element, pairing up the element at with the element at . works like this too. Broadcasting enables NumPy to operate on two arrays with different shapes, provided there’s still a sensible way to match up pairs of elements. The simplest example of this is to broadcast a single element over an entire array. You’ll explore broadcasting by continuing the example of Professor Newton and his linear algebra class. Suppose he asks you to ensure that none of his students receives a score below . Here’s how you might do it: You’ve applied the function to two arguments: , whose is (8, 5), and the single scalar parameter . You can think of this second parameter as a 1 × 1 array that’ll be stretched inside the function to cover eight rows and five columns. The stretched array can then be compared element by element with , and the pairwise maximum can be returned for each element of the result. The result is the same as if you had compared with an array of its own shape, (8, 5), but with the value in each element. This stretching is just conceptual—NumPy is smart enough to do all this without actually creating the stretched array. So you get the notational convenience of this example without compromising efficiency. You can do much more with broadcasting. Professor Leibniz has noticed Newton’s skulduggery with his array, and decides to engage in a little data manipulation of her own. Leibniz’s plan is to artificially boost all her students’ scores to be at least equal to the average score for a particular test. This will have the effect of increasing all the below-average scores—and thus produce some quite misleading results! How can you help the professor achieve her somewhat nefarious ends? Your first step is to use the array’s method to create a one-dimensional array of means per test. Then you can use and broadcast this array over the entire matrix: The broadcasting happens in the highlighted function call. The one-dimensional array has been conceptually stretched to match the two-dimensional array. The output array has the same as the larger of the two input arrays, . So, what are the rules for broadcasting? A great many NumPy functions accept two array arguments. is just one of these. Arrays that can be used together in such functions are termed compatible, and their compatibility depends on the number and size of their dimensions—that is, on their . The simplest case occurs if the two arrays, say and , have identical shapes. Each element in is matched, for the function’s purposes, to the element at the same index address in . Broadcasting rules get more interesting when and have different shapes. The elements of compatible arrays must somehow be unambiguously paired together so that each element of the larger array can interact with an element of the smaller array. The output array will have the of the larger of the two input arrays. So compatible arrays must follow these rules:\n• If one array has fewer dimensions than the other, only the trailing dimensions are matched for compatibility. The trailing dimensions are those that are present in the of both arrays, counting from the right. So if is and is , then and are compatible because are the trailing dimensions of each. You can completely ignore the two leftmost dimensions of .\n• Even if the trailing dimensions aren’t equal, the arrays are still compatible if one of those dimensions is equal to in either array. So if is as before and is or or or , then is still compatible with in each case. You can get a feel for the broadcasting rules by playing around in the Python REPL. You’ll be creating some toy arrays to illustrate how broadcasting works and how the output array is generated: There’s nothing really new to see here yet. You’ve created two arrays of identical and applied the operation to them. Notice that the handy method lets you build arrays of any shape. You can verify that the result is the element-by-element maximum of the two inputs. The fun starts when you experiment with comparing two arrays of different shapes. Try slicing to make a new array, : The two arrays, and , are compatible because the new array’s second dimension is , and the other dimensions match. Notice that the of the result of the operation is the same as . That’s because , the smaller array, is being broadcast over . The result of a broadcast operation between arrays will always have the of the larger array. Now you can try an even more radical slicing of : Once again, the trailing dimensions of and are all either equal or , so the arrays are compatible and the broadcast works. The result has the same as . Perhaps the most extreme type of broadcasting occurs when one of the array parameters is passed as a scalar: NumPy automatically converts the second parameter, , to an with , determines that this converted parameter is compatible with the first, and duly broadcasts it over the entire 2 × 3 × 4 array . : operands could not be broadcast together with shapes (2,3,4) (2,2,4) If you refer back to the broadcasting rules above, you’ll see the problem: the second dimensions of and don’t match, and neither is equal to , so the two arrays are incompatible. You can read more about broadcasting in Look Ma, No Loops: Array Programming With NumPy. There’s also a good description of the rules in the NumPy docs. The broadcasting rules can be confusing, so it’s a good idea to play around with some toy arrays until you get a feel for how it works!\n\nIn this tutorial, you’ve explored the NumPy library’s and operations to find the maximum values within or across arrays.\n• Why NumPy has its own function, and how you can use it\n• How the function differs from , and when it’s needed\n• Which practical applications exist for each function\n• How you can handle missing data so your results make sense\n• How you can apply your knowledge to the complementary task of finding minimum values Along the way, you’ve learned or refreshed your knowledge of the basics of NumPy syntax. NumPy is a hugely popular library because of its powerful support for array operations. Now that you’ve mastered the details of NumPy’s and , you’re ready to use them in your applications, or continue learning about more of the hundreds of array functions supported by NumPy. Free Bonus: Click here to get access to a free NumPy Resources Guide that points you to the best tutorials, videos, and books for improving your NumPy skills. If you’re interested in using NumPy for data science, then you’ll also want to investigate pandas, a very popular data-science library built on top of NumPy. You can learn about it in The Pandas DataFrame: Make Working With Data Delightful. And if you want to produce compelling images from data, take a look at Python Plotting With Matplotlib (Guide). The applications of NumPy are limitless. Wherever your NumPy adventure takes you next, go forth and matrix-multiply!"
    },
    {
        "link": "https://numpy.org/devdocs/user/quickstart.html",
        "document": "You’ll need to know a bit of Python. For a refresher, see the Python tutorial. To work the examples, you’ll need installed in addition to NumPy. This is a quick overview of arrays in NumPy. It demonstrates how n-dimensional (\\(n>=2\\)) arrays are represented and can be manipulated. In particular, if you don’t know how to apply common functions to n-dimensional arrays (without using for-loops), or if you want to understand axis and shape properties for n-dimensional arrays, this article might be of help. After reading, you should be able to:\n• None Understand the difference between one-, two- and n-dimensional arrays in NumPy;\n• None Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;\n\nNumPy’s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called axes. For example, the array for the coordinates of a point in 3D space, , has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3. NumPy’s array class is called . It is also known by the alias . Note that is not the same as the Standard Python Library class , which only handles one-dimensional arrays and offers less functionality. The more important attributes of an object are: the number of axes (dimensions) of the array. the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m columns, will be . The length of the tuple is therefore the number of axes, . the total number of elements of the array. This is equal to the product of the elements of . an object describing the type of the elements in the array. One can create or specify dtype’s using standard Python types. Additionally NumPy provides types of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples. the size in bytes of each element of the array. For example, an array of elements of type has 8 (=64/8), while one of type has 4 (=32/8). It is equivalent to . the buffer containing the actual elements of the array. Normally, we won’t need to use this attribute because we will access the elements in an array using indexing facilities. There are several ways to create arrays. For example, you can create an array from a regular Python list or tuple using the function. The type of the resulting array is deduced from the type of the elements in the sequences. A frequent error consists in calling with multiple arguments, rather than providing a single sequence as an argument. : array() takes from 1 to 2 positional arguments but 4 were given transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on. The type of the array can also be explicitly specified at creation time: Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation. The function creates an array full of zeros, the function creates an array full of ones, and the function creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is , but it can be specified via the key word argument . To create sequences of numbers, NumPy provides the function which is analogous to the Python built-in , but returns an array. When is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function that receives as an argument the number of elements that we want, instead of the step: # useful to evaluate function at lots of points When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:\n• None the last axis is printed from left to right,\n• None the second-to-last is printed from top to bottom,\n• None the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. See below to get more details on . If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: To disable this behaviour and force NumPy to print the entire array, you can change the printing options using . Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. Unlike in many matrix languages, the product operator operates elementwise in NumPy arrays. The matrix product can be performed using the operator (in python >=3.5) or the function or method: Some operations, such as and , act in place to modify an existing array rather than create a new one. # b is not automatically converted to integer type : Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting). Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the class. By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the parameter you can apply an operation along the specified axis of an array: NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called “universal functions” ( ). Within NumPy, these functions operate elementwise on an array, producing an array as output. One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences. # from start to position 6, exclusive, set every 2nd element to 1000 Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas: # each row in the second column of b # equivalent to the previous example # each column in the second and third row of b When fewer indices are provided than the number of axes, the missing indices are considered complete slices # the last row. Equivalent to b[-1, :] The expression within brackets in is treated as an followed by as many instances of as needed to represent the remaining axes. NumPy also allows you to write this using dots as . The dots ( ) represent as many colons as needed to produce a complete indexing tuple. For example, if is an array with 5 axes, then # same as c[1, :, :] or c[1] Iterating over multidimensional arrays is done with respect to the first axis: However, if one wants to perform an operation on each element in the array, one can use the attribute which is an iterator over all the elements of the array:\n\nChanging the shape of an array# An array has a shape given by the number of elements along each axis: The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array: The order of the elements in the array resulting from is normally “C-style”, that is, the rightmost index “changes the fastest”, so the element after is . If the array is reshaped to some other shape, again the array is treated as “C-style”. NumPy normally creates arrays stored in this order, so will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions and can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest. The function returns its argument with a modified shape, whereas the method modifies the array itself: If a dimension is given as in a reshaping operation, the other dimensions are automatically calculated: Several arrays can be stacked together along different axes: The function stacks 1D arrays as columns into a 2D array. It is equivalent to only for 2D arrays: # the result is different In general, for arrays with more than two dimensions, stacks along their second axes, stacks along their first axes, and allows for an optional arguments giving the number of the axis along which the concatenation should happen. In complex cases, and are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals . When used with arrays as arguments, and are similar to and in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate. Splitting one array into several smaller ones# Using , you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur: # Split `a` after the third and the fourth column splits along the vertical axis, and allows one to specify along which axis to split.\n\nWhen operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases: No copy at all# Simple assignments make no copy of objects or their data. # no new object is created # a and b are two names for the same ndarray object Python passes mutable objects as references, so function calls make no copy. # id is a unique identifier of an object Different array objects can share the same data. The method creates a new array object that looks at the same data. # c is a view of the data owned by a # a's shape doesn't change, reassigned c is still a view of a Slicing an array returns a view of it: # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10 The method makes a complete copy of the array and its data. # a new array object with new data is created Sometimes should be called after slicing if the original array is not required anymore. For example, suppose is a huge intermediate result and the final result only contains a small fraction of , a deep copy should be made when constructing with slicing: # the memory of ``a`` can be released. If is used instead, is referenced by and will persist in memory even if is executed. See also Copies and views. Here is a list of some useful NumPy functions and methods names ordered in categories. See Routines and objects by topic for the full list.\n\nNumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans. # the elements of `a` at the positions `i` When the indexed array is multidimensional, a single array of indices refers to the first dimension of . The following example shows this behavior by converting an image of labels into a color image using a palette. # each value corresponds to a color in the palette We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape. # indices for the first dim of `a` # indices for the second dim # i and j must have equal shape In Python, is exactly the same as —so we can put and in a and then do the indexing with that. However, we can not do this by putting and into an array, because this array will be interpreted as indexing the first dimension of . File , line , in : index 3 is out of bounds for axis 0 with size 3 Another common use of indexing with arrays is the search of the maximum value of time-dependent series: # index of the maxima for each series # times corresponding to the maxima You can also use indexing with arrays as a target to assign to: However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value: This is reasonable enough, but watch out if you want to use Python’s construct, as it may not do what you expect: Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires to be equivalent to . When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don’t. The most natural way one can think of for boolean indexing is to use boolean arrays that have the same shape as the original array: # `b` is a boolean with `a`'s shape This property can be very useful in assignments: # All elements of `a` higher than 4 become 0 You can look at the following example to see how to use boolean indexing to generate an image of the Mandelbrot set: \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\" The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want: Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, has length 3 (the number of rows in ), and (of length 4) is suitable to index the 2nd axis (columns) of . The function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c: You could also implement the reduce as follows: The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the broadcasting rules in order to avoid creating an argument array the size of the output times the number of vectors."
    },
    {
        "link": "https://scipy-lectures.org/advanced/image_processing",
        "document": "2.6. Image manipulation and processing using Numpy and Scipy¶\n\nThis section addresses basic image manipulation and processing using the core scientific modules NumPy and SciPy. Some of the operations covered by this tutorial may be useful for other kinds of multidimensional array processing than image processing. In particular, the submodule provides functions operating on n-dimensional NumPy arrays.\n\nTools used in this tutorial:\n• None : submodule dedicated to image processing (n-dimensional images). See the documentation:\n• Image segmentation: labeling pixels corresponding to different objects\n\n# First we need to create the PNG file Need to know the shape and dtype of the image (how to separate data bytes). For large data, use for memory mapping:\n\nLocal filters: replace the value of pixels by a function of the values of neighboring pixels. increase the weight of edges by adding an approximation of the Laplacian: A Gaussian filter smoothes the noise out… and the edges as well:\n• Create a binary image (of 0s and 1s) with several objects (circles, ellipses, squares, or random shapes).\n• Try two different denoising methods for denoising the image: gaussian filtering and median filtering.\n• Compare the histograms of the two different denoised images. Which one is the closest to the histogram of the original (noise-free) image? More denoising filters are available in , see the Scikit-image: image processing tutorial. See wikipedia for a definition of mathematical morphology. Probe an image with a simple shape (a structuring element), and modify this image according to how the shape locally fits or misses the image. Erosion = minimum filter. Replace the value of a pixel by the minimal value covered by the structuring element.: Many other mathematical morphology operations: hit and miss transform, tophat, etc.\n\nUse mathematical morphology to clean up the result: Check that reconstruction operations (erosion + propagation) produce a better result than opening/closing: Check how a first denoising step (e.g. with a median filter) modifies the histogram, and check that the resulting histogram-based segmentation is more accurate. More advanced segmentation algorithms are found in the : see Scikit-image: image processing. Other Scientific Packages provide algorithms that can be useful for image processing. In this example, we use the spectral clustering function of the in order to segment glued objects. # Convert the image into a graph with the value of the gradient on # Take a decreasing function of the gradient: we take it weakly # dependant from the gradient the segmentation is close to a voronoi\n\nCompute size, mean_value, etc. of each region: Can be used outside the limited scope of segmentation applications. # note that we use broadcasting When regions are regular blocks, it is more efficient to use stride tricks (Example: fake dimensions with strides). One example with mathematical morphology: granulometry"
    }
]