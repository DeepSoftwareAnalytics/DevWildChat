[
    {
        "link": "https://geeksforgeeks.org/rsa-algorithm-cryptography",
        "document": "RSA(Rivest-Shamir-Adleman) Algorithm is an asymmetric or public-key cryptography algorithm which means it works on two different keys: Public Key and Private Key. The Public Key is used for encryption and is known to everyone, while the Private Key is used for decryption and must be kept secret by the receiver. RSA Algorithm is named after Ron Rivest, Adi Shamir and Leonard Adleman, who published the algorithm in 1977.\n\nIf Person A wants to send a message securely to Person B:\n• decrypts the message using their Private\n• p q . These prime numbers should be kept secret.\n• n = p * q . This product is part of the public as well as the private key.\n• e\n• None gcd(e, Φ(n)) = 1, that is e should be co-prime with Φ(n).\n• d,\n• (d * e) ≡ 1 mod Φ(n) , that is d is e mod Φ(n). Some common methods to calculate multiplicative inverse are:\n• None We can have multiple values of d satisfying (d * e) ≡ 1 mod Φ(n) but it does not matter which value we choose as all of them are valid keys and will result into same message on decryption.\n\nFinally, the Public Key = (n, e) and the Private Key = (n, d).\n\nTo encrypt a message M, it is first converted to numerical representation using ASCII and other encoding schemes. Now, use the public key (n, e) to encrypt the message and get the cipher text using the formula:\n\nTo decrypt the cipher text C, use the private key (n, d) and get the original data using the formula:\n\nThe idea of RSA is based on the fact that it is difficult to factorize a large integer. The Public Key is (n, e), where n and e are publicly known, while the Private Key is (n, d). Since only the receiver knows the value of d, only they can decrypt the message. But is it possible to find the value of d using n and e?\n\nWe know that (d * e) ≡ 1 mod Φ(n), so if we can calculate the value of Φ(n), we can find the value of d. But Φ(n) = (p – 1) * (q – 1). So, we need the value of p and q. Now, one might think that it’s quite easy to find the value of p and q as n = p * q and n is already publicly known but RSA Algorithm takes the value of p and q to be very large which in turn makes the value of n extremely large and factorizing such a large value is computationally impossible.\n\nTherefore encryption strength lies in the values of p and q. RSA keys can be typically 1024 or 2048 bits long, but experts believe that 1024-bit keys could be broken shortly. But till now it seems to be an infeasible task.\n\nNote: If someone gets to know the value of p and q, then he can calculate the value of d and decrypt the message.\n\n// C++ Program for implementation of RSA Algorithm // Here we are calculating phi(n) using Hit and Trial Method // but we can optimize it using Extended Euclidean Algorithm # Here we are calculating phi(n) using Hit and Trial Method # but we can optimize it using Extended Euclidean Algorithm\n• Security: RSA algorithm is considered to be very secure and is widely used for secure data transmission.\n• Public-key cryptography: RSA algorithm is a public-key cryptography algorithm, which means that it uses two different keys for encryption and decryption. The public key is used to encrypt the data, while the private key is used to decrypt the data.\n• Key exchange: RSA algorithm can be used for secure key exchange, which means that two parties can exchange a secret key without actually sending the key over the network.\n• Digital signatures: RSA algorithm can be used for digital signatures, which means that a sender can sign a message using their private key, and the receiver can verify the signature using the sender’s public key.\n• Widely used: Online banking, e-commerce, and secure communications are just a few fields and applications where the RSA algorithm is extensively developed.\n• Slow processing speed: RSA algorithm is slower than other encryption algorithms, especially when dealing with large amounts of data.\n• Large key size: RSA algorithm requires large key sizes to be secure, which means that it requires more computational resources and storage space.\n• Vulnerability to side-channel attacks: RSA algorithm is vulnerable to side-channel attacks, which means an attacker can use information leaked through side channels such as power consumption, electromagnetic radiation, and timing analysis to extract the private key.\n• Limited use in some applications: RSA algorithm is not suitable for some applications, such as those that require constant encryption and decryption of large amounts of data, due to its slow processing speed.\n• Complexity: The RSA algorithm is a sophisticated mathematical technique that some individuals may find challenging to comprehend and use.\n• Key Management: The secure administration of the private key is necessary for the RSA algorithm, although in some cases this can be difficult.\n• Vulnerability to Quantum Computing: Quantum computers have the ability to attack the RSA algorithm, potentially decrypting the data.\n\nWhat is the RSA algorithm, and how does it work?\n\nWhat are the key components of the RSA algorithm?\n\nWhat are the primary applications of RSA?\n\nHow can I ensure the security of RSA encryption?"
    },
    {
        "link": "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa",
        "document": "This is a “Hazardous Materials” module. You should ONLY use it if you’re 100% absolutely sure that you know what you’re doing because this module is full of land mines, dragons, and dinosaurs with laser guns.\n\nRSA is a public-key algorithm for encrypting and signing messages.\n\nIf you already have an on-disk key in the PEM format (which are recognizable by the distinctive and markers), you can load it: Serialized keys may optionally be encrypted on disk using a password. In this example we loaded an unencrypted key, and therefore we did not provide a password. If the key is encrypted we can pass a object as the argument. There is also support for .\n\nIf you have a private key that you’ve loaded you can use to serialize the key. It is also possible to serialize without encryption using . For public keys you can use to serialize the key.\n\nA private key can be used to sign a message. This allows anyone with the public key to verify that the message was created by someone who possesses the corresponding private key. RSA signatures require a specific hash function, and padding to be used. Here is an example of signing using RSA, with a secure hash function and padding: Valid paddings for signatures are and . is the recommended choice for any new protocols or applications, should only be used to support legacy protocols. If your data is too large to be passed in a single call, you can hash it separately and pass that value using .\n\nThe previous section describes what to do if you have a private key and want to sign something. If you have a public key, a message, a signature, and the signing algorithm that was used you can check that the private key associated with a given public key was used to sign that specific message. You can obtain a public key to use in verification using , , , or . If the signature does not match, will raise an exception. If your data is too large to be passed in a single call, you can hash it separately and pass that value using .\n\nRSA encryption is interesting because encryption is performed using the public key, meaning anyone can encrypt data. The data is then decrypted using the private key. Like signatures, RSA supports encryption with several different padding options. Here’s an example using a secure padding and hash function: Valid paddings for encryption are and . is the recommended choice for any new protocols or applications, should only be used to support legacy protocols.\n\nThese classes hold the constituent components of an RSA key. They are useful only when more traditional Key Serialization is unavailable. The collection of integers that make up an RSA public key. The collection of integers that make up an RSA private key. With the exception of the integers contained in the all attributes of this class must be kept secret. Revealing them will compromise the security of any cryptographic operations performed with a key loaded from them. The which makes up the RSA public key associated with this RSA private key. , one of the two primes composing . , one of the two primes composing . A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: d mod (p-1) A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: d mod (q-1) A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: q-1 mod p A keyword-only argument that defaults to . If RSA private keys will not be validated. This significantly speeds up loading the keys, but is unsafe unless you are certain the key is valid. User supplied keys should never be loaded with this parameter set to . If you do load an invalid key this way and attempt to use it OpenSSL may hang, crash, or otherwise misbehave.\n\nIf you are trying to load RSA private keys yourself you may find that not all parameters required by are available. In particular the Chinese Remainder Theorem (CRT) values , , may be missing or present in a different form. For example, OpenPGP does not include the , or parameters. The following functions are provided for users who want to work with keys like this without having to do the math themselves. Computes the (also known as ) parameter from the RSA primes and . Computes the parameter from the RSA private exponent ( ) and prime . Computes the parameter from the RSA private exponent ( ) and prime . Computes the RSA private_exponent ( ) given the public exponent ( ) and the RSA primes and . This implementation uses the Carmichael totient function to return the smallest working value of . Older RSA implementations, including the original RSA paper, often used the Euler totient function, which results in larger but equally functional private exponents. The private exponents resulting from the Carmichael totient function, as returned here, are slightly more computationally efficient to use, and some modern standards require them. Computes the prime factors given the modulus, public exponent, and private exponent. When recovering prime factors this algorithm will always return and such that . Note: before 1.5, this function always returned and such that . It was changed because libraries commonly require .\n\nOur implementation of PKCS1 v1.5 decryption is not constant time. See Known security limitations for details. Decrypt data that was encrypted with the public key. An RSA public key object corresponding to the values of the private key. The bit length of the modulus. Changed in version 1.6: can now be used as an . Sign one block of data which can be verified later by others using the public key.\n• None algorithm – An instance of or if the you want to sign has already been hashed. Allows serialization of the key to bytes. Encoding ( or ), format ( , or ) and encryption algorithm (such as or ) are chosen to define the exact serialization.\n• None encoding – A value from the enum.\n• None format – A value from the enum.\n• None encryption_algorithm – An instance of an object conforming to the interface. ValueError – The data could not be encrypted. One possible cause is if is too large; RSA keys can only encrypt data that is smaller than the key size. The bit length of the modulus. Allows serialization of the key to bytes. Encoding ( or ) and format ( or ) are chosen to define the exact serialization.\n• None encoding – A value from the enum.\n• None format – A value from the enum. Changed in version 1.6: can now be used as an . Verify one block of data was signed by the private key associated with this public key.\n• None data (bytes-like) – The message string that was signed.\n• None algorithm – An instance of or if the you want to verify has already been hashed. cryptography.exceptions.InvalidSignature – If the signature does not validate. Recovers the signed data from the signature. The data typically contains the digest of the original message string. The and parameters must match the ones used when the signature was created for the recovery to succeed. The parameter can also be set to to recover all the data present in the signature, without regard to its format or the hash algorithm used for its creation. For padding, this method returns the data after removing the padding layer. For standard signatures the data contains the full structure. For non-standard signatures, any data can be returned, including zero-length data. Normally you should use the function to validate the signature. But for some non-standard signature formats you may need to explicitly recover and validate the signed data. The following are some examples:\n• None Some old Thawte and Verisign timestamp certificates without .\n• None padding – An instance of . Recovery is only supported with some of the padding types. (Currently only with ).\n• None algorithm – An instance of . Can be to return the all the data present in the signature.\n• None cryptography.exceptions.InvalidSignature – If the signature is invalid.\n• None cryptography.exceptions.UnsupportedAlgorithm – If signature data recovery is not supported with the provided type."
    },
    {
        "link": "https://splunk.com/en_us/blog/learn/rsa-algorithm-cryptography.html",
        "document": "Rivest Shamir Adleman (RSA) is a well-known public-key or asymmetric cryptographic algorithm. It protects sensitive data through encryption and decryption using a private and public key pair.\n\nFirst introduced in 1977 by Ron Rivest, Adi Shamir and Leonard Adleman of the Massachusetts Institute of Technology, RSA is named after their last initials.\n\nThe growing domain of computer networks required a solution to secure digital communication. RSA was initially developed in 1977 as one such solution. The primary focus of RSA was to allow data to be securely transmitted over unsecured networks, specifically to enable private communications over the Internet and other electronic systems.\n\nIn traditional cryptographic systems, secure key distribution was a challenge. It required both parties to share a secret key before sending or receiving a message. With RSA, public-key cryptography helps users to share their public key openly, while keeping their private key secret. This solved the problem of key distribution and allowed users to communicate securely without prior key sharing.\n\nThis makes RSA one of the most widely used encryption mechanisms worldwide. However, the computational complexity of RSA, it is not ideal to encrypt a huge amount of data.\n\nTo manage this goal, RSA is used to encrypt a symmetric key. The key is then used to encrypt the actual huge data. This hybrid approach utilizes both asymmetric and symmetric cryptography for efficient encryption.\n\nRSA is based on factorizing and factoring large integers. First, you must choose two large prime numbers for the key pair, which is difficult to factorize. Hence, the prime numbers must be selected randomly and with a substantial difference between them. For example, consider the two chosen prime numbers as p and q.\n\nThen, the algorithm calculates their product, denoted by n = p * q. The values of p and q should be kept secret, while n, which is used as the modulus for public and private keys, must be made public.\n\nNext, the Carmecheals’ totient function is calculated using p and q, and the integer e, whose value is used as the public exponent, is selected. Then the next step is calculating the value of d, which is used as the private exponent.\n\nHow do encryption and decryption happen in RSA?\n\nThe public key is the pair (n, e), while the private key is the pair (n, d).\n• Encryption. When encrypting a message, the sender uses the public key (n, e) of the recipient to compute the ciphertext, where the ciphertext = m^e mod n. The m indicates the plaintext message.\n• Decryption. When decrypting an RSA encrypted message, the recipient uses their private key (n, d) to compute the plaintext message, where the plaintext message = c^d mod n.\n\nRSA relies on the difficulty of factoring large prime numbers. (More on this below.) The security of RSA relies on a key's size. Although RSA is currently considered to be secure, it is vulnerable to potential future threats like Quantum computing.\n\nQuantum algorithms, for instance Shor's algorithm, can quickly factor large numbers, thus making RSA obsolete. Against traditional attacks, with large keys (2048 bit or more) RSA is secure. However, advancement in computing powers may prove to be a challenge to RSA's reliability in the future.\n\nSo, what happens if RSA is broken? The primary risk is obviously the exposure of sensitive data, like financial details or personal information. Digital signatures will no longer be trustworthy, negatively impacting financial and legal systems.\n\nTo handle this potential risk, post-quantum cryptography, like lattice-based encryption is currently being explored as a solution to ensure data security in a world where RSA is breakable.\n\nRSA is used in several information security and cryptography applications. Some of the most widely used applications include:\n\nA digital signature is a technique that lets the recipient of a message verify its authenticity, integrity and non-repudiation. It proves that the message has not been altered in transit.\n\nWhen creating digital signatures, the sender starts by generating a hash value of the message using a cryptographic hash function. Then, you sign it by applying the RSA algorithm using the private key, which generates the digital signature as the output. The recipient can then apply the RSA algorithm to the digital signature using the sender's public key.\n\nAdditionally, you can verify the signature by matching it with the hash value generated over the message.\n\nRSA is widely used in digital certificates, such as SSL certificates. These certificates can be used to verify the identity of individuals or organizations behind websites.\n\nDigital certificates utilize RSA to encrypt the digital signature of the certificate issuer, which can be verified using his public key. The digital certificate consists of information such as the domain name and the organization that operates the website, proving the identity of the website to clients.\n\nRSA encrypts communication between two parties over an insecure network like the Internet. For instance, RSA is used with Transport Layer Security (TLS) to establish secure connections between web servers and web browsers. Moreover, RSA aids secure email communication by providing a way to encrypt and decrypt messages.\n\nIt is also used in Virtual Private Networks (VPNs). VPNs utilize TLS to facilitate a handshake between two parties exchanging information. The TLS handshake depends on the RSA algorithm to authenticate the identities of both parties involved in the exchange.\n\nAnother use case of RSA is to have a secure key exchange between two parties who have not previously shared a secret key. The two parties involved generate a public-private key pair using the RSA algorithm.\n• The sender generates a symmetric key, encrypts it using the receiver’s public key, and sends the encrypted key to the receiver.\n• The receiver then decrypts it using the private key.\n\nBoth sender and receiver have the same symmetric key, which they can use for secure communication.\n\nThe RSA algorithm is difficult to crack, provided that it adheres to the recommendations. Several vulnerabilities in RSA have been discovered over the past few years. Those vulnerabilities are:\n\nA side-channel attack targets the vulnerabilities that arise when a computer system processes data — such as program execution time, power consumption, or electromagnetic radiation — rather than directly targeting the software or its code.\n\nFor instance, an attacker can reveal information from the electromagnetic radiation emitted by a computer while performing cryptographic operations.\n\nPower analysis and timing attacks are the two most common side-channel attacks on RSA encryption:\n• Power analysis attacks occur due to the computationally expensive operations of RSA, which can lead to varying power consumption.\n• Timing attacks occur when attackers measure the time a device takes to perform RSA encryption.\n\nBad actors can use this data to derive the secret key used in RSA encryption. Thus, appropriate countermeasures should be taken to prevent side-channel attacks.\n\nThe security of the RSA algorithm heavily relies on large, difficult-to-factor prime numbers used for the key generation process. Factoring the product of two large prime numbers is more difficult when the key length is higher.\n\nThe key length should be increased as computing power increases. Robust computers can factor large numbers relatively easily and with less time. Thus, they can easily crack keys with shorter lengths.\n\nOnce recommended, a 1024-bit RSA key can be cracked and is no longer valid today. Therefore, it is best practice to use a minimum key length of 2048 bits for RSA.\n\nWhen we talk about prime number weaknesses, we can break it into:\n\nThe randomness of prime numbers. The RSA algorithm depends on generating random prime numbers in the key generation process, which are then multiplied to produce the public and private keys.\n\nAssume that the organization uses a weak random number generator or an algorithm that generates easily predictable or easy-to-factor random numbers. In that case, attackers can guess the pattern used to generate the primes and factor the keys easily.\n\nThe closeness of prime numbers. In addition, the security of the RSA key can be compromised if the two prime numbers used in RSA are too close to each other in value or if one of them is too small. In such scenarios, attackers can easily determine the factors of the RSA modulus, which enables them to break the encryption and gain access to the private key.\n\nLost, stolen or compromised keys can be directly accessed by attackers, enabling them to decrypt encrypted messages using the corresponding public key. Therefore, the keys must be managed properly to avoid such vulnerabilities.\n\nFault attacks are attacks where attackers deliberately introduce faults in the hardware or software used to implement the cryptographic application. For instance, an attacker can use a laser or a bit flip to create a fault in cryptographic functions, resulting in weaker keys with more predictable values.\n\nRSA implementations can be vulnerable to fault attacks if you do not take appropriate countermeasures.\n\nThere are several things you can do to mitigate RSA vulnerabilities.\n• Use a strong prime number generator to ensure that the prime numbers are unpredictable and cannot be easily guessed by an attacker.\n• Avoid using weak prime numbers, such as small primes or primes too close to each other.\n• Use a minimum length of 2048 bits for the RSA key.\n• Take necessary actions to protect against fault-based attacks, such as using tamper-resistant hardware.\n• Manage and secure the RSA keys properly using techniques like regular key rotation and different keys for different applications.\n• Keep the RSA algorithm up to date by regularly monitoring for vulnerabilities and updates.\n\nRSA is a widely used cryptographic algorithm that was first introduced in 1977. It uses public and private key pairs to encrypt and decrypt data. Though RSA can be used in several applications, its computational complexity makes it unsuitable for encrypting large messages or files. Currently, RSA creates digital signatures and certificates for secure authentication, communication, web access and email messages and key exchanges.\n\nThere are several vulnerabilities in RSA, such as side-channel attacks, inappropriate key lengths, weaknesses in prime numbers, fault-based attacks and risks introduced by stolen or lost keys. Thus, it is important to consider the recommendations described in the article when using RSA for your cryptographic applications."
    },
    {
        "link": "https://en.wikipedia.org/wiki/RSA_(cryptosystem)",
        "document": "RSA (Rivest–Shamir–Adleman) cryptosystem is a public-key cryptosystem, one of the oldest widely used for secure data transmission. The initialism \"RSA\" comes from the surnames of Ron Rivest, Adi Shamir and Leonard Adleman, who publicly described the algorithm in 1977. An equivalent system was developed secretly in 1973 at Government Communications Headquarters (GCHQ), the British signals intelligence agency, by the English mathematician Clifford Cocks. That system was declassified in 1997.[2]\n\nIn a public-key cryptosystem, the encryption key is public and distinct from the decryption key, which is kept secret (private). An RSA user creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decrypted by someone who knows the private key.[1]\n\nThe security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the \"factoring problem\". Breaking RSA encryption is known as the RSA problem. Whether it is as difficult as the factoring problem is an open question.[3] There are no published methods to defeat the system if a large enough key is used.\n\nRSA is a relatively slow algorithm. Because of this, it is not commonly used to directly encrypt user data. More often, RSA is used to transmit shared keys for symmetric-key cryptography, which are then used for bulk encryption–decryption.\n\nThe idea of an asymmetric public-private key cryptosystem is attributed to Whitfield Diffie and Martin Hellman, who published this concept in 1976. They also introduced digital signatures and attempted to apply number theory. Their formulation used a shared-secret-key created from exponentiation of some number, modulo a prime number. However, they left open the problem of realizing a one-way function, possibly because the difficulty of factoring was not well-studied at the time.[4] Moreover, like Diffie-Hellman, RSA is based on modular exponentiation.\n\nRon Rivest, Adi Shamir, and Leonard Adleman at the Massachusetts Institute of Technology made several attempts over the course of a year to create a function that was hard to invert. Rivest and Shamir, as computer scientists, proposed many potential functions, while Adleman, as a mathematician, was responsible for finding their weaknesses. They tried many approaches, including \"knapsack-based\" and \"permutation polynomials\". For a time, they thought what they wanted to achieve was impossible due to contradictory requirements.[5] In April 1977, they spent Passover at the house of a student and drank a good deal of wine before returning to their homes at around midnight.[6] Rivest, unable to sleep, lay on the couch with a math textbook and started thinking about their one-way function. He spent the rest of the night formalizing his idea, and he had much of the paper ready by daybreak. The algorithm is now known as RSA – the initials of their surnames in same order as their paper.[7]\n\nClifford Cocks, an English mathematician working for the British intelligence agency Government Communications Headquarters (GCHQ), described a similar system in an internal document in 1973.[8] However, given the relatively expensive computers needed to implement it at the time, it was considered to be mostly a curiosity and, as far as is publicly known, was never deployed. His ideas and concepts were not revealed until 1997 due to its top-secret classification.\n\nKid-RSA (KRSA) is a simplified, insecure public-key cipher published in 1997, designed for educational purposes. Some people feel that learning Kid-RSA gives insight into RSA and other public-key ciphers, analogous to simplified DES.[9][10][11][12][13]\n\nA patent describing the RSA algorithm was granted to MIT on 20 September 1983: U.S. patent 4,405,829 \"Cryptographic communications system and method\". From DWPI's abstract of the patent:\n\nA detailed description of the algorithm was published in August 1977, in Scientific American's Mathematical Games column.[7] This preceded the patent's filing date of December 1977. Consequently, the patent had no legal standing outside the United States. Had Cocks' work been publicly known, a patent in the United States would not have been legal either.\n\nWhen the patent was issued, terms of patent were 17 years. The patent was about to expire on 21 September 2000, but RSA Security released the algorithm to the public domain on 6 September 2000.[14]\n\nThe RSA algorithm involves four steps: key generation, key distribution, encryption, and decryption.\n\nA basic principle behind RSA is the observation that it is practical to find three very large positive integers e, d, and n, such that for all integers m (0 ≤ m < n), both and have the same remainder when divided by (they are congruent modulo ): However, when given only e and n, it is extremely difficult to find d.\n\nThe integers n and e comprise the public key, d represents the private key, and m represents the message. The modular exponentiation to e and d corresponds to encryption and decryption, respectively.\n\nIn addition, because the two exponents can be swapped, the private and public key can also be swapped, allowing for message signing and verification using the same algorithm.\n\nThe keys for the RSA algorithm are generated in the following way:\n• Choose two large prime numbers and .\n• To make factoring harder, and should be chosen at random, be both large and have a large difference. 1 For choosing them the standard method is to choose random integers and use a primality test until two primes are found.\n• and are kept secret.\n• Compute .\n• is used as the modulus for both the public and private keys. Its length, usually expressed in bits, is the key length.\n• is released as part of the public key.\n• Compute , where is Carmichael's totient function. Since , and since and are prime, , and likewise . Hence .\n• The may be calculated through the Euclidean algorithm, since .\n• Choose an integer such that and ; that is, and are coprime.\n• having a short bit-length and small Hamming weight results in more efficient encryption – the most commonly chosen value for is . The smallest (and fastest) possible value for is 3, but such a small value for has been shown to be less secure in some settings. 15\n• is released as part of the public key.\n• Determine as ; that is, is the modular multiplicative inverse of modulo .\n• This means: solve for the equation ; can be computed efficiently by using the extended Euclidean algorithm, since, thanks to and being coprime, said equation is a form of Bézout's identity, where is one of the coefficients.\n• is kept secret as the private key exponent.\n\nThe public key consists of the modulus n and the public (or encryption) exponent e. The private key consists of the private (or decryption) exponent d, which must be kept secret. p, q, and λ(n) must also be kept secret because they can be used to calculate d. In fact, they can all be discarded after d has been computed.[16]\n\nIn the original RSA paper,[1] the Euler totient function φ(n) = (p − 1)(q − 1) is used instead of λ(n) for calculating the private exponent d. Since φ(n) is always divisible by λ(n), the algorithm works as well. The possibility of using Euler totient function results also from Lagrange's theorem applied to the multiplicative group of integers modulo pq. Thus any d satisfying d⋅e ≡ 1 (mod φ(n)) also satisfies d⋅e ≡ 1 (mod λ(n)). However, computing d modulo φ(n) will sometimes yield a result that is larger than necessary (i.e. d > λ(n)). Most of the implementations of RSA will accept exponents generated using either method (if they use the private exponent d at all, rather than using the optimized decryption method based on the Chinese remainder theorem described below), but some standards such as FIPS 186-4 (Section B.3.1) may require that d < λ(n). Any \"oversized\" private exponents not meeting this criterion may always be reduced modulo λ(n) to obtain a smaller equivalent exponent.\n\nSince any common factors of (p − 1) and (q − 1) are present in the factorisation of n − 1 = pq − 1 = (p − 1)(q − 1) + (p − 1) + (q − 1),[17][self-published source?] it is recommended that (p − 1) and (q − 1) have only very small common factors, if any, besides the necessary 2.[1][18][19][failed verification][20][failed verification]\n\nNote: The authors of the original RSA paper carry out the key generation by choosing d and then computing e as the modular multiplicative inverse of d modulo φ(n), whereas most current implementations of RSA, such as those following PKCS#1, do the reverse (choose e and compute d). Since the chosen key can be small, whereas the computed key normally is not, the RSA paper's algorithm optimizes decryption compared to encryption, while the modern algorithm optimizes encryption instead.[1][21]\n\nSuppose that Bob wants to send information to Alice. If they decide to use RSA, Bob must know Alice's public key to encrypt the message, and Alice must use her private key to decrypt the message.\n\nTo enable Bob to send his encrypted messages, Alice transmits her public key (n, e) to Bob via a reliable, but not necessarily secret, route. Alice's private key (d) is never distributed.\n\nAfter Bob obtains Alice's public key, he can send a message M to Alice.\n\nTo do it, he first turns M (strictly speaking, the un-padded plaintext) into an integer m (strictly speaking, the padded plaintext), such that 0 ≤ m < n by using an agreed-upon reversible protocol known as a padding scheme. He then computes the ciphertext c, using Alice's public key e, corresponding to\n\nThis can be done reasonably quickly, even for very large numbers, using modular exponentiation. Bob then transmits c to Alice. Note that at least nine values of m will yield a ciphertext c equal to m,[a] but this is very unlikely to occur in practice.\n\nAlice can recover m from c by using her private key exponent d by computing\n\nGiven m, she can recover the original message M by reversing the padding scheme.\n\nHere is an example of RSA encryption and decryption:[b]\n• Choose two distinct prime numbers, such as\n• Compute the Carmichael's totient function of the product as giving\n• Choose any number that is coprime to 780. Choosing a prime number for leaves us only to check that is not a divisor of 780.\n• Compute , the modular multiplicative inverse of , yielding\n\n as\n\nThe public key is (n = 3233, e = 17). For a padded plaintext message m, the encryption function is\n\nThe private key is (n = 3233, d = 413). For an encrypted ciphertext c, the decryption function is\n\nFor instance, in order to encrypt m = 65, one calculates\n\nTo decrypt c = 2790, one calculates\n\nBoth of these calculations can be computed efficiently using the square-and-multiply algorithm for modular exponentiation. In real-life situations the primes selected would be much larger; in our example it would be trivial to factor n = 3233 (obtained from the freely available public key) back to the primes p and q. e, also from the public key, is then inverted to get d, thus acquiring the private key.\n\nPractical implementations use the Chinese remainder theorem to speed up the calculation using modulus of factors (mod pq using mod p and mod q).\n\nThe values d , d and q , which are part of the private key are computed as follows:\n\nHere is how d , d and q are used for efficient decryption (encryption is efficient by choice of a suitable d and e pair):\n\nSuppose Alice uses Bob's public key to send him an encrypted message. In the message, she can claim to be Alice, but Bob has no way of verifying that the message was from Alice, since anyone can use Bob's public key to send him encrypted messages. In order to verify the origin of a message, RSA can also be used to sign a message.\n\nSuppose Alice wishes to send a signed message to Bob. She can use her own private key to do so. She produces a hash value of the message, raises it to the power of d (modulo n) (as she does when decrypting a message), and attaches it as a \"signature\" to the message. When Bob receives the signed message, he uses the same hash algorithm in conjunction with Alice's public key. He raises the signature to the power of e (modulo n) (as he does when encrypting a message), and compares the resulting hash value with the message's hash value. If the two agree, he knows that the author of the message was in possession of Alice's private key and that the message has not been tampered with since being sent.\n\nThis works because of exponentiation rules:\n\nThus the keys may be swapped without loss of generality, that is, a private key of a key pair may be used either to:\n• Decrypt a message only intended for the recipient, which may be encrypted by anyone having the public key (asymmetric encrypted transport).\n• Encrypt a message which may be decrypted by anyone, but which can only be encrypted by one person; this provides a digital signature.\n\nThe proof of the correctness of RSA is based on Fermat's little theorem, stating that ap − 1 ≡ 1 (mod p) for any integer a and prime p, not dividing a.[note 1]\n\nWe want to show that for every integer m when p and q are distinct prime numbers and e and d are positive integers satisfying ed ≡ 1 (mod λ(pq)).\n\nSince λ(pq) = lcm(p − 1, q − 1) is, by construction, divisible by both p − 1 and q − 1, we can write for some nonnegative integers h and k.[note 2]\n\nTo check whether two numbers, such as med and m, are congruent mod pq, it suffices (and in fact is equivalent) to check that they are congruent mod p and mod q separately.[note 3]\n\nTo show med ≡ m (mod p), we consider two cases:\n• If , is a multiple of . Thus med is a multiple of . So .\n• If , where we used Fermat's little theorem to replace with 1.\n\nThe verification that med ≡ m (mod q) proceeds in a completely analogous way:\n• If , med is a multiple of . So .\n\nThis completes the proof that, for any integer m, and integers e, d such that ed ≡ 1 (mod λ(pq)),\n\nAlthough the original paper of Rivest, Shamir, and Adleman used Fermat's little theorem to explain why RSA works, it is common to find proofs that rely instead on Euler's theorem.\n\nWe want to show that med ≡ m (mod n), where n = pq is a product of two different prime numbers, and e and d are positive integers satisfying ed ≡ 1 (mod φ(n)). Since e and d are positive, we can write ed = 1 + hφ(n) for some non-negative integer h. Assuming that m is relatively prime to n, we have\n\nwhere the second-last congruence follows from Euler's theorem.\n\nMore generally, for any e and d satisfying ed ≡ 1 (mod λ(n)), the same conclusion follows from Carmichael's generalization of Euler's theorem, which states that mλ(n) ≡ 1 (mod n) for all m relatively prime to n.\n\nWhen m is not relatively prime to n, the argument just given is invalid. This is highly improbable (only a proportion of 1/p + 1/q − 1/(pq) numbers have this property), but even in this case, the desired congruence is still true. Either m ≡ 0 (mod p) or m ≡ 0 (mod q), and these cases can be treated using the previous proof.\n\nThere are a number of attacks against plain RSA as described below.\n• When encrypting with low encryption exponents (e.g., ) and small values of the (i.e., ), the result of is strictly less than the modulus . In this case, ciphertexts can be decrypted easily by taking the th root of the ciphertext over the integers.\n• If the same clear-text message is sent to or more recipients in an encrypted way, and the receivers share the same exponent , but different , , and therefore , then it is easy to decrypt the original clear-text message via the Chinese remainder theorem. Johan Håstad noticed that this attack is possible even if the clear texts are not equal, but the attacker knows a linear relation between them. 22 This attack was later improved by Don Coppersmith (see Coppersmith's attack). 23\n• Because RSA encryption is a deterministic encryption algorithm (i.e., has no random component) an attacker can successfully launch a chosen plaintext attack against the cryptosystem, by encrypting likely plaintexts under the public key and test whether they are equal to the ciphertext. A cryptosystem is called semantically secure if an attacker cannot distinguish two encryptions from each other, even if the attacker knows (or has chosen) the corresponding plaintexts. RSA without padding is not semantically secure. 24\n• RSA has the property that the product of two ciphertexts is equal to the encryption of the product of the respective plaintexts. That is, . Because of this multiplicative property, a chosen-ciphertext attack is possible. E.g., an attacker who wants to know the decryption of a ciphertext may ask the holder of the private key to decrypt an unsuspicious-looking ciphertext for some value chosen by the attacker. Because of the multiplicative property, ' is the encryption of . Hence, if the attacker is successful with the attack, they will learn from which they can derive the message by multiplying with the modular inverse of modulo .[ ]\n• Given the private exponent , one can efficiently factor the modulus . And given factorization of the modulus , one can obtain any private key ( ', ) generated against a public key ( ', ). 15\n\nTo avoid these problems, practical RSA implementations typically embed some form of structured, randomized padding into the value m before encrypting it. This padding ensures that m does not fall into the range of insecure plaintexts, and that a given message, once padded, will encrypt to one of a large number of different possible ciphertexts.\n\nStandards such as PKCS#1 have been carefully designed to securely pad messages prior to RSA encryption. Because these schemes pad the plaintext m with some number of additional bits, the size of the un-padded message M must be somewhat smaller. RSA padding schemes must be carefully designed so as to prevent sophisticated attacks that may be facilitated by a predictable message structure. Early versions of the PKCS#1 standard (up to version 1.5) used a construction that appears to make RSA semantically secure. However, at Crypto 1998, Bleichenbacher showed that this version is vulnerable to a practical adaptive chosen-ciphertext attack. Furthermore, at Eurocrypt 2000, Coron et al.[25] showed that for some types of messages, this padding does not provide a high enough level of security. Later versions of the standard include Optimal Asymmetric Encryption Padding (OAEP), which prevents these attacks. As such, OAEP should be used in any new application, and PKCS#1 v1.5 padding should be replaced wherever possible. The PKCS#1 standard also incorporates processing schemes designed to provide additional security for RSA signatures, e.g. the Probabilistic Signature Scheme for RSA (RSA-PSS).\n\nSecure padding schemes such as RSA-PSS are as essential for the security of message signing as they are for message encryption. Two USA patents on PSS were granted (U.S. patent 6,266,771 and U.S. patent 7,036,014); however, these patents expired on 24 July 2009 and 25 April 2010 respectively. Use of PSS no longer seems to be encumbered by patents.[original research?] Note that using different RSA key pairs for encryption and signing is potentially more secure.[26]\n\nFor efficiency, many popular crypto libraries (such as OpenSSL, Java and .NET) use for decryption and signing the following optimization based on the Chinese remainder theorem.[27][citation needed] The following values are precomputed and stored as part of the private key:\n• and – the primes from the key generation,\n\nThese values allow the recipient to compute the exponentiation m = cd (mod pq) more efficiently as follows: \n\n , \n\n , \n\n ,[c] \n\n .\n\nThis is more efficient than computing exponentiation by squaring, even though two modular exponentiations have to be computed. The reason is that these two modular exponentiations both use a smaller exponent and a smaller modulus.\n\nThe security of the RSA cryptosystem is based on two mathematical problems: the problem of factoring large numbers and the RSA problem. Full decryption of an RSA ciphertext is thought to be infeasible on the assumption that both of these problems are hard, i.e., no efficient algorithm exists for solving them. Providing security against partial decryption may require the addition of a secure padding scheme.[28]\n\nThe RSA problem is defined as the task of taking eth roots modulo a composite n: recovering a value m such that c ≡ me (mod n), where (n, e) is an RSA public key, and c is an RSA ciphertext. Currently the most promising approach to solving the RSA problem is to factor the modulus n. With the ability to recover prime factors, an attacker can compute the secret exponent d from a public key (n, e), then decrypt c using the standard procedure. To accomplish this, an attacker factors n into p and q, and computes lcm(p − 1, q − 1) that allows the determination of d from e. No polynomial-time method for factoring large integers on a classical computer has yet been found, but it has not been proven that none exists; see integer factorization for a discussion of this problem.\n\nThe first RSA-512 factorization in 1999 used hundreds of computers and required the equivalent of 8,400 MIPS years, over an elapsed time of about seven months.[29] By 2009, Benjamin Moody could factor an 512-bit RSA key in 73 days using only public software (GGNFS) and his desktop computer (a dual-core Athlon64 with a 1,900 MHz CPU). Just less than 5 gigabytes of disk storage was required and about 2.5 gigabytes of RAM for the sieving process.\n\nRivest, Shamir, and Adleman noted[1] that Miller has shown that – assuming the truth of the extended Riemann hypothesis – finding d from n and e is as hard as factoring n into p and q (up to a polynomial time difference).[30] However, Rivest, Shamir, and Adleman noted, in section IX/D of their paper, that they had not found a proof that inverting RSA is as hard as factoring.\n\nAs of 2020 , the largest publicly known factored RSA number had 829 bits (250 decimal digits, RSA-250).[31] Its factorization, by a state-of-the-art distributed implementation, took about 2,700 CPU-years. In practice, RSA keys are typically 1024 to 4096 bits long. In 2003, RSA Security estimated that 1024-bit keys were likely to become crackable by 2010.[32] As of 2020, it is not known whether such keys can be cracked, but minimum recommendations have moved to at least 2048 bits.[33] It is generally presumed that RSA is secure if n is sufficiently large, outside of quantum computing.\n\nIf n is 300 bits or shorter, it can be factored in a few hours on a personal computer, using software already freely available. Keys of 512 bits have been shown to be practically breakable in 1999, when RSA-155 was factored by using several hundred computers, and these are now factored in a few weeks using common hardware. Exploits using 512-bit code-signing certificates that may have been factored were reported in 2011.[34] A theoretical hardware device named TWIRL, described by Shamir and Tromer in 2003, called into question the security of 1024-bit keys.[32]\n\nIn 1994, Peter Shor showed that a quantum computer – if one could ever be practically created for the purpose – would be able to factor in polynomial time, breaking RSA; see Shor's algorithm.\n\nFinding the large primes p and q is usually done by testing random numbers of the correct size with probabilistic primality tests that quickly eliminate virtually all of the nonprimes.\n\nThe numbers p and q should not be \"too close\", lest the Fermat factorization for n be successful. If p − q is less than 2n1/4 (n = p⋅q, which even for \"small\" 1024-bit values of n is 3×1077), solving for p and q is trivial. Furthermore, if either p − 1 or q − 1 has only small prime factors, n can be factored quickly by Pollard's p − 1 algorithm, and hence such values of p or q should be discarded.\n\nIt is important that the private exponent d be large enough. Michael J. Wiener showed that if p is between q and 2q (which is quite typical) and d < n1/4/3, then d can be computed efficiently from n and e.[35]\n\nThere is no known attack against small public exponents such as e = 3, provided that the proper padding is used. Coppersmith's attack has many applications in attacking RSA specifically if the public exponent e is small and if the encrypted message is short and not padded. 65537 is a commonly used value for e; this value can be regarded as a compromise between avoiding potential small-exponent attacks and still allowing efficient encryptions (or signature verification). The NIST Special Publication on Computer Security (SP 800-78 Rev. 1 of August 2007) does not allow public exponents e smaller than 65537, but does not state a reason for this restriction.\n\nIn October 2017, a team of researchers from Masaryk University announced the ROCA vulnerability, which affects RSA keys generated by an algorithm embodied in a library from Infineon known as RSALib. A large number of smart cards and trusted platform modules (TPM) were shown to be affected. Vulnerable RSA keys are easily identified using a test program the team released.[36]\n\nA cryptographically strong random number generator, which has been properly seeded with adequate entropy, must be used to generate the primes p and q. An analysis comparing millions of public keys gathered from the Internet was carried out in early 2012 by Arjen K. Lenstra, James P. Hughes, Maxime Augier, Joppe W. Bos, Thorsten Kleinjung and Christophe Wachter. They were able to factor 0.2% of the keys using only Euclid's algorithm.[37][38][self-published source?]\n\nThey exploited a weakness unique to cryptosystems based on integer factorization. If n = pq is one public key, and n′ = p′q′ is another, then if by chance p = p′ (but q is not equal to q'), then a simple computation of gcd(n, n′) = p factors both n and n', totally compromising both keys. Lenstra et al. note that this problem can be minimized by using a strong random seed of bit length twice the intended security level, or by employing a deterministic function to choose q given p, instead of choosing p and q independently.\n\nNadia Heninger was part of a group that did a similar experiment. They used an idea of Daniel J. Bernstein to compute the GCD of each RSA key n against the product of all the other keys n' they had found (a 729-million-digit number), instead of computing each gcd(n, n′) separately, thereby achieving a very significant speedup, since after one large division, the GCD problem is of normal size.\n\nHeninger says in her blog that the bad keys occurred almost entirely in embedded applications, including \"firewalls, routers, VPN devices, remote server administration devices, printers, projectors, and VOIP phones\" from more than 30 manufacturers. Heninger explains that the one-shared-prime problem uncovered by the two groups results from situations where the pseudorandom number generator is poorly seeded initially, and then is reseeded between the generation of the first and second primes. Using seeds of sufficiently high entropy obtained from key stroke timings or electronic diode noise or atmospheric noise from a radio receiver tuned between stations should solve the problem.[39]\n\nStrong random number generation is important throughout every phase of public-key cryptography. For instance, if a weak generator is used for the symmetric keys that are being distributed by RSA, then an eavesdropper could bypass RSA and guess the symmetric keys directly.\n\nKocher described a new attack on RSA in 1995: if the attacker Eve knows Alice's hardware in sufficient detail and is able to measure the decryption times for several known ciphertexts, Eve can deduce the decryption key d quickly. This attack can also be applied against the RSA signature scheme. In 2003, Boneh and Brumley demonstrated a more practical attack capable of recovering RSA factorizations over a network connection (e.g., from a Secure Sockets Layer (SSL)-enabled webserver).[40] This attack takes advantage of information leaked by the Chinese remainder theorem optimization used by many RSA implementations.\n\nOne way to thwart these attacks is to ensure that the decryption operation takes a constant amount of time for every ciphertext. However, this approach can significantly reduce performance. Instead, most RSA implementations use an alternate technique known as cryptographic blinding. RSA blinding makes use of the multiplicative property of RSA. Instead of computing cd (mod n), Alice first chooses a secret random value r and computes (rec)d (mod n). The result of this computation, after applying Euler's theorem, is rcd (mod n), and so the effect of r can be removed by multiplying by its inverse. A new value of r is chosen for each ciphertext. With blinding applied, the decryption time is no longer correlated to the value of the input ciphertext, and so the timing attack fails.\n\nIn 1998, Daniel Bleichenbacher described the first practical adaptive chosen-ciphertext attack against RSA-encrypted messages using the PKCS #1 v1 padding scheme (a padding scheme randomizes and adds structure to an RSA-encrypted message, so it is possible to determine whether a decrypted message is valid). Due to flaws with the PKCS #1 scheme, Bleichenbacher was able to mount a practical attack against RSA implementations of the Secure Sockets Layer protocol and to recover session keys. As a result of this work, cryptographers now recommend the use of provably secure padding schemes such as Optimal Asymmetric Encryption Padding, and RSA Laboratories has released new versions of PKCS #1 that are not vulnerable to these attacks.\n\nA variant of this attack, dubbed \"BERserk\", came back in 2014.[41][42] It impacted the Mozilla NSS Crypto Library, which was used notably by Firefox and Chrome.\n\nA side-channel attack using branch-prediction analysis (BPA) has been described. Many processors use a branch predictor to determine whether a conditional branch in the instruction flow of a program is likely to be taken or not. Often these processors also implement simultaneous multithreading (SMT). Branch-prediction analysis attacks use a spy process to discover (statistically) the private key when processed with these processors.\n\nSimple Branch Prediction Analysis (SBPA) claims to improve BPA in a non-statistical way. In their paper, \"On the Power of Simple Branch Prediction Analysis\",[43] the authors of SBPA (Onur Aciicmez and Cetin Kaya Koc) claim to have discovered 508 out of 512 bits of an RSA key in 10 iterations.\n\nA power-fault attack on RSA implementations was described in 2010.[44] The author recovered the key by varying the CPU power voltage outside limits; this caused multiple power faults on the server.\n\nThere are many details to keep in mind in order to implement RSA securely (strong PRNG, acceptable public exponent, etc.). This makes the implementation challenging, to the point the book Practical Cryptography With Go suggests avoiding RSA if possible.[45]\n\nSome cryptography libraries that provide support for RSA include:\n• The Original RSA Patent as filed with the U.S. Patent Office by Rivest; Ronald L. (Belmont, MA), Shamir; Adi (Cambridge, MA), Adleman; Leonard M. (Arlington, MA), December 14, 1977, .\n• Thorough walk through of RSA\n• Onur Aciicmez, Cetin Kaya Koc, Jean-Pierre Seifert: On the Power of Simple Branch Prediction Analysis"
    },
    {
        "link": "https://encryptionconsulting.com/education-center/what-is-rsa",
        "document": "Enhance the security of your HSMs backed by the right expertise"
    },
    {
        "link": "https://github.com/nakov/Practical-Cryptography-for-Developers-Book/blob/master/asymmetric-key-ciphers/rsa-encrypt-decrypt-examples.md",
        "document": "Now let's demonstrate how the RSA algorithms works by a simple example in Python. The below code will generate random RSA key-pair, will encrypt a short message and will decrypt it back to its original form, using the RSA-OAEP padding scheme.\n\nFirst, install the package, which is a powerful Python library of low-level cryptographic primitives (hashes, MAC codes, key-derivation, symmetric and asymmetric ciphers, digital signatures):\n\nNow, let's write the Python code. First, generate the RSA keys (1024-bit) and print them on the console (as hex numbers and in the PKCS#8 PEM ASN.1 format):\n\nRun the above code example: https://repl.it/@nakov/RSA-Key-Generation-in-Python.\n\nWe use short key length to keep the sample input short, but in a real world scenario it is recommended to use 3072-bit or 4096-bit keys.\n\nNext, encrypt the message using RSA-OAEP encryption scheme (RSA with PKCS#1 OAEP padding) with the RSA public key:\n\nRun the above code example: https://repl.it/@nakov/RSA-encryption-in-Python.\n\nRun the above code example: https://repl.it/@nakov/RSA-decryption-in-Python.\n\nA sample output of the code execution for the entire example is given below:\n• If you run the above example, your output will be different, because it generates different random RSA key-pair at each execution.\n• Even if you encrypt the same message several times with the same public key, you will get different output. This is because the OAEP padding algorithm injects some randomness with the padding.\n• If you try to encrypt larger messages, you will get and exception, because the 1024-bit key limits the maximum message length.\n\nNow play with the above code, modify it and run it to learn how RSA works in action."
    },
    {
        "link": "https://geeksforgeeks.org/rsa-algorithm-cryptography",
        "document": "RSA(Rivest-Shamir-Adleman) Algorithm is an asymmetric or public-key cryptography algorithm which means it works on two different keys: Public Key and Private Key. The Public Key is used for encryption and is known to everyone, while the Private Key is used for decryption and must be kept secret by the receiver. RSA Algorithm is named after Ron Rivest, Adi Shamir and Leonard Adleman, who published the algorithm in 1977.\n\nIf Person A wants to send a message securely to Person B:\n• decrypts the message using their Private\n• p q . These prime numbers should be kept secret.\n• n = p * q . This product is part of the public as well as the private key.\n• e\n• None gcd(e, Φ(n)) = 1, that is e should be co-prime with Φ(n).\n• d,\n• (d * e) ≡ 1 mod Φ(n) , that is d is e mod Φ(n). Some common methods to calculate multiplicative inverse are:\n• None We can have multiple values of d satisfying (d * e) ≡ 1 mod Φ(n) but it does not matter which value we choose as all of them are valid keys and will result into same message on decryption.\n\nFinally, the Public Key = (n, e) and the Private Key = (n, d).\n\nTo encrypt a message M, it is first converted to numerical representation using ASCII and other encoding schemes. Now, use the public key (n, e) to encrypt the message and get the cipher text using the formula:\n\nTo decrypt the cipher text C, use the private key (n, d) and get the original data using the formula:\n\nThe idea of RSA is based on the fact that it is difficult to factorize a large integer. The Public Key is (n, e), where n and e are publicly known, while the Private Key is (n, d). Since only the receiver knows the value of d, only they can decrypt the message. But is it possible to find the value of d using n and e?\n\nWe know that (d * e) ≡ 1 mod Φ(n), so if we can calculate the value of Φ(n), we can find the value of d. But Φ(n) = (p – 1) * (q – 1). So, we need the value of p and q. Now, one might think that it’s quite easy to find the value of p and q as n = p * q and n is already publicly known but RSA Algorithm takes the value of p and q to be very large which in turn makes the value of n extremely large and factorizing such a large value is computationally impossible.\n\nTherefore encryption strength lies in the values of p and q. RSA keys can be typically 1024 or 2048 bits long, but experts believe that 1024-bit keys could be broken shortly. But till now it seems to be an infeasible task.\n\nNote: If someone gets to know the value of p and q, then he can calculate the value of d and decrypt the message.\n\n// C++ Program for implementation of RSA Algorithm // Here we are calculating phi(n) using Hit and Trial Method // but we can optimize it using Extended Euclidean Algorithm # Here we are calculating phi(n) using Hit and Trial Method # but we can optimize it using Extended Euclidean Algorithm\n• Security: RSA algorithm is considered to be very secure and is widely used for secure data transmission.\n• Public-key cryptography: RSA algorithm is a public-key cryptography algorithm, which means that it uses two different keys for encryption and decryption. The public key is used to encrypt the data, while the private key is used to decrypt the data.\n• Key exchange: RSA algorithm can be used for secure key exchange, which means that two parties can exchange a secret key without actually sending the key over the network.\n• Digital signatures: RSA algorithm can be used for digital signatures, which means that a sender can sign a message using their private key, and the receiver can verify the signature using the sender’s public key.\n• Widely used: Online banking, e-commerce, and secure communications are just a few fields and applications where the RSA algorithm is extensively developed.\n• Slow processing speed: RSA algorithm is slower than other encryption algorithms, especially when dealing with large amounts of data.\n• Large key size: RSA algorithm requires large key sizes to be secure, which means that it requires more computational resources and storage space.\n• Vulnerability to side-channel attacks: RSA algorithm is vulnerable to side-channel attacks, which means an attacker can use information leaked through side channels such as power consumption, electromagnetic radiation, and timing analysis to extract the private key.\n• Limited use in some applications: RSA algorithm is not suitable for some applications, such as those that require constant encryption and decryption of large amounts of data, due to its slow processing speed.\n• Complexity: The RSA algorithm is a sophisticated mathematical technique that some individuals may find challenging to comprehend and use.\n• Key Management: The secure administration of the private key is necessary for the RSA algorithm, although in some cases this can be difficult.\n• Vulnerability to Quantum Computing: Quantum computers have the ability to attack the RSA algorithm, potentially decrypting the data.\n\nWhat is the RSA algorithm, and how does it work?\n\nWhat are the key components of the RSA algorithm?\n\nWhat are the primary applications of RSA?\n\nHow can I ensure the security of RSA encryption?"
    },
    {
        "link": "https://medium.com/coinmonks/rsa-encryption-and-decryption-with-pythons-pycryptodome-library-94f28a6a1816",
        "document": "This article explains how to encrypt and decrypt messages using RSA public key cryptography in Python, using the library for the implementation.\n\nRSA allows secure transmission of data using a key pair of public and private keys. I consider a grasp of RSA isn’t only crucial for data security but also provides insights into the principles of cryptography.\n\nRSA is a public-key cryptography algorithm developed 1970’s by Ron Rivest, Adi Shamir, and Leonard Adleman at MIT. RSA was publicly described in 1977 and the algorithm patented. The patent expired in 2000 allowing free public use.\n\nRSA is an asymmetric cryptography algorithm which enables secure data transmission using a public and private key pair. RSA was initially slow compared to symmetric ciphers but improved over time.\n• Authentication: Used in smart cards for secure user authentication.\n\nFirst, we set up a Python environment with the necessary library for cryptographic operations and use the “pycryptodome” library built upon the now-deprecated “PyCrypto.”\n\nThe pycryptodome library serves as a comprehensive Python package of low-level cryptographic primitives. To install it, run the following commands.\n\nAfter setting up your Python environment, generate an RSA key pair. In this example, we’ll use a 1024-bit key.\n\nIn this example, we’ll encrypt the message “Hello, this is a message to be encrypted.”\n\nEncrypted: b’3278c4093d20026311c0d3e70305b004ffec84b5d6636b2a4991e196f0065c946083d15f1c304f37b48c8b0ea7fe56fe3327150af555e8e903a13c7c797545d9ddd358c2d581f9070a98ad5bd8a4a6a725103346b53ba927f74e6730a62c38a4cb566f04c428a30a82d983f55358b4e201db9ce78741bf2de0d575e5ba248fc8'\n\nDecrypted: Hello, this is a message to be encrypted.\n\n# Step 1: Install pycryptodome package\n\n!pip install pycryptodome\n\n\n\n# Import necessary modules from pycryptodome\n\nfrom Crypto.PublicKey import RSA\n\nfrom Crypto.Cipher import PKCS1_OAEP\n\n\n\n# This module converts binary data to hexadecimal\n\nfrom binascii import hexlify\n\n\n\n\n\n# Step 2: Generate new RSA key\n\n# Create an RSA key pair with a key size of 1024 bits\n\nkey = RSA.generate(1024)\n\n\n\n# Set the private_key variable to the generated key\n\nprivate_key = key\n\n\n\n# Derive the public key from the generated key\n\npublic_key = key.publickey()\n\n\n\n\n\n# Step 3: Encrypt using public key\n\n# Create a PKCS1_OAEP cipher object with the public key for encryption\n\ndata_to_encrypt = b\"Hello, this is a message to be encrypted.\"\n\ncipher_rsa = PKCS1_OAEP.new(public_key)\n\n\n\n# Encrypt the provided data using the public key\n\nencrypted = cipher_rsa.encrypt(data_to_encrypt)\n\n\n\n# Convert binary data to hexadecimal for display using hexlify\n\nprint(\"Encrypted:\", hexlify(encrypted))\n\n\n\n\n\n# Step 4: Decrypt using private key\n\n# Create a PKCS1_OAEP cipher object with the private key for decryption\n\ncipher_rsa = PKCS1_OAEP.new(private_key)\n\ndecrypted = cipher_rsa.decrypt(encrypted)\n\n\n\n# Display the decrypted result as a UTF-8 encoded string\n\nprint(\"Decrypted:\", decrypted.decode(\"utf-8\"))\n\nUtilizing Python’s “pycryptodome” library provides practical insights into the inner workings of cryptographic algorithms. Yet, it’s vital to always handle private keys with care to ensure the security of your encrypted data.\n\nHope you enjoyed the enigmatic voyage into the cryptography. 🚢\n• Why Smart Contracts Needs the Real World Data — Oracle Solutions"
    },
    {
        "link": "https://onboardbase.com/blog/rsa-encryption-decryption",
        "document": "At Onboardbase, we combine TLS (HTTPS) with RSA as an extra layer of security to prevent person-in–the-middle attacks. 80% of websites use HTTPS, according to W3Tech. But what if you need to send information over a non-secure network? How do you prevent network administrators or hackers from reading your HTTP or email traffic and retrieving sensitive data? RSA encryption & decryption is one way to go about it.\n\nIn this article, you’ll find a practical guide on RSA encryption you can use in your project using Python―purposes, libraries, best practices, and pitfalls to watch out for.\n\nRSA (Rivest–Shamir–Adleman) is an encryption algorithm used to securely transmit data over a communication channel.\n\nSay you want to create an instant messaging app for example. Privacy is a key requirement―you don’t want anybody to be able to monitor HTTP requests and find out what’s being said. RSA will allow the receiver and the sender to communicate without having to fear leaking secrets, no matter the channel being used―be it a public Wi-fi network or your friend’s 3G hotspot.\n\nRSA presents several benefits as an encryption method.\n\nFirst, you cannot build reliable software solutions without proper data encryption. RSA is key to guaranteeing the security of your users, and understanding basic algorithms like RSA encryption helps prevent data breaches: 47% of data breaches are caused by negligence, and 37% of engineers have experienced a breach in their career!\n\nRSA is an asymmetric encryption method, meaning it uses a public key for encryption and a private key for decryption: anyone can send encrypted messages but only the receiver will be able to decrypt them. The TLS protocol used to enable HTTPS websites makes use of similar asymmetric encryption methods, for example. This separation is a great thing because symmetric algorithms like AES rely on a single private key, making them harder to secure since you need to share the secret key to allow someone else to send you an encrypted message.\n\nRSA encryption is slower to compute than AES and is limited to a few bytes of data, but it can be used to securely transmit short secrets, keys, and credentials. More importantly, RSA is a simple way to implement Forward Secrecy, as you will later read in this article. With forward secrecy, you create temporary encryption keys to minimize the impact of a security breach: even if an encryption key gets leaked, only a tiny portion of the system will be compromised―making your website much less attractive to potential attackers.\n\nHow To Use RSA In Python\n\nAn RSA encryption system can be broken down into 3 parts:\n• Key storage & retrieval - storing and retrieving the key pairs in a secure vault\n• Encryption/decryption - transmitting encrypted data over a network and decrypting it\n\nIn this article, you are going to use PKCS1 OAEP, a modern RSA implementation. Let’s dive into each step in detail.\n\nFirst, we create a public encryption key and a private decryption key. Just like regular passwords, these keys need to be strong, meaning it won’t be realistically possible to brute force them with a software program in a reasonable amount of time. To achieve this, keys are randomly generated using methods provided by approved cryptography libraries, like pycryptodome in Python.\n\nAnd the longer the keys, the harder they will be to break. For RSA, you want your keys to be at least 1024 bits in length:\n\nAn RSA public key will look like this:\n\nWhile an RSA private key will be similar to that:\n\nRSA keys are multi-line strings of characters, usually stored in .pem files. But the simplest and most computationally efficient way to store a key is to serialize it and store it in an environment variable in your program, using a .env file for example:\n\n.env variables can be referenced in your Python program using the native os library:\n\nBut as we previously mentioned, protecting the keys as best as possible is vital since leaking them would allow attackers to break the encryptions. While having your key in a .env file appears as a quick fix to the storage problem, using a secret manager like Onboardbase is much more secure. With Onboardbase, you can inject RSA keys in software programs as environment variables in your CI/CD process in just 3 commands, removing the need to directly share keys or hardcode them in files or environment variables.\n\nAfter defining your key in your account dashboard―it’s super easy to define multi-line environment variables―you can use Onboardbase CLI’s setup command to leverage its features in your own project in a few seconds:\n\nThe command generates an onboardbase.yml file used to access the online vault:\n\nAll you have left to do is to run the build command to integrate RSA keys from Onboardbase at runtime:\n\nIf you need the public key to be accessible worldwide, storing it in a .pem file and exposing it on your web server is still the best way to fetch it from client programs:\n\nRSA only requires the public key to encrypt a short message:\n\nThe result, known as ciphertext, can then be transmitted over any type of channel without risking any information leak.\n\nFor the inverse operation, you’ll need to use your private key:\n\nThen run the following command to inject your RSA private key at runtime from Onboardbase:\n\nNow, the big problem with RSA is you can’t use it to encrypt messages longer than its key size: if your RSA key is 1024 bits long, your messages won’t exceed 1024 bits.\n\nBut RSA is perfect to encrypt short app secrets, keys, and credentials. This is what you can leverage in hybrid encryption systems balancing the strengths of both symmetric and asymmetric encryption methods to implement Forward Secrecy. Forward Secrecy (FS) is a security best practice consisting in automatically changing the keys used to encrypt data. Each temporary key (aka session key) encrypts a single message. This way, even if the key is leaked, it won’t compromise the whole system.\n\nIn the following code snippet, we use RSA to encrypt and send a randomized session key. AES-256 then uses the session key to encrypt any sort of message. The ciphertext and the encrypted session key are then sent to the receiver, and the receiver just decrypts the key and the message:\n\nThanks to this system, the AES key will never be transmitted in plain view and we avoid a security pitfall, hence the term Forward Secrecy. We use the GCM flavor of AES (AES Galois Counter Mode) with 256-bit keys as it guarantees the encrypted data hasn’t been modified in transit.\n\nNote that while this encryption schema works, it is still a weak approach to forward secrecy. There are more modern ways to go about it, as we discuss in an article on Perfect Forward Secrecy using the ECC encryption system. The main difference is that with ECC there isn’t even a need to send keys over a network, they can just be calculated on the go thanks to the mathematical properties of ECC functions. It makes ECC much more secure than forward secrecy with RSA.\n\nThis is the minimum you need to know to use RSA encryption to secure your applications, so don’t wait any longer to get started and subscribe to Onboardbase for free.\n\nOnboardbase makes it easy to store encryption keys while programmatically changing and using them: it’s your best ally to keep your RSA key pairs safe. A dashboard centralizes public and private keys for the whole dev team, and a command-line interface is available to integrate them into any software project. Each one of your keys is encrypted with AES-CBC-256 and the web app is served over HTTPS with perfect forward secrecy. It’s so easy and secure to use you won’t pick another tool for the job: register today and never leak your app secrets ever again."
    },
    {
        "link": "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa",
        "document": "This is a “Hazardous Materials” module. You should ONLY use it if you’re 100% absolutely sure that you know what you’re doing because this module is full of land mines, dragons, and dinosaurs with laser guns.\n\nRSA is a public-key algorithm for encrypting and signing messages.\n\nIf you already have an on-disk key in the PEM format (which are recognizable by the distinctive and markers), you can load it: Serialized keys may optionally be encrypted on disk using a password. In this example we loaded an unencrypted key, and therefore we did not provide a password. If the key is encrypted we can pass a object as the argument. There is also support for .\n\nIf you have a private key that you’ve loaded you can use to serialize the key. It is also possible to serialize without encryption using . For public keys you can use to serialize the key.\n\nA private key can be used to sign a message. This allows anyone with the public key to verify that the message was created by someone who possesses the corresponding private key. RSA signatures require a specific hash function, and padding to be used. Here is an example of signing using RSA, with a secure hash function and padding: Valid paddings for signatures are and . is the recommended choice for any new protocols or applications, should only be used to support legacy protocols. If your data is too large to be passed in a single call, you can hash it separately and pass that value using .\n\nThe previous section describes what to do if you have a private key and want to sign something. If you have a public key, a message, a signature, and the signing algorithm that was used you can check that the private key associated with a given public key was used to sign that specific message. You can obtain a public key to use in verification using , , , or . If the signature does not match, will raise an exception. If your data is too large to be passed in a single call, you can hash it separately and pass that value using .\n\nRSA encryption is interesting because encryption is performed using the public key, meaning anyone can encrypt data. The data is then decrypted using the private key. Like signatures, RSA supports encryption with several different padding options. Here’s an example using a secure padding and hash function: Valid paddings for encryption are and . is the recommended choice for any new protocols or applications, should only be used to support legacy protocols.\n\nThese classes hold the constituent components of an RSA key. They are useful only when more traditional Key Serialization is unavailable. The collection of integers that make up an RSA public key. The collection of integers that make up an RSA private key. With the exception of the integers contained in the all attributes of this class must be kept secret. Revealing them will compromise the security of any cryptographic operations performed with a key loaded from them. The which makes up the RSA public key associated with this RSA private key. , one of the two primes composing . , one of the two primes composing . A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: d mod (p-1) A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: d mod (q-1) A Chinese remainder theorem coefficient used to speed up RSA operations. Calculated as: q-1 mod p A keyword-only argument that defaults to . If RSA private keys will not be validated. This significantly speeds up loading the keys, but is unsafe unless you are certain the key is valid. User supplied keys should never be loaded with this parameter set to . If you do load an invalid key this way and attempt to use it OpenSSL may hang, crash, or otherwise misbehave.\n\nIf you are trying to load RSA private keys yourself you may find that not all parameters required by are available. In particular the Chinese Remainder Theorem (CRT) values , , may be missing or present in a different form. For example, OpenPGP does not include the , or parameters. The following functions are provided for users who want to work with keys like this without having to do the math themselves. Computes the (also known as ) parameter from the RSA primes and . Computes the parameter from the RSA private exponent ( ) and prime . Computes the parameter from the RSA private exponent ( ) and prime . Computes the RSA private_exponent ( ) given the public exponent ( ) and the RSA primes and . This implementation uses the Carmichael totient function to return the smallest working value of . Older RSA implementations, including the original RSA paper, often used the Euler totient function, which results in larger but equally functional private exponents. The private exponents resulting from the Carmichael totient function, as returned here, are slightly more computationally efficient to use, and some modern standards require them. Computes the prime factors given the modulus, public exponent, and private exponent. When recovering prime factors this algorithm will always return and such that . Note: before 1.5, this function always returned and such that . It was changed because libraries commonly require .\n\nOur implementation of PKCS1 v1.5 decryption is not constant time. See Known security limitations for details. Decrypt data that was encrypted with the public key. An RSA public key object corresponding to the values of the private key. The bit length of the modulus. Changed in version 1.6: can now be used as an . Sign one block of data which can be verified later by others using the public key.\n• None algorithm – An instance of or if the you want to sign has already been hashed. Allows serialization of the key to bytes. Encoding ( or ), format ( , or ) and encryption algorithm (such as or ) are chosen to define the exact serialization.\n• None encoding – A value from the enum.\n• None format – A value from the enum.\n• None encryption_algorithm – An instance of an object conforming to the interface. ValueError – The data could not be encrypted. One possible cause is if is too large; RSA keys can only encrypt data that is smaller than the key size. The bit length of the modulus. Allows serialization of the key to bytes. Encoding ( or ) and format ( or ) are chosen to define the exact serialization.\n• None encoding – A value from the enum.\n• None format – A value from the enum. Changed in version 1.6: can now be used as an . Verify one block of data was signed by the private key associated with this public key.\n• None data (bytes-like) – The message string that was signed.\n• None algorithm – An instance of or if the you want to verify has already been hashed. cryptography.exceptions.InvalidSignature – If the signature does not validate. Recovers the signed data from the signature. The data typically contains the digest of the original message string. The and parameters must match the ones used when the signature was created for the recovery to succeed. The parameter can also be set to to recover all the data present in the signature, without regard to its format or the hash algorithm used for its creation. For padding, this method returns the data after removing the padding layer. For standard signatures the data contains the full structure. For non-standard signatures, any data can be returned, including zero-length data. Normally you should use the function to validate the signature. But for some non-standard signature formats you may need to explicitly recover and validate the signed data. The following are some examples:\n• None Some old Thawte and Verisign timestamp certificates without .\n• None padding – An instance of . Recovery is only supported with some of the padding types. (Currently only with ).\n• None algorithm – An instance of . Can be to return the all the data present in the signature.\n• None cryptography.exceptions.InvalidSignature – If the signature is invalid.\n• None cryptography.exceptions.UnsupportedAlgorithm – If signature data recovery is not supported with the provided type."
    }
]