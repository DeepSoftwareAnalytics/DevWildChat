[
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/finite_state_machine/index.html",
        "document": "An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\n\nIt is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.\n\nA finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.\n\nNot all functionality of the bot can be implemented as single handler, for example you will need to collect some data from user in separated steps you will need to use FSM.\n\nLet’s see how to do that step-by-step\n\nBefore handle any states you will need to specify what kind of states you want to handle And then write handler for each state separately from the start of dialog Here is dialog can be started only via command , so lets handle it and make transition user to state \"Hi there! What's your name?\" After that you will need to save some data to the storage and make transition to next step. Did you like to write bots?\" At the next steps user can make different answers, it can be , or any other Handle and soon we need to handle state What programming language did you use for it?\" And handle any other answers All possible cases of step was covered, let’s implement finally step \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" And now you have covered all steps from the image, but you can make possibility to cancel conversation, lets do that via command or text Allow user to cancel any action\n\n\"Hi there! What's your name?\" Allow user to cancel any action Did you like to write bots?\" What programming language did you use for it?\" \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://linkedin.com/pulse/exploring-finite-state-machine-aiogram-3-powerful-tool-telegram-dbsae",
        "document": "\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events.\n\nIn this handler, we've successfully stored the user's input for the first question and will now progress to the next question. Additionally, we'll incorporate an \"Go back\" button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user's response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a \"Cancel\" button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow.\n\nTransition to any state in flow"
    },
    {
        "link": "https://medium.com/sp-lutsk/exploring-finite-state-machine-in-aiogram-3-a-powerful-tool-for-telegram-bot-development-9cd2d19cfae9",
        "document": "In the realm of Telegram bot development, the quest for efficiency and robustness is an ongoing endeavor. With each iteration, developers seek tools and frameworks that streamline the development process while ensuring the scalability and maintainability of their bots. In this pursuit, the integration of Finite State Machines (FSMs) has emerged as a powerful technique, providing a structured approach to managing bot behavior. In this article, we delve into the integration of Finite State Machines within the Aiogram 3 framework, a powerful option for Telegram bot development in Python. Aiogram, renowned for its simplicity and flexibility, empowers developers to build feature-rich bots effortlessly. By using FSM, it can become even more seamless, offering developers a structured approach to handling complex bot behavior.\n\nA Finite State Machine (FSM) is a computational model used to describe the behavior of a system by dividing it into a finite number of states, along with transitions between these states based on certain conditions or events. At its core, an FSM consists of the following components:\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events. In Aiogram 3, the integration of Finite State Machines offers developers a remarkable opportunity to manage the intricate flow of user inputs with ease. By guiding users through a sequence of defined states and handling each state separately, FSMs empower developers to create Telegram bots that gracefully navigate through complex interaction scenarios. This capability allows for the systematic handling of user inputs, ensuring a seamless conversational experience for bot users.\n\nTo better comprehend the theoretical aspects of Finite State Machines (FSM) in Aiogram, let’s embark on a practical journey. Imagine we’re creating a form within our Telegram bot where we sequentially ask users a series of questions, concluding with a confirmation of the collected answers. In Aiogram, FSMs are represented as StatesGroups, serving as the foundation for organizing bot behavior into distinct states and managing transitions between them. The schema below illustrates the sequential flow of our form within the FSM framework: Starting with the creation of a StatesGroup, we establish a structured environment for managing the flow of user interactions. Each state within the StatesGroup corresponds to a specific stage in our form, guiding users through a sequence of questions and responses. As users progress through the form, transitions between states occur based on their inputs, ensuring a smooth and intuitive user experience. Now, let’s delve into the implementation details. Below, you’ll find the code snippet illustrating the creation of the StatesGroup with Aiogram: After defining the StatesGroup for our form, the next step is to establish handlers to manage user interactions. Typically, a conversation with the bot initiates with the /start command. Therefore, our first task is to handle this command and transition the user to the initial state of our form, Form.About.first_name. Below is a snippet showcasing the implementation of the handler for the /start command and the transition operation to the first state: We have added two buttons for this question — “Skip” and “Cancel”, we will cover them later. After the user answers the first question, we need to store the answer in the storage and move on to the next step. Code snippet to handler first state and transition to second state: In this handler, we’ve successfully stored the user’s input for the first question and will now progress to the next question. Additionally, we’ll incorporate an “Go back” button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user’s response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review. With the implementation of the described logic, our bot is now equipped to traverse through all defined states, guiding users through each step of the form.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a “Cancel” button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow. @form_router.message(Command(\"cancel\"))\n\n@form_router.message(F.text.casefold() == \"cancel\")\n\nasync def cancel_handler(message: Message, state: FSMContext) -> None:\n\n \"\"\"\n\n Allow user to cancel any action\n\n \"\"\"\n\n current_state = await state.get_state()\n\n if current_state is None:\n\n return To introduce the “Go back” button functionality, enabling users to transition to the previous state, we need to implement an additional tool — a list containing information about the states. For this, let’s outline a data structure representing the state information. Code snippet for this: Each element of the list will be represented as dataclass with state name, question for this state, in memory representative value, corresponding button (we will need it for future step) and keyboard buttons that need to be sent to user with state question. Code snippet for first state implementation in dataclass format: State(\n\n \"Form.About:first_name\",\n\n \"What's your first name?\",\n\n \"first_name\",\n\n \"First name\",\n\n [\n\n [KeyboardButton(text=\"Skip\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), All following states will have similar structure, but with additional “Go back” button. Code snippet example for following states: State(\n\n \"Form.About:last_name\",\n\n \"What's your last name?\",\n\n \"last_name\",\n\n \"Last name\",\n\n [\n\n [KeyboardButton(text=\"Skip\"), KeyboardButton(text=\"Go back\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), This list of states will allow us to track the state by name and manage all of its attributes to better understand it lets review code snippet for the “Go back” button handler: @form_router.message(Command(\"go back\"))\n\n@form_router.message(F.text.casefold() == \"go back\")\n\nasync def go_back_handler(message: Message, state: FSMContext) -> None:\n\n current_state = await state.get_state()\n\n logging.info(\"Going back from %r\", current_state)\n\n (\n\n previous_state,\n\n state_message,\n\n keyboard_buttons\n\n ) = get_previous_state(current_state)\n\n if previous_state is None:\n\n await message.answer(\n\n \"You are already at the first step.\",\n\n )\n\n else:\n\n await state.set_state(previous_state)\n\n await message.answer(\n\n state_message,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler we get the current_state and based on that we get the previous state information using the get_previous_state method. def get_previous_state(current_state: str) -> str:\n\n current_state_index = next(\n\n (i for i, obj in enumerate(STATES_LIST) if obj.state_name == current_state),\n\n None,\n\n )\n\n previous_state_index = current_state_index - 1\n\n if previous_state_index < 0:\n\n return None, None\n\n return (\n\n STATES_LIST[previous_state_index].state_name,\n\n STATES_LIST[previous_state_index].state_question,\n\n STATES_LIST[previous_state_index].keyboard_buttons,\n\n ) This method uses created STATES_LIST to receive current state (the state from which the user wants to go back) index and based on this returns information about previous state name, questions and keyboard buttons. After this we only need to set this state and send proper message to user. Implementation of this flow shown bellow.\n\nTransition to any state in flow Now when we can cancel flow and use transition to previous state we can try to implement even more complicated operations. For this lets implement confirmation for our form. Previously we have added “Approve” and “Disapprove” buttons for final step. Handler for “Approve” button is very simple. @form_router.message(Form.confirm, F.text.casefold() == \"approve\")\n\nasync def process_confirm(message: Message, state: FSMContext) -> None:\n\n await state.clear()\n\n await message.answer(\n\n \"Thank you for your Form!\",\n\n reply_markup=ReplyKeyboardRemove(),\n\n ) We will not save any customers data in this example, so all we need — close state and send appropriate message. To implement “Disapprove” function lets add another state — “confirm_reject”, after it our StatesGroup looks like this: Handler for “Disapprove” button will set this state and send message with proposition to change any of inputed data. @form_router.message(Form.confirm_reject, F.text.casefold() != \"cancel\")\n\nasync def process_reject(message: Message, state: FSMContext) -> None:\n\n required_state_index = next(\n\n (\n\n i\n\n for i, obj in enumerate(STATES_LIST)\n\n if obj.state_corresponding_button == message.text\n\n ),\n\n None,\n\n )\n\n if required_state_index is None:\n\n await message.answer(\n\n \"I don't understand you. Please, choose one of the options.\",\n\n )\n\n else:\n\n required_state = STATES_LIST[required_state_index]\n\n await state.update_data(reject=True)\n\n await state.set_state(required_state.state_name)\n\n await message.answer(\n\n required_state.state_question,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=required_state.keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler firstly we validate if user selected one of available buttons, for this we are trying to find state by state_corresponding_button value in STATES_LIST. After this we need to receive required_state information, make transition to this step and send proper message. But logically — after user will answer to this question we should send him to confirmation step again, for this we need to add “reject” value to states data and also update our states handlers to handle this value. Updated “first_name” state handler @form_router.message(Form.about.first_name)\n\nasync def process_first_name(message: Message, state: FSMContext) -> None:\n\n await state.update_data(first_name=message.text)\n\n data = await state.get_data()\n\n reject = data.get(\"reject\", False)\n\n if reject:\n\n await update_on_reject(message, state)\n\n else:\n\n await state.set_state(Form.about.last_name)\n\n await message.answer(\n\n \"What's your last name?\",\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=[\n\n [\n\n KeyboardButton(text=\"Skip\"),\n\n KeyboardButton(text=\"Go back\")\n\n ],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n resize_keyboard=True,\n\n ),\n\n ) As you can see we added only if else statement to handler reject, in case if reject is equal to True we are calling update_on_reject method: This method will make transition to confirmation state and send confirmation message again. On our state schema this operation is illustrated in two lines, firstly we perform transition from “Confirmation” to “First name” (with red arrow) and then back to “Confirmation” (with purple arrow). In Telegram flow it will looks like this:"
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.16.0/dispatcher/finite_state_machine",
        "document": "An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\n\nIt is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.\n\nA finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.\n\nNot all functionality of the bot can be implemented as single handler, for example you will need to collect some data from user in separated steps you will need to use FSM.\n\nLet’s see how to do that step-by-step\n\nBefore handle any states you will need to specify what kind of states you want to handle And then write handler for each state separately from the start of dialog Here is dialog can be started only via command , so lets handle it and make transition user to state \"Hi there! What's your name?\" After that you will need to save some data to the storage and make transition to next step. Did you like to write bots?\" At the next steps user can make different answers, it can be , or any other Handle and soon we need to handle state What programming language did you use for it?\" And handle any other answers All possible cases of step was covered, let’s implement finally step \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" And now you have covered all steps from the image, but you can make possibility to cancel conversation, lets do that via command or text Allow user to cancel any action\n\n\"Hi there! What's your name?\" Allow user to cancel any action Did you like to write bots?\" What programming language did you use for it?\" \"Python, you say? That's the language that makes my circuits light up! 😉\" \"you like to write bots with \"you don't like to write bots, so sad...\" # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/dev-3.x/migration_2_to_3.html",
        "document": "This version introduces numerous breaking changes and architectural improvements. It helps reduce the count of global variables in your code, provides useful mechanisms to modularize your code, and enables the creation of shareable modules via packages on PyPI. It also makes middlewares and filters more controllable, among other improvements.\n\nOn this page, you can read about the changes made in relation to the last stable 2.x version.\n\nThis page more closely resembles a detailed changelog than a migration guide, but it will be updated in the future. Feel free to contribute to this page, if you find something that is not mentioned here.\n• None The class no longer accepts a instance in its initializer. Instead, the instance should be passed to the dispatcher only for starting polling or handling events from webhooks. This approach also allows for the use of multiple bot instances simultaneously (“multibot”).\n• None now can be extended with another Dispatcher-like thing named . With routes, you can easily modularize your code and potentially share these modules between projects. (Read more ».)\n• None Removed the _handler suffix from all event handler decorators and registering methods. (Read more »)\n• None The has been entirely removed; you can now use the directly to start poll the API or handle webhooks from it.\n• None The throttling method has been completely removed; you can now use middlewares to control the execution context and implement any throttling mechanism you desire.\n• None Removed global context variables from the API types, and object. From now on, if you want to access the current bot instance within handlers or filters, you should accept the argument and use it instead of . In middlewares, it can be accessed via .\n• None To skip pending updates, you should now call the method directly, rather than passing to the start polling method.\n• None To feed updates to the , instead of method , you should use method . (Read more »)\n• None Keyword filters can no longer be used; use filters explicitly. (Read more »)\n• None Due to the removal of keyword filters, all previously enabled-by-default filters (such as state and content_type) are now disabled. You must specify them explicitly if you wish to use them. For example instead of using you should use\n• None Most common filters have been replaced with the “magic filter.” (Read more »)\n• None By default, the message handler now receives any content type. If you want a specific one, simply add the appropriate filters (Magic or any other).\n• None The state filter is no longer enabled by default. This means that if you used in v2, you should not pass any state filter in v3. Conversely, if the state was not specified in v2, you will now need to specify it in v3.\n• None Added the possibility to register global filters for each router, which helps to reduce code repetition and provides an easier way to control the purpose of each router.\n• None All API methods are now classes with validation, implemented via . These API calls are also available as methods in the Bot class.\n• None More pre-defined Enums have been added and moved to the sub-package. For example, the chat type enum is now instead of .\n• None The HTTP client session has been separated into a container that can be reused across different Bot instances within the application.\n• None API Exceptions are no longer classified by specific messages, as Telegram has no documented error codes. However, all errors are classified by HTTP status codes, and for each method, only one type of error can be associated with a given code. Therefore, in most cases, you should check only the error type (by status code) without inspecting the error message.\n• None State filters will no longer be automatically added to all handlers; you will need to specify the state if you want to use it.\n• None Added the possibility to change the FSM strategy. For example, if you want to control the state for each user based on chat topics rather than the user in a chat, you can specify this in the .\n• None Now and don’t have helper methods like , , etc. Instead, you should set states by passing them directly to (Read more »)\n• None The state proxy is deprecated; you should update the state data by calling and respectively."
    },
    {
        "link": "https://aiosqlite.omnilib.dev/en/latest/api.html",
        "document": "Create user-defined function that can be later used within SQL statements. Must be run within the same thread that query executions take place so instead of executing directly against the connection, we defer this to function.\n\nIf is true, the created function is marked as deterministic, which allows SQLite to perform additional optimizations. This flag is supported by SQLite 3.8.3 or higher, will be raised if used with older versions."
    },
    {
        "link": "https://aiosqlite.omnilib.dev/en/v0.20.0/api.html",
        "document": "Create user-defined function that can be later used within SQL statements. Must be run within the same thread that query executions take place so instead of executing directly against the connection, we defer this to function.\n\nIf is true, the created function is marked as deterministic, which allows SQLite to perform additional optimizations. This flag is supported by SQLite 3.8.3 or higher, will be raised if used with older versions."
    },
    {
        "link": "http://docs.sqlalchemy.org/en/latest/orm/extensions/asyncio.html",
        "document": "Support for Python asyncio. Support for Core and ORM usage is included, using asyncio-compatible dialects.\n\nThe asyncio extension requires Python 3 only. It also depends upon the greenlet library. This dependency is installed by default on common machine platforms including: For the above platforms, is known to supply pre-built wheel files. For other platforms, greenlet does not install by default; the current file listing for greenlet can be seen at Greenlet - Download Files. Note that there are many architectures omitted, including Apple M1. To install SQLAlchemy while ensuring the dependency is present regardless of what platform is in use, the setuptools extra may be installed as follows, which will include also instruct to install : Note that installation of on platforms that do not have a pre-built wheel file means that will be built from source, which requires that Python’s development libraries also be present.\n\nFor Core use, the function creates an instance of which then offers an async version of the traditional API. The delivers an via its and methods which both deliver asynchronous context managers. The can then invoke statements using either the method to deliver a buffered , or the method to deliver a streaming server-side : ... t1.insert(), [{\"name\": \"some name 1\"}, {\"name\": \"some name 2\"}] ... # select a Result, which will be delivered with buffered ... # for AsyncEngine created in function scope, close and Above, the method may be used to invoke special DDL functions such as that don’t include an awaitable hook. It’s advisable to invoke the method using when using the object in a scope that will go out of context and be garbage collected, as illustrated in the function in the above example. This ensures that any connections held open by the connection pool will be properly disposed within an awaitable context. Unlike when using blocking IO, SQLAlchemy cannot properly dispose of these connections within methods like or weakref finalizers as there is no opportunity to invoke . Failing to explicitly dispose of the engine when it falls out of scope may result in warnings emitted to standard out resembling the form within garbage collection. The also features a “streaming” API via the method that returns an object. This result object uses a server-side cursor and provides an async/await API, such as an async iterator:\n\nUsing events with the asyncio extension¶ The SQLAlchemy event system is not directly exposed by the asyncio extension, meaning there is not yet an “async” version of a SQLAlchemy event handler. However, as the asyncio extension surrounds the usual synchronous SQLAlchemy API, regular “synchronous” style event handlers are freely available as they would be if asyncio were not used. As detailed below, there are two current strategies to register events given asyncio-facing APIs:\n• None Events can be registered at the instance level (e.g. a specific instance) by associating the event with the attribute that refers to the proxied object. For example to register the event against an instance, use its attribute as target. Targets include:\n• None To register an event at the class level, targeting all instances of the same type (e.g. all instances), use the corresponding sync-style class. For example to register the event against the class, use the class as the target.\n• None To register at the level, combine an explicit with an using , and associate events with the . When working within an event handler that is within an asyncio context, objects like the continue to work in their usual “synchronous” way without requiring or usage; when messages are ultimately received by the asyncio database adapter, the calling style is transparently adapted back into the asyncio calling style. For events that are passed a DBAPI level connection, such as , the object is a pep-249 compliant “connection” object which will adapt sync-style calls into the asyncio driver. Some examples of sync style event handlers associated with async-facing API constructs are illustrated below:\n• In this example, we access the attribute of as the target for and : New DBAPI connection: <AdaptedConnection <asyncpg.connection.Connection object at 0x7f33f9b16960>> execute from event before execute!\n• In this example, we access as the target for : before commit! execute from event after commit!\n• For this use case, we make a as the event target, then assign it to the using the parameter: SQLAlchemy events by their nature take place within the interior of a particular SQLAlchemy process; that is, an event always occurs after some particular SQLAlchemy API has been invoked by end-user code, and before some other internal aspect of that API occurs. Contrast this to the architecture of the asyncio extension, which takes place on the exterior of SQLAlchemy’s usual flow from end-user API to DBAPI function. The flow of messaging may be visualized as follows: Where above, an API call always starts as asyncio, flows through the synchronous API, and ends as asyncio, before results are propagated through this same chain in the opposite direction. In between, the message is adapted first into sync-style API use, and then back out to async style. Event hooks then by their nature occur in the middle of the “sync-style API use”. From this it follows that the API presented within event hooks occurs inside the process by which asyncio API requests have been adapted to sync, and outgoing messages to the database API will be converted to asyncio transparently. Using awaitable-only driver methods in connection pool and other events¶ As discussed in the above section, event handlers such as those oriented around the event handlers receive a sync-style “DBAPI” connection, which is a wrapper object supplied by SQLAlchemy asyncio dialects to adapt the underlying asyncio “driver” connection into one that can be used by SQLAlchemy’s internals. A special use case arises when the user-defined implementation for such an event handler needs to make use of the ultimate “driver” connection directly, using awaitable only methods on that driver connection. One such example is the method supplied by the asyncpg driver. To accommodate this use case, SQLAlchemy’s class provides a method that allows an awaitable function to be invoked within the “synchronous” context of an event handler or other SQLAlchemy internal. This method is directly analogous to the method that allows a sync-style method to run under async. should be passed a function that will accept the innermost “driver” connection as a single argument, and return an awaitable that will be invoked by the method. The given function itself does not need to be declared as ; it’s perfectly fine for it to be a Python , as the return awaitable value will be invoked after being returned: Above, the object passed to the event handler is an instance of , which provides a DBAPI-like interface to an underlying async-only driver-level connection object. The method then provides access to an awaitable environment where the underlying driver level connection may be acted upon."
    },
    {
        "link": "https://stackoverflow.com/questions/77464742/python-sqlite-select-data-from-1-specific-column-to-use-in-a-variable",
        "document": "I am storing data in a database and want to retrieve data from one column but I'm only taking the data from one single cell, but the data it spits out with .fetchone() comes out as: (TheData, ).\n\nI am using aiosqlite, which is the async library of sqlite.\n\nThis is loading my main DB, looks into the sconfig table where I have, as an example:\n\nNow, this code works and it indeed does select the correct column I want, from the row I want, but it grabs the data (Lets say from 12345's Row) which would be in this pseudo case: RandomData but when stored in a variable it shows it as: ('RandomData',)\n\nCurrently I've just been doing the following to strip the stuff around the data away:\n\nWhich then sets a new variable \"result\" with the data looking like: RandomData Looks like a good solution but I'm sure this isn't the correct way to select a single cells data, there must be a way to get that data without needing to use join map, as other datatypes may get messed up in future with this method.\n\nI'm wanting to store date / time data soon and I fear the join map may break that data when taking it from the cell to use in variables.\n\nI'm very new to databases so any help is appreciated and I hope my examples explain my problem. Oh and, I have seen resources saying that the select is storing data in a tuple, so I need to iterate over the values, etc etc, but I'm using async and unsure if theres a way to do that in async with the library i'm using and hoping there may be a simple way of querying the DB to return just that one cell of data, as that's what I'm asking for, not a row of data or a list of columns."
    },
    {
        "link": "https://github.com/omnilib/aiosqlite",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://community.openai.com/t/how-to-manage-individual-user-sessions-and-history-in-a-chatbot/1022258",
        "document": "How can a chatbot effectively handle separate sessions for each user and maintain distinct interaction histories for different users?\n\nTo manage this, chatbots typically use session identifiers or tokens to distinguish users. These sessions can be stored temporarily in memory (e.g., Redis) or permanently in databases, ensuring each user’s interactions and history are maintained and accessible separately."
    },
    {
        "link": "https://medium.com/sp-lutsk/exploring-finite-state-machine-in-aiogram-3-a-powerful-tool-for-telegram-bot-development-9cd2d19cfae9",
        "document": "In the realm of Telegram bot development, the quest for efficiency and robustness is an ongoing endeavor. With each iteration, developers seek tools and frameworks that streamline the development process while ensuring the scalability and maintainability of their bots. In this pursuit, the integration of Finite State Machines (FSMs) has emerged as a powerful technique, providing a structured approach to managing bot behavior. In this article, we delve into the integration of Finite State Machines within the Aiogram 3 framework, a powerful option for Telegram bot development in Python. Aiogram, renowned for its simplicity and flexibility, empowers developers to build feature-rich bots effortlessly. By using FSM, it can become even more seamless, offering developers a structured approach to handling complex bot behavior.\n\nA Finite State Machine (FSM) is a computational model used to describe the behavior of a system by dividing it into a finite number of states, along with transitions between these states based on certain conditions or events. At its core, an FSM consists of the following components:\n• States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n• Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n• Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events. In Aiogram 3, the integration of Finite State Machines offers developers a remarkable opportunity to manage the intricate flow of user inputs with ease. By guiding users through a sequence of defined states and handling each state separately, FSMs empower developers to create Telegram bots that gracefully navigate through complex interaction scenarios. This capability allows for the systematic handling of user inputs, ensuring a seamless conversational experience for bot users.\n\nTo better comprehend the theoretical aspects of Finite State Machines (FSM) in Aiogram, let’s embark on a practical journey. Imagine we’re creating a form within our Telegram bot where we sequentially ask users a series of questions, concluding with a confirmation of the collected answers. In Aiogram, FSMs are represented as StatesGroups, serving as the foundation for organizing bot behavior into distinct states and managing transitions between them. The schema below illustrates the sequential flow of our form within the FSM framework: Starting with the creation of a StatesGroup, we establish a structured environment for managing the flow of user interactions. Each state within the StatesGroup corresponds to a specific stage in our form, guiding users through a sequence of questions and responses. As users progress through the form, transitions between states occur based on their inputs, ensuring a smooth and intuitive user experience. Now, let’s delve into the implementation details. Below, you’ll find the code snippet illustrating the creation of the StatesGroup with Aiogram: After defining the StatesGroup for our form, the next step is to establish handlers to manage user interactions. Typically, a conversation with the bot initiates with the /start command. Therefore, our first task is to handle this command and transition the user to the initial state of our form, Form.About.first_name. Below is a snippet showcasing the implementation of the handler for the /start command and the transition operation to the first state: We have added two buttons for this question — “Skip” and “Cancel”, we will cover them later. After the user answers the first question, we need to store the answer in the storage and move on to the next step. Code snippet to handler first state and transition to second state: In this handler, we’ve successfully stored the user’s input for the first question and will now progress to the next question. Additionally, we’ll incorporate an “Go back” button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user’s response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review. With the implementation of the described logic, our bot is now equipped to traverse through all defined states, guiding users through each step of the form.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a “Cancel” button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow. @form_router.message(Command(\"cancel\"))\n\n@form_router.message(F.text.casefold() == \"cancel\")\n\nasync def cancel_handler(message: Message, state: FSMContext) -> None:\n\n \"\"\"\n\n Allow user to cancel any action\n\n \"\"\"\n\n current_state = await state.get_state()\n\n if current_state is None:\n\n return To introduce the “Go back” button functionality, enabling users to transition to the previous state, we need to implement an additional tool — a list containing information about the states. For this, let’s outline a data structure representing the state information. Code snippet for this: Each element of the list will be represented as dataclass with state name, question for this state, in memory representative value, corresponding button (we will need it for future step) and keyboard buttons that need to be sent to user with state question. Code snippet for first state implementation in dataclass format: State(\n\n \"Form.About:first_name\",\n\n \"What's your first name?\",\n\n \"first_name\",\n\n \"First name\",\n\n [\n\n [KeyboardButton(text=\"Skip\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), All following states will have similar structure, but with additional “Go back” button. Code snippet example for following states: State(\n\n \"Form.About:last_name\",\n\n \"What's your last name?\",\n\n \"last_name\",\n\n \"Last name\",\n\n [\n\n [KeyboardButton(text=\"Skip\"), KeyboardButton(text=\"Go back\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), This list of states will allow us to track the state by name and manage all of its attributes to better understand it lets review code snippet for the “Go back” button handler: @form_router.message(Command(\"go back\"))\n\n@form_router.message(F.text.casefold() == \"go back\")\n\nasync def go_back_handler(message: Message, state: FSMContext) -> None:\n\n current_state = await state.get_state()\n\n logging.info(\"Going back from %r\", current_state)\n\n (\n\n previous_state,\n\n state_message,\n\n keyboard_buttons\n\n ) = get_previous_state(current_state)\n\n if previous_state is None:\n\n await message.answer(\n\n \"You are already at the first step.\",\n\n )\n\n else:\n\n await state.set_state(previous_state)\n\n await message.answer(\n\n state_message,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler we get the current_state and based on that we get the previous state information using the get_previous_state method. def get_previous_state(current_state: str) -> str:\n\n current_state_index = next(\n\n (i for i, obj in enumerate(STATES_LIST) if obj.state_name == current_state),\n\n None,\n\n )\n\n previous_state_index = current_state_index - 1\n\n if previous_state_index < 0:\n\n return None, None\n\n return (\n\n STATES_LIST[previous_state_index].state_name,\n\n STATES_LIST[previous_state_index].state_question,\n\n STATES_LIST[previous_state_index].keyboard_buttons,\n\n ) This method uses created STATES_LIST to receive current state (the state from which the user wants to go back) index and based on this returns information about previous state name, questions and keyboard buttons. After this we only need to set this state and send proper message to user. Implementation of this flow shown bellow.\n\nTransition to any state in flow Now when we can cancel flow and use transition to previous state we can try to implement even more complicated operations. For this lets implement confirmation for our form. Previously we have added “Approve” and “Disapprove” buttons for final step. Handler for “Approve” button is very simple. @form_router.message(Form.confirm, F.text.casefold() == \"approve\")\n\nasync def process_confirm(message: Message, state: FSMContext) -> None:\n\n await state.clear()\n\n await message.answer(\n\n \"Thank you for your Form!\",\n\n reply_markup=ReplyKeyboardRemove(),\n\n ) We will not save any customers data in this example, so all we need — close state and send appropriate message. To implement “Disapprove” function lets add another state — “confirm_reject”, after it our StatesGroup looks like this: Handler for “Disapprove” button will set this state and send message with proposition to change any of inputed data. @form_router.message(Form.confirm_reject, F.text.casefold() != \"cancel\")\n\nasync def process_reject(message: Message, state: FSMContext) -> None:\n\n required_state_index = next(\n\n (\n\n i\n\n for i, obj in enumerate(STATES_LIST)\n\n if obj.state_corresponding_button == message.text\n\n ),\n\n None,\n\n )\n\n if required_state_index is None:\n\n await message.answer(\n\n \"I don't understand you. Please, choose one of the options.\",\n\n )\n\n else:\n\n required_state = STATES_LIST[required_state_index]\n\n await state.update_data(reject=True)\n\n await state.set_state(required_state.state_name)\n\n await message.answer(\n\n required_state.state_question,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=required_state.keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler firstly we validate if user selected one of available buttons, for this we are trying to find state by state_corresponding_button value in STATES_LIST. After this we need to receive required_state information, make transition to this step and send proper message. But logically — after user will answer to this question we should send him to confirmation step again, for this we need to add “reject” value to states data and also update our states handlers to handle this value. Updated “first_name” state handler @form_router.message(Form.about.first_name)\n\nasync def process_first_name(message: Message, state: FSMContext) -> None:\n\n await state.update_data(first_name=message.text)\n\n data = await state.get_data()\n\n reject = data.get(\"reject\", False)\n\n if reject:\n\n await update_on_reject(message, state)\n\n else:\n\n await state.set_state(Form.about.last_name)\n\n await message.answer(\n\n \"What's your last name?\",\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=[\n\n [\n\n KeyboardButton(text=\"Skip\"),\n\n KeyboardButton(text=\"Go back\")\n\n ],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n resize_keyboard=True,\n\n ),\n\n ) As you can see we added only if else statement to handler reject, in case if reject is equal to True we are calling update_on_reject method: This method will make transition to confirmation state and send confirmation message again. On our state schema this operation is illustrated in two lines, firstly we perform transition from “Confirmation” to “First name” (with red arrow) and then back to “Confirmation” (with purple arrow). In Telegram flow it will looks like this:"
    },
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/index.html",
        "document": "aiogram includes Dispatcher mechanism. Dispatcher is needed for handling incoming updates from Telegram.\n\nWith dispatcher you can do:\n• None Filter incoming events before it will be processed by specific handler;\n• None Separate bot functionality between different handlers, modules and packages\n\nDispatcher is also separated into two entities - Router and Dispatcher. Dispatcher is subclass of router and should be always is root router.\n• None Webhook - you should configure your web server to receive updates from Telegram;\n• None Long polling - you should request updates from Telegram.\n\nSo, you can use both of them with aiogram."
    },
    {
        "link": "https://stackoverflow.com/questions/77322329/setting-multiple-states-for-a-user-on-aiogram-3-x",
        "document": "I am working on Telegram Bot, using aiogram 3.1.1 and its FSM. I did define UserState, that can have two states\n\nThis is the way how i filter users, that are currently waiting for an answer from bot or have the dialogue mode enabled.\n\nAnd it works fine. But i encounter an issue, when i want to have another independent StatesGroup for users. For example:\n\nUsing this i want to filter if the user wants to receive answers from bot via text message or via voice message. Those StatesGroups are meant to be independent, meaning that the user can have \"Voice\" and \"Dialogue\" states at once.\n\nI did try giving a person either \"Voice\" or \"Text\" status at the start of the conversation by asking him a question via the /start command. Then the user could choose if he wants a dialogue mode or not (should the bot set \"Dialogue\" state). For filtering this i've built two functions, they went smth like:\n\nThe problem is - the second function does not seem to be working properly. It seems like a user in aiogram FSM can only have one state a time, even if multiple states are in different StateGroups.\n\nSo did i get something wrong? And if, sadly, i am right - what are the common solutions for this task?"
    },
    {
        "link": "https://restack.io/p/aiogram-3-answer-best-telegram-bot-frameworks-ai-cat-ai",
        "document": "To create a simple Aiogram 3 bot, we will follow a structured approach that includes setting up the bot, handling commands, and responding to user messages. This guide assumes you have basic knowledge of Python and the Aiogram framework.\n\nFirst, ensure you have Python installed on your machine. You can download it from python.org. Next, install the Aiogram library using pip:\n\nOnce you have Aiogram installed, you need to create a new bot on Telegram. Start by chatting with the BotFather to create a new bot and obtain your bot token. This token is essential for your bot to communicate with the Telegram API.\n\nHere’s a simple example of how to set up your bot:\n\nThis code initializes the bot and sets up a command handler for the and commands. When a user sends either command, the bot responds with a welcome message.\n\nTo make your bot interactive, you can add more handlers to respond to user messages. For example, you can create a handler for text messages:\n\nThis handler will echo back any text message sent to the bot. You can expand this functionality by adding more complex logic based on user input.\n\nWith this basic setup, you have a functional Aiogram 3 bot that can respond to commands and messages. You can further enhance your bot by integrating it with external APIs, adding more commands, and implementing state management using Aiogram's built-in features. For more detailed information, refer to the official Aiogram documentation."
    }
]