[
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://cplusplus.com/reference/vector/vector",
        "document": "an unsigned integral type that can represent any non-negative value of\n\nusually the same as size_t"
    },
    {
        "link": "https://programiz.com/cpp-programming/vectors",
        "document": "In C++, vectors are used to store elements of similar data types. However, unlike arrays, the size of a vector can grow dynamically.\n\nThat is, we can change the size of the vector during the execution of a program as per our requirements.\n\nVectors are part of the C++ Standard Template Library. To use vectors, we need to include the header file in our program.\n\nOnce we include the header file, here's how we can declare a vector in C++:\n\nThe type parameter specifies the type of the vector. It can be any primitive data type such as , , , etc. For example,\n\nHere, is the name of the vector.\n\nNotice that we have not specified the size of the vector during the declaration. This is because the size of a vector can grow dynamically, so it is not necessary to define it.\n\nThere are different ways to initialize a vector in C++.\n\nHere, we are initializing the vector by providing values directly to the vector. Now, both and are initialized with values 1, 2, 3, 4, 5.\n\nHere, 5 is the size of the vector and 12 is the value.\n\nThis code creates an vector with size 5 and initializes the vector with the value of 12. So, the vector is equivalent to\n\nHere, we have declared and initialized three different vectors using three different initialization methods and displayed their contents.\n\nThe class provides various methods to perform different operations on vectors. We will look at some commonly used vector operations in this tutorial:\n\nTo add a single element into a vector, we use the function. It inserts an element into the end of the vector. For example,\n\nHere, we have initialized an vector with the elements . Notice the statements\n\nHere, the function adds elements and to the vector.\n\nNote: We can also use the and functions to add elements to a vector.\n\nIn C++, we use the index number to access the vector elements. Here, we use the function to access the element from the specified index. For example,\n\nWe can change an element of the vector using the same function. For example,\n\nIn the above example, notice the statements,\n\nHere, we have assigned new values to indexes 1 and 4. So the value at index 1 is changed to 9 and the value at index 4 is changed to 7.\n\nTo delete a single element from a vector, we use the function. For example,\n\nIn the above example, notice the statement,\n\nHere, we have removed the last element (7) from the vector.\n\nIn C++, the vector header file provides various functions that can be used to perform different operations on a vector.\n\nVector iterators are used to point to the memory address of a vector element. In some ways, they act like pointers in C++.\n\nWe can create vector iterators with the syntax\n\nFor example, if we have 2 vectors of and types, then we will need 2 different iterators corresponding to their types:\n\nWe can initialize vector iterators using the and functions.\n\nThe function returns an iterator that points to the first element of the vector. For example,\n\nThe function points to the theoretical element that comes after the final element of the vector. For example,\n\nHere, due to the nature of the function, we have used the code to point to the last element of the vector i.e. .\n\nIn this program, we have declared an vector iterator to use it with the vector .\n\nThen, we initialized the iterator to the first element of the vector using the function.\n\nThen, we printed the vector element by dereferencing the iterator:\n\nThen, we printed the 3rd element of the vector by changing the value of to .\n\nFinally, we printed the last element of the vector using the function.\n\nExample: Iterate Through Vector Using Iterators\n\nHere, we have used a for loop to initialize and iterate the iterator from the beginning of the vector to the end of the vector using the and functions."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/sorting-a-vector-in-c-plus-plus",
        "document": "In this tutorial, we are going to focus on Sorting a Vector in C++.\n\nSorting is one of the vastly performed operations in any programming language. Similarly, in C++ too, there are several algorithms following which we can sort any data structure.\n\nFor vectors, in particular, we can perform sorting operations in any order(ascending or descending).\n\nSorting a Vector in C++ in Ascending order\n\nA vector in C++ can be easily sorted in ascending order using the function defined in the header file.\n\nThe function sorts a given data structure and does not return anything. The sorting takes place between the two passed iterators or positions. The third parameter determines the order in which the elements are going to be compared.\n\nBy default, for not passing the third parameter, the function considers it to be the function. This function returns true or false on the basis of comparing two arguments, whether the first one is less than the other.\n\nSo, now let us see how we can sort a vector in C++(ascending order).\n\nSorting a Vector in C++ in Descending Order\n\nAs we said earlier, the third argument for the function in C++ determines the order of sorting. So, we can define functions in it to sort any vector in our desired order(descending in this case).\n\nSimilar to the function, the function returns a bool value as true or false but in the opposite sense. If the first argument is greater than the second one, the function returns true and false if the above condition is false.\n\nLet us see how we can use it to get a sorted vector in descending order.\n\nSince C++11, the use of lambda expressions was introduced to C++ programming. They are nothing but simple one-line functions, which do not need declaration or even require to specify their return type.\n\nHence, we can use our own defined lambda expression to determine the order of sorting by the function. This can be done by defining the one-line expression as the third parameter to the function. Let see how\n\nHere, the expression is used to compare two passed arguments from the vector. As we can see from the output for the above code, the vector gets sorted in descending order as desired.\n\nSo, in this article, we learned about sorting a vectors in C++, in both ascending and descending order. For any further questions related to this topic, feel free to use the comments below.\n• How to sort an STL vector? - StackOverflow Question,"
    },
    {
        "link": "https://geeksforgeeks.org/binary-search",
        "document": "Binary Search Algorithm is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N).\n\nBinary search is a search algorithm used to find the position of a target value within a sorted array. It works by repeatedly dividing the search interval in half until the target value is found or the interval is empty. The search interval is halved by comparing the target element with the middle value of the search space.\n• None The data structure must be sorted.\n• None Access to any element of the data structure should take constant time.\n\nBelow is the step-by-step algorithm for Binary Search:\n• None Divide the search space into two halves by finding the middle index “mid”\n• None Compare the middle element of the search space with the key\n• key is found at middle element, the process is terminated.\n• key is not found at middle element, choose which half will be used as the next search space.\n• key is smaller than the middle element, then the left side is used for next search.\n• key is larger than the middle element, then the right side is used for next search.\n• None This process is continued until the key is found or the total search space is exhausted.\n\nTo understand the working of binary search, consider the following illustration:\n\nConsider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.\n\n\n\nThe Binary Search Algorithm can be implemented in the following two ways\n\nGiven below are the pseudocodes for the approaches.\n\n// Check if x is present at mid // If x is smaller, ignore right half // If we reach here, then element was not present \"Element is not present in array\" // Check if x is present at mid // If x is smaller, ignore right half // If we reach here, then element was not present \"Element is not present in array\" // Returns index of x if it is present in arr[]. // Check if x is present at mid // If x is smaller, ignore right half // If we reach here, then element was \"Element is not present in array\" # It returns location of x in given array arr # Check if x is present at mid # If x is smaller, ignore right half # If we reach here, then the element \"Element is not present in array\" // Returns index of x if it is present in arr[] // Check if x is present at mid // If x is smaller, ignore right half // If we reach here, then element was \"Element is not present in array\" // location of x in given array arr[l..r] is present, // If the element is present at the middle // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not \"Element is not present in array\" // Check if x is present at mid // If we reach here, then \"Element is not present in array\"\n\n// location of x in given array arr[low..high] is present, // If the element is present at the middle // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present \"Element is not present in array\" // location of x in given array arr[low..high] is present, // If the element is present at the middle // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not \"Element is not present in array\" // Returns index of x if it is present in arr[low.. // If the element is present at the // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not present \"Element is not present in array\" # Returns index of x in arr if present, else -1 # If element is present at the middle itself # If element is smaller than mid, then it # can only be present in left subarray # Else the element can only be present # Element is not present in the array \"Element is not present in array\" // Returns index of x if it is present in // If the element is present at the // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not present \"Element is not present in arrau\" // location of x in given array arr[low..high] is present, // If the element is present at the middle // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not \"Element is not present in array\" // of x in given array arr[low..high] // If the element is present // If element is smaller than // mid, then it can only be // Else the element can only // be present in right subarray // We reach here when element // is not present in array \"Element is not present in array\"\n• Auxiliary Space: O(1), If the recursive call stack is considered then the auxiliary space will be O(logN).\n• None Binary search can be used as a building block for more complex algorithms used in machine learning, such as algorithms for training neural networks or finding the optimal hyperparameters for a model.\n• None It can be used for searching in computer graphics such as algorithms for ray tracing or texture mapping.\n• None It can be used for searching a database.\n• None Binary search is faster than linear search, especially for large arrays.\n• None More efficient than other searching algorithms with a similar time complexity, such as interpolation search or exponential search.\n• None Binary search is well-suited for searching large datasets that are stored in external memory, such as on a hard drive or in the cloud.\n• None The array should be sorted.\n• None Binary search requires that the data structure being searched be stored in contiguous memory locations.\n• None Binary search requires that the elements of the array be comparable, meaning that they must be able to be ordered.\n\n3. What is the time complexity of Binary Search?\n\n4. What are the prerequisites for Binary Search?\n\n5. What happens if the array is not sorted for binary search?\n\n6. Can binary search be applied to non-numeric data?\n\n7. What are some common disadvantages of Binary Search?\n\n8. When should Binary Search be used?\n\n10. Is Binary Search always the best choice for searching in a sorted array?"
    },
    {
        "link": "https://stackoverflow.com/questions/70294901/more-efficient-way-to-do-binary-search-in-c",
        "document": "I am a proponent of binary search without comparison for equality, so that every reduction step takes a single comparison (you perform a single comparison for equality in the end, when the interval has shrunk).\n\nThe idea of comparison for equality is that you can terminate the search earlier when the key is found. If the key is found at depth d, this takes 2d comparisons. The average number of comparisons is twice the average depth of the tree, and is 2 Log2(N) - 1 for a perfect tree (early termination only spares one comparison).\n\nThis is to be compared to Log2(N) without equality test. Not counting that when the key is not found, the full depth of the tree is always traversed ! Testing for equality seems a false good idea."
    },
    {
        "link": "https://codecademy.com/article/binary-search-in-cpp",
        "document": "Learn how to implement the binary search algorithm in C++ with step-by-step examples using both iterative and recursive approaches.\n\nLet’s explore how Binary Search works in practice with this method.\n\nWe’ll begin with the iterative approach, as it is more intuitive and easier to grasp for beginners.\n\nIn this article, we will study the principles of binary search and implement it iteratively and recursively in C++.\n\nBinary search is like finding a specific page in a book. Instead of starting at the beginning and flipping through every page, you open the book roughly in the middle, check if you’re too far ahead or behind, and then focus on half where the page might be. By repeatedly halving the search area, binary search quickly narrows down the possibilities, making it much faster than checking each page individually.\n\nThe Binary Search algorithm is a divide-and-conquer algorithm used to find an element within sorted datasets. Systematically halving the search range reduces the time complexity , making it significantly faster than linear search for large collections.\n\nSearch algorithms are essential for efficiently finding specific data within large datasets. Whether it’s looking for a particular number in a list or locating a file in a directory, search algorithms help reduce the time it takes to find information.\n\nFinding the data you are looking for in a data set is an important skill: get started with two common approaches. Try it for free\n\nHow to Implement Iterative Binary Search in C++?\n\nBinary search works on a dataset that is sorted in a specific order, either ascending (from smallest to largest) or descending (from largest to smallest). It starts by checking the middle element of the range. If the target value matches the middle element, the search ends. If the target is smaller than the middle element, the search continues in the left half; if it is larger, the search continues in the right half. This process repeats until the target is found or there are no more elements to check.\n\nNow, let’s walk through the steps involved in the iterative implementation of the binary search algorithm.\n• None Define the Search Range: Start with two pointers, (at the beginning of the array) and (at the end of the array), to confine the search range to .\n• None Calculate the Middle Index: Find the middle index of the current range using the formula: This approach prevents overflow issues by avoiding the direct addition of and , which could exceed the maximum value allowed by the data type and lead to incorrect calculations.\n• \n• If the middle element matches the , return as its position.\n• If the middle element is lower than the , search in the right half by setting to .\n• If the middle element exceeds the , search in the left half by setting to .\n• None Repeat Until the Range is Exhausted: Continue steps 2 and 3 until the pointer exceeds the pointer.\n\nIf this happens without finding the target, the search concludes that the target is not present in the dataset.\n\nLet’s first introduce these steps into pseudocode before diving into the implementation.\n\nThe following implementation translates the pseudocode into working C++ code, demonstrating how binary search can be applied iteratively.\n\nThe iterative version of binary search uses loops to reduce the search range gradually. It can also be implemented recursively, which more naturally highlights the divide-and-conquer approach.\n\nLet’s take a look at the recursive implementation of binary search.\n\nHow to Implement Recursive Binary Search in C++\n\nThe recursive approach follows the same principles as the iterative one, but with a key difference - it employs the power of recursion to break the problem down into smaller, more manageable subproblems.\n\nThis approach embodies the divide and conquer strategy, where the problem is repeatedly divided into halves. The solution is found by solving these smaller subproblems through self-calls, narrowing the search boundaries with each step.\n• None Base Case: If the pointer exceeds the pointer, the search range is exhausted, and the target is not present in the dataset. Return to indicate failure.\n• None Calculate the Middle Index: Compute the middle index using the formula:\n• \n• None If the middle element matches the target, return the middle index as the target’s position.\n• None If the middle element is less than the target, recursively search the right half by setting to .\n• None If the middle element is greater than the target, recursively search the left half by setting to .\n• The recursion continues, halving the search space with each call until the base case is met or the target is found.\n\nWith these steps in mind, let’s look at the pseudocode for this approach.\n\nThe output of the program will be:\n\nNow that we have covered both iterative and recursive implementations of binary search in C++, let’s analyze the binary search algorithm’s performance by finding the time and space complexity.\n\nBinary search works by halving the search space at each step. If the initial size is , after the first step, the search space is , then , , and so on. This continues until only one element remains, which happens when the search space is reduced to 1.\n\nThe number of steps it takes to reach 1 is the number of times can be divided by 2, which is . Since each step takes constant time, the overall time complexity for binary search is .\n\nIn terms of space complexity, the iterative approach requires space since it uses no additional memory, while the recursive approach has a space complexity of due to the call stack.\n\nNext, let’s look at the advantages and disadvantages of binary search in C++.\n\nAdvantages and Disadvantages of Binary Search in C++\n\nBinary search doesn’t work well with data that changes often because sorting the data before searching takes longer than the search itself.\n\nNow that we have covered the binary search algorithm, let’s explore some of its common applications.\n\nBinary search has a wide range of uses, including:\n• Finding Lower Bound and Upper Bound: Binary Search can find the positions where an element should be inserted in a sorted array.\n• Lower Bound: The position of the first occurrence of the target or where it can be inserted to maintain order.\n• Upper Bound: The position just after the last occurrence of the target or where it can be inserted to maintain order.\n• Square Root Approximation: Binary Search can approximate a number’s square root by narrowing down the range and checking the square of the middle value until it’s close enough.\n• Finding the minimum of a maximum: Binary Search is useful for problems that require finding the minimum of a maximum (or vice versa). It efficiently narrows down the possible values by halving the search space at each step, making it ideal for optimization problems with large ranges or continuous values.\n\nThis article covered the basics of binary search, including its iterative and recursive implementations and applications. Due to its efficiency, Binary search is crucial for searching through sorted datasets and solving many problems.\n\nTo deepen your understanding, try applying Binary Search to different types of problems, such as those involving sorted data. You can also explore combining Binary Search with other algorithms to improve efficiency in more complex scenarios.\n\nTo dive deeper into search algorithms and build a strong foundation in C++, explore Codecademy’s Learn C++ course, where you can practice coding exercises and master key C++ concepts."
    },
    {
        "link": "https://stackoverflow.com/questions/47050493/efficient-implementation-binary-search",
        "document": "Passing the vector as const reference as mentioned already is a major point, using another one. Not allocating the keys at all can give you some further performance, too:\n\nYou can safe one additional function call:\n\nSure, won't give you too much, but that's so simple so I mention it anyway...\n\nJust a side note: When dealing with values that cannot get negative by their nature (sizes, indices to arrays, etc) I would prefer the unsigned counter parts of the signed data types ( in your case). This will not have any impact on performance at all, as with modern two's complement architectures, exactly the same operations will be used (apart from some comparisons perhaps), just shows more clearly the intent and (part of) the valid range of the variable right away from the data type (one exception to mention: imagine you need int64_t for signed, but could do with uint32_t, and you have a 32-bit architecture, e. g. a micro controller – then you really get some minimal performance gain...)."
    },
    {
        "link": "https://medium.com/@RobuRishabh/understanding-searching-algorithms-in-c-guide-to-linear-and-binary-search-1c0db52dba9e",
        "document": "Now, let’s do some Leetcode Questions to understand above concepts better…\n\nYou are given an integer matrix with the following two properties:\n• Each row is sorted in non-decreasing order.\n• The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer , return if is in or otherwise.\n\nYou must write a solution in time complexity.\n• A 2D matrix with dimensions can be treated as a 1D array.\n• For any index in the flattened version, the corresponding row and column indices in the matrix are:\n• Start with two pointers, and (entire matrix treated as a 1D array).\n• Compare the value at this position with the target:\n• The loop ends when , indicating the target isn't in the matrix, and the function returns .\n\nKoko loves to eat bananas. There are piles of bananas, the pile has bananas. The guards have gone and will come back in hours.\n\nKoko can decide her bananas-per-hour eating speed of . Each hour, she chooses some pile of bananas and eats bananas from that pile. If the pile has less than bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer such that she can eat all the bananas within hours.\n• Write a helper function: This function determines if Koko can eat all bananas within h hours at a given speed .\n• Add to to account for complete chunks Koko can eat in an hour.\n• If (remainder exists), Koko needs an extra hour to finish the leftover bananas, so increment by 1.\n• If is less than or equal to h, return (speed is sufficient).\n\nThe apply Binary Search to minimize k, the eating speed.\n• End with (maximum pile size, as Koko cannot eat faster than the largest pile).\n• Calculate the middle value as a candidate speed.\n• Use the helper function to check if this speed allows finishing within h hours.\n• If , reduce the search range to look for a smaller speed ( ).\n• If , increase the search range to test larger speeds ( ).\n• Repeat until the range collapses ( ), at which point is the minimum speed k.\n\nSuppose an array of length sorted in ascending order is rotated between and times. For example, the array might become:\n• if it was rotated times.\n• if it was rotated times.\n\nNotice that rotating an array 1 time results in the array .\n\nGiven the sorted rotated array of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in .\n\nFollow a binary search approach to find the minimum element in a rotated sorted array. Here’s a breakdown:\n\nEdge Case: Check if the array is not rotated ( ). If true, return .\n• Use two pointers: (start of the array) and (end of the array).\n• If , the pivot is at , and you return (minimum element).\n• If , the pivot is at , and you return .\n• If (left side is sorted), the minimum must be on the right side. Update .\n• Else, the minimum is on the left side. Update .\n• If the loop exits without finding the pivot explicitly, return (though this shouldn't happen for valid input).\n\nThere is an integer array sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, is possibly rotated at an unknown pivot index ( ) such that the resulting array is (0-indexed). For example, might be rotated at pivot index and become .\n\nGiven the array after the possible rotation and an integer , return the index of if it is in , or if it is not in .\n\nYou must write an algorithm with runtime complexity.\n\nThe array is sorted but rotated around a pivot, making it tricky to apply a standard binary search. So, keeping Binary Search in mind, determine the Sorted Subarray.\n• Use two pointers ( and ) to perform binary search.\n• Check which part of the array is sorted:\n• If , the left part (from to ) is sorted.\n• Else, the right part (from to ) is sorted.\n• If the target lies within the sorted part, narrow the search to that range.\n• Otherwise, search in the unsorted part.\n• If the is found, return its index.\n• If the loop ends without finding the target, return .\n\nDry Run of the Code with Example\n• Target is not in the range .\n• Narrow search to the right:\n• Target is in the range ."
    }
]