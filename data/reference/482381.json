[
    {
        "link": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/network/esp_now.html",
        "document": "ESP-NOW is a kind of connectionless Wi-Fi communication protocol that is defined by Espressif. In ESP-NOW, application data is encapsulated in a vendor-specific action frame and then transmitted from one Wi-Fi device to another without connection. CTR with CBC-MAC Protocol (CCMP) is used to protect the action frame for security. ESP-NOW is widely used in smart light, remote controlling, sensor, etc.\n\nESP-NOW uses a vendor-specific action frame to transmit ESP-NOW data. The default ESP-NOW bit rate is 1 Mbps. Currently, ESP-NOW supports one version: v1.0. The maximum packet length supported by v1.0 devices is ESP_NOW_MAX_DATA_LEN bytes. The v1.0 devices can receive packets if the packet length is less than or equal to ESP_NOW_MAX_IE_DATA_LEN. For packets exceeding this length, the v1.0 devices will discard the packet entirely. The format of the vendor-specific action frame is as follows:\n• None Category Code: The Category Code field is set to the value (127) indicating the vendor-specific category.\n• None Organization Identifier: The Organization Identifier contains a unique identifier (0x18fe34), which is the first three bytes of MAC address applied by Espressif.\n• None Random Value: The Random Value filed is used to prevents relay attacks.\n• None Vendor Specific Content: The Vendor Specific Content contains one vendor-specific element field, x = 257(250 + 7). The format of the vendor-specific element frame is as follows:\n• None Element ID: The Element ID field is set to the value (221), indicating the vendor-specific element.\n• None Length: The length is the total length of Organization Identifier, Type, Version and Body, the maximum value is 255.\n• None Organization Identifier: The Organization Identifier contains a unique identifier (0x18fe34), which is the first three bytes of MAC address applied by Espressif.\n• None Type: The Type field is set to the value (4) indicating ESP-NOW.\n• None Version: The Version field is set to the version of ESP-NOW.\n• None Body: The Body contains the actual ESP-NOW data to be transmitted. As ESP-NOW is connectionless, the MAC header is a little different from that of standard frames. The FromDS and ToDS bits of FrameControl field are both 0. The first address field is set to the destination address. The second address field is set to the source address. The third address field is set to broadcast address (0xff:0xff:0xff:0xff:0xff:0xff).\n\nCall to initialize ESP-NOW and to de-initialize ESP-NOW. ESP-NOW data must be transmitted after Wi-Fi is started, so it is recommended to start Wi-Fi before initializing ESP-NOW and stop Wi-Fi after de-initializing ESP-NOW. When is called, all of the information of paired devices are deleted.\n\nCall to add the device to the paired device list before you send data to this device. If security is enabled, the LMK must be set. You can send ESP-NOW data via both the Station and the SoftAP interface. Make sure that the interface is enabled before sending ESP-NOW data. The maximum number of paired devices is 20, and the paired encryption devices are no more than 17, the default is 7. If you want to change the number of paired encryption devices, set CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM in the Wi-Fi component configuration menu. A device with a broadcast MAC address must be added before sending broadcast data. The range of the channel of paired devices is from 0 to 14. If the channel is set to 0, data will be sent on the current channel. Otherwise, the channel must be set as the channel that the local device is on.\n\nCall to send ESP-NOW data and to register sending callback function. It will return in sending callback function if the data is received successfully on the MAC layer. Otherwise, it will return . Several reasons can lead to ESP-NOW fails to send data. For example, the destination device does not exist; the channels of the devices are not the same; the action frame is lost when transmitting on the air, etc. It is not guaranteed that application layer can receive the data. If necessary, send back ack data when receiving ESP-NOW data. If receiving ack data timeouts, retransmit the ESP-NOW data. A sequence number can also be assigned to ESP-NOW data to drop the duplicate data. If there is a lot of ESP-NOW data to send, call to send less than or equal to 250 bytes of data once a time. Note that too short interval between sending two ESP-NOW data may lead to disorder of sending callback function. So, it is recommended that sending the next ESP-NOW data after the sending callback function of the previous sending has returned. The sending callback function runs from a high-priority Wi-Fi task. So, do not do lengthy operations in the callback function. Instead, post the necessary data to a queue and handle it from a lower priority task.\n\nSleep is supported only when ESP32 is configured as station. Call to configure Window for ESP-NOW RX at sleep. The default value is the maximum, which allowing RX all the time. If Power-saving is needed for ESP-NOW, call to configure Interval as well. Please refer to connectionless module power save to get more detail.\n• None This header file can be included with:\n• None This header file is a part of the API provided by the component. To declare that your component depends on , add the following to your CMakeLists.txt: Get the version of ESPNOW. Currently, ESPNOW supports one version: v1.0. The v1.0 devices can receive packets if the packet length is less than or equal to ESP_NOW_MAX_IE_DATA_LEN. For packets exceeding this length, the v1.0 devices will discard the packet entirely. 1. If peer_addr is not NULL, send data to the peer whose MAC address matches peer_addr 2. If peer_addr is NULL, send data to all of the peers that are added to the peer list 3. The maximum length of data must be less than ESP_NOW_MAX_DATA_LEN 4. The buffer pointed to by data argument does not need to be valid after esp_now_send returns\n• None ESP_ERR_ESPNOW_NO_MEM : out of memory, when this happens, you can delay a while before sending the next data please use esp_now_set_peer_rate_config() instead. 1. This API should be called after esp_wifi_start(). 2. This API only work when not use Wi-Fi 6 and esp_now_set_peer_rate_config() not called. 1. This API should be called after esp_wifi_start() and esp_now_init(). Get a peer whose MAC address matches peer_addr from peer list. Fetch a peer from peer list. Only return the peer which address is unicast, for the multicast/broadcast address, the function will ignore and try to find the next in the peer list.\n• None from_head -- fetch from head of list or not 1. primary master key is used to encrypt local master key Set wake window for esp_now to wake up in interval unit. 1. This configuration could work at connected status. When ESP_WIFI_STA_DISCONNECTED_PM_ENABLE is enabled, this configuration could work at disconnected status. 2. Default value is the maximum. window -- Milliseconds would the chip keep waked each interval, from 0 to 65535. ESPNOW peer MAC address that is also the MAC address of station or softap ESPNOW peer local master key that is used to encrypt data Wi-Fi channel that peer uses to send/receive ESPNOW data. If the value is 0, use the current channel which station or softap is on. Otherwise, it must be set as the channel that station or softap is on. Wi-Fi interface that peer uses to send/receive ESPNOW data ESPNOW data that this peer sends/receives is encrypted or not Number of ESPNOW peers which exist currently. Total number of ESPNOW peers, maximum value is ESP_NOW_MAX_TOTAL_PEER_NUM Number of encrypted ESPNOW peers, maximum value is ESP_NOW_MAX_ENCRYPT_PEER_NUM Maximum length of data sent in each ESPNOW transmission for v1.0 Number of ESPNOW peers which exist currently. esp_now_info is a local variable，it can only be used in the callback."
    },
    {
        "link": "https://docs.arduino.cc/tutorials/nano-esp32/esp-now",
        "document": ""
    },
    {
        "link": "https://docs.espressif.com/projects/arduino-esp32/en/latest/api/espnow.html",
        "document": "ESP-NOW is a communication protocol designed for low-power, low-latency, and high-throughput communication between ESP32 devices without the need for an access point (AP). It is ideal for scenarios where devices need to communicate directly with each other in a local network. ESP-NOW can be used for smart lights, remote control devices, sensors and many other applications. This library provides an easy-to-use interface for setting up ESP-NOW communication, adding and removing peers, and sending and receiving data packets.\n\nThe is the main class used for managing ESP-NOW communication. Initialize the ESP-NOW communication. This function must be called before using any other ESP-NOW functionalities.\n• None : Optional. Pass the pairwise master key (PMK) if encryption is enabled. Returns if initialization is successful, otherwise. End the ESP-NOW communication. This function releases all resources used by the ESP-NOW library. Returns if the operation is successful, otherwise. Get the total number of peers currently added. Returns the total number of peers, or if an error occurs. Get the number of peers using encryption. Returns the number of peers using encryption, or if an error occurs. You can register a callback function to handle incoming data from new peers using the function.\n• None : Optional. Pointer to user-defined argument to be passed to the callback function. : Information about the received packet. : Pointer to the received data. : Length of the received data. : User-defined argument passed to the callback function. The class represents a peer device in the ESP-NOW network. It is an abstract class that must be inherited by a child class that properly handles the peer connections and implements the and methods. Create an instance of the class.\n• None : Optional. Pass the local master key (LMK) if encryption is enabled. Add the peer to the ESP-NOW network. Returns if the peer is added successfully, otherwise. Remove the peer from the ESP-NOW network. Returns if the peer is removed successfully, otherwise.\n• None : Pointer to the data to be sent.\n• None : Length of the data in bytes. Returns the number of bytes sent, or if an error occurs. Get the MAC address of the peer. Set the MAC address of the peer. Get the communication channel of the peer. Set the communication channel of the peer. Get the Wi-Fi interface of the peer. Set the Wi-Fi interface of the peer. Check if the peer is using encryption. Returns if the peer is using encryption, otherwise. Set the local master key (LMK) for the peer. Callback function to handle incoming data from the peer. This is a virtual method can be implemented by the upper class for custom handling.\n• None : if the data is broadcasted, otherwise. Callback function to handle the completion of sending data to the peer. This is a virtual method can be implemented by the upper class for custom handling.\n• None : if the data is sent successfully, otherwise.\n\nSet of 2 examples of the ESP-NOW library to send and receive data using broadcast messages between multiple ESP32 devices (multiple masters, multiple slaves). This sketch demonstrates how to broadcast messages to all devices within the ESP-NOW network. This example is intended to be used with the ESP-NOW Broadcast Slave example. The master device will broadcast a message every 5 seconds to all devices within the network. This will be done using by registering a peer object with the broadcast address. The slave devices will receive the broadcasted messages and print them to the Serial Monitor. // For the MAC2STR and MACSTR macros // Creating a new class that inherits from the ESP_NOW_Peer class is required. // Constructor of the class using the broadcast address // Function to properly initialize the ESP-NOW and register the broadcast peer \"Failed to initialize ESP-NOW or register the broadcast peer\" // Function to send a message to all devices within the network // Broadcast a message to all devices within the network This sketch demonstrates how to receive broadcast messages from a master device using the ESP-NOW protocol. The master device will broadcast a message every 5 seconds to all devices within the network. The slave devices will receive the broadcasted messages. If they are not from a known master, they will be registered as a new master // For the MAC2STR and MACSTR macros // Creating a new class that inherits from the ESP_NOW_Peer class is required. // Function to print the received messages from the master // List of all the masters. It will be populated when a new master is registered \"Failed to register the new master\" // The slave will only receive broadcast messages Example of the ESP-NOW Serial library to send and receive data as a stream between 2 ESP32 devices using the serial monitor: Send data between two ESP32s using the ESP-NOW protocol in one-to-one (unicast) configuration. Note that different MAC addresses are used for different interfaces. The devices can be in different modes (AP or Station) and still communicate using ESP-NOW. The only requirement is that the devices are on the same Wi-Fi channel. Set the peer MAC address according to the device that will receive the data. Peer MAC address set to the Station MAC address of Device 2 (F4:12:FA:40:64:4C) Peer MAC address set to the AP MAC address of Device 1 (F6:12:FA:42:B6:E8) The device running this sketch will also receive and print data from any device that has its MAC address set as the peer MAC address. To properly visualize the data being sent, set the line ending in the Serial Monitor to \"Both NL & CR\". // Channel to be used by the ESP-NOW protocol // Set the MAC address of the device that will receive the data \"You can now send data to the peer device using the Serial Monitor."
    },
    {
        "link": "https://randomnerdtutorials.com/esp-now-esp32-arduino-ide",
        "document": "Learn how to use ESP-NOW to exchange data between ESP32 boards programmed with Arduino IDE. ESP-NOW is a connectionless communication protocol developed by Espressif that features short packet transmission. This protocol enables multiple devices to talk to each other in an easy way.\n\nWe have other tutorials for ESP-NOW with the ESP32:\n\nWe’ll program the ESP32 board using Arduino IDE, so before proceeding with this tutorial you should have the ESP32 add-on installed in your Arduino IDE. Follow the next guide:\n• Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux instructions)\n\nNote: we have a similar guide for the ESP8266 NodeMCU Board: Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)\n\nFor a video introduction to ESP-NOW protocol, watch the following (try the project featured in this video):\n\nStating the Espressif website, ESP-NOW is a “protocol developed by Espressif, which enables multiple devices to communicate with one another without using Wi-Fi. The protocol is similar to the low-power 2.4GHz wireless connectivity (…) . The pairing between devices is needed prior to their communication. After the pairing is done, the connection is safe and peer-to-peer, with no handshake being required.”\n\nThis means that after pairing a device with each other, the connection is persistent. In other words, if suddenly one of your boards loses power or resets, when it restarts, it will automatically connect to its peer to continue the communication.\n• Up to 250-byte payload can be carried;\n• Sending callback function that can be set to inform the application layer of transmission success or failure.\n\nESP-NOW technology also has the following limitations:\n• None Limited encrypted peers. 10 encrypted peers at the most are supported in Station mode; 6 at the most in SoftAP or SoftAP + Station mode;\n• Multiple unencrypted peers are supported, however, their total number should be less than 20, including encrypted peers;\n\nIn simple words, ESP-NOW is a fast communication protocol that can be used to exchange small messages (up to 250 bytes) between ESP32 boards.\n\nESP-NOW is very versatile and you can have one-way or two-way communication in different setups.\n\nFor example, in one-way communication, you can have scenarios like this:\n• One ESP32 board sending data to another ESP32 board\n\nThis configuration is very easy to implement and it is great to send data from one board to the other like sensor readings or ON and OFF commands to control GPIOs.\n\nOne ESP32 board sending the same or different commands to different ESP32 boards. This configuration is ideal to build something like a remote control. You can have several ESP32 boards around the house that are controlled by one main ESP32 board.\n\nThis configuration is ideal if you want to collect data from several sensors nodes into one ESP32 board. This can be configured as a web server to display data from all the other boards, for example.\n\nNote: in the ESP-NOW documentation there isn’t such thing as “sender/master” and “receiver/slave”. Every board can be a sender or receiver. However, to keep things clear we’ll use the terms “sender” and “receiver” or “master” and “slave”.\n\nWith ESP-NOW, each board can be a sender and a receiver at the same time. So, you can establish two-way communication between boards.\n\nFor example, you can have two boards communicating with each other.\n\nLearn how to: Exchange Sensor Readings with ESP-NOW Two-Way Communication.\n\nYou can add more boards to this configuration and have something that looks like a network (all ESP32 boards communicate with each other).\n\nIn summary, ESP-NOW is ideal to build a network in which you can have several ESP32 boards exchanging data with each other.\n\nTo communicate via ESP-NOW, you need to know the MAC Address of the ESP32 receiver. That’s how you know to which device you’ll send the data to.\n\nEach ESP32 has a unique MAC Address and that’s how we identify each board to send data to it using ESP-NOW (learn how to Get and Change the ESP32 MAC Address).\n\nTo get your board’s MAC Address, upload the following code.\n\nAfter uploading the code, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST/EN button. The MAC address should be printed as follows:\n\nSave your board MAC address because you’ll need it to send data to the right board via ESP-NOW.\n\nTo get you started with ESP-NOW wireless communication, we’ll build a simple project that shows how to send a message from one ESP32 to another. One ESP32 will be the “sender” and the other ESP32 will be the “receiver”.\n\nWe’ll send a structure that contains a variable of type char, int, float, and boolean. Then, you can modify the structure to send whichever variable types are suitable for your project (like sensor readings, or boolean variables to turn something on or off).\n\nFor better understanding, we’ll call “sender” to ESP32 #1 and “receiver” to ESP32 #2.\n\nHere’s what we should include in the sender sketch:\n• Register a callback function upon sending data – the function will be executed when a message is sent. This can tell us if the message was successfully delivered or not;\n• Add a peer device (the receiver). For this, you need to know the receiver MAC address;\n\nOn the receiver side, the sketch should include:\n• Register for a receive callback function ( ). This is a function that will be executed when a message is received.\n• Inside that callback function, save the message into a variable to execute any task with that information.\n\nESP-NOW works with callback functions that are called when a device receives a message or when a message is sent (you get if the message was successfully delivered or if it failed).\n\nHere’s a summary of the most essential ESP-NOW functions:\n\nFor more information about these functions read the ESP-NOW documentation at Read the Docs.\n\nHere’s the code for the ESP32 Sender board. Copy the code to your Arduino IDE, but don’t upload it yet. You need to make a few modifications to make it work for you.\n\nFirst, include the esp_now.h and WiFi.h libraries.\n\nIn the next line, you should insert the ESP32 receiver MAC address.\n\nIn our case, the receiver MAC address is: 30:AE:A4:07:0D:64, but you need to replace that variable with your own MAC address.\n\nThen, create a structure that contains the type of data we want to send. We called this structure struct_message and it contains 4 different variable types. You can change this to send other variable types.\n\nThen, create a new variable of type struct_message that is called myData that will store the variables’ values.\n\nCreate a variable of type esp_now_peer_info_t to store information about the peer.\n\nNext, define the OnDataSent() function. This is a callback function that will be executed when a message is sent. In this case, this function simply prints if the message was successfully delivered or not.\n\nIn the setup(), initialize the serial monitor for debugging purposes:\n\nAfter successfully initializing ESP-NOW, register the callback function that will be called when a message is sent. In this case, we register for the OnDataSent() function created previously.\n\nAfter that, we need to pair with another ESP-NOW device to send data. That’s what we do in the next lines:\n\nIn the loop(), we’ll send a message via ESP-NOW every 2 seconds (you can change this delay time).\n\nFirst, we set the variables values as follows:\n\nRemember that myData is a structure. Here we assign the values we want to send inside the structure. For example, the first line assigns a char, the second line assigns a random Int number, a Float, and a Boolean variable.\n\nWe create this kind of structure to show you how to send the most common variable types. You can change the structure to send other data types.\n\nFinally, send the message as follows:\n\nCheck if the message was successfully sent:\n\nThe loop() is executed every 2000 milliseconds (2 seconds).\n\nUpload the following code to your ESP32 receiver board.\n\nSimilarly to the sender, start by including the libraries:\n\nCreate a structure to receive the data. This structure should be the same defined in the sender sketch.\n\nCreate a callback function that will be called when the ESP32 receives the data via ESP-NOW. The function is called onDataRecv() and should accept several parameters as follows:\n\nWe copy the content of the incomingData data variable into the myData variable.\n\nNow, the myData structure contains several variables inside with the values sent by the ESP32 sender. To access variable a, for example, we just need to call myData.a.\n\nIn this example, we simply print the received data, but in a practical application you can print the data on a display, for example.\n\nIn the setup(), intialize the Serial Monitor.\n\nRegister for a callback function that will be called when data is received. In this case, we register for the OnDataRecv() function that was created previously.\n\nUpload the sender sketch to the sender ESP32 board and the receiver sketch to the receiver ESP32 board.\n\nNow, open two Arduino IDE windows. One for the receiver, and another for the sender. Open the Serial Monitor for each board. It should be a different COM port for each board.\n\nThis is what you should get on the sender side.\n\nAnd this is what you should get on the receiver side. Note that the Int variable changes between each reading received (because we set it to a random number on the sender side).\n\nWe tested the communication range between the two boards, and we are able to get a stable communication up to 220 meters (approximately 722 feet) in open field. In this experiment both ESP32 on-board antennas were pointing to each other.\n\nWe tried to keep our examples as simple as possible so that you better understand how everything works. There are more ESP-NOW-related functions that can be useful in your projects, like: managing peers, deleting peers, scanning for slave devices, etc… For a complete example, in your Arduino IDE, you can go to File > Examples > ESP32 > ESPNow and choose one of the example sketches.\n\nWe hope you’ve found this introduction to ESP-NOW useful. As a simple getting started example, we’ve shown you how to send data as a structure from one ESP32 to another. The idea is to replace the structure values with sensor readings or GPIO states, for example.\n\nAdditionally, with ESP-NOW, each board can simultaneously be a sender and receiver. One board can send data to multiple boards and also receive data from multiple boards.\n\nWe also have a tutorial about ESP-NOW with the ESP8266: Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE).\n\nTo learn more about the ESP32 board, make sure you take a look at our resources:"
    },
    {
        "link": "https://esp32.com/viewtopic.php?t=42486",
        "document": "Hello,I'm trying to make a very simple ESP-NOW program to help understand the basics. All of the information I've found online to date is very poor and unhelpful for newcomers trying to get the hang of this stuff.I am just trying to make a program that tells the ESP32 to transmit a single variable via an ESP-NOW broadcast (that is, to FF:FF:FF:FF:FF:FF), and I also want the same code to be able to receive such a broadcast so other ESP32 chips could participate in this as a form of two-way communication. I don't want to pick any specific ESP-32 and I don't want any master/slave stuff or identifying devices if at all possible. I'd rather take care of that through my own code.So far, what little information I can find about ESP-NOW makes it seems like it requires a struct to transmit data. And for some reason or another, the callback functions for receiving and sending seem to require pointers.I also have no clue what esp_now_recv_info means in the context of the parameter for the receiver callback. Documentation says it's a struct with three members, but doesn't go into any further detail. It's unclear what is even supposed to be sent in that parameter. There's also an 8-bit data parameter which is a pointer and I don't really get what that means.Here's the simplest code I've found that is closest to what I'm looking for so far:Note that the receiver callback here receives an 8-bit value in the first parameter rather than a receiver info value. This gave me an error when I tried compiling it. In loop(), you can also see where the broadcastAddr (an 8-bit array) is sent. Strangely, the compiler gave me no errors when I fixed the receiver parameter even through I didn't change the arguments given to esp_now_send. Keep in mind that this program, which said it's for ESP32 ESP-NOW, was posted just a few months ago this year. So it shouldn't even be out of date or anything. Not sure if they made a mistake or what.Can anyone help me figure out how to make the most bare-bones ESP-NOW program possible that is two-way and uses indiscriminate broadcasting? Can you explain what the parameters do on the callbacks? Can I send individual variables rather than structs? Thanks."
    },
    {
        "link": "https://randomnerdtutorials.com/guide-for-oled-display-with-arduino",
        "document": "This article shows how to use the SSD1306 0.96 inch I2C OLED display with the Arduino. We’ll show you some features of the OLED display, how to connect it to the Arduino board, and how to write text, draw shapes and display bitmap images. Lastly, we’ll build a project example that displays temperature and humidity readings.\n\nThe organic light-emitting diode (OLED) display that we’ll use in this tutorial is the SSD1306 model: a monocolor, 0.96-inch display with 128×64 pixels as shown in the following figure.\n\nThe OLED display doesn’t require backlight, which results in a very nice contrast in dark environments. Additionally, its pixels consume energy only when they are on, so the OLED display consumes less power when compared with other displays.\n\nThe model we’re using here has only four pins and communicates with the Arduino using I2C communication protocol. There are models that come with an extra RESET pin. There are also other OLED displays that communicate using SPI communication.\n\nBecause the OLED display uses I2C communication protocol, wiring is very simple. You just need to connect to the Arduino Uno I2C pins as shown in the table below.\n\nIf you’re using a different Arduino board, make sure you check the correct I2C pins:\n\nTo control the OLED display you need the adafruit_SSD1306.h and the adafruit_GFX.h libraries. Follow the next instructions to install those libraries.\n\n1. Open your Arduino IDE and go to Sketch > Include Library > Manage Libraries. The Library Manager should open.\n\n2. Type “SSD1306” in the search box and install the SSD1306 library from Adafruit.\n\n3. After installing the SSD1306 library from Adafruit, type “GFX” in the search box and install the library.\n\n4. After installing the libraries, restart your Arduino IDE.\n\nTips for writing text using these libraries\n\nHere’s some functions that will help you handle the OLED display library to write text or draw simple graphics.\n• – all pixels are off\n• – set the font size, supports sizes from 1 to 8\n• – call this method for the changes to make effect\n\nAfter wiring the OLED display to the Arduino and installing all required libraries, you can use one example from the library to see if everything is working properly.\n\nIn your Arduino IDE, go to File > Examples > Adafruit SSD1306 and select the example for the display you’re using.\n\nThe following code should load:\n\nIf your OLED doesn’t have a RESET pin, you should set the OLED_RESET variable to -1 as shown below:\n\nUpload the code to your Arduino board. Don’t forget to select the right board and COM port in the Tools menu.\n\nYou should get a series of different animations in the OLED as shown in the following short video.\n\nIf your OLED display is not showing anything:\n• Check that the OLED display is properly wired to the Arduino\n• Double-check the OLED display I2C address: with the OLED connected to the Arduino, upload this code and check the I2C address in the Serial Monitor\n\nYou should change the OLED address in the following line, if necessary. In our case, the address is 0x3C.\n\nThe Adafruit library for the OLED display comes with several functions to write text. In this section, you’ll learn how to write and scroll text using the library functions.\n\nThe following sketch displays Hello, world! message in the OLED display.\n\nAfter uploading the code, this is what you’ll get in your OLED:\n\nLet’s take a quick look on how the code works.\n\nFirst, you need to import the necessary libraries. The Wire library to use I2C and the Adafruit libraries to write to the display: Adafruit_GFX and Adafruit_SSD1306.\n\nThen, you define your OLED width and height. In this example, we’re using a 128×64 OLED display. If you’re using other sizes, you can change that in the SCREEN_WIDTH, and SCREEN_HEIGHT variables.\n\nThen, initialize a display object with the width and height defined earlier with I2C communication protocol (&Wire).\n\nThe (-1) parameter means that your OLED display doesn’t have a RESET pin. If your OLED display does have a RESET pin, it should be connected to a GPIO. In that case, you should pass the GPIO number as a parameter.\n\nIn the setup(), initialize the Serial Monitor at a baud raute of 115200 for debugging purposes.\n\nInitialize the OLED display with the begin() method as follows:\n\nThis snippet also prints a message on the Serial Monitor, in case we’re not able to connect to the display.\n\nIn case you’re using a different OLED display, you may need to change the OLED address. In our case, the address is 0x3C.\n\nIf this address doesn’t work, you can run an I2C scanner sketch to find your OLED address. You can find the I2C scanner sketch here.\n\nAfter initializing the display, add a two second delay, so that the OLED has enough time to initialize before writing text:\n\nAfter initializing the display, clear the display buffer with the clearDisplay() method:\n\nBefore writing text, you need to set the text size, color and where the text will be displayed in the OLED.\n\nSet the font size using the setTextSize() method:\n\nSet the font color with the setTextColor() method:\n\nDefine the position where the text starts using the setCursor(x,y) method. In this case, we’re setting the text to start at the (0,10) coordinates.\n\nFinally, you can send the text to the display using the println() method, as follows:\n\nThen, you need to call the display() method to actually display the text on the screen.\n\nThe Adafruit OLED library provides useful methods to easily scroll text.\n• : scroll text from left to right\n• : scroll text from right to left\n• : scroll text from left bottom corner to right upper corner\n• : scroll text from right bottom corner to left upper corner\n\nThe following sketch implements those methods.\n\nThe text scrolls as shown in the following short video.\n\nThe Adafruit GFX library allows us to use some alternate fonts besides the built-in fonts. It allows you to chose between Serif, Sans, and Mono. Each font is available in bold, italic and in different sizes.\n\nThe sizes are set by the actual font. So, the setTextSize() method doesn’t work with these fonts. The fonts are available in 9, 12, 18 and 24 point sizes and also contain 7-bit characters (ASCII codes) (described as 7b in the font name).\n\nYou can chose from the next selection of fonts:\n\nThe fonts that work better with the OLED display are the 9 and 12 points size.\n\nTo use one of those fonts, first you need to include it in your sketch, for example:\n\nNext, you just need to use the setFont() method and pass as argument, the specified font:\n\nAfter specifying the font, all methods to write text will use that font. To get back to use the original font, you just need to call the setFont() method with no arguments:\n\nUpload the next sketch to your board:\n\nNow, your display prints the “Hello, world!” message in FreeSerif font.\n\nThe Adafruit OLED library provides useful methods to draw pixels, lines and shapes. Let’s take a quick look at those methods.\n\nTo draw a pixel in the OLED display, you can use the drawPixel(x, y, color) method that accepts as arguments the x and y coordinates where the pixel appears, and color. For example:\n\nUse the drawLine(x1, y1, x2, y2, color) method to create a line. The (x1, y1) coordinates indicate the start of the line, and the (x2, y2) coordinates indicates where the line ends. For example:\n\nThe drawRect(x, y, width, height, color) provides an easy way to draw a rectangle. The (x, y) coordinates indicate the top left corner of the rectangle. Then, you need to specify the width, height and color:\n\nYou can use the fillRect(x, y, width, height, color) to draw a filled rectangle. This method accepts the same arguments as drawRect().\n\nThe library also provides methods to displays rectangles with round corners: drawRoundRect() and fillRoundRect(). These methods accepts the same arguments as previous methods plus the radius of the corner. For example:\n\nTo draw a circle use the drawCircle(x, y, radius, color) method. The (x,y) coordinates indicate the center of the circle. You should also pass the radius as an argument. For example:\n\nIn the same way, to build a filled circle, use the fillCircle() method with the same arguments:\n\nUse the the drawTriangle(x1, y1, x2, y2, x3, y3, color) method to build a triangle. This method accepts as arguments the coordinates of each corner and the color.\n\nUse the fillTriangle() method to draw a filled triangle.\n\nThe library provides an additional method that you can use with shapes or text: the invertDisplay() method. Pass true as argument to invert the colors of the screen or false to get back to the original colors.\n\nIf you call the following command after defining the triangle:\n\nYou’ll get an inverted triangle as follows:\n\nUpload the following sketch that implements each snippet of code we’ve covered previously and goes through all the shapes.\n\nYou can display 128×64 bitmap monocolor images on the OLED display.\n\nFirst, use an imaging program to resize a photo or picture and save it as monochrome bitmap. If you’re on a Windows PC, you can use Paint.\n\nThen, use a Image to C Array converter to convert the image into an array. I’ve used LCD Image Converter.\n\nRun the program and start with a new image. Go to Image > Import and select the bitmap image you’ve created earlier.\n\nGo to Options > Conversion and in the Prepare tab, select the following options:\n\nGo to the Image tab and select the following options:\n\nThen, click OK. Finally, in the main menu, go to File > Convert. A new file with .c extension should be saved. That file contains the C array for the image. Open that file with a text editor, and copy the array.\n\nIn our case, this is the array that we get:\n\nCopy your array to the sketch. Then, to display the array, use the drawBitmap() method that accepts the following arguments (x, y, image array, image width, image height, rotation). The (x, y) coordinates define where the image starts to be displayed.\n\nCopy the code below to display your bitmap image in the OLED.\n\nAfter uploading the code, this is what we get on the display.\n\nDisplay Temperature and Humidity in the OLED Display with Arduino\n\nIn this section we’ll build a project that displays temperature and humidity readings on the OLED display. We’ll get temperature and humidity using the DHT11 temperature and humidity sensor. If you’re not familiar with the DHT11 sensor, read the following article:\n• Complete Guide for DHT11/DHT22 Humidity and Temperature Sensor With Arduino\n\nTo complete this project you need the following components:\n\nYou can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!\n\nAssemble the circuit by following the next schematic diagram.\n\nNote: if you’re using a module with a DHT sensor, it normally comes with only three pins. The pins should be labeled so that you know how to wire them. Additionally, many of these modules already come with an internal pull up resistor, so you don’t need to add one to the circuit.\n\nBefore proceeding, make sure you have installed the“adafruit_GFX.h” and the “adafruit_SSD1306.h” libraries to control the OLED display.\n\nFor this project you also need two aditional libraries to read from the DHT sensor: the DHT library and the Adafruit_Sensor library. Follow the next steps to install those libraries\n\n1. Open your Arduino IDE and go to Sketch > Include Library > Manage Libraries. The Library Manager should open.\n\n2. Search for “DHT” on the Search box and install the DHT library from Adafruit.\n\n3. After installing the DHT library from Adafruit, type “Adafruit Unified Sensor” in the search box. Scroll all the way down to find the library and install it.\n\nAfter installing all the necessary libraries, you can upload the following code.\n\nRead this section if you want to learn how the code works. Otherwise, you can skip to the “Demonstration” section.\n\nThe code starts by including the necessary libraries. The Wire, Adafruit_GFX and Adafruit_SSD1306 are used to interface with the OLED display. The Adafruit_Sensor and the DHT libraries are used to interface with the DHT22 or DHT11 sensors.\n\nThen, define your OLED display dimensions. In this case, we’re using a 128×64 pixel display.\n\nThen, initialize a display object with the width and height defined earlier with I2C communication protocol (&Wire).\n\nThe (-1) parameter means that your OLED display doesn’t have a RESET pin. If your OLED display does have a RESET pin, it should be connected to a GPIO. In that case, you should pass the GPIO number as a parameter.\n\nThen, define the DHT sensor type you’re using. If you’re using a DHT11 you don’t need to change anything on the code. If you’re using another sensor, just uncomment the sensor you’re using and comment the others.\n\nInitialize a DHT sensor object with the pin and type defined earlier.\n\nIn the setup(), initialize the serial monitor for debugging purposes.\n\nIn this case, the address of the OLED display we’re using is 0x3C. If this address doesn’t work, you can run an I2C scanner sketch to find your OLED address. You can find the I2C scanner sketch here.\n\nAdd a delay to give time for the display to initialize, clear the display and set the text color to white:\n\nIn the loop() is where we read the sensor and display the temperature and humidity on the display.\n\nGet temperature and humidity readings from DHT\n\nThe temperature and humidity are saved on the t and h variables, respectively. Reading temperature and humidity is as simple as using the readTemperature() and readHumidity() methods on the dht object.\n\nIn case we are not able to get the readings, display an error message:\n\nIf you get that error message, read our troubleshooting guide: how to fix “Failed to read from DHT sensor”.\n\nThe following lines display the temperature on the OLED display.\n\nWe use the setTextSize() method to define the font size, the setCursor() sets where the text should start being displayed and the print() method is used to write something on the display.\n\nTo print the temperature and humidity you just need to pass their variables to the print() method as follows:\n\nThe “Temperature” label is displayed in size 1, and the actual reading is displayed in size 2.\n\nTo display the º symbol, we use the Code Page 437 font. For that, you need to set the cp437 to true as follows:\n\nThen, use the write() method to display your chosen character. The º symbol corresponds to character 167.\n\nA similar approach is used to display the humidity:\n\nDon’t forget that you need to call display.display() at the end, so that you can actually display something on the OLED.\n\nAfter wiring the circuit and uploading the code, the OLED display shows the temperature and humidity readings. The sensor readings are updated every five seconds.\n\nIf your DHT sensor fails to get the readings or you get the message “Failed to read from DHT sensor”, read our DHT Troubleshooting Guide to help you solve that problem.\n\nIf you get the “SSD1306 allocation failed” error or if the OLED is not displaying anything in the screen, it can be one of the following issues:\n\nThe I2C address for the OLED display we are using is 0x3C. However, yours may be different. So, make sure you check your display I2C address using an I2C scanner sketch.\n\nPlease make sure that you have the SDA and SCL pins of the OLED display wired correctly.\n\nThe OLED display provides an easy and inexpensive way to display text or graphics using an Arduino. We hope you’ve found this guide and the project example useful.\n\nIf you like Arduino, make sure you check all our Arduino resources:\n\nDon’t miss our next tutorials and projects! Make sure you subscribe the RNT blog."
    },
    {
        "link": "https://learn.adafruit.com/monochrome-oled-breakouts/arduino-library-and-examples",
        "document": "For all of the different kinds of small OLED monochrome displays, you'll need to install the Arduino libraries. The code we have is for any kind of Arduino, if you're using a different microcontroller, the code is pretty simple to adapt, the interface we use is basic bit-twiddling SPI or I2C\n\nUsing these OLEDs with Arduino sketches requires that two libraries be installed: Adafruit_SSD1306, which handles the low-level communication with the hardware, and Adafruit_GFX, which builds atop this to add graphics functions like lines, circles and text. In recent versions of the Arduino IDE software (1.6.2 and later), this is most easily done through the Arduino Library Manager.\n\nIf using an earlier version of the Arduino IDE (prior to 1.8.10), also locate and install Adafruit_BusIO (newer versions will install this dependency automatically). We also have a great tutorial on Arduino library installation here:\n\nhttp://learn.adafruit.com/adafruit-all-about-arduino-libraries-install-use\n\nAfter installing the Adafruit_SSD1306 and Adafruit_GFX library, restart the Arduino IDE. You should now be able to access the sample code by navigating through menus in this order: File→Examples→Adafruit_SSD1306→SSD1306...\n\nAfter you've finished wiring the display as indicated on the following pages, load the example sketch to demonstrate the capabilities of the library and display. The OLED SSD1306 driver is based on the Adafruit GFX library which provides all the underlying graphics functions such as drawing pixels, lines, circles, etc. For more details about what you can do with the OLED check out the GFX library tutorial\n\nYou can create bitmaps to display easily with the LCD assistant software. First make your image using any kind of graphics software such as photoshop or Paint and save as a Monochrome Bitmap (bmp)\n\nSelect the following options (You might also want to try Horizontal if Vertical is not coming out right)\n\n\n\nand import your monochrome bitmap image. Save the output to a cpp\n\nYou can use the output directly with our example code\n\nimage2cpp was created by GitHub user javl and provides a handy way to create bitmaps without installing any additional software. Just visit https://javl.github.io/image2cpp/, upload an image, put in any settings that you would like to use, select a format and generate the code. You can copy the code right into your sketch. If you're interested, you can view the source in their GitHub repository."
    },
    {
        "link": "https://forum.arduino.cc/t/document-for-ssd1306-commands/993269",
        "document": "The Adafruit_GFX library for Arduino provides a common syntax and set of graphics functions for all of our LCD and OLED displays."
    },
    {
        "link": "https://instructables.com/Arduino-and-the-SSD1306-OLED-I2C-128x64-Display",
        "document": "About: Retired teacher of computing - started 1967 with FORTRAN IV. I now play with development boards such as Raspberry Pi, Pico, Arduino, micro:bit and Adafruit CircuitPython boards like the Insybitsy M4 and Circui… Most Arduino owners soon decide that they would like to output text and results to a screen from their projects. Many opt for a two-line 1602 LCD display. They are easily available, inexpensive and there are plenty of guides to help set them up. Most go for the simple version that ties up many of their digital I/O lines and buy a device which is built for text but cannot display a graph or geometrical shape. The SSD1306 may be small, only 0.96 inch on the diagonal, but it is much more useful and only SCL and SDA have to be connected. This OLED (organic light-emitting diode) device is a very clear, inexpensive mono digital display and is a very useful addition to an Arduino user’s collection of parts. I would not be without it and have bought several as they are cheap enough to leave embedded in projects. It is widely available from a variety of outlets, including Adafruit, who provide many of the libraries we will be using. It is an I2C device, and only uses two of the data pins, A4 and A5. It can be powered directly from the Arduino with 5V and GND. It will also run from 3V devices. In this Instructable I am going to show you how to set it up and load the essential Libraries, explain the commands needed to program it and provide three example sketches:\n\nIf you are using an UNO or a Nano connect VCC to 5V, GND to GND, SDA to pin A4 and SCL to pin A5. If you are not using an Arduino UNO the SDA and SCL connections might be on different pins. On a MEGA or Leonardo SDA goes to pin 20 and SCL to pin 21. Take care as some SSD1306 boards have their pins in a different order – use the labels not the relative positions.\n\nMany drawing and writing primitives are provided: single pixel plotting, lines, circles, triangles, rectangles (with square and rounded corners), and corresponding filled shapes. Text and numeric values, may be placed anywhere on the screen in a variety of sizes. Bitmapped shapes can be scrolled or moved about the screen and the whole screen can be rotated. Points are defined by their Cartesian co-ordinates, (x, y). The origin (0, 0) is at the top left of the screen. Increasing the y value moves down the screen. The addressable dimensions of the SSD1306 screen are 128 pixels left to right (0, 1, 2, …, 127) and 64 pixels from top to bottom (0, 1, 2, …, 63). The pixel in the bottom right corner is (127, 63). All the primitives have parameters which should be unsigned 16-bit integers (uint16_t). (x0, y0) and (x1, y1) would define the first two positions, while h is the height and w the width of an object. A radius is r. All dimensions are in pixels. The colour is specified by c, SSD1306_WHITE or SSD1306_BLACK. These are based on the system used for printing to the Serial monitor with print() and println(). The font included with the library is 5 pixels wide and 7 pixels tall but prints into a 6x8 pixel space. None of these instructions will produce a change on the screen without a display.display(); method. If your script does not appear to be working check you have included this line at the bottom of your screen changing code.\n\nI'm going to provide three examples to help you get started. The first illustrates the graphics. You do not need to type in the sketch a download will be provided for each sketch. The top of the program appears above. You do not need to include the SPI.h if you are using a I2C device, but Adafruit have supplied dual interface boards so include it in their example sketch. When writing your own sketches you need all the lines down to the initialise variables comment to load the libraries and set up communication with the SSD1306 board.\n\nThis is the main loop which does all the heavy lifting. The first half checks to see if it is time to update the second counter at the top right of the screen. Most of the time it skips the rest but every second it carries out the update. This is a very useful method of appearing to be doing two things at once, especially when one action needs to be carried out much more frequently than the other. The second half reads the pot, calculates the percent value and updates the various parts of the screen. This is quite time consuming. Please note that the whole screen is never cleared and re-drawn. I hope you have found this Instructable useful and that you find the little SSD1306 display as useful as I do. There is more information and some more of my programming examples and tips on LCD displays with Arduinos here:"
    },
    {
        "link": "https://github.com/adafruit/Adafruit_SSD1306",
        "document": "This is a library for our Monochrome OLEDs based on SSD1306 drivers\n\nPick one up today in the adafruit shop! ------> http://www.adafruit.com/category/63_98\n\nThese displays use I2C or SPI to communicate, 2 to 5 pins are required to interface.\n\nAdafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit!\n\nWritten by Limor Fried/Ladyada for Adafruit Industries, with contributions from the open source community. Scrolling code contributed by Michael Gregg. Dynamic buffer allocation based on work by Andrew Canaday. BSD license, check license.txt for more information. All text above must be included in any redistribution\n\nPreferred installation method is to use the Arduino IDE Library Manager. To download the source from Github instead, click \"Clone or download\" above, then \"Download ZIP.\" After uncompressing, rename the resulting folder Adafruit_SSD1306. Check that the Adafruit_SSD1306 folder contains Adafruit_SSD1306.cpp and Adafruit_SSD1306.h.\n\nYou will also have to install the Adafruit GFX library which provides graphics primitves such as lines, circles, text, etc. This also can be found in the Arduino Library Manager, or you can get the source from https://github.com/adafruit/Adafruit-GFX-Library\n• Added define to opt-out of including splash images in and drawing to display during .\n• new #defines for SSD1306_BLACK, SSD1306_WHITE and SSD1306_INVERSE that match existing #define naming scheme and won't conflict with common color names\n• old #defines for BLACK, WHITE and INVERSE kept for backwards compat (opt-out with #define NO_ADAFRUIT_SSD1306_COLOR_COMPATIBILITY)\n• Display dimensions are now specified in the constructor...you no longer need to edit the .h file for different screens (though old sketches can continue to work that way).\n• SPI transactions are used and SPI bitrate can be specified (both require Arduino 1.6 or later).\n• SPI and Wire (I2C) interfaces other than the defaults are supported.\n• RTduino : RTduino is the Arduino ecosystem compatibility layer for RT-Thread RTOS BSPs"
    }
]