[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.timespan?view=net-9.0",
        "document": "The following example instantiates a TimeSpan object that represents the difference between two dates. It then displays the TimeSpan object's properties.\n\nFor more information about this API, see Supplemental API remarks for TimeSpan."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-timespan",
        "document": "This article provides supplementary remarks to the reference documentation for this API.\n\nA TimeSpan object represents a time interval (duration of time or elapsed time) that is measured as a positive or negative number of days, hours, minutes, seconds, and fractions of a second. The TimeSpan structure can also be used to represent the time of day, but only if the time is unrelated to a particular date. Otherwise, the DateTime or DateTimeOffset structure should be used instead. (For more information about using the TimeSpan structure to reflect the time of day, see Choosing Between DateTime, DateTimeOffset, TimeSpan, and TimeZoneInfo.)\n\nThe largest unit of time that the TimeSpan structure uses to measure duration is a day. Time intervals are measured in days for consistency, because the number of days in larger units of time, such as months and years, varies.\n\nThe value of a TimeSpan object is the number of ticks that equal the represented time interval. A tick is equal to 100 nanoseconds, or one ten-millionth of a second. The value of a TimeSpan object can range from TimeSpan.MinValue to TimeSpan.MaxValue.\n\nYou can instantiate a TimeSpan value in a number of ways:\n• None By calling its implicit parameterless constructor. This creates an object whose value is TimeSpan.Zero, as the following example shows.\n• None By calling one of its explicit constructors. The following example initializes a TimeSpan value to a specified number of hours, minutes, and seconds.\n• None By calling a method or performing an operation that returns a TimeSpan value. For example, you can instantiate a TimeSpan value that represents the interval between two date and time values, as the following example shows. DateTime departure = new DateTime(2010, 6, 12, 18, 32, 0); DateTime arrival = new DateTime(2010, 6, 13, 22, 47, 0); TimeSpan travelTime = arrival - departure; Console.WriteLine($\"{arrival} - {departure} = {travelTime}\"); // The example displays the following output: // 6/13/2010 10:47:00 PM - 6/12/2010 6:32:00 PM = 1.04:15:00 let departure = DateTime(2010, 6, 12, 18, 32, 0) let arrival = DateTime(2010, 6, 13, 22, 47, 0) let travelTime = arrival - departure printfn $\"{arrival} - {departure} = {travelTime}\" // The example displays the following output: // 6/13/2010 10:47:00 PM - 6/12/2010 6:32:00 PM = 1.04:15:00 Dim departure As DateTime = #06/12/2010 6:32PM# Dim arrival As DateTime = #06/13/2010 10:47PM# Dim travelTime As TimeSpan = arrival - departure Console.WriteLine(\"{0} - {1} = {2}\", arrival, departure, travelTime) ' The example displays the following output: ' 6/13/2010 10:47:00 PM - 6/12/2010 6:32:00 PM = 1.04:15:00 You can also initialize a TimeSpan object to a zero time value in this way, as the following example shows. Random rnd = new Random(); TimeSpan timeSpent = TimeSpan.Zero; timeSpent += GetTimeBeforeLunch(); timeSpent += GetTimeAfterLunch(); Console.WriteLine($\"Total time: {timeSpent}\"); TimeSpan GetTimeBeforeLunch() { return new TimeSpan(rnd.Next(3, 6), 0, 0); } TimeSpan GetTimeAfterLunch() { return new TimeSpan(rnd.Next(3, 6), 0, 0); } // The example displays output like the following: // Total time: 08:00:00 open System let rnd = Random() let getTimeBeforeLunch () = TimeSpan(rnd.Next(3, 6), 0, 0) let getTimeAfterLunch() = TimeSpan(rnd.Next(3, 6), 0, 0) do let timeSpent = TimeSpan.Zero let timeSpent = timeSpent + getTimeBeforeLunch () let timeSpent = timeSpent + getTimeAfterLunch () printfn $\"Total time: {timeSpent}\" // The example displays output like the following: // Total time: 08:00:00 Module Example Dim rnd As New Random() Public Sub Main() Dim timeSpent As TimeSpan = TimeSpan.Zero timeSpent += GetTimeBeforeLunch() timeSpent += GetTimeAfterLunch() Console.WriteLine(\"Total time: {0}\", timeSpent) End Sub Private Function GetTimeBeforeLunch() As TimeSpan Return New TimeSpan(rnd.Next(3, 6), 0, 0) End Function Private Function GetTimeAfterLunch() As TimeSpan Return New TimeSpan(rnd.Next(3, 6), 0, 0) End Function End Module ' The example displays output like the following: ' Total time: 08:00:00 TimeSpan values are returned by arithmetic operators and methods of the DateTime, DateTimeOffset, and TimeSpan structures.\n• None By parsing the string representation of a TimeSpan value. You can use the Parse and TryParse methods to convert strings that contain time intervals to TimeSpan values. The following example uses the Parse method to convert an array of strings to TimeSpan values. string[] values = { \"12\", \"31.\", \"5.8:32:16\", \"12:12:15.95\", \".12\"}; foreach (string value in values) { try { TimeSpan ts = TimeSpan.Parse(value); Console.WriteLine($\"'{value}' --> {ts}\"); } catch (FormatException) { Console.WriteLine($\"Unable to parse '{value}'\"); } catch (OverflowException) { Console.WriteLine($\"'{value}' is outside the range of a TimeSpan.\"); } } // The example displays the following output: // '12' --> 12.00:00:00 // Unable to parse '31.' // '5.8:32:16' --> 5.08:32:16 // '12:12:15.95' --> 12:12:15.9500000 // Unable to parse '.12' let values = [| \"12\"; \"31.\"; \"5.8:32:16\"; \"12:12:15.95\"; \".12\" |] for value in values do try let ts = TimeSpan.Parse value printfn $\"'{value}' --> {ts}\" with | :? FormatException -> printfn $\"Unable to parse '{value}'\" | :? OverflowException -> printfn $\"'{value}' is outside the range of a TimeSpan.\" // The example displays the following output: // '12' --> 12.00:00:00 // Unable to parse '31.' // '5.8:32:16' --> 5.08:32:16 // '12:12:15.95' --> 12:12:15.9500000 // Unable to parse '.12' Dim values() As String = {\"12\", \"31.\", \"5.8:32:16\", \"12:12:15.95\", \".12\"} For Each value As String In values Try Dim ts As TimeSpan = TimeSpan.Parse(value) Console.WriteLine(\"'{0}' --> {1}\", value, ts) Catch e As FormatException Console.WriteLine(\"Unable to parse '{0}'\", value) Catch e As OverflowException Console.WriteLine(\"'{0}' is outside the range of a TimeSpan.\", value) End Try Next ' The example displays the following output: ' '12' --> 12.00:00:00 ' Unable to parse '31.' ' '5.8:32:16' --> 5.08:32:16 ' '12:12:15.95' --> 12:12:15.9500000 ' Unable to parse '.12' In addition, you can define the precise format of the input string to be parsed and converted to a TimeSpan value by calling the ParseExact or TryParseExact method.\n\nYou can add and subtract time durations either by using the Addition and Subtraction operators, or by calling the Add and Subtract methods. You can also compare two time durations by calling the Compare, CompareTo, and Equals methods. The TimeSpan structure also includes the Duration and Negate methods, which convert time intervals to positive and negative values,\n\nThe range of TimeSpan values is MinValue to MaxValue.\n\nA TimeSpan value can be represented as [-]d.hh:mm:ss.ff, where the optional minus sign indicates a negative time interval, the d component is days, hh is hours as measured on a 24-hour clock, mm is minutes, ss is seconds, and ff is fractions of a second. That is, a time interval consists of a positive or negative number of days without a time of day, or a number of days with a time of day, or only a time of day.\n\nBeginning with .NET Framework 4, the TimeSpan structure supports culture-sensitive formatting through the overloads of its ToString method, which converts a TimeSpan value to its string representation. The default TimeSpan.ToString() method returns a time interval by using an invariant format that is identical to its return value in previous versions of .NET Framework. The TimeSpan.ToString(String) overload lets you specify a format string that defines the string representation of the time interval. The TimeSpan.ToString(String, IFormatProvider) overload lets you specify a format string and the culture whose formatting conventions are used to create the string representation of the time interval. TimeSpan supports both standard and custom format strings. (For more information, see Standard TimeSpan Format Strings and Custom TimeSpan Format Strings.) However, only standard format strings are culture-sensitive.\n\nIn some cases, code that successfully formats TimeSpan values in .NET Framework 3.5 and earlier versions fails in .NET Framework 4. This is most common in code that calls a <TimeSpan_LegacyFormatMode> element method to format a TimeSpan value with a format string. The following example successfully formats a TimeSpan value in .NET Framework 3.5 and earlier versions, but throws an exception in .NET Framework 4 and later versions. Note that it attempts to format a TimeSpan value by using an unsupported format specifier, which is ignored in .NET Framework 3.5 and earlier versions.\n\nIf you cannot modify the code, you can restore the legacy formatting of TimeSpan values in one of the following ways:\n• None By creating a configuration file that contains the <TimeSpan_LegacyFormatMode> element. Setting this element's attribute to restores legacy TimeSpan formatting on a per-application basis.\n• None By setting the \"NetFx40_TimeSpanLegacyFormatMode\" compatibility switch when you create an application domain. This enables legacy TimeSpan formatting on a per-application-domain basis. The following example creates an application domain that uses legacy TimeSpan formatting. Module Example3 Public Sub Main() Dim appSetup As New AppDomainSetup() appSetup.SetCompatibilitySwitches({\"NetFx40_TimeSpanLegacyFormatMode\"}) Dim legacyDomain As AppDomain = AppDomain.CreateDomain(\"legacyDomain\", Nothing, appSetup) legacyDomain.ExecuteAssembly(\"ShowTimeSpan.exe\") End Sub End Module When the following code executes in the new application domain, it reverts to legacy TimeSpan formatting behavior. using System; public class Example3 { public static void Main() { TimeSpan interval = DateTime.Now - DateTime.Now.Date; string msg = String.Format(\"Elapsed Time Today: {0:d} hours.\", interval); Console.WriteLine(msg); } } // The example displays the following output: // Elapsed Time Today: 01:40:52.2524662 hours. open System let interval = DateTime.Now - DateTime.Now.Date printfn $\"Elapsed Time Today: {interval:d} hours.\" // The example displays the following output: // Elapsed Time Today: 01:40:52.2524662 hours. Module Example4 Public Sub Main() Dim interval As TimeSpan = Date.Now - Date.Now.Date Dim msg As String = String.Format(\"Elapsed Time Today: {0:d} hours.\", interval) Console.WriteLine(msg) End Sub End Module ' The example displays output like the following: ' Elapsed Time Today: 01:40:52.2524662 hours."
    },
    {
        "link": "https://influxdata.com/blog/detailed-c-timespan-guide",
        "document": "Ah, the C# TimeSpan struct. It’s quite a humble type and somewhat underutilized, if my anecdotal experience counts for anything. Despite that, the C# TimeSpan type has enormous potential to make your code more readable and robust.\n\nDon’t believe me? Well, read the post, and you’ll learn how a type that does the (seemingly) simplest of jobs—representing a time duration—can be so awesome. Here’s how this will go:\n• We’ll open the post with a definition and explanation of TimeSpan. You’ll learn what this type is and what kinds of problems it solves.\n• Then, you’ll learn about the benefits of using TimeSpan over other alternatives.\n• Next, it’s time to get practical: you’ll learn how to get started with TimeSpan, including its basic syntax, ways to initialize it, and an explanation of its key methods and properties.\n• Finally, we’ll cover some use cases for this type and some of the most common errors you might face.\n\nWhat is a TimeSpan in C#?\n\nLet’s start by saying that, technically—maybe a bit pedantically—“C# TimeSpan” isn’t a thing. The System.TimeSpan struct is a type in .NET, and its use isn’t restricted to C#; you can also leverage it with any of the .NET languages, such as VB.NET and F#. (But, yes, this post caters to C# programmers, so all examples will be in that language.)\n\nSo, what is theSystem.TimeSpan struct? It’s a type from the .NET BCL (Base Class Library) representing a time interval. Do you ever need to represent the concept of “five minutes” or “two hours”? If that’s the case, TimeSpan is what you’re looking for.\n\nHere’s what I consider the top benefits of using TimeSpan:\n• It reduces the likelihood of bugs\n• The code becomes more readable\n• It provides useful functionality related to time\n\nBut couldn’t you simply use a numerical type—like int—to represent a duration?\n\nYes, but such an approach has several downsides. First, it results in more error-prone code. If you use a primitive type to represent a time interval in C#, you cannot express the unit of measurement you mean.\n\nIf a certain portion of the code “thinks” the duration is in minutes while another assumes it’s in seconds, such a mismatch will cause a bug. Yes, you could use comments and/or naming conventions to make such mismatches less likely, but those can only go so far.\n\nAnother example: let’s say you have a method that takes two integers as parameters, one representing an identifier and the other a duration. A common error is to pass the two parameters in the wrong order. Such errors are easy to miss during code reviews and would result in a bug. However, if you had used a TimeSpan for the time interval, the error would have been impossible: the compiler would prevent you from passing the wrong type.\n\nAnother consequence? Less readable code. If you see a method signature that returns a TimeSpan, then you know that you’re dealing with a duration. An int, on the other hand, could be anything, and you have to resort to naming conventions to understand what it means.\n\nA final downside of using primitives instead of the more specific time is that the primitive can’t provide useful operations with the domain it ostensibly represents. After all, a number is just a number; it can’t know anything about the domain of time.\n\nOn the other hand, TimeSpan does provide a lot of useful operations related to the concept of a time interval. Also—and unsurprisingly—it plays well with other time-related types, such as DateTime.\n\nHaving covered the what of the TimeSpan type, it’s time for the how. The first thing I’m going to show you is how to get a TimeSpan value. There are several ways you can do that:\n\nUsing One of the Factory Methods\n\nAdding Two or More TimeSpans Together\n\nUsing the Parameterless Constructor (Empty Value)\n\nUsing the Other Several Constructors\n\nvar e = new TimeSpan(ticks: 10_000_000); // 10 million ticks is equivalent to one second\n\nOnce you get down to a microsecond, things can get confusing, so here’s a reminder for those units:\n• A millisecond is one-thousandth of a second.\n• A microsecond is one-millionth of a second.\n• A microsecond contains 1000 nanoseconds. In other words, a nanosecond is one billionth of a second.\n• One tick is equivalent to 100 nanoseconds. In other words, one second contains 10 million ticks.\n\nFinally, you can also obtain a TimeSpan value by parsing from a string representation, similar to what you can do with dates and numbers. Several methods follow the pattern Parse and TryParse: the methods without the “Try” suffix throw an exception in case the parsing doesn’t succeed, while the methods with the suffix return a boolean indicating the status of the operation. The actual parsed value is returned via an out parameter.\n\nHere’s an example of one of the versions of TryParse():\n\nWhat are the key methods and properties associated with Timespan in C#?\n\nNow you know the main ways to get a shiny, new TimeSpan value. That’s great, but what can you do with it? What functionality does this type provide?\n\nAs it turns out, the TimeSpan type has many methods, fields, and properties. I won’t cover all of them, but only the most important ones.\n\nYou’ve just seen how you can add two or more TimeSpan values. It’s also possible to perform other operations using the methods Subtract, Multiply, Divide, or the correspondent operators:\n\nIt’s important to remember that TimeSpan is an immutable type. Every time you do something to its value, it returns a new value instead of changing the existing one.\n\nDo you need to invert a TimeSpan? That is, make a positive value become negative or vice versa? Then, the Negate() method is your friend. If you need the absolute value of a TimeSpan, though, Duration() is the method you’re looking for.\n\nTimeSpan overrides the Equals method, which enables comparisons by value:\n\nThe method CompareTo can be used to determine whether each TimeSpan value is shorter, longer, or equal to another one, returning an integer (-1, 0, 1) for each case. It’s useful when sorting a list of values.\n\nTimeSpan offers properties that allow you to get the component portions of its value, such as hours, minutes, days, and so on. Here are all the properties:\n\nThe properties that start with “Total” are all of type double. They return the total value of the TimeSpan instance, expressed in the desired unit, and allow for fractional parts. The properties without the “Total” are integers (int and long types), and they return the value of the respective component without any fraction part.\n\nTime for an example:\n\nHow to format a TimeSpan in C#\n\nThere are several ways to format a TimeSpan in C#. Let’s cover some of them.\n\nFirst, you can use the ToString() method to return the default formatting:\n\nKeep in mind that the ToString() above isn’t necessary since WriteLine() already calls ToString() on whatever objects it gets passed. I’ve only included it for didactical purposes.\n\nNow, let’s see an example with more components:\n\nAnd finally, another alternative in which we make use of string interpolation and access the properties of the TimeSpan value directly:\n\nC# TimeSpan: common issues and how to avoid them\n\nBefore wrapping up, let’s cover some common errors people make regarding TimeSpan values and how to avoid them.\n\nOn this StackOverflow question, the user tried the following:\n\nI failed. Why? In the format above, the first component means hours and its valid range is up to 23. So, for that to work, the person would need to use the Days component to express the complete information.\n\nEarlier in the article, you learned the difference between the TimeSpan properties that start with “Total” and the ones that don’t. A common mistake is to misunderstand and swap the types of properties, resulting in unwanted behaviors.\n\nThere are several ways in which people can make arithmetical mistakes when handling TimeSpan values, but my concern here is one super specific mistake: dismissing daylight saving time when subtracting DateTime values.\n\nLet’s say you have code like this:\n\nIt might look like there’s nothing wrong here, but there may be a problem lurking if you live in an area where daylight saving time is a thing. If a daylight saving time transition happens between the time the start and end variables are initialized, you will end up with a wrong value, containing either an extra hour or a missing hour.\n\nIn these situations, you should use a “neutral” timezone that doesn’t fluctuate with daylight-saving time transitions. In other words, use UTC:\n\nIn this post, we’ve introduced you to TimeSpan. Now, you know what it is, what you can use it for, what the benefits are, and how to get started with it.\n\nNow, as a next step, I invite you to keep exploring. Give the TimeSpan documentation a good read. Create toy projects to explore this type and its relation to other time-related types in .NET. And, of course, as soon as you have the chance, use TimeSpan in your real projects. Make primitive obsession a thing of the past.\n\nThis post was written by Carlos Schults. Carlos is a skilled software engineer and an accomplished technical writer for various clients. His passion is to get to the bottom (the original source) of things, and captivate readers with approachable and informative technical content."
    },
    {
        "link": "https://bytehide.com/blog/timespan-csharp",
        "document": "C# is a versatile programming language that offers numerous features to make it easier for developers to manage various aspects of their applications. One such feature is TimeSpan, which makes working with durations and time intervals a breeze. In this article, we will delve into what TimeSpan is, how to create and manipulate instances of it, and explore some real-life scenarios where it can prove to be helpful.\n\nTimeSpan is a structure in C# that represents a time interval. It can express durations, such as the difference between two dates or times, as well as time spans for scheduling tasks. TimeSpan is part of the System namespace and is designed to work seamlessly with DateTime and DateTimeOffset objects.\n\nThere are several ways to create a TimeSpan instance. The most straightforward method is by using its constructor, which accepts the following arguments: hours, minutes, and seconds. You can also provide days, hours, minutes, seconds, and milliseconds as separate arguments. Here’s an example:\n\nAnother way to create a TimeSpan instance is by using its static methods, such as FromDays, FromHours, FromMinutes, FromSeconds, and FromMilliseconds. These methods return a TimeSpan object representing the specified number of time units. For example:\n\nYou can also create a TimeSpan instance by calculating the difference between two DateTime or DateTimeOffset objects:\n\nTimeSpan provides several properties that allow you to access the various components of the time interval.\n\nA tick is the smallest unit of time in the .NET Framework, equal to 100 nanoseconds. The Ticks property returns the number of ticks that represent the time interval:\n\nTimeSpan has properties such as TotalDays, TotalHours, TotalMinutes, TotalSeconds, and TotalMilliseconds that return the total time represented by the interval in the respective units:\n\nTimeSpan also provides properties like Days, Hours, Minutes, Seconds, and Milliseconds to access individual components of the time interval:\n\nTimeSpan offers several methods to manipulate and compare time intervals.\n\nThe Add and Subtract methods allow you to perform arithmetic operations with TimeSpan instances:\n\nThe Duration method returns a new TimeSpan with the absolute value of the current instance, while the Negate method returns a new TimeSpan with the negated value:\n\nYou can use the Compare and Equals methods to compare two TimeSpan instances:\n\nThe ToString method converts a TimeSpan instance to a string representation, and the Parse method converts a string representation back to a TimeSpan:\n\nTimeSpan is useful for calculating the difference between two dates or times. For example, to determine the number of days between two dates:\n\nYou can use TimeSpan to add or subtract time intervals from DateTime objects:\n\nTimeSpan can help schedule tasks to execute at specific intervals, as shown in this example using a Timer:\n\nTimeSpan in C# is a powerful structure that simplifies working with durations and time intervals. With its properties and methods, you can easily perform arithmetic operations, compare time intervals, and calculate differences between dates or times. By incorporating TimeSpan into your applications, you can streamline tasks related to time management and scheduling.\n• What is the smallest unit of time represented by TimeSpan?\n• The smallest unit of time in TimeSpan is a tick, which is equal to 100 nanoseconds.\n• How can I create a TimeSpan instance from a string? To create a TimeSpan instance from a string, use the TimeSpan.Parse method, like this:\n• Can TimeSpan represent negative time intervals?\n• Yes, TimeSpan can represent negative time intervals. This is useful when calculating the difference between two dates or times where the first one is greater than the second one.\n• How can I compare two TimeSpan instances?\n• You can compare two TimeSpan instances using the Compare method or the Equals method. Compare returns an integer value (-1, 0, or 1), while Equals returns a boolean value (true or false).\n• Is it possible to use TimeSpan with DateTimeOffset objects?\n• Yes, you can use TimeSpan with DateTimeOffset objects in the same way as with DateTime objects. TimeSpan can be added or subtracted from DateTimeOffset instances, and the difference between two DateTimeOffset objects can be calculated as a TimeSpan."
    },
    {
        "link": "https://zerotomastery.io/blog/c-sharp-timespan",
        "document": "Ever tried to set a delay or track time in your code and felt lost in all the numbers and calculations? I get it. Working with time such as creating countdowns, setting timers, or managing durations - can feel confusing.\n\nThe good news is that C# has a solution that makes it easy: .\n\nIn this guide, I’ll show you how works and why it’s a game-changer for time-based tasks. So that by the end, you’ll be able to build precise, smooth timers and schedules right in your C# projects. Ready to make timing a breeze?\n\nThis is the only course you need to learn C# programming and master the .NET platform. No previous coding experience required - you’ll learn C# programming from scratch, including powerful skills like data structures, object-oriented programming (OOP), and testing. All while building your own projects, so you can get hired as a C#/.NET Developer in 2025! Check it out above, or watch the first few videos here for free.\n\nWith that out of the way, let’s get into this 5-minute tutorial…\n\nWhat is TimeSpan in C#?\n\nis your go-to tool in C# for handling time intervals—whether you’re working with milliseconds, hours, or days. Instead of converting hours to seconds or juggling complex calculations, simplifies it all, so you can focus on what your code needs to do.\n\nbrings clarity, precision, and versatility to any time-based task in your projects:\n• Readability: makes your code easy to understand at a glance. For example, using clearly shows a 30-minute interval, saving you from manually converting or calculating time units. This clarity becomes crucial as your project scales, making it easier to troubleshoot or adjust timing\n• Precision: With , you can control timing down to the millisecond, or handle long periods like days or even weeks. This flexibility means you can use it for tasks ranging from setting a daily cache refresh in a web app to creating countdown timers in games\n• Versatility: is an all-in-one tool for setting delays, scheduling intervals, or tracking durations—without needing extra code or libraries. Whether you’re managing quick delays, setting a high-precision timer, or scheduling recurring processes, keeps your code clean, reliable, and easy to maintain\n\nCreating a in C# is simple, and you’ve got several options depending on your timing needs.\n\nHere’s a closer look at each approach, with examples of when to use them.\n\nIf you need an exact duration that combines days, hours, minutes, and seconds, you can specify each part individually. This is useful if you’re scheduling tasks with precise timing, like setting a process to run in exactly 1 day, 2 hours, 30 minutes, and 45 seconds.\n\nFor example, let’s say you’re building a backend service that processes data on a daily schedule. You could use to control the exact interval between each run:\n\nHere, knows the order: days, hours, minutes, seconds, and milliseconds (if you add a fifth value). This method is perfect for projects needing precision across longer durations.\n\nFor many tasks, you only need a single unit like minutes or hours. .NET provides built-in methods that make it easy to set these intervals without conversions. Here’s how these methods fit common use cases:\n• TimeSpan.FromDays() – Perfect for daily tasks, like refreshing a report every day\n• TimeSpan.FromHours() – Useful for hourly schedules, like sending an automated email or syncing data every hour\n• TimeSpan.FromMinutes() – Ideal for session timeouts or shorter intervals, like a quick timeout feature\n• TimeSpan.FromSeconds() – Handy for quick delays or countdowns, such as retrying a task after a short delay\n• TimeSpan.FromMilliseconds() – Ideal for high-precision timing, like animations or micro-delays.\n\nUsing these methods makes your code readable and keeps your intent clear. When you write , anyone reading your code immediately understands it’s a 30-minute interval.\n\nNegative values are helpful if you track time that has passed since an event, like overdue tasks or countdowns. This is especially useful in situations where you need to display the elapsed time since a deadline or to track tasks that are past due.\n\nIn project management software, you might show how late a task is. makes this easy with negative intervals:\n\nThis negative value represents the “backwards” interval, making it clear how far a task is overdue. Negative values allow you to display these “past-due” states, which can be invaluable for reminders or alerts in applications that depend on timing accuracy.\n\nWhich TimeSpan methods are best for different tasks?\n\nEach method offers specific advantages based on your timing needs.\n• If you’re managing session timeouts, you might want a method that’s readable and precise, like for a 30-minute timeout\n• But when working with recurring events or complex schedules, you’ll find methods like or the fully specified constructor (with days, hours, minutes, etc.) helpful\n\nOnce you’ve created a , you’ll often want to display it in a user-friendly way, so let's look at a few options:\n\nOne of the simplest ways to format a is by using . This method automatically organizes days, hours, minutes, and seconds into a standard format:\n\nThis output, “1.02:30:45,” represents 1 day, 2 hours, 30 minutes, and 45 seconds. It’s ideal for logs, dashboards, or anywhere clarity is key.\n\nIf you only need specific parts of the , custom formatting can help. The format, for example, gives a compact, clean display—perfect for showing hours and minutes only:\n\nWith , you get a simple, readable format (1 hour and 30 minutes) that works great in timers or logs.\n\nSome more options for more specific needs\n\nFor added control, you can use other custom format specifiers to tailor the display. These make it easy to adapt for your exact needs, whether it’s a countdown timer, high-precision display, or any other timing feature.\n\nHere are a few handy ones:\n\nSay you’re timing an event and need hours, minutes, and seconds. You’d format it like this:\n\nLet’s say you’re creating a 5-minute countdown timer for a game, and you want it to show the remaining time in minutes and seconds, updating every second as it ticks down.\n\nWith , you can define this time interval, and then use a loop to display it dynamically, simulating an active countdown, like so:\n\nIn this example, we start by defining a 5-minute . The loop runs as long as is greater than zero, updating the display with each second.\n• clears the console at the start of each loop iteration, so only the current time appears on the screen\n• pauses for one second without blocking, creating the countdown effect\n• subtracts one second from the countdown on each loop iteration\n\nThis approach lets your countdown update smoothly, ticking down in real-time from \"04:59,\" \"04:58,\" and so on, until it reaches \"00:00.\" This setup is ideal for games or applications where users need to see a visible, real-time countdown.\n\nUsing is generally straightforward, but there are a few common pitfalls to avoid:\n• Misunderstanding Constructor Order: Remember, the constructor expects days, hours, minutes, seconds, and milliseconds (in that order). Mixing these up can lead to unintended intervals\n• Forgetting Time Units: Be careful with the differences between methods like and to avoid inaccurate timing\n• Negative Issues: Negative values are helpful, but remember to use them correctly in conditional checks or displays, as they may appear differently based on your format\n• Ignoring : Here's the thing - represents an interval of zero. Use it in comparisons or as a default, but avoid unintended behavior by checking it carefully in your conditions\n\nNow it's your turn to try this out\n\nNow it’s your turn to put to work. is truly a game-changer for handling time in C#. From setting session timeouts to creating countdowns and scheduling tasks, manages the heavy lifting, letting you focus on your project’s core functionality while keeping your code clean, readable, and precise.\n\nIncorporating brings a level of polish to time-dependent features—whether it’s logging durations, displaying countdowns, or managing recurring events. Its intuitive format options make timing easy to work with, clear to understand, and simple to maintain, giving your users dependable, accurate displays.\n\nReady to level up your C# skills? Start experimenting with in your projects and explore its flexible options. You’ll quickly see how it transforms time management, bringing both efficiency and professionalism to your code.\n\nDon’t forget - if you want to learn more about C# as well as the .NET platform, check out my complete course:\n\nNo previous coding experience required - you’ll learn C# programming from scratch, including powerful skills like data structures, object-oriented programming (OOP), and testing. All while building your own projects, so you can get hired as a C#/.NET Developer in 2025!\n\nIt’s the only course you need to learn C# programming and master the .NET platform. You’ll learn everything from scratch and put your skills to the test with exercises, quizzes, and projects!\n\nPlus, once you join, you'll have the opportunity to ask questions in our private Discord community from me, other students, and working developers.\n\nThere's always someone online 24/7 happy to help. It's by far the thing that my students always tell me is the best part of their experience. Hope you decide to take my course and if you do, make sure to come say hi on Discord!\n\nCheck it out above, or watch the first few videos here for free.\n\nLike this guide? Get more C# content below!\n\nCheck out these other C# guides and tutorials (All with code examples!)\n• Beginners Guide To C# Struct vs Class\n• Beginner’s Guide to Async and Await in C#\n• Beginner's Guide to To C# Access Modifiers\n• What Is C# Used For? Pretty Much Everything!\n• 5 Reasons Why You Should Learn C#"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members",
        "document": "A static class is basically the same as a non-static class, but there's one difference: a static class can't be instantiated. In other words, you can't use the new operator to create a variable of the class type. Because there's no instance variable, you access the members of a static class by using the class name itself. For example, if you have a static class that is named that has a public static method named , you call the method as shown in the following example:\n\nA static class can be used as a convenient container for sets of methods that just operate on input parameters and don't have to get or set any internal instance fields. For example, in the .NET Class Library, the static System.Math class contains methods that perform mathematical operations, without any requirement to store or retrieve data that is unique to a particular instance of the Math class. That is, you apply the members of the class by specifying the class name and the method name, as shown in the following example.\n\nAs is the case with all class types, the .NET runtime loads the type information for a static class when the program that references the class is loaded. The program can't specify exactly when the class is loaded. However, it's guaranteed to load and have its fields initialized and its static constructor called before the class is referenced for the first time in your program. A static constructor is only called one time, and a static class remains in memory for the lifetime of the application domain in which your program resides.\n\nThe following list provides the main features of a static class:\n\nCreating a static class is therefore basically the same as creating a class that contains only static members and a private constructor. A private constructor prevents the class from being instantiated. The advantage of using a static class is that the compiler can check to make sure that no instance members are accidentally added. The compiler guarantees that instances of this class can't be created.\n\nStatic classes are sealed and therefore can't be inherited. They can't inherit from any class or interface except Object. Static classes can't contain an instance constructor. However, they can contain a static constructor. Non-static classes should also define a static constructor if the class contains static members that require non-trivial initialization. For more information, see Static Constructors.\n\nHere's an example of a static class that contains two methods that convert temperature from Celsius to Fahrenheit and from Fahrenheit to Celsius:\n\nA non-static class can contain static methods, fields, properties, or events. The static member is callable on a class even when no instance of the class exists. The static member is always accessed by the class name, not the instance name. Only one copy of a static member exists, regardless of how many instances of the class are created. Static methods and properties can't access non-static fields and events in their containing type, and they can't access an instance variable of any object unless it's explicitly passed in a method parameter.\n\nIt's more typical to declare a non-static class with some static members, than to declare an entire class as static. Two common uses of static fields are to keep a count of the number of objects that are instantiated, or to store a value that must be shared among all instances.\n\nStatic methods can be overloaded but not overridden, because they belong to the class, and not to any instance of the class.\n\nAlthough a field can't be declared as , a const field is essentially static in its behavior. It belongs to the type, not to instances of the type. Therefore, fields can be accessed by using the same notation used for static fields. No object instance is required.\n\nC# doesn't support static local variables (that is, variables that are declared in method scope).\n\nYou declare static class members by using the keyword before the return type of the member, as shown in the following example:\n\nStatic members are initialized before the static member is accessed for the first time and before the static constructor, if there's one, is called. To access a static class member, use the name of the class instead of a variable name to specify the location of the member, as shown in the following example:\n\nIf your class contains static fields, provide a static constructor that initializes them when the class is loaded.\n\nA call to a static method generates a call instruction in common intermediate language (CIL), whereas a call to an instance method generates a instruction, which also checks for null object references. However, most of the time the performance difference between the two isn't significant.\n\nFor more information, see Static classes, Static and instance members and Static constructors in the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    },
    {
        "link": "https://stackoverflow.com/questions/57064093/creating-a-static-settings-class-in-net-core-class-library",
        "document": "Given the above code, you're rebuilding the configuration every time its called. You may as well make it a singleton. And since singletons are bad, well something else is probably wrong. Your instinct this feels wrong is RIGHT!\n• Avoid classes until you know they are static.\n• Usually, common 'helper' classes like this violate one or more SOLID principles. (This is probably why you have that feel of the code being 'wrong')\n\nRead more on how 'helper' classes like this do not adhere to SOLID principles, and what those principles are in this blog article\n\nIf instead of a class, were you to leverage .NET Core's built in dependency injection, we could easily turn this abstraction into a bit of code that adheres to SOLID principles. That of course doesn't solve your problem of being able to use your new in another static class, but does enable you to use this interface as a first class citizen directly where you need the , and you would simply use dependency injection in your , or"
    },
    {
        "link": "https://stackoverflow.com/questions/15570629/can-i-add-static-methods-to-existing-class-in-the-net-api",
        "document": "I want to build a Windows Store class library using source code from a regular .NET Framework class library. Ideally, I do not want to modify the original source code files.\n\nIn some of the source code files from the .NET Framework library, static members are used from a class that is defined in both the regular .NET Framework API and the .NET for Windows Store apps API, but where only a subset of the .NET Framework members are available for Windows Store.\n\nOne specific example is System.IO.Path, where the GetFullPath method is not available for Windows Store apps.\n\nIt is fairly straightforward to incorporate a replacement for this method in my Windows Store class library and have the original source code invoke this method instead. My question is, is there any way I can do this without modifying the original source code file?\n\nSo far, I have not been able to figure out a satisfactory solution to this problem, but I have solved it for my Windows Store class library by implementing e.g. the method in another namespace:\n\nand then adding a preprocessor directive in the original files:\n\nIs there an alternative solution to this issue that does not require modification of the original source code files?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/static-class",
        "document": "This content is reprinted by permission of Pearson Education, Inc. from Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition. That edition was published in 2008, and the book has since been fully revised in the third edition. Some of the information on this page may be out-of-date.\n\nA static class is defined as a class that contains only static members (of course besides the instance members inherited from System.Object and possibly a private constructor). Some languages provide built-in support for static classes. In C# 2.0 and later, when a class is declared to be static, it is sealed, abstract, and no instance members can be overridden or declared.\n\nStatic classes are a compromise between pure object-oriented design and simplicity. They are commonly used to provide shortcuts to other operations (such as System.IO.File), holders of extension methods, or functionality for which a full object-oriented wrapper is unwarranted (such as System.Environment).\n\nStatic classes should be used only as supporting classes for the object-oriented core of the framework.\n\n❌ DO NOT treat static classes as a miscellaneous bucket.\n\n❌ DO NOT declare or override instance members in static classes.\n\n✔️ DO declare static classes as sealed, abstract, and add a private instance constructor if your programming language does not have built-in support for static classes.\n\nReprinted by permission of Pearson Education, Inc. from Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-static-class",
        "document": "In C#, one is allowed to create a static class, by using static keyword. A static class can only contain static data members and static methods. It is not allowed to create objects of the static class and since it does not allow to create objects it means it does not allow instance constructor. Static classes are sealed, means you cannot inherit a static class from another class.\n\nIn C#, the static class contains two types of static members as follows:\n• Static Data Members: As static class always contains static data members, so static data members are declared using static keyword and they are directly accessed by using the class name. The memory of static data members is allocating individually without any relation with the object. \n\nSyntax:\n• Static Methods: As static class always contains static methods, so static methods are declared using static keyword. These methods only access static data members, they can not access non-static data members. \n\nSyntax:\n\nExplanation: In the above example, we have a static class named as Author by using static keyword. The Author class contains static data members named A_name, L_name, and T_no, and a static method named as details(). The method of a static class is simply called by using its class name like Author.details();. As we know that static class doesn’t consist object so the data member of the Author class is accessed by its class name, like Author.A_name, Author.L_name, and Author.T_no."
    }
]