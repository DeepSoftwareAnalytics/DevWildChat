[
    {
        "link": "https://docwiki.embarcadero.com/RADStudio/Sydney/en/Conditional_compilation_(Delphi)",
        "document": "Go Up to Delphi Compiler Directives (List) Index\n\nConditional compilation is based on the existence and evaluation of constants, the status of compiler switches, and the definition of conditional symbols.\n\nConditional symbols work like Boolean variables: they are either defined (True) or undefined (False). Any valid conditional symbol is treated as false until it has been defined.\n\nYou can define a conditional in the following ways:\n• Use the directive to set a specified symbol to True, and the directive to set the symbol to False.\n• Use the switch with the command-line compiler (this option is supported by all the Delphi compilers).\n• Add the symbol to the Conditional Defines field on the page.\n\nThe conditional directives , , , , , , and allow you to compile or suppress code based on the status of a conditional symbol. and allow you to base conditional compilation on declared Delphi identifiers. {$IFOPT} compiles or suppresses code depending on whether a specified compiler switch is enabled.\n\nFor example, the following Delphi code snippet processes differently depending on whether the DEBUG conditional define is set ( ):\n\nNote: Conditional symbols are not Delphi identifiers and cannot be referenced in actual program code. Similarly, Delphi identifiers cannot be referenced in any conditional directives other than and .\n\nNote: Conditional definitions are evaluated only when source code is recompiled. If you change a conditional symbol status and then rebuild a project, source code in unchanged units may not be recompiled. Use to ensure that everything in your project reflects the current status of conditional symbols.\n\nConditional-directive constructions can be nested up to 32 levels deep. For every , the corresponding or must be found within the same source file. Conditional symbols must start with a letter, followed by any combination of letters, digits, and underscores; they can be of any length, but only the first 255 characters are significant.\n\nThe following standard conditional symbols are defined:\n\nDefined if an application is being compiled as a console application. Defined if the target platform is iOS.\n\n *New* in XE4/iOS. Defined if the target platform is iOS64.\n\n Since XE8/iOSarm64. Defined if the target platform is macOS.\n\n*New* in XE2/macOS. Defined if the target platform is macOS.\n\n*New* in 10.3.2 . Indicates that the operating environment is Windows. Use MSWINDOWS to test for any flavor of the Windows platform instead of WIN32. Target platform is an Apple Darwin OS (macOS or iOS). \n\n Note: This symbol existed before Apple changed the name of OS X to macOS. *New* in XE2/macOS. Target platform is 32-bit Apple Darwin OS (32-bit macOS or 32-bit iOS). Note: This symbol existed before Apple changed the name of OS X to macOS. *New* in XE2/macOS. Target platform is 64-bit Apple Darwin OS (64-bit macOS or 64-bit iOS). Note: This symbol existed before Apple changed the name of OS X to macOS. *New* in XE8/macOS. Defined if the target platform is Android.\n\n*New* in XE5. Indicates that the CPU is an Intel 386 or later. CPU is an Intel 386 or later on any platform. \n\n*New* in XE2/x64. The CPU supports the x86-64 instruction set, and is in a 64-bit environment. \n\n*New* in XE2/x64. The CPU is in a 32-bit environment, such as DCC32.EXE. \n\n*New* in XE8. The CPU is in a 64-bit environment, such as DCC64.EXE. \n\n*New* in XE8. Defined if the CPU is based on the ARM architecture.. \n\n*New* in XE4/iOS. The CPU is in a 32-bit ARM environment. \n\n*New* in XE8. The CPU is in a 64-bit ARM environment, such as DCCIOSARM64.EXE. \n\n*New* in XE8. Defined in code that may be shared with the macOS compiler and another compiler on another platform such as Linux that does not have a rigid stack alignment requirement. For more information, see Eli Boling's blog at http://blogs.embarcadero.com/eboling/2009/05/20/5607 . \n\n*New* in XE2/macOS. Defined for compilers that use automatic reference counting, such as the Delphi mobile compilers. \n\n*New* in XE4/iOS. Removed in 10.4 Sydney. Defined for compilers that have an external linker and the LLVM code generator; the Delphi mobile compilers have the external ld linker and use LLVM as code generator. \n\n*New* in XE4/iOS. UNICODE is defined as the default string type. Tests for the use of the $IF directive. Defined for compilers (such as the Delphi mobile compilers) that use \"next-generation\" language features, such as 0-based strings. \n\n*New* in XE4/iOS. Removed in 10.4 Sydney. Defined when compiling on a platform or for a target platform that uses address maps instead of stack frames to unwind exceptions (such as macOS). \n\n*New* in XE2. Defined for platforms that require Position-Independent Code (PIC), such as macOS. Defined for compilers that add a leading underscore (for example, in names of dynamic libraries imported from Mac OS). \n\n*New* in XE4/iOS. Defined for compilers that can use weak references (the attribute). \n\n*New* in XE4/iOS. Defined when weak references are defined for instances. \n\n*New* in XE4/iOS. Removed in 10.4 Sydney. Defined when weak references are defined for interfaces. \n\n*New* in XE4/iOS.\n\nThe following conditionals are available as of RAD Studio 11.1:\n\nUsing Conditional Defines for the Compiler Version\n\nFor example, to determine the version of the compiler and run-time library that were used to compile your code, you can use with the CompilerVersion, RTLVersion and other constants:\n\nSee the table of Compiler Versions for a list of version numbers associated with various released Delphi compilers.\n\nConstants can be more powerful than conditionals because you can use constants programmatically in Delphi code. Conditionals, on the other hand, are accepted only inside conditional compiler directives such as and .\n\nThere are three important constants available:\n• System.RTLVersion is a constant defined as the version of the run-time library. For Sydney, RTLVersion is 34.\n• System.CompilerVersion is a constant defined as the version of the current Delphi compiler. For Sydney, CompilerVersion is 34.\n• FMX.Types.FireMonkeyVersion is a constant defined as the version of the current FireMonkey library. For Sydney, FireMonkeyVersion is 270."
    },
    {
        "link": "https://thoughtco.com/delphi-compiler-version-directives-1058183",
        "document": "If you plan on writing Delphi code that should work with several version of the Delphi compiler you need to know under which versions your code gets compiled.\n\nSuppose you are writing your own commercial custom component. Users of your component might have different Delphi versions than you have. If they try to recompile the component's code—your code—they might be in trouble! What if you were using default parameters in your functions and the user has Delphi 3?\n\nCompiler directives are special syntax comments we can use to control the features of the Delphi compiler. The Delphi compiler has three types of directives: switch directives, parameter directives, and conditional directives. Conditional compilation lets us selectively compile parts of a source code depending on which conditions are set.\n\nThe syntax looks like:\n\nThe DefName presents the so-called conditional symbol. Delphi defines several standard conditional symbols. In the \"code\" above, if the DefName is defined the code above $Else gets compiled.\n\nA common use for the $IfDef directive is to test the version of the Delphi compiler. The following list indicates the symbols to check when compiling conditionally for a particular version of the Delphi compiler:\n• WIN32 - Indicates that the operating environment is the Win32 API.\n• LINUX - Indicates that the operating environment is Linux\n• MSWINDOWS - Indicates that the operating environment is the MS Windows/li]\n• CONSOLE - Indicates that an application is being compiled as a console application\n\nBy knowing the above symbols it is possible to write code which works with several versions of Delphi by using compiler directives to compile appropriate source code for each version.\n\nNote: symbol VER185, for example, is used to indicate Delphi 2007 compiler or an earlier version.\n\nIt's quite usual (and desirable) for each new Delphi version to add several new RTL routines to the language.\n\nFor example, the IncludeTrailingBackslash function, introduced in Delphi 5, adds \"\\\" to the end of a string if it is not already there. In the Delphi MP3 project, I have used this function and several readers have complained that they can't compile the project—they have some Delphi version prior to Delphi 5.\n\nOne way to solve this problem is to create your own version of this routine - the AddLastBackSlash function. If the project should be compiled on Delphi 5, the IncludeTrailingBackslash is called. If some of the previous Delphi versions are used, then we simulate the IncludeTrailingBackslash function.\n\nIt could look something like:\n\nWhen you call the AddLastBackSlash function Delphi figures out which portion of the function should be used and the other part is simply skipped.\n\nDelphi 2007 uses VER180 in order to maintain non-breaking compatibility with Delphi 2006 and then adds VER185 in order for development that specifically needs to target Delphi 2007 for whatever reason. Note: any time the interface of a unit changes the code that uses that unit has to be re-compiled.\n\nDelphi 2007 is non-breaking release meaning that DCU files from Delphi 2006 will work as-is."
    },
    {
        "link": "https://wstomv.win.tue.nl/edu/delphi/DelphiLanguageGuide.pdf",
        "document": ""
    },
    {
        "link": "https://oreilly.com/library/view/delphi-in-a/1565926595/re425.html",
        "document": "Get full access to Delphi in a Nutshell and 60K+ other titles, with a free 10-day trial of O'Reilly.\n\nThere are also live events, courses curated by job role, and more."
    },
    {
        "link": "https://stackoverflow.com/questions/6790274/delphi-how-to-use-more-defined-values-in-conditional-compilation",
        "document": "Reach devs & technologists worldwide about your product, service or employer brand"
    },
    {
        "link": "https://freepascal.org/docs-html/rtl/math/index-5.html",
        "document": "Return the lowest integer number greater than or equal to argument\n\nRound to the nearest bigger int64 value\n\nChange value so it fits in a specified range.\n\nReturn the largest integer smaller than or equal to argument\n\nRound to the nearest smaller int64 value\n\nCalculate the future value of an investment.\n\nReturn one of two values, depending on a boolean condition\n\nCheck whether value is in range.\n\nCalculate the interest rate value of an investment\n\nCheck whether value is infinite\n\nCheck whether value is Not a Number\n\nCheck whether value is zero\n\nRound to the specified number of digits\n\nCheck whether 2 float values are the same\n\nRound to the specified number of digits (rounding up if needed)\n\nReturn the sum of an array of integers\n\nReturn sum and sum of squares of values."
    },
    {
        "link": "https://freepascal.org/docs-html/rtl/system/mathematicalfunctions.html",
        "document": ""
    },
    {
        "link": "https://wiki.freepascal.org/Basic_Pascal_Tutorial/Chapter_1/Standard_Functions",
        "document": "Pascal has several standard mathematical functions that you can utilize. For example, to find the value of sin of pi radians:\n\nNote that the sin function operates on angular measure stated in radians, as do all the trigonometric functions. If everything goes well, value should become 0.\n\nFunctions are called by using the function name followed by the argument(s) in parentheses. Standard Pascal functions include:\n\nFor ordinal data types (integer or char), where the allowable values have a distinct predecessor and successor, you can use these functions:\n\nReal is not an ordinal data type! That's because it has no distinct successor or predecessor. What is the successor of 56.0? Is it 56.1, 56.01, 56.001, 56.0001?\n\nHowever, for an integer 56, there is a distinct predecessor — 55 — and a distinct successor — 57.\n\nThe same is true of characters:\n\nThe above is not an exhaustive list, as modern Pascal compilers include thousands of functions for all sorts of purposes. Check your compiler documentation for more."
    },
    {
        "link": "https://freepascal.org/docs-html/rtl/math/index.html",
        "document": "This document describes the math unit. The unit was initially written by Florian Klaempfl. It provides mathematical functions which aren't covered by the system unit.\n\nThis chapter starts out with a definition of all types and constants that are defined, after which an overview is presented of the available functions, grouped by category, and the last part contains a complete explanation of each function.\n\nThe following things must be taken into account when using this unit:\n• This unit is compiled in Object Pascal mode so all are 32 bit.\n• Some overloaded functions exist for data arrays of integers and floats. When using the address operator ( ) to pass an array of data to such a function, make sure the address is typecasted to the right type, or turn on the 'typed address operator' feature. failing to do so, will cause the compiler not be able to decide which function you want to call."
    },
    {
        "link": "https://ksvi.mff.cuni.cz/~dingle/2018/library_reference.html",
        "document": "This is the subset of the Free Pascal Run-Time Library (RTL) that we are learning and using in Programming I.\n\nThis is a work in progress. I will add more functions as we learn them in this class.\n\nThe heading names below are units in the Run-Time Library. To use the functions from any unit, you need to import it with a clause at the top of your program. As an exception, the functions in the unit are automatically available in any program.\n\nI’ve simplified some of the types below. For example, the run-time library documentation often uses the type , but below I’ve written just , which is the same as long as you’re using as we are in this course. Similarly, I’ve written in place of and , and in place of .\n\nI’ve also converted all function names to begin with lowercase (the RTL documentation uses upper and lower case variously). Because Pascal is case-insensitive, you can call these functions using any case you like.\n\nFor more information, see the full Run-Time Library Reference at the Free Pascal site.\n\nReturn true if c is a digit, i.e. a character in the range ‘0’..’9’.\n\nReturn true if c is an uppercase or lowercase letter.\n\nThe height of the terminal window in characters.\n\nThe width of the terminal window in characters.\n\nPause for the given number of milliseconds.\n\nMove to the position (x, y) in the terminal window. The upper-left-most character is (1, 1).\n\nReturn immediately, returning true if the user has pressed a key (which you can then retrieve with the function) or false otherwise.\n\nRead a key from the user, without waiting for the user to press Enter. If the key is a non-symbolic key such as an arrow key, returns the character with ASCII code zero. In that case a second call to ReadKey will return a code indicating the non-symbolic key that was pressed. Some of these codes include the following: up arrow = 72, left arrow = 75, right arrow = 77, down arrow = 80.\n\nSet the foreground text color to c, which can be one of the color constants listed above.\n\nCalculate the number of whole milliseconds between two DateTime values.\n\nA special floating-point value that is greater than any other.\n\nRaise an integer to a power. For example, is 81.\n\nReturn the greater of two values.\n\nReturn the lesser of two values.\n\nReturn the leftmost n characters of a string. For example, .\n\nReturn a copy of in which all occurrences of have been replaced by .\n\nReturn the rightmost n characters of a string. For example, .\n\nReturn the upper bound of a static or dynamic array.\n\nReturn the length of a string or array.\n\nReturn the lower bound of a static or dynamic array.\n\nElements in a dynamic array are numbered from zero, so after a call to they will have indices from 0 to – 1, inclusive. If this call increases the size of an array, the new array elements will all be zero.\n\nReturn true if we have reached the end of standard input. In the typical case where the input comes from a terminal window, this means that the user has pressed Ctrl+D (on Linux or macOS) or Ctrl+Z (on Windows). (“eof” stands for “end of file”).\n\nIn most programs you will want to use the function (see below) instead.\n\nRead one or more values of standard input. The exact behavior depends on the type of value being read:\n• None : Read a single input character. (This could be a newline character if the input position is currently at the end of a line.)\n• None , , : Skip past all whitespace (possibly including one or more newlines) and then read the first following number.\n• None : Consume the rest of the current input line and return it as a string. Warning: This does not consume the newline following the string; a subsequent call to read() will return the empty string. If you want to read a series of strings on separate lines, you must use readln().\n\nThis procedure is like , but after reading all values it consumes the rest of the input line including the newline character at the end. (Any extra text on the input line is ignored.)\n\nAdvance past all whitespace (such as spaces or newlines), then return true if we have reached the end of standard input, false otherwise.\n\nWrite one or more values to standard output, with no following newline. The values to be written may be of any fundamental type (boolean, integer, int64, real, char, string).\n\nEach value in the argument list may optionally be followed by a field width and decimal width, separated by colons.\n\nThe field width is the minimum number of characters to output. If the value to be written is shorter than the field width, the output will be padded at the left with space characters. The default field width is 0.\n\nA decimal width can be specified only for real values, and specifies the number of digits to write after the decimal point. The output value will be rounded to this number of digits.\n\nThis procedure is like , but follows the output with a newline character.\n\nOpen an existing file for writing. Newly written data will be appended to the end of the file.\n\nReturn true if we are at the end of the given file.\n\nRead one or more values from a text file.\n\nRead a line containing one or more values from a text file.\n\nOpen a file for writing. If the file does not exist, it is created. If the file already exists, it is truncated to length 0: all existing data in the file is lost!\n\nAdvance past all whitespace (such as spaces or newlines) in a text file, then return true if we are at the end of the file, false otherwise.\n\nWrite one or more values to a text file.\n\nWrite a line containing one or more values to a text file.\n\nThe maximum value that can be held in an integer. If you have enabled Delphi mode, integers are signed 32-bit values and MaxInt is 2,147,483,647.\n\nUnfortunately the library contains no corresponding constant . The minimum possible integer value is ( .\n\nReturn the absolute number of an integer or floating-point number.\n\nReturn the cosine of the given angle in radians.\n\nReturn the exponent of , i.e. the number e to the power .\n\nReturn the fractional part of a floating-point value. For example, is 0.14159...\n\nReturn the natural logarithm (i.e. the logarithm to the base e = 2.7182818…) of the value d, which must be positive.\n\nInitialize the random number generator with a seed based on the current time. You must call this once at the beginning of any program if you want random numbers to be different on each program run.\n\nRound a floating-point number to the nearest integer. The algorithm uses \"banker’s rounding\": values of the form i + 0.5 (for any integer i) are always rounded towards an even number.\n\nReturn the sine of the given angle in radians.\n\nReturn the integer part of , which is always smaller than (or equal to) in absolute value.\n\nA newline character. The ASCII value of this character may vary from platform to platform.\n\nReturn the character with ASCII value . For example, is .\n\nReturn the substring of that begins at and has characters. For example, is 'we'.\n\nConvert a character to an integer. For example, is 65.\n\nReturn the first index at which c occurs in s, or 0 if c is not in s.\n\nConvert a string to a floating-point number. If the string does not represent a valid floating-point number, the program will fail.\n\nConvert a string to an integer. If the string does not represent a valid integer, the program will fail.\n\nTrim whitespace from the ends of a string."
    }
]