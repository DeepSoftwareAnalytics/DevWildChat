[
    {
        "link": "https://forum.qt.io/topic/142180/qtcpsocket-client-qt-5-12-not-connecting",
        "document": "Hey, some background info: I use the QT extension in visual studio 2022, QT version 5.12.2. I want to send a simple \"J\" character to a server from my client using TCP. I got this to work using a different TCP socket code that is not part of the QT framework. So the communication and setup outside the code works but now I need it also to work using QT's framework, QTcpSocket.\n\nI have tested different versions that I found on the internet like the fortune client example, so far I have not gotten any of them to work. I am not too experienced with TCP coding so to keep it short, the simplest way to connect to server at ip=192.168.3.154 and port=4035 and send \"J\" as I understand could look like this:\n\nBut in the code above I get a timeout so it seems I cannot make the connection this way. Am I misusing the QTcpSocket object?\n\nEdit: Added some more error handling. The message from the qDebug() is: Error: QAbstractSocket::SocketTimeoutError State: QAbstractSocket::UnconnectedState"
    },
    {
        "link": "https://doc.qt.io/qt-6/qtcpsocket.html",
        "document": "The QTcpSocket class provides a TCP socket. More...\n\nNote: All functions in this class are reentrant.\n\nTCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.\n\nQTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details."
    },
    {
        "link": "https://hwzen.myds.me:17001/qtdoc/qtnetwork/qtcpsocket.html",
        "document": "The QTcpSocket class provides a TCP socket. More...\n\nNote: All functions in this class are reentrant.\n\nTCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.\n\nQTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details.\n\nNote: TCP sockets cannot be opened in QIODevice::Unbuffered mode."
    },
    {
        "link": "https://hwzen.myds.me:17001/qtdoc/qtdoc/topics-data-storage.html",
        "document": "The QIODevice class is the base class for all file and data storage devices in Qt Core. All classes that are used for reading and writing data inherit from it.\n\nExamples of devices are QFile, QBuffer, QTcpSocket, and QProcess. QFile is used for reading and writing text, binary files, and resources. The QBuffer class provides a QIODevice interface for a QByteArray. QTcpSocket enables the developer to establish a TCP connection and transfer streams of data. QProcess is used to start external programs, and to read from and write to that process.\n\nThe Qt SQL module uses driver plugins to communicate with several database APIs. Qt has drivers for SQLite, MySQL, DB2, Borland InterBase, Oracle, ODBC, and PostgreSQL. It is also possible to develop your own driver if Qt does not provide the driver needed.\n\nQt's SQL classes can be divided in 3 layers:\n\nWith the MySQL driver, it is possible to connect to a MySQL server. In order to build the QMYSQL Plugin for Unix or macOS, you need the MySQL header files as well as the shared library, libmysqlclient.so. To compile the plugin for Windows, install MySQL.\n\nIf you use the embedded MySQL Server, you do not need a MySQL server in order to use that database system. In order to do so, you need to link the Qt plugin to libmysqld instead of libmysqlclient.\n\nThe Qt SQLite plugin is very suitable for local storage. SQLite is a relational database management system contained in a small (~350 KiB) C library. In contrast to other database management systems, SQLite is not a separate process that is accessed from the client application, but an integral part of it. SQLite operates on a single file, which must be set as the database name when opening a connection. If the file does not exist, SQLite will try to create it.\n\nSQLite has some restrictions regarding multiple users and multiple transactions. If you are reading or writing on a file from different transactions, your application might freeze until one transaction commits or rolls back.\n\nOnce the driver part is set up, the data is accessible using the classes, QSqlQueryModel, QSqlTableModel, and QSqlRelationalTableModel. QSqlTableModel and QSqlRelationalTableModel provide editable models that can used with Qt's item views. QSqlTableModel has read/write access to a single table, whereas QSqlRelationalTableModel has read/write access to the main table (not to the table with the foreign key).\n\nThe following pages contain information about incorporating SQL into applications:\n\nQt provides APIs to read and parse XML streams, and also to write to these streams. The following key classes facilitate these actions by providing the necessary infrastructure:\n• QXmlStreamReader class provides a parser to read XML. It is a well-formed XML 1.0 parser that does not include external parsed entities.\n• It understands and resolves XML namespaces. For example, in case of a StartElement, namespaceUri() returns the namespace the element is in, and name() returns the element's local name. The combination of namespaceUri() and name() uniquely identifies an element.\n• It is not CPU-intensive, as it doesn't store the entire XML document tree in memory. It only stores the current token at the time it is reported.\n• The QXmlStreamWriter class provides an XML writer with a simple streaming API. It is the counterpart to QXmlStreamReader for writing XML, and it operates on a QIODevice specified with setDevice().\n• It is a simple API that provides a dedicated function for every XML token or event you want to write.\n• It takes care of prefixing namespaces based on the namespaceUri specified while writing elements or attributes. If you have to use certain standardized prefixes, you can force the writer to use them by declaring the namespaces manually with either writeNamespace() or writeDefaultNamespace().\n• It can automatically format the generated XML data by adding line-breaks and indentation, making it readable. This feature can be turned on with the auto-formatting property.\n• It encodes XML in UTF-8 by default. Different encodings can be enforced using setCodec().\n\nBesides reading and writing to XML streams, Qt also provides APIs for the following additional use cases:\n• Querying an XML data source using XQuery and XPath\n\nThe following topics provide more insight into Qt XML support:\n\nJSON is a text-based open standard for data interchange that is easy to read and parse. It is used for representing simple data structures and associative arrays, called objects. It is related to JavaScript, but is a language-independent notation form.\n\nAn object can take 2 forms:\n\nThe Local Storage API provides the ability to access local offline storage in an SQL database from QML and JavaScript.\n\nThese databases are user-specific and QML-specific, but accessible to all QML applications. They are stored in the Databases subdirectory of QDeclarativeEngine::offlineStoragePath() as SQLite databases (SQL Database Drivers).\n\nThe API conforms to the Synchronous API of the HTML5 Web Database API, W3C Working Draft 29 October 2009 (HTML5 Web Database API).\n\nSee Qt Quick Examples - Local Storage for a basic demonstration of using the Local Storage API.\n\nThe QSettings class provides persistent storage of application settings. An application usually remembers its settings from the previous session.\n\nSettings are stored differently on different platforms. For example, on Windows they are stored in the registry, whereas on macOS they are stored in XML files.\n\nQSettings enable you to save and restore application settings in a portable manner. Constructing and destroying a QSettings object is lightweight and fast. While creating an object of QSettings, it is a good practice to specify not only the name of the application, but also the name of your organization. For example:\n\nThe Qt Resource System is a platform-independent mechanism for storing binary files in the application's executable. This is handy if your application frequently needs a certain file, or set of files. It also protects against loss of that particular file .\n\nResource data can either be compiled into the binary and accessed immediately in the application code, or a binary resource can be created dynamically and registered with the resource system by the application.\n\nBy default, resources are accessible from the application code by the same file name as they are stored in the source tree, with a prefix, or by a URL with a qrc scheme.\n\nAn archive file is a collection of files or directories which are generally compressed in order to reduce the space they would otherwise consume on a drive. Examples of archive files are ZIP, TAR, RAR and 7z.\n\nQt has support for archives produced by zlib (see qCompress() and qUncompress())."
    },
    {
        "link": "https://felgo.com/doc/qt/qtcpsocket",
        "document": "The QTcpSocket class provides a TCP socket. More...\n\nNote: All functions in this class are reentrant.\n\nTCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.\n\nQTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details."
    },
    {
        "link": "https://qt.developpez.com/doc/5.12/qtwebsockets-examples",
        "document": "The examples below can be used as a guide to using the Qt WebSockets API.\n• Echo Client Example: Describes how to use the WebSocket API for creating a simple echo client.\n• Echo Server Example: Shows how to create a simple server application that sends back the messages it receives.\n• QML WebSocket Server Example: A simple example that shows how to use a QML WebSocketServer.\n• SSL Echo Client Example: Shows how to use the QWebSocket class to implement an echo client over a secure connection (wss).\n• SSL Echo Server Example: Shows how to use the QWebSocketServer class for implementing a simple echo server over secure sockets (wss).\n• Simple Chat Example: Shows how to use the QWebSocket and QWebSocketServer classes for creating a minimalistic chat application over the WebSocket protocol."
    },
    {
        "link": "https://forum.qt.io/topic/99829/qwebsocket-and-examples",
        "document": "Sorry if this has been tackled earlier. I am looking for some examples which are not just ping and echo.\n\n Anyone know of any better examples built?\n\n I ask because I am trying to port a Windows socket service to Qt and make it cross-platform. The examples in the 5.12 docs are amazing just works but I am not able to move further from that.\n\nI tried to search for writeups to read and tutorials in youtube but did not find anything substantial. Are there any open source examples that anybody can link which is a robust example.\n\nI have pasted the socket.cpp which I am tackling. Being cross-platform getting rid of the registry details into a config file. All the logging into a new cross-platform library. There is a process of device locking, which I do a ifdef and keep it platform dependent."
    },
    {
        "link": "https://doc.qt.io/qt-5/qtwebsockets-examples.html",
        "document": "2024 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners."
    },
    {
        "link": "https://hwzen.myds.me:17001/qtdoc/qtwebsockets/qtwebsockets-examples.html",
        "document": "Describes how to use the WebSocket API for creating a simple echo client.\n\nShows how to create a simple server application that sends back the messages it receives.\n\nExplains how to program a QML WebSocket client example.\n\nA simple example that shows how to use a QML WebSocketServer.\n\nShows how to use the QWebSocket class to implement an echo client over a secure connection (wss).\n\nShows how to use the QWebSocketServer class for implementing a simple echo server over secure sockets (wss).\n\nShows how to use the QWebSocket and QWebSocketServer classes for creating a minimalistic chat application over the WebSocket protocol."
    },
    {
        "link": "https://felgo.com/doc/qt/qwebsocket",
        "document": "Implements a TCP socket that talks the WebSocket protocol. More...\n\nWarning: To generate masks, this implementation of WebSockets uses the reasonably secure QRandomGenerator::global ()->generate() function. For more information about the importance of good masking, see \"Talking to Yourself for Fun and Profit\" by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection ( wss:// ). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.\n\nNote: Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.\n\nQWebSocket only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 .\n\nWebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. QWebSocket can both be used in a client application and server application.\n\nSee also QAbstractSocket, QTcpSocket, and QWebSocket client example.\n\nCreates a new QWebSocket with the given origin, the version of the protocol to use and parent.\n\nThe origin of the client is as specified in RFC 6454. (The origin is not required for non-web browser clients (see RFC 6455)). The origin may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.\n\nThis signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).\n\nQWebSocket emits this signal if an alert message was received from a peer. level tells if the alert was fatal or it was a warning. type is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertSent(), QSsl::AlertLevel, and QSsl::AlertType.\n\nQWebSocket emits this signal if an alert message was sent to a peer. level describes if it was a warning or a fatal error. type gives the code of the alert message. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertReceived(), QSsl::AlertLevel, and QSsl::AlertType.\n\nThis signal is emitted whenever a binary frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a binary message is received. The message contains the received bytes.\n\nThis signal is emitted every time a payload of data has been written to the socket. The bytes argument is set to the number of bytes that were written in this payload.\n\nGracefully closes the socket with the given closeCode and reason.\n\nAny data in the write buffer is flushed before the socket is closed. The closeCode is a QWebSocketProtocol::CloseCode indicating the reason to close, and reason describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for closeCode the maximum length of reason is 123! If reason exceeds this limit it will be truncated.\n\nEmitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.\n\nSee also open() and disconnected().\n\nEmitted when the socket is disconnected.\n\nSee also close() and connected().\n\nThis signal is emitted after an error occurred. The error parameter describes the type of error that occurred.\n\nQAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().\n\nNote: Signal error is overloaded in this class. To connect to this signal by using the function pointer syntax, Qt provides a convenient helper for obtaining the function pointer as shown in this example:\n\nSee also error() and errorString().\n\nQWebSocket emits this signal if a certificate verification error was found and if early error reporting was enabled in QSslConfiguration. An application is expected to inspect the error and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also continueInterruptedHandshake(), sslErrors(), and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nThis slot tells QWebSocket to ignore errors during QWebSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.\n\nSee also sslErrors(), QSslSocket::ignoreSslErrors(), and QNetworkReply::ignoreSslErrors().\n\nOpens a WebSocket connection using the given request and options.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given url and options.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given request.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nThis function was introduced in Qt 5.6.\n\nOpens a WebSocket connection using the given url.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nQWebSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QWebSocket is unable to securely identify the peer.\n\nThis signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QWebSocket will proceed to emitting QWebSocket::sslErrors().\n\nThis function was introduced in Qt 6.2.\n\nPings the server to indicate that the connection is still alive. Additional payload can be sent along the ping message.\n\nThe size of the payload cannot be bigger than 125. If it is larger, the payload is clipped to 125 bytes.\n\nEmitted when a pong message is received in reply to a previous ping. elapsedTime contains the roundtrip time in milliseconds and payload contains an optional payload that was sent with the ping.\n\nThis signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.\n\nWhen using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.\n\nThis function was introduced in Qt 5.8.\n\nSee also QSslPreSharedKeyAuthenticator and QSslSocket::preSharedKeyAuthenticationRequired().\n\nThis signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.\n\nSee also QAuthenticator and QNetworkProxy.\n\nThis signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.\n\nQWebSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QWebSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call QWebSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).\n\nerrors contains one or more errors that prevent QWebSocket from verifying the identity of the peer.\n\nThis signal is emitted whenever QWebSocket's state changes. The state parameter is the new state.\n\nQAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().\n\nThis signal is emitted whenever a text frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a text message is received. The message contains the received text.\n\nDestroys the QWebSocket. Closes the socket if it is still open, and releases any used resources.\n\nAborts the current socket and resets the socket. Unlike close(), this function immediately closes the socket, discarding any pending data in the write buffer.\n\nReturns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.\n\nThis function was introduced in Qt 5.12.\n\nReturns the code indicating why the socket was closed.\n\nSee also QWebSocketProtocol::CloseCode and closeReason().\n\nReturns the reason why the socket was closed.\n\nIf an application wants to conclude a handshake even after receiving handshakeInterruptedOnError() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also handshakeInterruptedOnError() and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nReturns the type of error that last occurred\n\nReturns a human-readable description of the last error that occurred\n\nThis function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need QWebSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QWebSocket will start sending data automatically once control goes back to the event loop.\n\nReturns the handshake options that were used to open this socket.\n\nThis function was introduced in Qt 6.4.\n\nThis is an overloaded function.\n\nThis method tells QWebSocket to ignore the errors given in errors.\n\nNote that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:\n\nMultiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.\n\nReturns if the socket is ready for reading and writing; otherwise returns .\n\nReturns the mask generator that is currently used by this QWebSocket.\n\nReturns the maximum allowed size of an incoming websocket frame.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum allowed size of an incoming websocket message.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an incoming websocket frame for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an incoming websocket message for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an outgoing websocket frame for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum size of an outgoing websocket frame.\n\nThis function was introduced in Qt 5.15.\n\nReturns the pause mode of this socket\n\nReturns the size in bytes of the readbuffer that is used by the socket.\n\nReturns the request that was or will be used to open this socket.\n\nThis function was introduced in Qt 5.6.\n\nReturns the url the socket is connected to or will connect to.\n\nReturns the name of the resource currently accessed.\n\nContinues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is sslErrors(). Calling this method if the socket is not paused results in undefined behavior.\n\nSee also pauseMode() and setPauseMode().\n\nSends the given data over the socket as a binary message and returns the number of bytes actually sent.\n\nSends the given message over the socket as a text message and returns the number of bytes actually sent.\n\nSets the generator to use for creating masks to maskGenerator. The default QWebSocket generator can be reset by supplying a nullptr. The mask generator can be changed at any time, even while the connection is open.\n\nSets the maximum allowed size of an incoming websocket frame to maxAllowedIncomingFrameSize. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingFrameSize(), default is maxIncomingFrameSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nThis function was introduced in Qt 5.15.\n\nSets the maximum allowed size of an incoming websocket message to maxAllowedIncomingMessageSize. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingMessageSize(), default is maxIncomingMessageSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nThis function was introduced in Qt 5.15.\n\nSets the maximum size of an outgoing websocket frame to outgoingFrameSize. The accepted range is between 0 and maxOutgoingFrameSize(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.\n\nThis function was introduced in Qt 5.15.\n\nControls whether to pause upon receiving a notification. The pauseMode parameter specifies the conditions in which the socket should be paused.\n\nThe only notification currently supported is sslErrors(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling resume(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.\n\nSee also pauseMode() and resume().\n\nSets the size of QWebSocket's internal read buffer to be size bytes.\n\nIf the buffer size is limited to a certain size, QWebSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.\n\nSets the socket's SSL configuration to be the contents of sslConfiguration.\n\nThis function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in sslConfiguration. It is not possible to set the SSL-state related fields.\n\nReturns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.\n\nReturns the current state of the socket.\n\nThis function was introduced in Qt 6.4.\n\nReturns the version the socket is currently using."
    }
]