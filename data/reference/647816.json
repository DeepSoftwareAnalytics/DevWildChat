[
    {
        "link": "https://stackoverflow.com/questions/5532253/exception-handling-placement-c-sharp",
        "document": "I've decided to remove some of the using statements in my code so I can catch specific exceptions and handle the disposing of resources manually. I have refactored some of the code to make it more readable and maintable, after implementing the new try/catch block I am left wondering if they have been placed correctly for the task at hand.\n\nIn this example I have only implemented the try/catch around the SQL operations themselves, I did this as it ensures any exceptions that are thrown can be noted and the resourced disposed correctly. I then noticed that this left the for loop open to exceptions, although the supplied indexer will be protected and created via a GUI.\n\nWould I be wise to encapsulate the entire method in the try/catch statement or am I being overly cautious? You could say I'm looking for the best practice when it comes to managing the placement of the statements themselves.\n\nThanks for your time!\n\nI know that the using statement would be ideal in terms of handling the disposal and management of resources however as mentioned at the beginning of the question I wish to be able to catch specific types of exceptions, in particular those generated from the SQLite components."
    },
    {
        "link": "https://stackoverflow.com/questions/71171771/microsoft-data-sqlite-unexpected-behaviour",
        "document": "There is a method in my code, which initializes sqlite3 db to a specified directory as you can see in the following code snippet:\n\nCase 1: When calling this this method for the first time, everything works as expected. Which means => Database file is created with table(MyTable) that is specified in the code.\n\nCase 2: When calling this this method for the 2nd time, after manual database file deletion, database file is created WITHOUT table(MyTable) that is specified in the code and the following error occurs => SQLite Error 8: 'attempt to write a readonly database'\n\nIt seems to me, as if connection to the database was not properly disposed after first run or database that was created during first run, stays cached in memory somehow.\n\nExpected behaviour: Method should create sqlite database file with specified tables, every time it's called, when the conditions above are met.\n\nWorth to mention: When replacing 'File.Create()' method with 'Mode=ReadWriteCreate' ConnectionString, the file doesn't get created for the 2nd time, after manual deletion. Only during the first method run.\n\nEDIT: Swapped 'Microsoft.Data.Sqlite' for 'System.Data.SQLite.Core' and now the method works as expected every time.\n\nI guess It's either a BUG in 'Microsoft.Data.Sqlite', or I am just missing an important difference between those 2 libraries.\n\nWould be great to have an official answer from MSFT devs as to what I was doing wrong."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/database-errors",
        "document": "SqliteException is thrown when a SQLite error is encountered. The message is provided by SQLite. The and properties contain the SQLite result code of the error.\n\nErrors may be encountered any time the Microsoft.Data.Sqlite interacts with the native SQLite library. The following list shows the common scenarios where errors can occur:\n\nConsider carefully how your app will handle these errors.\n\nSQLite is aggressive when it comes to locking tables and database files. If your app enables any concurrent database access, you'll likely encounter busy and locked errors. You can mitigate many errors by using write-ahead logging.\n\nWhenever Microsoft.Data.Sqlite encounters a busy or locked error, it will automatically retry until it succeeds or the command timeout is reached.\n\nYou can increase the timeout of a command by setting CommandTimeout. The default timeout is 30 seconds. A value of means no timeout.\n\nMicrosoft.Data.Sqlite sometimes needs to create an implicit command object. For example, during BeginTransaction. To set the timeout for these commands, use DefaultTimeout."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions",
        "document": "Proper exception handling is essential for application reliability. You can intentionally handle expected exceptions to prevent your app from crashing. However, a crashed app is more reliable and diagnosable than an app with undefined behavior.\n\nThis article describes best practices for handling and creating exceptions.\n\nThe following best practices concern how you handle exceptions:\n• Use try/catch/finally blocks to recover from errors or release resources\n• Design classes so that exceptions can be avoided\n\nUse try/catch/finally blocks to recover from errors or release resources\n\nFor code that can potentially generate an exception, and when your app can recover from that exception, use / blocks around the code. In blocks, always order exceptions from the most derived to the least derived. (All exceptions derive from the Exception class. More derived exceptions aren't handled by a clause that's preceded by a clause for a base exception class.) When your code can't recover from an exception, don't catch that exception. Enable methods further up the call stack to recover if possible.\n\nClean up resources that are allocated with either statements or blocks. Prefer statements to automatically clean up resources when exceptions are thrown. Use blocks to clean up resources that don't implement IDisposable. Code in a clause is almost always executed even when exceptions are thrown.\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that avoids the exception. For example, if you try to close a connection that's already closed, you'll get an . You can avoid that by using an statement to check the connection state before trying to close it.\n\nIf you don't check the connection state before closing, you can catch the exception.\n\nThe approach to choose depends on how often you expect the event to occur.\n• None Use exception handling if the event doesn't occur often, that is, if the event is truly exceptional and indicates an error, such as an unexpected end-of-file. When you use exception handling, less code is executed in normal conditions.\n• None Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions. Up-front checks eliminate exceptions most of the time. However, there can be race conditions where the guarded condition changes between the check and the operation, and in that case, you could still incur an exception.\n\nIf the performance cost of exceptions is prohibitive, some .NET library methods provide alternative forms of error handling. For example, Int32.Parse throws an OverflowException if the value to be parsed is too large to be represented by Int32. However, Int32.TryParse doesn't throw this exception. Instead, it returns a Boolean and has an parameter that contains the parsed valid integer upon success. Dictionary<TKey,TValue>.TryGetValue has similar behavior for attempting to get a value from a dictionary.\n\nIt's better to catch OperationCanceledException instead of TaskCanceledException, which derives from , when you call an asynchronous method. Many asynchronous methods throw an OperationCanceledException exception if cancellation is requested. These exceptions enable execution to be efficiently halted and the callstack to be unwound once a cancellation request is observed.\n\nAsynchronous methods store exceptions that are thrown during execution in the task they return. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as ArgumentException, are still thrown synchronously. For more information, see Asynchronous exceptions.\n\nDesign classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, the FileStream class provides methods that help determine whether the end of the file has been reached. You can call these methods to avoid the exception that's thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception:\n\nAnother way to avoid exceptions is to return (or default) for most common error cases instead of throwing an exception. A common error case can be considered a normal flow of control. By returning (or default) in these cases, you minimize the performance impact to an app.\n\nFor value types, consider whether to use or as the error indicator for your app. By using , becomes instead of . Sometimes, adding can make it clearer when a value is present or absent. Other times, adding can create extra cases to check that aren't necessary and only serve to create potential sources of errors.\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nThe preceding method doesn't directly throw any exceptions. However, you must write the method so that the withdrawal is reversed if the deposit operation fails.\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nThis example illustrates the use of to rethrow the original exception, making it easier for callers to see the real cause of the problem without having to examine the InnerException property. An alternative is to throw a new exception and include the original exception as the inner exception.\n\nOnce an exception is thrown, part of the information it carries is the stack trace. The stack trace is a list of the method call hierarchy that starts with the method that throws the exception and ends with the method that catches the exception. If you rethrow an exception by specifying the exception in the statement, for example, , the stack trace is restarted at the current method and the list of method calls between the original method that threw the exception and the current method is lost. To keep the original stack trace information with the exception, there are two options that depend on where you're rethrowing the exception from:\n• If you rethrow the exception from within the handler ( block) that's caught the exception instance, use the statement without specifying the exception. Code analysis rule CA2200 helps you find places in your code where you might inadvertently lose stack trace information.\n• If you're rethrowing the exception from somewhere other than the handler ( block), use ExceptionDispatchInfo.Capture(Exception) to capture the exception in the handler and ExceptionDispatchInfo.Throw() when you want to rethrow it. You can use the ExceptionDispatchInfo.SourceException property to inspect the captured exception.\n\nThe following example shows how the ExceptionDispatchInfo class can be used, and what the output might look like.\n\nIf the file in the example code doesn't exist, the following output is produced:\n\nThe following best practices concern how you throw exceptions:\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n• If a property set or method call isn't appropriate given the object's current state, throw an InvalidOperationException exception.\n• If invalid parameters are passed, throw an ArgumentException exception or one of the predefined classes that derive from ArgumentException.\n\nIt's common for a class to throw the same exception from different places in its implementation. To avoid excessive code, create a helper method that creates the exception and returns it. For example:\n\nSome key .NET exception types have such static helper methods that allocate and throw the exception. You should call these methods instead of constructing and throwing the corresponding exception type:\n\nIf you're implementing an asynchronous method, call CancellationToken.ThrowIfCancellationRequested() instead of checking if cancellation was requested and then constructing and throwing OperationCanceledException. For more information, see CA2250.\n\nThe error message the user sees is derived from the Exception.Message property of the exception that was thrown, and not from the name of the exception class. Typically, you assign a value to the Exception.Message property by passing the message string to the argument of an Exception constructor.\n\nFor localized applications, you should provide a localized message string for every exception that your application can throw. You use resource files to provide localized error messages. For information on localizing applications and retrieving localized strings, see the following articles:\n• How to: Create user-defined exceptions with localized exception messages\n\nWrite clear sentences and include ending punctuation. Each sentence in the string assigned to the Exception.Message property should end in a period. For example, \"The log table has overflowed.\" uses correct grammar and punctuation.\n\nPlace throw statements where the stack trace will be helpful. The stack trace begins at the statement where the exception is thrown and ends at the statement that catches the exception.\n\nDon't raise exceptions in clauses. For more information, see code analysis rule CA2219.\n\nSome methods, such as , , and methods, static constructors, and equality operators, shouldn't throw exceptions. For more information, see code analysis rule CA1065.\n\nIn task-returning methods, you should validate arguments and throw any corresponding exceptions, such as ArgumentException and ArgumentNullException, before entering the asynchronous part of the method. Exceptions that are thrown in the asynchronous part of the method are stored in the returned task and don't emerge until, for example, the task is awaited. For more information, see Exceptions in task-returning methods.\n\nThe following best practices concern custom exception types:\n\nWhen a custom exception is necessary, name it appropriately and derive it from the Exception class. For example:\n\nUse at least the three common constructors when creating your own exception classes: the parameterless constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n• Exception(String, Exception), which accepts a string message and an inner exception.\n\nFor an example, see How to: Create user-defined exceptions.\n\nProvide additional properties for an exception (in addition to the custom message string) only when there's a programmatic scenario where the additional information is useful. For example, the FileNotFoundException provides the FileName property."
    },
    {
        "link": "https://learn.microsoft.com/en-gb/answers/questions/1341197/sqlite-problems-c-visual-studio",
        "document": "An object-oriented and type-safe programming language that has its roots in the C family of languages and includes support for component-oriented programming."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/data/sqlite/parameters",
        "document": "Parameters are used to protect against SQL injection attacks. Instead of concatenating user input with SQL statements, use parameters to ensure input is only ever treated as a literal value and never executed. In SQLite, parameters are typically allowed anywhere a literal is allowed in SQL statements.\n\nParameters can be prefixed with either , , or .\n\nSee Data types for details about how .NET values are mapped to SQLite values.\n\nUse the Size property to truncate TEXT and BLOB values.\n\nSometimes, you may want to use an alternative SQLite type. Do this by setting the SqliteType property.\n\nThe following alternative type mappings can be used. For the default mappings, see Data types.\n\nSQLite doesn't support output parameters. Return values in the query results instead."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/apps/develop/data-access/sqlite-data-access",
        "document": "You can use SQLite to store and retrieve data in a lightweight database on the user's device. This guide shows you how to do it in your Windows App SDK apps.\n\nSome benefits of using SQLite for local storage\n\n✔️ SQLite is lightweight and self-contained. It's a code library without any other dependencies. There's nothing to configure.\n\n✔️ There's no database server. The client and the server run in the same process.\n\n✔️ SQLite is in the public domain so you can freely use and distribute it with your app.\n\nYou can read more about SQLite here.\n\nWe recommend that you use either Entity Framework Core or the open-source SQLite library built by Microsoft.\n\nEntity Framework (EF) is an object-relational mapper that you can use to work with relational data by using domain-specific objects. If you've already used this framework to work with data in other .NET apps, you can use the same code in your Windows App SDK app and it will work with appropriate changes to the connection string.\n\nTo try it out, see Getting Started with EF Core.\n\nThe Microsoft.Data.Sqlite library implements the interfaces in the System.Data.Common namespace. Microsoft actively maintains these implementations, and they provide an intuitive wrapper around the low-level native SQLite API.\n\nThe rest of this guide helps you to use this library.\n\nSet up your solution to use the Microsoft.Data.SQlite library\n\nWe'll start with a basic Windows App SDK project, and then install the SQLite NuGet package.\n\nAll supported versions of Windows support SQLite, so your app does not have to package SQLite libraries. Instead, your app can use the version of SQLite that comes installed with Windows. This helps you in a few ways.\n\n✔️ Reduces the size of your application because you don't have to download the SQLite binary, and then package it as part of your application.\n\n✔️ Prevents you from having to push a new version of your app to users in the event that SQLite publishes critical fixes to bugs and security vulnerabilities in SQLite. The Windows version of SQLite is maintained by Microsoft in coordination with SQLite.org.\n\n✔️ App load time has the potential to be faster because most likely, the SDK version of SQLite will already be loaded into memory.\n\nLet's start by adding a class to your project named DataAccess. If you plan to share your data access logic with other client code, you can use a .NET class library project to contain your data access code, but we won't use one in our example.\n• None Right-click the solution, and then click Manage NuGet Packages for Solution. At this point, you have a choice. You can use the version of SQLite that is included with Windows or if you have some reason to use a specific version of SQLite, you can include the SQLite library in your package. We are going to use the version of SQLite that's included with Windows.\n• None Choose the Browse tab, search for the Microsoft.Data.SQLite package, and then install the latest stable version.\n\nWe'll do these things:\n\nOpen the class in your project and make that class static.\n\nAdd the following statements to the top of this file.\n\nAdd a method to the class that initializes the SQLite database.\n\nThis code creates the SQLite database and stores it in the application's local data store.\n\nIn this example, we name the database but you can use whatever name you want as long as you use that name in all SqliteConnection objects that you instantiate. In a production application, connection information such as the database filename should be stored in app configuration rather than hard-coded (see Adding Azure App Configuration by using Visual Studio Connected Services).\n\nIn the constructor of the App.xaml.cs file of your project, call the method of the class. This will ensure that the database is created or opened each time the app starts.\n\nAdd a method to the class that inserts data into the SQLite database. This code uses parameters in the query to prevent SQL injection attacks.\n\nAdd a method that gets all rows of data from a table in our SQLite database.\n\nThe Read method advances through the rows of returned data. It returns if there are rows left, otherwise it returns .\n\nThe GetString method returns the value of the specified column as a string. It accepts an integer value that represents the zero-based column ordinal of the data that you want. You can use similar methods such as GetDataTime and GetBoolean. Choose a method based on what type of data the column contains.\n\nThe ordinal parameter isn't as important in this example because we are selecting all of the entries in a single column. However, if multiple columns are part of your query, use the ordinal value to obtain the column you want to pull data from.\n\nIn the MainWindow.xaml file of the project, add the following XAML.\n\nThis basic user interface gives the user a that they can use to type a string that we'll add to the SQLite database. We'll connect the in this UI to an event handler that will retrieve data from the SQLite database and then show that data in the .\n\nIn the MainWindow.xaml.cs file, add the following handler. This is the method that we associated with the event of the in the UI.\n\nWe also want to be sure that any existing data is loaded when the application starts. Add a line of code to the constructor to call .\n\nThat's it. Explore the Microsoft.Data.Sqlite to see what other things you can do with your SQLite database. Check out the links below to learn about other ways to use data in your Windows apps.\n\nSee Use a SQL Server database in a Windows app.\n\nShare code between different apps across different platforms\n\nSee Share code between desktop and UWP."
    },
    {
        "link": "https://stackoverflow.com/questions/69273253/c-sharp-sqlite-parameterized-queries-fail-to-include-parameter-value",
        "document": "I'm attempting to rework some SQLite queries that I'm making in the my application to use parameters instead of concatenating a string, to make sure that my code is not prone to SQL injection attacks and is more robust in general. However, I'm failing to get any parameterized queries to successfully execute in my application. I've browsed countless examples and related questions and none have helped.\n\nWhen I execute the above code manually in DBBrowser for SQLite, replacing '@tablename' with Service as I'd like to do programatically, the query works fine and inserts the table as it should.\n\nHowever, when I execute the code, I get the following exception :\n\nWhen I modify my code to omit the '@' character in front of the parameter name, the code executes successfully, but performs the query without parameterizing it - IE despite changing the parameter name that I pass in from '@tablename' to 'tablename', the query that gets execute is :\n\nI have a feeling at this point that there is a deeper underlying issue that is causing this, maybe to do with .NET Framework 4.5 version that I've selected for this sample project. System.Data.Sqlite library version being used is 1.0.115."
    },
    {
        "link": "https://stackoverflow.com/questions/21225354/c-sharp-sqlite-injection",
        "document": "SQL injection isn't about creatively using quote characters. It's about treating input as data instead of as code. Take a look at a classic SQL injection vulnerability:\n\nIt may intuitively look like you're using as a data value, but you're actually using it as actual SQL code. The SQL engine doesn't see this as a value parameter, it sees it as part of the command being executed. That code should just be a value, but it can be anything. And you'd be executing whatever code is supplied.\n\nThinking of it in this way, it becomes clear that you should never execute user-supplied code in your application.\n\nThe alternative is to treat the user input as values in pre-defined code. That way you control the complete scope of the code and users are only supplying values. Which would look more like this:\n\nNow the SQL engine sees that parameter ( ) and expects you to supply a value for that parameter. In ADO.NET it might look something like:\n\nNow the SQL engine knows that this is a data value and not code, so it treats it as data instead of executing it."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/uwp/data-access/sqlite-databases",
        "document": "You can use SQLite to store and retrieve data in a light-weight database on the user's device. This guide shows you how.\n\nSome benefits of using SQLite for local storage\n\n✔️ SQLite is light-weight and self-contained. It's a code library without any other dependencies. There's nothing to configure.\n\n✔️ There's no database server. The client and the server run in the same process.\n\n✔️ SQLite is in the public domain so you can freely use and distribute it with your app.\n\nYou can read more about SQLite here.\n\nWe recommend that you use either the Entity Framework Core or the open-source SQLite library built by Microsoft.\n\nEntity Framework (EF) is an object-relational mapper that you can use to work with relational data by using domain-specific objects. If you've already used this framework to work with data in other .NET apps, you can migrate that code to a UWP app and it will work with appropriate changes to the connection string.\n\nTo try it out, see Getting Started with EF Core.\n\nThe Microsoft.Data.Sqlite library implements the interfaces in the System.Data.Common namespace. Microsoft actively maintains these implementations, and they provide an intuitive wrapper around the low-level native SQLite API.\n\nThe rest of this guide helps you to use this library.\n\nSet up your solution to use the Microsoft.Data.SQlite library\n\nWe'll start with a basic UWP project, and then install the appropriate Nuget packages.\n\nAll supported versions of Windows support SQLite, so your app does not have to package SQLite libraries. Instead, your app can use the version of SQLite that comes installed with Windows. This helps you in a few ways.\n\n✔️ Reduces the size of your application because you don't have to download the SQLite binary, and then package it as part of your application.\n\n✔️ Prevents you from having to push a new version of your app to users in the event that SQLite publishes critical fixes to bugs and security vulnerabilities in SQLite. The Windows version of SQLite is maintained by Microsoft in coordination with SQLite.org.\n\n✔️ App load time has the potential to be faster because most likely, the SDK version of SQLite will already be loaded into memory.\n\nLet's start by adding a class to your UWP project named DataAccess. You can use a .NET Standard class library project to contain your data access code, but we won't use one in our example.\n\nRight-click the solution, and then click Manage NuGet Packages for Solution.\n\nAt this point, you have a choice. You can use the version of SQLite that is included with Windows or if you have some reason to use a specific version of SQLite, you can include the SQLite library in your package. We are going to use the version of SQLite that's included with Windows.\n\nChoose the Browse tab, search for the Microsoft.Data.SQLite.Core package, and then install the latest stable version.\n\nWe'll do these things:\n\nOpen the class in your project and make that class static.\n\nAdd the following using statements to the top of this file.\n\nAdd a method to the class that initializes the SQLite database.\n\nThis code creates the SQLite database and stores it in the application's local data store.\n\nIn this example, we name the database but you can use whatever name you want as long as you use that name in all SqliteConnection objects that you instantiate.\n\nIn the constructor of the App.xaml.cs file of your UWP project, call the method of the class.\n\nAdd a method to the class that inserts data into the SQLite database. This code uses parameters in the query to prevent SQL injection attacks.\n\nAdd a method that gets rows of data from a SQLite database.\n\nThe Read method advances through the rows of returned data. It returns if there are rows left, otherwise it returns .\n\nThe GetString method returns the value of the specified column as a string. It accepts an integer value that represents the zero-based column ordinal of the data that you want. You can use similar methods such as GetDataTime and GetBoolean. Choose a method based on what type of data the column contains.\n\nThe ordinal parameter isn't as important in this example because we are selecting all of the entries in a single column. However, if multiple columns are part of your query, use the ordinal value to obtain the column you want to pull data from.\n\nIn the MainPage.xaml file of the UWP project, add the following XAML.\n\nThis basic user interface gives the user a that they can use to type a string that we'll add to the SQLite database. We'll connect the in this UI to an event handler that will retrieve data from the SQLite database and then show that data in the .\n\nIn the MainPage.xaml.cs file, add the following handler. This is the method that we associated with the event of the in the UI.\n\nWe also want to be sure that any existing data is loaded when the application starts. Add a line of code to the constructor to call .\n\nThat's it. Explore the Microsoft.Data.Sqlite to see what other things you can do with your SQLite database. Check out the links below to learn about other ways to use data in your UWP app.\n\nSee Use a SQL Server database in a UWP app.\n\nShare code between different apps across different platforms\n\nSee Share code between desktop and UWP."
    }
]