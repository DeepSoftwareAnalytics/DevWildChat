[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
        "document": "Boolean values are typically produced by relational operators, equality operators, and logical NOT ( ). They can also be produced by functions that represent conditions, such as . Note that binary logical operators such as and return the values of the operands, which may or may not be boolean values.\n\nBoolean values are typically used in conditional testing, such as the condition for and statements, the conditional operator ( ), or the predicate return value of .\n\nYou would rarely need to explicitly convert something to a boolean value, as JavaScript does this automatically in boolean contexts, so you can use any value as if it's a boolean, based on its truthiness. You are also encouraged to use and instead of or in your own code so you can take advantage of this convention. However, making sure that values representing conditions are always booleans can help clarify the intent of your code."
    },
    {
        "link": "https://stackoverflow.com/questions/31253687/setting-and-getting-a-boolean-object-property-in-javascript",
        "document": "So I just submitted my very first pull request on a collaborative software project (a web app built with Ember.js), and I noticed that I had carelessly included a boolean variable (conditionally set inside a function) in an object literal using only the variable name rather than a key-value pair, like so:\n\nI was surprised that accessing the boolean later with\n\nseems to work, but is this valid JavaScript? Otherwise poor form? Setting it with something like feels less DRY if the above is OK."
    },
    {
        "link": "https://geeksforgeeks.org/es6-boolean",
        "document": "The Boolean of ES6 is nothing different than the other Boolean objects. It also represents two values True or False. There are two properties and three methods that build this object in ES6 JavaScript.\n\nJavaScript constructor: In ES6 JavaScript, the constructor property returns the constructor function for an object. For ES6 JavaScript Boolean, the constructor property returns function Boolean() { [native code] }.\n\nParameter: It does not require any parameters.\n\nReturn Value: It returns the function Boolean() { [native code] }.\n\nJavaScript prototype: The Boolean.prototype is an inbuilt property in ES6 JavaScript which is used to add a new property to the all Boolean instances. There is a constructor prototype that is used to add properties or methods to all Boolean objects.\n‚Ä¢ Boolean.prototype.valueOf(): It simply returns the value of boolean object.\n‚Ä¢ Boolean.prototype.toString(): This method returns a string according to the Boolean value.\n\nJavaScript valueOf() Method: The Boolean.valueOf() method is an inbuilt methods in ES6 javascript which is used to return a boolean value either ‚Äútrue‚Äù or ‚Äúfalse‚Äù depending upon the value of the specified boolean object.\n\nReturn Value: It returns false if the string argument is null otherwise it returns true.\n\nJavaScript toString() Method: The boolean.toString() is an inbuilt method in ES6 javascript which is used to return a string either ‚Äútrue‚Äù or ‚Äúfalse‚Äù depending upon the value of the specified boolean object.\n\nReturn Value: It returns a string either ‚Äútrue‚Äù or ‚Äúfalse‚Äù depending upon the value of the specified Boolean object.\n\nJavaScript toSource() Method: The boolean.toSource() is an inbuilt method in ES6 JavaScript which is used to return a string representing the source code of the object.\n\nReturn Value: It returns a string representing the source code of the object.\n\nNote: This method is not compatible with all browsers.\n\nWe have a complete list of Javascript ES6 features, to check those please go through this Introduction to ES6 article.\n\nWe have a Cheat Sheet on Javascript where we covered all the important topics of Javascript to check those please go through"
    },
    {
        "link": "https://kevinpeters.net/adding-object-properties-conditionally-with-es-6",
        "document": "This was a tweet recently by an engineer from Google who is working on the V8 engine powering the Google Chrome web browser and Node.js. It got me to think what use-cases are extremely helpful for me and that I should share them with the world here.\n\nAdding a property to an object is quite easy in JavaScript. You can basically do it like in the following code.\n\nBut imagine the lastName should just be added if there is a specific conditional.\n\nThis still looks fine but what if we combine conditions and add them into multiple if blocks?\n\nIt looks a lot harder to read overall and a function with this code would grow a lot even though it is just doing simple things.\n\nEcmaScript 6 (ES6) is a new standard which enables a lot of new features in the language JavaScript. With those features, we could write the following code.\n\nThe result of the value of person would be the same as in the script mentioned above. But how does this work?\n\nis a logical operator in JavaScript and is combining boolean values by using AND . It can be used with two parameters. Let us assume those parameters are a and b . When we apply the parameter it would look like . This will result in a boolean as a result which can be either or . It will be true if both of the parameters are also true . If one, or both, are false the result will be false too.\n\nA specialty is also that when not using booleans for a or b it can happen that no boolean is getting returned. We can simply check this by using the browser console.\n\nWe can extend this feature and also return an object which is super nice.\n\nBut somehow we need to merge this object into the person object above ü§Ø\n\nMerging objects is possible for a long time already in JavaScript with the functionality.\n\nWhat happens here is that the last parameter gets merged into the object . If properties would be the same the last object would win and overwrite the property of the preceding object. Also Object.assign is mutable function. This means it will apply all changes to the first parameter in all parameters of the function. To avoid changes to the basePerson object we pass an empty object as the first parameter, so a new object is being created rather than an old one which is reused.\n\nEcmaScript 6 (ES6) offers a nicer way to do these merges.\n\nThis would result in the same person object as before with the properties and . Also, here the last properties are overwriting the first properties, but we still have a problem of applying the object returned in the expression into the object because the current version assumes that is just a key and has a static value.\n\nWe can pass an object to be destructured though into the person object to actually pass an object rather than key and a value.\n\nThis might be enough now to refactor and put in a variable but we have one problem as could result in either or . If we pass the object to the destructuring function everything is fine but what is happening if we pass something like ...false in?\n\nActually, this would result in nothing when being used in an object. This also means we can use it in the big destructuring functionality.\n\nThis is super nice but can be still improved by inlining the result somehow.\n\nThis is a super slick example on how to extend objects conditionally in JavaScript and really shows that when using modern language we can use a more crisp syntax to express ourself.\n\nThese functions become especially important when you create the same type of object, sometimes with some properties and sometimes not. Think of factory functions for unit or integration tests.\n\nIf you are interested in more JavaScript content, check out my blog articles Add or delete a property of an object in JavaScript, How to debug JavaScript applications and tests or Function parameters in JavaScript."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects",
        "document": "JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method. Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics. In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.\n\nObject initializers are also called object literals. \"Object initializer\" is consistent with the terminology used by C++. The syntax for an object using an object initializer is: const obj = { property1: value1, // property name may be an identifier 2: value2, // or a number \"property n\": value3, // or a string }; Each property name before colons is an identifier (either a name, a number, or a string literal), and each is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax. In this example, the newly created object is assigned to a variable ‚Äî this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.) Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal. The following statement creates an object and assigns it to the variable if and only if the expression is true: let x; if (cond) { x = { greeting: \"hi there\" }; } The following example creates with three properties. Note that the property is also an object with its own properties. Objects created with initializers are called plain objects, because they are instances of , but not any other object type. Some object types have special initializer syntaxes ‚Äî for example, array initializers and regex literals.\n\nAlternatively, you can create an object with these two steps:\n‚Ä¢ Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.\n‚Ä¢ Create an instance of the object with . To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called , and you want it to have properties for make, model, and year. To do this, you would write the following function: Notice the use of to assign values to the object's properties based on the values passed to the function. Now you can create an object called as follows: This statement creates and assigns it the specified values for its properties. Then the value of is the string , is the string , is the integer , and so on. The order of arguments and parameters should be the same. You can create any number of objects by calls to . For example, An object can have a property that is itself another object. For example, suppose you define an object called as follows: and then instantiate two new objects as follows: Then, you can rewrite the definition of to include an property that takes a object, as follows: To instantiate the new objects, you then use the following: Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects and as the arguments for the owners. Then if you want to find out the name of the owner of , you can access the following property: You can always add a property to a previously defined object. For example, the statement adds a property to , and assigns it a value of . However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the object type. You can also use the syntax instead of the syntax to define a constructor function. For more information, see the class guide.\n\nYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the object as follows: An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e. not determinable until runtime. Examples are as follows: const myObj = {}; const str = \"myString\"; const rand = Math.random(); const anotherObj = {}; // Create additional properties on myObj myObj.type = \"Dot syntax for a key named type\"; myObj[\"date created\"] = \"This key has a space\"; myObj[str] = \"This key is in variable str\"; myObj[rand] = \"A random number is the key here\"; myObj[anotherObj] = \"This key is object anotherObj\"; myObj[\"\"] = \"This key is an empty string\"; console.log(myObj); // { // type: 'Dot syntax for a key named type', // 'date created': 'This key has a space', // myString: 'This key is in variable str', // '0.6398914448618778': 'A random number is the key here', // '[object Object]': 'This key is object anotherObj', // '': 'This key is an empty string' // } console.log(myObj.myString); // 'This key is in variable str' In the above code, the key is an object, which is neither a string nor a symbol. When it is added to the , JavaScript calls the method of , and use the resulting string as the new key. You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable held and it is that is the property name. Therefore, will return as undefined. str = \"myString\"; myObj[str] = \"This key is in variable str\"; console.log(myObj.str); // undefined console.log(myObj[str]); // 'This key is in variable str' console.log(myObj.myString); // 'This key is in variable str' This allows accessing any property as determined at runtime: let propertyName = \"make\"; myCar[propertyName] = \"Ford\"; // access different properties by changing the contents of the variable propertyName = \"model\"; myCar[propertyName] = \"Mustang\"; console.log(myCar); // { make: 'Ford', model: 'Mustang' } However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks. Nonexistent properties of an object have value (and not ).\n\nThere are three native ways to list/traverse object properties:\n‚Ä¢ loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.\n‚Ä¢ . This method returns an array with only the enumerable own string property names (\"keys\") in the object , but not those in the prototype chain.\n‚Ä¢ . This method returns an array containing all the own string property names in the object , regardless of if they are enumerable or not. You can use the bracket notation with to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function: function showProps(obj, objName) { let result = \"\"; for (const i in obj) { // Object.hasOwn() is used to exclude properties from the object's // prototype chain and only show \"own properties\" if (Object.hasOwn(obj, i)) { result += `${objName}.${i} = ${obj[i]}\n\n`; } } console.log(result); } The term \"own property\" refers to the properties of the object, but excluding those of the prototype chain. So, the function call would print the following: The above is equivalent to: There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function: function listAllProperties(myObj) { let objectToInspect = myObj; let result = []; while (objectToInspect !== null) { result = result.concat(Object.getOwnPropertyNames(objectToInspect)); objectToInspect = Object.getPrototypeOf(objectToInspect); } return result; } For more information, see Enumerability and ownership of properties.\n\nA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is: objectName.methodName = functionName; const myObj = { myMethod: function (params) { // do something }, // this works too! myOtherMethod(params) { // do something else }, }; where is an existing object, is the name you are assigning to the method, and is the name of the function. You can then call the method in the context of the object as follows: Methods are typically defined on the object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined objects. Notice the use of to refer to the object to which the method belongs. Then you can call the method for each of the objects as follows:\n\nUsing this for object references JavaScript has a special keyword, , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, and . Each object has its own , and . In the function , notice the use of . When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to. const Manager = { name: \"Karina\", age: 27, job: \"Software Engineer\", }; const Intern = { name: \"Tyrone\", age: 21, job: \"Software Engineer Intern\", }; function sayHi() { console.log(`Hello, my name is ${this.name}`); } // add sayHi function to both objects Manager.sayHi = sayHi; Intern.sayHi = sayHi; Manager.sayHi(); // Hello, my name is Karina Intern.sayHi(); // Hello, my name is Tyrone is a \"hidden parameter\" of a function call that's passed in by specifying the object before the function that was called. For example, in , is the object, because comes before the function . If you access the same function from another object, will change as well. If you use other methods to call the function, like or , you can explicitly pass the value of as an argument.\n\nA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property. Getters and setters can be either\n‚Ä¢ added later to any existing object. Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords or . The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance: const myObj = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2; }, }; console.log(myObj.a); // 7 console.log(myObj.b); // 8, returned from the get b() method myObj.c = 50; // Calls the set c(x) method console.log(myObj.a); // 25\n‚Ä¢ ‚Äî a setter that sets the value of to half of the value is being set to Getters and setters can also be added to an object at any time after creation using the method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example: const myObj = { a: 0 }; Object.defineProperties(myObj, { b: { get() { return this.a + 1; }, }, c: { set(x) { this.a = x / 2; }, }, }); myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property console.log(myObj.b); // Runs the getter, which yields a + 1 or 6 Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later ‚Äî maybe because you did not write the particular object ‚Äî then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand."
    },
    {
        "link": "https://blog.pixelfreestudio.com/best-practices-for-managing-state-in-react-applications",
        "document": "State management is one of the most critical aspects of building modern React applications. Whether you‚Äôre building a simple web app or a complex platform, how you manage the state of your components can significantly impact the performance, scalability, and maintainability of your project. Poor state management can lead to performance bottlenecks, unpredictable behavior, and difficult-to-maintain code.\n\nIn this article, we‚Äôll explore best practices for managing state in React applications, from using local component state efficiently to handling global state with tools like React‚Äôs Context API, Redux, and more. Whether you‚Äôre new to React or looking to improve your current projects, these best practices will help you create more predictable and scalable applications.\n\nWhat is State in React?\n\nIn React, state refers to data that can change over time and needs to be reflected in the UI. Every React component can have its own state, and this state is what drives the dynamic, interactive behavior of the application. A component‚Äôs state can be modified through user input (such as typing in a form), external data (like API responses), or system events (such as timers or resizing).\n\nIn React, state management is the practice of controlling how and where this state is stored, updated, and accessed across different components. As applications grow in size and complexity, managing state effectively becomes crucial for maintaining the app‚Äôs performance and reliability.\n\nWithout proper state management, React applications can quickly become difficult to work with. If components rely on unstructured or ad-hoc state management, you may encounter problems such as:\n\nInconsistent UI: If state is not properly synchronized, parts of your application can display outdated or incorrect information.\n\nPerformance issues: Unnecessary re-renders caused by improper state updates can lead to slow performance, especially in large applications.\n\nComplex code maintenance: When state management is scattered across components without a clear strategy, maintaining and scaling the application becomes a challenge.\n\nEffective state management helps ensure that your app‚Äôs data is organized, easy to update, and predictably affects the UI. Let‚Äôs dive into some best practices for managing state in React.\n\nLocal state is managed within a single component and is used for small pieces of data that don‚Äôt need to be shared across multiple components. In many cases, local state can be the most efficient way to manage state in a React application, especially when dealing with isolated components.\n\nThe hook is React‚Äôs simplest way of managing local state in functional components. It‚Äôs perfect for managing simple data like form input values, toggle switches, or counters.\n\nExample: Using for a Counter\n\nIn this example, is used to manage the count state of the component. Every time the button is clicked, the is incremented, and the component re-renders to display the updated value.\n\nBest Practice: Only use for local, simple state that doesn‚Äôt need to be shared with other components.\n\nFor more complex state logic or state that depends on multiple actions, consider using the hook instead of . allows you to define state transitions more clearly by handling different actions in a reducer function.\n\nExample: Using for Form State\n\nBest Practice: Use when managing complex state transitions, especially when state updates are based on multiple types of actions.\n\n3. Keep Local State as Close to the Component as Possible\n\nAs a general rule, try to keep local state as close to the component that needs it as possible. If a piece of state is only needed by a specific component, store it in that component rather than lifting it up or managing it globally. This makes your app easier to maintain and reduces unnecessary re-renders.\n\nBest Practice: Avoid ‚Äúlifting state up‚Äù unnecessarily. Keep state local unless multiple components need access to the same data.\n\nWhile local state is sufficient for managing small, isolated pieces of data, most React applications will require global state at some point. Global state is any state that needs to be shared across multiple components, such as user authentication data, app-wide settings, or data fetched from an API.\n\nHere are some best practices for managing global state in React applications.\n\nThe Context API is React‚Äôs built-in solution for managing global state. It allows you to share state between components without prop drilling‚Äîwhere props are manually passed through many layers of components.\n\nExample: Using Context API for Theme Management\n\nBest Practice: Use the Context API for simple global state that doesn‚Äôt change often or affect many components, like themes or language settings.\n\nWhile the Context API is great for small, static global state, it can lead to performance issues if the state is updated frequently. When a context provider‚Äôs state changes, all of its consumers re-render, which can negatively affect performance in larger apps.\n\nIf your app has frequently updated global state, consider using more advanced state management solutions like Redux.\n\nBest Practice: Use Context API sparingly for infrequently updated state. If the state changes often, use a dedicated state management library.\n\nFor larger applications that require a more structured approach to state management, Redux is a popular choice. Redux provides a predictable way to manage global state, making it easier to debug and scale your application.\n\nExample: Using Redux to Manage User Authentication\n\nBest Practice: Use Redux or similar state management libraries for large, complex applications where state needs to be managed in a predictable, centralized way.\n\nGlobal state can easily get out of hand if you store too much information in it. Only store data in global state if it truly needs to be shared across multiple components. If a piece of state is only relevant to a specific feature or section of your app, consider managing it locally within that feature.\n\nBest Practice: Avoid using global state for data that is only relevant to a small part of your application. Keep global state lean and efficient.\n\nIn modern React applications, handling asynchronous state‚Äîsuch as data fetched from APIs‚Äîis a common challenge. Asynchronous state can introduce complexities related to loading states, error handling, and caching.\n\n1. Use Libraries Like React Query for Server State\n\nWhen managing server state (data fetched from APIs), it‚Äôs often more efficient to use a specialized library like React Query or SWR. These libraries handle caching, synchronization, and error states out of the box, making your code simpler and more efficient.\n\nExample: Using React Query to Fetch Data\n\nBest Practice: Use a library like React Query for managing asynchronous server state to simplify your code and improve performance.\n\nWhen dealing with asynchronous operations, always explicitly manage loading and error states. This ensures your UI can provide feedback to the user while waiting for data and handle errors gracefully.\n\nBest Practice: Always include states for loading and errors when managing asynchronous state. This improves user experience and prevents UI glitches.\n\nAs your React application grows in size and complexity, managing state becomes more challenging. Following basic best practices is a good start, but larger applications often require more advanced techniques to handle state efficiently. In this section, we will explore additional state management strategies and tips to optimize performance, reduce complexity, and improve maintainability in larger React projects.\n\nOne of the most common performance challenges in React is unnecessary re-renders. When a component‚Äôs state or props change, React automatically re-renders the component, but this behavior can lead to performance bottlenecks, especially if your components are deeply nested or manage large amounts of data.\n\nHere are several techniques you can use to prevent unnecessary re-renders in React:\n\nMemoization with : Use to prevent functional components from re-rendering if their props haven‚Äôt changed. This is especially useful for components that rely on static props or props that don‚Äôt change often.\n\nIn this example, will only re-render when its prop changes, preventing unnecessary re-renders when parent components update for other reasons.\n\nUsing and : For functions and expensive calculations, you can use and to ensure that they are only recomputed when necessary. This is particularly important when passing callback functions as props to child components.\n\nHere, ensures that the function is not redefined on every render, preventing unnecessary re-renders of .\n\nSplit Large Components: If a component becomes too large and manages too much state, it‚Äôs often a good idea to split it into smaller, more manageable components. This can reduce the likelihood of unnecessary re-renders and make the code easier to maintain.\n\nBest Practice: Always be aware of when your components are re-rendering and use memoization techniques like , , and to optimize performance.\n\nOne of React‚Äôs most powerful features is the ability to create custom hooks that encapsulate and reuse stateful logic across multiple components. This is particularly useful when you find yourself repeating the same state management code across different parts of your application.\n\nYou can now use this custom hook in any component that requires form handling, making your code more modular and reusable.\n\nBy using custom hooks, you can abstract away the logic for managing state, making it easier to maintain and scale your application.\n\nBest Practice: Use custom hooks to extract and reuse stateful logic across multiple components, reducing code duplication and improving maintainability.\n\nAs your app grows, managing complex data structures like arrays of objects can become difficult, especially when dealing with collections like lists of users, products, or posts. One common issue is duplicated or inconsistent data in state, where the same piece of information is stored in multiple places and must be updated in multiple components. To avoid this, you should consider normalizing your state.\n\nNormalized state is a way of structuring your state so that data is stored by its unique identifier (usually an ) and referenced by other parts of the state. This reduces duplication and simplifies updates, as you only need to modify data in one place.\n\nLet‚Äôs say you‚Äôre working with a list of blog posts, and each post has an author. Rather than storing the same author data in multiple posts, you can normalize your state like this:\n\nIn this structure, each post only stores the of its author, and the author‚Äôs details are stored in a separate object. This makes it easier to update an author‚Äôs information without having to modify each post individually.\n\nBest Practice: Normalize your state to avoid duplication and simplify data updates. This technique is particularly useful in large applications with complex relationships between entities.\n\nIn many React applications, it‚Äôs useful to persist state across sessions so that users can return to the app and pick up where they left off. This is especially important for user preferences, authentication, or unfinished tasks like forms or drafts.\n\nYou can persist state by storing it in the browser‚Äôs local storage, session storage, or using libraries like redux-persist for Redux.\n\nExample: Using to Persist State\n\nIn this example, the username is stored in , and the state persists across page reloads or browser restarts.\n\nBest Practice: Persist important state (such as user preferences or form data) using local storage or session storage. For more complex state persistence, use libraries like .\n\nManaging state effectively is crucial for building scalable, maintainable React applications. By following best practices‚Äîsuch as using for local state, Context API for simple global state, and libraries like Redux or React Query for complex global or asynchronous state‚Äîyou can keep your code clean and predictable.\n\nAt PixelFree Studio, we help developers create high-performance, scalable React applications using the latest state management practices. Whether you‚Äôre working on a small project or a complex, enterprise-level application, our team can help you optimize your state management to ensure smooth performance and easier maintenance. Contact us today to learn more about how we can help you build better React applications!\n‚Ä¢ The Impact of Network Latency on Web Performance\n‚Ä¢ How to Use Asynchronous Loading for Faster Websites"
    },
    {
        "link": "https://dev.to/ajones_codes/a-better-guide-to-forms-in-react-47f0",
        "document": "The React ecosystem is lush with libraries, articles, videos, and more resources for every web development topic you could imagine. However, over time, many of these resources become outdated with modern best practices.\n\nWorking on a complex dynamic form recently for an AI side project, and researching good guides to React forms, I realized that most of the resources about building forms are outdated, often by many years.\n\nThis article will explain modern best practices for building forms in React, how to build dynamic forms, how forms relate to React Server Components, and more. Finally, after gaining an understanding of those topics, I‚Äôll conclude with an explanation of what I found lacking in other guides, and recommendations from my experience with React.\n\nThe key to understanding React forms is the idea of ‚Äúcontrolled‚Äù vs ‚Äúuncontrolled‚Äù inputs, which are two different methods of building forms in React.\n\nControlled forms store each input‚Äôs value in React state, and then set the value of each input on each re-render from that state. If another function updates the state, that will immediately be reflected in the components‚Äô values. If your React logic does not render the form inputs, the values will still be maintained in your app‚Äôs state. Controlled inputs tend to give you more options in your React logic, such as complex, non-HTML-standard form validation as the user types (maybe checking password strength), code manipulation of the values of the inputs (such as hyphenating phone numbers as the user types).\n\nThey look something like this:\n\n\n\nNote that it would be more semantically correct to wrap the input in a , and give the input a name, but it‚Äôs not functionally needed because the data is already saved in a state, so we don‚Äôt need a real event and our input doesn‚Äôt need to be accessed directly when the button is pressed.\n\nThere are a few downsides:\n‚Ä¢ You may not want to re-render the form every time the user types.\n‚Ä¢ You need to write a lot of code to manage complex forms, because you wind up with a lot of states as your form grows in size. That leads to boilerplate useState and state-setting, which expands your code.\n‚Ä¢ It‚Äôs harder to build dynamic forms where the number of fields is variable, because you can‚Äôt conditionally use hooks like useState. To fix this problem: (a) Your entire form state likely becomes a single, huge object, (b) Then all children components will re-render on every input change due to using an object as a state rather than primitives. (c) The only way around this, memoization, adds a lot more boilerplate.\n\nThis can lead to performance challenges with bigger forms like spreadsheets, tables, etc.\n\n\n\nOn the other hand, uncontrolled inputs do not save the input values in React state. Instead, uncontrolled forms use the native, built-in functionalities of vanilla HTML and JavaScript to manage data. So, for example, instead of setting a state with the input‚Äôs value every time it‚Äôs changed, and then setting its value prop, the browser manages the input value. Our React component never needs or uses the values - when the component is rendered, React will add the onsubmit event listener to the form, and when the submit button is pushed, our handleSubmit function runs. Instead of using React state, it‚Äôs much closer to the way a plain HTML form would work without any JavaScript.\n\n\n\nA benefit of this approach is that there‚Äôs less boilerplate. Compare these two inputs:\n\n\n\nThe difference is significant even with 1 input, but becomes even more clear with many more inputs. Compare the longer controlled form above with this one:\n\n\n\nThis form has less boilerplate than the controlled version, and we don‚Äôt need to manage multiple hook calls or a large complex state object. In fact, there is no state here at all. This form could have hundreds or thousands of children, and they will never cause each other to re-render. With this method, forms perform better, have less boilerplate, and are easier to reason about.\n\nThe downside of uncontrolled forms is that you don‚Äôt have direct access to each input‚Äôs value. This can make custom validation more difficult, and makes direct input value manipulation impossible.\n\nMany articles recommend using a ref on each input in uncontrolled forms instead of using which I believe is because the FormData API is lesser-known. However, it‚Äôs been a standard for almost a decade and has been supported by all major browsers for many years. I strongly recommend that you do not use a useRef call for each form input, as this introduces some of the same challenges and boilerplate as useState calls.\n\nHowever, there are some use-cases where a ref can help.\n‚Ä¢ Focus Management - programmatically focus on form elements, especially when dealing with dynamic form fields.\n‚Ä¢ Calling Methods on Child Components‚Äô HTML Elements - for example, if your form is broken into subcomponents and you need to focus on one of them from your parent form, or a sibling of the subcomponent, you need to pass around a ref from the parent, like this:\n‚Ä¢ Other, non-form-specific ref use-cases - such as saving previous values with a useEffect, or measuring the physical size of an element like a textarea that a user can expand\n\nIn many cases, you may need to control one or a few inputs. Manipulating a phone number as the user types it in is a great example. In those cases, even if you‚Äôre using an uncontrolled form, you can just use one controlled input. In that case, don‚Äôt use the state to access the input‚Äôs value in form submission - continue using - just use the state to manage the display of the input in question.\n\n\n\nNote: minimize states. In this example, you wouldn‚Äôt want a useState for saving the raw phone number, and a separate useState for saving the formatted phone number, with an effect to sync them - that would cause unnecessary re-renders.\n\nSpeaking of optimizing re-renders, we can also move the controlled input to its own component to minimize re-renders of the rest of the form.\n\n\n\nIf you‚Äôre used to controlled inputs, then on a first glance at the code above, you might think, ‚Äúhow does the parent form know the value of the child phone input if it‚Äôs not passing in some state setter or a ref?‚Äù To understand that, remember that when the React code is rendered as HTML, the browser will only ‚Äúsee‚Äù the HTML for the form and the inputs inside, including the input which the PhoneInput renders - the structure of our React components has no impact on the functionality of our rendered HTML. Then, that input value will be included in the FormData like any other field in the form. This is the power of encapsulation and composition of components in React. We can localize the re-renders to the minimum-affected JSX, while the DOM all still comes together as native HTML.\n\nThis is also useful for building dynamic forms. If you were. managing a state object using controlled components, you'd need to add and remove properties manually when form fields were created or removed. On the other hand, with uncontrolled components, you can just render/unrender inputs with unique names, and their values will automatically appear in the FormData on-submit.\n\nBut wait‚Ä¶ how do I validate input values in uncontrolled inputs?\n\nIf you thought of this, you‚Äôre not alone! When validation is required before submitting a form, React devs tend to jump to using controlled components with state.\n\nMany developers don‚Äôt realize that you don‚Äôt always need React or custom JavaScript for these types of validations - in fact, the web platform has them built in as attributes on form inputs! Check out this page on MDN for the details: https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation\n\nWithout any JS, you can require input values, set length requirements, and set format requirements using regular expressions (AI tools like ChatGPT are great for helping with complex Regex)\n\nOn a related topic, devs tend to reach for controlled components when we need to show some validation errors on the client-side. However, instead of using controlled components and setting values on every input change, when the requirements allow it I would prefer to use uncontrolled components and manage error handling in my onSubmit function. This minimizes the amount of state and state updates in your forms. Maybe it looks like this:\n\n\n\nThere‚Äôs one more big benefit to using uncontrolled components.\n\nReact Server Components (RSC) uses server-side frameworks to render some of your components and thereby reduce the amount of JavaScript that web browsers download to run your website. This can drastically improve the performance of your website.\n\nRSC has a big impact on the way we write forms, because, for the first time, if our form inputs do not use state, they can be rendered to HTML on the server and ship 0 JavaScript to the browser. This means that uncontrolled forms can be interactive without JavaScript, making them function earlier rather than waiting for JS to download and execute - in effect, it makes your website feel snappier, there‚Äôs no delay to interactivity.\n\nUsing Next.js, you can also use Server Actions in your forms, so you don‚Äôt need to write an API for your form to interact with - all you need is a handler function. You can find out more info about this topic from the Next.js docs or Lee‚Äôs excellent explainer video here.\n\nIf you build a mixed form with some controlled inputs in an RSC-rendered form, make sure to encapsulate your controlled components into a separate client-component, similar to the component from earlier, but in its own file. This ensures that only the minimum amount of JavaScript needed will be bundled. It may look like this:\n\n\n\nThere are many great form libraries in the React ecosystem, designed for controlled inputs. Recently I‚Äôve been using React Hook Form for those applications, though I‚Äôve been leaning more heavily on uncontrolled inputs so I don‚Äôt need a library to manage form state. (Edit: some popular options are React Hook Form, Formik, and Informed)\n\nThis article was motivated by the confusing, out-dated, and/or misleading articles that show up near the top of the Google search results for ‚Äúreact forms.‚Äù\n‚Ä¢ One of those articles says ‚Äúthe more idiomatic React way would be using controlled forms‚Äù - I don‚Äôt think either controlled or uncontrolled inputs are more ‚ÄúReact idiomatic.‚Äù In reality, both types have their place, as discussed above. In fact, many older articles seem to recommend controlled inputs, for similarly vague or misleading reasons. I would argue that using uncontrolled inputs is actually more ‚Äúweb idiomatic‚Äù by nature of relying on less JavaScript, which allows uncontrolled inputs to shine in React Server Components.\n‚Ä¢ Not one of the top articles uses FormData. For uncontrolled forms, at least two recommend multiple useRef calls, making your code inflexible and more boilerplatey.\n‚Ä¢ Some of the top articles still use class components with no mention of functional components.\n‚Ä¢ In my experience, most forms are a mixture of uncontrolled and controlled inputs. The reason we have both of those options is flexibility and we shouldn‚Äôt be dogmatic. We can use them both together, as in the React Server Components example above (although server components are not needed for that example).\n‚Ä¢ Today, I favor uncontrolled inputs wherever I can. I believe this simplifies the code structure and performance.\n‚Ä¢ Use ‚Äúnew FormData(...)‚Äù in your onSubmit functions instead of using refs. Seriously.\n‚Ä¢ Use composition and encapsulation for controlled inputs to minimize the impact of state updates on other components, and rely on the rendered, composed DOM for submit events.\n\nI hope this article helps someone! Feel free to leave questions in the comments."
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-handle-form-state-in-frontend-applications",
        "document": "Forms are a fundamental part of almost every frontend application. Whether you‚Äôre building a contact form, login page, or an e-commerce checkout process, forms allow users to interact with your app and submit data. However, managing form state efficiently can be challenging, especially as your forms grow in complexity. From handling user input, validation, and submitting data, to maintaining a seamless user experience, form state management is a critical part of frontend development.\n\nIn this article, we will explore the different strategies and best practices for handling form state in modern frontend applications. We‚Äôll dive into the basics of managing form input, handling validation, error messages, and using advanced techniques with modern frameworks like React and Vue.js to streamline the process.\n\nForm state management is not just about capturing user input. It involves maintaining a smooth user experience by ensuring:\n\nError handling: Giving users immediate feedback if something goes wrong.\n\nPerformance: Preventing unnecessary re-renders and optimizing the overall performance.\n\nMaintainability: Keeping the form logic clean, modular, and easy to scale as the app grows.\n\nPoorly managed form state can lead to messy code, buggy experiences, and frustrated users. That‚Äôs why it‚Äôs essential to understand the best practices for managing form state effectively in any frontend application.\n\nThe simplest form of state management involves capturing user input as they type and updating the component‚Äôs state with the new values. In most cases, you‚Äôll be working with input fields like text boxes, checkboxes, radio buttons, and dropdown menus.\n\nLet‚Äôs look at how to handle basic form state in a React component using the hook:\n\nState management with : We use the hook to manage the form data as an object containing multiple fields ( , , ).\n\nUpdating state with : The function is responsible for updating the state based on user input. It dynamically updates the appropriate form field by using the attribute of the input.\n\nSubmitting the form: The form submission is handled by the function, which prevents the default form submission behavior and logs the form data.\n\nSimple forms with a few input fields can easily be handled using React‚Äôs built-in hooks like .\n\nAs forms grow larger or become more complex, handling multiple fields manually becomes tedious. This is where more advanced state management techniques can help.\n\nValidation is a critical part of any form. It ensures that the user submits valid data before the form is processed. There are different types of validation:\n\nClient-side validation: Checking form fields in the browser before submitting the data to the server.\n\nServer-side validation: Validating form data on the server after submission, often as a backup to client-side validation.\n\nLet‚Äôs extend the previous example to include basic validation. In this case, we‚Äôll check if the name and email fields are not empty and if the email is in a valid format.\n\nValidation function: The function checks each field to ensure that the required fields are filled and the email format is correct.\n\nDisplaying error messages: If there are errors, they are stored in the state and displayed beneath the respective fields.\n\nForm submission: If there are no errors, the form is submitted; otherwise, the user is informed of the issues.\n\nImmediate feedback: Users receive instant feedback if they make a mistake, improving the user experience.\n\nReduced server load: By catching errors early on the client side, you can reduce unnecessary form submissions to the server.\n\nAs forms grow more complex, manually handling form state, validation, and error management can become difficult. Fortunately, there are several libraries designed to simplify form handling in React applications.\n\nReact Hook Form: A lightweight library that focuses on minimal re-renders and improved performance.\n\nFormik simplifies form management by providing an easy-to-use API for handling state, validation, and submission. Here‚Äôs how you can use Formik to handle form state and validation:\n\nValidation schema: You can define a validation schema using Yup, a schema validation library that integrates seamlessly with Formik.\n\nSimplified submission: The handler receives the validated form values and can submit them to the server.\n\nEase of use: Formik reduces the boilerplate code needed for managing form state and validation.\n\nScalability: It can handle forms of any size, from simple login forms to complex multi-step forms with hundreds of fields.\n\nValidation: With support for validation schemas, managing complex validation rules becomes much simpler.\n\nAnother popular library, React Hook Form, offers a different approach to form state management with a focus on performance by reducing the number of re-renders during input changes.\n\nMinimal re-renders: React Hook Form is designed to reduce the number of re-renders when managing form inputs, making it highly performant.\n\nSimple API: Its hook-based API makes it easy to integrate into functional components and keep the form logic clean.\n\nValidation with minimal setup: Validation rules can be easily added using the function without needing an external library.\n\nAs forms grow in complexity, you might encounter multi-step forms, where users are required to fill out multiple sections over several steps. Handling state across these steps can be challenging, but with proper state management techniques, it becomes manageable.\n\nHere‚Äôs how you can manage state across multiple steps using and conditional rendering:\n\nStep management: We use the state to track the current form step and conditionally render the appropriate step based on the value.\n\nData persistence across steps: The form data is stored in a central object, ensuring that data entered in one step is preserved when moving between steps.\n\nImproved user experience: Breaking down complex forms into multiple steps makes the process less overwhelming for users.\n\nData management: State management ensures data from all steps is consolidated and submitted as a single payload.\n\nIn some cases, the number of form fields may vary based on user input, such as adding multiple addresses or dynamically generating additional fields. Handling dynamic fields can be tricky, but it can be managed effectively with modern state management techniques.\n\nHere‚Äôs how you can handle dynamically adding and removing fields using :\n\nDynamic state management: We manage an array of fields using , and the array grows or shrinks as fields are added or removed.\n\nField manipulation: The and functions dynamically add or remove form fields while maintaining the form‚Äôs current state.\n\nIn many cases, form fields are dependent on each other. For example, selecting a country may change the available options in a ‚ÄúState‚Äù dropdown, or selecting a product category might reveal different product subcategories.\n\nHere‚Äôs an example of how to manage dependent form fields, such as a country and state selector:\n\nDynamic rendering: The list of available states is updated dynamically based on the selected country.\n\nConditional rendering: The state dropdown is only rendered if there are available options to show.\n\nImproved user experience: Dynamically adjusting form fields based on previous selections can help guide users through the form and reduce the potential for errors.\n\nSimplified logic: By maintaining dependent field logic inside the component, you ensure that the form is intuitive and responsive.\n\nWhen users fill out long forms, it‚Äôs important to allow them to save their progress and come back later without losing their input. You can achieve this by persisting the form state in the browser‚Äôs local storage or session storage.\n\nUsing the browser‚Äôs , you can store the form data and retrieve it later, ensuring that users don‚Äôt lose their progress if they accidentally close the page or navigate away.\n\nInitializing from : The form‚Äôs initial state is fetched from , ensuring that if the user has already started filling out the form, their progress is preserved.\n\nAutomatically saving progress: Using the hook, the form data is saved to every time the state changes.\n\nResilience: Users can return to the form even if they accidentally close the tab or refresh the page.\n\nImproved user experience: This feature is particularly useful for lengthy forms or multi-step processes where users might need to pause and return later.\n\nIn some cases, you may want to prevent excessive re-rendering or API calls as the user types in a form field (such as a search box or live validation). Debouncing is a technique where you delay the execution of a function until the user has stopped typing for a certain amount of time.\n\nHere‚Äôs how to implement debouncing in a React form using the hook:\n\nThrottle API calls: The state is only updated after 500 milliseconds of inactivity, reducing the number of API requests made as the user types.\n\nEfficiency: This technique ensures that expensive operations (like API calls) only happen after the user has finished typing, preventing unnecessary re-renders or requests.\n\nOptimized performance: Debouncing prevents overwhelming the server or UI with frequent updates, improving both the performance of the application and the user experience.\n\nReal-time feedback: Debouncing still allows for near-instant feedback to users without the downside of frequent, unnecessary function executions.\n\nEnhancing form inputs with real-time suggestions or validation from third-party APIs can significantly improve the user experience. For instance, you can integrate Google Places API for address autocomplete or an email validation API to verify email addresses as they are typed.\n\nHere‚Äôs an example of integrating Google Places API to provide address autocomplete in a form:\n\nGoogle Places API: This example integrates with Google Places API to fetch address suggestions as the user types.\n\nReal-time suggestions: Suggestions are displayed in real-time, improving the accuracy of user input and reducing the need for manual entry.\n\nEnhanced user experience: Providing real-time suggestions speeds up the form-filling process and improves accuracy.\n\nReduced errors: With pre-validated addresses, the likelihood of incorrect or incomplete data submission is reduced.\n\nManaging form state is a crucial aspect of frontend development that can significantly impact user experience and application performance. Whether you‚Äôre building simple forms or complex multi-step workflows, handling form state efficiently is essential to creating maintainable, scalable applications.\n\nBy mastering the basics of form state management, including handling validation, leveraging external libraries like Formik and React Hook Form, and handling dynamic fields and multi-step forms, you can provide a seamless and polished experience for users.\n\nAt PixelFree Studio, we specialize in building high-performance web applications with intuitive user interfaces, including efficient form state management. Whether you‚Äôre creating complex forms or need help optimizing your app‚Äôs performance, reach out to us to learn how we can help you streamline your form handling processes and build scalable frontend applications.\n‚Ä¢ The Impact of Network Latency on Web Performance\n‚Ä¢ How to Use Asynchronous Loading for Faster Websites"
    },
    {
        "link": "https://dev.to/spencerpauly/the-1-best-design-pattern-for-managing-forms-in-react-4215",
        "document": "Ughh‚Ä¶ why does form code in React always get so messy?\n\nIt starts out simple: a component, a couple input fields, and a submit button. But soon things get a little more complicated.\n\nYou think, \"hmmm.. I want some more validation for this zip code field\". So you add a custom workaround that validates the data in the input field.\n\nThen, you think \"I want to disable the submit button when the form is submitting\". So you create another custom workaround that keeps track of what's submitting, and when things are complete, etc.\n\nThen, you think \"I want better error handling\". So you add yet another workaround.\n\nAnd over time that simple form balloons into a 400-line long super-component with multiple useEffects, useStates, and custom logic to handle all the edge cases.\n\nI've had this trouble more times than I'd like to admit. So 6 months ago, I decided to double down and find the solution. I wanted to know:\n\nThat's what I'm going to share here today.\n\nA Form Library - Do I need one?\n\nI've come at this crossroads before. As a project is small the answer usually starts as \"nah\", then over time it inevitably sways towards \"please, please yes\".\n\nSo now, I advocate for form management libraries no matter what scale of project. Form libraries usually have a relatively small bundle size and make a world of difference for code organization.\n\nBut, I should note: I've also seen custom form management work in the past.\n\nThe issue is that it's really difficult. It's possible, but even if you're successful you'll usually end up building a similar version of another form library except without all the great documentation.\n\nThat's why I recommend starting your project with a good form library from the get-go. So that brings us to the next question.\n\nThis decision making process could be a whole other article in itself. But, I want to focus on concrete design patterns today, so I'm only going to give a high-level overview of the landscape.\n\nThe landscape for form management libraries in React is huge. But, luckily it's concentrated among only a few popular libraries. Some of the most popular are: react-hook-form, formik, redux form, and react-final-form.\n\nHere's a breakdown of their popularity, with Formik as the most popular and react-hook-form chasing close on their heals.\n\nAs I already mentioned, I'm not going to be deeply comparing these solutions in this article. But, if you want a great article comparing these, https://retool.com/blog/choosing-a-react-form-library/.\n\nWith that said, the two form libraries that I consider to be an excellent choice are Formik and React-Hook-Form.\n\nBoth provide hook-centric form management and have great documentation, active devs, and a healthy user base.\n\nHowever, between these two, I tend to lean towards React-Hook-Form and I'll explain why below.\n\nReact-hook-form (RHF) is great because it prioritizes hooks to manage your form state (hence the name). This makes it fast, flexible, and a breeze to work with if you're already using hooks.\n\nAmong it's various benefits, one advantage over Formik is that react-hook-form was created exclusively for hooks. This means, although react-hook-form can't support class components, their docs and best practices are more focused. If you look up articles online, you won't find a lot of outdated guides with old design patterns. I find this extremely valuable when trying to learn a new library.\n\nThey also have numerous other small performance, bundle, and flexibility advantages over the other libraries. Here's just some examples:\n\nThat's why I chose React-Hook-Form. However, if your codebase uses a lot of class components you might be better off going with Formik as it'll be easier to integrate into your components.\n\nThe basic premise of the 3 layer approach is to take a complicated form component and split it into three parts.\n\nEach part will be its own react component and will focus on one responsibility of the form (see: SOLID). Each part will also be named with a suffix (Apollo, Logic or View), which will make it easier to find.\n\nHere's an overview of what each component does:\n\nThis component handles strictly the network requests for your form (aka. fetching the initial data for the form, and submitting the final data to your backend). It's named \"Apollo\" because I typically use Apollo to talk to my GraphQL backend. Feel free to use a more relevant suffix such as: \"API\", \"Network\", or \"Fetch\" if you prefer.\n\nThis handles the logic for the form. This is the component where you'll define the shape of the form, default values, and validation.\n\nThis component renders the view of the form. It's meant to be a stateless component. However, I usually allow view-related state in this component such as an isOpen toggle for an expandable section of the form or something similar.\n\nThis chart shows how the data will flow between these three layers to create an organized form structure. Start at the Apollo.tsx file and follow the arrows to read how the data will flow through the components.\n\nLet's dive a little further into each of these components. I use TypeScript in this example, because it will help give a good look into the different types of data being passed around.\n\nAlso, here is the finished codebase. If you're a hands-on learner feel free to play around yourself as you read.\n\nThe Apollo component is responsible for fetching form data over the wire. Here's what it looks like.\n\nThere's a couple things I want to point out about this component.\n\nFirst of all, notice how the data fetched from the database is transformed before being passed down into the default values of . This is important, because in general it's a good idea not to trust data fetched from over the wire. If you don't do this it can go wrong in one of three ways.\n\n(a) You can end up fetching too many fields from the API. This means your form will have more defaults than it needs. This can add clutter to your form and problems when we get to validation.\n\n(b) This also safeguards against bad defaults (ex. undefined). Instead of trusting the backend, it's a good idea to provide sensible defaults, such as the empty string, just in-case.\n\n(c) It's more robust. Notice how the user field from the API is transformed into the username field before being passed down to the form? This is useful for other fields too. Ex. parsing a string timestamp from the backend into a Date object for the form.\n\nThe second thing I want to point out is regarding the handleSubmit function. This function takes the submitted form data, transforms it into JSON for the API, and returns an async function for updating the database with the result.\n\nReturning the async function is important. You'll see this a bit later, but essentially it allows you to await the API response in your CreateUserLogic component which means you can know what the submission status of the form currently is.\n\nThe goal of this component is simple: set up the form with the default values, pass the form down to the view layer, then handle submitting the form to the parent component when the submit button is pressed.\n\nThe main thing I want to point out here is the handleSubmit function. You'll remember that the Apollo component had a handleSubmit function too. Why do you need two of them?\n\nThe reason is to keep our three layers modular. The handleSubmit in this component lets you make state changes after a successful submission of the form. It doesn't care how that data is submitted, it just cares about when it completes.\n\nTrust me, I've tried doing it other ways and eventually you'll realize this way is the cleanest. It lets you keep each layer from needing to care about what's happening in the other layers and instead simply focusing on what they care about.\n\nIn this example, we reset the form after submitting. But, you can just as easily use this to route to a different page, show a success toast, close a modal, etc. This design pattern leaves it up in the air, which is good.\n\nAlso, it's important that you either await or return the onSubmit(data) function. If you don't, everything will still work but react-hook-form won't know when you've completed the submission process and won't properly handle the isSubmitting state of the form.\n\nFinally we have the simplest component. This one simply renders out your form fields. Since you've done all the hard work in the layers above this component can be pretty simple.\n\nThis is great because in a large form this will usually be your biggest component. Additionally, this component only handles the \"look\" of the form and won't deal with any logic. This is great because now you can easily hand this file off to a designer and the designer won't need to care about how the form works, they only have to worry about how it looks. Which is great!\n\nThe benefits of this pattern\n\nOk, so I mentioned at the beginning of the article all my pain points when building forms. Not only does this structure solve all of those, it also has some other inherit benefits as-well.\n\n‚úÖ Built in type checking and validation for every step of your form\n\nIf you noticed, the logic component contains per-field validation, and every step of this process has strong typescript typings. This makes it very hard to mess up and much easier to debug.\n\nüîç Easy to find where things happens\n\nDo you have an issue submitting data to the backend? It's likely in the Apollo component. Issue with the default value of a field? Logic component. Issue with the \"look\" your form? View component. Super easy!\n\nThis is a commonly under-looked benefit of this pattern. But, if you notice, you can test the functionality of a form by passing props to the Logic components directly. There is no need to mock your backend at all since you can test all the functionality by bypassing the Apollo component entirely.\n\nüéÅ Forms become much more composable\n\nThis means you can mix and match different layers to have the form behave differently. You can have different Apollo components submit form data in a different way (ex. editing vs. creating a document). Or vice versa, you can reuse an Apollo component for different forms to submit different data to the same backend services. Really cool!\n\nThis structure lends itself well to working with a team. Your designer can work on the View layer, while the backend person can work on the Apollo component. Then, you can easily meet in the middle at the Logic component and get your new feature launched twice as fast!\n\nAnd that's the design pattern!\n\nAs you can see, by combining a good form library with a good design pattern can make messy form code a thing of the past. It allows for easier collaboration, cleaner development, and faster debugging. What's not to like?\n\nIf you have any further questions or improvements, leave a comment!"
    },
    {
        "link": "https://daily.dev/blog/form-on-react-best-practices",
        "document": "Creating and managing forms in React doesn't have to be complicated. Here's a straightforward guide on best practices for handling forms effectively within your React applications:\n‚Ä¢ Use Controlled Components: React state manages your form data, making it easier to handle changes and errors.\n‚Ä¢ Perform Real-time Validation: Check user input as it's entered to catch errors early.\n‚Ä¢ Display Errors Clearly: Show mistakes next to the relevant fields to help users correct them quickly.\n‚Ä¢ Ensure Accessibility: Make your forms usable for everyone, including people with disabilities.\n‚Ä¢ Submit Without Page Reloads: Use AJAX to send form data, improving user experience.\n‚Ä¢ Consider Libraries for Complex Forms: Tools like Formik can simplify handling complicated forms.\n\nThese practices will help you build React forms that are efficient, user-friendly, and scalable. Whether you're dealing with controlled or uncontrolled components, understanding and implementing these strategies will enhance your form handling in React.\n\nWith controlled components, React keeps an eye on the form data using its own state. This means React is in charge of the form data, not the webpage itself.\n‚Ä¢ First, we set up the form's default values with something called the hook. Like this:\n‚Ä¢ Next, we make sure the form inputs show the right state values. Like so:\n‚Ä¢ When someone types in the form, we have a special function to update the state. Like this:\n‚Ä¢ When the form is sent, we use the state because it has all the form data.\n\nControlled components are great because they make checking the form and dealing with mistakes easier. Plus, they stop unexpected things from happening since the state always has the latest form data.\n\nUncontrolled components let the webpage (the DOM) handle the form data, not React. This means the state doesn't keep track of the form data.\n\nHere's how it goes:\n‚Ä¢ We use something called refs to connect directly to the form inputs. Like this:\n‚Ä¢ We attach these refs to the inputs. Like so:\n‚Ä¢ When the form is sent, we use the refs to get the input values from the webpage. Like this:\n\nUncontrolled components skip the step of syncing the state with the input values. But, they make checking the form and dealing with mistakes a bit trickier since the webpage is the source of truth.\n\nIn short, both controlled and uncontrolled components have their places in React forms. Controlled components are better for forms that need checking and have complex stuff going on, while uncontrolled components are good when you want to keep things simple and not duplicate data in the state.\n\nBefore you start making forms in React, here are some things you should know:\n‚Ä¢ React Hooks and Components: You should be okay with using hooks like , , and . Also, you should have tried making your own components before.\n‚Ä¢ Handling State: You need to know how to use the hook for keeping track of your form's data and any errors. You should also know how to update the state when someone fills out the form.\n‚Ä¢ Basic Form Stuff: You should understand the basics of how forms work, including inputs, labels, and how to show messages when something goes wrong.\n‚Ä¢ Checking Forms: Knowing how to make sure everything filled out in the form is correct is important. This includes making sure all the required fields are filled, the format is right, and showing helpful error messages.\n‚Ä¢ Sending Data: You'll need to know how to collect all the information from the form and send it somewhere, like to a server.\n\nIf you're comfortable with these things, you're ready to learn some best ways to build forms in React. We'll use examples that mainly talk about controlled forms with , but these ideas work for uncontrolled forms too.\n\nIn React, there are two main ways to handle forms: controlled and uncontrolled. Here's a quick comparison to understand them better:\n\nControlled forms keep all the form data in React's state. This means you can easily check and manage the data because React knows all about it.\n\nHow to set up a controlled form:\n‚Ä¢ Start by using the hook to set up your state.\n‚Ä¢ Make sure each form input shows the state's current value.\n‚Ä¢ Create a function that updates the state whenever someone types in the form.\n\nControlled forms are great for when you need to check user input closely. The downside? They might make your app run a bit slower because of the extra updates.\n\nUncontrolled forms let the browser handle all the form data, not React. This means less work for React and potentially faster performance since it doesn't have to update the state every time something changes.\n\nHow to set up an uncontrolled form:\n‚Ä¢ Use the hook to create references for your form inputs.\n‚Ä¢ Attach these refs to your inputs so you can grab their values easily.\n‚Ä¢ When the form is submitted, use the refs to get the input values right from the form.\n\nUncontrolled forms are simpler because they don't involve React state. But, this also means checking the data can be a bit trickier.\n\nIn short, use controlled forms when you need to keep a close eye on the data, and uncontrolled forms for simpler situations.\n\nControlled forms are super helpful but can be a bit tricky. Here are some tips to make your controlled forms in React work better and be more user-friendly.\n\nWhen you start making your form with the hook, give every field a starting value. Don't just leave them empty. This way, you won't run into errors later on.\n\nThis helps avoid problems if you try to use values that aren't set yet.\n\nSometimes, you need to fill form fields with data from somewhere else, like a server. When you do this:\n‚Ä¢ Show a loading sign so people know it's working.\n‚Ä¢ If there's an error, make it clear what went wrong.\n‚Ä¢ Use default values until the real data loads.\n\nTyping in controlled forms can feel slow because of how they update. To fix this:\n‚Ä¢ Use debounce to slow down state updates and make typing feel smoother.\n‚Ä¢ Boost performance by remembering calculations and using useCallback.\n‚Ä¢ Try uncontrolled inputs if things get too complicated.\n\nWith controlled forms, you can check if the data is right as soon as it's typed. Use this to:\n‚Ä¢ Tell people exactly what to fix.\n\nChecking things step by step makes the whole process smoother.\n\nWhen the form is sending, show that it's busy and stop people from changing anything. Once it's done, let them know everything went well and what to expect next.\n\nThese signs help people feel sure their form was sent properly.\n\nControlled forms might take some time to get used to but they let you do a lot of cool stuff. Remember these tips:\n‚Ä¢ Start off right by setting up your form properly.\n‚Ä¢ Check the data as you go and be clear about errors.\n‚Ä¢ Guide people through sending the form and what happens after.\n\nKeeping these things in mind will help you make controlled forms that are easy and reliable.\n\nUncontrolled forms are pretty handy when you want to keep things simple in your React app. They're great for forms that don't need a lot of checks and can help your app run faster. Here's how to get the most out of them:\n\nUse When Forms Are Simple\n\nUncontrolled forms are best for straightforward forms. If your form just has a couple of fields and you don't need to worry about checking the info as people type, these forms can make your life easier.\n\nTo work with uncontrolled forms, you'll use something called . This lets you link directly to the form elements, like where someone types their name.\n\nLater, you can grab the input's value with .\n\nWhen it's time to send the form, just use the refs to get the input values.\n\nThis way, you don't have to juggle the values in React's state, which keeps things simple.\n\nIf your form is slowing down because it's updating the state a lot, uncontrolled forms can help. They don't update the state every time something changes, so they can make your form faster.\n\nSometimes, you might need to add checks or other features to your form. If that happens, you might find it easier to switch to a controlled form, where you manage the state.\n\nUncontrolled forms can make things simpler in the right situations. Just remember:\n‚Ä¢ Use to connect to your inputs.\n‚Ä¢ Get the values directly when submitting.\n‚Ä¢ They can be faster because they don't update the state.\n‚Ä¢ It's okay to switch to controlled forms if you need more features.\n\nKeep these tips in mind, and you'll be able to use uncontrolled forms effectively in your React apps.\n\nChecking if the form is filled out correctly is super important. This makes sure the info users give us is right and safe before we send it off. Here's how to do it well in React apps.\n\nIt's best to check each part of the form right when it changes. This helps because:\n‚Ä¢ It clearly shows users what they need to fix.\n‚Ä¢ It encourages fixing problems right away.\n\nYou can do this by making a function that checks the form and running it every time the form updates:\n\nDoing it this way makes it easier to fix mistakes compared to checking only when sending.\n\nMake sure you check every part of the form, not just some. This includes:\n‚Ä¢ Fields that must be filled\n‚Ä¢ Numbers, like making sure they're not too low\n\nChecking everything helps make sure nothing wrong slips through.\n\nDon't just say something is wrong. Tell users exactly what's wrong and how to fix it. For example:\n‚Ä¢ \"Email needs to have an @ symbol\"\n‚Ä¢ \"Passwords need to be the same\"\n‚Ä¢ \"Number needs to be more than 0\"\n\nHTML forms have some checks built in that you can use, like:\n\nThese checks happen in the browser before React even gets the info.\n\nFor forms that have a lot going on, think about using a library like Formik or React Hook Form. They help with:\n\nLibraries offer strong checking features that work well with React.\n\nIn short, checking forms is key for making sure they're filled out right and safe. Do it often, check everything, be clear about what's wrong, use what's already available, and think about using libraries for big forms. Good checking makes forms better for everyone.\n\nMaking sure users know when they've made a mistake on a form is key to a good experience. You want to point out the errors clearly and help them fix them easily. Here are some smart ways to handle errors in React forms:\n\n1. Show Error Messages Right Next to the Field\n\nPut any error messages right by the field where the mistake was made. This makes it easy for users to see what they need to fix:\n\nThis way, users don't have to look around to find out what went wrong.\n\nMake sure your messages tell users:\n‚Ä¢ What the mistake is\n‚Ä¢ How to fix it\n\n‚ùå \"Email invalid\" ‚úÖ \"The email address should contain an '@' symbol\"\n\nDon't stop users from editing a field if they make a mistake. Let them fix it right away.\n\n4. Focus on the Big Errors First\n\nIf there are several mistakes, show the most important ones first, like missing required fields, before worrying about smaller issues.\n\nOnly show error messages if there are actually errors to talk about. This keeps things simple and not too crowded:\n\nThe main idea is to make error messages easy to understand and helpful, guiding users to quickly correct any issues. Getting error handling right in React forms means smoother, more user-friendly experiences.\n\nUsing libraries like React Hook Form, Formik, and Redux Form can make your life a lot easier when you're creating forms in React that are a bit more complicated. Here's why they're helpful:\n\nEasier to Keep Track of Things\n\nThese libraries take care of the hard parts of keeping track of what's being typed into forms, checking for mistakes, and so on. This means you don't have to write as much code to manage the form's state, making your job easier.\n\nThey Help with Checking for Mistakes\n\nThey come with tools that help you check for common errors, like making sure a field isn't left blank, that an email address looks right, or that passwords match. This saves you from having to write all this checking yourself.\n\nGood for Forms that Change Based on What's Happening\n\nIf you need to create forms that change based on what a user does (like adding more questions if they answer a certain way), these libraries have features that make this easy, like adding or removing fields dynamically.\n\nThey also make it simpler to show error messages right where the mistakes are, helping users fix them. The libraries handle the errors, so you focus on making the form look good.\n\nChecking Fields Against Each Other\n\nSometimes, you need to make sure two fields agree with each other, like confirming a password. Form libraries have easy ways to do this kind of check without adding a lot of extra work.\n\nThese libraries are built to work well with React, meaning they fit right into how you build components. They're smart about only updating parts of your form when needed, which helps keep your app running smoothly.\n\nIn short, using a form library can save you a lot of time and trouble when you're building more complex forms in React. They handle a lot of the routine work for you, letting you focus on the parts of your form that users see and interact with. For bigger projects, they're definitely worth considering.\n\nWhen you're working on more complicated forms in React, using some extra tools can really help. These tools, or libraries, do a lot of the heavy lifting, so you can focus on making your forms nice and user-friendly.\n\nIn this part, we'll talk about two useful tools:\n‚Ä¢ Zod for making sure the data is correct\n\nThese tools help you manage data and make sure it's right, which makes your forms work better.\n\nGetting Set Up with React Query\n\nReact Query is a tool for React that helps with getting data from the server, keeping it up to date, and more.\n\nTo add React Query to your project:\n\nThen, you need to wrap your app with :\n\nNow, you can start using React Query to get data for your forms.\n\nOften, forms need data from somewhere else, like a list of options for a dropdown. Here's how you can get that data:\n\nReact Query takes care of getting the data, updating it, and more, which makes your form components reliable.\n\nZod is a tool for checking if the data in your forms is right. You set up rules for your data, and Zod helps you spot any mistakes.\n\nThen, you make a set of rules for your form data:\n\nAnd use these rules to check your data:\n\nZod can check things like types, required fields, and more. It works well with React, especially for showing errors right in your forms.\n\nBy using React Query and Zod together, you can make forms that handle data and check it properly. Try them out in your next React project!\n\nMaking form components that you can use again and again is a smart move when building forms in React. This means you create custom inputs, hooks, and bits and pieces once and then use them in many places. This approach helps keep your forms looking and acting the same, cuts down on repeating the same code, and makes building things faster.\n‚Ä¢ Consistency - Using the same components everywhere means your forms will look and work the same way, making things predictable for users.\n‚Ä¢ Less Code - You won't have to write the same stuff over and over because your components take care of the tricky parts. This speeds up how quickly you can make things.\n‚Ä¢ Easier Maintenance - If something needs updating, like how a form checks for errors, you just do it in one spot.\n‚Ä¢ Flexible - Good components can be tweaked with props to fit different needs, making them super versatile.\n\nIn the long run, reusing components makes your forms better and your code cleaner.\n\nA cool trick is to make a custom hook called that handles common form tasks. Here's a simple version:\n\nAnd here's how you might use it in a form:\n\nThis hook helps clean up your components by keeping the state management stuff out of the way.\n\nHere are some pointers:\n‚Ä¢ Be open to props for more options\n‚Ä¢ Make sure they can stand on their own\n‚Ä¢ Write down how to use them so others can easily pick them up\n\nTaking the time to build reusable parts makes handling forms in React much smoother as your project grows.\n\nWhen you're dealing with a lot of input fields in a React form, it might seem a bit complex at first. But, with a few smart moves, it can be pretty straightforward. Here's how to manage multiple inputs smoothly:\n\nInstead of having a separate state for each input, it's easier to keep everything in one big state object. This way, all your form data is in one spot:\n\nThis method keeps things tidy and simple.\n\nMake sure each input field has a that matches its key in the state object:\n\nThis tells React which part of the state to update when things change.\n\nYou can use just one function to handle changes for all the fields. It looks at the input's to know which part of the state to update:\n\nThis way, you don't need a bunch of separate functions for each input.\n\nWhen the form is sent, you can check all the fields at once by looking through the state object:\n\nUsing this method makes handling lots of inputs much easier and keeps your form flexible. If you have more questions, feel free to ask!\n\nWhen you're ready to send your form in React, you want everything to go smoothly for the people using your app. Here's how to make sure both controlled and uncontrolled forms are sent off correctly:\n\nIn controlled forms, you keep the form data in React's state. Here's what to do when sending the form:\n‚Ä¢ Use an handler on the tag. This function kicks in when the form is submitted.\n‚Ä¢ Stop the form from sending the usual way with inside your submit handler. This prevents the page from refreshing.\n‚Ä¢ Gather the form data from React's state and send it over to the server. Like this:\n‚Ä¢ After sending, you can change the state to show a message that everything went well, clear out the form, or take the user somewhere else.\n\nIn uncontrolled forms, the form data is in the DOM, not in React's state. To send the form:\n‚Ä¢ Inside the handler, use to stop the form from sending the usual way.\n‚Ä¢ Use refs to grab the form data straight from the DOM inputs.\n‚Ä¢ After sending, update the screen to show a message that everything went well.\n‚Ä¢ Show a spinner or disable the submit button while the form is sending.\n‚Ä¢ If everything goes well, pop up a friendly message to let the user know.\n‚Ä¢ If there's a problem, make sure to explain it clearly and let the user try again.\n‚Ä¢ Once the form is sent, you can clear the data, reset everything, close a pop-up, or move the user to a new page.\n\nMaking sure your form sends off properly can really make a difference in how people see your app. Follow these steps for a smooth, hassle-free experience in your React apps.\n\nHandling forms is a key part of making web apps that are easy to use. By sticking to good practices for managing forms, checking them, and dealing with mistakes, you can make forms in React that work well and feel smooth to use.\n‚Ä¢ Choose controlled forms when you need tight control over the form's data, want to check inputs right away, and handle errors smoothly. Uncontrolled forms are simpler but can make checking inputs harder.\n‚Ä¢ Check your forms often as people fill them out, look at every field, and give clear messages about what to fix. You might want to use tools like React Hook Form for complicated forms.\n‚Ä¢ Make sure error messages are easy to see and fix right next to the problem areas. Deal with the big issues first before the small ones.\n‚Ä¢ Make typing in controlled forms feel better by using tricks like debouncing, remembering calculations, and sometimes using uncontrolled inputs instead.\n‚Ä¢ Set up all form fields from the start to avoid surprises later.\n‚Ä¢ Help users through the form with signs that it's working, success messages, and guiding them on what to do after submitting.\n‚Ä¢ Build inputs, hooks, and parts you can use over and over to cut down on repeating yourself. Custom hooks like can help with managing data.\n‚Ä¢ Use tools like React Query and Zod for getting data and making sure it's correct.\n\nThinking ahead about how to set up your forms, making parts you can use many times, and using the right tools can make your code easier to handle and make your users happy. Keep these tips in mind when you're working on forms in your React projects.\n\nWhat is the best way to handle forms in React?\n‚Ä¢ Avoid using react-hook-form just for state management.\n‚Ä¢ Organize your form based on the order of steps needed.\n‚Ä¢ Treat each step as its own react-hook-form setup.\n\nWhat is the best practice for form validation in React?\n‚Ä¢ Always check the data on the server-side too, to catch any wrong or harmful data.\n‚Ä¢ Think about using libraries like Formik or React Hook Form. They make managing and checking your form's data easier.\n\nWhat is the best form module for React?\n\nFormik is a widely used and feature-rich library for handling forms in React and React Native. It takes care of managing the form's state, checks the data, and handles sending the form for you.\n\nWhat are the best practices for React?\n\nSome key tips for working with React:\n‚Ä¢ Keep your files organized in a clear way\n‚Ä¢ Be consistent with how you order imports\n‚Ä¢ Use tools like ESLint to help with code quality\n‚Ä¢ Use styled components to mix CSS with JavaScript\n‚Ä¢ Try not to make too many components\n‚Ä¢ Use lazy loading to improve how fast your app loads"
    }
]