[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/interface-quick-start-guide-in-unreal-engine",
        "document": "Interfaces define a set of common behaviors or methods that can be implemented by different Actors. This communication type is especially useful when implementing the same type of functionality across different Actor class Blueprint.\n\nAs an example, you may choose to use an Interface when implementing a common Open behavior for several Blueprint classes in your project, such as for a door, a window, a car, and so on. In this example, each Actor is a different class and will exhibit a different response when the Open Interface is called.\n\nAdditionally, there are performance benefits to using Interfaces over Casting, as loading an Actor class Blueprint that casts to another Actor class Blueprint will subsequently load that Blueprint to memory as well. If not used with caution, this could result in a cascading loading effect where loading a single Blueprint results in several other Blueprints being loaded into memory as well.\n\nThis method requires each Actor class Blueprint to implement the interface in order to access those common functions.\n\nIn this Quick Start guide, you will learn how to use Interfaces by creating a simple interaction system to communicate with two Actor class Blueprints.\n• Create an Interface with an Interact function.\n• Create an interactive lamp and door Actor that implement the interface.\n• Modify the BpCommunication Character class to call the Interact interface function on nearby objects.\n• In the New Project Categories section of the menu, select Games and click Next.\n• Select the Third Person template and click Next.\n• Select a C++ project with the With Starter Content option enabled, then click Create Project.\n\nYou have created a new Third Person project and are now ready to learn about Interfaces.\n• From the C++ Class Wizard, create a new Unreal Interface class named InteractInterface.\n• In the class defaults of your declare the following method.\n\nIn this section you created an Unreal Interface and added the function OnInteract. Any Actor class Blueprint that implements this interface will now be able to use this function.\n• From the C++ Class Wizzard, create a new Actor class named CeilingLight. In the class defaults of CeilingLight.h declare the following class library. Then, implement the following code.\n• Next, navigate to CeilingLight.cpp and declare the following Include library. Then implement the following code. ACeilingLight::ACeilingLight() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it. PrimaryActorTick.bCanEverTick = true; RootComponent = CreateDefaultSubobject<URootComponent>(TEXT(\"RootComponent\")); PointLightComp = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComp\")); StaticMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComp\")); PointLightComp->AttachToComponent(RootComponent,FAttachmentTransformRules::KeepRelativeTransform); StaticMeshComp->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform); PointLightComp->SetWorldLocation(FVector(0, 0, -130)); Brightness = 1700.f; Color = FLinearColor(1.f, 0.77f, 0.46f); SourceRadius = 3.5f; PointLightComp->SetIntensity(Brightness); PointLightComp->SetLightColor(Color); PointLightComp->SetSourceRadius(SourceRadius); } void ACeilingLight::OnInteract() { ToggleLight(); } void ACeilingLight::ToggleLight() { if (bbIsLightOn) { PointLightComp->SetVisibility(false); bbIsLightOn = false; } else { PointLightComp->SetVisibility(true); bbIsLightOn = true; } } ACeilingLight::ACeilingLight() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it. PrimaryActorTick.bCanEverTick = true; RootComponent = CreateDefaultSubobject<URootComponent>(TEXT(\"RootComponent\")); PointLightComp = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLightComp\")); StaticMeshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticMeshComp\")); PointLightComp->AttachToComponent(RootComponent,FAttachmentTransformRules::KeepRelativeTransform); StaticMeshComp->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform); PointLightComp->SetWorldLocation(FVector(0, 0, -130)); Brightness = 1700.f; Color = FLinearColor(1.f, 0.77f, 0.46f); SourceRadius = 3.5f; PointLightComp->SetIntensity(Brightness); PointLightComp->SetLightColor(Color); PointLightComp->SetSourceRadius(SourceRadius); } void ACeilingLight::OnInteract() { ToggleLight(); } void ACeilingLight::ToggleLight() { if (bbIsLightOn) { PointLightComp->SetVisibility(false); bbIsLightOn = false; } else { PointLightComp->SetVisibility(true); bbIsLightOn = true; } }\n• From the C++ Classes folder, right-click your CeilingLight Actor, then from the C++ Class Actions dropdown menu, select Create Blueprint class based on CeilingLight. Name your Blueprint BP_CeilingLight.\n• From the BP_CeilingLight class defaults, navigate to the Components panel, then select the StaticMeshComp.\n• From the Details panel, navigate to the Static Mesh category, select the dropdown arrow next to the Static Mesh variable, then search and select for SM_Lamp_Ceiling.\n\nIn this section you created a Ceiling Light Actor class and added a custom function that toggles the light's visibility. Additionally, you implemented the Interact interface to trigger the execution of the ToggleLight event.\n• From the C++ Class Wizard, create a new Actor class named DoorActor.\n• Navigate to your DoorActor.h file and declare the following include:\n• In your DoorActor class namespace, you will need to inherit from your Interact Interface.\n• Then declare the following class definitions. // Variable to hold the Curve asset UPROPERTY(EditAnywhere) UCurveFloat* DoorTimelineFloatCurve; UFUNCTION() virtual void OnInteract(); protected: // Called when the game starts or when spawned virtual void BeginPlay() override; //MeshComponents to represent Door assets UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UStaticMeshComponent* DoorFrame; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UStaticMeshComponent* Door; //TimelineComponent to animate Door meshes UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UTimelineComponent* DoorTimelineComp; //Float Track Signature to handle our update track event FOnTimelineFloat UpdateFunctionFloat; //Function which updates our Door's relative location with the timeline graph UFUNCTION() void UpdateTimelineComp(float Output); // Variable to hold the Curve asset UPROPERTY(EditAnywhere) UCurveFloat* DoorTimelineFloatCurve; UFUNCTION() virtual void OnInteract(); protected: // Called when the game starts or when spawned virtual void BeginPlay() override; //MeshComponents to represent Door assets UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UStaticMeshComponent* DoorFrame; UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UStaticMeshComponent* Door; //TimelineComponent to animate Door meshes UPROPERTY(VisibleAnywhere, BlueprintReadWrite) UTimelineComponent* DoorTimelineComp; //Float Track Signature to handle our update track event FOnTimelineFloat UpdateFunctionFloat; //Function which updates our Door's relative location with the timeline graph UFUNCTION() void UpdateTimelineComp(float Output);\n• Inside of DoorActor.cpp implement the following class definitions ADoorActor::ADoorActor() { //Create our Default Components DoorFrame = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DoorFrameMesh\")); Door = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DoorMesh\")); DoorTimelineComp = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"DoorTimelineComp\")); //Setup our Attachments DoorFrame->SetupAttachment(RootComponent); Door->AttachToComponent(DoorFrame, FAttachmentTransformRules::KeepRelativeTransform); Door->SetRelativeLocation(FVector(0, 35, 0)); } void ADoorActor::OnInteract() { DoorTimelineComp->Play(); } // Called when the game starts or when spawned void ADoorActor::BeginPlay() { Super::BeginPlay(); //Binding our float track to our UpdateTimelineComp Function's output UpdateFunctionFloat.BindDynamic(this, &ADoorActor::UpdateTimelineComp); //If we have a float curve, bind its graph to our update function if (DoorTimelineFloatCurve) { DoorTimelineComp->AddInterpFloat(DoorTimelineFloatCurve, UpdateFunctionFloat); } } void ADoorActor::UpdateTimelineComp(float Output) { // Create and set our Door's new relative location based on the output from our Timeline Curve FRotator DoorNewRotation = FRotator(0.0f, Output, 0.f); Door->SetRelativeRotation(DoorNewRotation); } ADoorActor::ADoorActor() { //Create our Default Components DoorFrame = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DoorFrameMesh\")); Door = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"DoorMesh\")); DoorTimelineComp = CreateDefaultSubobject<UTimelineComponent>(TEXT(\"DoorTimelineComp\")); //Setup our Attachments DoorFrame->SetupAttachment(RootComponent); Door->AttachToComponent(DoorFrame, FAttachmentTransformRules::KeepRelativeTransform); Door->SetRelativeLocation(FVector(0, 35, 0)); } void ADoorActor::OnInteract() { DoorTimelineComp->Play(); } // Called when the game starts or when spawned void ADoorActor::BeginPlay() { Super::BeginPlay(); //Binding our float track to our UpdateTimelineComp Function's output UpdateFunctionFloat.BindDynamic(this, &ADoorActor::UpdateTimelineComp); //If we have a float curve, bind its graph to our update function if (DoorTimelineFloatCurve) { DoorTimelineComp->AddInterpFloat(DoorTimelineFloatCurve, UpdateFunctionFloat); } } void ADoorActor::UpdateTimelineComp(float Output) { // Create and set our Door's new relative location based on the output from our Timeline Curve FRotator DoorNewRotation = FRotator(0.0f, Output, 0.f); Door->SetRelativeRotation(DoorNewRotation); }\n• Select CurveFloat and name your CurveFloat asset DoorCurveFloat\n• Double-click your DoorCurveFloat asset. Add two keys to your Float Curve and give one key the time-value (0,0), and the other key the time-value of (4,90).\n• Shift-click to select both your keys, and set them to Auto Cubic interpolation, then save your curve.\n• From the Content Browser, navigate to your C++ Classes folder and right-click your DoorActor class. Select Create Blueprint Class based on Door Actor and name your Blueprint Actor Bp_DoorActor.\n• Inside BP_DoorActor's class defaults, find the Components tab, and select the DoorFrame Static Mesh component, navigate to the Details panel and change the Static Mesh to SM_DoorFrame.\n• Next, from the Components tab, select the DoorMesh component. Navigate to the Details panel and change the Static Mesh to SM_Door.\n• From the Details panel, select DoorCurveFloat from the Door Timeline Float Curve dropdown menu.\n\nIn this section you created an interactive Door Actor that opens when the OnInteract method of the Interact interface is called.\n• Open your BpCommunicationCharacter.h file and then declare the following in its class definitions.\n• Navigate to your BpCommunicationCharacter.cpp file and declare the following class libraries. Then implement the following class methods.\n\nIn this section you added a sphere component to the ThirdPersonCharacter class to detect overlapping Actors. When an actor overlaps with the sphere, the Character casts to the interact Interface and triggers the OnInteract function for the overlapped Actor.\n• Drag an instance of your BP_DoorActor and the BP_CeilingLamp Blueprints into the Level viewport.\n• Click Play and approach each Blueprint to see them interact with the player.\n\nIn this section you confirmed that the interaction system is working as intended by testing it with the interactive door and ceiling lamp Actor Blueprints.\n\nIn this Quick Start guide you learned how each Actor class Blueprint can implement the same Interface, and also specify their functionality separately. You also learned why Interfaces are ideal for implementing similar functionality on a wide variety of Blueprint classes without the need for casting.\n\nNow that you know how to use Blueprint Interfaces, take a look at the other communication types referenced in the Actor Communication documentation page."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/details-panel-customizations-in-unreal-engine",
        "document": "The Unreal Engine Reflection System uses information from UProperty macros to decide how to display properties in the Details Panel. This is sufficient for most use-cases for exposing properties. However, you may want to customize how the Details Panel displays and edits information in greater detail.\n\nUnreal Engine provides Details Panel Customization Interface classes to override the Details Panel and change, remove, or add elements as needed. This includes modifications to displaying specific properties, custom edit conditions, or implementations of complex custom Slate widgets. This page provides an overview of the basics of Details Panel Customizations as well as links to tutorials showing you how to build them step-by-step.\n\nThe interface classes used for Details Panel Customizations are:\n\nWhen you implement one of these classes, you can override their customization functions to add Slate code. The parameters expose utility classes and data about the class or struct that you are customizing. These interfaces are summarized in further detail below.\n\ncustomizes the Details Panel for UObject and UActor-derived classes. Anytime you select an instance of an object with an assigned to it, the Details Panel will display according to the Detail Customization's rules.\n\nis a simple example of a class that uses a Detail Customization. is a Detail Customization that adds a button to open a supplied URL in your web browser.\n\nprovides a place to add Slate code that overrides the Details Panel for and Actor-derived classes. Anything you do not explicitly change displays the default details panel without the Detail Customization, giving you room to focus only on what you want to add or rearrange.\n\nis the base class to customize the Details Panel display for a custom property type. Anytime you expose an instance of a property type to the Details Panel for editing – either through Blueprint-defined variables or specifiers such as or .\n\nExamples of structs in Unreal Engine that use property type customizations include:\n\nThe header represents the details of a property handle, including the collapsible drop-down that appears above the property's members. In a struct that doesn't implement the Property Type Customization interface, the property's name appears in this section.\n\nThe Details Customization for a struct called \"MyStruct.\" It includes a customized header (1) and children (2).\n\nIf you declare this without any parameter arguments, the function displays at the same hierarchical level as a class's other child properties, with no collapsible drop-down displayed in Unreal Editor.\n\nAlternatively, you can customize your header but override CustomizeChildren to do nothing.\n\ncustomizes the section that appears when you click a property's collapsible drop-down to display all its child properties.\n\nIn a struct without a Property Type Customization, all properties defined as part of the struct appear in this section.\n\nExample of a custom struct with CustomizeChildren (1) filled but no CustomizeHeader. Fields appear inline with the Actor's other properties (2) instead of in a drop-down.\n\nIf you override this function without providing any code, none of the child properties of the struct will appear in the Details Panel. To display them, you need to use . You can loop through the full list of your property's children to display all of them.\n\nThe following class interfaces provide useful functions to access slate class properties.\n\nprovides utility functions for accessing and changing a UObject or UActor's properties and categories. is available in .\n\nprovides utility functions for accessing and changing a custom property type's properties and categories. It works similarly to , but is limited only to child properties of the property that the parent customizes.\n\nis a wrapper that contains information about a property within the Details system, including delegates that respond to the property being changed and a reference to the property itself. IPropertyTypeCustomization has two functions that both provide references to the IPropertyHandle for the property you are customizing. the , and interfaces get a shared reference ( ) to the for any child properties of the class it is customizing.\n\nprovides references to common fonts, access to the thumbnail pool, and a shared reference to the interface.\n\nprovides a variety of utility functions. This includes the ability to force or request a refresh of the Details Panel, access to information about the user's current selection, and a utility function that can create a Color Picker window. is available through or .\n\nThe following tutorials provide more details and examples for specific operations when customizing the Details Panel:"
    },
    {
        "link": "https://forums.unrealengine.com/t/help-with-details-panel-customization/76425",
        "document": "Hey, So I am customizing my struct’s details panel but there is one variable that I want to appear as normal/default (as if I didn’t override CustomizeHeader). The variable TWeakObjectPtr Doorway is the variable that should appear as default, with..."
    },
    {
        "link": "https://forums.unrealengine.com/t/how-can-i-customize-the-details-panel-for-a-class/334022",
        "document": "According to this guide, the first thing I need to do is create a class that inherits from ILayoutDetails. Which does not exist anywhere in the code. There is no information on this class in the wiki, forums, or google search. It also says: “(more examples are located in DetailCustomizations.cpp)”. This file exists nowhere in the entire solution. Rama’s Slate, Hello guide does explain how to get slate in-game, but setting slate widgets via BeginPlay() won’t work for the editor, and setting slate widgets in a constructor crashes the engine. My end goal here is to have a 2d matrix of boolean values that I can tick, with a scalable number of tickboxes in each dimension, and then set a property based on the selected tickboxes. It’s a makeshift bitmask, which I’ve implemented in C++ but it can currently only be set via a series of blueprint functions. I want to have some bitmask-setting functionality in the editor.\n\nIt’s called a Details Customization. You can find many examples in the code base by searching for *Customization.h IDetailCustomization is the interface you need to implement. It has a single method CustomizeDetails that will pass you an IDetailLayoutBuilder. The latter has lots of helper methods for various kinds of things.\n\nThank you for the quick response. I’ve been at this all day and still can’t figure out how to access the IDetailLayoutBuilder’s functions. I’ve included the “Editor/PropertyEditor/Public/IDetailCustomization.h” file to access the builder, but it has no members nor functions available to it. Maybe there’s a part of the UE4 C++ API that I don’t know about. I’m pretty lost as to what to do here. The furthest I have gotten while compiling: the “layout” parameter has nothing usable.\n\nSo for example, including the file: “Editor/PropertyEditor/Public/DetailLayoutBuilder.h”, which gives access to IDetailLayoutBuilder’s functions, causes a compiler error C2653: ‘FEditorStyle’ is not a class or namespace name. I’ve included the modules mentioned in the documentation for both FEditorStyle s and IDetailLayoutBuilder s, but the error persists, and I don’t think modifying the engine code to include the files it references is what I need to do.\n\nYeah, the includes are a bit of a mess. You will have to include a bunch of header files by head as the required dependencies are not being pulled in automatically. We will clean that up, eventually. You also need to add some modules to your PrivateDependencyModuleNames array in the Build.cs of your project, such as PropertyEditor and EditorStyle. I think it would be best if you take a look at the existing implementations - preferably not the ones in the DetailCustomizations module, but those in plug-ins. They are pretty self-contained and show you what you need to include.\n\nAlso, the general process is this:\n• Register your class in your module’s StartupModule() method\n• Unregister your class in your module’s ShutdownModule() method Once your class is registered for a certain UClass or UStruct type, the details panel will call the corresponding methods on your class whenever such a type needs to be visualized. For example, it may call CustomizeDetails() on your class customization, and it passes in a DetailBuilder, which you can use to create custom widgets, etc.\n\nI figured out a few problems:\n\n -DetailCustomizations.cpp actually DOES exist, contrary to what i posted in my question. Looking at it in combination with your answers is making this all much clearer.\n\n -I wasn’t aware of how Modules worked, but after making my own(which was useful since this editor is specific only to my game), registering things in startup and shutdown for the modules makes sense, as well as the RegisterCustomization()s you were referring to. Anyway, I made my own module, and then set up the correct registrations with it, and now it draws a thing in the detail panel! Thank you for your help."
    },
    {
        "link": "https://unrealcommunity.wiki/62d71a61b4d2780e06e3a523",
        "document": "\n• the well documented and explained tutorial from Kantan website\n• a lot of digging in and modules.\n\nYou need to master these elements first (or at least well understand their key principles):\n• Create an Editor Module (but I show you quickly how to make it below)\n\nEvery lines of codes has been written and testing on this repo: https://github.com/NansPellicari/UE4-HowTo-DetailsPanelCustomization so you can test all these next features in a glimpse.\n\nLook at each commit! I separate each commit trying to get a step by step guide following the instructions bellow. This way you can check what lines of codes has been added at each step.\n\nIf you want to contribute on the repo you are very welcome!\n\nThere are 2 kinds of cutomizations:\n• Property Type Customization: it gives the ability of changing the layout and validate data of the (ies) of an . >>> This works exclusively with an .\n• Detail Customization: gives full control over the rendering of all parts of the pane (customizing the category box, creating new categories, do whatever you like in the categories etc.). >>> This works with any or .\n\nFirst we need to create a dedicated Editor Module.\n\nIn our files, add these lines:\n\nCreate necessary folder and then create in the file with this content:\n\nAdd our new module on our file:\n\nTo create a Property Type Customization we need a to work with (as we've talking about above):\n\nWhy an enum? This enum will be used to change the customization's display in accordance with its value.\n\nthen compile and we'll see this new setting in our details panels of the Actor:\n\nNow everything will be done in our Editor module.\n\n> What can we customize?\n\nFor now it is represented by our property's name (defined in the actor). It should be great to add a bit more details here to distinguished quickly what type of value has been selected.\n\nThis part is dedicated to the list of properties of our Struct, this is where the most of our customization fit.\n\nFor the both parts (Children & Header), we can:\n• add events when values changes to customize behaviors\n• change or add slate widget to customize the style\n\nOur class name shoulds represent the struct's name the customization was made for, add appendix to the =\n\n> Register the customization for the editor\n\nNow the customization exists, we can register (and unregister) it thanks to our module definition:\n\nUnfortunatly, everytime you change your customizations you should close and reopen the unreal editor...😦 BTW Unreal Doc says: \"If this is an engine class, you should add your customization class (if it does not already exist) to the module. This module can be recompiled and reloaded without restarting the editor, making it useful for fast tweaking of properties.\" We will not do that here (it is not an engine class), but keep it in mind to ease your further developments if you need so.\n\nNow in your Actor BP, there is no more details shown for our property. This because the customization is applied but we didn't implement anything yet:\n\nBut you can see in the logs panel:\n\nFirst, lets retrieve the default display of our header:\n\nNow we'll need to add more usefull details.\n\nFirst we need to get some configured style for the editor, so we have to add a dependency on the module:\n\nthen we get the of the to display it :\n\nBut it is not sufficient for now, if the property value change, this widget will not be notified (so the display not updated). Although we still don't managed the display for the value, we can already attached an event to the property to prevent this.\n\nFirst upgrade our to a protected property and give it a more explicit name: . At the same time we can write the definition of the bound function we want to attached to our event.\n\nNext, add these changes on the cpp file:\n\nOk that seems good but something missing. The value is passed to the widget but we have to bind a function to the desired attributes (as we need to do in the editor for a blueprint Widget to have a refreshed data to display)...\n\nwith the Slate API we do:\n\nOk the most interesting parts are coming here. First we need to test a changing value of the to see if our header customization is working:\n\nAfter compiling we can change the and see the text changing:\n\nNow add some style for our children properties:\n\nOk ok style is still a subjective taste... But now you probably better understand how far you can go == Sky is the limit 😵!!\n\nAs we planned when we created the , we want the properties edition depending on the chosen.\n\nThanks to the previously header's customization, we already listen an event when 's value changes. We just have to push a bit further the implementation:\n\nThen add attribute for wrapping the desired field:\n\nIf you want to call a customization inside your new customization without changing its style and behavior, you should call (which return a slate widget) in your method."
    },
    {
        "link": "https://github.com/wolfpld/tracy",
        "document": "Tracy supports profiling CPU (Direct support is provided for C, C++, Lua, Python and Fortran integration. At the same time, third-party bindings to many other languages exist on the internet, such as Rust, Zig, C#, OCaml, Odin, etc.), GPU (All major graphic APIs: OpenGL, Vulkan, Direct3D 11/12, Metal, OpenCL.), memory allocations, locks, context switches, automatically attribute screenshots to captured frames, and much more.\n• Releases containing the documentation ( ) and compiled Windows x64 binaries ( ) as assets\n\nAn Introduction to Tracy Profiler in C++ - Marcos Slomp - CppCon 2023\n\nIntroduction to Tracy Profiler v0.2\n\n New features in Tracy Profiler v0.3\n\n New features in Tracy Profiler v0.4\n\n New features in Tracy Profiler v0.5\n\n New features in Tracy Profiler v0.6\n\n New features in Tracy Profiler v0.7\n\n New features in Tracy Profiler v0.8"
    },
    {
        "link": "https://scribd.com/document/766566957/tracy",
        "document": "You are on page 1"
    },
    {
        "link": "https://github.com/wolfpld/tracy/blob/master/README.md",
        "document": "Tracy supports profiling CPU (Direct support is provided for C, C++, Lua, Python and Fortran integration. At the same time, third-party bindings to many other languages exist on the internet, such as Rust, Zig, C#, OCaml, Odin, etc.), GPU (All major graphic APIs: OpenGL, Vulkan, Direct3D 11/12, Metal, OpenCL.), memory allocations, locks, context switches, automatically attribute screenshots to captured frames, and much more.\n• Releases containing the documentation ( ) and compiled Windows x64 binaries ( ) as assets\n\nAn Introduction to Tracy Profiler in C++ - Marcos Slomp - CppCon 2023\n\nIntroduction to Tracy Profiler v0.2\n\n New features in Tracy Profiler v0.3\n\n New features in Tracy Profiler v0.4\n\n New features in Tracy Profiler v0.5\n\n New features in Tracy Profiler v0.6\n\n New features in Tracy Profiler v0.7\n\n New features in Tracy Profiler v0.8"
    },
    {
        "link": "https://docs.tenstorrent.com/tt-metalium/latest/tools/tracy_profiler.html",
        "document": ""
    },
    {
        "link": "https://maplibre.org/maplibre-native/docs/book/profiling/tracy-profiling.html",
        "document": "MapLibre Native integrates Tracy profiler which offers an easy way to understand and optimize your application's CPU and GPU performance. Tracy mainly consists in manually adding markup instrumentation in the code to log performance events. These events can then be analyzed and visualized using the Tracy Profiler tool.\n\nInstrumentation is generally the first step in profiling applications that use MapLibre. Once slow inner-loop routines are identified, additional hardware vendor specific tools can be used to collect hardware counters and optimize low level CPU and GPU code.\n\nTracy client consists of an API to mark CPU and GPU performance zones. A zone is a code section where the start and end timestamps are recorded.\n\nThe server is the Tracy profiler that allows the analysis and visualization of the client recorded data. The server can be downloaded from Tracy release page or it can be easily built from sources on Linux, Windows or Mac using CMake\n\nInstrumentation is enabled by turning the CMake option . Tracy computational overhead is very low but by default it keeps all instrumentation events that are not consumed by the server in system memory. This can have a negative effect on platforms with low memory. To prevent high memory usage, macro should defined. This way instrumentation data is only stored when the server is connected to the application.\n\nThe file defines the following instrumentation macros:\n\nThe macro records the timestamps at the start and end of the code scope. The parameter label is a user defined name for the zone. Example:\n\nThe macro is meant to be placed at the start of a function and expands to:\n\nOpenGL is also supported in MapLibre native. Tracy support is currently missing for other APIs such as Metal and need to be added separately.\n\nThis macro is similar to except that OpenGL timestamp queries are inserted in the GPU command buffer instead of recording CPU time.\n\nThis macro is similar to except that OpenGL timestamp queries are inserted in the GPU command buffer instead of recording CPU time.\n\nThe above macros can be added inside MapLibre code and also in the application code that calls MapLibre.\n\nThe following macros should only be used if there are changes to MapLibre internals:\n\nPlaced after an OpenGL context is created.\n\nRecord a buffer allocation and deallocation that is intended to be used as a read-only vertex buffer\n\nRecord a buffer allocation and deallocation that is intended to be used as a read-only index buffer\n\nRecord a buffer allocation and deallocation that is intended to be used as a constant buffer\n\nUsage example on Linux and Windows\n\nDownload or build the Tracy profiler (server) and run it.\n\nMake sure you generate the MapLibre project with the option enabled.\n\nAs an example, the glfw sample is used.\n\nWith CMake, in MapLibre repository root do\n\nIn the Tracy Profiler hit the connect button (or select the glfw application from the list of applications that are running Tracy Client). Profile then optimize the code.\n\nThe Android application communicates instrumentation data to the profiler (Tracy server) on the network using port 8086 by default. You can expose the port to the profiler using Android Debug Bridge by running the command:\n\nMore information and advanced usage in Tracy"
    }
]