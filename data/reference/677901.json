[
    {
        "link": "https://labcenter.com/downloads",
        "document": "This PDF includes the Visual Designer for Raspberry Pi® and Arduino™ Tutorials along with the Funduino Turtle & Zumo Tutorials. Download\n\nThis PDF includes several tutorials showing you how to create remote user interfaces for your Arduino™ and Raspberry Pi® appliances. Download\n\nThis Coursework book is designed to introduce the reader to Visual Designer, programming and electronics in an easy step-by-step way. You can contact Labcenter if you would prefer it in an ePub format. Download\n\nThe Proteus 9 brochure provides a short summary of some new capabilities & features in the latest version. Download\n\nThis PDF download explains how users can access millions of library parts through our integrated web search or by importing from various library part vendors such as Samacsys, SnapEDA or Ultra-Librarian. Download\n\nThis download summarises the flexible design rule system in Proteus which provides you with the flexibility to define board constraints at the level you need. Download\n\nThis flyer outlines support for Raspberry Pi in Proteus. This makes it easy to create embedded design projects with Raspberry Pi. Download\n\nIoT Builder is a unique product designed to make it quick and easy to control remote Arduino or Raspberry Pi electronics from a mobile device. Download\n\nProteus is a powerful tool used worldwide to teach electronics, PCB design and Micro Controller at all levels of education from beginner to degree. Download\n\nIf you have an old (Purple or Blue) SparKey dongle, you can download the latest drivers for both Microsoft® Windows® 32 & 64 bit OS. Current dongles do not require a driver.\n\n Image for illustration purposes only and does not represent a Proteus dongle. Download"
    },
    {
        "link": "https://st.com/en/embedded-software/stsw-proteus.html",
        "document": ""
    },
    {
        "link": "https://edaboard.com/threads/problem-with-simulating-microcontrollers-in-proteus.349851",
        "document": "Quality Assurance\n\n As always, the Proteus software undergoes intensive testing before release. However, there is always the possibility of unforeseen behaviour causing a software crash. In the event that you do have problems, there is a crash reporting system in place that will prompt you to upload a 'crash dump' to our servers after a successful restart. We would be grateful if as many of you as possible leave this mechanism enabled as the crash dumps will be extremely helpful in understanding why a particular crash occured and where in the software the problem lies."
    },
    {
        "link": "https://labcenter.com",
        "document": "The Proteus Design Suite combines ease of use with a powerful feature set to enable the rapid design, test and layout of professional printed circuit boards. Proteus PCB tools seamlessly combines schematic capture and PCB layout to provide a powerful, integrated and easy to use suite of tools for professional PCB Design. PCB Design Software Design, Test and Debug complete embedded systems inside schematic capture before ordering a physical prototype. VSM brings AGILE development to the embedded workflow. Circuit Simulation Software A complete workflow for designing an Arduino™ or Raspberry Pi® appliances and then controlling it remotely from a phone or browser. Build multi-appliance systems with the MQTT protocol. Design, simulate and deploy directly from Proteus. IoT Builder Software\n\nThe 8.17 release is a significant point release introducing a new Push and Shove route editing mode. Building on the Push routing algorithms, users can now push tracks and vias out of the way during a route editing operation. This is fully design rule aware and works with both linear and curved cornering modes.\n• Push other tracks and vias out of the way during route editing.\n• Route Command Centre allows toggling of push editing mode on and off.\n• Visual DRC shows clearances of objects around the mouse.\n• Status bar upgrades for live display of route length and style. Learn more about our latest features\n\nWe started developing Proteus way back in the days of MS-DOS. Over 35 years of constant development later we're proud to offer one of the most productive and cost effective PCB tools on the market. Our philosophy has always been one of continuous improvement and innovation resulting in a modern software suite packed full of powerful, time-saving features to help you design PCBs faster. Affordable PCB Packages\n\nPurchasing Proteus is the start - not the end - of a successful business relationship. Included with the cost of the software comes a world class technical support service. After each professional purchase one of our team will introduce themselves as your technical support point of contact. This gives you an easy way to ask questions and direct access to Labcenter support. We may not be able to solve every problem immediately but we'll certainly try our best. Free Dedicated Support\n\nOur customers are the reason for our success. We remain fully engaged with our user base and encourage customers to get in touch and tell us what features would help make their job easier. We can't implement each request immediately of course but a formal logging system is in place for customer feedback which is regularly reviewed by management. Each and every Proteus product release benefits from customer driven development. Proteus Release Features\n\nProteus Design Suite is found in High Schools, Colleges and Universities across the world, teaching electronics, embedded design and PCB layout to tens of thousands of students each year.\n• A software solution allows instructors to prepare and re-use virtual labs.\n• Flexible licensing gives freedom for classes and assignments to be completed anywhere. Learn more about Proteus in Education The Proteus Design Suite is widely used across various industry sectors as a cost effective solution for professional PCB design and as a rapid prototyping tool for R&D.\n• Virtual Prototyping enables system Testing before the first physical PCB is ordered.\n• Direct access to over 15 million parts means never building a component or footprint again. Learn more about Proteus in Industry\n\nTry the Proteus Design Suite today. Our demo version is time limited only in simulation and is a great way to get started with the Proteus tools. Alternatively, if you want a full evaluation please contact the sales team via the link below. Get Started Now! Contact Us"
    },
    {
        "link": "https://en.eeworld.com.cn/news/mcu/eic613754.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/71626597/what-are-the-various-ways-to-disable-and-re-enable-interrupts-in-stm32-microcont",
        "document": "Update 10 May 2023: one of my primary motivating factors in learning this stuff was related to my first ever ring buffer implementation I wrote 7 years ago in 2016, leading to this debugging problem where I lost 25 hours of debugging work in 2 days. I finally wrote a really good ring buffer implementation that is lock-free when used on any system which supports C11 or C++11 atomic types. It is the best implementation I've ever written, and also the best I've ever seen. It solves a lot of the problems of other implementations. Full details are in the top of the file. It runs in both C and C++. You can see the full implementation here: containers_ring_buffer_FIFO_GREAT.c in my eRCaGuy_hello_world repo.\n\nFor the definition of these functions, see:\n• https://github.com/ARM-software/CMSIS/blob/master/CMSIS/Include/cmsis_gcc.h\n• Contains at least:\n\nTo save and restore the interrupt state, use , like this:\n\nWhen dealing with global interrupts, this is the best way for bare-metal, non-FreeRTOS code!\n\nI think this technique is also cross-compatible with ALL ARM-core mcus, not just STM32.\n\nI first learned this technique from Tilen Majerle, here: https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/. His work and contributions to clear up this super-obfuscated stuff are infinitely valuable and appreciated!\n\nIt is best to avoid disabling global interrupts, if possible, and disable only the fewest number of specific interrupts possible to achieve atomicity for your specific code. So, using these functions allows you to enable or disable only the specific interrupts you need to!\n\nNVIC stands for \"Nested Vector Interrupt Controller\". Nested interrupts (meaning: a higher-priority interrupt can still fire within an ISR) are enabled by default on STM32 microcontrollers. Each interrupt type has a priority assigned to it, with lower numbers being higher priority, and higher-priority interrupts are able to fire while an ISR is being processed for a lower-priority interrupt. See here for a little more information on the STM32 NVIC: https://stm32f4-discovery.net/2014/05/stm32f4-stm32f429-nvic-or-nested-vector-interrupt-controller/.\n\nContrast this to AVR microcontrollers (ex: ATMega328 / Arduino Uno), which do not have priority-based interrupts, so by default, when any ISR is being processed, all interrupts (ie: global interrupts) are automatically disabled as the program enters the ISR. Note that even on AVR mcus, however, you can still manually enable nested interrupts / ISRs if you like by manually re-enabling global interrupts inside your ISR, via a call to on Arduino or (set interrupts) on raw AVR.\n\nEach ARM-core microcontroller manufacturer, I believe, including STM32 types, must define and create its own list of interrupt request types, so see below for the STM32 details on their specific interrupt types defined for each mcu.\n\nSee, for example: \"stm/stm32f2xx/st_hal_v1.1.3/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cortex.c/.h\" - definitions for those functions above are in those files. See them online:\n\nHere are the definitions of and . Notice that they just check to ensure your is valid, then they pass the input argument on to the ARM-core CMSIS and functions above!:\n\nFor s: see the appropriate definition file for your specific board! These are board-specific definitions, for your board from your manufacturer. Here are all of the boards in the STM32 F2xx line, for instance: https://github.com/STMicroelectronics/STM32CubeF2/tree/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include. Let's look at the file specifically:\n• Raw view (since file is too big to view on GitHub otherwise): https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF2/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include/stm32f217xx.h\n\nFrom this file, we can see the definition for the , which is the \"STM32F2XX Interrupt Number Definition\". Here is what it looks like:\n\nTo get exclusive access (to ensure strings are atomically printed, for instance) to the for printing debug chars via a HAL-based blocking (polled) mode (ie: via ), you need to disable all interrupts for by doing the following. (This guarantees you get atomic access to this device):\n\nThe FreeRTOS atomic-access-guard / interrupt-related functions are listed under the \"Modules\" section of the Kernel Control API here: Kernel Control:\n\nSee also my README here, with a potential list of which calls are and are not allowed within FreeRTOS critical sections: https://github.com/ElectricRCAircraftGuy/eRCaGuy_Engineering/tree/main/FreeRTOS#freertos-critical-section-calls\n• None These are the preferred macros to use, and are the freertos-recommended ones!\n• None These all support nested calls, and end up calling anyway, which is the port implementation of the lower-level , shown below. Calls to and are designed to nest. Therefore, a critical section will only be exited when one call to has been executed for every preceding call to . Critical sections must be kept very short, otherwise they will adversely affect interrupt response times. Every call to must be closely paired with a call to . FreeRTOS API functions must not be called from within a critical section.\n• None These do NOT support nested calls!\n• None Official documentation on them is on the main \"Kernel Control\" page:\n• \n• at the link above states: Normally this macro would not be called directly and and should be used in its place.\n• at the link above states: Normally this macro would not be called directly and and should be used in its place.\n• Note also that the use of is demonstrated as the technique used to panic inside an example macro definition for .\n• From here: https://www.freertos.org/a00110.html#configASSERT, when used with a debugger, it is defined as: /* Define configASSERT() to disable interrupts and sit in a loop. */ #define configASSERT( ( x ) ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }\n• My thoughts: perhaps in this one case (ie: hard asserting, or panicking), might be preferred over because no amount of calling from another thread will re-enable interrupts once has been called [I think!?]--rather, one would have to explicitly (and accidentally) call (ex: from another thread) to re-enable interrupts once has been called. In other words, using the low-level call is appropriate here because it will truly cause the system to sit in a loop, as desired, whereas would not.\n\nBeyond the examples above, you can also use FreeRTOS queues (which are thread-safe, unlike all containers in the C++ std library), mutexes, semaphores, task notifications, and other synchronization primitives, where able and where appropriate, to protect certain data which is shared between FreeRTOS tasks (threads), assuming you are running FreeRTOS.\n\nSee the list of these tools here: https://www.freertos.org/a00106.html, and in the left-hand navigation menus once you click on that link.\n• None Add an atomic ( or really makes more sense as a function name for this, I think) demo using ARM-core CMSIS functions, or assembly, or whatever means necessary, to demonstrate writing a spin lock in STM32. I don't know how to do this yet so it will require finding the right function or operation to use. See here: https://en.wikipedia.org/wiki/Test-and-set#Pseudo-C_implementation_of_a_spin_lock: volatile int lock = 0; void critical() { // Spin lock: loop forever until we get the lock; we know the lock was // successfully obtained after exiting this while loop because the // test_and_set() function locks the lock and returns the previous lock // value. If the previous lock value was 1 then the lock was **already** // locked by another thread or process. Once the previous lock value // was 0, however, then it indicates the lock was **not** locked before we // locked it, but now it **is** locked because we locked it, indicating // we own the lock. while (test_and_set(&lock) == 1); critical section // only one process can be in this section at a time lock = 0; // release lock when finished with the critical section } Here is a spin lock implementation I did in C11 using types. It should work just fine for STM32 as well, and probably compiles to use the underlying exclusive / operations to store (write) and read (load), but I'd have to check that by looking at the assembly. Additionally, this implementation would need to be modified to add safety anti-deadlock mechanisms such as automatic deferral, timeout, and retry, to prevent deadlock. See my notes here: Add basic mutex (lock) and spin lock implementations in C11, C++11, AVR, and STM32\n• My answer on this for AVR mcus/Arduino\n• My answer on the general practice and demo of using atomic access guards, and my func which ensures atomic access withOUT turning interrupts off\n• [my Q&A] Which variable types/sizes are atomic on STM32 microcontrollers?\n\nSee the References section of my question here: How to properly count timer overflows to convert a 32-bit high-resolution timer into a 64-bit high-resolution timer:"
    },
    {
        "link": "https://reddit.com/r/stm32/comments/166dxyz/uart_rx_interrupt_best_practises",
        "document": "What are the best practices for handling received packets using UART in interrupt mode?\n\nThe way I am currently working, I have a global receive buffer and then perform all processing of this buffer inside my RxCpltCallback function and although it works, it doesn't seem right to me.\n\nI can think of two ways I could improve on this but I would like it if someone could weigh in for me:\n• Use a secondary processing buffer: I can create a secondary global \"processing buffer\" and copy the received data into this buffer in the interrupt callback function, and then process this second buffer in the main body of my code. This will allow me to begin receiving again immediately in the callback, but there is the obvious problem of the secondary buffer being overwritten in the middle of processing if more data comes in.\n• Raise a flag upon completion: In the interrupt callback, I could raise a flag and then process the received packet inside the main body. After processing, I would then begin trying to receive data again. This eliminates the need for two buffers (I could even have a single local buffer but I would still require a global flag) and if I attempt to send data before I start trying to receive again, I believe it will just sit in a transmission buffer on the transmitting device until it can be received. Please correct me if my understanding here is wrong.\n\nI appreciate any and all input or if you have ideas for better/nicer ways of handling things."
    },
    {
        "link": "https://stackoverflow.com/questions/65178548/how-to-implement-uart1-interrupts-correctly-on-stm32f103xx-while-running-a-main",
        "document": "I am trying to program my bluePill to blink an LED at the PB11 pin while echoing whats being send over the serial port UART1.\n\nas far as my knowledge, Interrupts allows us to run the programme we want and while running it if any flag triggered an interrupt signal the program the control will be diverted to run the interrupt service routine while the original program is running, am I correct here?\n\nSo, I'm trying to keep the Green LED blinking and when I type anything on the serial port the red LED blinks while the green is blinking and the blue led must be always turned on unless data is being sent.\n\nProblem 2: Whenever sending letters or numbers through Arduino serial monitor the received echo is always 2 letters out of the entire send letters, also the echo is always on the same line, I mean not not on a newline so typing and pressing enter yields and when typing and pressing enter the it just adds the first two letters like so , why?"
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-touchgfx-and-gui/stm32-good-practices-interrupts/td-p/104475",
        "document": "I am preparing a much larger code that handles a slew of tasks (gathers CAN data from up to 5 different nodes, reads ADCs, sends GPIO PWM signals and ON/OFF signals, LCD display screen via TouchGFX).\n\nI have interrupts for specific tasks (when a CAN message is received, timer interrupt, etc.). Additionally, I will want to periodically send information to different CAN nodes. I understand that it is considered a good practice to minimize the amount of code in the interrupt functions, so I picture the code sequence being as follows (for the CAN receive portion, for example):\n• Read RxData and store it in the the variables relevant to the data sent\n• Do arithmetic or logic based on data received <------------------------------\n\nWhat I want to know is the best practice to do step 4. The arithmetic and/or logic could be a fair bit of code, so I know I shouldn't do it in the interrupt function, but the TouchGFX display portion will cause it to be in a specific task. Should I write the logic in the TouchGFX task function, or create a different task/function? If so, how will it be entered without another interrupt?"
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/best-practices-how-to-work-with-interrupts-and-low-power-modes/td-p/620588",
        "document": "The user \"davidshel3193\" is a bot and it has regurgitated the \"average Joe\" on the internet. Part of the information is true, but in many points it is critically incomplete and therefore is a disinformation.\n\nGenerally there are tree levels, where interrupts can be disabled - peripheral, NVIC and CPU core. You can learn about it, reading this discussion, but even that one is slightly in correct. ARM CPU wakes up from the sleep when the interrupt becomes pending in NVIC, regardless of whether interrupts can actually be executed. Therefore disabling interrupts at NVIC will not wake up CPU from the sleep. In addition NVIC is \"per peripheral\" and that is not what you need here. Disabling interrupts in CPU core sets a flag in PRIMASK register, which disables just the execution of all interrupts, but the CPU still wakes up from the sleep, when an interrupt becomes pending in NVIC. And, if the interrupt becomes pending before or at the time of executing the WFI instruction, the WFI instruction will act as a NOP instruction and the CPU will not go into sleep mode.\n\nGenerally one should not disable the system tick, when going into sleep mode. If you disable it, the system time will not advance. If you are using those ticks only in blocking functions, that can be OK, but, if you are saving timestamps and using those later, that will obviously fail. For extreme power saving by disabling system ticks typically then an RTC with an additional synchronization code is involved.\n\nTaking all that into account, the correct code can be seen in this topic about CPU load measurement. But the generic template is this:\n\nFor a task selection I recommend using the __CLZ() macro (instruction) instead of inefficiently testing all bits. Though it's not available on M0(+) cores, but even then a simple loop with a binary search algorithm with O(log n) time complexity is generally better.\n\nOn 32-bit ARM all data types up to the size of 32 bits are atomic, therefore uint32_t, uint_fast16_t, uint_fast8_t, all of which on 32-bit ARM are defined as 32-bit unsigned integers, are often the preferred types, that can often be faster than the smaller types. But, the RMW operations, of course, are not atomic.\n\nEffectively, what you are developing here, is not just an interrupt processing code, but a cooperative task scheduler. As the tasks can be activated (flag set) from interrupts with different preempt priorities or thread (non-interrupt) code, the flag setting code cannot just re-enable the interrupt unconditionally. Instead this approach must be used:"
    }
]