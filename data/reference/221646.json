[
    {
        "link": "https://keras.io/api/layers/recurrent_layers/lstm",
        "document": "Based on available runtime hardware and constraints, this layer will choose different implementations (cuDNN-based or backend-native) to maximize the performance. If a GPU is available and all the arguments to the layer meet the requirement of the cuDNN kernel (see below for details), the layer will use a fast cuDNN implementation when using the TensorFlow backend. The requirements to use the cuDNN implementation are:\n• Inputs, if use masking, are strictly right-padded.\n• Eager execution is enabled in the outermost context.\n• activation: Activation function to use. Default: hyperbolic tangent ( ). If you pass , no activation is applied (ie. \"linear\" activation: ).\n• recurrent_activation: Activation function to use for the recurrent step. Default: sigmoid ( ). If you pass , no activation is applied (ie. \"linear\" activation: ).\n• use_bias: Boolean, (default ), whether the layer should use a bias vector.\n• kernel_initializer: Initializer for the weights matrix, used for the linear transformation of the inputs. Default: .\n• recurrent_initializer: Initializer for the weights matrix, used for the linear transformation of the recurrent state. Default: .\n• unit_forget_bias: Boolean (default ). If , add 1 to the bias of the forget gate at initialization. Setting it to will also force . This is recommended in Jozefowicz et al.\n• activity_regularizer: Regularizer function applied to the output of the layer (its \"activation\"). Default: .\n• dropout: Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. Default: 0.\n• recurrent_dropout: Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state. Default: 0.\n• return_sequences: Boolean. Whether to return the last output in the output sequence, or the full sequence. Default: .\n• return_state: Boolean. Whether to return the last state in addition to the output. Default: .\n• go_backwards: Boolean (default: ). If , process the input sequence backwards and return the reversed sequence.\n• stateful: Boolean (default: ). If , the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.\n• unroll: Boolean (default False). If , the network will be unrolled, else a symbolic loop will be used. Unrolling can speed-up a RNN, although it tends to be more memory-intensive. Unrolling is only suitable for short sequences.\n• use_cudnn: Whether to use a cuDNN-backed implementation. will attempt to use cuDNN when feasible, and will fallback to the default implementation if not.\n• mask: Binary tensor of shape indicating whether a given timestep should be masked (optional). An individual entry indicates that the corresponding timestep should be utilized, while a entry indicates that the corresponding timestep should be ignored. Defaults to .\n• training: Python boolean indicating whether the layer should behave in training mode or in inference mode. This argument is passed to the cell when calling it. This is only relevant if or is used (optional). Defaults to .\n• initial_state: List of initial state tensors to be passed to the first call of the cell (optional, causes creation of zero-filled initial state tensors). Defaults to ."
    },
    {
        "link": "https://keras.io/guides/sequential_model",
        "document": "Author: fchollet\n\n Date created: 2020/04/12\n\n Last modified: 2023/06/25\n\n Description: Complete guide to the Sequential model.\n\nWhen to use a Sequential model\n\nA model is appropriate for a plain stack of layers where each layer has exactly one input tensor and one output tensor.\n\nis equivalent to this function:\n\nA Sequential model is not appropriate when:\n• Your model has multiple inputs or multiple outputs\n• Any of your layers has multiple inputs or multiple outputs\n• You need to do layer sharing\n\nYou can create a Sequential model by passing a list of layers to the Sequential constructor:\n\nIts layers are accessible via the attribute:\n\nYou can also create a Sequential model incrementally via the method:\n\nNote that there's also a corresponding method to remove layers: a Sequential model behaves very much like a list of layers.\n\nAlso note that the Sequential constructor accepts a argument, just like any layer or model in Keras. This is useful to annotate TensorBoard graphs with semantically meaningful names.\n\nSpecifying the input shape in advance\n\nGenerally, all layers in Keras need to know the shape of their inputs in order to be able to create their weights. So when you create a layer like this, initially, it has no weights:\n\nIt creates its weights the first time it is called on an input, since the shape of the weights depends on the shape of the inputs:\n\nNaturally, this also applies to Sequential models. When you instantiate a Sequential model without an input shape, it isn't \"built\": it has no weights (and calling results in an error stating just this). The weights are created when the model first sees some input data:\n\nOnce a model is \"built\", you can call its method to display its contents:\n\nHowever, it can be very useful when building a Sequential model incrementally to be able to display the summary of the model so far, including the current output shape. In this case, you should start your model by passing an object to your model, so that it knows its input shape from the start:\n\nNote that the object is not displayed as part of , since it isn't a layer:\n\nModels built with a predefined input shape like this always have weights (even before seeing any data) and always have a defined output shape.\n\nIn general, it's a recommended best practice to always specify the input shape of a Sequential model in advance if you know what it is.\n\nWhen building a new Sequential architecture, it's useful to incrementally stack layers with and frequently print model summaries. For instance, this enables you to monitor how a stack of and layers is downsampling image feature maps:\n\nWhat to do once you have a model\n\nOnce your model architecture is ready, you will want to:\n• Train your model, evaluate it, and run inference. See our guide to training & evaluation with the built-in loops\n• Save your model to disk and restore it. See our guide to serialization & saving.\n\nOnce a Sequential model has been built, it behaves like a Functional API model. This means that every layer has an and attribute. These attributes can be used to do neat things, like quickly creating a model that extracts the outputs of all intermediate layers in a Sequential model:\n\nHere's a similar example that only extract features from one layer:\n\nTransfer learning consists of freezing the bottom layers in a model and only training the top layers. If you aren't familiar with it, make sure to read our guide to transfer learning.\n\nHere are two common transfer learning blueprint involving Sequential models.\n\nFirst, let's say that you have a Sequential model, and you want to freeze all layers except the last one. In this case, you would simply iterate over and set on each layer, except the last one. Like this:\n\nAnother common blueprint is to use a Sequential model to stack a pre-trained model and some freshly initialized classification layers. Like this:\n\nIf you do transfer learning, you will probably find yourself frequently using these two patterns.\n\nThat's about all you need to know about Sequential models!\n\nTo find out more about building models in Keras, see:\n• Guide to making new Layers & Models via subclassing"
    },
    {
        "link": "https://tensorflow.org/api_docs/python/tf/keras/layers/LSTM",
        "document": "Used in the notebooks\n\nBased on available runtime hardware and constraints, this layer will choose different implementations (cuDNN-based or backend-native) to maximize the performance. If a GPU is available and all the arguments to the layer meet the requirement of the cuDNN kernel (see below for details), the layer will use a fast cuDNN implementation when using the TensorFlow backend. The requirements to use the cuDNN implementation are:\n• Inputs, if use masking, are strictly right-padded.\n• Eager execution is enabled in the outermost context.\n\nThis method is the reverse of , capable of instantiating the same layer from the config dictionary. It does not handle layer connectivity (handled by Network), nor weights (handled by )."
    },
    {
        "link": "https://faroit.com/keras-docs/1.0.1/getting-started/sequential-model-guide",
        "document": "Getting started with the Keras Sequential model\n\nThe model is a linear stack of layers.\n\nYou can create a model by passing a list of layer instances to the constructor:\n\nYou can also simply add layers via the method:\n\nThe model needs to know what input shape it should expect. For this reason, the first layer in a model (and only the first, because following layers can do automatic shape inference) needs to receive information about its input shape. There are several possible ways to do this:\n• pass an argument to the first layer. This is a shape tuple (a tuple of integers or entries, where indicates that any positive integer may be expected). In , the batch dimension is not included.\n• pass instead a argument, where the batch dimension is included. This is useful for specifying a fixed batch size (e.g. with stateful RNNs).\n• some 2D layers, such as , support the specification of their input shape via the argument , and some 3D temporal layers support the arguments and .\n\nAs such, the following three snippets are strictly equivalent:\n\nAnd so are the following three snippets:\n\nMultiple instances can be merged into a single output via a layer. The output is a layer that can be added as first layer in a new model. For instance, here's a model with two separate input branches getting merged:\n• : tensor concatenation. You can specify the concatenation axis via the argument .\n• : dot product. You can specify which axes to reduce along via the argument .\n\nYou can also pass a function as the argument, allowing for arbitrary transformations:\n\nNow you know enough to be able to define almost any model with Keras. For complex models that cannot be expressed via and , you can use the functional API.\n\nBefore training a model, you need to configure the learning process, which is done via the method. It receives three arguments:\n• an optimizer. This could be the string identifier of an existing optimizer (such as or ), or an instance of the class. See: optimizers.\n• a loss function. This is the objective that the model will try to minimize. If can be the string identifier of an existing loss function (such as or ), or it can be an objective function. See: objectives.\n• a list of metrics. For any classification problem you will want to set this to . A metric could be the string identifier of an existing metric (only is supported at this point), or a custom metric function.\n\nKeras models are trained on Numpy arrays of input data and labels. For training a model, you will typically use the function. Read its documentation here.\n\nHere are a few examples to get you started!\n\nIn the examples folder, you will also find example models for real datasets:\n\nArchitecture for learning image captions with a convnet and a Gated Recurrent Unit:\n\nNote that getting this to work well will require using a bigger convnet, initialized with pre-trained weights.\n\nIn this model, we stack 3 LSTM layers on top of each other, making the model capable of learning higher-level temporal representations.\n\nThe first two LSTMs return their full output sequences, but the last one only returns the last step in its output sequence, thus dropping the temporal dimension (i.e. converting the input sequence into a single vector).\n\nA stateful recurrent model is one for which the internal states (memories) obtained after processing a batch of samples are reused as initial states for the samples of the next batch. This allows to process longer sequences while keeping computational complexity manageable.\n\nYou can read more about stateful RNNs in the FAQ.\n\nTwo merged LSTM encoders for classification over two parallel sequences\n\nIn this model, two input sequences are encoded into vectors by two separate LSTM modules.\n\nThese two vectors are then concatenated, and a fully connected network is trained on top of the concatenated representations."
    },
    {
        "link": "https://tensorflow.org/guide/keras/sequential_model",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nWhen to use a Sequential model\n\nA model is appropriate for a plain stack of layers where each layer has exactly one input tensor and one output tensor.\n\nis equivalent to this function:\n\nA Sequential model is not appropriate when:\n• Your model has multiple inputs or multiple outputs\n• Any of your layers has multiple inputs or multiple outputs\n• You need to do layer sharing\n\nYou can create a Sequential model by passing a list of layers to the Sequential constructor:\n\nIts layers are accessible via the attribute:\n\nYou can also create a Sequential model incrementally via the method:\n\nNote that there's also a corresponding method to remove layers: a Sequential model behaves very much like a list of layers.\n\nAlso note that the Sequential constructor accepts a argument, just like any layer or model in Keras. This is useful to annotate TensorBoard graphs with semantically meaningful names.\n\nSpecifying the input shape in advance\n\nGenerally, all layers in Keras need to know the shape of their inputs in order to be able to create their weights. So when you create a layer like this, initially, it has no weights:\n\nIt creates its weights the first time it is called on an input, since the shape of the weights depends on the shape of the inputs:\n\nNaturally, this also applies to Sequential models. When you instantiate a Sequential model without an input shape, it isn't \"built\": it has no weights (and calling results in an error stating just this). The weights are created when the model first sees some input data:\n\nOnce a model is \"built\", you can call its method to display its contents:\n\nHowever, it can be very useful when building a Sequential model incrementally to be able to display the summary of the model so far, including the current output shape. In this case, you should start your model by passing an object to your model, so that it knows its input shape from the start:\n\nNote that the object is not displayed as part of , since it isn't a layer:\n\nA simple alternative is to just pass an argument to your first layer:\n\nModels built with a predefined input shape like this always have weights (even before seeing any data) and always have a defined output shape.\n\nIn general, it's a recommended best practice to always specify the input shape of a Sequential model in advance if you know what it is.\n\nWhen building a new Sequential architecture, it's useful to incrementally stack layers with and frequently print model summaries. For instance, this enables you to monitor how a stack of and layers is downsampling image feature maps:\n\nWhat to do once you have a model\n\nOnce your model architecture is ready, you will want to:\n• Train your model, evaluate it, and run inference. See our guide to training & evaluation with the built-in loops\n• Save your model to disk and restore it. See our guide to serialization & saving.\n• Speed up model training by leveraging multiple GPUs. See our guide to multi-GPU and distributed training.\n\nOnce a Sequential model has been built, it behaves like a Functional API model. This means that every layer has an and attribute. These attributes can be used to do neat things, like quickly creating a model that extracts the outputs of all intermediate layers in a Sequential model:\n\nHere's a similar example that only extract features from one layer:\n\nTransfer learning consists of freezing the bottom layers in a model and only training the top layers. If you aren't familiar with it, make sure to read our guide to transfer learning.\n\nHere are two common transfer learning blueprint involving Sequential models.\n\nFirst, let's say that you have a Sequential model, and you want to freeze all layers except the last one. In this case, you would simply iterate over and set on each layer, except the last one. Like this:\n\nAnother common blueprint is to use a Sequential model to stack a pre-trained model and some freshly initialized classification layers. Like this:\n\nIf you do transfer learning, you will probably find yourself frequently using these two patterns.\n\nThat's about all you need to know about Sequential models!\n\nTo find out more about building models in Keras, see:\n• Guide to making new Layers & Models via subclassing"
    },
    {
        "link": "https://pypi.org/project/yfinance",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://algotrading101.com/learn/yfinance-guide",
        "document": "\n• Why should I use the yfinance library?\n• Why shouldn’t I use the yfinance library?\n• What are some of the alternatives to the yfinance library?\n• How do I get started with the yfinance library?\n• How do I download historical data using the yfinance library?\n• How do I download fundamental data using the yfinance library?\n• Fundamentals data with multiple tickers at once\n• How do I download trading data using the yfinance library?\n• How do I download options data using the yfinance library?\n• How do I get Expiration dates?\n• How do I get Calls Data?\n• How do I get Puts Data?\n\nyfinance is a popular open source library developed by Ran Aroussi as a means to access the financial data available on Yahoo Finance.\n\nYahoo Finance offers an excellent range of market data on stocks, bonds, currencies and cryptocurrencies. It also offers market news, reports and analysis and additionally options and fundamentals data- setting it apart from some of it’s competitors.\n\nYahoo Finance used to have their own official API, but this was decommissioned on May 15th 2017, following wide-spread misuse of data.\n\nThese days a range of unofficial APIs and libraries exist to access the same data, including of course yfinance.\n\nNote you might know of yfinance under it’s old name- fix-yahoo-finance, since it was re-named on May 26th 2019 at the same time that it went over a large overhaul to fix some usability issues.\n\nTo ensure backwards compatibility, fix-yahoo-finance now imports and uses yfinance anyway, but Ran Aroussi still recommends to install and use yfinance directly.\n\nIn this article we will focus mainly on the yfinance library, but we discuss the overall range of options and other alternative providers in more depth in our parent article, Yahoo Finance API – A Complete Guide.\n\nYes, yfinance is completely open source and free. You can find the documentation here.\n\nWhy should I use the yfinance library?\n• Quick and easy to set yourself up\n\nAs we have just mentioned yfinance is completely open source and free. There are other ways to access the Yahoo Finance data, some free and some paid, and there are certain benefits to some of the options that require paying, like being ensured a degree of maintenance to the solution, but everybody loves free!\n\nInstallation couldn’t be quicker or easier. yfinance has just 4 dependencies, all of which come with Anaconda anyway, and installs fully in a single line of code. No account creation required, or signing up for and using API keys!\n\nIts simple. yfinance is highly Pythonic in it’s design and incredibly streamlined. It’s as easy as creating a ticker object for a particular ticker/list of tickers and then just calling all the methods on this object. Like this:\n\nDon’t worry, we’ll break down that code further in a bit!\n\nFurthermore, the documentation is concise- fitting on a single page, and the method names are very self explanatory.\n\nHigh granularity of data. One cool feature of yfinance is that you can get highly refined data, all the way down to 5 minute, 3 minute and even 1 minute data! The full range of intervals available are:\n\nHowever it is important to note that the 1m data is only retrievable for the last 7 days, and anything intraday (interval <1d) only for the last 60 days.\n\nyfinance also handily returns data directly in padas dataframes or series. This is on contrast to some other options to access Yahoo Finance’s data where you will get lengthy JSONs you need parse for the specific information you want, and will have to manually convert to data-frames yourself.\n\nWhy shouldn’t I use the yfinance library?\n• Can get yourself rate limited/blacklisted\n\nLacks specialised features. Despite the fact you can use it to get a good range of core data, including options and fundamentals data, yfinance doesn’t provide a method to scrape any of the news reports/analysis that are available on Yahoo Finance.\n\nThis obviously isn’t ideal if you want to build model that relies in part on sentiment analysis, so if you want that sort of data, you might want to check out RapidAPI (which will talk about more shortly) that does offer such data.\n\nAlso, other market data alternatives often include interesting extras. For example Alpha Vantage provides modules that calculate various technical analysis indicators for you- obviously an enormous effort save if you want to build an algorithm utilising any of them! yfinance just provides the basics.\n\nSome methods are fragile. yfinance mainly makes API calls to Yahoo Finance to gather it’s data, but it does occasionally employ HTML scraping and pandas tables scraping to unofficially gather the information off the Yahoo Finance website for some of it’s methods. As such, the functionality of some of it’s methods is at the mercy of Yahoo not changing the layout or design of some of their pages. In fact, yfinance is widely known to already have a few issues.\n\nAs a quick aside, data scraping works by simply downloading the HTML code of a web page, and searching through all the HTML tags to find the specific elements of a page you want.\n\nFor instance below is the Yahoo Finance Apple (‘AAPL’) historical data page:\n\nIf the method to get the historical data HTML scraped, it would be searching the various div, class and tr tags etc. for various IDs to pick out the data that should be returned.\n\nFor instance the class ID “Py(10px) Pstart(10px)” refers to the historical prices populating the table. If in this case Yahoo Finance was to change the class ID pointing to this value, the method might return completely incorrect data, or even nothing at all. Again, this sort of vulnerability doesn’t apply to all of yfinance’s methods- most of them do in fact make direct API calls- but it does affect a few.\n\nIt’s an unofficial solution. Again, because yfinance is simply the result of one man’s hard work and not in any way affiliated with Yahoo Finance, there’s no guarantee if it breaks it will be maintained.\n\nAs we already mentioned it did have a big update to fix issues on May 26th 2019 on the same day it was renamed, but that’s no guarantee problems will be fixed in the future. Are you sure you want to build a trading algorithm on-top of data that might one day suddenly and without warning be wrong? There are already a few known issues with yfinance, which we will highlight later on in this article.\n\nYou can get yourself rate limited/blacklisted. Again because yfinance scrapes data for a few of it’s functions, you sometimes run the risk of getting rate limited or blacklisted for too many scraping attempts.\n\nThis is a risk that’s always present when trying to scrape websites, but when you’re building applications trading real money on-top of infrastructure that might be making a lot of data requests, the risk:reward changes.\n\nOverall yfinance an incredibly beginner friendly option. You’ll be able to dive right in and test out ideas without wasting time puzzling over complex documentation whilst still having access to a good range of data!\n\nThat said, the risk of getting faulty data or being blocked from getting any data at all when employing algorithms trading real money is absolutely unacceptable.\n\nWe think yfinance is great for prototyping, or if you are beginner, or just want to download a bunch of historic data.\n\nBut if you want complete confidence that a serious trading system is going to function with total reliability, we’d absolutely recommend going with a official and alternative market data provider- preferably one claiming to provide low latency data directly from exchanges.\n\nWhat are some of the alternatives to the yfinance library?\n\nOf the two alternatives to yfinance we will consider, RapidAPI is the most distinct.\n\nFirstly, whilst it does still have a limited usage free tier, you will have to pay for anything over 500 requests per month:\n\nSecondly, its not quite as simple as yfinance to get started with. You will have to sign up for an account to get your own access API keys.\n\nThat said, a big plus of RapidAPI is that you can use it with 15 different languages, if for some reason Python isn’t your thing:\n\nIt also offers more range of data than our other options, specifically the option to download market news and analysis which is fantastically useful if you want to add a degree of sentiment analysis in your model!\n\nMaking snap trading decisions based on machine scanning of news far faster than a human ever could can be one way (if slightly uncertain) to gain a trading edge.\n\nThat said RapidAPI does have a few drawbacks.\n\nAs you can see requests have an average latency of 1660ms which isn’t terrible, but alternative data providers such as polygon.io offer anything from 200ms down to 1ms delays- quite the difference.\n\nMore concerning is the fact requests only have a 98% success rate. Having 1 in 50 data requests fail could be a big deal if you have a system trading real money, especially if you are making a lower frequency of calls. Definitely something to consider.\n\nResults returned can also be in quite lengthy and nested JSONs, making the data a bit trickier to get ready for use than when using yfinance:\n\nThat said a further plus of RapidAPI is that it offers a huge range of APIs for other purposes, so familiarising yourself with how to use the their API for Yahoo Finance data might carry over into easily using another of their APIs for a different project in the future.\n\nIn summary, RapidAPI offers a very limited free tier, but perhaps by using a solution where some people are paying, it is more likely that any scraping issues from Yahoo Finance structure changes are resolved more quickly.\n\nIts also fiddlier to use and harder get started with, but does provide a bigger range of data than our other two options.\n\nyahoo_fin is an open source and free library similar to yfinance.\n\nYou can find the documentation here.\n\nIt offers a similar range of data to yfinance, but notably has a few functions that generate all the tickers for certain markets for you:\n\nwhich is a useful feature yfinance lacks.\n\nWe actually focus on the yahoo_fin library in the example sections of our parent article, Yahoo Finance API – A Complete Guide, so we won’t talk about it anymore here.\n\nHow do I get started with the yfinance library?\n\nGetting started with the yfinance library is super easy.\n\nIt has the following dependencies:\n\nThese all come as standard in an installation with Anaconda, but are really easy to install manually if for some reason you don’t have them.\n\nAfter that its as easy as:\n\nThe layout itself is also really simple, there are just three modules:\n\nAlmost all the methods are in the Tickers module.\n\nThe download module is for rapidly downloading the historical data of multiple tickers at once.\n\nAnd pandas_datareader is for back compatibility with legacy code, which we will ignore as irrelevant since if you’re reading this you are probably a new user of the library!\n\nHow do I download historical data using the yfinance library?\n\nFirstly, lets import yfinance as yf and create ourselves a ticker object for a particular ticker (stock):\n\nRemember we now use this aapl ticker object for almost everything- calling various methods on it.\n\nTo get the historical data we want to use the history() method, which is the most “complicated” method in the yfinance library.\n\nIt takes the following parameters as input:\n• period: data period to download (either use period parameter or use start and end) Valid periods are:\n• interval: data interval (1m data is only for available for last 7 days, and data interval <1d for the last 60 days) Valid intervals are:\n• start: If not using period – in the format (yyyy-mm-dd) or datetime.\n• end: If not using period – in the format (yyyy-mm-dd) or datetime.\n• prepost: Include Pre and Post regular market data in results? (Default is )- no need usually to change this from False\n• auto_adjust: Adjust all OHLC (Open/High/Low/Close prices) automatically? (Default is )- just leave this always as true and don’t worry about it\n\nThat might look a little complex but mainly you will just be changing the period (or start and end) and interval parameters.\n\nSo as an example, to get 1minute historical data for Apple between 02/06/2020 and 07/06/2020 (British format) we just use the ticker object we created and run:\n\nIt’s as simple as that!\n\nTo download the historical data for multiple tickers at once you can use the download module.\n\nIt takes mostly the same arguments as the history() method on a ticker object, but additionally:\n• group_by: group by column or ticker (‘column’/’ticker’, default is ‘column’)\n• proxy: proxy URL if you want to use a proxy server for downloading the data (optional, default is None)\n\nFor example to get the data for Amazon, Apple and Google all at once we can run:\n\nNote that the default with no interval specified is daily data.\n\nThen, if we want to group by ticker instead of Open/High/Low/Close we can do:\n\nHow do I download fundamental data using the yfinance library?\n\nYou can get the price to earnings ratio with the Ticker.info() method.\n\nTicker.info() returns a dictionary with a wide range of information about a ticker, including such things as a summary description, employee count, marketcap, volume, P/E ratios, dividends etc.- we recommend taking a look at it yourself as it takes a lot of space to show, but in short if you can’t find the information you’re looking for with the other methods, try the info() method!\n\nTo get specifically the price to earnings ratio search the dictionary for ‘forwardPE’:\n\nYou can get the yearly dividend % also by using info():\n\nAnd if you want a breakdown of each dividend payout as it occurred and on what date, you can use Ticker.dividends():\n\nFundamentals data with multiple tickers at once\n\nWe might also want to grab fundamentals (or other) data for a bunch of tickers at once.\n\nLets have a go at doing that and then try comparing our tickers by a particular attribute!\n\nTo do this we can start by creating a list of the tickers we want to get data for, and an empty dictionary to store all the data.\n\nWe will need to use the pandas library to manipulate the data frames:\n\nWe then loop through the list of the tickers, in each case adding to our dictionary a key, value pair where the key is the ticker and the value the dataframe returned by the info() method for that ticker:\n\nWe then combine this dictionary of dataframes into a single dataframe:\n\nAnd then delete the unnecessary “level_1” column and clean up the column names:\n\nGreat, so we now know how to get any data we want for multiple tickers at once into the same dataframe!\n\nBut how do we easily compare by a particular attribute?\n\nIt’s quite easy actually, lets try for one of the attributes in info()– the fullTimeEmployees count:\n\nSo now we have a dataframe of just the employee counts- one entry per ticker- and we can now order by the ‘Recent’ column:\n\nBoom! Obviously not that required with only 5 tickers in our list, but a fantastically easy and powerful way to quickly compare by a particular attribute if we had the ticker list of an entire market!\n\nYou can easily use this exact same method to compare any attribute you want!\n\nHow do I download trading data using the yfinance library?\n\nYou can find the data for all three of Market Cap, Volume and Highs and Lows from the info() method.\n\nTo get the market cap, use:\n\nTo find the current volume do:\n\nIf you want the average volume over the last 24 hours do:\n\nAnd finally if you want the average volume over the last 10 days:\n\nRemember, you can find the highs and lows for any time interval:\n\nwithin a desired period by using the history() method and adjusting the interval.\n\nFor example, to get the weekly highs and lows for all the historical data that exists, use:\n\nJust filter the dataframe with:\n\nAnd so forth to get the individual columns.\n\nAlternatively, you can use info() to get the following useful high/low information:\n\nHow do I download options data using the yfinance library?\n\nBriefly, options are contracts giving a trader the right, but not the obligation, to buy (call) or sell (put) the underlying asset they represent at a specific price on or before a certain date.\n\nTo download options data we can use the option_chain() method. It takes the parameter as input:\n• date: (YYYY-MM-DD), expiry date. If None return all options data.\n\nAnd has the opt.calls and opt.puts methods.\n\nTo get the various expiry dates for options for a particular ticker it’s as easy as:\n\nHow do I get Calls Data?\n\nTo get the calls data, we can do:\n\nHow do I get Puts Data?\n\nTo get puts data, we do:\n\nFinally, opts by itself returns a ticker object containing both the calls and puts data together, if that’s useful to you!\n\nAs we highlighted near the beginning of this article, yfinance is an unofficial scraping solution to gather data from Yahoo Finance, so is subject to breaking if Yahoo Finance changes any of its layout.\n\nUnfortunately this already seems to have happened in part, with the following problems discovered when writing this guide:\n• Tickers, the multiple tickers object for interacting with multiple tickers at once, doesn’t seem to work. We have provided a more manual workaround for this in the Fundamentals data with multiple tickers at once section.\n• The financials, quarterly_financials, balance_sheet, quarterly_balance_sheet, cashflow, quarterly_cashflow, earnings, quarterly_earnings Ticker methods do not work and return empty dataframes.\n\nThis is a big problem as in many cases there is no alternative way to the data in some of these methods from other methods in yfinance.\n\nIf you are building something that requires any of this data, for example balance sheets and income and cashflow statements and still want free access to the Yahoo Finance data, check out the yahoo_fin library in the examples section of our guide https://algotrading101.com/learn/yahoo-finance-api/ which has working methods to get all of this data!\n\nSo clearly as we have just demonstrated, yfinance is NOT a safe bet to build critical infrastructure on.\n\nIf you want to build algorithms trading real money, we absolutely recommend you use an official data source/API, preferably one connected directly to exchange data and with low latency. Something like Polygon.io or IEX might suit you better.\n\nIf you absolutely HAVE to use the Yahoo Finance data specifically, we recommend at least paying for an unofficial API like RapidAPI, where you stand a good bet there is an active team of developers constantly maintaining the API. Remember RapidAPI does still have a limited usage free tier!\n\nThat said, yfinance can be good to use to build test applications as a beginner, as the sections of it that do work are fantastically easy to get started with and use.\n\nA particular forte of yfinance is that the threads parameter of yf.download does allow very rapid downloading of historical for multiple tickers when set to True!\n\nYou can find the code used in this article here."
    },
    {
        "link": "https://github.com/ranaroussi/yfinance",
        "document": "yfinance offers a Pythonic way to fetch financial & market data from Yahoo!Ⓡ finance.\n\nYahoo!, Y!Finance, and Yahoo! finance are registered trademarks of Yahoo, Inc. yfinance is not affiliated, endorsed, or vetted by Yahoo, Inc. It's an open-source tool that uses Yahoo's publicly available APIs, and is intended for research and educational purposes. You should refer to Yahoo!'s terms of use (here, here, and here) **for details on your rights to use the actual data downloaded. Remember - the Yahoo! finance API is intended for personal use only.**\n\nThe list of changes can be found in the Changelog\n\nrelies on the community to investigate bugs, review code, and contribute code. Developer guide: #1084\n\nyfinance is distributed under the Apache Software License. See the LICENSE.txt file in the release for details.\n\nAGAIN - yfinance is not affiliated, endorsed, or vetted by Yahoo, Inc. It's an open-source tool that uses Yahoo's publicly available APIs, and is intended for research and educational purposes. You should refer to Yahoo!'s terms of use (here, here, and here) for details on your rights to use the actual data downloaded.\n\nPlease drop me a note with any feedback you have."
    },
    {
        "link": "https://rowzero.io/blog/yfinance",
        "document": "yfinance is a popular open source Python library that provides free access to financial data on Yahoo Finance. The yfinance package allows users to write simple Python commands and pull a wide range of financial data, like stock ticker data, options, fundamental financials, and much more, into a notebook, spreadsheet, or development environment. In the following tutorial, we show you how to use the most common yfinance Python commands to pull financial data into to a spreadsheet where you can analyze, chart, and track stock tickers, ETFs, crypto, bonds, options, etc. You can access your own personal yfinance template with a few pre-built functions in our yfinance spreadsheet template.\n\nContinue reading for full instructions or jump to any of the following sections.\n\nUsing the yfinance api in a spreadsheet makes it easy to execute commands and further analyze financial data with simple spreadsheet formulas. Unlike Jupyter notebooks or a code editor, you do not need to worry about running a Python environment. Row Zero, a powerful online spreadsheet, takes care of all the complexity. To start, open the free yfinance template spreadsheet which includes each of the yfinance examples below. Next, open the Row Zero Python code window using the right side menu. If building from scratch, you'll need to first import the the yfinance library with the command import yfinance as yf and execute the code window by pressing shift + enter or clicking the 'run' button. In the template, the code is already written for you but you should still run the code window.\n\nThe first and most basic thing to do with yfinance is import historical ticker data for a specific stock ticker. For example, if we wanted to know Tesla's stock price since the IPO, the functions below let us pull that data into the spreadsheet. The same can be done for any other stock ticker, ETF, Bitcoin, or anything with a yf ticker. Using this function will pull in the date, opening price, high, low, closing price, volume of shares traded, dividends, and stock splits for every day of trading. In the example of Tesla, the data goes all the way back to the IPO on June 29, 2010 when shares began trading at $1.267.\n\nTo start, define a python function that accepts a ticker symbol argument and returns the stock's price history. The yf.Ticker function is used in this example and is one of the most popular yfinance functions. Run the code with shift + enter. There are a number of additional arguments that can be used with the yfinance command. Review the appendix at the end of this post for more details.\n\nNow use that function in the spreadsheet by typing the function with a ticker in any cell and hitting enter.\n\nYou can also type a ticker in a cell and reference the cell in the formula.\n\nThe following data table will be returned using both methods, which shows Tesla's daily stock price since IPO.\n\nYou can easily graph it and look at the trend over time.\n\nyfinance supports various arguments that allow users to specify certain time periods that are applicable to the analysis or dataset they are trying to build. These arguments can be added to functions to modify the amount or range of data returned. Below we review modifying the timeframe for the yf ticker command and use Row Zero's column modification feature to reduce the number of viewable columns. In the Tesla example, if we only wanted to see the ticker data for the past 100 days or 1 year, we could use additional arguments to specify the time period with yfinance.\n\nUpdate the python command and specify a different to import the last X days of data.\n\nAnother easy option is to use Row Zero's filters by clicking on the drop down at the top of a column and entering a filter by date.\n\nOnce the data has been imported to Row Zero, right click and select 'manage columns' to remove columns of data that aren't needed.\n\nNow that we know how to import data for one ticker, the function can be applied to multiple tickers. To import data for multiple yf tickers, use the command in yfinance. The parameters for can be found at the end of this post.\n\nUse the following command to write a function that imports the closing price for a number of stock tickers. In this yfinance example, it is important to set the parameter to either or based on the desired structure of the data table.\n\nget_stock_prices can be used in Row Zero to reference cells with tickers of interest. See the images below for an example.\n\nAfter hitting enter, the function will return the following data table:\n\nRow Zero makes it easy to quickly chart stock data. Rather than having to use complicated code based graphing libraries, simply point and click to graph your data. Row Zero graphs auto update as source data updates. As an example, select the date and close columns from the data table and then click the graph button.\n\nYour graph will appear and can be customized by double clicking on it.\n\nStock fundamentals refer to the core financial data and performance metrics of a company. Investors use fundamental data to analyze a company's financial health and intrinsic value. Fundamentals include revenue, earnings, profit margins, and growth rates, as well as more complex metrics like price-to-earnings (P/E) ratio, return on equity, and debt-to-equity ratio. In the case of Tesla, fundamentals might show revenue growth, which has been significant due to rising sales of electric vehicles, or its P/E ratio, which reflects investors' high expectations for future growth. An investor would also consider Tesla's operational efficiency, market share in the electric vehicle industry, and its ability to innovate and sustain profitability in a competitive market. The instructions below show how to use yfinance to pull fundamental data for one ticker or multiple yf tickers.\n\nYfinance makes it easy to gather fundamental data for various companies using Using the Python function below, pass in a ticker and the function will pull the fundamental data into the spreadsheet.\n\nIt may be more helpful to pull fundamental data for multiple companies at once. Do to so, use the function which expects multiple tickers and will return results for all tickers in the selected range. The python code for this function can be found in the Appendix\n\nyfinance also provides options data for a given ticker symbol with another set of commands. Options data refers to details of options contracts in financial markets. These contracts give the holder the right, but not the obligation, to buy or sell an underlying asset, like a stock, at a predetermined price within a specific timeframe. Key options data include the strike price, expiration date, premiums, and whether the option is a 'call' (betting the asset price will rise) or 'put' (betting the price will fall). Options data can also include the trading volume and open interest for specific contracts, which help investors gauge market sentiment and potential price movements of the underlying asset. The following instructions show how to pull options data from the open source yfinance library.\n\nGet puts for one stock ticker\n\nIt is easy to get options data using and . Python code can be found in the Appendix.\n\nGet calls for one stock ticker\n\nThe function passes a ticker and returns the calls associated with the ticker. Python code can be found in the Appendix.\n\nInstitutional holders are entities like mutual funds, pension funds, insurance companies, investment firms, and other large organizations that invest in sizable quantities of shares. The yfinance API has a function that will provide information on the institutional holders of a specified stock ticker, making it easy to pull the data into Row Zero. Use to import this data. Python code can be found in the Appendix.\n\nThe yfinance python package supports any tickers on Yahoo Finance including crypto like Bitcoin and Ethereum, ETFs like QQQ, SPY, and SCHD, as well as bonds, and other financial instruments. If your investments are diversified across these tickers, you can build one common investment portfolio tracker spreadsheet to track crypto prices, stocks, ETFs, etc.\n\nyfinance is a great free tool for analyzing financial data but there are a few pros and cons to consider. Below we review the pros and cons of the open source yfinance Python package.\n• yfinance is free. There are a few other free financial data sources but they are less widely used. Paid data sources are very expensive (Bloomberg costs $24,000/year)\n• User-friendly. The open source package is easy to install and use. Pypi reports several hundred thousand installs each month.\n• Valuable data. yfinance exposes data for strategic investing decisions and lets you track stocks and ETFs or analyze your investment portfolio.\n• Dependencies. yfinance can break if Yahoo Finance ever changes the format of their site. If this were to happen, it is likely the yfinance library would be updated to remedy the situation but access to data may incur a short disruption.\n• Data frequency. The highest frequency data is minute level, which makes yfinance a less suitable option for real-time trading.\n• Reliability. Paid data sources typically offer higher fidelity data from more reliable access points, like terminals and APIs.\n• Python skills. While very accessible to many, the yfinance python package requires basic knowledge of Python. Hopefully, this yfinance tutorial makes it easier for beginners. Non-technical users can start with our yfinance template spreadsheet which has yfinance examples and pre-built code to start working with yfinance in a spreadsheet even if you don't know Python.\n\nYfinance is a great free resource for pulling and analyzing stock data. It's easy to pull stock prices, fundamentals, options data, and institutional holders among many other options. There are pros and cons. The pros center on its ease of use and its free price tag. The cons mainly center on reliability, data frequency, and a need to know basic Python. If your preference is to work with financial data in a spreadsheet, or you need help getting started with yfinance, use the yfinance spreadsheet template to pull ticker data straight into a spreadsheet and begin your analysis.\n\nThis section includes additional information about parameters for popular functions available in the yfinance python library. Reference these lists to expand upon the and functions provided above. There is also additional information and yfinance python documentation on the pypi yfinance page.\n\nThe following are all the parameters for the command in yfinance.\n\nThe following are all the parameters for the command in yfinance. Each parameter can be used to specify changes in the data returned from each function."
    },
    {
        "link": "https://ranaroussi.github.io/yfinance",
        "document": "Showing a small sample of yfinance API, the full API is much bigger and covered in API Reference."
    }
]