[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/getting-started?view=netframeworkdesktop-4.8",
        "document": "Windows Presentation Foundation (WPF) is a UI framework that creates desktop client applications. The WPF development platform supports a broad set of application development features, including an application model, resources, controls, graphics, layout, data binding, documents, and security. It is a subset of the .NET Framework, so if you have previously built applications with the .NET Framework using ASP.NET or Windows Forms, the programming experience should be familiar. WPF uses the Extensible Application Markup Language (XAML) to provide a declarative model for application programming. This section has topics that introduce and help you get started with WPF."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/framework",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/app-development?view=netframeworkdesktop-4.8",
        "document": "Windows Presentation Foundation (WPF) is a presentation framework that can be used to develop the following types of applications:\n• None Standalone Applications (traditional style Windows applications built as executable assemblies that are installed to and run from the client computer).\n• None XAML browser applications (XBAPs) (applications composed of navigation pages that are built as executable assemblies and hosted by Web browsers such as Microsoft Internet Explorer or Mozilla Firefox).\n\nTo build this set of applications, WPF implements a host of services. This topic provides an overview of these services and where to find more information.\n\nExecutable WPF applications commonly require a core set of functionality that includes the following:\n• None Creating and managing common application infrastructure (including creating an entry point method and a Windows message loop to receive system and input messages).\n• None Tracking and interacting with the lifetime of an application.\n• None Tracking navigation in XAML browser applications (XBAPs), and standalone applications with navigation windows and frames.\n\nThese capabilities are implemented by the Application class, which you add to your applications using an application definition.\n\nFor more information, see Application Management Overview.\n\nWPF extends the core support in the Microsoft .NET Framework for embedded resources with support for three kinds of non-executable data files: resource, content, and data. For more information, see WPF Application Resource, Content, and Data Files.\n\nA key component of the support for WPF non-executable data files is the ability to identify and load them using a unique URI. For more information, see Pack URIs in WPF.\n\nUsers interact with WPF standalone applications through windows. The purpose of a window is to host application content and expose application functionality that usually allows users to interact with the content. In WPF, windows are encapsulated by the Window class, which supports:\n• None Tracking and interacting with the lifetime of a window.\n\nFor more information, see WPF Windows Overview.\n\nWindow supports the ability to create a special type of window known as a dialog box. Both modal and modeless types of dialog boxes can be created.\n\nFor convenience, and the benefits of reusability and a consistent user experience across applications, WPF exposes three of the common Windows dialog boxes: OpenFileDialog, SaveFileDialog, and PrintDialog.\n\nA message box is a special type of dialog box for showing important textual information to users, and for asking simple Yes/No/OK/Cancel questions. You use the MessageBox class to create and show message boxes.\n\nFor more information, see Dialog Boxes Overview.\n\nWPF supports Web-style navigation using pages (Page) and hyperlinks (Hyperlink). Navigation can be implemented in a variety of ways that include the following:\n• None Standalone pages that are hosted in a Web browser.\n• None Pages compiled into an XBAP that is hosted in a Web browser.\n• None Pages compiled into a standalone application and hosted by a navigation window (NavigationWindow).\n• None Pages that are hosted by a frame (Frame), which may be hosted in a standalone page, or a page compiled into either an XBAP or a standalone application.\n\nTo facilitate navigation, WPF implements the following:\n• None NavigationService, the shared navigation engine for processing navigation requests that is used by Frame, NavigationWindow, and XBAPs to support intra-application navigation.\n• None Navigation events to track and interact with navigation lifetime.\n• None Remembering back and forward navigation using a journal, which can also be inspected and manipulated.\n\nWPF also supports a special type of navigation known as structured navigation. Structured navigation can be used to call one or more pages that return data in a structured and predictable way that is consistent with calling functions. This capability depends on the PageFunction<T> class, which is described further in Structured Navigation Overview. PageFunction<T> also serves to simplify the creation of complex navigation topologies, which are described in Navigation Topologies Overview.\n\nXBAPs can be hosted in Microsoft Internet Explorer or Firefox. Each hosting model has its own set of considerations and constraints that are covered in Hosting.\n\nAlthough simple WPF applications can be built from a command prompt using command-line compilers, WPF integrates with Visual Studio to provide additional support that simplified the development and build process. For more information, see Building a WPF Application.\n\nDepending on the type of application you build, there are one or more deployment options to choose from. For more information, see Deploying a WPF Application."
    },
    {
        "link": "https://textcontrol.com/blog/2022/09/01/getting-started-with-wpf-net-framework",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/70698885/how-can-i-use-net-framework-4-8-on-an-wpf-class-library",
        "document": "So I want to create an WPF Class Library but in the .NET Framework 4.8. But in the creating I only get this two Frameworks to choose:\n\nHow Can I get .NET Framework 4.8 in this to Choose? Because when I just use the normal Class Library, without the WPF in the name I can only add an UserControl. I cant choose in that something like Ressource dictionary for example"
    },
    {
        "link": "https://stackoverflow.com/questions/55108911/c-sharp-wpf-built-in-icommand-interface-and-the-command-design-patttern",
        "document": "I am new to WPF and c# in general. I was reading about the Command Design Pattern and was looking forward to implement it on my new application so that it could have do and undo functionality. Then i realized that WPF already comes with a ICommand Interface and that de xml buttons can implement it. Said interface have this methods:\n\nSo, should i add the undo funcionality to this already build in ICommand Interface by having some other interface inherit from it and add the undo method?\n\nis this interface ment only for buttons? I mean, i would like to create many other commands that are not necesarilly connected to a xnml button"
    },
    {
        "link": "https://stackoverflow.com/questions/61086722/how-correctly-implement-icommand-in-wpf-using-mvvm-pattern",
        "document": "I`m trying to do a simple WPF application using MVVM pattern. I wrote a class implementing ICommand interface:\n\nthen I use it, when I click on the button in the view, to show a new page, by assigning a page to the current page\n\nBut nothing happens. Please help me, did I miss something, or doing it in the wrong way?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/commanding-overview?view=netframeworkdesktop-4.8",
        "document": "Commanding is an input mechanism in Windows Presentation Foundation (WPF) which provides input handling at a more semantic level than device input. Examples of commands are the Copy, Cut, and Paste operations found on many applications.\n\nThis overview defines what commands are in WPF, which classes are part of the commanding model, and how to use and create commands in your applications.\n\nThis topic contains the following sections:\n\nCommands have several purposes. The first purpose is to separate the semantics and the object that invokes a command from the logic that executes the command. This allows for multiple and disparate sources to invoke the same command logic, and it allows the command logic to be customized for different targets. For example, the editing operations Copy, Cut, and Paste, which are found in many applications, can be invoked by using different user actions if they are implemented by using commands. An application might allow a user to cut selected objects or text by either clicking a button, choosing an item in a menu, or using a key combination, such as CTRL+X. By using commands, you can bind each type of user action to the same logic.\n\nAnother purpose of commands is to indicate whether an action is available. To continue the example of cutting an object or text, the action only makes sense when something is selected. If a user tries to cut an object or text without having anything selected, nothing would happen. To indicate this to the user, many applications disable buttons and menu items so that the user knows whether it is possible to perform an action. A command can indicate whether an action is possible by implementing the CanExecute method. A button can subscribe to the CanExecuteChanged event and be disabled if CanExecute returns or be enabled if CanExecute returns .\n\nThe semantics of a command can be consistent across applications and classes, but the logic of the action is specific to the particular object acted upon. The key combination CTRL+X invokes the Cut command in text classes, image classes, and Web browsers, but the actual logic for performing the Cut operation is defined by the application that performs the cut. A RoutedCommand enables clients to implement the logic. A text object may cut the selected text into the clipboard, while an image object may cut the selected image. When an application handles the Executed event, it has access to the target of the command and can take appropriate action depending on the target's type.\n\nThe simplest way to use a command in WPF is to use a predefined RoutedCommand from one of the command library classes; use a control that has native support for handling the command; and use a control that has native support for invoking a command. The Paste command is one of the predefined commands in the ApplicationCommands class. The TextBox control has built in logic for handling the Paste command. And the MenuItem class has native support for invoking commands.\n\nThe following example shows how to set up a MenuItem so that when it is clicked it will invoke the Paste command on a TextBox, assuming the TextBox has keyboard focus.\n\nThe routed command model in WPF can be broken up into four main concepts: the command, the command source, the command target, and the command binding:\n• None The command is the action to be executed.\n• None The command source is the object which invokes the command.\n• None The command target is the object that the command is being executed on.\n• None The command binding is the object which maps the command logic to the command.\n\nIn the previous example, the Paste command is the command, the MenuItem is the command source, the TextBox is the command target, and the command binding is supplied by the TextBox control. It is worth noting that it is not always the case that the CommandBinding is supplied by the control that is the command target class. Quite often the CommandBinding must be created by the application developer, or the CommandBinding might be attached to an ancestor of the command target.\n\nCommands in WPF are created by implementing the ICommand interface. ICommand exposes two methods, Execute, and CanExecute, and an event, CanExecuteChanged. Execute performs the actions that are associated with the command. CanExecute determines whether the command can execute on the current command target. CanExecuteChanged is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding. The WPF implementation of ICommand is the RoutedCommand class and is the focus of this overview.\n\nThe main sources of input in WPF are the mouse, the keyboard, ink, and routed commands. The more device-oriented inputs use a RoutedEvent to notify objects in an application page that an input event has occurred. A RoutedCommand is no different. The Execute and CanExecute methods of a RoutedCommand do not contain the application logic for the command, but rather they raise routed events that tunnel and bubble through the element tree until they encounter an object with a CommandBinding. The CommandBinding contains the handlers for these events and it is the handlers that perform the command. For more information on event routing in WPF, see Routed Events Overview.\n\nThe Execute method on a RoutedCommand raises the PreviewExecuted and the Executed events on the command target. The CanExecute method on a RoutedCommand raises the CanExecute and PreviewCanExecute events on the command target. These events tunnel and bubble through the element tree until they encounter an object which has a CommandBinding for that particular command.\n\nWPF supplies a set of common routed commands spread across several classes: MediaCommands, ApplicationCommands, NavigationCommands, ComponentCommands, and EditingCommands. These classes consist only of the RoutedCommand objects and not the implementation logic of the command. The implementation logic is the responsibility of the object on which the command is being executed on.\n\nA command source is the object which invokes the command. Examples of command sources are MenuItem, Button, and KeyGesture.\n• None Command is the command to execute when the command source is invoked.\n• None CommandTarget is the object on which to execute the command. It is worth noting that in WPF the CommandTarget property on ICommandSource is only applicable when the ICommand is a RoutedCommand. If the CommandTarget is set on an ICommandSource and the corresponding command is not a RoutedCommand, the command target is ignored. If the CommandTarget is not set, the element with keyboard focus will be the command target.\n• None CommandParameter is a user-defined data type used to pass information to the handlers implementing the command.\n\nThe WPF classes that implement ICommandSource are ButtonBase, MenuItem, Hyperlink, and InputBinding. ButtonBase, MenuItem, and Hyperlink invoke a command when they are clicked, and an InputBinding invokes a command when the InputGesture associated with it is performed.\n\nThe following example shows how to use a MenuItem in a ContextMenu as a command source for the Properties command.\n\nTypically, a command source will listen to the CanExecuteChanged event. This event informs the command source that the ability of the command to execute on the current command target may have changed. The command source can query the current status of the RoutedCommand by using the CanExecute method. The command source can then disable itself if the command cannot execute. An example of this is a MenuItem graying itself out when a command cannot execute.\n\nAn InputGesture can be used as a command source. Two types of input gestures in WPF are the KeyGesture and MouseGesture. You can think of a KeyGesture as a keyboard shortcut, such as CTRL+C. A KeyGesture is comprised of a Key and a set of ModifierKeys. A MouseGesture is comprised of a MouseAction and an optional set of ModifierKeys.\n\nIn order for an InputGesture to act as a command source, it must be associated with a command. There are a few ways to accomplish this. One way is to use an InputBinding.\n\nThe following example shows how to create a KeyBinding between a KeyGesture and a RoutedCommand.\n\nAnother way to associate an InputGesture to a RoutedCommand is to add the InputGesture to the InputGestureCollection on the RoutedCommand.\n\nThe following example shows how to add a KeyGesture to the InputGestureCollection of a RoutedCommand.\n\nA CommandBinding associates a command with the event handlers that implement the command.\n\nThe CommandBinding class contains a Command property, and PreviewExecuted, Executed, PreviewCanExecute, and CanExecute events.\n\nCommand is the command that the CommandBinding is being associated with. The event handlers which are attached to the PreviewExecuted and Executed events implement the command logic. The event handlers attached to the PreviewCanExecute and CanExecute events determine if the command can execute on the current command target.\n\nThe following example shows how to create a CommandBinding on the root Window of an application. The CommandBinding associates the Open command with Executed and CanExecute handlers.\n\nNext, the ExecutedRoutedEventHandler and a CanExecuteRoutedEventHandler are created. The ExecutedRoutedEventHandler opens a MessageBox that displays a string saying the command has been executed. The CanExecuteRoutedEventHandler sets the CanExecute property to .\n\nA CommandBinding is attached to a specific object, such as the root Window of the application or a control. The object that the CommandBinding is attached to defines the scope of the binding. For example, a CommandBinding attached to an ancestor of the command target can be reached by the Executed event, but a CommandBinding attached to a descendant of the command target cannot be reached. This is a direct consequence of the way a RoutedEvent tunnels and bubbles from the object that raises the event.\n\nIn some situations the CommandBinding is attached to the command target itself, such as with the TextBox class and the Cut, Copy, and Paste commands. Quite often though, it is more convenient to attach the CommandBinding to an ancestor of the command target, such as the main Window or the Application object, especially if the same CommandBinding can be used for multiple command targets. These are design decisions you will want to consider when you are creating your commanding infrastructure.\n\nThe command target is the element on which the command is executed. With regards to a RoutedCommand, the command target is the element at which routing of the Executed and CanExecute starts. As noted previously, in WPF the CommandTarget property on ICommandSource is only applicable when the ICommand is a RoutedCommand. If the CommandTarget is set on an ICommandSource and the corresponding command is not a RoutedCommand, the command target is ignored.\n\nThe command source can explicitly set the command target. If the command target is not defined, the element with keyboard focus will be used as the command target. One of the benefits of using the element with keyboard focus as the command target is that it allows the application developer to use the same command source to invoke a command on multiple targets without having to keep track of the command target. For example, if a MenuItem invokes the Paste command in an application that has a TextBox control and a PasswordBox control, the target can be either the TextBox or PasswordBox depending on which control has keyboard focus.\n\nThe following example shows how to explicitly set the command target in markup and in code behind.\n\nThe CommandManager serves a number of command related functions. It provides a set of static methods for adding and removing PreviewExecuted, Executed, PreviewCanExecute, and CanExecute event handlers to and from a specific element. It provides a means to register CommandBinding and InputBinding objects onto a specific class. The CommandManager also provides a means, through the RequerySuggested event, to notify a command when it should raise the CanExecuteChanged event.\n\nThe InvalidateRequerySuggested method forces the CommandManager to raise the RequerySuggested event. This is useful for conditions that should disable/enable a command but are not conditions that the CommandManager is aware of.\n\nWPF provides a set of predefined commands. The command library consists of the following classes: ApplicationCommands, NavigationCommands, MediaCommands, EditingCommands, and the ComponentCommands. These classes provide commands such as Cut, BrowseBack and BrowseForward, Play, Stop, and Pause.\n\nMany of these commands include a set of default input bindings. For example, if you specify that your application handles the copy command, you automatically get the keyboard binding \"CTRL+C\" You also get bindings for other input devices, such as Tablet PC pen gestures and speech information.\n\nWhen you reference commands in the various command libraries using XAML, you can usually omit the class name of the library class that exposes the static command property. Generally, the command names are unambiguous as strings, and the owning types exist to provide a logical grouping of commands but are not necessary for disambiguation. For instance, you can specify rather than the more verbose . This is a convenience mechanism that is built in to the WPF XAML processor for commands (more precisely, it is a type converter behavior of ICommand, which the WPF XAML processor references at load time).\n\nIf the commands in the command library classes do not meet your needs, then you can create your own commands. There are two ways to create a custom command. The first is to start from the ground up and implement the ICommand interface. The other way, and the more common approach, is to create a RoutedCommand or a RoutedUICommand.\n\nFor an example of creating a custom RoutedCommand, see Create a Custom RoutedCommand Sample.\n• How to: Add a Command to a MenuItem"
    },
    {
        "link": "https://codeproject.com/Articles/1052346/ICommand-Interface-in-WPF",
        "document": "In this article, we will learn about ICommand interface and its use in generic implementation of Command while working with MVVM Pattern in WPF/Silverlight applications.\n\nIn this article, we will learn about interface and its use in generic implementation of while working with MVVM (Model View ViewModel) Pattern in WPF/Silverlight applications. First, we will understand about and then look into members of interface. We will create a demo application in WPF to learn the use of . In the demo application, we will use MVVM Pattern also.\n\nNote: For this article, as a prerequisite, we must have basic understanding of WPF and MVVM pattern. If you are new to MVVM Pattern, please have a look at Wiki and MSDN Page.\n• How to Use ICommand Interface\n\nIn WPF context, is any class which implement interface. There is minute difference between Commands and Events. Events are defined and associated with UI Controls. But Commands are more abstract and focused on what to be done. One Command can be associated with multiple UI Controls/Options. For example, a Save Command we can be executed on Save Button Click, or by pressing Ctrl+S or by choosing Save option from Menu bar. To have interactions in application, we use either events or commands.\n\nIn WPF applications, we have two options to provide interactions in UI:\n• The first option is using events and write code in code-behind file which we want to execute on a particular event, if we are not following MVVM pattern. There are many inbuilt s available in WPF to use for this case.\n• The second option is write code block which we want to execute in and invoke that code using Command, if we are following MVVM pattern. If we are using MVVM Pattern, then generally we should not write code in code-behind files. So we cannot use RoutedEvents because RoutedEvents are not accessible in ViewModels. That is why we have to use Commands to execute desired code block written in ViewModel. Thus Commands provide glue between View and ViewModel for interactivity.\n\nis an interface which has three members as shown in the below table:\n\nis core interface in WPF for s. It is heavily used in MVVM and Prism based application. But use of interface is not just limited to MVVM. There are many inbulit s which already implements this interface provided by WPF/Silverlight/Prism framework. The base class implements interface. And WPF provides , , , , and which uses class. For more information, please have a look at the MSDN Page.\n\nTo make it easy to understand, let us create a demo application.\n\nThe demo application is doing very basic calculation, just to show interface implementation. Demo application is having two es to accept input value, one label to show output and four buttons to perform calculations. Four buttons are used to perform add, subtraction, multiply and divide operation. After entering values in es, then on a button click, the associated command will get fired and it shows result in the label. How we will achieve the above functionality, we will see in further steps. Please download the code sample attached as it will be helpful to understand and follow up explanations given further.\n\nThe final screenshot of the demo application is as shown below:\n\nNow fire up Visual Studio and to create demo application, please follow the steps given below:\n\nCreate a WPF application named as . Make project structure by adding folders and files same as shown below. In further steps, we will write code in those files.\n\nFirst, we will create a layout demo UI. To do that, we will create the grid with four rows and four columns. Controls will be placed in this grid by specifying rows and columns position. Write the same code as shown below in CalculatorView.xaml file.\n\nNow go to MainWindow.xaml file, add of CalculatorView.xaml file so that we can access CalculatorView.xaml in .\n\nNow we need to attach properties of two textboxes and label in CalculatorView.xaml to its called .\n\nAs we can see in XAML, we have bounded UI propertites with properties. 's property “ ” is bounded with \" \" property of first , 's property “ ” is bounded with \" \" property of second . And 's property “ ” is bounded with “ ” property of .\n\nTo do Binding with , create three fields called , and output and three properties with the same name what we have given for binding of text property of the es and . We must provide the same names to three properties as we have used while binding for property of es in UI.\n\nProperty “ ” is written as shown below, in a similar way, we have to create two more properties named as “ ” and “ ” in .\n\nHow to Use ICommand Interface\n\nTo bind Commands with UI Controls, we need to create a class which must implement interface.\n\nFirst, we would be creating a class for each button's functionality. Later, we will see how we can reuse a single generic class to handle those functionality. As of now, we will first create individual for \" \" functionality.\n\nWe have already created a “Plus” button on UI page. As we are following MVVM pattern, in this case to handle such kind of functionality, we need to implement interface. Let us do that by writing the below code in Class.\n\nNow create a field of class in and create an instance of class inside the constructor of .\n\nRegister namespace of to CalculatorView.xaml file. For that, the below line of code needs to be added in area.\n\nAfter namespaces, add tag to register by specifying the key \" \". Same key we have used while providing Binding to the grid.\n\nCreate a command named as “ ” name in . ’s name must be same as we have given for button's property binding in CalculatorView.xaml file. Code for is shown below:\n\nNow run the application, click on “Plus” button, constructor will be called because we have given reference of in CalculatorView.xaml file as . From the constructor of , we are creating the instance of . While creating instance of , we are passing itself using “ ” keyword.\n\nWhile execution of , first method will be called which will return \" \" as we have hardcoded it for simplicity. Then method will be called and it will invoke method of .\n\nPut the breakpoint to method and run the application, we will see values entered into textboxes are available in , variables. And calculated result will be assigned to property. But result is not visible on the screen in the content of . If we want to see the result on UI, we have to implement INotifyPropertyChanged Interface so that Change in \"Output\" property of ViewModel can be notified to UI.\n\nThe purpose of is to notify if any changes happen to a property to all of its references (UI Controls/ViewModel). Since by default, UI properties (i.e., property of ) mostly have implemented. Now we need to implement this interface for s too, so that if any change occurs in side, it can be notified/reflected to UI.\n\nAs we have seen in the above step, “ ” is the name of ’s property, which we have bound to the property of . When call comes to method, we assign calculated value to “ ” property. Since “ ” is a property and bound to UI, this way change will be reflected to . Now with the help of , ’s will be updated.\n\nSo let us implement interface in class. The code is as shown below:\n\nInherit from , add one line of code inside the set block of all three properties as shown below:\n\nis a method which takes property name as argument. We have implemented this method in class. Whenever any change will occur in properties either from UI or , method will be called. Since we have written in XAML code for first and second , whenever there will be any change either at UI side or side, another party (UI or ) will be notified.\n\nNow run the application, we would be able to perform operation and result will be visible in label. We need to follow the same steps for the rest of the button click commands to achieve three more calculations.\n\nAs of now, we need to create separate command classes for each operation. As we have done, for PlusCommand class, it has the following drawbacks:\n\nFirst: class is tightly coupled with because class is having the reference of .\n\nSecond: From method, we are calling method of . In future, if we change the name of method, then we have to modify ( method of) class also.\n\nThird: As we cannot reuse class for other operations, so for every event, we need to write many different individual command classes for each operation. In our case, on “Plus” button click, we are calling Add method. But for “Minus” button click, we need to call method, which we cannot do by using Class. That is why we have created four classes to handle each click event named as , , and , which is not a good approach.\n\nThat’s why we create a generic command class to handle all kind of operations. For that, we can use inbuilt delegates.\n\nThere are many inbuilt delegates like , and , etc. with .NET Framework. In our demo application, we will use delegate. For more information about , have a look here. Then we will see how to makes our work easy by increasing reusability.\n\nIn the above steps, we have created four command classes to handle four button click event. Now by using delegate, we will remove all of four command classes, by creating one generic command class called . We can give any name instead of . As a good practice, we should give some meaningful name. Write the below code in class:\n\nNow we need to change one line of code. Comment the first line and uncomment the second line of block of property as shown below:\n\nBefore returning from this block, the constructor of will be called which takes a method as an delegate. Here, we are passing name of method to delegate parameter.\n\nPut the breakpoint on constructor of and run the application. We will be able to see the name of method in local variable as shown below:\n\nNow all four operations can be handled just by using class. Now we can remove all of four command classes as we have created in folder \"Commands\\Specific\".\n\nIn this article, we had a walkthrough to learn Interface and its use. We understood how to use interface to create generic class as a standard practice of MVVM pattern. Thanks for reading. Your comments and suggestions for improvement are most welcome."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/how-to-implement-icommandsource?view=netframeworkdesktop-4.8",
        "document": "This example shows how to create a command source by implementing ICommandSource. A command source is an object that knows how to invoke a command. The ICommandSource interface exposes three members:\n• Command: the command that will be invoked.\n• CommandParameter: a user-defined data type which is passed from the command source to the method that handles the command.\n• CommandTarget: the object that the command is being executed on.\n\nIn this example, a class is created that inherits from the Slider control and implements the ICommandSource interface.\n\nWPF provides a number of classes which implement ICommandSource, such as Button, MenuItem, and Hyperlink. A command source defines how it invokes a command. These classes invoke a command when they're clicked and they only become a command source when their Command property is set.\n\nIn this example, you'll invoke the command when the slider is moved, or more accurately, when the Value property is changed.\n\nThe following is the class definition:\n\nThe next step is to implement the ICommandSource members. In this example, the properties are implemented as DependencyProperty objects. This enables the properties to use data binding. For more information about the DependencyProperty class, see the Dependency Properties Overview. For more information about data binding, see the Data Binding Overview.\n\nOnly the Command property is shown here.\n\nThe following is the DependencyProperty change callback:\n\nThe next step is to add and remove the command which is associated with the command source. The Command property cannot simply be overwritten when a new command is added, because the event handlers associated with the previous command, if there was one, must be removed first.\n\nThe next step is to create logic for the CanExecuteChanged handler.\n\nThe CanExecuteChanged event notifies the command source that the ability of the command to execute on the current command target may have changed. When a command source receives this event, it typically calls the CanExecute method on the command. If the command cannot execute on the current command target, the command source will typically disable itself. If the command can execute on the current command target, the command source will typically enable itself.\n\nThe last step is the Execute method. If the command is a RoutedCommand, the RoutedCommand Execute method is called; otherwise, the ICommand Execute method is called."
    },
    {
        "link": "https://reddit.com/r/learncsharp/comments/yztrmt/wpf_best_practice_for_setting_click_handlers",
        "document": "I am doing a couple of tutorials on WPF and they introduced two ways of adding click handlers. I'm curious what is the \"better\" way to do this.\n\nOne way was declaring it in the XAML: <Button x:Name=\"additionButton\" Click=\"OperationButton_Click\" Background=\"Orange\" Foreground=\"White\" Content=\"+\" Margin=\"5\" Grid.Row=\"4\" Grid.Column=\"3\"/>\n\nThe other way was declaring it in the cs code: acButton.Click += AcButton_Click;\n\nIs either considered a better way to handle it? For this tutorial they are using a mix of both. Sorry for the formatting, for some reason I can't get it to display as code."
    },
    {
        "link": "https://stackoverflow.com/questions/24011869/handling-a-buttons-click-event-in-xaml",
        "document": "This feels like a terribly basic question but I am sure there is a better way to do this. I have a in my UI which selects a specific tab and fire a from the\n\nHere is the current code (which works fine):\n\nIsn't there any cleaner, XAML-only way to do that UI operation? I was thinking about something like:\n\nBut unfortunately it seems like the won't support a event. Why so? I am still sometimes confused with triggers after a few years working in WPF, and this pretty much sums it up. When trying to build that I have an error on the line:\n\nEDIT since I was ask the XAML structure of my Window, it looks like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/70617317/what-event-should-be-used-to-handle-clicking-a-button-in-a-wpf-application-on",
        "document": "If you handle the and also set the attached property of the to , the event should be raised as soon as the finger touches the screen:\n\nBy default and as stated in the docs, the event doesn't occur until a finger touches the screen and moves."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/events",
        "document": "Events in .NET are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with and receive notifications from a provider. An event sender pushes a notification when an event occurs. An event receiver defines the response. This article describes the major components of the delegate model, how to consume events in applications, and how to implement events in your code.\n\nAn event is a message sent by an object to signal the occurrence of an action. The action might be user interaction, such as a button press, or it might result from other program logic, such as a property value change. The object that raises the event is called the event sender. The event sender doesn't know the object or method that receives (handles) the events it raises. The event is typically a member of the event sender. For example, the Click event is a member of the Button class, and the PropertyChanged event is a member of the class that implements the INotifyPropertyChanged interface.\n\nTo define an event, you use the C# event or the Visual Basic Event keyword in the signature of your event class, and specify the type of delegate for the event. Delegates are described in the next section.\n\nTypically, to raise an event, you add a method that is marked as and (in C#) or and (in Visual Basic). The naming convention for the method is , such as . The method should take one parameter that specifies an event data object, which is an object of type EventArgs or a derived type. You provide this method to enable derived classes to override the logic for raising the event. A derived class should always call the method of the base class to ensure registered delegates receive the event.\n\nThe following example shows how to declare an event named . The event is associated with the EventHandler delegate and raised in a method named :\n\nA delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references. It can hold references only to methods that match its signature. A delegate is equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class.\n\nDelegates have many uses in .NET. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration, as shown in the example in the previous section. For more information about delegates, see the Delegate class.\n\n.NET provides the EventHandler and EventHandler<TEventArgs> delegates to support most event scenarios. Use the EventHandler delegate for all events that don't include event data. Use the EventHandler<TEventArgs> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data).\n\nDelegates are multicast class objects, which means they can hold references to more than one event-handling method. For more information, see the Delegate reference page. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.\n\nUse the EventHandler and EventHandler<TEventArgs> delegate types to define the needed delegate. You mark a delegate with the type in [C#]](../../csharp/language-reference/builtin-types/reference-types.md#the-delegate-type) or the type in Visual Basic in the declaration. The following example shows how to declare a delegate named :\n\nData associated with an event can be provided through an event data class. .NET provides many event data classes that you can use in your applications. For example, the SerialDataReceivedEventArgs class is the event data class for the SerialPort.DataReceived event. .NET follows a naming pattern where all event data classes end with the suffix. You determine which event data class is associated with an event by looking at the delegate for the event. For example, the SerialDataReceivedEventHandler delegate includes the SerialDataReceivedEventArgs class as a parameter.\n\nThe EventArgs class is typically the base type for event data classes. You also use this class if an event doesn't have any data associated with it. When you create an event that notifies subscribers that something happened without any additional data, include the EventArgs class as the second parameter in the delegate. You can pass the EventArgs.Empty value when no data is provided. The EventHandler delegate includes the EventArgs class as a parameter.\n\nYou can create a class that derives from the EventArgs class to provide any members needed to pass data related to the event. Typically, you should use the same naming pattern as .NET and end your event data class name with the suffix.\n\nThe following example shows an event data class named that contains properties that are specific to the event being raised:\n\nTo respond to an event, you define an event handler method in the event receiver. This method must match the signature of the delegate for the event you're handling. In the event handler, you perform the actions that are required when the event is raised, such as collecting user input after the user presses a button. To receive notifications when the event occurs, your event handler method must subscribe to the event.\n\nThe following example shows an event handler method named that matches the signature for the EventHandler delegate. The method subscribes to the event:\n\n.NET allows subscribers to register for event notifications either statically or dynamically. Static event handlers are in effect for the entire life of the class whose events they handle. Dynamic event handlers are explicitly activated and deactivated during program execution, usually in response to some conditional program logic. You can use dynamic handlers when event notifications are needed only under certain conditions, or when run-time conditions determine the specific handler to call. The example in the previous section shows how to dynamically add an event handler. For more information, see Events (in Visual Basic) and Events (in C#).\n\nIf your class raises multiple events, the compiler generates one field per event delegate instance. If the number of events is large, the storage cost of one field per delegate might not be acceptable. For these scenarios, .NET provides event properties that you can use with another data structure of your choice to store event delegates.\n\nEvent properties consist of event declarations accompanied by event accessors. Event accessors are methods that you define to add or remove event delegate instances from the storage data structure.\n\nThe trade-off is between memory and speed. If your class defines many events that are infrequently raised, you should implement event properties. For more information, see Handle multiple events by using event properties.\n\nThe following resources describe other tasks and concepts related to working with events:\n• Raise and consume events: Find examples for raising and consuming events.\n• Handle multiple events with event properties: Discover how to use event properties to handle multiple events.\n• Explore the observer design pattern: Review a design pattern that enables a subscriber to register with and receive notifications from a provider.\n\nSpecification reference documentation is available for the APIs that support event handling:"
    },
    {
        "link": "https://codeproject.com/Articles/999328/Handling-Events-in-WPF-in-an-Easy-and-Short-Hand-W",
        "document": "This tip is for WPF developers, understanding the usage of lambda expressions for handling the events instead of markup based or function based event handlers.\n\nI would talk about the WPF events and how to handle them easily, perhaps you might already know how to handle them; XAML gives you a lot of good handy functions, but there are a lot of other good ways of doing the same.\n\nEvents in WPF are similar to what we had in Console and Windows Forms. They provide us with notifications and procedures to handle the business logic based on what the state of application is. They allow us to manage what to happen when the application is starting, what to do when the application is closing and when the user interacts with the application.\n\nInteraction includes the button clicks, input value change, window resize and many other similar processes that can be handled to ensure that our business logic is always applied. Validation and other checks can be easily applied to check the values.\n\nI won't go into the depth of events in this tip, you can read more on MSDN.\n\nAlthough handling the events is another function, we require a function to perform (or get triggered) when a certain event is triggered.\n\nNote: Please note that I would be using Visual C# for the purpose of this tip, it would be different as to what VB.NET would provide you as intuition and library resource, so try to follow Visual C# and not VB.NET at the moment.\n\nIn C#, you can handle the event by attaching a function to it. It is similar to say, “When this happens, do that“. You tell your application to perform an action when something happens. The similar action is perform when a new email is received in your email clients, or when download is complete; if notification gets raised for that download complete. The attachment of the event to another function is pretty much simple, the only thing to worry is the required dependencies (the parameters or values or objects required to handle the event).\n\nLook at the following code:\n\nThe above code is an XAML code (remember we are in WPF), the function to handle the event would be like this:\n\nNow, the function is attached to the event of the object. Remember that event needs to be raised in order to trigger that function. User, by interactions, triggers the event which in turn executes the function. You can think of this as:\n• Application checks the input of the user\n\nThe event was click on button, which application used to handle and store the user's input. You can define your own conditions, by default no action is performed for you but application is itself aware of the click but does nothing.\n\nPretty much easy it is to handle the events in WPF, just embed the code in the XAML markup, and Visual Studio would generate the back-end code. Write what you want to be done and you’re good to go!\n\nAs you know, you can do anything with back-end code. You can also attach the event handler to the control’s event using the back-end code. In this section, I would explain how you can do that using back-end code.\n\nSince we used for the previous example, I would use the same for this one. Attaching the event is as easy as 1, 2, 3…\n\nStep 3 is the click event that is performed by the user. ;)\n\nEasy isn’t it? (IMO, it is not! Look in the next section to make it even better!)\n\nThis section is the actual section, which I wanted to talk about. The simple way to handle the events in WPF. It uses the lambda expression, to generate the delegate functions which in turn are executed when the event gets raised. If you are unclear as to what lambda expression or delegate functions are, I would suggest that before continuing, you learn them from the links I have provided. :)\n\nA very simple way (IMO) to handle the event in WPF is like this:\n\nNotice the above expressions. It is a simple lambda expression, being resolved as a delegate function with two parameters ( and ). The parameters are required by the event handler itself, so that is why we need to pass them. Parameters here have the same type that they had in the first code block. C# does the type casting for us and determines what type is being expected.\n\nSpecial thanks to comments below by tbayart and Sacha Barber, the above section was pretty simple, yet it had a problem of memory leakage. You can instead of writing hard-coded lambda expression, create an delegate for the arguments and then use it to attach or detach the event handler.\n\nIn the above code, the handler can be removed when no longer required. Whereas, in the above block, you cannot remove the handler, because it is hard-coded and attached and does not hold a definition or reference.\n\nThis is more efficient as compared to the previous section as it allows us to write the handler in a memory-friendly way.\n\nThe above is the simplest way anyone can handle the event in WPF and is very much short hand, because you leave everything to the context of the object itself. You skip one more step for casting the object, you also don’t have to create different functions with different appended names such as, “ ”, “ ”. All you need to do is just create a lambda expression and use it as the event handler. Pretty much simple, isn’t it?\n\nThat’s all for now. :) I hope, I might have helped you out in making programming WPF applications easier. I will post more such helpful tips for WPF developers soon. :) Stay tuned."
    }
]