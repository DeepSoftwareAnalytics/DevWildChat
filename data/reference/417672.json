[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference",
        "document": "A regular expression is a pattern that the regular expression engine attempts to match in input text. A pattern consists of one or more character literals, operators, or constructs. For a brief introduction, see .NET Regular Expressions.\n\nEach section in this quick reference lists a particular category of characters, operators, and constructs that you can use to define regular expressions.\n\nWe've also provided this information in two formats that you can download and print for easy reference:\n\nThe backslash character (\\) in a regular expression indicates that the character that follows it either is a special character (as shown in the following table), or should be interpreted literally. For more information, see Character Escapes.\n\nA character class matches any one of a set of characters. Character classes include the language elements listed in the following table. For more information, see Character Classes.\n\nAnchors, or atomic zero-width assertions, cause a match to succeed or fail depending on the current position in the string, but they do not cause the engine to advance through the string or consume characters. The metacharacters listed in the following table are anchors. For more information, see Anchors.\n\nGrouping constructs delineate subexpressions of a regular expression and typically capture substrings of an input string. Grouping constructs include the language elements listed in the following table. For more information, see Grouping Constructs.\n\nWhen the regular expression engine hits a lookaround expression, it takes a substring reaching from the current position to the start (lookbehind) or end (lookahead) of the original string, and then runs Regex.IsMatch on that substring using the lookaround pattern. Success of this subexpression's result is then determined by whether it's a positive or negative assertion.\n\nOnce they have matched, atomic groups won't be re-evaluated again, even when the remainder of the pattern fails due to the match. This can significantly improve performance when quantifiers occur within the atomic group or the remainder of the pattern.\n\nA quantifier specifies how many instances of the previous element (which can be a character, a group, or a character class) must be present in the input string for a match to occur. Quantifiers include the language elements listed in the following table. For more information, see Quantifiers.\n\nA backreference allows a previously matched subexpression to be identified subsequently in the same regular expression. The following table lists the backreference constructs supported by regular expressions in .NET. For more information, see Backreference Constructs.\n\nAlternation constructs modify a regular expression to enable either/or matching. These constructs include the language elements listed in the following table. For more information, see Alternation Constructs.\n\nSubstitutions are regular expression language elements that are supported in replacement patterns. For more information, see Substitutions. The metacharacters listed in the following table are atomic zero-width assertions.\n\nYou can specify options that control how the regular expression engine interprets a regular expression pattern. Many of these options can be specified either inline (in the regular expression pattern) or as one or more RegexOptions constants. This quick reference lists only inline options. For more information about inline and RegexOptions options, see the article Regular Expression Options.\n\nYou can specify an inline option in two ways:\n• By using the miscellaneous construct , where a minus sign (-) before an option or set of options turns those options off. For example, turns case-insensitive matching ( ) on, turns multiline mode ( ) off, and turns unnamed group captures ( ) off. The option applies to the regular expression pattern from the point at which the option is defined, and is effective either to the end of the pattern or to the point where another construct reverses the option.\n• By using the grouping construct subexpression , which defines options for the specified group only.\n\nThe .NET regular expression engine supports the following inline options:\n\nMiscellaneous constructs either modify a regular expression pattern or provide information about it. The following table lists the miscellaneous constructs supported by .NET. For more information, see Miscellaneous Constructs."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex?view=net-9.0",
        "document": "This member overrides Finalize(), and more complete documentation might be available in that topic. Allows an Object to attempt to free resources and perform other cleanup operations before the Object is reclaimed by garbage collection."
    },
    {
        "link": "https://bytehide.com/blog/regex-csharp",
        "document": "Introduction to C# Regex: Why It’s a Powerful Tool for Text Manipulation\n\nBefore diving into the magical world of regular expressions, let’s get an idea of why using C# Regex is important and how it can boost your productivity as a developer. In this section, we’ll walk through the basics of regular expressions, their syntax, and key elements to help you get started.\n\nWhat is C# Regex and Why You Should Learn It\n\nC# Regex, or regular expressions in C#, is a powerful tool that allows you to manipulate text data by searching, matching, and replacing patterns within the text. It helps in solving a great number of text-related tasks, such as form validation, data extraction, and text transformations. Mastering C# regular expressions will make you a more efficient developer and provide you the ability to tackle complex text-manipulation tasks with ease.\n\nRegular Expressions in C#: A Brief Overview\n\nRegular expressions are a language for specifying patterns in text data. It’s like a super-powered version of the wildcard functionality you’re familiar with, but much more powerful and flexible. In C#, you don’t need to worry about including any special library, as Regex is natively supported. The namespace contains the class, which provides all the tools needed for working with regular expressions in C#.\n\nThe Power of .NET Regex: The Ultimate String Search Pattern Tool\n\nThe .NET Regex engine is not only efficient and widely-used, but it also supports an extensive set of features. Say goodbye to lengthy, error-prone string manipulation code. Mastering the power of C# Regex will help you create more accurate, concise, and efficient string search patterns that will make your applications more reliable and robust.\n\nGetting Started with Regex in C#: Essential Building Blocks\n\nTo effectively use regular expressions in C#, it’s essential to understand the syntax and building blocks. In this section, we’ll cover the basics of C# Regex syntax, key elements for matching, capturing, and replacing text, and give you an example to get started with matching patterns.\n\nRegular expressions have their own syntax, which can be intimidating at first. But fear not! With practice and a bit of patience, you’ll start seeing the beauty in this concise and expressive language. Here’s a quick overview of some syntax elements you’ll need to know:\n• : Indicates the start of a line.\n• : Indicates the end of a line.\n• : Matches the preceding element 0 or more times.\n• : Matches the preceding element 1 or more times.\n• : Matches exactly n occurrences of the preceding element.\n• : Matches any one of the characters a, b, or c.\n• : Groups the expression inside the parentheses and treats them as a single element.\n\nAnd that’s just the tip of the iceberg! As you progress in your Regex journey, you’ll discover more advanced elements to create even more powerful search patterns.\n\nUsing regex in C# starts with three fundamental techniques: matching, capturing, and replacing. Matching involves finding if a pattern exists in the input text, while capturing goes beyond matching and extracts the matched text for further processing. Replacing, as the name suggests, involves changing the matched text and substituting it with new content.\n\nFor example, let’s say you have a list of email addresses and you want to extract the usernames (the part before the @ symbol) from them. Here’s a simple C# regex example that demonstrates the three techniques in action:\n\nThis code snippet demonstrates how to:\n• Match and capture usernames using the regex\n• Extract the captured group (the username) within a loop\n• Replace the email addresses with a modified version, so that email addresses are displayed as “username is at example.com”\n\nRegex C# Match: The Importance of Accurate Matching in C#\n\nAccurate matching is the crux of regex usage in C#. An incorrect pattern can lead to bugs and issues in your application, so it is crucial to have a strong grasp of regex patterns. Regular expressions can be very complex, but with practice, you’ll be able to create precise, efficient, and intelligible patterns. Take the time to test and refine your regex patterns, as this will prove invaluable in the long run.\n\nRegex Match C# Example: The Essential Code to Get You Started on Matching\n\nTo give you a head start in mastering matching in C# regex, here’s a basic example demonstrating how to match a regex pattern against an input string:\n\nIn this example, we use the method to check if the word “match” is present within the input string, and then output the result (True/False) accordingly.\n\nAs you gain experience with C# regex, you’ll become familiar with the endless potential of regex patterns. Creating complex and efficient patterns requires understanding new syntax elements, as well as the ability to nest and combine them effectively. Keep practicing and exploring regex resources to help you build increasingly intricate and powerful patterns.\n\nMastering Regex in C# with Simple Regex Examples C#\n\nTo help you make quick progress in your regex journey, we’ll explore three examples – basic, intermediate, and advanced – that demonstrate using C# regex in real-world situations. Each example will showcase different regex concepts and techniques to help you become a true regex aficionado.\n\nBasic C# Regex Example: A Simple Regular Expression for Email Validation\n\nEmail validation is a common task encountered by developers. The following example demonstrates a basic regex pattern that checks if an input string is a valid email address:\n\nIn this example, we use the method again, but with a more complex pattern that checks for a valid email format.\n\nIntermediate C# Regex Example: Web Scraping Using Regular Expressions\n\nThis intermediate example demonstrates how to extract specific information from a block of HTML text using regex. Consider the following example that extracts all the URLs from a list of links in an HTML page:\n\nHere, we use the method to find and capture all URLs within the tags in the input string. The extracted URLs are then printed to the console.\n\nAdvanced C# Regex Example: A Case Study on Extracting Structured Data from Unstructured Text\n\nIn this advanced example, we’ll extract structured data from an unstructured block of text: let’s say, grabbing the name, location, and email from a resume-like text.\n\nIn this example, named capture groups (using ) are employed to make extracting the desired information easier. Additionally, the and options are used to allow for multiline matching and ignore whitespace in our pattern, respectively.\n\nC# Regex Replace: Updating Text with Precision and Efficiency\n\nEfficient text manipulation involves more than just finding and capturing text. Understanding how to use C# regex replace techniques with precision will significantly enhance your text-processing skills. In this section, we’ll explore the art of regex replace in C# and delve into tips and tricks for optimal results.\n\nThe Art of C# Regex Replace: How to Replace Text Like a Pro\n\nRegex replace allows us to modify the input text based on a regex pattern, substituting the matched text with new content. This is particularly useful when cleaning up or transforming data. The power and flexibility offered by regex replace will turn you into a text-manipulation maestro in no time!\n\nUsing Regex in C# to Replace Text: Tips and Tricks for Optimal Results\n\nHere are some tips and tricks for using regex replace in C# to achieve optimal results:\n• Use non-capturing groups when the matched text doesn’t need to be captured. It makes the regex pattern more efficient and readable.\n• Utilize regex replace with a lambda expression for more complex replacements.\n• Keep your regex patterns concise and readable for easier maintainability.\n\nLet’s say you have a string that contains dates in the format ‘yyyy-MM-dd’ and you need to replace them with the format ‘dd-MM-yyyy’:\n\nIn this example, we use capturing groups to create a replacement template, which reformats the date string with the desired pattern.\n\nEssential .NET Regex Functions: Making Your C# Regex more Powerful\n\nTo truly harness the power of regex in C#, it’s essential to master the built-in .NET Regex functions. In this section, we’ll cover key functions such as , , , and more, giving you the skills necessary to handle even the most complex text-manipulation tasks with ease.\n\nThe method allows you to quickly check if an input string matches a regex pattern, returning a value that represents the result. This function is especially useful for simple validations and pattern checks. Here’s an example that ensures a password contains at least one uppercase letter, one lowercase letter, one digit, and is between 8 and 14 characters long:\n\nIn this example, the method checks if the input string matches the password requirements specified in the pattern.\n\nUsing C# Regex.Matches: Extracting Multiple Matches from a Single Call\n\nThe method enables you to extract multiple matches from a single input string, returning a object containing all matches found. This method is incredibly useful for extracting data from large, unstructured text. Here’s an example that finds all words containing 4 or more characters in a string:\n\nIn this example, the method finds and extracts all words in the input string that match the specified pattern.\n\nMastering C# Regex.Replace: Up Your Game in Text Manipulation\n\nAs we’ve seen in previous examples, the method provides a powerful way to manipulate text by replacing matched portions of an input string with new content. To truly master text manipulation in C#, you’ll need to have a deep understanding of , including how to use it with capture groups, backreferences, and Lambda expressions for added power and flexibility.\n\nExploring Other Regular Expression C# Methods: C# Replace Regex, Check Regex, and More\n\nIn addition to the core C# Regex methods we’ve discussed, make sure to explore other useful methods available in the class, such as , , and . Each of these methods offers additional functionalities that can help you streamline your text processing tasks and create more advanced and efficient applications.\n\nThe C# Regex Cheat Sheet: A Handy Reference Guide for Common Regex Tasks\n\nTo help solidify your understanding of regular expressions in C#, here’s a cheat sheet containing numerous essential regex syntax elements, functions, and patterns that every C# developer should know.\n\nC# String Pattern Essentials: Building Blocks Every Developer Should Know\n• : 0 or more of the preceding character\n• : At least n, up to m of the preceding character\n• : Negated character set (matching characters not in a, b, or c)\n• : Alternation (match one of the expressions on either side of the )\n\nThese are just a few examples of the regex syntax elements you’ll encounter. The full list of regex syntax elements can be found in the official .NET documentation.\n\nAs previously mentioned, the method is a quick and easy way to check if an input string matches a regex pattern. Add this method to your toolbox to handle simple pattern checks and validations effortlessly.\n\nA Comprehensive List of Regex C# Match Chars and Shortcuts: From Simple to Advanced\n\nThis expanded list offers a more comprehensive look at the various regex elements available to you. Continuously expand your knowledge by exploring regex tutorials, guides, and documentation to better understand and utilize C# regex patterns in your projects.\n\nAdvanced C# Regex: Techniques to Boost Efficiency and Improve Performance\n\nAs you become more proficient in using C# regex, you’ll want to explore advanced techniques that can boost efficiency and improve performance. In this section, we discuss how to optimize your regex patterns for faster results, implement complex regex requirements, and employ C# best practices for clean and effective code.\n\nOptimizing Your Regex C# Match Searches for Faster Results\n\nEfficient regex patterns yield better performance. Here are a few tips to optimize your regex searches with practical examples:\n• Use non-capturing groups whenever possible.\n\nInstead of using which captures the expression, use which matches but won’t capture the expression.\n• Avoid overly complex or nested patterns.\n\nSimplify your regex pattern, and divide it into smaller patterns if needed. Refactor your code to use multiple simple patterns instead of a single complex pattern.\n• Utilize anchors ( and ) to limit the search scope.\n\nAnchors can help speed up the regex matching as they limit the search scope, reducing the processing time.\n\nImplementing complex regex requirements often involves using advanced regex features, such as lookahead and lookbehind assertions. These allow you to create patterns that take the surrounding context into account without actually capturing the text. Understanding and utilizing these advanced features will enable you to create more powerful and precise search patterns.\n\nPositive lookahead ensures that the pattern inside the lookahead is present in the string but doesn’t consume characters in the string.\n\nNegative lookahead ensures that the pattern inside the lookahead is not present in the string but doesn’t consume characters in the string.\n\nPositive lookbehind ensures that the pattern inside the lookbehind is present in the string but doesn’t consume characters in the string.\n\nNegative lookbehind ensures that the pattern inside the lookbehind is not present in the string but doesn’t consume characters in the string.\n\nRegex in .NET: Tips for Seamless Interoperability in Your C# Projects\n\nRegular expressions in C# are part of the .NET library, which means they are easily interoperable with other .NET languages and tools. Ensure that you’re familiar with the .NET regex syntax and follow established best practices when working in a multi-language environment. This will help you maintain consistent code, reduce potential bugs, and ensure a seamless regex experience across your entire project.\n\nFor example, when working with VB.NET or F# developers, share your regex patterns and ensure everyone understands the syntax and structure of the patterns used in the project. Use established naming conventions for the regex patterns and keep the patterns similar across all languages to make it easier for developers from different language backgrounds to read and understand them.\n\nRegular Expressions C# Best Practices: Developing Clean, Efficient, and Readable Code\n\nTake the time to develop clean, efficient, and readable regex code. Keep your patterns concise and maintainable to ensure long-term stability and efficiency. Include comments and explanations for complex regex expressions to guide fellow developers, making it easier for them to understand and maintain the code. As with all programming scenarios, following best practices is key to achieving optimal results with your C# regex implementation.\n\nThis pattern demonstrates the use of comments to explain each portion of the regex pattern, making it easier for others (and your future self) to understand the purpose and behavior of the regex pattern.\n\nPutting It All Together: C# Regex for Real-world Applications\n\nAs you’ve seen throughout this guide, C# regex can be a versatile and powerful tool for text manipulation in various real-world applications. Let’s recap some practical use cases for regex in C# with examples to provide further insights.\n\nPractical Use Cases for Regex in C Sharp\n\nHere are a few example applications that can benefit from the power of regex in C#:\n\nRegex can be used to validate form fields in a web application, such as checking if an email address follows the correct format.\n• Extracting and transforming data for data analysis or reporting:\n\nRegex can be used to parse log files, for example, and extract useful information like error messages, timestamps and user data.\n\nRegex can be utilized to extract content from web pages, such as fetching all the links on a webpage.\n\nRegex can be used to find specific patterns or strings in large code files or text documents, helping you quickly locate the information you need.\n\nBy using regex patterns, you can parse log files to find specific error messages or occurrences, aiding in the debugging process.\n\nUsing Regex C# in ASP.NET for Form Validation and Input Sanitization\n\nRegex plays a vital role in form validation and input sanitization in web applications. Mastering regex in C# allows you to create robust and secure ASP.NET applications that efficiently validate user input, ensuring data integrity and preventing potential security issues. For example, you can use regex in conjunction with Validator controls, such as , to match a specific pattern in user-submitted input.\n\nC# Regular Expressions in Data Processing: Extracting and Transforming Text in Real-time\n\nRegex is a game-changer when it comes to data processing. It empowers you to effortlessly extract and transform text data in real-time, simplifying complex data processing tasks and improving the overall efficiency of your applications.\n\nFor example, you might need to parse thousands of lines of text files and extract specific information, such as all email addresses within the text:\n\nAnother example would be transforming formatted text, such as removing all HTML tags from a given text while preserving the content:\n\nAs you delve deeper into the world of C# regex, you will discover countless areas of application that can benefit from the power and flexibility offered by regular expressions. By mastering regex, you can tackle complex text manipulation tasks head-on, enhancing the performance and capabilities of your applications, and ultimately becoming a more effective and proficient C# developer.\n\nThroughout this guide, you’ve explored the world of C# regex, from basic syntax elements to advanced techniques. The possibilities are virtually limitless once you’ve mastered regex in C#. Continue honing your regex skills and applying them to real-world applications to take full advantage of the power and flexibility that regular expressions in C# offer.\n\nC Sharp Regex Resources to Boost Your Knowledge and Skills\n\nTo further improve your regex mastery, explore the wealth of regex resources, tutorials, and guides available online. The official .NET documentation is a great place to start, but don’t be afraid to dig into blog posts, Stack Overflow discussions, and regex tools to expand your knowledge.\n\nC# Regex Guide: The Journey Towards Regex Mastery\n\nMastering regex in C# is a continuous process of learning, experimentation, and practice. Keep exploring new regex concepts and applying them in your projects. The more you work with regex, the better your understanding and proficiency will become.\n\nThe Future of Regex C#: A Look at the Evolution of Regular Expressions and Their Role in Modern Applications\n\nAs programming languages and tools continue to evolve, so too will the role of regex in text manipulation and modern applications. Stay up-to-date with the latest regex functionalities in C# and other languages, as well as evolving best practices, to ensure that your regex skills remain current and relevant."
    },
    {
        "link": "https://csharp.com/article/c-sharp-regex-examples",
        "document": "Regex in C# defines a regular expression in C#. The Regex class offers methods and properties to parse a large text to find patterns of characters. In this article, you’ll learn how to use a Regex class in C#.\n\nRegex, short for regular expression, is a sequence of characters that defines a search pattern. It is a versatile tool used for pattern matching and manipulation of text. With a regular expression, you can specify rules or patterns to search for specific sequences of characters within a larger text. These patterns can include literal characters, metacharacters, character classes, quantifiers, and more. Regular expressions are commonly used for various tasks, such as:\n• Pattern matching: Finding and extracting specific sequences of characters in text.\n• String validation: Checking if a string conforms to a specific pattern or format.\n• Data extraction: Parsing and extracting data from structured text, such as log files or web pages.\n\nIn C#, the Regex class provides methods and properties to work with regular expressions. Here are some key features and functionalities of C# regex:\n• Pattern matching: C# regex allows you to define patterns using special characters and constructs to match specific sequences of characters within a string.\n• Searching and replacing: You can use regex to search for patterns within a string and replace them with other text or manipulate the matched portions of the string.\n• Validation: Regex is commonly used for validating user input. You can define a pattern that input must match, and then check if the input string conforms to that pattern.\n• Splitting strings: Regex can be used to split strings based on a specified pattern. For example, using regex, you can split a comma-separated list of values into individual elements.\n• Capturing groups: Regex allows you to define capturing groups, which are portions of the pattern enclosed in parentheses. These groups can be used to extract specific parts of a matched string.\n\nThe Regex class is defined in the System.Text.RegularExpressions namespace. The Regex class constructor takes a pattern string as a parameter with other optional parameters.\n\nThe following code snippet creates a Regex from a pattern. Here the pattern is to match a word starting with char ‘M’.\n\nThe following code snippet has a long text with author names that must be parsed.\n\nThe Matches method finds all the matches in a Regex and returns a MatchCollection.\n\nThe following code snippet loops through the matches collection.\n\nHere is the complete code:\n\nIn the above example, the code looks for char ‘M’. But what if the word starts with ‘m’? The following code snippet uses RegexOptions.IgnoreCase parameter to ensure that Regex does not look for uppercase or lowercase.\n\nThe Regex.Replace() method replaces a matched string with a new one. The following example finds multiple whitespaces in a string and replaces them with a single whitespace.\n\nThe following code snippet replaces whitespaces with a ‘-‘.\n\n3. Replacing multiple white spaces using Regex in C#\n\nThe following example uses the regular expression pattern [a-z]+ and the Regex.Split() method to split a string on any uppercase or lowercase alphabetic character.\n\nRegular expressions are a pattern-matching standard for string parsing and replacement. They are a way for a computer user to express how a program should look for a specified pattern in text and what the program should do when each pattern match is found. Sometimes it is abbreviated \"regex\". They are a powerful way to find and replace strings in a defined format.\n\nHere is a simple code example in C# that shows how to use regular expressions.\n\nHere is a detailed tutorial on Regular Expressions and how to use them in C# and .NET: Regular Expressions In C#.\n\n4. Email Validation in C# with Regex\n\nFor validating multiple emails, we can use the following regular expressions. We are separating emails by using the delimiter ';'\n\nIf you want to use delimiter ',' then use this.\n\nAnd if you want to use both delimiters ',' and ';,' then use this.\n\nSo by using the above regular expression, you can validate a single email as well as multiple emails.\n\nLearn more here: Regex for Multiple Email Validation.\n\n5. Validating User Input with Regular Expressions in C#\n\nThis article explains how to use Regular expressions (the Regx class of the System.Text.RegularExpressions namespace) in C#.\n\nWe can use Regex.Match method that takes an input and regex and returns success if\n\nLearn more here: Validating User Input with Regular Expressions\n\n6. Split String using Regex.split (Regular expression) in C#\n\nIn this post, we will learn how to split the string using Regex in c#.\n\nHere we will learn how to split the string using RegEx in C#. Regex splits the string based on a pattern. It handles a delimiter specified as a pattern. This is why Regex is better than string.Split. Here are some examples of how to split a string using Regex in C#. Let's start coding.\n\nFor use, Regex adds the below namespaces for splitting a string.\n\nThe above code splits the string using \\D+ and loops through check number and print.\n\nLearn more here: Split String using Regex in C#\n\n7. Replace Special Characters from string using Regex in C#\n\nLearn how to replace Special Characters Using Regex in C#.\n\nYou can use regex if you have a string with special characters and want to remove/replace them.\n\nThis code will remove all of the special characters, but if you don't want to remove some of the special characters for, e.g., comma \",\" and colon \":\" then make changes like this:\n\nSimilarly, you can make changes according to your requirement.\n\nPlease note that regular expressions do not solve every tiny string parsing. If you need simple parsing provided by the String class or other classes, try to use those."
    },
    {
        "link": "https://strabo.partners/a-practical-guide-to-using-regular-expressions-for-pattern-matching-in-c",
        "document": "Regular expressions, or RegEx, are a powerful tool for pattern matching and manipulating strings. However, if you’re not familiar with their syntax, implementing regular expressions can be challenging. In the first part of this two-part series, we’ll explore several examples of regular expressions, discuss their significance, and break down each component for better understanding. By the end, you’ll be ready to effectively implement regular expressions for pattern matching in your own projects!\n\nLet’s begin with an example of a RegEx used in Product Desk, Strabo Partner’s Product Management Tool (PIM). In this case, we employ the Regular Expression “^[a-zA-Z0-9\\-_.~ ]$” within a Fluent Validation Rule to ensure that the Product Group ID, used in the URL for displaying the Product Group Details page, contains only valid URL characters. Let’s dig in:\n• A regular expression always starts and ends with anchors. The “^” anchor marks the start of the expression, while the “$” anchor denotes its end. Together, they ensure that the entire ProductGroupID matches the RegEx pattern.\n• The content within the brackets “[ ]” form a character class, defining the acceptable range of characters within the evaluated string. In this case, the character class includes alphanumeric characters (a-z, A-Z, 0-9), as well as hyphen “–“, underscore “_”, period “.”, tilde “~”, and space “ “. To interpret the hyphen “–” as a literal character and not part of a range, we precede it with a backslash “\\” escape character.\n\nThis regular expression ensures that the ProductGroupID consists solely of alphanumeric characters, hyphens, underscores, periods, tildes, and spaces. It effectively validates whether the Product Group ID can be used in a URL. Let’s consider a few examples of Product Group IDs that would undergo analysis using this RegEx:\n• Wheels&Tires – This example fails the test due to the presence of the excluded special character “&”.\n• Wheel Accessories – This example passes the test as it includes uppercase and lowercase letters, along with an included special character, a space.\n• Rear/Wheels – Our final example fails because it contains an excluded special character, “/“.\n\nNext, let’s examine another RegEx borrowed from our partner, Big Commerce. Product Desk integrates seamlessly with Big Commerce, allowing clients to manage their products and instantaneously keep their Big Commerce store-fronts up to date. In the Big Commerce Shipping API documentation, they utilize this RegEx to define a valid Harmonized System Code for their platform: “/^[0-9A-Za-z]{6,14}$/“. While it may appear familiar, there are a few differences that make it a useful example:\n• In addition to the beginning and ending anchors “^” and “$”, this regular expression is wrapped in forward slashes “/”. These delimiters are commonly used in languages like Perl, PHP, and Ruby, but less frequently in C#, Java, and JavaScript.\n• Following the character class, we observe a new addition: “{6,14}“. In RegEx, this part of the expression is known as a quantifier. It enforces a minimum and maximum number of characters when creating Harmonized System Codes on the Big Commerce platform.\n\nLet’s explore some examples of strings that can be analyzed using this RegEx:\n• AbCdE12345 – This passes as its length is within the allowed range, and it includes uppercase letters, lowercase letters, and digits, all of which are accounted for in the pattern’s character class.\n• Ab.12 – This string satisfies almost all of the requirements, except that it includes an excluded special character “.” and falls short of the minimum required length of 6 characters.\n\nBy using this regular expression, Big Commerce can validate whether a given string meets their criteria for a valid Harmonized System Code.\n\nNow that we’ve gotten a basic understanding of how we can use regular expressions to validate strings, let’s take a look at an example that is a little more complicated. This one builds on our first two examples and I promise, it’s not as scary as it looks.\n\nIn this regular expression, we have multiple positive lookahead assertions represented by (?=.*[A-Z]), (?=.*[a-z]), (?=.*\\d), and (?=.*[\\-_.~]). Each assertion enforces a specific requirement within the expression.\n• The first two assertions, (?=.*[A-Z]) and (?=.*[a-z]), ensure that there is at least one uppercase and one lowercase letter somewhere in the string.\n• The third assertion, (?=.*\\d), ensures that there is at least one digit (0-9) in the string.\n• The final assertion, (?=.*[\\-_.~]), ensures that at least one of the following characters appears somewhere in the string: hyphen “–“, underscore “_”, period “.”,tilde “~”, or a space “ “.\n\nThe positive lookahead assertions delineate the required characters for the string being analyzed. After that, the character class [A-Za-z0-9\\-_.~ ] specifies the allowed characters, and finally, the {8,20} quantifier enforces a length requirement between 8 and 20 characters.\n\nIt’s not hard to imagine this regular expression being used to enforce password requirements. It ensures that the string, or password, contains at least one uppercase letter, one lowercase letter, one digit, and one of the specified special characters, while also enforcing a minimum and maximum length.\n\nBefore we move on, lets consider one more possibility. Wouldn’t it be more concise to consolidate the positive lookahead assertions into the one, shorter statement – (?=.*[a-ZA-Z\\d\\-_.~])? While it takes up less space and is a bit easier to read, the answer is no. This statement is not equivalent to our original, and much longer one. Here’s why:\n• “^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[-_.~])[A-Za-z0-9-.~ ]{8,20}$” requires one uppercase letter to be present in the string, AND one lowercase letter, AND one digit, AND one of the characters “–“, “_”, “.”, “~”, or “ “.\n• “^(?=.*[ A-Za-z\\d-_.~]) [A-Za-z0-9-.~ ]{8,20}$” requires that one uppercase letter exists in the string, OR one lowercase letter, OR one digit, OR one of the characters “–“, “_”, “.”, “~”, or “ “. This expression would not ensure the presence of all of the different character types.\n\nThese three examples demonstrate how regular expressions can be used for pattern matching in C#. By understanding the syntax and components of regular expressions, you can create powerful string validation rules for various use cases in your own projects.\n\nRemember to test your regular expressions thoroughly with different input scenarios to ensure they behave as expected. Regular expressions can be complex, so it’s important to consider edge cases and potential pitfalls.\n\nAdditionally, there are various online resources and tools available that can assist in building and testing regular expressions, such as regex101.com and RegEx libraries for specific programming languages.\n\nI hope this explanation helps you gain a better understanding of how you can use regular expressions for pattern matching in C#. In the next post, we’ll dive into how you can use RegEx for matching and extracting substrings from blocks of text. If you have any further questions, feel free to ask!\n• Stack Overflow. “To Use or Not to Use Regular Expressions?” Stack Overflow. Accessed June 10, 2023. Link"
    },
    {
        "link": "https://stackoverflow.com/questions/73815865/regular-expression-to-exactly-match-the-last-path-segment-of-an-url-without-para",
        "document": "The goal of my regular expression adventure is to create a matcher for a mechanism that could add a trailing slash to URLs, even in the presence of parameters denoted by or at the end of the URL.\n\nFor any of the following URLs, I'm looking for a match for as follows:\n\nIn case there is a match for I'm going to replace it with .\n\nFor any of the following URLs, there should be no match:\n\nbecause here, there is already a trailing slash.\n• This primitive regex and their variants: . However, with this approach, I could not make it not match when there is already a trailing slash.\n• I experimented with negative lookaheads as follows: . In this case, I could not get rid of any or parts properly.\n\nThank you for your kind help!"
    },
    {
        "link": "https://stackoverflow.com/questions/8798187/how-do-i-get-the-last-segment-of-url-using-regular-expressions",
        "document": "How do I get the last term between slashes? i.e. using regular expressions?\n\nPlease note that the URL could just be:\n\nI need to extract this last term for use in the Zeus Server's Request Rewrite module which uses PERL and REGEX.\n\nAfter implementing some answers, I have just realized that I need this match to be made only on URLs in a certain directory."
    },
    {
        "link": "https://cambiaresearch.com/articles/46/parsing-urls-with-regular-expressions-and-the-regex-object",
        "document": "Parsing URLs with Regular Expressions and the Regex Object\n\nAnd the Anatomy of a URI (Uniform Resource Identifier)\n\nWhile the .NET Framework contains a class call Uri which provides a lot of functionality when dealing with URLs and URIs, it's not always easy to get at the pieces of a URL. I present a technique here using regular expressions to extract the subparts of a URI in one fell swoop. But first let's talk about the parts of a URI.\n\nThe following information is taken from the official W3C Network Working Group documents. For the whole kit and kaboodle see RFC9386. stands for Uniform Resource Identifier and is a \"compact sequence of characters which identifies an abstract or physical resource.\" stands for Uniform Resource Locator. URLs are a subset of URIs that \"provide a means of locating a resource by describing its primary access mechanism, for example, its network location. Now, let's talk about the syntax of the URI, or the various pieces that combine to form the whole. These consist of the scheme, authority, path, query and fragment.\n\nIn a URL the authority is also called the domain and may include a port number at the end separated by a colon. In the following example, the authority is www.cambiaresearch.com In the following example, the authority is www.cambiaresearch.com:81 In the following example, the authority is info@cambiaresearch.com\n\nThe path component of the URL specifies the specific file (or page) at a particular domain. The path is terminated by the end of the URL, a question mark (?) which signifies the beginning of the query string or the number sign (#) which signifies the beginning of the fragment. The path of the following URL is \"/default.htm\" The path of the following URL is \"/snippets/csharp/regex/uri_regex.aspx\"\n\nThe query part of the URL is a way to send some information to the path or webpage that will handle the web request. The query begins with a question mark (?) and is terminated by the end of the URL or a number sign (#) which signifies the beginning of the fragment. The query of the following URL is \"?id=241\" The query of the following URL is \"?sourceid=navclient&ie=UTF-8&rls=GGLC,GGLC: 1969-53,GGLC:en&q=uri+query\"\n\nIn a URL the fragment is used to specify a location within the current page. This is often used in a FAQ with a list of links at the top of the page linking to longer descriptions farther down in the page. The fragment of the following URL is \"contact\" The fragment of the following URL is \"scheme\""
    },
    {
        "link": "https://forum.eastgate.com/t/get-the-last-segment-of-a-url/7424",
        "document": "The referenced page is a bit confusing as its the test URL contains no year fragment. So, I assume you are strting with an example like:\n\nand you wish to retrieve the ‘123’. Of more specifically as this is using a computer, everything after the in a source URL. Assumption: a sequence should, I think occur only once.\n\nSo , we want to split our URL and retrieve the second part, i.e. ‘123’ for the test above. This should work, but doesn’t:\n\nNote the need to escape the as .split() uses a regular expression pattern and is a regex specaial ooperator character. means treat this as a question mark not a speciail operator.\n\nWhy does this not work? It seems the in the URL is misread as a comment and causes the code to returns a wrong result.\n\n[Edit: turns out the culprit is and the presence of in an list item: same holds whither using or list item addressing. Regardless, the problem is now known to the developer.]\n\nWe can fix that, by first removing the sequence from the URL. It is only done on the being-evaluated version so the source $URL value is untouched:\n\nOne last wrinkle. Perhaps the query marker is just and not , or indeed, could we split on eiher of the two? Yes, regex to the rescue. In the split pattern we change from to . The in regex means “the preceding character occurs zero or more times”. Tada!"
    },
    {
        "link": "https://red-gate.com/simple-talk/development/dotnet-development/url-matching-c",
        "document": "Ah, URLs. The Unified Resource Locator (URL) is ubiquitous in enterprise software. It doesn’t matter whether it’s a desktop, a web application, or a backend service, URLs have the unique ability to catch you off guard when you least expect it.\n\nOne can lean on the ASP.NET framework for URL routing which provides its own way of matching URLs to action methods. But alas, as is often the case, a full feature framework might not get you where you need to be. URL routing has a powerful way to invoke action methods inside MVC controllers but doesn’t help with URL matching.\n\nIf you’ve worked with URLs before and found it hard, then you’re doing it right. If it was easy, then this write up is for you. There are many traps hidden inside these URLs. A URL appears harmless on the surface but, when you look closer, it can be perilous.\n\nIn this take, I’d like to give you a deep dive into working with URLs in plain C#. In IT, there may come a time when you have this URL from a config and must match it with another one. The URL can come from the web request that you need to intercept through middleware with a match. I’ll stick to real examples I’ve come across in my programming adventures in the enterprise.\n\nTo start, let’s define what the internals of a URL looks like:\n\nFor our purposes, we care about the scheme, authority, path, query, and fragment. You can think of the scheme as the protocol, i.e., HTTP or HTTPS. The authority is the root or domain, for example, mycompany.com. The path, query, and fragment make up the rest of the URL. The URL spec defines each segment in this specific order. For example, the scheme always comes before the authority. The path comes after the scheme and authority. The query and fragment come after the path if there is one in the URL.\n\nWith the textbook definition in place, it’s time for string matching URLs. I’ll stick to the terminology from the figure so it is crystal clear for you.\n\nGiven a URL, it is somewhat reasonable to do a string comparison:\n\nAll code samples use xUnit assertions to prove out matching concepts. Note the String.Equals comparison to get a string match with a URL.\n\nOne thing to look out for is that URLs are case-insensitive in the spec. This means https://example.com matches HTTPS://example.com. A naïve string comparison with an equals method does not account for this.\n\nTo make this more robust, add case-insensitivity to the comparison:\n\nThe StringComparison.OrdinalIgnoreCase enumerator will do a byte match for each character while ignoring casing. This works well for URLs which are made up of ASCII characters. Note that there is an extra parameter to the overloaded the String.Equals method. With this much effort necessary to add robustness, it should appear often in your code.\n\nAnother interesting aspect is that the path of the URL can end with a forward slash. For example, /abc/ also matches /abc without a trailing forward slash. The config or app providing the URL can go either way and you must account for this.\n\nUsing string manipulation, we can trim the ends then do a match:\n\nThis accounts for many mishaps with string comparisons. You will start to notice you need a good amount of trimming around URLs. When engaging in this line of work, it is best to stay alert and practice defensive coding. It’s difficult to imagine the many radical new ways folks can type in a simple URL. Human beings are not like computers and may find innovative ways to muck up URLs.\n\nC# uses the .NET framework behind the scenes and provides a list of methods that can aid with URL matching. The System.String type, for example, has many extension methods available. It’s like having a full array of tools at your fingertips, time to examine which methods are most useful.\n\nLet’s say we want to match the scheme to make sure it’s HTTPS:\n\nNote that it is safe to assume the scheme comes first according to the spec. The String.StartsWith method has a sibling method that can match the end of the string. This is useful for doing a match on the path of the URL. This is assuming your URLs always end with the path only.\n\nSo, for example:\n\nOne can be clever with string matching in C#. Your string comparisons have an arsenal of methods at your disposal, so you can be as effective as possible. Let’s say, for example, I want to know if a given URL even has a query. The spec defines this as ?key=value. Note that the question mark is a unique character. This question mark character is in the URL spec and does not belong elsewhere.\n\nSo, for example:\n\nIf you can make safe assumptions about your URLs, like in the example above. Feel free to exploit these assumptions to your advantage with string comparison methods. All you need is to know is which method to use and a little imagination.\n\nWith URLs coming from a config or any data source, what you might get back is a list. With the .NET framework, you can use LINQ to iterate through URL lists and then do a match. Imagine there is a list of URLs that must match a target URL. All I want to know is whether the URL exists within the list.\n\nSay, for example:\n\nThe IEnumerable.Any method allows you to match a list with a URL. Note the use of a lambda expressions to further refine the match. This becomes quintessential when you need to trim and ignore case sensitivity. At the end, this lambda expression expects a true or false which comes from the equal string comparison. If any items on the list return true then the entire method returns true.\n\nFor example, let’s say you have a list of paths that belong to the URL that needs a match. What you need is to combine the paths to the whole URL, then do a match. The string type has a String.Join method you can use to do the job. This join method takes in a list you can further refine using LINQ.\n\nSo, for example:\n\nI am purposely being naughty with the list of paths. One path has a trailing slash while the other does not. The goal here is to illustrate what kind of assumptions you can and cannot make with URLs. The way you write URL matching can have a life of its own depending on the assumptions.\n\nNote the IEnumerable.Where method to filter out empty paths. LINQ has many more methods available you can use for URL matching. What I find is that I tend to use both IEnumerable.Any and IEnumerable.Select() often. These extension methods are part of the IEnumerable interface in C#. This means it can support a wide array of list types including an array of integers.\n\nLINQ gets enabled on a list when you add System.Linq to the using statements. Inside Visual Studio, these extension methods don’t show up in IntelliSense until you do so. Feel free to explore this namespace if you need more ideas when working with URLs.\n\nWhat you will find in .NET is that each type may have methods that come with it. The string type, for example, has a list of methods through the System namespace. So far, you can see how these methods are useful to you. It is like having a toolbelt with a whole array of functionality available.\n\nThe .NET framework has a type to encapsulate URLs if necessary. There is a System.Uri type that can parse any valid URL. The string and LINQ methods I have explained so far do not parse but only provide URL matching. The Uri type has a list of methods and properties you can use to break a URL apart for further analysis.\n\nLet’s say you have a URL with a scheme, authority, path, query, and fragment. Attempting to match against each piece requires good Regex skills. The good news is that a Uri type can do matches in an object-oriented fashion. This OOP (object oriented programming) approach can help keep the code nice and tidy.\n\nOne gotcha is that the Query property returns a string type, not a dictionary object. This will require that you parse out the string into a key-value pair. When you are working with the query inside a URL, you often need it as a dictionary to do lookups.\n\nSo, for example:\n\nYou can get the schema and path through the Uri.GetLeftPart method. Note the use of the System.UriPartial enumerable to get each segment of the URL. The Fragment property has the fragment of the URL.\n\nFor the Query, note that ?key1=value&key2 is a valid query string because the spec is lenient. The String.Split method gives me back an array I can turn into a dictionary object. For duplicate keys, I use a Dictionary.ContainsKey first then a Dictionary.Add if it’s not in the dictionary. This is a defensive way of dealing with potential typos from a bad config, for example. For those in .NET Core 2.0+, there is a shiny new Dictionary.TryAdd that has this same logic as part of the method. Each itemValue can come from the Query or get a default value of string.Empty. Empty keys in the Query are still plausible. The asserts prove out that code above works as expected.\n\nOne gotcha comes from the scheme segment. Note that it returns the colon and backslashes as part of the scheme itself. If the goal is to match it against HTTPS, for example, it might be wise to match it with a String.StartsWith and ignore casing.\n\nThis covers just about everything you will encounter when matching URLs with a Uri type. I hope you can see it is far from trivial. One nice advantage is you get the Uri type through the System namespace. This namespace often appears inside many using statements in C#.\n\nThe .NET framework comes with a set of namespaces useful for working with URLs. So far, you have seen the System and System.Linq namespaces at work. In C#, there are two types of primary concerns which are System.String and System.Uri. These two types have many methods which are useful to you. For the System.String type, keep an eye on String.StartsWith and String.Equal with case insensitivity. For working with a list of URLs, use any list type that implements the IEnumerable interface. The System.Linq namespace will enable a set of extensions methods for your favorite type. To parse the Query into a dictionary type use the System.Collections.Generic namespace.\n\nAll these namespaces have been available in .NET since 3.5 and are part of the .NET Standard library. This means this code is guaranteed to work with many implementations of the .NET framework which include .NET Core. Microsoft is pushing for a standards-based approach and these namespaces are part of it. It is nice to have working code that has a commitment and supports a standard.\n\nBecause we are talking about the .NET framework and not only niche features in C#, these same namespaces and object-oriented types are available in PowerShell if you have a language version that supports .NET version 3.5 at a minimum. This means you can go all the way back to PowerShell 3.0."
    }
]