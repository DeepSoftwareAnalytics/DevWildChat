[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding?view=net-9.0",
        "document": "The following example converts a string from one encoding to another.\n\nFor more information about this API, see Supplemental API remarks for Encoding.\n• How to use character encoding classes in .NET"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-text-encoding-default",
        "document": "This article provides supplementary remarks to the reference documentation for this API.\n\nDifferent computers can use different encodings as the default, and the default encoding can change on a single computer. If you use the Encoding.Default encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly. In addition, the encoding returned by the Default property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these reasons, using the default encoding is not recommended. To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as UTF8Encoding or UnicodeEncoding. You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.\n\nIn .NET Framework, the Default property always gets the system's active code page and creates a Encoding object that corresponds to it. The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page. Because all Default encodings based on ANSI code pages lose data, consider using the Encoding.UTF8 encoding instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.\n\nIn .NET Core, the Default property always returns the UTF8Encoding. UTF-8 is supported on all the operating systems (Windows, Linux, and macOS) on which .NET Core applications run."
    },
    {
        "link": "https://github.com/dotnet/standard/issues/260",
        "document": "You can’t perform that action at this time."
    },
    {
        "link": "https://stackoverflow.com/questions/6550254/default-c-sharp-string-encoding",
        "document": "There's no one single \"extended ASCII\" encoding. There are lots of different 8-bit encodings which are compatible with ASCII for the bottom 128 values.\n\nYou need to find out what encoding your files actually use, and specific that when reading the data with (or whatever else you're using). For example, you may want encoding Windows-1252:\n\n.NET strings are always sequences of UTF-16 code points. You can't change that, and you shouldn't try. (That's true in Java as well, and you really shouldn't use the platform default encoding when calling etc unless that's what you really, really mean.)"
    },
    {
        "link": "https://stackoverflow.com/questions/57920826/how-to-change-string-encoding-after-reading-it-from-file-using-default-encoding",
        "document": "From various comments it appears the text is in the codepage, also known as 437. To load files in that codepage use , eg :\n\nThe or characters are the conversion error replacement characters returned when trying to read text using the wrong codepage. It's not possible to recover the original text from them.\n\nEncoding.Default is the system's default codepage, not some .NET-wide default. As the docs say:\n\nThe Default property in the .NET Framework In the .NET Framework on the Windows desktop, the Default property always gets the system's active code page and creates a Encoding object that corresponds to it. The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page. Because all Default encodings based on ANSI code pages lose data, consider using the Encoding.UTF8 encoding instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.\n\nFinally, both File.ReadAllText and the StreamReader class it uses will try to detect the encoding from the file's BOM (Byte Order Marks) and fall back to UTF8 if no BOM is found.\n\nThere's no reliable way to detect the encoding as many codepages may use the same bytes. One can only identify bad matches reliably because the resulting text will contain\n\nWhat one can do is load the file's bytes once and try multiple encodings, eliminating those that contain . Another step would be to check for expected non-English words or characters and eliminate the encodings that don't produce them.\n\nEncoding.GetEncodings() will return all registered encodings. A rough method that finds probable encodings could be :\n\nor, using value tuples :"
    },
    {
        "link": "https://stackoverflow.com/questions/190385/how-to-manipulate-images-at-the-pixel-level-in-c-sharp",
        "document": "System.Drawing.Bitmap has a GetPixel(int x, int y) public method that returns a System.Drawing.Color structure. That struct has byte members R, G, B, and A, which you can modify directly, and then call SetPixel(Color) on your Bitmap again.\n\n Unfortunately, that's going to be relatively slow, but it's by the easiest way to do it in C#. If you are working with individual pixels a lot and find the performance is lacking, and you need something faster, you can use LockBits... It's a lot more complicated though, as you need to understand the bit structure for that color depth and type, and work with the bitmap's stride and what not... so if you find it's necessary, make sure you find a good tutorial! There are several out there on the web, Googling \"C# LockBits\" will get you a half dozen that are worth a read."
    },
    {
        "link": "https://codeproject.com/Articles/617613/Fast-Pixel-Operations-in-NET-With-and-Without-unsa",
        "document": "Using GetPixel or SetPixel for all but tiniest images is a terrible idea. Stop using these methods and make your code over 300 times faster!\n\nThe class has and methods that let you acquire and change color of chosen pixels. Those methods are very easy to use but are also extremely slow. My previous post gives detailed explanation on the topic, click here if you are interested.\n\nFortunately, you don’t have to use external libraries (or resign from .NET altogether) to do fast image manipulation. The Framework contains a class called that lets you apply many changes to images in an efficient manner. Properties such as contrast or saturation can be modified this way. But what about manipulation of individual pixels? It can be done too, with the help from the method and the class…\n\nA good way to test individual pixel manipulation speed is color difference detection. The task is to find portions of an image that have color similar to some chosen color. How to check if colors are similar? Think about color as a point in three dimensional space, where axis are: red, green and blue. Two colors are two points. The difference between colors is described by the distance between two points in RGB space.\n\ndiff = sqrt((C -C )2+(C -C )2+(C -C 2)\n\nThis technique is very easy to implement and gives decent results. Color comparison is actually a pretty complex matter though. Different color spaces are better suited for the task than RGB and human color perception should be taken into account (e.g. our eyes are more keen to detect difference in shades of green that in shades of blue). But let’s keep things simple here…\n\nOur test image will be this Ultra HD 8K (7680x4320, 33.1Mpx) picture (on this blog, it’s of course scaled down to save bandwidth):\n\nThis is a method that may be used to look for R=255 G=161 B=71 pixels (car number \"36\"). It sets matching pixels as white (the rest will be black):\n\nThe above code is our terribly slow / baseline. If we call it this way (named parameters for clarity):\n\nwe will receive the following outcome:\n\nResult may be ok but having to wait over 84300ms* is a complete disaster!\n\nNow check out this method:\n\nIt does exactly the same thing but runs for only 230ms - over 360 times faster!\n\nThe above code makes use of method that is a wrapper for native (GDI+, gdiplus.dll) function. creates a temporary buffer that contains pixel information in desired format (in our case RGB, 8 bits per color component). Any changes to this buffer are copied back to the bitmap upon call (therefore, you should always use and as a pair). returns object ( namespace) that has two interesting properties: and . returns an address of the first pixel data. is the width of single row of pixels (scan line) in bytes (with optional padding to make it dividable by 4).\n\nPlease notice that I don’t use calls to and to calculate distance between colors. Writing code like this:\n\nto process millions of pixels is a terrible idea. Such line can make our optimized method about 25 times slower! Using with integer parameters is extremely wasteful and we don’t have to calculate square root to determine if distance is longer than specified tolerance.\n\nPreviously presented method uses code marked with keyword. It allows C# program to take advantage of pointer arithmetic. Unfortunately, mode has some important restrictions. Code must be compiled with \\unsafe option and executed for fully trusted assembly.\n\nLuckily, there is a method (from namespace) that can move data between managed and unmanaged memory. We can use it to copy image data into a byte array and manipulate pixels very efficiently. Look at this method:\n\nIt runs for 280ms, so it is only slightly slower than version. It is CPU efficient but uses more memory than the previous method – almost 100 megabytes for our test Ultra HD 8K image in RGB 24 format.\n\nIf you want to make pixel manipulation even faster, you may process different parts of the image in parallel. You need to make some benchmarking first because for small images, the cost of threading may be bigger than gains from concurrent execution. Here’s a quick sample of code that uses 4 threads to process 4 parts of the image simultaneously. It yields 30% time improvement on my machine. Treat is as a quick and dirty hint, this post is already too long…\n\nUpdate (2013-07-11): I forgot to precalculate (thanks to Axel Rietschin for noticing this). With , execution time dropped from 260ms to 230ms.\n\nUpdate (2018-01-08): If you really want to do some complex and efficient image processing then you should use specialized library like OpenCV. Few months ago I've written \"Detecting a Drone - OpenCV in .NET for Beginners (Emgu CV 3.2, Visual Studio 2017)\" blog post series that will help you do it..."
    },
    {
        "link": "https://stackoverflow.com/questions/24701703/c-sharp-faster-alternatives-to-setpixel-and-getpixel-for-bitmaps-for-windows-f",
        "document": "There's no need for or . Use the above class for direct access to bitmap data.\n\nWith this class, it is possible to set raw bitmap data as 32-bit data. Notice that it is PARGB, which is premultiplied alpha. See Alpha Compositing on Wikipedia for more information on how this works and examples on the MSDN article for BLENDFUNCTION to find out how to calculate the alpha properly.\n\nIf premultiplication might overcomplicate things, use instead. A performance hit occurs when it's drawn, because it's internally being converted to . If the image doesn't have to change prior to being drawn, the work can be done before premultiplication, drawn to a buffer, and further used from there.\n\nAccess to standard members is exposed via the property. Bitmap data is directly accessed using the property.\n\nUsing instead of for raw pixel data\n\nChange both instances of to , and then change this line:\n\nWhen bytes are used, the format is Alpha/Red/Green/Blue in that order. Each pixel takes 4 bytes of data, one for each channel. The GetPixel and SetPixel functions will need to be reworked accordingly or removed.\n\nBenefits to using the above class\n• Memory allocation for merely manipulating the data is unnecessary; changes made to the raw data are immediately applied to the bitmap.\n• There are no additional objects to manage. This implements just like .\n• It does not require an block.\n• Pinned memory cannot be moved. It's a required side effect in order for this kind of memory access to work. This reduces the efficiency of the garbage collector (MSDN Article). Do it only with bitmaps where performance is required, and be sure to them when you're done so the memory can be unpinned.\n\nBecause the property is actually a .NET object, it's straightforward to perform operations using the class.\n\nThe question asks about performance, so here's a table that should show the relative performance between the three different methods proposed in the answers. This was done using a .NET Standard 2 based application and NUnit."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1165942/how-to-convert-the-method-to-use-lockbits-instead",
        "document": "I've answered a similar question here. The code is originally written by Vano Maisuradze with some small modifications. The class is using method and provides fast version of and methods.\n\nHere is the class:\n\nYou can simply modify your code to use the class like this:"
    },
    {
        "link": "https://github.com/SixLabors/ImageSharp/discussions/1807",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    }
]