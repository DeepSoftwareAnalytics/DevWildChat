[
    {
        "link": "https://doc.qt.io/qt-6/qtime.html",
        "document": "The QTime class provides clock time functions. More...\n\nNote: All functions in this class are reentrant.\n\nQTime objects can also be created from a text representation using fromString () and converted to a string representation using toString (). All conversion to and from string formats is done using the C locale. For localized conversions, see QLocale .\n\nQTime provides a full set of operators to compare two QTime objects; an earlier time is considered smaller than a later one; if A. msecsTo (B) is positive, then A < B.\n\nThe addSecs () and addMSecs () functions provide the time a given number of seconds or milliseconds later than a given time. Correspondingly, the number of seconds or milliseconds between two times can be found using secsTo () or msecsTo ().\n\nThe hour (), minute (), second (), and msec () functions provide access to the number of hours, minutes, seconds, and milliseconds of the time. The same information is provided in textual format by the toString () function.\n\nA QTime object is typically created either by giving the number of hours, minutes, seconds, and milliseconds explicitly, or by using the static function currentTime (), which creates a QTime object that represents the system's local time.\n\nQTime uses the 24-hour clock format; it has no concept of AM/PM. Unlike QDateTime , QTime knows nothing about time zones or daylight-saving time (DST).\n\nA QTime object contains a clock time, which it can express as the numbers of hours, minutes, seconds, and milliseconds since midnight. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds. QTime objects should be passed by value rather than by reference to const; they simply package int .\n\nSee also QDate and QDateTime.\n\nThe format parameter determines the format of the result string. If the time is invalid, an empty string will be returned.\n\nThese expressions may be used:\n\nWhen the timezone cannot be determined or no suitable representation of it is available, the forms to represent it may be skipped. See QTimeZone::displayName() for details of when it returns an empty string.\n\nAny non-empty sequence of characters enclosed in single quotes will be included verbatim in the output string (stripped of the quotes), even if it contains formatting characters. Two consecutive single quotes (\"''\") are replaced by a single quote in the output. All other characters in the format string are included verbatim in the output string.\n\nFormats without separators (e.g. \"ddMM\") are supported but must be used with care, as the resulting strings aren't always reliably readable (e.g. if \"dM\" produces \"212\" it could mean either the 2nd of December or the 21st of February).\n\nExample format strings (assuming that the QTime is 14:13:09.042)\n\nSee also fromString(), QDate::toString(), QDateTime::toString(), and QLocale::toString().\n\nConstructs a null time object. For a null time, isNull() returns and isValid() returns . If you need a zero time, use QTime(0, 0). For the start of a day, see QDate::startOfDay().\n\nSee also isNull() and isValid().\n\nh must be in the range 0 to 23, m and s must be in the range 0 to 59, and ms must be in the range 0 to 999.\n\nReturns a QTime object containing a time ms milliseconds later than the time of this object (or earlier if ms is negative).\n\nNote that the time will wrap if it passes midnight. See addSecs() for an example.\n\nReturns a null time if this time is invalid.\n\nSee also addSecs(), msecsTo(), and QDateTime::addMSecs().\n\nReturns a QTime object containing a time s seconds later than the time of this object (or earlier if s is negative).\n\nNote that the time will wrap if it passes midnight.\n\nReturns a null time if this time is invalid.\n\nSee also addMSecs(), secsTo(), and QDateTime::addSecs().\n\nReturns the current time as reported by the system clock.\n\nNote that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.\n\nFurthermore, currentTime() only increases within each day; it shall drop by 24 hours each time midnight passes; and, beside this, changes in it may not correspond to elapsed time, if a daylight-saving transition intervenes.\n\nSee also QDateTime::currentDateTime() and QDateTime::currentDateTimeUtc().\n\nReturns a new QTime instance with the time set to the number of msecs since the start of the day, i.e. since 00:00:00.\n\nIf msecs falls outside the valid range an invalid QTime will be returned.\n\nReturns the time represented in the string as a QTime using the format given, or an invalid time if this is not possible.\n\nSee also toString() and QLocale::toTime().\n\nReturns the QTime represented by the string, using the format given, or an invalid time if the string cannot be parsed.\n\nThese expressions may be used for the format:\n\nAll other input characters will be treated as text. Any non-empty sequence of characters enclosed in single quotes will also be treated (stripped of the quotes) as text and not be interpreted as expressions.\n\nIf the format is not satisfied, an invalid QTime is returned. Expressions that do not expect leading zeroes to be given (h, m, s and z) are greedy. This means that they will use two digits (or three, for z) even if this puts them outside the range of accepted values and leaves too few digits for other sections. For example, the following string could have meant 00:07:10, but the m will grab two digits, resulting in an invalid time:\n\nAny field that is not represented in the format will be set to zero. For example:\n\nSee also toString(), QDateTime::fromString(), QDate::fromString(), QLocale::toTime(), and QLocale::toDateTime().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 6.0.\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 6.0.\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 6.0.\n\nReturns the hour part (0 to 23) of the time.\n\nReturns -1 if the time is invalid.\n\nSee also minute(), second(), and msec().\n\nReturns if the time is null (i.e., the QTime object was constructed using the default constructor); otherwise returns false. A null time is also an invalid time.\n\nReturns if the time is valid; otherwise returns . For example, the time 23:30:55.746 is valid, but 24:12:30 is invalid.\n\nThis is an overloaded function.\n\nReturns if the specified time is valid; otherwise returns false.\n\nThe time is valid if h is in the range 0 to 23, m and s are in the range 0 to 59, and ms is in the range 0 to 999.\n\nReturns the minute part (0 to 59) of the time.\n\nReturns -1 if the time is invalid.\n\nSee also hour(), second(), and msec().\n\nReturns the millisecond part (0 to 999) of the time.\n\nReturns -1 if the time is invalid.\n\nSee also hour(), minute(), and second().\n\nReturns the number of msecs since the start of the day, i.e. since 00:00:00.\n\nReturns the number of milliseconds from this time to t. If t is earlier than this time, the number of milliseconds returned is negative.\n\nBecause QTime measures time within a day and there are 86400 seconds in a day, the result is always between -86400000 and 86400000 ms.\n\nReturns 0 if either time is invalid.\n\nSee also secsTo(), addMSecs(), and QDateTime::msecsTo().\n\nReturns the second part (0 to 59) of the time.\n\nReturns -1 if the time is invalid.\n\nSee also hour(), minute(), and msec().\n\nReturns the number of seconds from this time to t. If t is earlier than this time, the number of seconds returned is negative.\n\nBecause QTime measures time within a day and there are 86400 seconds in a day, the result is always between -86400 and 86400.\n\nsecsTo() does not take into account any milliseconds.\n\nReturns 0 if either time is invalid.\n\nSee also addSecs() and QDateTime::secsTo().\n\nSets the time to hour h, minute m, seconds s and milliseconds ms.\n\nh must be in the range 0 to 23, m and s must be in the range 0 to 59, and ms must be in the range 0 to 999. Returns if the set time is valid; otherwise returns .\n\nThis is an overloaded function.\n\nReturns the time as a string. The format parameter determines the format of the string.\n\nIf format is Qt::TextDate, the string format is HH:mm:ss; e.g. 1 second before midnight would be \"23:59:59\".\n\nIf format is Qt::ISODate, the string format corresponds to the ISO 8601 extended specification for representations of dates, represented by HH:mm:ss. To include milliseconds in the ISO 8601 date, use the format Qt::ISODateWithMs, which corresponds to HH:mm:ss.zzz.\n\nIf the format is Qt::RFC2822Date, the string is formatted in an RFC 2822 compatible way. An example of this formatting is \"23:59:20\".\n\nIf the time is invalid, an empty string will be returned.\n\nSee also fromString(), QDate::toString(), QDateTime::toString(), and QLocale::toString()."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtCore/QTime.html",
        "document": "The QTime class provides clock time functions. More …\n\nA object contains a clock time, which it can express as the numbers of hours, minutes, seconds, and milliseconds since midnight. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds. uses the 24-hour clock format; it has no concept of AM/PM. Unlike , knows nothing about time zones or daylight-saving time (DST). A object is typically created either by giving the number of hours, minutes, seconds, and milliseconds explicitly, or by using the static function , which creates a object that represents the system’s local time. The , , , and functions provide access to the number of hours, minutes, seconds, and milliseconds of the time. The same information is provided in textual format by the function. The and functions provide the time a given number of seconds or milliseconds later than a given time. Correspondingly, the number of seconds or milliseconds between two times can be found using or . provides a full set of operators to compare two objects; an earlier time is considered smaller than a later one; if A. (B) is positive, then A < B.\n\nConstructs a null time object. For a null time, returns and returns . If you need a zero time, use (0, 0). For the start of a day, see . must be in the range 0 to 23, and must be in the range 0 to 59, and must be in the range 0 to 999.\n\nReturns the number of milliseconds that have elapsed since the last time or was called. Note that the counter wraps to zero 24 hours after the last call to or restart. Note that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy. If the system’s clock setting has been changed since the last time or was called, the result is undefined. This can happen when daylight-saving time is turned on or off.\n\nSets this time to the current time and returns the number of milliseconds that have elapsed since the last time or was called. This function is guaranteed to be atomic and is thus very handy for repeated measurements. Call to start the first measurement, and for each later measurement. Note that the counter wraps to zero 24 hours after the last call to or . If the system’s clock setting has been changed since the last time or was called, the result is undefined. This can happen when daylight-saving time is turned on or off.\n\nThis is an overloaded function. Returns the time as a string. The parameter determines the format of the string. If is , the string format is HH:mm:ss; e.g. 1 second before midnight would be “23:59:59”. If is , the string format corresponds to the ISO 8601 extended specification for representations of dates, represented by HH:mm:ss. To include milliseconds in the ISO 8601 date, use the , which corresponds to HH:mm:ss.zzz. The options :, and shall be removed in Qt 6. Their use should be replaced with: or . The options , and shall be removed in Qt 6. Their use should be replaced with: or . If the is , the string is formatted in an RFC 2822 compatible way. An example of this formatting is “23:59:20”. If the time is invalid, an empty string will be returned."
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_versions/freesurfer/lib/qt/qt_doc/html/qtime.html",
        "document": "The QTime class provides clock time functions. More...\n\nNote: All functions in this class are reentrant.\n\nQTime can be used to measure a span of elapsed time using the start (), restart (), and elapsed () functions.\n\nThe time a given number of seconds or milliseconds later than a given time can be found using the addSecs () or addMSecs () functions. Correspondingly, the number of seconds or milliseconds between two times can be found using secsTo () or msecsTo ().\n\nQTime provides a full set of operators to compare two QTime objects. One time is considered smaller than another if it is earlier than the other.\n\nThe hour (), minute (), second (), and msec () functions provide access to the number of hours, minutes, seconds, and milliseconds of the time. The same information is provided in textual format by the toString () function.\n\nA QTime object is typically created either by giving the number of hours, minutes, seconds, and milliseconds explicitly, or by using the static function currentTime (), which creates a QTime object that contains the system's local time. Note that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.\n\nQTime uses the 24-hour clock format; it has no concept of AM/PM. Unlike QDateTime , QTime knows nothing about time zones or daylight savings time (DST).\n\nA QTime object contains a clock time, i.e. the number of hours, minutes, seconds, and milliseconds since midnight. It can read the current time from the system clock and measure a span of elapsed time. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds.\n\nSee also QDate and QDateTime.\n\nConstructs a null time object. A null time can be a QTime(0, 0, 0, 0) (i.e., midnight) object, except that isNull() returns true and isValid() returns false.\n\nSee also isNull() and isValid().\n\nh must be in the range 0 to 23, m and s must be in the range 0 to 59, and ms must be in the range 0 to 999.\n\nReturns a QTime object containing a time ms milliseconds later than the time of this object (or earlier if ms is negative).\n\nNote that the time will wrap if it passes midnight. See addSecs() for an example.\n\nSee also addSecs(), msecsTo(), and QDateTime::addMSecs().\n\nReturns a QTime object containing a time s seconds later than the time of this object (or earlier if s is negative).\n\nNote that the time will wrap if it passes midnight.\n\nSee also addMSecs(), secsTo(), and QDateTime::addSecs().\n\nReturns the current time as reported by the system clock.\n\nNote that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.\n\nReturns the number of milliseconds that have elapsed since the last time start() or restart() was called.\n\nNote that the counter wraps to zero 24 hours after the last call to start() or restart.\n\nNote that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.\n\nWarning: If the system's clock setting has been changed since the last time start() or restart() was called, the result is undefined. This can happen when daylight savings time is turned on or off.\n\nSee also start() and restart().\n\nReturns the time represented in the string as a QTime using the format given, or an invalid time if this is not possible.\n\nNote that fromString() uses a \"C\" locale encoded string to convert milliseconds to a float value. If the default locale is not \"C\", this may result in two conversion attempts (if the conversion fails for the default locale). This should be considered an implementation detail.\n\nReturns the QTime represented by the string, using the format given, or an invalid time if the string cannot be parsed.\n\nThese expressions may be used for the format:\n\nthe hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display) the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display) the minute without a leading zero (0 to 59) the minute with a leading zero (00 to 59) the second without a leading zero (0 to 59) the second with a leading zero (00 to 59) the milliseconds without leading zeroes (0 to 999) the milliseconds with leading zeroes (000 to 999) interpret as an AM/PM time. AP must be either \"AM\" or \"PM\". Interpret as an AM/PM time. ap must be either \"am\" or \"pm\".\n\nAll other input characters will be treated as text. Any sequence of characters that are enclosed in single quotes will also be treated as text and not be used as an expression.\n\nIf the format is not satisfied an invalid QTime is returned. Expressions that do not expect leading zeroes to be given (h, m, s and z) are greedy. This means that they will use two digits even if this puts them outside the range of accepted values and leaves too few digits for other sections. For example, the following string could have meant 00:07:10, but the m will grab two digits, resulting in an invalid time:\n\nAny field that is not represented in the format will be set to zero. For example:\n\nSee also QDateTime::fromString(), QDate::fromString(), and QDate::toString().\n\nReturns the hour part (0 to 23) of the time.\n\nSee also minute(), second(), and msec().\n\nReturns true if the time is null (i.e., the QTime object was constructed using the default constructor); otherwise returns false. A null time is also an invalid time.\n\nReturns true if the time is valid; otherwise returns false. For example, the time 23:30:55.746 is valid, but 24:12:30 is invalid.\n\nThis is an overloaded function.\n\nReturns true if the specified time is valid; otherwise returns false.\n\nThe time is valid if h is in the range 0 to 23, m and s are in the range 0 to 59, and ms is in the range 0 to 999.\n\nReturns the minute part (0 to 59) of the time.\n\nSee also hour(), second(), and msec().\n\nReturns the millisecond part (0 to 999) of the time.\n\nSee also hour(), minute(), and second().\n\nReturns the number of milliseconds from this time to t. If t is earlier than this time, the number of milliseconds returned is negative.\n\nBecause QTime measures time within a day and there are 86400 seconds in a day, the result is always between -86400000 and 86400000 ms.\n\nSee also secsTo(), addMSecs(), and QDateTime::msecsTo().\n\nSets this time to the current time and returns the number of milliseconds that have elapsed since the last time start() or restart() was called.\n\nThis function is guaranteed to be atomic and is thus very handy for repeated measurements. Call start() to start the first measurement, and restart() for each later measurement.\n\nNote that the counter wraps to zero 24 hours after the last call to start() or restart().\n\nWarning: If the system's clock setting has been changed since the last time start() or restart() was called, the result is undefined. This can happen when daylight savings time is turned on or off.\n\nSee also start(), elapsed(), and currentTime().\n\nReturns the second part (0 to 59) of the time.\n\nSee also hour(), minute(), and msec().\n\nReturns the number of seconds from this time to t. If t is earlier than this time, the number of seconds returned is negative.\n\nBecause QTime measures time within a day and there are 86400 seconds in a day, the result is always between -86400 and 86400.\n\nsecsTo() does not take into account any milliseconds.\n\nSee also addSecs() and QDateTime::secsTo().\n\nSets the time to hour h, minute m, seconds s and milliseconds ms.\n\nh must be in the range 0 to 23, m and s must be in the range 0 to 59, and ms must be in the range 0 to 999. Returns true if the set time is valid; otherwise returns false.\n\nSets this time to the current time. This is practical for timing:\n\nSee also restart(), elapsed(), and currentTime().\n\nReturns the time as a string. The format parameter determines the format of the result string.\n\nThese expressions may be used:\n\nthe hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display) the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display) the hour without a leading zero (0 to 23, even with AM/PM display) the hour with a leading zero (00 to 23, even with AM/PM display) the minute without a leading zero (0 to 59) the minute with a leading zero (00 to 59) the second without a leading zero (0 to 59) the second with a leading zero (00 to 59) the milliseconds without leading zeroes (0 to 999) the milliseconds with leading zeroes (000 to 999) use AM/PM display. AP will be replaced by either \"AM\" or \"PM\". use am/pm display. ap will be replaced by either \"am\" or \"pm\". the timezone (for example \"CEST\")\n\nAll other input characters will be ignored. Any sequence of characters that are enclosed in singlequotes will be treated as text and not be used as an expression. Two consecutive singlequotes (\"''\") are replaced by a singlequote in the output.\n\nExample format strings (assuming that the QTime is 14:13:09.042)\n\nIf the datetime is invalid, an empty string will be returned. If format is empty, the default format \"hh:mm:ss\" is used.\n\nSee also QDate::toString() and QDateTime::toString().\n\nThis is an overloaded function.\n\nReturns the time as a string. Milliseconds are not included. The format parameter determines the format of the string.\n\nIf format is Qt::TextDate, the string format is HH:MM:SS; e.g. 1 second before midnight would be \"23:59:59\".\n\nIf format is Qt::ISODate, the string format corresponds to the ISO 8601 extended specification for representations of dates, which is also HH:MM:SS. (However, contrary to ISO 8601, dates before 15 October 1582 are handled as Julian dates, not Gregorian dates. See Use of Gregorian and Julian Calendars. This might change in a future version of Qt.)\n\nIf the format is Qt::SystemLocaleShortDate or Qt::SystemLocaleLongDate, the string format depends on the locale settings of the system. Identical to calling QLocale::system().toString(time, QLocale::ShortFormat) or QLocale::system().toString(time, QLocale::LongFormat).\n\nIf the format is Qt::DefaultLocaleShortDate or Qt::DefaultLocaleLongDate, the string format depends on the default application locale. This is the locale set with QLocale::setDefault(), or the system locale if no default locale has been set. Identical to calling QLocale().toString(time, QLocale::ShortFormat) or QLocale().toString(time, QLocale::LongFormat).\n\nIf the time is invalid, an empty string will be returned.\n\nReturns true if this time is different from t; otherwise returns false.\n\nReturns true if this time is earlier than t; otherwise returns false.\n\nReturns true if this time is earlier than or equal to t; otherwise returns false.\n\nReturns true if this time is equal to t; otherwise returns false.\n\nReturns true if this time is later than t; otherwise returns false.\n\nReturns true if this time is later than or equal to t; otherwise returns false."
    },
    {
        "link": "https://informit.com/articles/article.aspx?p=1149122",
        "document": "This chapter covers three tiny yet useful GUI applications written in PyQt and discusses PyQt's \"signals and slots\" mechanism--a high-level communication mechanism for responding to user interaction that lets you ignore irrelevant detail.\n\nIn this chapter we begin with brief reviews of three tiny yet useful GUI applications written in PyQt. We will take the opportunity to highlight some of the issues involved in GUI programming, but we will defer most of the details to later chapters. Once we have a feel for PyQt GUI programming, we will discuss PyQt's \"signals and slots\" mechanism—this is a high-level communication mechanism for responding to user interaction that allows us to ignore irrelevant detail.\n\nAlthough PyQt is used commercially to build applications that vary in size from hundreds of lines of code to more than 100 000 lines of code, the applications we will build in this chapter are all less than 100 lines, and they show just how much can be done with very little code.\n\nIn this chapter we will design our user interfaces purely by writing code, but in Chapter 7, we will learn how to create user interfaces using Qt's visual design tool, Qt Designer.\n\nPython console applications and Python module files always have a extension, but for Python GUI applications we use a extension. Both and are fine on Linux, but on Windows, ensures that Windows uses the interpreter instead of , and this in turn ensures that when we execute a Python GUI application, no unnecessary console window will appear.* On Mac OS X, it is essential to use the extension.\n\nThe PyQt documentation is provided as a set of HTML files, independent of the Python documentation. The most commonly referred to documents are those covering the PyQt API. These files have been converted from the original C++/Qt documentation files, and their index page is called ; Windows users will find a link to this page in their Start button's PyQt menu. It is well worth looking at this page to get an overview of what classes are available, and of course to dip in and read about those classes that seem interesting.\n\nThe first application we will look at is an unusual hybrid: a GUI application that must be launched from a console because it requires command-line arguments. We have included it because it makes it easier to explain how the PyQt event loop works (and what that is), without having to go into any other GUI details. The second and third examples are both very short but standard GUI applications. They both show the basics of how we can create and lay out widgets (\"controls\" in Windows-speak)—labels, buttons, comboboxes, and other on-screen elements that users can view and, in most cases, interact with. They also show how we can respond to user interactions—for example, how to call a particular function or method when the user performs a particular action.\n\nIn the last section we will cover how to handle user interactions in more depth, and in the next chapter we will cover layouts and dialogs much more thoroughly. Use this chapter to get a feel for how things work, without worrying about the details: The chapters that follow will fill in the gaps and will familiarize you with standard PyQt programming practices.\n\nOur first GUI application is a bit odd. First, it must be run from the console, and second it has no \"decorations\"—no title bar, no system menu, no X close button. Figure 4.1 shows the whole thing.\n\nTo get the output displayed, we could enter a command line like this:\n\nWhen run, the program executes invisibly in the background, simply marking time until the specified time is reached. At that point, it pops up a window with the message text. About a minute after showing the window, the application will automatically terminate.\n\nThe specified time must use the 24-hour clock. For testing purposes we can use a time that has just gone; for example, by using 12:15 when it is really 12:30, the window will pop up immediately (well, within less than a second).\n\nNow that we know what it does and how to run it, we will review the implementation. The file is a few lines longer than 25 lines because we have not counted comment lines and blank lines in the total—but there are only 25 lines of executable code. We will begin with the imports.\n\nWe import the module because we want to access the command-line arguments it holds in the list. The module is imported because we need its function, and we need the PyQt modules for the GUI and for the class.\n\nWe begin by creating a object. Every PyQt GUI application must have a object. This object provides access to global-like information such as the application's directory, the screen size (and which screen the application is on, in a multihead system), and so on. This object also provides the event loop, discussed shortly.\n\nWhen we create a object we pass it the command-line arguments; this is because PyQt recognizes some command-line arguments of its own, such as and , so we ought to give it the chance to read them. If recognizes any of the arguments, it acts on them, and removes them from the list it was given. The list of arguments that recognizes is given in the 's initializer's documentation.\n\nAt the very least, the application requires a time, so we set the variable to the time right now. We also provide a default message. If the user has not given at least one command-line argument (a time), we raise a exception. This will result in the time being now and the message being the \"usage\" error message.\n\nIf the first argument does not contain a colon, a will be raised when we attempt to unpack two items from the call. If the hours or minutes are not a valid number, a will be raised by , and if the hours or minutes are out of range, will be an invalid , and we raise a ourselves. Although Python provides its own date and time classes, the PyQt date and time classes are often more convenient (and in some respects more powerful), so we tend to prefer them.\n\nIf the time is valid, we set the message to be the space-separated concatenation of the other command-line arguments if there are any; otherwise, we leave it as the default \"Alert!\" that we set at the beginning. (When a program is executed on the command line, it is given a list of arguments, the first being the invoking name, and the rest being each sequence of nonwhitespace characters, that is, each \"word\", entered on the command line. The words may be changed by the shell—for example, by applying wildcard expansion. Python puts the words it is actually given in the list.)\n\nNow we know when the message must be shown and what the message is.\n\nWe loop continuously, comparing the current time with the target time. The loop will terminate if the current time is later than the target time. We could have simply put a statement inside the loop, but if we did that Python would loop as quickly as possible, gobbling up processor cycles for no good reason. The command tells Python to suspend processing for the specified number of seconds, 20 in this case. This gives other programs more opportunity to run and makes sense since we don't want to actually do anything while we wait for the due time to arrive.\n\nApart from creating the object, what we have done so far is standard console programming.\n\nWe have created a object, we have a message, and the due time has arrived, so now we can begin to create our application. A GUI application needs widgets, and in this case we need a label to show the message. A can accept HTML text, so we give it an HTML string that tells it to display bold red text of size 72 points.*\n\nIn PyQt, any widget can be used as a top-level window, even a button or a label. When a widget is used like this, PyQt automatically gives it a title bar. We don't want a title bar for this application, so we set the label's window flags to those used for splash screens since they have no title bar. Once we have set up the label that will be our window, we call on it. At this point, the label window is not shown! The call to merely schedules a \"paint event\", that is, it adds a new event to the object's event queue that is a request to paint the specified widget.\n\nNext, we set up a single-shot timer. Whereas the Python library's function takes a number of seconds, the function takes a number of milliseconds. We give the method two arguments: how long until it should time out (one minute in this case), and a function or method for it to call when it times out.\n\nIn PyQt terminology, the function or method we have given is called a \"slot\", although in the PyQt documentation the terms \"callable\", \"Python slot\", and \"Qt slot\" are used to distinguish slots from Python's , a feature of new-style classes that is described in the Python Language Reference. In this book we will use the PyQt terminology, since we never use .\n\nSo now we have two events scheduled: A paint event that wants to take place immediately, and a timer timeout event that wants to take place in a minute's time.\n\nThe call to starts off the object's event loop.* The first event it gets is the paint event, so the label window pops up on-screen with the given message. About one minute later the timer timeout event occurs and the method is called. This method performs a clean termination of the GUI application. It closes any open windows, frees up any resources it has acquired, and exits.\n\nEvent loops are used by all GUI applications. In pseudocode, an event loop looks like this:\n\nWhen the user interacts with the application, or when certain other things occur, such as a timer timing out or the application's window being uncovered (maybe because another application was closed), an event is generated inside PyQt and added to the event queue. The application's event loop continuously checks to see whether there is an event to process, and if there is, it processes it (or passes it on to the event's associated function or method for processing).\n\nAlthough complete, and quite useful if you use consoles, the application uses only a single widget. Also, we have not given it any ability to respond to user interaction. It also works rather like traditional batch-processing programs. It is invoked, performs some processing (waits, then shows a message), and terminates. Most GUI programs work differently. Once invoked, they run their event loop and respond to events. Some events come from the user—for example, key presses and mouse clicks—and some from the system, for example, timers timing out and windows being revealed. They process in response to requests that are the result of events such as button clicks and menu selections, and terminate only when told to do so.\n\nThe next application we will look at is much more conventional than the one we've just seen, and is typical of many very small GUI applications generally."
    },
    {
        "link": "https://yilectronics.com/Courses/CE232/Spring2019/lectures/lecture34_GUI_PyQt_I/lec34_GUI_PyQt_I.html",
        "document": "Lecture 34 GUI - PyQt I\n\n \n\n 1. Introduction: \n\n \n\n This is an introductory PyQt5 tutorial. The purpose of this tutorial is to get you started with the PyQt5 toolkit.\n\n \n\n PyQt5 is a set of Python bindings for Qt5 application framework from Digia. It is available for the Python 2.x and 3.x. This tutorial uses Python 3. Qt library is one of the most powerful GUI libraries. The official home site for PyQt5 is www.riverbankcomputing.co.uk/news. PyQt5 is developed by Riverbank Computing. PyQt5 is implemented as a set of Python modules. It has over 620 classes and 6000 functions and methods. It is a multiplatform toolkit which runs on all major operating systems, including Unix, Windows, and Mac OS. PyQt5 is dual licensed. Developers can choose between a GPL and a commercial license.\n\n \n\n PyQt5 modules PyQt5's classes are divided into several modules, including the following: \n\n \n\n QtCore \n\n QtGui \n\n QtWidgets \n\n QtMultimedia \n\n QtBluetooth \n\n QtNetwork \n\n QtPositioning Enginio \n\n QtWebSockets \n\n QtWebKit \n\n QtWebKitWidgets \n\n QtXml \n\n QtSvg \n\n QtSql \n\n QtTest \n\n \n\n The QtCore module contains the core non-GUI functionality. This module is used for working with time, files and directories, various data types, streams, URLs, mime types, threads or processes. The QtGui contains classes for windowing system integration, event handling, 2D graphics, basic imaging, fonts and text. The QtWidgets module contains classes that provide a set of UI elements to create classic desktop-style user interfaces. The QtMultimedia contains classes to handle multimedia content and APIs to access camera and radio functionality. The QtBluetooth module contains classes to scan for devices and connect and interact with them. The QtNetwork module contains the classes for network programming. These classes facilitate the coding of TCP/IP and UDP clients and servers by making the network programming easier and more portable. The QtPositioning contains classes to determine a position by using a variety of possible sources, including satellite, Wi-Fi, or a text file. The Enginio module implements the client-side library for accessing the Qt Cloud Services Managed Application Runtime. The QtWebSockets module contains classes that implement the WebSocket protocol. The QtWebKit contains classes for a web browser implementation based on the WebKit2 library. The QtWebKitWidgets contains classes for a WebKit1 based implementation of a web browser for use in QtWidgets based applications. \n\n \n\n The QtXml contains classes for working with XML files. This module provides implementation for both SAX and DOM APIs. The QtSvg module provides classes for displaying the contents of SVG files. Scalable Vector Graphics (SVG) is a language for describing two-dimensional graphics and graphical applications in XML. The QtSql module provides classes for working with databases. The QtTest contains functions that enable unit testing of PyQt5 applications.\n\n \n\n \n\n \n\n PyQt5 has QDate, QDateTime, QTime classes to work with date and time. The QDate is a class for working with a calendar date in the Gregorian calendar. It has methods for determining the date, comparing, or manipulating dates. The QTime class works with a clock time. It provides methods for comparing time, determining the time and various other time manipulating methods. The QDateTime is a class that combines both QDate and QTime objects into one object. \n\n \n\n \n\n \n\n PyQt5 has currentDate(), currentTime() and currentDateTime() methods for determining current date and time.\n\n\n\n\n\n The currentDate() method returns the current date.\n\n\n\n \n\n \n\n The date is printed in two different formats by passing the values Qt.ISODate and Qt.DefaultLocaleLongDate to the toString() method.\n\n \n\n \n\n \n\n The currentDateTime() returns the current date and time. Finally, the currentTime() method returns the current time.\n\n \n\n \n\n \n\n You don't have to remember and use all these date and time format. However, I recommend that if you can remember the '.currentDateTime()' method, you can do string slicing to take any information you are interested in the output: \n\n \n\n \n\n \n\n Number of days in a particular month or year :\n\n \n\n The number of days in a particular month is returned by the daysInMonth() method and the number of days in a year by the daysInYear() method.\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n We often need to add or subtract days, seconds, or years to a datetime value.\n\n \n\n \n\n \n\n \n\n \n\n Daylight saving time (DST) is the practice of advancing clocks during summer months so that evening daylight lasts longer. The time is adjusted forward one hour in the beginning of spring and adjusted backward in the autumn to standard time.\n\n \n\n \n\n \n\n \n\n \n\n This is a simple example showing a small window. Yet we can do a lot with this window. We can resize it, maximise it or minimise it. This requires a lot of coding. Someone already coded this functionality. Because it is repeated in most applications, there is no need to code it over again. PyQt5 is a high level toolkit. If we would code in a lower level toolkit, the following code example could easily have hundreds of lines.\n\n \n\n The code below shows a small window on the screen. Here we provide the necessary imports. The basic widgets are located in PyQt5.QtWidgets module.\n\n \n\n \n\n \n\n Every PyQt5 application must create an application object. The sys.argv parameter is a list of arguments from a command line. Python scripts can be run from the shell. It is a way how we can control the startup of our scripts.\n\n \n\n The QWidget widget is the base class of all user interface objects in PyQt5. We provide the default constructor for QWidget. The default constructor has no parent. A widget with no parent is called a window.\n\n \n\n The resize() method resizes the widget. It is 250px wide and 150px high.\n\n \n\n The move() method moves the widget to a position on the screen at x=300, y=300 coordinates.\n\n \n\n We set the title of the window with setWindowTitle(). The title is shown in the titlebar.\n\n \n\n The show() method displays the widget on the screen. A widget is first created in memory and later shown on the screen.\n\n \n\n Finally, we enter the mainloop of the application. The event handling starts from this point. The mainloop receives events from the window system and dispatches them to the application widgets. The mainloop ends if we call the exit() method or the main widget is destroyed. The sys.exit() method ensures a clean exit. The environment will be informed how the application ended. The exec_() method has an underscore. It is because the exec is a Python keyword. And thus, exec_() was used instead.\n\n \n\n \n\n \n\n find a picture online in the '.png' format. Right click the figure and save it as 'web.png' to the same directory as your current '.py' file. Use the following code to add an icon to the window: \n\n \n\n An application icon:find a picture online in the '.png' format. Right click the figure and save it as 'web.png' to the same directory as your current '.py' file. Use the following code to add an icon to the window: The previous example was coded in a procedural style. Python programming language supports both procedural and object oriented programming styles. Programming in PyQt5 means programming in OOP. Three important things in object oriented programming are classes, data, and methods. Here we create a new class called Example. The Example class inherits from the QWidget class. This means that we call two constructors: the first one for the Example class and the second one for the inherited class. The super() method returns the parent object of the Example class and we call its constructor. The __init__() method is a constructor method in Python language. The creation of the GUI is delegated to the initUI() method. All three methods have been inherited from the QWidget class. The setGeometry() does two things: it locates the window on the screen and sets it size. The first two parameters are the x and y positions of the window. The third is the width and the fourth is the height of the window. In fact, it combines the resize() and move() methods in one method. The last method sets the application icon. To do this, we have created a QIcon object. The QIcon receives the path to our icon to be displayed. The application and example objects are created. The main loop is started.\n\n \n\n \n\n \n\n In this example, we show a tooltip for two PyQt5 widgets.\n\n \n\n This static method sets a font used to render tooltips. We use a 10pt SansSerif font. <b>QWidget</b> will bold the font. This is a CSS script. \n\n \n\n To create a tooltip, we call the setTooltip() method. We can use rich text formatting.\n\n \n\n We create a push button widget and set a tooltip for it. The date is printed in two different formats by passing the values Qt.ISODate and Qt.DefaultLocaleLongDate to the toString() method.The currentDateTime() returns the current date and time. Finally, the currentTime() method returns the current time.You don't have to remember and use all these date and time format. However, I recommend that if you can remember the '.currentDateTime()' method, you can do string slicing to take any information you are interested in the output:The number of days in a particular month is returned by the daysInMonth() method and the number of days in a year by the daysInYear() method.We often need to add or subtract days, seconds, or years to a datetime value.Daylight saving time (DST) is the practice of advancing clocks during summer months so that evening daylight lasts longer. The time is adjusted forward one hour in the beginning of spring and adjusted backward in the autumn to standard time.This is a simple example showing a small window. Yet we can do a lot with this window. We can resize it, maximise it or minimise it. This requires a lot of coding. Someone already coded this functionality. Because it is repeated in most applications, there is no need to code it over again. PyQt5 is a high level toolkit. If we would code in a lower level toolkit, the following code example could easily have hundreds of lines.The code below shows a small window on the screen. Here we provide the necessary imports. The basic widgets are located in PyQt5.QtWidgets module.Every PyQt5 application must create an application object. The sys.argv parameter is a list of arguments from a command line. Python scripts can be run from the shell. It is a way how we can control the startup of our scripts.The QWidget widget is the base class of all user interface objects in PyQt5. We provide the default constructor for QWidget. The default constructor has no parent. A widget with no parent is called a window.The resize() method resizes the widget. It is 250px wide and 150px high.The move() method moves the widget to a position on the screen at x=300, y=300 coordinates.We set the title of the window with setWindowTitle(). The title is shown in the titlebar.The show() method displays the widget on the screen. A widget is first created in memory and later shown on the screen.Finally, we enter the mainloop of the application. The event handling starts from this point. The mainloop receives events from the window system and dispatches them to the application widgets. The mainloop ends if we call the exit() method or the main widget is destroyed. The sys.exit() method ensures a clean exit. The environment will be informed how the application ended. The exec_() method has an underscore. It is because the exec is a Python keyword. And thus, exec_() was used instead.The previous example was coded in a procedural style. Python programming language supports both procedural and object oriented programming styles. Programming in PyQt5 means programming in OOP. Three important things in object oriented programming are classes, data, and methods. Here we create a new class called Example. The Example class inherits from the QWidget class. This means that we call two constructors: the first one for the Example class and the second one for the inherited class. The super() method returns the parent object of the Example class and we call its constructor. The __init__() method is a constructor method in Python language. The creation of the GUI is delegated to the initUI() method. All three methods have been inherited from the QWidget class. The setGeometry() does two things: it locates the window on the screen and sets it size. The first two parameters are the x and y positions of the window. The third is the width and the fourth is the height of the window. In fact, it combines the resize() and move() methods in one method. The last method sets the application icon. To do this, we have created a QIcon object. The QIcon receives the path to our icon to be displayed. The application and example objects are created. The main loop is started.In this example, we show a tooltip for two PyQt5 widgets.This static method sets a font used to render tooltips. We use a 10pt SansSerif font. QWidget will bold the font. This is a CSS script.To create a tooltip, we call the setTooltip() method. We can use rich text formatting.We create a push button widget and set a tooltip for it.\n\nThe move() method moves the widget to a position on the screen at x=50, y=50 coordinates.\n\n\n\n The button is being resized and moved on the window. The sizeHint() method gives a recommended size for the button.\n\n \n\n \n\n \n\n \n\n \n\n In this example, we create a quit button. Upon clicking on the button, the application terminates. \n\n \n\n We create a push button. The button is an instance of the QPushButton class. The first parameter of the constructor is the label of the button. The second parameter is the parent widget. The parent widget is the Example widget, which is a QWidget by inheritance.\n\n \n\n The event processing system in PyQt5 is built with the signal & slot mechanism. If we click on the button, the signal clicked is emitted. The slot can be a Qt slot or any Python callable. QCoreApplication, which is retrieved with QApplication.instance(), contains the main event loop—it processes and dispatches all events. The clicked signal is connected to the quit() method which terminates the application. The communication is done between two objects: the sender and the receiver. The sender is the push button, the receiver is the application object.\n\n \n\n \n\n \n\n By default, if we click on the x button on the titlebar, the QWidget is closed. Sometimes we want to modify this default behaviour. For example, if we have a file opened in an editor to which we did some changes. We show a message box to confirm the action.\n\n \n\n \n\n \n\n If we close a QWidget, the is generated. To modify the widget behaviour we need to reimplement the closeEvent() event handler.\n\n \n\n We show a message box with two buttons: Yes and No. The first string appears on the titlebar. The second string is the message text displayed by the dialog. The third argument specifies the combination of buttons appearing in the dialog. The last parameter is the default button . It is the button which has initially the keyboard focus. The return value is stored in the reply variable.\n\n \n\n \n\n \n\n The following script shows how we can center a window on the desktop screen.\n\n \n\n \n\n \n\n The QDesktopWidget class provides information about the user's desktop, including the screen size.\n\n \n\n The code that will center the window is placed in the custom center() method.\n\n \n\n We get a rectangle specifying the geometry of the main window. This includes any window frame.\n\n \n\n We figure out the screen resolution of our monitor. And from this resolution, we get the center point.\n\n \n\n Our rectangle has already its width and height. Now we set the center of the rectangle to the center of the screen. The rectangle's size is unchanged.\n\n \n\n We move the top-left point of the application window to the top-left point of the qr rectangle, thus centering the window on our screen. \n\n\n\n\n\nIn this part of the PyQt5 tutorial, we have created simple code examples in PyQt5.\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n :\n\n \n\n 1. Start a new repository called 'PyQt_GUI' in your GitHub account. Code up all these examples in this tutorial in one .py file and 'push' it to your GUI repository. Send the link of the repository to the homework email. \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n The button is being resized and moved on the window. The sizeHint() method gives a recommended size for the button.In this example, we create a quit button. Upon clicking on the button, the application terminates.We create a push button. The button is an instance of the QPushButton class. The first parameter of the constructor is the label of the button. The second parameter is the parent widget. The parent widget is the Example widget, which is a QWidget by inheritance.The event processing system in PyQt5 is built with the signal & slot mechanism. If we click on the button, the signal clicked is emitted. The slot can be a Qt slot or any Python callable. QCoreApplication, which is retrieved with QApplication.instance(), contains the main event loop—it processes and dispatches all events. The clicked signal is connected to the quit() method which terminates the application. The communication is done between two objects: the sender and the receiver. The sender is the push button, the receiver is the application object.By default, if we click on the x button on the titlebar, the QWidget is closed. Sometimes we want to modify this default behaviour. For example, if we have a file opened in an editor to which we did some changes. We show a message box to confirm the action.If we close a QWidget, theis generated. To modify the widget behaviour we need to reimplement the closeEvent() event handler.We show a message box with two buttons: Yes and No. The first string appears on the titlebar. The second string is the message text displayed by the dialog. The third argument specifies the combination of buttons appearing in the dialog.. It is the button which has initially the keyboard focus. The return value is stored in the reply variable.The following script shows how we can center a window on the desktop screen.The QDesktopWidget class provides information about the user's desktop, including the screen size.The code that will center the window is placed in the custom center() method.We get a rectangle specifying the geometry of the main window. This includes any window frame.We figure out the screen resolution of our monitor. And from this resolution, we get the center point.Our rectangle has already its width and height. Now we set the center of the rectangle to the center of the screen. The rectangle's size is unchanged.We move the top-left point of the application window to the top-left point of the qr rectangle, thus centering the window on our screen.In this part of the PyQt5 tutorial, we have created simple code examples in PyQt5.1. Start a new repository called 'PyQt_GUI' in your GitHub account. Code up all these examples in this tutorial in one .py file and 'push' it to your GUI repository. Send the link of the repository to the homework email."
    },
    {
        "link": "https://stackoverflow.com/questions/11651852/how-to-use-qtimer",
        "document": "In Qt I'm trying to set a that calls a function called \"update\" every second. Here is my .cpp file:\n\nThe project is being build, but it doesn't execute update, since the line \"update\" is not showing anywhere... Does anybody see what I´m doing wrong?"
    },
    {
        "link": "https://pythonpyqt.com/qtimer",
        "document": "If you’re developing applications where specific tasks are executed periodically, the from PyQt5 is an indispensable tool. For instance, consider an application that routinely checks the host’s CPU value.\n\nensures functionality by emitting a Timeout signal. On receiving this signal, the window’s control will cease the timer.\n\nTwo primary methods of include for initiating the timer and to halt it.\n\nIn the sample application described below, we have two buttons: start and stop. Initiating the start button activates the , updating the time display every second.\n• None A timer is initialized and its timeout signal is connected to the function:\n• None The function retrieves and displays the system’s current time:\n• None On pressing the Start button, the timer starts and the button is deactivated:\n• None The end button halts the timer and disables itself:"
    },
    {
        "link": "https://stackoverflow.com/questions/74038574/pyqt5-qtimer-10ms-is-not-accurate-with-qeventloop-and-qasync-in-gui-app",
        "document": "I have a weird behaviour with QTimer in PyQT5 when I try to measure frames and frequency. If you set a timer with 10ms = 1 / 100 every signal message gives the time every time. It works with the following snippet but then with another app with QEventLoop/qasync has a big latency.\n\nFirst of all I have this sample code snippet:\n\nIt's pretty simple, write every time elapsed time and frame count. A sample output (tail of file):\n\nYou can divide 2082 / 20.83 = 100 (aprox.) then is the real frequency 10ms = 1/100 Good! But...\n\n... I have a GUI PyQt5 app with EventLoop and Qasync. I put the main of the app:\n\nAnd QMainWindow class (a snippet with important code), I have the timer signal:\n\nIt's double time. And I have tried timestamps, PreciseTimer, but always I have the same behaviour.\n\nI don't know what happens with timer signals in PyQt5 with EventLoop or/and qasync. Someone could send me some tips to resolve this or investigate the solution.\n\nI appreciate your help Kind Regards"
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtCore/QTimer.html",
        "document": "The class provides a high-level programming interface for timers. To use it, create a , connect its signal to the appropriate slots, and call . From then on, it will emit the signal at constant intervals.\n\nExample for a one second (1000 millisecond) timer (from the Analog Clock example):\n\nFrom then on, the slot is called every second.\n\nYou can set a timer to time out only once by calling (true). You can also use the static function to call a slot after a specified interval:\n\nIn multithreaded applications, you can use in any thread that has an event loop. To start an event loop from a non-GUI thread, use . Qt uses the timer’s to determine which thread will emit the signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.\n\nAs a special case, a with a timeout of 0 will time out as soon as possible, though the ordering between zero timers and other sources of events is unspecified. Zero timers can be used to do some work while still providing a snappy user interface:\n\nFrom then on, will be called repeatedly. It should be written in such a way that it always returns quickly (typically after processing one data item) so that Qt can deliver events to the user interface and stop the timer as soon as it has done all its work. This is the traditional way of implementing heavy work in GUI applications, but as multithreading is nowadays becoming available on more and more platforms, we expect that zero-millisecond objects will gradually be replaced by s."
    },
    {
        "link": "https://forum.qt.io/topic/81861/how-to-use-qtimer-in-right-way",
        "document": "Hi,\n\n I'm new with Qt and use QTimer but It does not work as my expecting. My issue is:\n\n I have a button. When the button is activated, It will show a QWidget and start countdown timer 8 second to hide the QWidget. However, I want restart countdown timer to 8 second if the button is activated again and countdown timer is less than 8 second.\n\n This is my code:\n\nActually, this code does work as my expecting. If I activate button in countdown time, it does not reset coundown timer and still emit hideMessageAtn() in the timeout.\n\n So anyone give me in this case ?\n\n Thank in advance."
    }
]