[
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/relation-queries",
        "document": "A key feature of Prisma Client is the ability to query relations between two or more models. Relation queries include:\n• Nested reads (sometimes referred to as eager loading) via and\n\nPrisma Client also has a fluent API for traversing relations.\n\nNested reads allow you to read related data from multiple tables in your database - such as a user and that user's posts. You can:\n• Use to include related records, such as a user's posts or profile, in the query response.\n• Use a nested to include specific fields from a related record. You can also nest inside an .\n\nSince version 5.8.0 , you can decide on a per-query-level how you want Prisma Client to execute a relation query (i.e. what load strategy should be applied) via the option for PostgreSQL databases.\n\nSince version 5.10.0 , this feature is also available for MySQL.\n\nBecause the option is currently in Preview, you need to enable it via the preview feature flag in your Prisma schema file:\n\nAfter adding this flag, you need to run again to re-generate Prisma Client. This feature is currently available on PostgreSQL, CockroachDB and MySQL.\n• (default): Uses a database-level (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\n• : Sends multiple queries to the database (one per table) and joins them on the application level.\n\nAnother important difference between these two options is that the strategy uses JSON aggregation on the database level. That means that it creates the JSON structures returned by Prisma Client already in the database which saves computation resources on the application level.\n\nYou can use the option on the top-level in any query that supports or .\n\nHere is an example with :\n\nAnd here is another example with :\n• The strategy (default) will be more effective in most scenarios. On PostgreSQL, it uses a combination of and JSON aggregation to reduce redundancy in result sets and delegate the work of transforming the query results into the expected JSON structures on the database server. On MySQL, it uses correlated subqueries to fetch the results with a single query.\n• There may be edge cases where could be more performant depending on the characteristics of the dataset and query. We recommend that you profile your database queries to identify these situations.\n• Use if you want to save resources on the database server and do heavy-lifting of merging and transforming data in the application server which might be easier to scale.\n\nThe following example returns a single user and that user's posts:\n\nThe following example returns a post and its author:\n\nYou can nest options to include relations of relations. The following example returns a user's posts, and each post's categories:\n\nYou can use a nested to choose a subset of fields of relations to return. For example, the following query returns the user's and the of each related post:\n\nYou can also nest a inside an - the following example returns all fields and the field of each post:\n\nNote that you cannot use and on the same level. This means that if you choose to a user's post and each post's title, you cannot only the users' :\n\nIn 3.0.1 and later, you can or a count of relations alongside fields - for example, a user's post count.\n\nWhen you use or to return a subset of the related data, you can filter and sort the list of relations inside the or .\n\nFor example, the following query returns list of titles of the unpublished posts associated with the user:\n\nYou can also write the same query using as follows:\n\nA nested write allows you to write relational data to your database in a single transaction.\n• Provide transactional guarantees for creating, updating or deleting data across multiple tables in a single Prisma Client query. If any part of the query fails (for example, creating a user succeeds but creating posts fails), Prisma Client rolls back all changes.\n• Support any level of nesting supported by the data model.\n• Are available for relation fields when using the model's create or update query. The following section shows the nested write options that are available per query.\n\nYou can create a record and one or more related records at the same time. The following query creates a record and two related records:\n\nThere are two ways to create or update a single record and multiple related records - for example, a user with multiple posts:\n\nIn most cases, a nested will be preferable unless the query option is required. Here's a quick table describing the differences between the two options:\n\nThe following query uses nested to create:\n\nThe example also uses a nested to include all posts and post categories in the returned data.\n\nHere's a visual representation of how a nested create operation can write to several tables in the database as once:\n\nThe following query uses a nested to create:\n\nThe example also uses a nested to include all posts in the returned data.\n\nNote that it is not possible to nest an additional or inside the highlighted query, which means that you cannot create a user, posts, and post categories at the same time.\n\nAs a workaround, you can send a query to create the records that will be connected first, and then create the actual records. For example:\n\nIf you want to create all records in a single database query, consider using a or type-safe, raw SQL.\n\nYou cannot access relations in a or query, which means that you cannot create multiple users and multiple posts in a single nested write. The following is not possible:\n\nThe following query creates ( ) a new record and connects that record ( ) to three existing posts:\n\nYou can an existing record to a new or existing user. The following query connects an existing post ( ) to an existing user ( )\n\nIf a related record may or may not already exist, use to connect the related record:\n• Connect a with the email address or\n• Create a new with the email address if the user does not already exist\n\nTo one out of a list of records (for example, a specific blog post) provide the ID or unique identifier of the record(s) to disconnect:\n\nTo one record (for example, a post's author), use :\n\nTo all related records in a one-to-many relation (a user has many posts), the relation to an empty list as shown:\n\nYou can use a nested to update all related records for a particular user. The following query unpublishes all posts for a specific user:\n\nThe following query uses a nested to update if that user exists, or create the user if they do not exist:\n\nYou can nest or inside an to add new related records to an existing record. The following query adds two posts to a user with an of 9:\n\nPrisma Client provides the , , and options to filter records by the properties of related records on the \"-to-many\" side of the relation. For example, filtering users based on properties of their posts.\n\nFor example, the following query returns that meet the following criteria:\n• No posts with more than 100 views\n• All posts have less than, or equal to 50 likes\n\nPrisma Client provides the and options to filter records by the properties of related records on the \"-to-one\" side of the relation. For example, filtering posts based on properties of their author.\n\nFor example, the following query returns records that meet the following criteria:\n• Author's name is not Bob\n\nFor example, the following query uses to return all users that have zero posts:\n\nThe following query returns all posts that don't have an author relation:\n\nThe following query returns all users with at least one post:\n\nThe fluent API lets you fluently traverse the relations of your models via function calls. Note that the last function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).\n\nThis query returns all records by a specific :\n\nThis is equivalent to the following query:\n\nThe main difference between the queries is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this GitHub issue )\n\nThis request returns all categories by a specific post:\n\nNote that you can chain as many queries as you like. In this example, the chaining starts at and goes over to :\n\nThe only requirement for chaining is that the previous function call must return only a single object (e.g. as returned by a query or a \"to-one relation\" like ).\n\nThe following query is not possible because does not return a single object but a list:"
    },
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/select-fields",
        "document": "By default, when a query returns records (as opposed to a count), the result includes:\n\nAs an example, consider this schema:\n\nA query to the model will include the , , and fields (because these are scalar fields), but not the field (because that's a relation field):\n\nIf you want to customize the result and have a different combination of fields returned, you can:\n• Use to return specific fields. You can also use a nested by selecting relation fields.\n• Use to exclude specific fields from the result. can be seen as the \"opposite\" to .\n\nIn all cases, the query result will be statically typed, ensuring that you don't accidentally access any fields that you did not actually query from the database.\n\nSelecting only the fields and relations that you require rather than relying on the default selection set can reduce the size of the response and improve query speed.\n\nSince version 5.9.0 , when doing a relation query with or by using on a relation field, you can also specify the to decide whether you want to use a database-level join or perform multiple queries and merge the data on the application level. This feature is currently in Preview, you can learn more about it here.\n\nAll following examples on this page are based on the following schema:\n\nThe following query returns the default fields (all scalar fields, no relations):\n\nUse to return a subset of fields instead of all fields. The following example returns the and fields only:\n\nYou can also return relations by nesting multiple times on relation fields.\n\nThe following query uses a nested to select each user's and the of each related post:\n\nThe following query uses within an , and returns all user fields and each post's field:\n\nYou can nest your queries arbitrarily deep. The following query fetches:\n• the of the related\n• the of the related\n\nFor more information about querying relations, refer to the following documentation:\n\nThere may be situations when you want to return most fields of a model, excluding only a small subset. A common example for this is when you query a but want to exclude the field for security reasons.\n\nIn these cases, you can use , which can be seen as the counterpart to :\n\nNotice how the returned object does not contain the field.\n\nIn 3.0.1 and later, you can or a count of relations alongside fields. For example, a user's post count."
    },
    {
        "link": "https://prisma.io/docs/orm/reference/prisma-client-reference",
        "document": "The Prisma Client API reference documentation is based on the following schema:\n\nAll example generated types (such as and ) are based on the model.\n\nThis section describes the constructor and its parameters.\n\nProgrammatically overrides properties of the block in the file - for example, as part of an integration test. See also: Data sources\n\nFrom version 5.2.0 and upwards, you can also use the property to programmatically override the database connection string.\n• You must re-generate Prisma Client each time you add or rename a data source. Datasource names are included in the generated client.\n• If you named your block something else in the schema, replace with the name of your block.\n\nBased on the following block:\n\nProgrammatically overrides the block in the file.\n\nDetermines the type and level of logging. See also: Logging\n\nNote that for MongoDB, the and fields will be undefined.\n\nDetermines the level and formatting of errors returned by Prisma Client.\n\nDefines an instance of a driver adapter. See also Database drivers .\n\nThe example below uses the Neon driver adapter\n\nUse the parameter to configure and/or to throw an error if the record was not found. By default, both operations return if the record is not found.\n• You can configure on a per-request level for both and\n\nAllows to set transaction options globally on the constructor level.\n• The transaction levels can be overridden on a per-transaction level.\n\nUse model queries to perform CRUD operations on your models. See also: CRUD\n• Prisma Client's dataloader automatically batches queries with the same and parameters.\n• If you want the query to throw an error if the record is not found, then consider using instead.\n• You cannot use filter conditions (e.g. , , ) to filter fields of the JSON data type. Using filter conditions will likely result in a response for that field.\n\nretrieves a single record in the same way as . However, if the query does not find the requested record, it throws a .\n\nNote that before Prisma v6, it would throw a .\n\nHere’s an example of its usage:\n\ndiffers from as follows:\n• Its return type is non-nullable. For example, can return or , but always returns .\n• It is not compatible with sequential operations in the API. If the query throws a , then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the API, as follows:\n\nreturns the first record in a list that matches your criteria.\n• If you want the query to throw an error if the record is not found, then consider using instead.\n• calls behind the scenes and accepts the same query options.\n• Passing in a negative value when you use a query reverses the order of the list.\n\nSee Filter conditions and operators for examples of how to filter results.\n\nretrieves a single data record in the same way as . However, if the query does not find a record, it throws a .\n\nNote that before Prisma v6, it would throw a .\n\ndiffers from as follows:\n• Its return type is non-nullable. For example, can return or , but always returns .\n• It is not compatible with sequential operations in the API. If the query returns , then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the API, as follows:\n\nSee Filter conditions and operators for examples of how to filter results.\n• You can also perform a nested - for example, add a and two records at the same time.\n\nIn most cases, you can carry out batch inserts with the or queries. However, there are scenarios where is the best option to insert multiple records.\n\nThe following example results in two statements:\n• To perform arithmetic operations on update (add, subtract, multiply, divide), use atomic updates to prevent race conditions.\n• You can also perform a nested - for example, update a user and that user's posts at the same time.\n\ndoes the following:\n• If an existing database record satisfies the condition, it updates that record\n• If no database record satisfies the condition, it creates a new database record\n• To perform arithmetic operations on update (add, subtract, multiply, divide), use atomic updates to prevent race conditions.\n• If two or more upsert operations happen at the same time and the record doesn't already exist, then a race condition might happen. As a result, one or more of the upsert operations might throw a unique key constraint error. Your application code can catch this error and retry the operation. Learn more.\n• From version 4.6.0, Prisma ORM hands over upsert queries to the database where possible. Learn more.\n\nIf multiple upsert operations happen at the same time and the record doesn't already exist, then one or more of the operations might return a unique key constraint error.\n\nWhen Prisma Client does an upsert, it first checks whether that record already exists in the database. To make this check, Prisma Client performs a read operation with the clause from the upsert operation. This has two possible outcomes, as follows:\n• If the record does not exist, then Prisma Client creates that record.\n• If the record exists, then Prisma Client updates it.\n\nWhen your application tries to perform two or more concurrent upsert operations, then a race condition might happen where two or more operations do not find the record and therefore try to create that record. In this situation, one of the operations successfully creates the new record but the other operations fail and return a unique key constraint error.\n\nHandle the P2002 error in your application code. When it occurs, retry the upsert operation to update the row.\n\nWhere possible, Prisma Client hands over an query to the database. This is called a database upsert.\n\nDatabase upserts have the following advantages:\n• They are faster than upserts handled by Prisma Client\n\nPrisma Client uses a database upsert automatically when specific criteria are met. When these criteria are not met, Prisma Client handles the .\n\nTo use a database upsert, Prisma Client sends the SQL construction to the database.\n\nPrisma Client can use database upserts if your stack meets the following criteria:\n• You use Prisma ORM version 4.6.0 or later\n• Your application uses a CockroachDB, PostgreSQL, or SQLite data source\n\nPrisma Client uses a database upsert for an query when the query meets the following criteria:\n• There are no nested queries in the 's and options\n• The query does not include a selection that uses a nested read\n• The query modifies only one model\n• There is only one unique field in the 's option\n• The unique field in the option and the unique field in the option have the same value\n\nIf your query does not meet these criteria, then Prisma Client handles the upsert itself.\n\nThe following examples use this schema:\n\nThe following query meets all of the criteria, so Prisma Client uses a database upsert.\n\nIn this situation, Prisma uses the following SQL query:\n\nThe following query has multiple unique values in the clause, so Prisma Client does not use a database upsert:\n\nIn the following query, the values for in the and options are different, so Prisma Client does not use a database upsert.\n\nIn the following query, the selection on the field in is a nested read, so Prisma Client does not use a database upsert.\n\ndeletes an existing database record. You can delete a record:\n\nTo delete records that match a certain criteria, use with a filter.\n• To delete multiple records based on some criteria (for example, all records with a email address, use )\n\nThe following query deletes a specific user record and uses to return the and of the deleted user:\n• As of Prisma ORM version 5.12.0, is now supported by SQLite.\n• The option is not supported by MongoDB, SQLServer, or SQLite.\n• You cannot create or connect relations by using nested , , , queries inside a top-level query. See here for a workaround.\n• You can use a nested query inside an or query - for example, add a and two records with a nested at the same time.\n• The option is not supported by SQLite.\n• You cannot create or connect relations by using nested , , , queries inside a top-level query. See here for a workaround.\n• When relations are included via , a separate query is generated per relation.\n\nupdates a batch of existing database records in bulk and returns the number of updated records.\n\nSee Filter conditions and operators for examples of how to filter the records to delete.\n• A count of all records with non- fields\n• A count of all records with non- fields\n\nSee also: Aggregation, grouping, and summarizing\n\nSee also: Aggregation, grouping, and summarizing\n\nThe query also returns a count of records in each group, and all records with non- field values in each group.\n\ndefines which fields are included in the object that Prisma Client returns. See: Select fields and include relations .\n• You cannot combine and on the same level.\n• In 3.0.1 and later, you can select a of relations.\n\nThe following example demonstrates how to use the with :\n\ndefines which relations are included in the result that Prisma Client returns. See: Select fields and include relations .\n• In 3.0.1 and later, you can a of relations\n\nThe following example demonstrates how to use the with :\n\ndefines which fields are excluded in the object that Prisma Client returns.\n• You cannot combine and since they serve opposite purposes\n• was released into General Availability with Prisma ORM 6.2.0. It was available via the Preview feature in Prisma ORM versions through .\n\nThe following example demonstrates how to use the with :\n\nspecifies how a relation should be loaded from the database. It has two possible values:\n• (default): Uses a database-level (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\n• : Sends multiple queries to the database (one per table) and joins them on the application level.\n\nYou can learn more about join strategies here.\n\nBecause the option is currently in Preview, you need to enable it via the preview feature flag in your Prisma schema file:\n\nAfter adding this flag, you need to run again to re-generate Prisma Client. This feature is currently available on PostgreSQL, CockroachDB and MySQL.\n• In most situations, the default strategy will be more effective. Use if you want to save resources on your database server or if you profiling shows that the application-level join is more performant.\n• You can only specify the on the top-level in your query. The top-level choice will affect all nested sub-queries.\n\ndefines one or more filters, and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).\n\nThe following examples demonstrate how to use the with :\n• This type works by exposing any unique fields on the model. A field assigned is considered unique, as is one assigned . From version 4.5.0, this type exposes all fields on the model. This means that when you filter for a single record based on a unique field, you can check additional non-unique and unique fields at the same time. Learn more.\n• - This type accepts a unique field (an or another assigned ) and updates any field on the model except the . The is the scalar field on the model. 'This is some updated content' \n\n 'This is a new title'\n• - This type will update the records title field where the id matches, if it doesn't exist it will create it instead. 'This is a new title' \n\n 'If the title doesnt exist, then create one with this text'\n• - This type will update all records where published is set to false.\n\nSorts a list of records. See also: Sorting\n• In 2.16.0 and later, you can order by relation fields - for example, order posts by the author's name.\n• In 3.5.0 and later, in PostgreSQL you can order by relevance. For details, see Sort by relevance.\n• In 4.1.0 and later, you can sort records first or last. For details, see Sort with nulls first or last.\n• It is for use on optional scalar fields only. If you try to sort by nulls on a required or relation field, Prisma Client throws a P2009 error.\n• It is available in version 4.1.0 and later, as a preview feature. See sort with nulls first or last for details of how to enable the feature.\n\nThe following example returns all records sorted by ascending:\n\nThe following example returns all records sorted by descending:\n\nThe following query orders posts by user name:\n\nThe following query orders posts by user name, with records first:\n\nThe following query orders posts by relevance of the search term to the title:\n\nThe following query orders users by post count:\n\nThe following example sorts users by two fields - first , then :\n\nThe order of sorting parameters matters - the following query sorts by , then . Not the difference in the results:\n\nThe following example returns all the and fields of all records, sorted by :\n\nThe following example:\n• For each record, returns the field of all nested records sorted by\n\nThe following example retrieves a single record by ID, as well as a list of nested records sorted by :\n\nThe following sorts all records by (an ):\n\nThe following examples demonstrate how to use the with :\n\nDeduplicate a list of records from or . See also: Aggregation, grouping, and summarizing\n\nThe following example returns all distinct fields, and selects only the and fields:\n\nThe following example returns all distinct and field combinations, and selects only the and fields:\n\nNote that there is now a \"Paris, Denmark\" in addition to \"Paris, France\":\n\nThe following example returns all distinct and field combinations where the user's email contains , and selects only the and fields:\n\nEnabling in your Prisma schema pushes the operation to the database layer (where supported). This can significantly improve performance. However, note that:\n• Some databases may not fully support DISTINCT on certain field combinations.\n\nSee Preview Features for more details.\n\nA nested query adds a new related record or set of records to a parent record. See: Working with relations\n• is available as a nested query when you ( ) a new parent record or ( ) an existing parent record.\n• You can use a nested or a nested to create multiple related records. If you require the query option you should use .\n\nBecause it's a one-to-many relation, you can also create multiple records at once by passing an array to :\n\nNote: You can also use a nested to achieve the same result.\n\nA nested query adds a new set of records to a parent record. See: Working with relations\n• is available as a nested query when you ( ) a new parent record or ( ) an existing parent record.\n• Available in the context of a one-to-many relation — for example, you can a user and use a nested to create multiple posts (posts have one user).\n• Not available in the context of a many-to-many relation — for example, you cannot a post and use a nested to create categories (many posts have many categories).\n• You cannot nest an additional or .\n• Allows setting foreign keys directly — for example, setting the on a post.\n• As of Prisma ORM version 5.12.0, nested is supported by SQLite.\n• You can use a nested or a nested to create multiple related records - if you do not need the query option, you should probably use .\n\noverwrites the value of a relation - for example, replacing a list of records with a different list. See: Working with relations\n\nA nested query connects a record to an existing related record by specifying an ID or unique identifier. See: Working with relations\n• is available as a nested query when you create a new parent record or update an existing parent record.\n• If the related record does not exist, Prisma Client throws an exception: The required connected records were not found. Expected 1 records to be connected, found 0.\n• When using and together, the order in which they are applied significantly impacts the result. If is used before , the connected records will only reflect the final state established by the operation, as clears all existing connections before establishes new ones. Conversely, if is applied before , the operation will override the action by clearing all connected records and replacing them with its own specified state.\n\nIn 2.11.0 and later, you can set the foreign key directly:\n\nHowever, you can't use both the direct approach and the approach in the same query. See this issue comment for details.\n\neither connects a record to an existing related record by ID or unique identifier or creates a new related record if the record does not exist. See: Working with relations\n• Multiple queries that run as concurrent transactions can result in a race condition. Consider the following example, where two queries attempt to a blog post tag named at the same time (tag names must be unique): 'How to handle schema drift in production' \n\n If query A and query B overlap in the following way, query A results in an exception: To work around this scenario, we recommend catching the unique violation exception ( , error ) and retrying failed queries.\n\nThe following example:\n• Attempts to connect the profile to a where the email address is\n• Creates a new user if a matching user does not exist\n\nThe following example:\n• Attempts to connect the user to a with an of\n• Creates a new profile if a matching profile does not exist\n\nA nested query breaks the connection between a parent record and a related record, but does not delete either record. See: Working with relations\n• is only available if the relation is optional.\n• If the relationship you are attempting to disconnect does not exist:\n• (In 2.21.0 and later ), the operation does nothing\n• (Before 2.21.0 ) Prisma Client throws an exception if the provided ID or unique identifier is not connected: The records for relation `PostToUser` between the `User` and `Post` models are not connected. \n\n\n\nA nested query updates one or more related records where the parent record's ID is . See: Working with relations\n• Nested queries are only available in the context of a top-level query (for example, ).\n• If the parent record does not exist, Prisma Client throws an exception: AssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\")\n• If the related record that you want to update does not exist, Prisma Client throws an exception: AssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\") \n\n\n\nA nested query updates a related record if it exists, or creates a new related record.\n\nA nested query deletes a related record. The parent record is not deleted.\n• is only available if the relation is optional.\n\nA nested updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.\n\nA nested deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.\n\nYou can also exclude the :\n\nThis example compares fields of the same model which is available as of version 4.3.0.\n\nValue does not equal .\n\nThe following example combines and . You can also use .\n\nValue does not exist in list.\n\nValue is less than .\n\nValue is less than or equal to .\n\nValue is greater than .\n\nValue is greater than or equal to .\n\nUse Full-Text Search to search within a field.\n• Supported by the PostgreSQL and MongoDB connectors only\n\nAll conditions must return . Alternatively, pass a list of objects into the clause - the operator is not required.\n\nThe following format returns the same results as the previous example without the operator:\n\nThe following example combines and :\n\nOne or more conditions must return .\n\nThe following example combines and :\n\nThe following example combines and :\n\nReturns all records where one or more (\"some\") related records match filtering criteria.\n• You can use without parameters to return all records with at least one relation\n\nReturns all records where all (\"every\") related records match filtering criteria.\n\nReturns all records where zero related records match filtering criteria.\n• You can use without parameters to return all records with no relations\n\nReturns all records where related record matches filtering criteria (for example, user's name Bob).\n\nReturns all records where the related record does not match the filtering criteria (for example, user's name Bob).\n\nUse to overwrite the value of a scalar list field.\n• is optional - you can set the value directly:\n\nis available in version 2.20.0 and later. Use to add one value or multiple values to a scalar list field.\n• Available for PostgreSQL and MongoDB only.\n• You can push a list of values or only a single value.\n\nUse to unset the value of a scalar list. Unlike , removes the list entirely.\n\nScalar list filters allow you to filter by the contents of a list / array field.\n• Scalar list / array filters ignore values . Using or does not return records with value lists / arrays, and results in an error.\n\nThe given value exists in the list.\n\nThe following query returns all records where the list includes :\n\nThe following query returns all records where the list does not include :\n\nEvery value exists in the list.\n\nThe following query returns all records where the list includes at least and :\n\nAt least one value exists in the list.\n\nThe following query returns all records where the list includes or :\n\nThe following query returns all records that have no tags:\n\nFilter lists to include only results that have been set (either set to a value, or explicitly set to ). Setting this filter to will exclude undefined results that are not set at all.\n\nThe following query returns all records where the have been set to either or a value:\n\nThe list matches the given value exactly.\n\nThe following query returns all records where the list includes and only:\n\nComposite type methods allow you to create, update and delete composite types.\n\nUse to overwrite the value of a composite type.\n• The keyword is optional - you can set the value directly:\n\nUse to unset the value of a composite type. Unlike , this removes the field entirely from the MongoDB document.\n\nUse to update fields within a required composite type.\n\nThe method cannot be used on optional types. Instead, use upsert\n\nUse to update an existing optional composite type if it exists, and otherwise set the composite type.\n\nThe method cannot be used on required types. Instead, use update\n\nUse to push values to the end of a list of composite types.\n\nComposite type filters allow you to filter the contents of composite types.\n\nUse to filter results by matching a composite type or a list of composite types. Requires all required fields of the composite type to match.\n\nWhen matching optional fields, you need to distinguish between undefined (missing) fields of the document, and fields that have been explicitly set to :\n• If you omit an optional field, it will match undefined fields, but not fields that have been set to\n• If you filter for values of an optional field with , then it will match only documents where the field has been set to , and not undefined fields\n\nThe ordering of fields and lists matters when using :\n• For fields, and are not considered equal\n• For lists, and are not considered equal\n\nUse to filter results by matching specific fields within composite types.\n\nUse to filter results for composite type fields that do not match.\n\nUse to filter results for an empty list of composite types.\n\nUse to filter for lists of composite types where every item in the list matches the condition\n\nUse to filter for lists of composite types where one or more items in the list match the condition.\n\nUse to filter for lists of composite types where no items in the list match the condition.\n\nAtomic operations on update is available for number field types ( and ). This feature allows you to update a field based on its current value (such as subtracting or dividing) without risking a race condition.\n• You can only perform one atomic update per field, per query.\n• If a field is , it will not be updated by , , , or .\n\nCan also be written as:\n\nFor use cases and advanced examples, see: Working with fields.\n\nThe examples in this section assumes that the value of the field is:\n• The implementation of filtering differs between database connectors\n• Filtering is case sensitive in PostgreSQL and does not yet support\n\nrepresents the location of a specific key. The following query returns all users where the nested > key equals .\n\nThe following query returns all users where the nested > array contains .\n\nThe following query returns all users where the nested > array contains an object where the value is :\n\nThe following query returns all users where the nested > key value contains :\n\nThe following query returns all users where the nested > key value starts with :\n\nThe following query returns all users where the nested > key value ends with :\n\nSpecify whether the the string filtering should be case sensitive (default) or case insensitive.\n\nThe following query returns all users where the nested > key value contains or :\n\nThe following query returns all users where the array contains the value :\n\nThe following query returns all users where the array contains all the values in the given array:\n\nThe following query returns all users where the array starts with the value :\n\nThe following query returns all users where the array ends with the value :\n• and client methods do not exist on extended client instances which are extended using\n\nThe method closes the database connections that were established when was called and stops the process that was running Prisma ORM's query engine. See Connection management for an overview of and .\n• returns a , so you should call it inside an function with the keyword.\n\nThe method establishes a physical connection to the database via Prisma ORM's query engine. See Connection management for an overview of and .\n• returns a , so you should call it inside an function with the keyword.\n\nThe method allows you to subscribe to logging events or the exit hook.\n\nrepresents the \"next level\" in the middleware stack, which could be the next middleware or the Prisma Query, depending on where in the stack you are.\n\nis an object with information to use in your middleware.\n\nPrisma Client metrics give you a detailed insight into how Prisma Client interacts with your database. You can use this insight to help diagnose performance issues with your application. Learn more: Metrics.\n\nPrisma Client metrics has the following methods:\n\nWith , you can create and use Prisma Client extensions to add functionality to Prisma Client in the following ways:\n\nUtility types are helper functions and types that live on the namespace. They are useful for keeping your application type safe.\n\nThe helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid. See also: Using\n\nThere are two ways you can use the :\n\nUsing types provides a type-level approach to validate data:\n\nWhen using the selector pattern, you use an existing Prisma Client instance to create a validator. This pattern allows you to select the model, operation, and query option to validate against.\n\nYou can also use an instance of Prisma Client that has been extended using a Prisma Client extension.\n\nThe following example shows how you can extract and validate the input for the operation you can reuse within your app:\n\nHere is an alternative syntax for the same operation:\n\nYou can compare columns in the same table directly, for non-unique filters.\n\nThis feature was moved to general availability in version 5.0.0 and was available via the Preview feature from Prisma ORM versions 4.3.0 to 4.16.2.\n\nTo compare columns in the same table, use the property. In the following example, the query returns all records where the value in the field is less than or equal to the value in the field.\n\nYou can only make comparisons on fields of the same type. For example, the following causes an error:\n\nYou can only make comparisons with the property on fields in the same model. The following example does not work:\n\nHowever, you can compare fields in separate models with standard queries.\n\nIf you use the groupBy model query with the option, then you must put your referenced fields in the argument.\n\nThe following example works:\n\nThe following example does not work, because is not in the argument:\n\nIf your data source supports scalar lists (for example in PostgreSQL), then you can search for all records where a specific field is in a list of fields. To do so, reference the scalar list with the and filters. For example:\n\nFrom version 5.0.0, the generated type on exposes all fields on the model, not just unique fields. This was available under the Preview flag between versions 4.5.0 to 4.16.2\n\nYou must specify at least one unique field in your statement outside of boolean operators, and you can specify any number of additional unique and non-unique fields. You can use this to add filters to any operation that returns a single record. For example, you can use this feature for the following:\n\nFrom version 4.6.0, you can use this feature to filter on optional one-to-one nested reads.\n\nYou can filter on non-unique fields to perform optimistic concurrency control on operations.\n\nTo perform optimistic concurrency control, we recommend that you use a field to check whether the data in a record or related record has changed while your code executes. Before version 4.5.0, you could not evaluate the field in an operation, because the field is non-unique. From version 4.5.0, you can evaluate the field.\n\nIn the following example, and first read the same record and then attempt to update it. The database only executes these updates if the value in is the same as the value when it did the initial read. When the database executes the first of these updates (which might be or , depending on timing), it increments the value in . This means that the database does not execute the second update because the value in has changed.\n\nYou can filter on non-unique fields to check permissions during an update.\n\nIn the following example, a user wants to update a post title. The statement checks the value in to confirm that the user is the author of the post. The application only updates the post title if the user is the post author.\n\nYou can filter on non-unique fields to handle soft deletes.\n\nIn the following example, we do not want to return a post if it is soft-deleted. The operation only returns the post if the value in is .\n\nWith , you must specify at least one unique field outside of the boolean operators , , . You can still use these boolean operators in conjunction with any other unique fields or non-unique fields in your filter.\n\nIn the following example, we test , a unique field, in conjunction with . This is valid.\n\nThe following example is not valid, because there is no unique field outside of any boolean operators:\n\nFrom version 4.5.0, you can filter on non-unique fields in the following operations on one-to-one relations:\n\nPrisma Client automatically uses a unique filter to select the appropriate related record. As a result, you do not need to specify a unique filter in your statement with a generated type. Instead, the statement has a generated type. You can use this to filter without the restrictions of .\n\nAll Prisma Client queries return an instance of . This is a \"thenable\" , meaning a only executes when you call or or . This behavior is different from a regular JavaScript , which starts executing immediately.\n\nWhen using the API, this behavior makes it possible for Prisma Client to pass all the queries on to the query engine as a single transaction."
    },
    {
        "link": "https://prisma.io/docs/orm/prisma-client/queries/crud",
        "document": "This page describes how to perform CRUD operations with your generated Prisma Client API. CRUD is an acronym that stands for:\n\nRefer to the Prisma Client API reference documentation for detailed explanations of each method.\n\nAll examples are based on the following schema:\n\nFor relational databases, use command to push the example schema to your own database\n\nFor MongoDB, ensure your data is in a uniform shape and matches the model defined in the Prisma schema.\n\nThe following query creates ( ) a single user with two fields:\n\nThe user's is auto-generated, and your schema determines which fields are mandatory.\n\nThe following example produces an identical result, but creates a variable named outside the context of the query. After completing a simple check (\"Should posts be included in this query?\"), the variable is passed into the query:\n\nFor more information about working with generated types, see: Generated types.\n\nPrisma Client supports bulk inserts as a GA feature in 2.20.0 and later.\n\nThe following query creates multiple users and skips any duplicates ( must be unique):\n\nuses a single statement with multiple values, which is generally more efficient than a separate per row:\n\nThe following video demonstrates how to use and faker.js to seed a database with sample data:\n\nSee Working with relations > Nested writes for information about creating a record and one or more related records at the same time.\n\nYou can use in order to create many records and return the resulting objects.\n\nThe following queries return a single record ( ) by unique identifier or ID:\n\nIf you are using the MongoDB connector and your underlying ID type is , you can use the string representation of that :\n\nThe following query returns all records:\n\nYou can also paginate your results.\n\nThe following query returns the most recently created user with at least one post that has more than 100 likes:\n• Order users by descending ID (largest first) - the largest ID is the most recent\n• Return the first user in descending order with at least one post that has more than 100 likes\n\nThe following query returns all records with an email that ends in :\n\nThe following query uses a combination of operators to return users whose name start with or administrators with at least 1 profile view:\n\nThe following query returns users with an email that ends with and have at least one post ( ) that is not published:\n\nSee Working with relations for more examples of filtering on related field values.\n\nThe following query uses to return the and fields of a specific record:\n\nFor more information about including relations, refer to:\n\nThe following query uses a nested to return:\n• The field of each post\n\nFor more information about including relations, see Select fields and include relations.\n\nSee Select for information about selecting distinct field values.\n\nThe following query returns all users and includes each user's posts in the result:\n\nFor more information about including relations, see Select fields and include relations.\n\nSee Working with relations to find out how to combine and for a filtered list of relations - for example, only include a user's published posts.\n\nThe following query uses to find and update a single record by :\n\nThe following query uses to update all records that contain :\n\nYou can use in order to update many records and return the resulting objects.\n\nThe following query uses to update a record with a specific email address, or create that record if it does not exist:\n\nPrisma Client does not have a query. You can use as a workaround. To make behave like a method, provide an empty parameter to .\n\nUse atomic number operations to update a number field based on its current value - for example, increment or multiply. The following query increments the and fields by :\n\nRefer to Working with relations for information about disconnecting ( ) and connecting ( ) related records.\n\nThe following query uses to delete a single record:\n\nAttempting to delete a user with one or more posts result in an error, as every requires an author - see cascading deletes.\n\nThe following query uses to delete all records where contains :\n\nAttempting to delete a user with one or more posts result in an error, as every requires an author - see cascading deletes.\n\nThe following query uses to delete all records:\n\nBe aware that this query will fail if the user has any related records (such as posts). In this case, you need to delete the related records first.\n\nThe following query uses to delete a single record:\n\nHowever, the example schema includes a required relation between and , which means that you cannot delete a user with posts:\n\nTo resolve this error, you can:\n• Change the author of the posts to another user before deleting the user.\n• Delete a user and all their posts with two separate queries in a transaction (all queries must succeed):\n\nSometimes you want to remove all data from all tables but keep the actual tables. This can be particularly useful in a development environment and whilst testing.\n\nThe following shows how to delete all records from all tables with Prisma Client and with Prisma Migrate.\n\nWhen you know the order in which your tables should be deleted, you can use the function. This is executed synchronously in a and can be used with all types of databases.\n• Works well when you know the structure of your schema ahead of time\n• When working with relational databases, this function doesn't scale as well as having a more generic solution which looks up and s your tables regardless of their relational constraints. Note that this scaling issue does not apply when using the MongoDB connector.\n\nIf you are comfortable working with raw SQL, you can perform a query on a table using .\n\nIn the following examples, the first tab shows how to perform a on a Postgres database by using a look up that maps over the table and all tables in a single query.\n\nThe second tab shows performing the same function but with a MySQL database. In this instance the constraints must be removed before the can be executed, before being reinstated once finished. The whole process is run as a\n• Using reserved SQL key words as tables names can cause issues when trying to run a raw query\n\nIf you use Prisma Migrate, you can use , this will:"
    },
    {
        "link": "https://stackoverflow.com/questions/68140035/exclude-users-password-from-query-with-prisma-2",
        "document": "Recently I started working on a new project to learn some new technologies (Prisma 2, REST api with Express, etc.). Tho, I faced a problem.\n\nMy app has a user authentication system and the user model has a password column. So, when the client requests a user, the backend selects all the columns from the database including the password (that's hashed by the way).\n\nI tried to not select the password column on the prisma findMany, like this:\n\nBut I got an error by prisma saying that the select should contain at least one truly value. Thus, I added to the select. I made an api request and I saw that only the id was returning for the user.\n\nBy my understanding, prisma expects me to add all the columns I care to the select object. But, I need a lot of columns from the user and I am making a lot of queries to fetch users and I cannot just write all the field I need everytime.\n\nSo, I wanted to ask you if there is a legit way to do that.\n\nPS: I don't take \"use rawQuery instead\" as a solution."
    },
    {
        "link": "https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all",
        "document": "I want to add a catch statement to handle an individual promise in case it errors, but when I try, Promise.all returns the first error it finds (disregards the rest), and then I can't get the data from the rest of the promises in the array (that didn't error).\n\nI go on to continue the promise chain. Looks something like this\n\nI have an array of Promises that I'm resolving with Promise.all(arrayOfPromises);\n\nis all or nothing. It resolves once all promises in the array resolve, or reject as soon as one of them rejects. In other words, it either resolves with an array of all resolved values, or rejects with a single error. Some libraries have something called , which I understand would instead wait for all promises in the array to either resolve or reject, but I'm not familiar with it, and it's not in ES6. I agree with others here that your fix should work. It should resolve with an array that may contain a mix of successful values and errors objects. It's unusual to pass error objects in the success-path but assuming your code is expecting them, I see no problem with it. The only reason I can think of why it would \"not resolve\" is that it's failing in code you're not showing us and the reason you're not seeing any error message about this is because this promise chain is not terminated with a final catch (as far as what you're showing us anyway). I've taken the liberty of factoring out the \"existing chain\" from your example and terminating the chain with a catch. This may not be right for you, but for people reading this, it's important to always either return or terminate chains, or potential errors, even coding errors, will get hidden (which is what I suspect happened here): Promise.all(state.routes.map(function(route) { return route.handler.promiseHandler().catch(function(err) { return err; }); })) .then(function(arrayOfValuesOrErrors) { // handling of my array containing values and/or errors. }) .catch(function(err) { console.log(err.message); // some coding error in handling happened });\n\nTo continue the loop (even when a Promise rejects) I wrote a utility function which is called . This utility function returns an object with and . The idea is that all Promises you pass to will be wrapped into a new Promise which will always resolve. The new Promise resolves with an array which has 2 spots. The first spot holds the resolving value (if any) and the second spot keeps the error (if the wrapped Promise rejects). As a final step the accumulates all values of the wrapped promises and returns the final object with an array for and an array for . function executeAllPromises(promises) { // Wrap all Promises in a Promise that will always \"resolve\" var resolvingPromises = promises.map(function(promise) { return new Promise(function(resolve) { var payload = new Array(2); promise.then(function(result) { payload[0] = result; }) .catch(function(error) { payload[1] = error; }) .then(function() { /* * The wrapped Promise returns an array: * The first position in the array holds the result (if any) * The second position in the array holds the error (if any) */ resolve(payload); }); }); }); var errors = []; var results = []; // Execute all wrapped Promises return Promise.all(resolvingPromises) .then(function(items) { items.forEach(function(payload) { if (payload[1]) { errors.push(payload[1]); } else { results.push(payload[0]); } }); return { errors: errors, results: results }; }); } var myPromises = [ Promise.resolve(1), Promise.resolve(2), Promise.reject(new Error('3')), Promise.resolve(4), Promise.reject(new Error('5')) ]; executeAllPromises(myPromises).then(function(items) { // Result var errors = items.errors.map(function(error) { return error.message }).join(','); var results = items.results.join(','); console.log(`Executed all ${myPromises.length} Promises:`); console.log(`— ${items.results.length} Promises were successful: ${results}`); console.log(`— ${items.errors.length} Promises failed: ${errors}`); });\n\nIt seems to be designed to do exactly what you want - execute a function once all the promises have settled (resolved/rejected), regardless of some of the promises being rejected. The method can be useful if you want to do some processing or cleanup once the promise is settled, regardless of its outcome. The method is very similar to calling however there are couple of differences: When creating a function inline, you can pass it once, instead of being forced to either declare it twice, or create a variable for it. A finally callback will not receive any argument, since there's no reliable means of determining if the promise was fulfilled or rejected. This use case is for precisely when you do not care about the rejection reason, or the fulfillment value, and so there's no need to provide it. Unlike (which will be resolved with undefined), will be resolved with 2. Similarly, unlike (which will be fulfilled with undefined), will be rejected with 3. If your version of JavaScript doesn't support you can use this workaround from Jake Archibald:"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-handle-errors-in-promise-all",
        "document": "JavaScript - How to Handle Errors in Promise.all?\n\nTo handle errors in Promise.all(), you need to understand that it fails immediately if any of the promises reject, discarding all resolved values. This behavior can lead to incomplete operations and potential application crashes.\n\nThe best way to manage errors in Promise.all() is by using .catch() inside each promise, switching to Promise.allSettled() to capture both resolved and rejected results, or wrapping Promise.all() inside a try...catch block when using async/await.\n\nIf you want all promises to run without failures, use Promise.allSettled(), which returns an array of results including both fulfilled and rejected promises.\n\nIn this example\n• None Each promise result includes { status: \"fulfilled\", value: result } for success or { status: \"rejected\", reason: error } for failure.\n• None Unlike Promise.all(), this method does not discard fulfilled results when one promise fails, making error handling more efficient.\n\nThe async/await syntax streamlines asynchronous operations, allowing code to pause and resume tasks, enhancing readability and responsiveness.\n\nThis method catches the first rejection and prevents the application from crashing.\n\nAn alternative approach is to catch individual errors within each promise, ensuring one failure doesn't break the entire chain.\n\nIn this example\n• None safePromise ensures that if a promise fails, it doesn't reject Promise.all() but instead returns { error: \"Error Message\" }.\n• None Even if one promise fails, the remaining promises continue execution.\n• None The output contains both resolved values and errors in a structured format.\n• None This method prevents unexpected crashes and allows handling partial results.\n\nBest Practices for Handling Errors in Promise.all()\n• None Use Promise.allSettled() if all promises should run, even if some fail.\n• None Wrap each promise with .catch() to prevent failures from breaking the entire chain.\n• None Use try...catch with async/await to handle errors in asynchronous functions.\n• None Log and analyze errors properly to prevent silent failures in production.\n• None Consider retry mechanisms for network requests and external API calls.\n\nHow to handle errors in Promise.all - FAQs\n\nWhat happens if one promise in Promise.all fails?\n\nCan we handle individual promise errors in Promise.all?\n\nHow can I ignore errors in Promise.all and continue?\n\nCan Promise.all be used with async functions?\n\nHow do we handle multiple errors from multiple promises in Promise.all?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all",
        "document": "The static method takes an iterable of promises as input and returns a single . This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason.\n\nThe method is one of the promise concurrency methods. It can be useful for aggregating the results of multiple promises. It is typically used when there are multiple related asynchronous tasks that the overall code relies on to work successfully — all of whom we want to fulfill before the code execution continues. will reject immediately upon any of the input promises rejecting. In comparison, the promise returned by will wait for all input promises to complete, regardless of whether or not one rejects. Use if you need the final result of every promise in the input iterable.\n\nwaits for all fulfillments (or the first rejection). If the contains non-promise values, they will be ignored, but still counted in the returned promise array value (if the promise is fulfilled): // All values are non-promises, so the returned promise gets fulfilled const p = Promise.all([1, 2, 3]); // The only input promise is already fulfilled, // so the returned promise gets fulfilled const p2 = Promise.all([1, 2, 3, Promise.resolve(444)]); // One (and the only) input promise is rejected, // so the returned promise gets rejected const p3 = Promise.all([1, 2, 3, Promise.reject(555)]); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(p); console.log(p2); console.log(p3); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[3] } // Promise { <state>: \"fulfilled\", <value>: Array[4] } // Promise { <state>: \"rejected\", <reason>: 555 }\n\nThis following example demonstrates the asynchronicity of when a non-empty is passed: // Passing an array of promises that are already resolved, // to trigger Promise.all as soon as possible const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)]; const p = Promise.all(resolvedPromisesArray); // Immediately logging the value of p console.log(p); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs, in order: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] } The same thing happens if rejects: const mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)]; const p = Promise.all(mixedPromisesArray); console.log(p); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"rejected\", <reason>: 44 } resolves synchronously if and only if the passed is empty: const p = Promise.all([]); // Will be immediately resolved const p2 = Promise.all([1337, \"hi\"]); // Non-promise values are ignored, but the evaluation is done asynchronously console.log(p); console.log(p2); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p2); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[0] } // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] }\n\nWithin async functions, it's very common to \"over-await\" your code. For example, given the following functions: function promptForDishChoice() { return new Promise((resolve, reject) => { const dialog = document.createElement(\"dialog\"); dialog.innerHTML = ` <form method=\"dialog\"> <p>What would you like to eat?</p> <select> <option value=\"pizza\">Pizza</option> <option value=\"pasta\">Pasta</option> <option value=\"salad\">Salad</option> </select> <menu> <li><button value=\"cancel\">Cancel</button></li> <li><button type=\"submit\" value=\"ok\">OK</button></li> </menu> </form> `; dialog.addEventListener(\"close\", () => { if (dialog.returnValue === \"ok\") { resolve(dialog.querySelector(\"select\").value); } else { reject(new Error(\"User cancelled dialog\")); } }); document.body.appendChild(dialog); dialog.showModal(); }); } async function fetchPrices() { const response = await fetch(\"/prices\"); return await response.json(); } You may write a function like this: However, note that the execution of and don't depend on the result of each other. While the user is choosing their dish, it's fine for the prices to be fetched in the background, but in the code above, the operator causes the async function to pause until the choice is made, and then again until the prices are fetched. We can use to run them concurrently, so that the user doesn't have to wait for the prices to be fetched before the result is given: is the best choice of concurrency method here, because error handling is intuitive — if any of the promises reject, the result is no longer available, so the whole expression throws. accepts an iterable of promises, so if you are using it to run several async functions concurrently, you need to call the async functions and use the returned promises. Directly passing the functions to does not work, since they are not promises. async function getPrice() { const [choice, prices] = await Promise.all([ promptForDishChoice, fetchPrices, ]); // `choice` and `prices` are still the original async functions; // Promise.all() does nothing to non-promises }"
    },
    {
        "link": "https://arunangshudas.medium.com/asynchronous-patterns-and-best-practices-in-node-js-87ba2a7c0477",
        "document": "Asynchronous programming is the cornerstone of Node.js, enabling it to handle high concurrency with minimal resources. However, with great power comes great responsibility. Misusing or misunderstanding asynchronous patterns can lead to issues like callback hell, memory leaks, or inefficient code.\n\nNode.js operates on a single-threaded event loop, making it inherently non-blocking. This means that instead of waiting for a task (e.g., reading a file, querying a database) to complete, Node.js can handle other operations. Here’s how it achieves this:\n• Callbacks: The original way of handling async operations.\n• Promises: Introduced in ES6 to make asynchronous code more readable.\n• Async/Await: A syntactic sugar over promises introduced in ES8, enabling a synchronous look and feel.\n\nCallbacks were the first way to handle async operations in JavaScript. They involve passing a function as an argument to another function, which gets executed after the operation completes.\n\nPitfall: Overuse of callbacks can lead to callback hell — a nested and difficult-to-read structure.\n\nBest Practice: Use callbacks judiciously or refactor to promises or async/await for cleaner code.\n\nPromises represent a value that may be available now, or in the future, or never. They chain and for cleaner asynchronous flows.\n• Provides better error handling with .\n\nAsync/Await is built on promises but offers a more synchronous style of coding, improving readability.\n\nBest Practices for Asynchronous Programming in Node.js\n\nIf you find yourself with nested callbacks, it’s time to refactor. Transition to promises or async/await to simplify your code.\n\nAlways handle errors in your asynchronous operations. Whether using callbacks, promises, or async/await, ensure error paths are covered.\n\nNode.js has native support for promises in many modules like ( ). Always prefer these over manually promisifying older APIs.\n\nWhen handling multiple independent asynchronous tasks, use to execute them concurrently.\n\nFor large data processing, streams are more memory-efficient than reading the entire file into memory.\n\nDebugging asynchronous code can be tricky. Use tools like:\n\nAvoid blocking the event loop with synchronous code. Use asynchronous methods for expensive operations.\n\nIn conclusion, mastering asynchronous programming in Node.js is key to building fast and scalable applications. By embracing best practices like proper error handling, avoiding callback hell, and using modern features like promises and async/await, you can write cleaner, more maintainable code. Optimizing concurrency and understanding how the event loop works also play a big role in keeping your apps responsive and efficient. With the right techniques and mindset, you’ll be well on your way to creating high-performance Node.js applications.\n\nYou may also like:\n\n1) How do you optimize a website’s performance?\n\n2) Change Your Programming Habits Before 2025: My Journey with 10 CHALLENGES\n\n4) What is Database Indexing, and Why is It Important?"
    },
    {
        "link": "https://codedamn.com/news/nodejs/promises-error-handling",
        "document": "Promises have become an essential part of asynchronous programming in JavaScript, especially in Node.js applications. They allow developers to write cleaner, more maintainable code by providing a better way to handle asynchronous operations. However, error handling with Promises can still be challenging for beginners. In this blog post, we will dive deep into the world of error handling with Promises in Node.js and learn how to make your code more robust and reliable.\n\nBefore we dive into error handling, let's take a moment to understand what Promises are and why they are so important in the world of asynchronous programming.\n\nPromises are objects that represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide a standardized way to handle the outcome of an asynchronous operation, making it easier to reason about the flow of your code.\n\nIn this example, we create a new Promise that resolves after one second. The function is used to signal that the asynchronous operation has completed successfully, and the function is used to signal that the operation has failed.\n\nNow that we have a basic understanding of Promises, let's dive into error handling. There are two main ways to handle errors in Promises: using the method or the method with two arguments.\n\nThe method is used to handle any errors that are thrown during the execution of the Promise. It takes a single argument, a function that will be called when an error occurs. Here's an example:\n\nIn this example, we attach a method to our Promise. If an error occurs during the execution of the Promise, the function passed to will be called, allowing you to handle the error gracefully.\n\nThe .then() Method with Two Arguments\n\nAlternatively, you can handle errors by passing a second argument to the method. This second argument is a function that will be called when an error occurs. Here's an example:\n\nIn this example, we pass two functions to the method. The first function will be called when the Promise resolves successfully, and the second function will be called when an error occurs.\n\nWhile both of these methods work for handling errors in Promises, it is generally recommended to use the method, as it provides a clearer separation between success and error handling code.\n\nOne of the benefits of using Promises is the ability to chain them together, allowing you to compose complex flows of asynchronous operations. When chaining Promises, it's important to understand how errors propagate through the chain.\n\nHere's an example of chaining Promises:\n\nIn this example, we have two functions, and , that both return Promises. We first call , and when it resolves successfully, we pass the result to . If either of these Promises rejects (i.e., an error occurs), the error will propagate through the chain until it reaches the method, where it will be handled.\n\nThis error propagation allows you to handle errors at any point in the chain, making your code more maintainable and easier to reason about.\n\nBest Practices for Error Handling with Promises\n\nNow that we understand the basics of error handling with Promises, let's discuss some best practices to ensure your code is robust and reliable.\n• Always handle errors: It's important to always handle errors when working with Promises. Unhandled errors can lead to unexpected behavior and make your code difficult to debug. To avoid this, make sure to attach a method or provide a second argument to the method for every Promise in your code.\n• Use meaningful error messages: When rejecting a Promise, make sure to provide a meaningful error message. This will help you understand the root cause of the error when it occurs, making it easier to debug and fix issues.\n• Use custom error classes: To improve error handling, consider using custom error classes that extend the built-in class. This will allow you to provide more context about the error and make it easier to handle specific error types.\n• Use / with / : If you're using / syntax, you can use / blocks to handle errors in a more familiar way. This can make your code more readable and easier to reason about.\n\nHere's an example of using / with / for error handling:\n\nQ: What is the difference between and the second argument of ?\n\nA: Both methods can be used to handle errors in Promises. However, the method is generally recommended, as it provides a clearer separation between success and error handling code. The second argument of is an alternative way to handle errors, but it can make your code more difficult to read and maintain.\n\nA: Yes, you can handle multiple errors in a Promise chain by attaching multiple methods. Each method will handle the error and stop the propagation of the error through the chain. However, it's important to ensure that all errors are properly handled, as unhandled errors can lead to unexpected behavior.\n\nQ: What is the difference between and ?\n\nA: The method is used to execute code after a Promise has either resolved or rejected, regardless of the outcome. This can be useful for cleaning up resources or performing other tasks that need to happen in both success and error cases. The method, on the other hand, is specifically used for handling errors.\n\nQ: How can I handle timeouts in Promises?\n\nA: To handle timeouts in Promises, you can use the method to create a race between the Promise you want to execute and a Promise that will reject after a certain period of time. Here's an example:\n\nIn this example, we create a function that returns a Promise that rejects after the specified number of milliseconds. We then use to race this timeout Promise against our Promise. If the Promise resolves before the timeout, the race will be won by that Promise. If the timeout occurs first, the race will be won by the timeout Promise, and an error will be thrown.\n\nQ: How do I handle multiple Promises that should all resolve before proceeding?\n\nA: You can use the method to wait for multiple Promises to resolve before proceeding. This method takes an array of Promises and returns a new Promise that resolves with an array of the resolved values, in the same order as the input Promises. If any of the input Promises reject, the returned Promise will reject as well. Here's an example:\n\nIn this example, we use to wait for two Promises to resolve. Once both Promises have resolved, the method is called with the results.\n\nBy following these best practices and understanding the nuances of error handling with Promises in Node.js, you'll be able to write more robust and maintainable code. Remember to always handle errors, use meaningful error messages, and consider using custom error classes and / with / for improved error handling."
    },
    {
        "link": "https://stackoverflow.com/questions/65615469/typescript-syntax-for-handling-promise-rejection",
        "document": "Since the the first return immediately returns the promise, isn't it true that the try/catch doesn't get a chance to handle the case where the promise gets rejected?\n\nIndeed, the asynchronous part that would throw an error would not be running in this function's execution context, and so the block does not apply to that asynchronous code.\n\nThe / solution will have that function execution context restored (this is the magic of ), and then the error will be treated within the context. But there is no such execution context restoration happening in a normal function, so then the context is not there at the moment of the error.\n\nHere is an example, with a promise that rejects after 100 milliseconds. The first function has the same pattern you started with. It will not see the error, and so there is an \"uncaught promise rejection\" (Stack Snippets don't show this, but it's in the browser console).\n\nThere are essentially two ways to do it right. You already showed the / way. But you can do this without that syntax. Instead of a block, chain a method call:"
    },
    {
        "link": "https://stackoverflow.com/questions/41863251/proper-error-pattern-for-async-functions-using-promises-in-typescript",
        "document": "I want to make a typed async function with proper error handling.\n\nI can define one like this:\n\n...which seems to work, but (for reasons that are clear), if I try to assign the result to an object, I get the error Type 'void | ISomething' is not assignable to type 'ISomething' .\n\nI get why that is. My question is, what pattern should I use for error handling in a case like this? Note that if the return type is instead then I get an error for the line (which would return ).\n\nIn place of the line I can use , but there may be times where I'd want to use the pattern (like if I want to do some more things before I return).\n\nI have a feeling that I'm missing something with promises / async, but I can't find typed examples that follow this pattern.\n\n...note that if I use the full Promise pattern it works fine:\n\nShould I just be using and forget about ? If I use , will the be triggered appropriately?"
    },
    {
        "link": "https://javascript.info/promise-error-handling",
        "document": "Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice.\n\nFor instance, in the code below the URL to is wrong (no such site) and handles the error:\n\nAs you can see, the doesn’t have to be immediate. It may appear after one or maybe several .\n\nOr, maybe, everything is all right with the site, but the response is not valid JSON. The easiest way to catch all errors is to append to the end of chain:\n\nNormally, such doesn’t trigger at all. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.\n\nThe code of a promise executor and promise handlers has an “invisible ” around it. If an exception happens, it gets caught and treated as a rejection.\n\n…Works exactly the same as this:\n\nThe “invisible ” around the executor automatically catches the error and turns it into rejected promise.\n\nThis happens not only in the executor function, but in its handlers as well. If we inside a handler, that means a rejected promise, so the control jumps to the nearest error handler.\n\nThis happens for all errors, not just those caused by the statement. For example, a programming error:\n\nThe final not only catches explicit rejections, but also accidental errors in the handlers above.\n\nAs we already noticed, at the end of the chain is similar to . We may have as many handlers as we want, and then use a single at the end to handle errors in all of them.\n\nIn a regular we can analyze the error and maybe rethrow it if it can’t be handled. The same thing is possible for promises.\n\nIf we inside , then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful handler.\n\nIn the example below the successfully handles the error:\n\nHere the block finishes normally. So the next successful handler is called.\n\nIn the example below we see the other situation with . The handler catches the error and just can’t handle it (e.g. it only knows how to handle ), so it throws it again:\n\nThe execution jumps from the first to the next one down the chain.\n\nWhat happens when an error is not handled? For instance, we forgot to append to the end of the chain, like here:\n\nIn case of an error, the promise becomes rejected, and the execution should jump to the closest rejection handler. But there is none. So the error gets “stuck”. There’s no code to handle it.\n\nIn practice, just like with regular unhandled errors in code, it means that something has gone terribly wrong.\n\nWhat happens when a regular error occurs and is not caught by ? The script dies with a message in the console. A similar thing happens with unhandled promise rejections.\n\nThe JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.\n\nIn the browser we can catch such errors using the event :\n\nThe event is the part of the HTML standard.\n\nIf an error occurs, and there’s no , the handler triggers, and gets the object with the information about the error, so we can do something.\n\nUsually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.\n\nIn non-browser environments like Node.js there are other ways to track unhandled errors.\n• handles errors in promises of all kinds: be it a call, or an error thrown in a handler.\n• also catches errors in the same manner, if given the second argument (which is the error handler).\n• We should place exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones (maybe they are programming mistakes).\n• It’s ok not to use at all, if there’s no way to recover from an error.\n• In any case we should have the event handler (for browsers, and analogs for other environments) to track unhandled errors and inform the user (and probably our server) about them, so that our app never “just dies”."
    },
    {
        "link": "https://medium.com/@sudhirkmr529/mastering-error-handling-with-async-await-in-javascript-cb1c877bb554",
        "document": "In the world of modern web development, asynchronous programming plays a pivotal role in delivering seamless user experiences. JavaScript, being the backbone of web interactivity, has evolved to provide developers with powerful tools to manage asynchronous operations. One such advancement is the introduction of, a syntax that simplifies error handling and enhances code readability. In this comprehensive guide, we will delve deep into mastering error handling with in JavaScript, equipping you with the skills to create robust and reliable applications.\n\nAsynchronous programming enables web applications to perform multiple tasks simultaneously, enhancing performance and responsiveness. Traditional callback-based approaches often lead to callback hell and convoluted code. was introduced to address these issues and streamline asynchronous code execution.\n\nis a pair of keywords in JavaScript that simplifies the process of working with promises, making asynchronous code look and behave more like synchronous code. The keyword is used to define an asynchronous function, which returns a promise. Within a function, the the keyword is used to pause the execution of the function until a promise is resolved.\n\nError handling is crucial in any application to provide graceful fallbacks and user-friendly feedback. With , managing errors becomes more intuitive and concise.\n\nTry-Catch Blocks: By encapsulating statements within a block, you can catch and handle errors that occur during asynchronous operations.\n\nPromises Rejection: When an function returns a rejected promise, it automatically throws an exception, allowing you to catch and handle it in an outer block.\n\nHandling Multiple Promises: You can use to handle multiple asynchronous operations concurrently and catch errors collectively.\n• Specific Error Messages: Provide clear and concise error messages that help developers identify and troubleshoot issues quickly.\n• Logging and Monitoring: Implement robust logging and monitoring mechanisms to track errors and gather insights for continuous improvement.\n• Graceful Degradation: Design your application to gracefully handle errors by providing fallbacks and alternative actions for users.\n\nLet’s put our knowledge into practice by creating a simple weather application that fetches weather data from an API and displays it to the user. Below is a high-level overview of the steps involved:\n• Setting Up the Project: Initialize a new project using a package manager like npm or yarn.\n• Fetching Weather Data: Use the API to retrieve weather data from a reliable source.\n• Parsing and Displaying Data: Process the fetched data and display it to the user interface.\n• Error Handling: Implement robust error handling using and provide meaningful feedback to users in case of errors.\n\nMastering error handling with in JavaScript empowers developers to build resilient and efficient applications that provide exceptional user experiences. By effectively managing asynchronous operations and gracefully handling errors, you can create codebases that are both robust and maintainable. Embrace the power of to elevate your web development skills and stay ahead in the ever-evolving landscape of modern programming.\n• We can use for synchronous code.\n• We can use (in combination with functions) and the approaches to handle errors for asynchronous code.\n• When returning a promise within a block, make sure to it if you want the block to catch the error.\n• Be aware when wrapping errors and rethrowing, that you lose the stack trace with the origin of the error.\n\nStart your journey towards becoming an error-handling maestro with and watch your applications flourish.\n\nfollow our blog for more learning content"
    },
    {
        "link": "https://zipy.ai/blog/debug-typescript-asynchronous-errors",
        "document": "Greetings, fellow JavaScript enthusiasts! If you've found your way here, chances are you're on a quest to master the intricacies of handling asynchronous errors in TypeScript. Whether you're a seasoned developer or someone looking to elevate their coding game, this blog is designed to be your beacon through the sometimes murky waters of TypeScript asynchronous errors.\n\nAsynchronous programming in TypeScript, as in JavaScript, is a powerful tool for performing tasks concurrently, leading to more efficient and responsive applications. However, with great power comes great responsibility—specifically, the responsibility to handle errors that may arise during these asynchronous operations. Understanding and debugging asynchronous errors in TypeScript can be a challenge, but fear not! We're here to dive deep into the common pitfalls and how to gracefully recover from them.\n\nIn this scenario, the error handling was implemented using around the asynchronous operation. The correction ensures that we check the response's status before attempting to parse it as JSON, preventing unhandled promise rejections.\n\nThe correction involves adding a check for the response's property and throwing an error if it's false. This ensures that the promise chain correctly propagates errors to be caught by a handler.\n\nIn this example, we've added error checking within the function, throwing an error if any fetch request does not return an response. This ensures that either resolves with all resolved promises or rejects at the first sign of trouble, which we catch and handle gracefully.\n\nSuccessfully managing asynchronous errors in TypeScript not only requires understanding and Promises but also knowing how to effectively implement try-catch blocks and error propagation. It's crucial to anticipate potential failures in asynchronous operations and prepare your code to handle these exceptions smoothly.\n\nWhile mastering error handling is essential, utilizing tools like Zipy can dramatically simplify the process. Zipy offers proactive error monitoring and user session replay capabilities, making it easier to debug runtime TypeScript errors. By integrating such a tool, developers can gain insights into the root cause of errors and fix them before they impact users.\n\nAsynchronous error handling in TypeScript is an art that requires patience, practice, and a bit of strategic thinking. By understanding the common pitfalls and applying best practices, you can ensure your applications are robust, reliable, and user-friendly.\n\nResources on how to debug and fix Typescript errors\n• TypeScript Error Handling: A guide to 11 TypeScript errors and their fixes\n• How to handle Typescript Null or Undefined Value Errors?\n• How to handle Typescript Property Does Not Exist on Type Errors?\n\nHow can I catch all unhandled promise rejections?\n\nUse the to listen for and handle unhandled promise rejections.\n\nWhat's the difference between and Promises?\n\nis syntactic sugar built on top of Promises, designed to make asynchronous code easier to write and read.\n\nCan I use with Promises?\n\nYes, you can use in async functions or method of the Promise chain to handle errors.\n\nHow does error propagation work with ?\n\nErrors in are propagated down the chain and can be caught using a block surrounding the awaited calls.\n\nIs it possible to handle asynchronous errors without ?\n\nYes, you can handle errors in Promises using the method, which works similarly to for asynchronous operations.\n• Always use around asynchronous operations to handle errors gracefully.\n• Propagate errors in Promises using to ensure they don't go unnoticed.\n• Leverage tools like Zipy for proactive error monitoring and easier debugging of runtime TypeScript errors."
    }
]