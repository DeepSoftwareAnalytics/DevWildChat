[
    {
        "link": "https://unity.com/blog/games/level-up-your-code-with-game-programming-patterns",
        "document": ""
    },
    {
        "link": "https://deperiers-a.medium.com/solid-principles-in-the-context-of-video-games-1940bbae48e9",
        "document": "SOLID principles in the context of video games The SOLID principles were created by Robert C. Martin, also known as “Uncle Bob”, in the early 2000s as a set of guidelines for designing software in a way that is maintainable, scalable, and easy to understand. The SOLID principles are an acronym for five principles of object-oriented design: Single Responsibility Principle (SRP), Open/Closed Principle (OCP), Liskov Substitution Principle (LSP), Interface Segregation Principle (ISP), and Dependency Inversion Principle (DIP). The SOLID principles are based on the principles of object-oriented design, which have been around since the 1960s. However, Martin formalized the SOLID principles and popularized them in the software development community through his writing and speaking on the topic. Today, the SOLID principles are widely used as a guide for designing software systems that are easy to maintain and extend over time. They are applicable to a variety of programming languages, including C#, and are often used in conjunction with other design patterns and principles to create well-structured, scalable software systems.\n\nThe SOLID principles can be applied in the design of a video game to create a scalable, maintainable, and extensible codebase. Here is an explanation of each principle and how it can be applied in the context of a video game, along with examples in C#: S Single Responsibility Principle (SRP): This principle states that a software entity (such as a class, module, or function) should have only one reason to change. In other words, a software entity should have a single, well-defined responsibility, and that responsibility should be encapsulated within the entity. Here’s an example of how the Single Responsibility Principle can be applied in a game development context: Imagine you are building a game that has a character class, which represents a player character in the game. The character class has several responsibilities, such as handling movement, handling attacks, and handling collisions with other objects in the game world. One way to implement this might be to include all of these responsibilities within a single character class. However, this violates the Single Responsibility Principle, because the character class now has multiple reasons to change. For example, if you wanted to change the way movement is handled, you would need to modify the character class. If you wanted to change the way attacks are handled, you would also need to modify the character class. A better way to implement this would be to create separate classes for each responsibility, such as a Movement class, an Attack class, and a Collision class. The character class can then depend on these classes, rather than handling all of these responsibilities itself. This way, each class has a single, well-defined responsibility, and the character class is only responsible for managing the other classes. Here’s some example code to illustrate this: In this example, the character class depends on the Movement, Attack, and Collision classes, rather than handling all of these responsibilities itself. This allows each class to have a single, well-defined responsibility, and the character class is only responsible for managing the other classes. This makes the character class more modular and easier to maintain, as it is not tied to any specific implementation of movement, attack, or collision handling.\n\nOOpen-Closed Principle (OCP): This principle states that software entities (such as classes, modules, and functions) should be open for extension, but closed for modification. This means that you should be able to add new functionality to a software entity without changing its existing code. Here’s an example of how the Open/Closed Principle can be applied in a game development context: Imagine you are building a game that has a character class, which represents a player character in the game. The character class has a method called “Attack()” that allows the character to attack enemies in the game. However, you want to give the player the option to choose from different types of attacks, such as a sword attack or a magic attack. One way to implement this might be to add a parameter to the Attack() method that specifies the type of attack to use. However, this violates the Open/Closed Principle, because every time you want to add a new type of attack, you would need to modify the Attack() method to accept a new parameter. A better way to implement this would be to create an abstraction for attacks, such as an interface called “IAttack”. The character class can then depend on this abstraction, rather than on specific attack types. This way, the character class can use any implementation of the IAttack interface to perform an attack, and you can add new types of attacks by creating new implementations of the IAttack interface, without modifying the character class. Here’s some example code to illustrate this: In this example, the character class depends on the IAttack abstraction, rather than on specific attack types. This allows the character class to use any implementation of the IAttack interface to perform an attack, and you can add new types of attacks by creating new implementations of the IAttack interface, without modifying the character class. This makes the character class more flexible and easier to maintain, as it is not tied to any specific attack type.\n\nLLiskov Substitution Principle (LSP): This principle states that objects of a derived class should be able to be used in the same way as objects of the base class, without causing any unexpected behavior. In other words, a derived class should be able to substitute for its base class without breaking any existing code that uses the base class. Here’s an example of how the Liskov Substitution Principle can be applied in a game development context: Imagine you are building a game that has a character class, which represents a player character in the game. The character class has a method called “Move()” that allows the character to move around in the game world. You want to create a derived class for enemy characters, called “EnemyCharacter”, which should behave in the same way as the character class, but with some additional behavior for attacking the player character. One way to implement this might be to simply copy the code for the Move() method from the character class into the EnemyCharacter class. However, this violates the Liskov Substitution Principle, because the EnemyCharacter class is now incompatible with any existing code that expects the character class to behave in a certain way. A better way to implement this would be to use inheritance and override the Move() method in the EnemyCharacter class, while still maintaining the same behavior as the character class. This way, the EnemyCharacter class can be used in the same way as the character class, but with the added behavior for attacking the player character. Here’s some example code to illustrate this: In this example, the EnemyCharacter class derives from the Character class and overrides the Move() method, while still maintaining the same behavior as the character class. This allows the EnemyCharacter class to be used in the same way as the character class, but with the added behavior for attacking the player character. This ensures that the Liskov Substitution Principle is upheld, and any existing code that expects the character class to behave in a certain way will work correctly with the EnemyCharacter class.\n\nIInterface Segregation Principle (ISP): This principle states that clients (classes that depend on other classes) should not be forced to depend on interfaces they do not use. In other words, interfaces should be small and specific, rather than large and general. Here’s an example of how the Interface Segregation Principle can be applied in a game development context: Imagine you are building a game that has a character class, which represents a player character in the game. The character class has several behaviors, such as movement, attacking, and interacting with objects in the game world. You want to create an interface for the character class, called “ICharacter”, to specify the behaviors that the character class should have. One way to implement this might be to create a single, general interface called “ICharacter” that includes all of the behaviors for the character class. However, this violates the Interface Segregation Principle, because the interface is now large and general, and any class that implements it is forced to depend on all of the behaviors, even if it only needs to use a few of them. A better way to implement this would be to create several small, specific interfaces, each representing a single behavior. The character class can then implement all of these interfaces, rather than a single, general interface. This way, classes that depend on the character class can choose which interfaces they want to depend on, rather than being forced to depend on a large, general interface. Here’s some example code to illustrate this: In this example, the character class implements three separate interfaces, each representing a single behavior. This allows classes that depend on the character class to choose which interfaces they want to depend on, rather than being forced to depend on a single, large interface. This ensures that the Interface Segregation Principle is upheld, and clients are not forced to depend on interfaces they do not use.\n\nDDependency Inversion Principle (DIP): This principle states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This helps to decouple the different components of a software system, making it easier to change one part of the system without affecting other parts. Here’s an example of how the Dependency Inversion Principle can be applied in a game development context: Imagine you are building a game that has a character class, which represents a player character in the game. The character class needs to be able to move around in the game world, so it has a method called “Move()”. However, you want to give the player the option to control the character using either a keyboard or a gamepad. One way to implement this might be to have the character class depend directly on classes for handling keyboard input and gamepad input. However, this violates the Dependency Inversion Principle, because the character class is now directly dependent on low-level input handling classes. A better way to implement this would be to create an abstraction for input handling, such as an interface called “IInputHandler”. The character class can then depend on this abstraction, rather than on specific input handling classes. This way, the character class is no longer directly dependent on low-level input handling classes, and it can be used with any implementation of the IInputHandler interface. Here’s some example code to illustrate this: In this example, the character class depends on the IInputHandler abstraction, rather than on specific input handling classes. This allows the character class to be used with any implementation of the IInputHandler interface, such as the KeyboardInputHandler or the GamepadInputHandler. This makes the character class more flexible and easier to maintain, as it is not tied to any specific input handling implementation."
    },
    {
        "link": "https://unity.com/blog/game-programming-patterns-update-ebook",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/10qtoe4/what_are_some_game_design_patterns_that_you_wish",
        "document": "The subreddit covers various game development aspects, including programming, design, writing, art, game jams, postmortems, and marketing. It serves as a hub for game creators to discuss and share their insights, experiences, and expertise in the industry."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/cqaxgm/solid_design_patterns_unity_single_responsibility",
        "document": "The subreddit covers various game development aspects, including programming, design, writing, art, game jams, postmortems, and marketing. It serves as a hub for game creators to discuss and share their insights, experiences, and expertise in the industry."
    },
    {
        "link": "https://discussions.unity.com/t/health-system/805432",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/UIE-Events-Handling.html",
        "document": "Handle event callbacks and value changes\n\nEvents in UI(User Interface) Allows a user to interact with your application. Unity currently supports three UI systems. More info\n\nSee in Glossary Toolkit are similar to HTML events. When an event occurs, UI Toolkit sends it to the target visual elementA node of a visual tree that instantiates or derives from the C# class. You can style the look, define the behaviour, and display it on screen as part of the UI. More info\n\nSee in Glossary and all elements within the propagation path in the visual treeAn object graph, made of lightweight nodes, that holds all the elements in a window or panel. It defines every UI you build with the UI Toolkit.\n\nSee in Glossary.\n\nThe event handling sequence is as follows:\n• Execute event callbacks on elements from the root element down to the event target. This is the trickle-down phase of the dispatch process.\n• Execute event callbacks on elements from the event target up to the root. This is the bubble-up phase of the dispatch process.\n\nAs an event moves along the propagation path, the property updates to the element currently handling the event. Within an event callback function:\n• is the visual element that the callback registers on.\n• is the visual element where the original event occurs.\n\nFor more information, see Dispatching events.\n\nYou can register an event callback to customize the behavior of an individual instance of an existing class, such as reacting to a mouse click on a text label. To register a callback for an event, use the method to register the callback directly on the element.\n\nEach element along the propagation path (except the target) can receive an event twice:\n• Once during the trickle-down phase.\n• Once during the bubble-up phase.\n\nBy default, a registered callback executes during the target phase and the bubble-up phase. This default behavior ensures that a parent element reacts after its child element.\n\nHowever, if you want a parent element to react before its child, register your callback with the option like this:\n\nThis informs the dispatcher to execute the callback at the target phase and the trickle-down phase.\n\nTo add a custom behavior to a specific visual element, register an event callback on that element like this:\n\nThe signature for the callback function looks like this:\n\nFor an element whose child elements handle the event, to register a callback, use the method to find the child element and register the callback on it.\n\nThe following example registers a callback on a slider’s drag container element to handle the pointer up event for the slider. In this case, you must register the callback on the drag container element instead of the slider itself because the drag container captures the pointer during pointer down events, which makes it the only receiver for the next pointer up event.\n\nNote: You can register multiple callbacks for an event. However, you can only register the same callback function on the same event and propagation phase once.\n\nTo remove a callback from a , call the method.\n\nFor information on how to get access to a visual element from a MonoBehaviour, refer to Get started with runtime UI.\n\nYou can send custom data along with the callback to an event. To attach custom data, you must extend the call to register the callback.\n\nThe following example registers a callback for and sends custom data to the callback function:\n\nThe signature for the callback function looks like this:\n\nManage the value of a control\n\nUI controls use the property to hold data for their internal state. For example:\n• A holds a Boolean value that changes when the is turned on or off.\n• An holds an integer that holds the field’s value.\n\nTo get the value of a control:\n• None Get the value from the control directly: .\n• Listen to a sent by the control and process the change when it happens. You must register your callback to the event like this: //RegisterValueChangedCallback is a shortcut for RegisterCallback<ChangeEvent>. //It constrains the right type of T for any VisualElement that implements an //INotifyValueChange interface. myIntegerField.RegisterValueChangedCallback(OnIntegerFieldChange); The signature for the callback function looks like this:\n\nTo change the value of a control:\n• Directly change the variable: . This triggers a new .\n• Use . This doesn’t trigger a new .\n\nFor more information, see Change events"
    },
    {
        "link": "https://discussions.unity.com/t/game-switches-for-npcs-events/824691",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/16uq60i/unity_developer_here_if_using_event_tick_is",
        "document": "I've been reading everywhere how you wouldn't use event tick, unless you absolutely need to, and even if you need to, you should in c++. Can someone tell me the reason why it's different in UE compared to Unity, where i see ALOT of things being done in the Update function."
    },
    {
        "link": "https://docs.convai.com/api-docs/plugins-and-integrations/unity-plugin/utilities/dynamic-information-context",
        "document": "The Dynamic Information feature enables you to pass variables to NPCs in real time, allowing them to react dynamically to changes in the game environment. This can include the player’s current health, inventory items, or contextual world information, greatly enhancing interactivity and immersion.\n\nFirst, Add the Dynamic Info Controller Component to your Convai NPC.\n\nCreate a new script or use an existing script to define a variable that will store a reference to the Dynamic Info Controller Component you added to your NPC.\n\nExample: Passing Player Health to the NPC\n• None Initialize the Dynamic Info: In the script’s Start method, call the method on the Dynamic Info Controller reference. This will set the dynamic information that the NPC will use. In this example, we’ll initialize the Player’s health as a dynamic variable.\n• None Updating the Dynamic Info: Whenever you need to update the NPC with new information (such as a change in Player Health), call the method on the Dynamic Info Controller.\n• None At the start of the game, we set the Player’s health to 100 and send this information to the NPC as the initial value.\n• None Then, when the player takes damage (simulated here by pressing the \"K\" key), we reduce the Player’s health and update the Dynamic Info in real time so that the NPC remains aware of the Player's current health status.\n\nBelow, we provide a sample conversation showcasing how the NPC can react based on the dynamic health information of the Player. By dynamically updating the Player's health, NPCs can deliver responses that feel personalized and relevant to the current gameplay.\n\nAdd the Dynamic Info Controller to your NPC. Use to initialize the dynamic variable at the start, and call again whenever updates are needed.\n\nThis feature provides a powerful tool for creating NPC interactions that respond in real-time to the state of the game world, creating a more immersive experience for the player."
    }
]