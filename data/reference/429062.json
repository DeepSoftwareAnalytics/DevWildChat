[
    {
        "link": "https://developers.katalon.com/reference/find-id-variables-for-api-calls",
        "document": "Getting Started With Your API\n\nGetting Started With Your API\n\nKatalon API uses ID values to identify resources, such as the name of your Organization, Project, test suites, and more. To access a resource through an API call, specify the ID value in the request URL.\n\nTo find your project ID, log in to TestOps with your credentials. Select your desired project. You can see the project ID in the URL.\n\nA Katalon project can have multiple script repositories to store different types of tests. Script repositories are fully integrated with Git for version control and synchronization between different modules in the Katalon Platform.\n\nTo find the ID of a test project, in TestOps, go to your Katalon project > Configurations > Script Repositories, and select the desired script configuration. The test project ID is displayed in the URL.\n\nTo perform the request methods for the endpoint, you need to provide a\n\nTo find the in TestOps, go to your Project > Test Management > Test Cases, and select the desired test case.\n\nYou can see the ID in the browser's address bar as shown below:\n\nIn the URL , the test case ID is .\n\nTo find the ID of a test suite in a test run, go to your project > Test Management > Test Suites, and select the desired test suite.\n\nYou can see the ID in the browser's address bar as shown below:\n\nIn the URL , the test suite ID is .\n\nTestOps uses the Project ID and order value to identify a test run in API requests. To retrieve your Project ID and order value, in TestOps, go to your Project > Reports > Test Runs, and select the desired test run.\n\nYou can see the Project ID and order value in the browser's address bar as shown below:\n\nIn the URL , the Project ID and test run order are and , respectively.\n\nTo identify a object, TestOps uses the ID of the child object. You can use this ID in API requests to query information about the corresponding scheduled test execution.\n\nTo find the ID of a object (or the ID of the child ) in TestOps, go to your Project > Test Execution > Test Run List, and select the scheduled test execution.\n\nYou can see the ID in the browser's address bar as shown below:\n\nFor example, with the URL , the ID is .\n\nA object shares the same ID as its parent object.\n\nA test result belongs to only one test run. See: Test run.\n\nTestOps uses the test result ID to identify a object. To find the ID of a test result in a test run, follow these steps:\n• In TestOps, go to your project > Reports > Test Runs, and select the desired test run.\n• Switch to the Test Results tab. You can see a list of test result IDs of test cases associated with the test run.\n\nTo find the ID of a object, in TestOps, go to your Project > Planning > Releases, and select the desired release.\n\nYou can see the ID in the browser's address bar as shown below:\n\nIN the URL , the release ID is .\n\nA release can have several builds, to find the ID of a specific build of a release:\n• In TestOps, go to your Project > Planning > Releases and select a release.\n• In the Builds section, select the desired build.\n\nYou can see the build ID in the browser's address bar as shown below:\n\nIn the URL , the build ID is ."
    },
    {
        "link": "https://developers.katalon.com/reference/testops-api-documentation",
        "document": "Getting Started With Your API\n\nGetting Started With Your API\n\nThe Katalon TestOps API allows you to interact with the Katalon Platform and create integrations with other tools and frameworks. These integrations can help enhance your test orchestration activities, including:\n• Test Management: Create and query information on test resources for integrations, such as test suites, test cases, and test objects.\n• Environment Configuration: Set up your test execution agents to automate your test pipeline.\n• Scheduling: Interact with the Smart Scheduler to create and trigger test runs.\n\nAPI access is over HTTPS and begins with . All data is sent and received as JSON."
    },
    {
        "link": "https://docs.qameta.io/allure-testops/briefly/test-cases",
        "document": "Test case is the main object in Allure TestOps. A test case defines the testing procedure, either manual or automated, and can include additional information such as tags to make the process of managing a large number of test cases easier.\n\nEach test case in Allure TestOps has a name, which you provide when you create a test case, a unique identifier (AllureID), which is assigned automatically by Allure TestOps, and a workflow status — the current life cycle state of a test case (e.g., draft, active, outdated, etc.). You can learn more about workflows in a dedicated article.\n\nIf a test case is manual, it usually includes a test scenario — a set of steps that must be followed to check whether the software is working as intended. It can also include test parameters, which allow you to run the test case with different data. To learn more, see Manual test scenarios and Manual test parameters.\n\nTest cases can additionally include a number of attributes; each of them is described in more detail in a separate article:\n• Tags. Tags are custom labels you can apply to your test cases to help organize and filter them.\n• Test layers. Test cases can be organized into distinct testing layers, such as API tests, UI tests, unit tests, etc. Unlike tags, a test case can only belong to one testing layer at a time.\n• Custom fields. You can create your own set of custom fields to use with your test cases.\n• Members. Team members can be assigned to test cases with specific roles, helping you track and manage the workload of your team.\n• External issue links and external test case links aka Test keys.\n• Test cases can be linked to issues in third-party trackers (like Jira, Redmine, etc.)\n• Test cases in third-party test management tools (like TestRail and Zephyr Scale) when synchronising test cases from Allure TestOps to third-party TMSs.\n• Relations. You can link a test case to other test cases and specify the type of relation between them.\n\nAll of these attributes can be added using the web interface or, with the exception of relations, by specifying them in the test results you upload to Allure TestOps.\n\nAllure TestOps allows you to work with both manual and automated test cases. Manual test cases are the test cases that you create using the web interface. Automated test cases are those that were created automatically by uploading the test results generated by your testing framework (using one of the Allure Report integrations).\n• None Go to the Test cases section.\n• None At the bottom of the screen, click + Test Case, type a name for the new test case and press . If you need to create several test cases, press + instead of . You can change this behavior using the Display → Creation settings menu.\n• None On the right side of the page, you can add a description and a test scenario for the test case, and change the attributes of the test case.\n• None To rename or delete the selected test case, click in the top right corner of the screen and select the required action. Alternatively, you can hover over the test case, click next to its name, and select the required action.\n\nAutomated test cases are created by Allure TestOps when test results are uploaded to Allure TestOps after closing created launch.\n\nNormally, this process is automated by using of allurectl or relevant CI plugin and integrating your CI pipelines with Allure TestOps, but you can also upload test results manually using the web interface.\n\nIn general, the process looks like follows.\n• You integrate your test framework with Allure Framework by using appropriate adaptor.\n• You run your tests as usual (from CI pipeline, upload from IDE, or manual upload via UI). After running the tests, the adapter will generate test results — a set of files in JSON format.\n• These test results are then uploaded to Allure TestOps using allurectl or other means.\n• When Allure TestOps receives test results it creates a new launch, associates the test results from a single run with the created launch, then, after you close the created launch, it creates test cases for uploaded test results (if those don't exist already) or updates an existing ones.\n• Go to the Launches section.\n• In the top right corner of the page, click the Import button.\n• In the resulting window, select the type of upload (individual files or a ZIP archive) and click the upload area or drag and drop files to upload them.\n• Optionally, specify attributes that will be applied to the uploaded results.\n\nYou can achieve the same result by dragging a zip file with the test results to Launches page or dragging full directory content to the Launches page.\n\nWe also provide plugins for popular IDEs that make the process of creating and uploading test results easier.\n\nTest cases can be imported from a CSV file created by Microsoft Excel, Google Sheets, or a third-party test management tool.\n\nTo learn more about that, see Importing test cases from CSV files.\n\nTo sort the list of test cases:\n• From the Sort by menu, select the field by which you want to sort the test cases.\n• From the Direction menu, select the direction of sorting.\n\nAdditionally, you can customize how a test case looks in the list of test cases:\n• Under List options, select elements you want to display.\n\nYou can filter test cases by the values of their main and additional attributes:\n• To filter by main attributes, you only need to enter the search text.\n• To filter by additional attributes, you need to specify the attribute and its value.\n\nOne filter can contain several search terms for additional attributes and one search term for main attributes. If you specify several search terms, all of them must be matched for a test case to be shown in the filtered list.\n\nThe main attributes of a test case are:\n\nTo filter test cases by their main attributes:\n• In the Test cases section, click the search box above the test case list.\n• Enter the text to search and press . This text will be used to search through all the main test case attributes at the same time.\n• To clear the search box, press or click Clear under the search box.\n\nTo filter test cases by their additional attributes:\n• None In the Test cases section, click the search box above the test case list.\n• None Select an attribute to be searched.\n• None Select one or more values for the attribute. To find test cases that don't have a specified value for the attribute (e.g., find test cases without tags), switch the No value toggle on.\n• None To clear the search box, press or click Clear under the search box.\n\nWhen selecting values for additional attributes, you can change the Filter conditions:\n• None Partial Match — finds test cases that contain at least one of the specified values. This is the default option.\n• None Exact Match — finds test cases that contain all the specified values. You can select this option for multiple-value attributes, such as tags.\n• None Does Not Contain — finds test cases that do not contain the specified values. If you switch the No value toggle on, only test cases with a non-empty attribute will be found instead.\n\nConditions are selected separately for each attribute specified in the filter. To change filter conditions, click on the attribute in the search box and select new conditions.\n\nTo save a filter for future use:\n• After entering search terms, click Save under the search box.\n• Enter a name for the filter.\n• Choose who will have access to this filter: only you or all members of the project team.\n\nThe saved filter will appear below the search box. To modify or delete a saved filter, right-click it and select the action you need.\n\nYou can delete, clone, and change attributes of several test cases at once using the bulk actions menu.\n• Go to the Test cases section.\n• Select one or more test cases using or by checking the boxes next to them.\n• Click in the bottom panel and select the action you need.\n\nTo clear the selection, click the cross icon in the bottom panel.\n\nDeleted test cases are moved to the special \"folder\" (the Trash tree) from which they can be restored.\n• Go to the Test cases section.\n• In the top left corner, click All test cases (or the name of the tree if it has been changed).\n\nYou will see a list of deleted test cases. For each test case in the list, you will have the option to restore or delete it permanently.\n• In the top right part of the screen, click the Restore icon to restore the test case, or → Delete permanently to delete it.\n\nAlternatively, you can hover over the test case, click next to its name and select the required action.\n\nTo restore or delete several test cases:\n• Select the test cases using or by checking the boxes next to them.\n• In the panel at the bottom, click Restore to restore the test cases, or → Delete permanently to delete them.\n\nTest cases are restored to their previous positions in the tree with all custom field values intact.\n\nTo view the history and results of test case runs:\n• Go to the Test cases section and select a test case.\n• In the upper-right part of the screen, go to the History tab.\n\nEach item in the list of test case history includes:\n• name of the user who executed the test;\n\nTo view more details about a launch, click its name.\n\nYou can compare several test results side by side. To do this, select the results you want to compare by selecting the checkboxes next to them and click the Compare test results icon above the list.\n\nYou can filter the list of test results. To do this:\n• None Click the Filter test results icon above the list.\n• None In the resulting window, select attributes for filtering (for example, to show only failed tests).\n• None Close the window by clicking the close button in its upper-right corner. To change the filter conditions after closing the window, click the Filter test results icon.\n• None To clear filters and return to the full list, click the Clear filter icon.\n\nYou can also view the history and results of test case runs in the Launches section. To do this:\n• Go to the Launches section and open a launch.\n• Go to the Tree tab.\n• Select a test result and go to the History tab in the upper-right part of the screen.\n\nPlease note that in this case, unlike in the Test cases section, only results that are older and have the same test parameters as the selected result will be shown by default. To view all results, click Show full history above the list.\n\nMuting is an Allure TestOps feature that allows you to resolve a failing test result associated with particular test case by providing a reason why it can be ignored.\n• Go to Test cases and open a test case.\n• In the top right part of the screen, under the name of the test case, go to the Mutes tab.\n• Enter a name and a reason for the mute.\n• Optionally, add an issue link to the mute (see Issue links for more info).\n\nTo mute several test cases at once, use the bulk actions menu.\n\nAllure TestOps supports the creation of automated test cases using code generation — a feature that allows you to quickly create a template for your testing framework with the required test case attributes (metadata).\n\nCode generation uses an existing Allure TestOps test case and its attributes to create a template. You can select a previously created test case or create a new temporary one with the required metadata.\n• Go to Test cases and open a test case.\n• Click in the top right corner of the screen and select Generate code.\n• Choose which attributes should be included in the code.\n• Click Download to download the code or Copy to copy it into clipboard.\n\nAutomated test cases can be converted to manual test cases. After this conversion, the automation parts of a test case will be detached from it and all future uploaded test results will no longer be linked to that test case. If an automated test case has test steps (the steps field in the JSON test result file), they can be automatically converted to a manual test scenario.\n\nTo convert an automated test case to a manual test case:\n• None Click in the top right corner of the screen and select Convert into manual. In the resulting window, you will be able to select a workflow for the test case and choose the source for the test scenario.\n• None Under Copy scenario from, select what do you want to use as the source for the test scenario.\n• Test result — convert the test steps from test results to a test scenario.\n• None Under Workflow, select a workflow for the test case.\n• None Under Status, select a workflow status for the test case."
    },
    {
        "link": "https://github.com/katalon-studio/testops-api-java",
        "document": "To install the API client library to your local Maven repository, simply execute:\n\nTo deploy it to a remote Maven repository instead, configure the settings of the repository and execute:\n\nRefer to the OSSRH Guide for more information.\n\nAdd this dependency to your project's POM:\n\nAdd this dependency to your project's build file:\n\nAt first generate the JAR by executing:\n\nThen manually install the following JARs:\n\nPlease follow the installation instruction and execute the following Java code:\n\nAll URIs are relative to http://localhost:8443\n\nIt's recommended to create an instance of per thread in a multithreaded environment to avoid any potential issues."
    },
    {
        "link": "https://developers.qase.io/reference/get-cases",
        "document": "Create a new configuration in a particular group.\n\nCreate a new configuration in a particular group.\n\nGet all configuration groups with configurations.\n\nGet all configuration groups with configurations.\n\nDetach the external issues from the test cases\n\nDetach the external issues from the test cases\n\nAttach the external issues to the test cases\n\nAttach the external issues to the test cases\n\nThis method allows to retrieve all test cases stored in selected project."
    },
    {
        "link": "https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design",
        "document": "REST APIs are one of the most common kinds of web interfaces available today. They allow various clients including browser apps to communicate with services via the REST API. Therefore, it's very important to design REST APIs properly so that we won't run into problems down the road. We have to take into account security, performance, and ease of use for API consumers.\n\nOtherwise, we create problems for clients that use our APIs, which isn’t pleasant and detracts people from using our API. If we don’t follow commonly accepted conventions, then we confuse the maintainers of the API and the clients that use them since it’s different from what everyone expects.\n\nIn this article, we'll look at how to design REST APIs to be easy to understand for anyone consuming them, future-proof, and secure and fast since they serve data to clients that may be confidential.\n• Use nouns instead of verbs in endpoint paths\n\nA REST API is an application programming interface architecture style that conforms to specific architectural constraints, like stateless communication and cacheable data. It is not a protocol or standard. While REST APIs can be accessed through a number of communication protocols, most commonly, they are called over HTTPS, so the guidelines below apply to REST API endpoints that will be called over the internet.\n\nNote: For REST APIs called over the internet, you'll like want to follow the best practices for REST API authentication.\n\nEven though some people think REST should only return hypertext (including Roy Fielding who created the term) REST APIs should accept JSON for request payload and also send responses to JSON. JSON is the standard for transferring data. Almost every networked technology can use it: JavaScript has built-in methods to encode and decode JSON either through the Fetch API or another HTTP client. Server-side technologies have libraries that can decode JSON without doing much work.\n\nThere are other ways to transfer data. XML isn’t widely supported by frameworks without transforming the data ourselves to something that can be used, and that’s usually JSON. We can’t manipulate this data as easily on the client-side, especially in browsers. It ends up being a lot of extra work just to do normal data transfer.\n\nForm data is good for sending data, especially if we want to send files. But for text and numbers, we don’t need form data to transfer those since—with most frameworks—we can transfer JSON by just getting the data from it directly on the client side. It’s by far the most straightforward to do so.\n\nTo make sure that when our REST API app responds with JSON that clients interpret it as such, we should set Content-Type in the response header to application/json after the request is made. Many server-side app frameworks set the response header automatically. Some HTTP clients look at the Content-Type response header and parse the data according to that format.\n\nThe only exception is if we’re trying to send and receive files between client and server. Then we need to handle file responses and send form data from client to server. But that is a topic for another time.\n\nWe should also make sure that our endpoints return JSON as a response. Many server-side frameworks have this as a built-in feature.\n\nLet’s take a look at an example API that accepts JSON payloads. This example will use the Express back end framework for Node.js. We can use the body-parser middleware to parse the JSON request body, and then we can call the res.json method with the object that we want to return as the JSON response as follows:\n\nbodyParser.json() parses the JSON request body string into a JavaScript object and then assigns it to the req.body object.\n\nSet the Content-Type header in the response to application/json; charset=utf-8 without any changes. The method above applies to most other back end frameworks.\n\nUse nouns instead of verbs in endpoint paths\n\nWe shouldn't use verbs in our endpoint paths. Instead, we should use the nouns which represent the entity that the endpoint that we're retrieving or manipulating as the pathname.\n\nThis is because our HTTP request method already has the verb. Having verbs in our API endpoint paths isn’t useful and it makes it unnecessarily long since it doesn’t convey any new information. The chosen verbs could vary by the developer’s whim. For instance, some like ‘get’ and some like ‘retrieve’, so it’s just better to let the HTTP GET verb tell us what and endpoint does.\n\nThe action should be indicated by the HTTP request method that we're making. The most common methods include GET, POST, PUT, and DELETE.\n• POST submits new data to the server.\n\nWith the two principles we discussed above in mind, we should create routes like GET /articles/ for getting news articles. Likewise, POST /articles/ is for adding a new article , PUT /articles/:id is for updating the article with the given id. DELETE /articles/:id is for deleting an existing article with the given ID.\n\n/articles represents a REST API resource. For instance, we can use Express to add the following endpoints for manipulate articles as follows:\n\nIn the code above, we defined the endpoints to manipulate articles. As we can see, the path names do not have any verbs in them. All we have are nouns. The verbs are in the HTTP verbs.\n\nThe POST, PUT, and DELETE endpoints all take JSON as the request body, and they all return JSON as the response, including the GET endpoint.\n\nWhen designing endpoints, it makes sense to group those that contain associated information. That is, if one object can contain another object, you should design the endpoint to reflect that. This is good practice regardless of whether your data is structured like this in your database. In fact, it may be advisable to avoid mirroring your database structure in your endpoints to avoid giving attackers unnecessary information.\n\nFor example, if we want an endpoint to get the comments for a news article, we should append the /comments path to the end of the /articles path. We can do that with the following code in Express:\n\nIn the code above, we can use the GET method on the path '/articles/:articleId/comments'. We get comments on the article identified by articleId and then return it in the response. We add 'comments' after the '/articles/:articleId' path segment to indicate that it's a child resource of /articles.\n\nThis makes sense since comments are the children objects of the articles, assuming each article has its own comments. Otherwise, it’s confusing to the user since this structure is generally accepted to be for accessing child objects. The same principle also applies to the POST, PUT, and DELETE endpoints. They can all use the same kind of nesting structure for the path names.\n\nHowever, nesting can go too far. After about the second or third level, nested endpoints can get unwieldy. Consider, instead, returning the URL to those resources instead, especially if that data is not necessarily contained within the top level object.\n\nFor example, suppose you wanted to return the author of particular comments. You could use /articles/:articleId/comments/:commentId/author. But that's getting out of hand. Instead, return the URI for that particular user within the JSON response instead:\n\nTo eliminate confusion for API users when an error occurs, we should handle errors gracefully and return HTTP response codes that indicate what kind of error occurred. This gives maintainers of the API enough information to understand the problem that’s occurred. We don’t want errors to bring down our system, so we can leave them unhandled, which means that the API consumer has to handle them.\n• 401 Unauthorized - This means the user isn't not authorized to access a resource. It usually returns when the user isn't authenticated.\n• 403 Forbidden - This means the user is authenticated, but it's not allowed to access a resource.\n• 404 Not Found - This indicates that a resource is not found.\n• 500 Internal server error - This is a generic server error. It probably shouldn't be thrown explicitly.\n• 502 Bad Gateway - This indicates an invalid response from an upstream server.\n• 503 Service Unavailable - This indicates that something unexpected happened on server side (It can be anything like server overload, some parts of the system failed, etc.).\n\nWe should be throwing errors that correspond to the problem that our app has encountered. For example, if we want to reject the data from the request payload, then we should return a 400 response as follows in an Express API:\n\nIn the code above, we have a list of existing users in the users array with the given email.\n\nThen if we try to submit the payload with the email value that already exists in users, we'll get a 400 response status code with a 'User already exists' message to let users know that the user already exists. With that information, the user can correct the action by changing the email to something that doesn't exist.\n\nError codes need to have messages accompanied with them so that the maintainers have enough information to troubleshoot the issue, but attackers can’t use the error content to carry our attacks like stealing information or bringing down the system.\n\nWhenever our API does not successfully complete, we should fail gracefully by sending an error with information to help users make corrective action.\n\nThe databases behind a REST API can get very large. Sometimes, there's so much data that it shouldn’t be returned all at once because it’s way too slow or will bring down our systems. Therefore, we need ways to filter items.\n\nWe also need ways to paginate data so that we only return a few results at a time. We don't want to tie up resources for too long by trying to get all the requested data at once.\n\nFiltering and pagination both increase performance by reducing the usage of server resources. As more data accumulates in the database, the more important these features become.\n\nHere’s a small example where an API can accept a query string with various query parameters to let us filter out items by their fields:\n\nIn the code above, we have the req.query variable to get the query parameters. We then extract the property values by destructuring the individual query parameters into variables using the JavaScript destructuring syntax. Finally, we run filter on with each query parameter value to locate the items that we want to return.\n\nOnce we have done that, we return the results as the response. Therefore, when we make a GET request to the following path with the query string:\n\nas the returned response since we filtered by lastName and age.\n\nLikewise, we can accept the page query parameter and return a group of entries in the position from (page - 1) * 20 to page * 20.\n\nWe can also specify the fields to sort by in the query string. For instance, we can get the parameter from a query string with the fields we want to sort the data for. Then we can sort them by those individual fields.\n\nFor instance, we may want to extract the query string from a URL like:\n\nWhere + means ascending and - means descending. So we sort by author’s name in alphabetical order and datepublished from most recent to least recent.\n\nMost communication between client and server should be private since we often send and receive private information. Therefore, using SSL/TLS for security is a must.\n\nA SSL certificate isn't too difficult to load onto a server and the cost is free or very low. There's no reason not to make our REST APIs communicate over secure channels instead of in the open.\n\nPeople shouldn't be able to access more information that they requested. For example, a normal user shouldn't be able to access information of another user. They also shouldn't be able to access data of admins.\n\nTo enforce the principle of least privilege, we need to add role checks either for a single role, or have more granular roles for each user.\n\nIf we choose to group users into a few roles, then the roles should have the permissions that cover all they need and no more. If we have more granular permissions for each feature that users have access to, then we have to make sure that admins can add and remove those features from each user accordingly. Also, we need to add some preset roles that can be applied to a group users so that we don’t have to do that for every user manually.\n\nWe can add caching to return data from the local memory cache instead of querying the database to get the data every time we want to retrieve some data that users request. The good thing about caching is that users can get data faster. However, the data that users get may be outdated. This may also lead to issues when debugging in production environments when something goes wrong as we keep seeing old data.\n\nThere are many kinds of caching solutions like Redis, in-memory caching, and more. We can change the way data is cached as our needs change.\n\nFor instance, Express has the apicache middleware to add caching to our app without much configuration. We can add a simple in-memory cache into our server like so:\n\nThe code above just references the apicache middleware with apicache.middleware and then we have:\n\nto apply the caching to the whole app. We cache the results for five minutes, for example. We can adjust this for our needs.\n\nIf you are using caching, you should also include Cache-Control information in your headers. This will help users effectively use your caching system.\n\nWe should have different versions of API if we're making any changes to them that may break clients. The versioning can be done according to semantic version (for example, 2.0.6 to indicate major version 2 and the sixth patch) like most apps do nowadays.\n\nThis way, we can gradually phase out old endpoints instead of forcing everyone to move to the new API at the same time. The v1 endpoint can stay active for people who don’t want to change, while the v2, with its shiny new features, can serve those who are ready to upgrade. This is especially important if our API is public. We should version them so that we won't break third party apps that use our APIs.\n\nVersioning is usually done with /v1/, /v2/, etc. added at the start of the API path.\n\nFor example, we can do that with Express as follows:\n\nWe just add the version number to the start of the endpoint URL path to version them.\n\nThe most important takeaways for designing high-quality REST APIs is to have consistency by following web standards and conventions. JSON, SSL/TLS, and HTTP status codes are all standard building blocks of the modern web.\n\nPerformance is also an important consideration. We can increase it by not returning too much data at once. Also, we can use caching so that we don't have to query for data all the time.\n\nPaths of endpoints should be consistent, we use nouns only since the HTTP methods indicate the action we want to take. Paths of nested resources should come after the path of the parent resource. They should tell us what we’re getting or manipulating without the need to read extra documentation to understand what it’s doing."
    },
    {
        "link": "https://stackoverflow.com/questions/29571284/for-restful-api-can-get-method-use-json-data",
        "document": "In theory, there's nothing preventing you from sending a request body in a request. The HTTP protocol allows it, but have no defined semantics, so it's up to you to document what exactly is going to happen when a client sends a payload. For instance, you have to define if parameters in a JSON body are equivalent to querystring parameters or something else entirely.\n\nHowever, since there are no clearly defined semantics, you have no guarantee that implementations between your application and the client will respect it. A server or proxy might reject the whole request, or ignore the body, or anything else. The REST way to deal with broken implementations is to circumvent it in a way that's decoupled from your application, so I'd say you have two options that can be considered best practices.\n\nThe simple option is to use instead of as recommended by other answers. Since is not standardized by HTTP, you'll have to document how exactly that's supposed to work.\n\nAnother option, which I prefer, is to implement your application assuming the payload is never tampered with. Then, in case something has a broken implementation, you allow clients to override the HTTP method with the header, which is a popular convention for clients to emulate HTTP methods with . So, if a client has a broken implementation, it can write the request as a , sending the header, and you can have a middleware that's decoupled from your application implementation and rewrites the method accordingly. This is the best option if you're a purist."
    },
    {
        "link": "https://medium.com/swlh/getting-json-data-from-a-restful-api-using-java-b327aafb3751",
        "document": "I like Java. It’s my go to object oriented programming language. It’s easy to use and it gets the job done. Recently, I had to implement an application that gets data from a REST API using Java and oh my god! I started hating Java.\n\nHaving previously worked with technologies such as “ReactJS”, getting JSON (JavaScript Object Notation) data from a RESTful API is just an “axios” call away. JavaScript makes it so easy for me to work with JSON data. Java on the other hand was a mess, and there was no proper material online that I could refer to. So I decided to help anyone who’s struggling to do this in Java.\n\nBefore we begin make sure you have downloaded and installed the JSON Simple Java library (https://github.com/fangyidong/json-simple). For this article I’ll be using the REST API for Covid-19 (https://api.covid19api.com/)\n\nThis is how our JSON data will look,\n\nFirst let’s set the URL object and type cast it into an HttpURLConnection object so that we can set request types and get response codes back. Since we’re only going to get data from the endpoint, let’s set the request method to “GET” and connect. Now we’ll be able to get a response code.\n\nMake sure everything is inside a try and catch block :)\n\nNow that we have a response code, let’s check if it’s successful and if so do the rest of the work.\n\nIf the response code is not 200 (Successful) we throw a new exception, otherwise we use a scanner to go through the URL stream and write all the data we get into a string.\n\nThen using the JSON Simple library we parse that string into a JSON object. Then we can get the object (or array) we want from that object using its key. Here I took the “Global” object containing all the global statistics and displayed the total number of recovered individuals.\n\nIf you want to access an array we simply cast the object we want to a JSONArray and within a for loop try to find the specific object we want from inside the array.\n\nHere you can see the code to get the total number of recovered individuals from “Albania”\n\nBelow you can find the code we used in its entirety,\n\nI hope this article helped anyone who was struggling with this problem. If I forgot to cover something or if something was unclear please let me know :)"
    },
    {
        "link": "https://getambassador.io/blog/7-rest-api-design-best-practices",
        "document": "REST which stands for Representational State Transfer is an architectural style that governs how APIs are designed and built. REST’s popularity and ease of implementation make it the most preferred API architectural style for modern-day software development as compared to other protocols such as SOAP (simple object access protocol).\n\nREST APIs or RESTful web services have become the backbone for efficient communication between client and server in modern-day software development. However, to build efficient and robust REST APIs, it is crucial to follow some standard best practices.\n\nIn this blog, we’ll explore REST API best practices that can help you build scalable, maintainable, secure, and robust APIs.\n\nWhen you’re naming your HTTP request endpoints; it’s recommended that you follow naming conventions that are clear, precise, and aligned with the functionality they represent. If you are developing a RESTful web service for managing books in a library, you’d typically need to provide endpoints to retrieve a list of books, create a new book, update an existing book, and delete a book.\n\nFor almost all the functionalities, you should follow the standard naming convention pattern of /api/books. By using the /books path in the endpoint, we convey that this endpoint is responsible for managing books. For endpoints that update an existing book or delete it from the library, you can use the pattern /api/books/{id}.\n\n2. Use the Appropriate HTTP Method\n\nAfter you’ve named an endpoint, determine which HTTP methods to use based on the nature of the operation being performed. For context:\n• GET requests are used to retrieve resources.\n• PUT requests are typically employed for resource creation or replacement.\n• POST requests are suitable for resource creation when the server assigns a unique identifier.\n• DELETE requests, as the name implies, deletes the specified resource.\n\nGoing back to our previous example, the endpoint /api/books can be used for both creating a book or retrieving a list of books. So, what distinguishes the two? Here's how we can apply clear and precise naming conventions along with the correct HTTP methods to these endpoints:\n\nHere’s an example in Node.js to demonstrate the guidelines shared above:\n\nFollowing these naming conventions ensures consistency, promotes good API design, improves developer experience, and helps prevent confusion or errors when working with the API. It allows developers or API consumers to quickly grasp the purpose and functionality of each endpoint, facilitating efficient API consumption and development.\n\nOnce you’ve designed your endpoints, you need to manage your API requests and responses effectively. This will ensure a smooth and secure user experience and efficient communication between client and server.\n\nFor instance, you can use appropriate status codes in your responses so your client can handle them accordingly. Use 200 for all successful requests, 400 for client-based errors, and 500 for server-side errors. You should also regularly monitor your API’s usage and activities. This can be extremely helpful in identifying common errors and issues and any downtimes associated with your API. Ensure that you handle network timeouts as well. Set reasonable timeout limits and provide useful feedback to the client when such timeouts occur alongside the cause of these timeouts.\n\n4. Use the Appropriate Request Headers for Authentication\n\nRequest headers to provide a way to pass authentication information from the client to the server. By utilizing appropriate request headers, you can implement authentication mechanisms like API keys, JWT (JSON Web Tokens), OAuth, or other custom authentication schemes. Here are some recommended request headers to use:\n\nAuthorization header: The Authorization header allows the client to include authentication credentials, such as tokens or API keys, in the request header. Here’s an example that uses the Bearer scheme to send the JWT after the scheme as authentication credentials.\n• API key header: Another approach is using an x-api-key header to authenticate API requests. The client includes an API key, a unique identifier, in this header. The header carries the API key value, which is sent to the client for authentication.\n• Custom headers: Depending on the authentication mechanism implemented, custom headers can pass authentication-related information.\n\n5. Know When to use Parameters vs. Query Parameters\n\nWeb APIs often require you to work with additional information passed in the endpoint from the client. Understanding when to use path parameters (e.g., /api/books/{id}) versus query parameters (e.g., /api/books?category=fiction) is essential, especially for API consumers.\n\nPath parameters are typically used to identify or retrieve a specific resource. Query parameters are more suitable for sorting the request data. You can also use it for filtering and pagination.\n\nReturning to our previous example of books API, we’ve used path parameters for deleting a book or updating a book information using the endpoint /api/books/{id}. Here, the path parameter is id, and its value is the unique book identifier. On the other hand, let’s say you wish to retrieve all the books that belong to a certain category. You can use query parameters to specify this filter, such as /api/books?category=fiction. Here, the query parameter is category, and its value is fiction.\n\nA good API design ensures that your RESTful web services throw the correct error when needed. Having a robust error-handling mechanism aims to provide informative and actionable error messages.\n\nYou should wrap your code in Try-Catch blocks and return appropriate HTTP status codes, error payloads, and error messages that can be directly displayed to your users.\n\nConsider the following API, which retrieves book information based on the path parameter id:\n\nIn the code snippet above, a 404 status is returned if the book doesn’t exist in the database. It also returns a 500 status with a generic error message if the API fails due to some other reason.\n\n7. Create an API Documentation and Version your REST APIs\n\nTo increase the adoption and ease of use of your APIs, it’s crucial to create and maintain comprehensive API documentation. This documentation should provide information about available endpoints, request and response formats, authentication patterns, etc. OpenAPI, formerly known as Swagger, is a widely adopted specification for documenting REST APIs.\n\nAlong with documentation, you should also version your APIs. API versioning helps to easily manage changes and updates to an API while still maintaining compatibility with other versions of the APIs for clients. To version your APIs, you can assign unique identifiers or labels. Here are some common approaches to versioning your API:\n• URL versioning: In this approach, the API version is included in the URL. For example, /api/v1/books indicate that this is version 1 of the API.\n• Query parameter versioning: The version number is specified as a query parameter in the API request. For example, /api/books?version=1.\n• Header versioning: The version number is a custom header in the API request. For example, Accept-Version: 1.\n• Content negotiation versioning: The version is negotiated based on the Accept header or the media type of the request payload.\n\nVersioning enables you to provide backward compatibility to your clients, facilitate the gradual adoption of changes for developers, and ensure stability throughout your various versions of APIs.\n\nEdge Stack offers features for API documentation and version management, simplifying the process for developers and API consumers. You should check it out.\n\nPerformance is an essential factor in determining the end-user experience of your APIs.\n\nLet’s look at some common performance optimization techniques that you can adopt to create high-performing REST APIs:\n• Use caching mechanisms to store frequently accessed data and reduce the load on the server. This can significantly improve response times when sending data between client and server and also reduce network traffic.\n• Implement pagination to retrieve large datasets in smaller and more manageable chunks to ensure an optimized API design. By returning a limited number of results per page and providing navigation links, APIs can efficiently handle large amounts of data.\n• Apply compression techniques, such as gzip, to reduce the size of data transferred between the client and server. This will improve response times for bandwidth-constrained environments and your application specific architectural constraints.\n• Leverage rate limiting and throttling mechanisms to control the number of requests allowed from a particular client within a specific timeframe. This will prevent abuse and ensure fair usage of your REST API resources.\n\nSecurity is a critical aspect of developing any software. However, security is also a tricky subject. By addressing some common vulnerabilities and implementing robust security measures, you can protect your APIs and the sensitive data they handle.\n\nHere are some security best practices that you should add to your REST APIs against some common vulnerabilities:\n• Properly validate and sanitize user inputs received on the server side. Also, encode the API responses to prevent malicious code execution. Following this will protect your REST APIs against vulnerabilities like SQL injection and cross-site scripting (XSS).\n• Implement foolproof authentication and RBAC (Role-Based Access Control) mechanisms to protect your database resources from being accessed by unauthorized users. Your REST APIs are a gateway to your database, and you should ensure that all of your data is only accessed by users who are allowed to access it.\n• Employ tools like Edge Stack as an API gateway solution for additional security features. It acts as a centralized entry point for all API traffic, enabling traffic encryption through SSL/TLS and offering protection against common attacks like DDoS (Distributed Denial-of-Service).\n\nDesigning and developing REST APIs that adhere to best practices is essential for creating robust, scalable, and secure software systems. Now, you’ve seen how you can create robust, secure, and high-performing APIs right from design to development.\n\nWe also explored the role of Edge Stack as an API Gateway solution that facilitates the implementation of these best practices. Its comprehensive features, including SSO, WAF, version management, security enhancements, and traffic encryption, make it an ideal choice for a robust and secure API Gateway solution.\n\nEnsuring your REST API functions as expected requires rigorous testing and validation. From verifying endpoints and request handling to simulating real-world scenarios, testing is a crucial step in building reliable APIs. Blackbird simplifies this process by providing a powerful platform for API testing and mocking, allowing developers to validate their APIs before deployment."
    },
    {
        "link": "https://stackoverflow.com/questions/7750557/how-do-i-get-json-data-from-restful-service-using-python",
        "document": "Is there any standard way of getting JSON data from RESTful service using Python?\n\nI need to use kerberos for authentication.\n\nsome snippet would help."
    }
]