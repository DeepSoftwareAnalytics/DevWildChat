[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/collections",
        "document": "The .NET runtime provides many collection types that store and manage groups of related objects. Some of the collection types, such as System.Array, System.Span<T>, and System.Memory<T> are recognized in the C# language. In addition, interfaces like System.Collections.Generic.IEnumerable<T> are recognized in the language for enumerating the elements of a collection.\n\nCollections provide a flexible way to work with groups of objects. You can classify different collections by these characteristics:\n• Element access: Every collection can be enumerated to access each element in order. Some collections access elements by index, the element's position in an ordered collection. The most common example is System.Collections.Generic.List<T>. Other collections access elements by key, where a value is associated with a single key. The most common example is System.Collections.Generic.Dictionary<TKey,TValue>. You choose between these collection types based on how your app accesses elements.\n• Performance profile: Every collection has different performance profiles for actions like adding an element, finding an element, or removing an element. You can pick a collection type based on the operations used most in your app.\n• Grow and shrink dynamically: Most collections support adding or removing elements dynamically. Notably, Array, System.Span<T>, and System.Memory<T> don't.\n\nIn addition to those characteristics, the runtime provides specialized collections that prevent adding or removing elements or modifying the elements of the collection. Other specialized collections provide safety for concurrent access in multi-threaded apps.\n\nYou can find all the collection types in the .NET API reference. For more information, see Commonly Used Collection Types and Selecting a Collection Class.\n\nArrays are represented by System.Array and have syntax support in the C# language. This syntax provides more concise declarations for array variables.\n\nSystem.Span<T> is a type that provides a snapshot over a sequence of elements without copying those elements. The compiler enforces safety rules to ensure the can't be accessed after the sequence it references is no longer in scope. It's used in many .NET APIs to improve performance. Memory<T> provides similar behavior when you can't use a type.\n\nBeginning with C# 12, all of the collection types can be initialized using a Collection expression.\n\nAn indexable collection is one where you can access each element using its index. Its index is the number of elements before it in the sequence. Therefore, the element reference by index is the first element, index is the second, and so on. These examples use the List<T> class. It's the most common indexable collection.\n\nThe following example creates and initializes a list of strings, removes an element, and adds an element to the end of the list. After each modification, it iterates through the strings by using a foreach statement or a loop:\n\nThe following example removes elements from a list by index. Instead of a statement, it uses a statement that iterates in descending order. The RemoveAt method causes elements after a removed element to have a lower index value.\n\nFor the type of elements in the List<T>, you can also define your own class. In the following example, the class that is used by the List<T> is defined in the code.\n\nThese examples use the Dictionary<TKey,TValue> class. It's the most common dictionary collection. A dictionary collection enables you to access elements in the collection by using the key of each element. Each addition to the dictionary consists of a value and its associated key.\n\nThe following example creates a collection and iterates through the dictionary by using a statement.\n\nThe following example uses the ContainsKey method and the Item[] property of to quickly find an item by key. The property enables you to access an item in the collection by using the in C#.\n\nThe following example instead uses the TryGetValue method to quickly find an item by key.\n\nAn iterator is used to perform a custom iteration over a collection. An iterator can be a method or a accessor. An iterator uses a yield return statement to return each element of the collection one at a time.\n\nYou call an iterator by using a foreach statement. Each iteration of the loop calls the iterator. When a statement is reached in the iterator, an expression is returned, and the current location in code is retained. Execution is restarted from that location the next time that the iterator is called.\n\nFor more information, see Iterators (C#).\n\nThe following example uses an iterator method. The iterator method has a statement that is inside a loop. In the method, each iteration of the statement body creates a call to the iterator method, which proceeds to the next statement.\n\nLanguage-integrated query (LINQ) can be used to access collections. LINQ queries provide filtering, ordering, and grouping capabilities. For more information, see Getting Started with LINQ in C#.\n\nThe following example runs a LINQ query against a generic . The LINQ query returns a different collection that contains the results."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/csharp/comments/t8amw4/c_offline_documentation",
        "document": "Can anyone help me find C sharp documentation, I'm new to the language, currently typiing console programs running on .NET 5\n\nIn Java, you had some documentation were you see available functions/methods and deprecated methods for eg String class. I'm looking for a similar thing in C#, a source of Language documentation were I'll see available functions for String manipulation, Collection methods/Interface, IOStream, StringBuffer etc"
    },
    {
        "link": "https://stackoverflow.com/questions/398903/what-is-the-difference-between-list-of-t-and-collectionof-t",
        "document": "In C#, there are three concepts for representing a bag of objects. In order of increasing features, they are:\n• List - allows items to have an order (accessing and removing by index)\n\nEnumerable has no order. You cannot add or remove items from the set. You cannot even get a count of items in the set. It strictly lets you access each item in the set, one after the other.\n\nCollection is a modifiable set. You can add and remove objects from the set, you can also get the count of items in the set. But there still is no order, and because there is no order: no way to access an item by index, nor is there any way to sort.\n\nList is an ordered set of objects. You can sort the list, access items by index, remove items by index.\n\nIn fact, when looking at the interfaces for these, they build on one another:\n\nWhen declaring variables, or method parameters, you should choose to use\n\nbased on what conceptually you need to do with the set of objects.\n\nIf you just need to be able to do something to every object in a list, then you only need :\n\nYou don't care if the Users are kept in a , , or anything else. You only need the interface.\n\nIf you need to be able to add, remove, or count the items in a set, then use a Collection:\n\nIf you care about a sort order, and need the order to be correct, then use a List:\n\nThe and in are two classes that implement these interfaces; but they aren't the only classes:\n• is an ordered bag of objects ( )\n• is a bag where you are not allowed to access items by index ( ); but you can arbitrarily add and remove items from the collection\n• is an ordered collection, where you can add/remove items by index\n\nSo you can easily change:\n\nChoose the concept you need, then use the matching class."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_collections.html",
        "document": "The .NET base class library contains multiple collection types that can be used to store and manipulate data. Godot also provide some collection types that are tightly integrated with the rest of the engine.\n\nThe main difference between the .NET collections and the Godot collections is that the .NET collections are implemented in C# while the Godot collections are implemented in C++ and the Godot C# API is a wrapper over it, this is an important distinction since it means every operation on a Godot collection requires marshaling which can be expensive especially inside a loop.\n\nDue to the performance implications, using Godot collections is only recommended when absolutely necessary (such as interacting with the Godot API). Godot only understands its own collection types, so it's required to use them when talking to the engine.\n\nIf you have a collection of elements that don't need to be passed to a Godot API, using a .NET collection would be more performant.\n\nIt's also possible to convert between .NET collections and Godot collections. The Godot collections contain constructors from generic .NET collection interfaces that copy their elements, and the Godot collections can be used with the LINQ , and methods. But keep in mind this conversion requires marshaling every element in the collection and copies it to a new collection so it can be expensive.\n\nDespite this, the Godot collections are optimized to try and avoid unnecessary marshaling, so methods like or are implemented with a single interop call and don't need to marshal every element. Keep an eye out for generic APIs that take collection interfaces like LINQ because every method requires iterating the collection and, therefore, marshaling every element. Prefer using the instance methods of the Godot collections when possible.\n\nTo choose which collection type to use for each situation, consider the following questions:\n• None Does your collection need to interact with the Godot engine? (e.g.: the type of an exported property, calling a Godot method).\n• None If yes, since Godot only supports Variant-compatible types, use a Godot collection.\n• None If not, consider choosing an appropriate .NET collection.\n• None Do you need a Godot collection that represents a list or sequential set of data?\n• None Godot arrays are similar to the C# collection .\n• None Godot packed arrays are more memory-efficient arrays, in C# use one of the supported types.\n• None Do you need a Godot collection that maps a set of keys to a set of values?\n• None Godot dictionaries store pairs of keys and values and allow easy access to the values by their associated key."
    },
    {
        "link": "https://stackoverflow.com/questions/24123986/validating-datetime-input-from-console-in-c-sharp",
        "document": "In a bid to learn C# in a hands-on manner, I started working through these assignments I found online...\n\nI am stuck on Exercise 1, Question 3. How can I request a date from the console and then check against given criteria? In this case, check if the date is after today and provide an 'invalid' message if true.\n\nMy code currently looks like the below. I feel like the logic is there, but something to do with scope won't let it compile - the userBirthdate seems inaccessible outside of the loop.\n\nI'm sure there's also a much simpler solution.\n\nAny help greatly appreciated - thanks guys!"
    },
    {
        "link": "https://stackoverflow.com/questions/31343564/c-sharp-how-do-i-get-a-user-input-for-date-and-time",
        "document": "You have to get an input from a user and store that value in a variable.\n\nI am assuming is the line of code that queries the DB for a match.\n\nIn that case you would want to pass the datetime as a string. and then just pass userInput to the FindPIPoint method.\n\nBut if the .FindPiPoint method is looking for a datetime you would need to cast it to a datetime object first.\n\nSince this is working on the assumption that any possible datetime is a possible match(and I doubt this is the case) you should add some error handling for an incorrect match."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.datetime.parse?view=net-9.0",
        "document": "Numerous examples that call the method are interspersed throughout the Remarks section of this article and in the documentation for the individual overloads.\n\nYou can also download a complete set of examples, which are included in a .NET Core project for C#.\n• The return value and DateTime.Kind\n\nThe Parse method tries to convert the string representation of a date and time value to its DateTime equivalent. It tries to parse the input string completely without throwing a FormatException exception.\n\nThe string to be parsed can take any of the following forms:\n• None A string with a date but no time component. If the time component is absent, the method assumes 12:00 midnight. If the date component has a two-digit year, it is converted to a year based on the Calendar.TwoDigitYearMax of the current culture's current calendar or the specified culture's current calendar (if you use an overload with a non-null argument).\n• None A string with a date component that includes only the month and the year but no day component. The method assumes the first day of the month.\n• None A string with a date component that includes only the month and the day but no year component. The method assumes the current year.\n• None A string with a time but no date component. The method assumes the current date unless you call the Parse(String, IFormatProvider, DateTimeStyles) overload and include DateTimeStyles.NoCurrentDateDefault in the argument, in which case the method assumes a date of January 1, 0001.\n• None A string with a time component that includes only the hour and an AM/PM designator, with no date component. The method assumes the current date and a time with no minutes and no seconds. You can change this behavior by calling the Parse(String, IFormatProvider, DateTimeStyles) overload and include DateTimeStyles.NoCurrentDateDefault in the argument, in which case the method assumes a date of January 1, 0001.\n• None A string that includes time zone information and conforms to ISO 8601. In the following examples, the first string designates Coordinated Universal Time (UTC), and the second designates the time in a time zone that's seven hours earlier than UTC:\n• None A string that includes the GMT designator and conforms to the RFC 1123 time format; for example:\n• None A string that includes the date and time along with time zone offset information; for example:\n\nThe following example parses strings in each of these formats by using the formatting conventions of the current culture, which in this case is the en-US culture:\n\nIf the input string represents a leap day in a leap year in the calendar used by the parsing method (see Parsing and cultural conventions), the Parse method parses the string successfully. If the input string represents a leap day in a non-leap year, the method throws a FormatException.\n\nBecause the Parse method tries to parse the string representation of a date and time by using the formatting rules of the current or a specified culture, trying to parse a string across different cultures can fail. To parse a specific date and time format across different locales, use one of the overloads of the DateTime.ParseExact method and provide a format specifier.\n\nAll overloads of the Parse method are culture-sensitive unless the string to be parsed (which is represented by in the following table) conforms to the ISO 8601 pattern. The parsing operation uses the formatting information in a DateTimeFormatInfo object that is derived as follows:\n\nWhen formatting information is derived from a DateTimeFormatInfo object, the DateTimeFormatInfo.Calendar property defines the calendar used in the parsing operation.\n\nIf you parse a date and time string by using a DateTimeFormatInfo object with customized settings that are different from those of a standard culture, use the ParseExact method instead of the Parse method to improve the chances for a successful conversion. A non-standard date and time string can be complicated and difficult to parse. The Parse method tries to parse a string with several implicit parse patterns, all of which might fail. In contrast, the ParseExact method requires you to explicitly designate one or more exact parse patterns that are likely to succeed. For more information, see the \"DateTimeFormatInfo and Dynamic Data\" section in the DateTimeFormatInfo topic.\n\nAll Parse overloads ignore leading, inner, or trailing white-space characters in the input string (which is represented by in the following table). The date and time can be bracketed with a pair of leading and trailing NUMBER SIGN characters (\"#\", U+0023), and can be trailed with one or more NULL characters (U+0000).\n\nIn addition, the Parse(String, IFormatProvider, DateTimeStyles) overload has a parameter that consists of one or more members of the DateTimeStyles enumeration. This parameter defines how should be interpreted and how the parse operation should convert to a date and time. The following table describes the effect of each DateTimeStyles member on the parse operation.\n\nThe overloads return a DateTime value whose Kind property includes time zone information. It can indicate that the time is:\n• The time in the local time zone (System.DateTimeKind.Local).\n• The time in an unknown time zone (System.DateTimeKind.Unspecified).\n\nGenerally, the Parse method returns a DateTime object whose Kind property is DateTimeKind.Unspecified. However, the Parse method may also perform time zone conversion and set the value of the Kind property differently, depending on the values of the and parameters:\n\nThe following example converts date strings that contain time zone information to the time in the local time zone:\n\nYou can also preserve the value of a date and time's Kind property during a formatting and parsing operation by using the DateTimeStyles.RoundtripKind flag. The following example illustrates how the RoundtripKind flag affects the parsing operation on DateTime values that are converted to strings by using the \"o\", \"r\", or \"u\" format specifier.\n\nConverts the string representation of a date and time to its DateTime equivalent by using the conventions of the current culture. A string that contains a date and time to convert. See The string to parse for more information. An object that is equivalent to the date and time contained in . does not contain a valid string representation of a date and time. The following example parses the string representation of several date and time values by:\n• None Using the default format provider, which provides the formatting conventions of the current culture of the computer used to produce the example output. The output from this example reflects the formatting conventions of the en-US culture.\n• None Using the default style value, which is AllowWhiteSpaces. It handles the FormatException exception that is thrown when the method tries to parse the string representation of a date and time by using some other culture's formatting conventions. It also shows how to successfully parse a date and time value that does not use the formatting conventions of the current culture. using System; using System.Globalization; public class DateTimeParser { public static void Main() { // Assume the current culture is en-US. // The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. // Use standard en-US date and time value DateTime dateValue; string dateString = \"2/16/2008 12:15:12 PM\"; try { dateValue = DateTime.Parse(dateString); Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue); } catch (FormatException) { Console.WriteLine(\"Unable to convert '{0}'.\", dateString); } // Reverse month and day to conform to the fr-FR culture. // The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. dateString = \"16/02/2008 12:15:12\"; try { dateValue = DateTime.Parse(dateString); Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue); } catch (FormatException) { Console.WriteLine(\"Unable to convert '{0}'.\", dateString); } // Call another overload of Parse to successfully convert string // formatted according to conventions of fr-FR culture. try { dateValue = DateTime.Parse(dateString, new CultureInfo(\"fr-FR\", false)); Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue); } catch (FormatException) { Console.WriteLine(\"Unable to convert '{0}'.\", dateString); } // Parse string with date but no time component. dateString = \"2/16/2008\"; try { dateValue = DateTime.Parse(dateString); Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue); } catch (FormatException) { Console.WriteLine(\"Unable to convert '{0}'.\", dateString); } } } // The example displays the following output to the console: // '2/16/2008 12:15:12 PM' converted to 2/16/2008 12:15:12 PM. // Unable to convert '16/02/2008 12:15:12'. // '16/02/2008 12:15:12' converted to 2/16/2008 12:15:12 PM. // '2/16/2008' converted to 2/16/2008 12:00:00 AM. open System open System.Globalization [<EntryPoint>] let main _ = // Assume the current culture is en-US. // The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. // Use standard en-US date and time value let dateString = \"2/16/2008 12:15:12 PM\" try let dateValue = DateTime.Parse dateString printfn $\"'{dateString}' converted to {dateValue}.\" with :? FormatException -> printfn $\"Unable to convert '{dateString}'.\" // Reverse month and day to conform to the fr-FR culture. // The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. let dateString = \"16/02/2008 12:15:12\" try let dateValue = DateTime.Parse dateString printfn $\"'{dateString}' converted to {dateValue}.\" with :? FormatException -> Console.WriteLine(\"Unable to convert '{0}'.\", dateString) // Call another overload of Parse to successfully convert string // formatted according to conventions of fr-FR culture. try let dateValue = DateTime.Parse(dateString, CultureInfo(\"fr-FR\", false)) printfn $\"'{dateString}' converted to {dateValue}.\" with :? FormatException -> printfn $\"Unable to convert '{dateString}'.\" // Parse string with date but no time component. let dateString = \"2/16/2008\" try let dateValue = DateTime.Parse dateString printfn $\"'{dateString}' converted to {dateValue}.\" with :? FormatException -> printfn $\"Unable to convert '{dateString}'.\" 0 // The example displays the following output to the console: // '2/16/2008 12:15:12 PM' converted to 2/16/2008 12:15:12 PM. // Unable to convert '16/02/2008 12:15:12'. // '16/02/2008 12:15:12' converted to 2/16/2008 12:15:12 PM. // '2/16/2008' converted to 2/16/2008 12:00:00 AM. Imports System.Globalization Class DateTimeParser Public Shared Sub Main() ' Assume the current culture is en-US. ' The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. ' Use standard en-US date and time value Dim dateValue As Date Dim dateString As String = \"2/16/2008 12:15:12 PM\" Try dateValue = Date.Parse(dateString) Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue) Catch e As FormatException Console.WriteLine(\"Unable to convert '{0}'.\", dateString) End Try ' Reverse month and day to conform to the fr-FR culture. ' The date is February 16, 2008, 12 hours, 15 minutes and 12 seconds. dateString = \"16/02/2008 12:15:12\" Try dateValue = Date.Parse(dateString) Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue) Catch e As FormatException Console.WriteLine(\"Unable to convert '{0}'.\", dateString) End Try ' Call another overload of Parse to successfully convert string ' formatted according to conventions of fr-FR culture. Try dateValue = Date.Parse(dateString, New CultureInfo(\"fr-FR\", False)) Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue) Catch e As FormatException Console.WriteLine(\"Unable to convert '{0}'.\", dateString) End Try ' Parse string with date but no time component. dateString = \"2/16/2008\" Try dateValue = Date.Parse(dateString) Console.WriteLine(\"'{0}' converted to {1}.\", dateString, dateValue) Catch e As FormatException Console.WriteLine(\"Unable to convert '{0}'.\", dateString) End Try End Sub End Class ' The example displays the following output to the console: ' '2/16/2008 12:15:12 PM' converted to 2/16/2008 12:15:12 PM. ' Unable to convert '16/02/2008 12:15:12'. ' '16/02/2008 12:15:12' converted to 2/16/2008 12:15:12 PM. ' '2/16/2008' converted to 2/16/2008 12:00:00 AM. If contains time zone information, this method returns a DateTime value whose Kind property is DateTimeKind.Local and converts the date and time in to local time. Otherwise, it performs no time zone conversion and returns a DateTime value whose Kind property is DateTimeKind.Unspecified. This overload attempts to parse by using the formatting conventions of the current culture. The current culture is indicated by the CurrentCulture property. To parse a string using the formatting conventions of a specific culture, call the Parse(String, IFormatProvider) or the Parse(String, IFormatProvider, DateTimeStyles) overloads. This overload attempts to parse by using DateTimeStyles.AllowWhiteSpaces style.\n• Parsing Date and Time Strings in the .NET Framework\n\nConverts the string representation of a date and time to its DateTime equivalent by using culture-specific format information and a formatting style. Public Shared Function Parse (s As String, provider As IFormatProvider, styles As DateTimeStyles) As DateTime A string that contains a date and time to convert. See The string to parse for more information. An object that supplies culture-specific formatting information about . See Parsing and cultural conventions A bitwise combination of the enumeration values that indicates the style elements that can be present in for the parse operation to succeed, and that defines how to interpret the parsed date in relation to the current time zone or the current date. A typical value to specify is None. An object that is equivalent to the date and time contained in , as specified by and . does not contain a valid string representation of a date and time. contains an invalid combination of DateTimeStyles values. For example, both AssumeLocal and AssumeUniversal. The following example demonstrates the Parse(String, IFormatProvider, DateTimeStyles) method and displays the value of the Kind property of the resulting DateTime values. using System; using System.Globalization; public class ParseDateExample { public static void Main() { string dateString; CultureInfo culture ; DateTimeStyles styles; DateTime result; // Parse a date and time with no styles. dateString = \"03/01/2009 10:00 AM\"; culture = CultureInfo.CreateSpecificCulture(\"en-US\"); styles = DateTimeStyles.None; try { result = DateTime.Parse(dateString, culture, styles); Console.WriteLine(\"{0} converted to {1} {2}.\", dateString, result, result.Kind.ToString()); } catch (FormatException) { Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString); } // Parse the same date and time with the AssumeLocal style. styles = DateTimeStyles.AssumeLocal; try { result = DateTime.Parse(dateString, culture, styles); Console.WriteLine(\"{0} converted to {1} {2}.\", dateString, result, result.Kind.ToString()); } catch (FormatException) { Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString); } // Parse a date and time that is assumed to be local. // This time is five hours behind UTC. The local system's time zone is // eight hours behind UTC. dateString = \"2009/03/01T10:00:00-5:00\"; styles = DateTimeStyles.AssumeLocal; try { result = DateTime.Parse(dateString, culture, styles); Console.WriteLine(\"{0} converted to {1} {2}.\", dateString, result, result.Kind.ToString()); } catch (FormatException) { Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString); } // Attempt to convert a string in improper ISO 8601 format. dateString = \"03/01/2009T10:00:00-5:00\"; try { result = DateTime.Parse(dateString, culture, styles); Console.WriteLine(\"{0} converted to {1} {2}.\", dateString, result, result.Kind.ToString()); } catch (FormatException) { Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString); } // Assume a date and time string formatted for the fr-FR culture is the local // time and convert it to UTC. dateString = \"2008-03-01 10:00\"; culture = CultureInfo.CreateSpecificCulture(\"fr-FR\"); styles = DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeLocal; try { result = DateTime.Parse(dateString, culture, styles); Console.WriteLine(\"{0} converted to {1} {2}.\", dateString, result, result.Kind.ToString()); } catch (FormatException) { Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString); } } } // The example displays the following output to the console: // 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Unspecified. // 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Local. // 2009/03/01T10:00:00-5:00 converted to 3/1/2009 7:00:00 AM Local. // Unable to convert 03/01/2009T10:00:00-5:00 to a date and time. // 2008-03-01 10:00 converted to 3/1/2008 6:00:00 PM Utc. open System open System.Globalization [<EntryPoint>] let main _ = // Parse a date and time with no styles. let dateString = \"03/01/2009 10:00 AM\" let culture = CultureInfo.CreateSpecificCulture \"en-US\" let styles = DateTimeStyles.None try let result = DateTime.Parse(dateString, culture, styles) printfn $\"{dateString} converted to {result} {result.Kind}.\" with :? FormatException -> printfn $\"Unable to convert {dateString} to a date and time.\" // Parse the same date and time with the AssumeLocal style. let styles = DateTimeStyles.AssumeLocal try let result = DateTime.Parse(dateString, culture, styles) printfn $\"{dateString} converted to {result} {result.Kind}.\" with :? FormatException -> printfn $\"Unable to convert {dateString} to a date and time.\" // Parse a date and time that is assumed to be local. // This time is five hours behind UTC. The local system's time zone is // eight hours behind UTC. let dateString = \"2009/03/01T10:00:00-5:00\" let styles = DateTimeStyles.AssumeLocal try let result = DateTime.Parse(dateString, culture, styles) printfn $\"{dateString} converted to {result} {result.Kind}.\" with :? FormatException -> printfn $\"Unable to convert {dateString} to a date and time.\" // Attempt to convert a string in improper ISO 8601 format. let dateString = \"03/01/2009T10:00:00-5:00\" try let result = DateTime.Parse(dateString, culture, styles) printfn $\"{dateString} converted to {result} {result.Kind}.\" with :? FormatException -> printfn $\"Unable to convert {dateString} to a date and time.\" // Assume a date and time string formatted for the fr-FR culture is the local // time and convert it to UTC. let dateString = \"2008-03-01 10:00\" let culture = CultureInfo.CreateSpecificCulture \"fr-FR\" let styles = DateTimeStyles.AdjustToUniversal ||| DateTimeStyles.AssumeLocal try let result = DateTime.Parse(dateString, culture, styles) printfn $\"{dateString} converted to {result} {result.Kind}.\" with :? FormatException -> printfn $\"Unable to convert {dateString} to a date and time.\" 0 // The example displays the following output to the console: // 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Unspecified. // 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Local. // 2009/03/01T10:00:00-5:00 converted to 3/1/2009 7:00:00 AM Local. // Unable to convert 03/01/2009T10:00:00-5:00 to a date and time. // 2008-03-01 10:00 converted to 3/1/2008 6:00:00 PM Utc. Imports System.Globalization Module ParseDateExample Public Sub Main() Dim dateString As String Dim culture As CultureInfo Dim styles As DateTimeStyles Dim result As DateTime ' Parse a date and time with no styles. dateString = \"03/01/2009 10:00 AM\" culture = CultureInfo.CreateSpecificCulture(\"en-US\") styles = DateTimeStyles.None Try result = DateTime.Parse(dateString, culture, styles) Console.WriteLine(\"{0} converted to {1} {2}.\", _ dateString, result, result.Kind.ToString()) Catch e As FormatException Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString) End Try ' Parse the same date and time with the AssumeLocal style. styles = DateTimeStyles.AssumeLocal Try result = DateTime.Parse(dateString, culture, styles) Console.WriteLine(\"{0} converted to {1} {2}.\", _ dateString, result, result.Kind.ToString()) Catch e As FormatException Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString) End Try ' Parse a date and time that is assumed to be local. ' This time is five hours behind UTC. The local system's time zone is ' eight hours behind UTC. dateString = \"2009/03/01T10:00:00-5:00\" styles = DateTimeStyles.AssumeLocal Try result = DateTime.Parse(dateString, culture, styles) Console.WriteLine(\"{0} converted to {1} {2}.\", _ dateString, result, result.Kind.ToString()) Catch e As FormatException Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString) End Try ' Attempt to convert a string in improper ISO 8601 format. dateString = \"03/01/2009T10:00:00-5:00\" Try result = DateTime.Parse(dateString, culture, styles) Console.WriteLine(\"{0} converted to {1} {2}.\", _ dateString, result, result.Kind.ToString()) Catch e As FormatException Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString) End Try ' Assume a date and time string formatted for the fr-FR culture is the local ' time and convert it to UTC. dateString = \"2008-03-01 10:00\" culture = CultureInfo.CreateSpecificCulture(\"fr-FR\") styles = DateTimeStyles.AdjustToUniversal Or DateTimeStyles.AssumeLocal Try result = DateTime.Parse(dateString, culture, styles) Console.WriteLine(\"{0} converted to {1} {2}.\", _ dateString, result, result.Kind.ToString()) Catch e As FormatException Console.WriteLine(\"Unable to convert {0} to a date and time.\", dateString) End Try End Sub End Module ' ' The example displays the following output to the console: ' 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Unspecified. ' 03/01/2009 10:00 AM converted to 3/1/2009 10:00:00 AM Local. ' 2009/03/01T10:00:00-5:00 converted to 3/1/2009 7:00:00 AM Local. ' Unable to convert 03/01/2009T10:00:00-5:00 to a date and time. ' 2008-03-01 10:00 converted to 3/1/2008 6:00:00 PM Utc. This method overload converts the date and time in and sets the Kind property of the returned DateTime value as follows: To the time in the local time zone contains time zone information, and includes the DateTimeStyles.AdjustToUniversal flag. contains the Z or GMT time zone designator, and includes the DateTimeStyles.RoundtripKind.\n• Parsing Date and Time Strings in the .NET Framework\n• How to: Round-trip Date and Time Values"
    },
    {
        "link": "https://w3resource.com/csharp-exercises/exception-handling/csharp-exception-handling-exercise-9.php",
        "document": "C# Program: Convert user input to datetime with exception handling\n\nWrite a C# program that creates a method that reads a date from the user in the format \"dd/mm/yyyy\" and converts it to a DateTime object. Handle an exception if the input format is invalid.\n\nIn the above exercise -\n• The \"Main()\" method prompts the user to enter a date in the format \"dd/mm/yyyy\" using Console.Write() and Console.ReadLine(). The input is stored in the input variable.\n• The program calls the ConvertToDate method, passing the input string as an argument.\n• The ConvertToDate method uses DateTime.ParseExact to convert the string to a DateTime object, specifying the desired format \"dd/MM/yyyy\". If the input string cannot be parsed according to the specified format, a FormatException is thrown.\n• In the \"Main()\" method, exceptions are handled using catch blocks. If a FormatException occurs, it means the input date format was invalid. The program catches this exception and displays an appropriate error message.\n• Any other exceptions are caught by the generic catch block, and a general error message is displayed.\n• The program displays the converted DateTime object using ToShortDateString() to format it as a short date string.\n\nImprove this sample solution and post your code through Disqus\n\nPrevious: Divide two numbers with exception handling.\n\n Next: Calculate square root with exception handling."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-datetime",
        "document": "This article provides supplementary remarks to the reference documentation for this API.\n\nThe DateTime value type represents dates and times with values ranging from 00:00:00 (midnight), January 1, 0001 Anno Domini (Common Era) through 11:59:59 P.M., December 31, 9999 A.D. (C.E.) in the Gregorian calendar.\n\nTime values are measured in 100-nanosecond units called ticks. A particular date is the number of ticks since 12:00 midnight, January 1, 0001 A.D. (C.E.) in the GregorianCalendar calendar. The number excludes ticks that would be added by leap seconds. For example, a ticks value of 31241376000000000L represents the date Friday, January 01, 0100 12:00:00 midnight. A DateTime value is always expressed in the context of an explicit or default calendar.\n\nYou can view the source for the entire set of examples from this article in either Visual Basic, F#, or C#.\n\nThis article includes several examples that use the type:\n• Specify both a format string and a specific culture\n• Format a date time using the ISO 8601 standard for web services\n• Use or to convert a string to a date and time\n• Use or to convert a string in a known format\n• Convert from the ISO 8601 string representation to a date and time\n• Explore the resolution of date and time values\n• Retrieving the week of the year using culture specific calendars\n• Persisting date and time values as strings in the local time zone\n• Persisting date and time values as strings in a culture and time invariant format\n• Persisting date and time values using the\n\nYou can assign an initial value to a new value in many different ways:\n• Calling a constructor, either one where you specify arguments for values, or use the implicit parameterless constructor.\n• Assigning a to the return value of a property or method.\n• Parsing a value from its string representation.\n\nThe following code snippets show examples of each.\n\nYou call any of the overloads of the DateTime constructor that specify elements of the date and time value (such as the year, month, and day, or the number of ticks). The following code creates a specific date using the DateTime constructor specifying the year, month, day, hour, minute, and second.\n\nYou invoke the structure's implicit parameterless constructor when you want a initialized to its default value. (For details on the implicit parameterless constructor of a value type, see Value Types.) Some compilers also support declaring a DateTime value without explicitly assigning a value to it. Creating a value without an explicit initialization also results in the default value. The following example illustrates the DateTime implicit parameterless constructor in C# and Visual Basic, as well as a DateTime declaration without assignment in Visual Basic.\n\nYou can assign the DateTime object a date and time value returned by a property or method. The following example assigns the current date and time, the current Coordinated Universal Time (UTC) date and time, and the current date to three new DateTime variables.\n\nThe Parse, ParseExact, TryParse, and TryParseExact methods all convert a string to its equivalent date and time value. The following examples use the Parse and ParseExact methods to parse a string and convert it to a DateTime value. The second format uses a form supported by the ISO 8601 standard for a representing date and time in string format. This standard representation is often used to transfer date information in web services.\n\nThe TryParse and TryParseExact methods indicate whether a string is a valid representation of a DateTime value and, if it is, performs the conversion.\n\nThe following Visual Basic statement initializes a new DateTime value.\n\nInternally, all DateTime values are represented as the number of ticks (the number of 100-nanosecond intervals) that have elapsed since 12:00:00 midnight, January 1, 0001. The actual DateTime value is independent of the way in which that value appears when displayed. The appearance of a DateTime value is the result of a formatting operation that converts a value to its string representation.\n\nThe appearance of date and time values is dependent on culture, international standards, application requirements, and personal preference. The DateTime structure offers flexibility in formatting date and time values through overloads of ToString. The default DateTime.ToString() method returns the string representation of a date and time value using the current culture's short date and long time pattern. The following example uses the default DateTime.ToString() method. It displays the date and time using the short date and long time pattern for the current culture. The en-US culture is the current culture on the computer on which the example was run.\n\nYou may need to format dates in a specific culture to support web scenarios where the server may be in a different culture from the client. You specify the culture using the DateTime.ToString(IFormatProvider) method to create the short date and long time representation in a specific culture. The following example uses the DateTime.ToString(IFormatProvider) method to display the date and time using the short date and long time pattern for the fr-FR culture.\n\nOther applications may require different string representations of a date. The DateTime.ToString(String) method returns the string representation defined by a standard or custom format specifier using the formatting conventions of the current culture. The following example uses the DateTime.ToString(String) method to display the full date and time pattern for the en-US culture, the current culture on the computer on which the example was run.\n\nFinally, you can specify both the culture and the format using the DateTime.ToString(String, IFormatProvider) method. The following example uses the DateTime.ToString(String, IFormatProvider) method to display the full date and time pattern for the fr-FR culture.\n\nThe DateTime.ToString(String) overload can also be used with a custom format string to specify other formats. The following example shows how to format a string using the ISO 8601 standard format often used for web services. The Iso 8601 format does not have a corresponding standard format string.\n\nFor more information about formatting DateTime values, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n\nParsing converts the string representation of a date and time to a DateTime value. Typically, date and time strings have two different usages in applications:\n• None A date and time takes a variety of forms and reflects the conventions of either the current culture or a specific culture. For example, an application allows a user whose current culture is en-US to input a date value as \"12/15/2013\" or \"December 15, 2013\". It allows a user whose current culture is en-gb to input a date value as \"15/12/2013\" or \"15 December 2013.\"\n• None A date and time is represented in a predefined format. For example, an application serializes a date as \"20130103\" independently of the culture on which the app is running. An application may require dates be input in the current culture's short date format.\n\nYou use the Parse or TryParse method to convert a string from one of the common date and time formats used by a culture to a DateTime value. The following example shows how you can use TryParse to convert date strings in different culture-specific formats to a DateTime value. It changes the current culture to English (United Kingdom) and calls the GetDateTimeFormats() method to generate an array of date and time strings. It then passes each element in the array to the TryParse method. The output from the example shows the parsing method was able to successfully convert each of the culture-specific date and time strings.\n\nYou use the ParseExact and TryParseExact methods to convert a string that must match a particular format or formats to a DateTime value. You specify one or more date and time format strings as a parameter to the parsing method. The following example uses the TryParseExact(String, String[], IFormatProvider, DateTimeStyles, DateTime) method to convert strings that must be either in a \"yyyyMMdd\" format or a \"HHmmss\" format to DateTime values.\n\nOne common use for ParseExact is to convert a string representation from a web service, usually in ISO 8601 standard format. The following code shows the correct format string to use:\n\nIf a string cannot be parsed, the Parse and ParseExact methods throw an exception. The TryParse and TryParseExact methods return a Boolean value that indicates whether the conversion succeeded or failed. You should use the TryParse or TryParseExact methods in scenarios where performance is important. The parsing operation for date and time strings tends to have a high failure rate, and exception handling is expensive. Use these methods if strings are input by users or coming from an unknown source.\n\nFor more information about parsing date and time values, see Parsing Date and Time Strings.\n\nDescriptions of time values in the DateTime type are often expressed using the Coordinated Universal Time (UTC) standard. Coordinated Universal Time is the internationally recognized name for Greenwich Mean Time (GMT). Coordinated Universal Time is the time as measured at zero degrees longitude, the UTC origin point. Daylight saving time is not applicable to UTC.\n\nLocal time is relative to a particular time zone. A time zone is associated with a time zone offset. A time zone offset is the displacement of the time zone measured in hours from the UTC origin point. In addition, local time is optionally affected by daylight saving time, which adds or subtracts a time interval adjustment. Local time is calculated by adding the time zone offset to UTC and adjusting for daylight saving time if necessary. The time zone offset at the UTC origin point is zero.\n\nUTC time is suitable for calculations, comparisons, and storing dates and time in files. Local time is appropriate for display in user interfaces of desktop applications. Time zone-aware applications (such as many Web applications) also need to work with a number of other time zones.\n\nIf the Kind property of a DateTime object is DateTimeKind.Unspecified, it is unspecified whether the time represented is local time, UTC time, or a time in some other time zone.\n\nThe Ticks property expresses date and time values in units of one ten-millionth of a second. The Millisecond property returns the thousandths of a second in a date and time value. Using repeated calls to the DateTime.Now property to measure elapsed time is dependent on the system clock. The system clock on Windows 7 and Windows 8 systems has a resolution of approximately 15 milliseconds. This resolution affects small time intervals less than 100 milliseconds.\n\nThe following example illustrates the dependence of current date and time values on the resolution of the system clock. In the example, an outer loop repeats 20 times, and an inner loop serves to delay the outer loop. If the value of the outer loop counter is 10, a call to the Thread.Sleep method introduces a five-millisecond delay. The following example shows the number of milliseconds returned by the property changes only after the call to Thread.Sleep.\n\nA calculation using a DateTime structure, such as Add or Subtract, does not modify the value of the structure. Instead, the calculation returns a new DateTime structure whose value is the result of the calculation.\n\nConversion operations between time zones (such as between UTC and local time, or between one time zone and another) take daylight saving time into account, but arithmetic and comparison operations do not.\n\nThe DateTime structure itself offers limited support for converting from one time zone to another. You can use the ToLocalTime method to convert UTC to local time, or you can use the ToUniversalTime method to convert from local time to UTC. However, a full set of time zone conversion methods is available in the TimeZoneInfo class. You convert the time in any one of the world's time zones to the time in any other time zone using these methods.\n\nCalculations and comparisons of DateTime objects are meaningful only if the objects represent times in the same time zone. You can use a TimeZoneInfo object to represent a DateTime value's time zone, although the two are loosely coupled. A DateTime object does not have a property that returns an object that represents that date and time value's time zone. The Kind property indicates if a represents UTC, local time, or is unspecified. In a time zone-aware application, you must rely on some external mechanism to determine the time zone in which a DateTime object was created. You could use a structure that wraps both the DateTime value and the TimeZoneInfo object that represents the DateTime value's time zone. For details on using UTC in calculations and comparisons with DateTime values, see Performing Arithmetic Operations with Dates and Times.\n\nEach DateTime member implicitly uses the Gregorian calendar to perform its operation. Exceptions are methods that implicitly specify a calendar. These include constructors that specify a calendar, and methods with a parameter derived from IFormatProvider, such as System.Globalization.DateTimeFormatInfo.\n\nOperations by members of the DateTime type take into account details such as leap years and the number of days in a month.\n\nThe .NET Class Library includes a number of calendar classes, all of which are derived from the Calendar class. They are:\n\nEach culture uses a default calendar defined by its read-only CultureInfo.Calendar property. Each culture may support one or more calendars defined by its read-only CultureInfo.OptionalCalendars property. The calendar currently used by a specific CultureInfo object is defined by its DateTimeFormatInfo.Calendar property. It must be one of the calendars found in the CultureInfo.OptionalCalendars array.\n\nA culture's current calendar is used in all formatting operations for that culture. For example, the default calendar of the Thai Buddhist culture is the Thai Buddhist Era calendar, which is represented by the ThaiBuddhistCalendar class. When a CultureInfo object that represents the Thai Buddhist culture is used in a date and time formatting operation, the Thai Buddhist Era calendar is used by default. The Gregorian calendar is used only if the culture's DateTimeFormatInfo.Calendar property is changed, as the following example shows:\n\nA culture's current calendar is also used in all parsing operations for that culture, as the following example shows.\n\nYou instantiate a DateTime value using the date and time elements (number of the year, month, and day) of a specific calendar by calling a DateTime constructor that includes a parameter and passing it a Calendar object that represents that calendar. The following example uses the date and time elements from the ThaiBuddhistCalendar calendar.\n\nDateTime constructors that do not include a parameter assume that the date and time elements are expressed as units in the Gregorian calendar.\n\nAll other DateTime properties and methods use the Gregorian calendar. For example, the DateTime.Year property returns the year in the Gregorian calendar, and the DateTime.IsLeapYear(Int32) method assumes that the parameter is a year in the Gregorian calendar. Each DateTime member that uses the Gregorian calendar has a corresponding member of the Calendar class that uses a specific calendar. For example, the Calendar.GetYear method returns the year in a specific calendar, and the Calendar.IsLeapYear method interprets the parameter as a year number in a specific calendar. The following example uses both the DateTime and the corresponding members of the ThaiBuddhistCalendar class.\n\nThe DateTime structure includes a DayOfWeek property that returns the day of the week in the Gregorian calendar. It does not include a member that allows you to retrieve the week number of the year. To retrieve the week of the year, call the individual calendar's Calendar.GetWeekOfYear method. The following example provides an illustration.\n\nFor more information on dates and calendars, see Working with Calendars.\n\nYou can persist DateTime values in the following ways:\n• Convert them to strings and persist the strings.\n• Convert them to 64-bit integer values (the value of the Ticks property) and persist the integers.\n\nYou must ensure that the routine that restores the DateTime values doesn't lose data or throw an exception regardless of which technique you choose. DateTime values should round-trip. That is, the original value and the restored value should be the same. And if the original DateTime value represents a single instant of time, it should identify the same moment of time when it's restored.\n\nTo successfully restore DateTime values that are persisted as strings, follow these rules:\n• None Make the same assumptions about culture-specific formatting when you restore the string as when you persisted it. To ensure that a string can be restored on a system whose current culture is different from the culture of the system it was saved on, call the ToString overload to save the string by using the conventions of the invariant culture. Call the Parse(String, IFormatProvider, DateTimeStyles) or TryParse(String, IFormatProvider, DateTimeStyles, DateTime) overload to restore the string by using the conventions of the invariant culture. Never use the ToString(), Parse(String), or TryParse(String, DateTime) overloads, which use the conventions of the current culture.\n• None If the date represents a single moment of time, ensure that it represents the same moment in time when it's restored, even on a different time zone. Convert the DateTime value to Coordinated Universal Time (UTC) before saving it or use DateTimeOffset.\n\nThe most common error made when persisting DateTime values as strings is to rely on the formatting conventions of the default or current culture. Problems arise if the current culture is different when saving and restoring the strings. The following example illustrates these problems. It saves five dates using the formatting conventions of the current culture, which in this case is English (United States). It restores the dates using the formatting conventions of a different culture, which in this case is English (United Kingdom). Because the formatting conventions of the two cultures are different, two of the dates can't be restored, and the remaining three dates are interpreted incorrectly. Also, if the original date and time values represent single moments in time, the restored times are incorrect because time zone information is lost.\n• If the values represent single moments of time, convert them from the local time to UTC by calling the ToUniversalTime method.\n• Convert the dates to their string representations by calling the ToString(String, IFormatProvider) or String.Format(IFormatProvider, String, Object[]) overload. Use the formatting conventions of the invariant culture by specifying CultureInfo.InvariantCulture as the argument. Specify that the value should round-trip by using the \"O\" or \"R\" standard format string.\n\nTo restore the persisted DateTime values without data loss, follow these steps:\n• Parse the data by calling the ParseExact or TryParseExact overload. Specify CultureInfo.InvariantCulture as the argument, and use the same standard format string you used for the argument during conversion. Include the DateTimeStyles.RoundtripKind value in the argument.\n• If the DateTime values represent single moments in time, call the ToLocalTime method to convert the parsed date from UTC to local time.\n\nThe following example uses the invariant culture and the \"O\" standard format string to ensure that DateTime values saved and restored represent the same moment in time regardless of the system, culture, or time zone of the source and target systems.\n\nYou can persist a date and time as an Int64 value that represents a number of ticks. In this case, you don't have to consider the culture of the systems the DateTime values are persisted and restored on.\n\nTo persist a DateTime value as an integer:\n• If the DateTime values represent single moments in time, convert them to UTC by calling the ToUniversalTime method.\n• Retrieve the number of ticks represented by the DateTime value from its Ticks property.\n\nTo restore a DateTime value that has been persisted as an integer:\n• Instantiate a new DateTime object by passing the Int64 value to the DateTime(Int64) constructor.\n• If the DateTime value represents a single moment in time, convert it from UTC to the local time by calling the ToLocalTime method.\n\nThe following example persists an array of DateTime values as integers on a system in the U.S. Pacific Time zone. It restores it on a system in the UTC zone. The file that contains the integers includes an Int32 value that indicates the total number of Int64 values that immediately follow it.\n\nYou can persist DateTime values through serialization to a stream or file, and then restore them through deserialization. DateTime data is serialized in some specified object format. The objects are restored when they are deserialized. A formatter or serializer, such as JsonSerializer or XmlSerializer, handles the process of serialization and deserialization. For more information about serialization and the types of serialization supported by .NET, see Serialization.\n\nThe following example uses the XmlSerializer class to serialize and deserialize DateTime values. The values represent all leap year days in the twenty-first century. The output represents the result if the example is run on a system whose current culture is English (United Kingdom). Because you've deserialized the DateTime object itself, the code doesn't have to handle cultural differences in date and time formats.\n\nThe previous example doesn't include time information. If a DateTime value represents a moment in time and is expressed as a local time, convert it from local time to UTC before serializing it by calling the ToUniversalTime method. After you deserialize it, convert it from UTC to local time by calling the ToLocalTime method.\n\nThe DateTime and TimeSpan value types differ in that a DateTime represents an instant in time whereas a TimeSpan represents a time interval. You can subtract one instance of DateTime from another to obtain a TimeSpan object that represents the time interval between them. Or you could add a positive TimeSpan to the current DateTime to obtain a DateTime value that represents a future date.\n\nYou can add or subtract a time interval from a DateTime object. Time intervals can be negative or positive, and they can be expressed in units such as ticks, seconds, or as a TimeSpan object.\n\nEquality comparisons for DateTime values are exact. To be considered equal, two values must be expressed as the same number of ticks. That precision is often unnecessary or even incorrect for many applications. Often, you want to test if DateTime objects are roughly equal.\n\nThe following example demonstrates how to compare roughly equivalent DateTime values. It accepts a small margin of difference when declaring them equal.\n\nA DateTime value that is transferred to a COM application, then is transferred back to a managed application, is said to round-trip. However, a DateTime value that specifies only a time does not round-trip as you might expect.\n\nIf you round-trip only a time, such as 3 P.M., the final date and time is December 30, 1899 C.E. at 3:00 P.M., instead of January, 1, 0001 C.E. at 3:00 P.M. .NET and COM assume a default date when only a time is specified. However, the COM system assumes a base date of December 30, 1899 C.E., while .NET assumes a base date of January, 1, 0001 C.E.\n\nWhen only a time is passed from .NET to COM, special processing is performed that converts the time to the format used by COM. When only a time is passed from COM to .NET, no special processing is performed because that would corrupt legitimate dates and times on or before December 30, 1899. If a date starts its round-trip from COM, .NET and COM preserve the date.\n\nThe behavior of .NET and COM means that if your application round-trips a DateTime that only specifies a time, your application must remember to modify or ignore the erroneous date from the final DateTime object."
    }
]