[
    {
        "link": "https://geeksforgeeks.org/named-pipe-fifo-example-c-program",
        "document": "Named Pipe or FIFO with example C program\n\nIn computing, a named pipe, also known as a FIFO (First In, First Out), is a powerful mechanism for inter-process communication (IPC). Unlike unnamed pipes, which are temporary and exist only as long as the process that created them is running, named pipes provide a persistent communication channel between processes, surviving beyond the life of the process that created them. This makes named pipes an essential tool for developers who need processes to exchange data reliably and efficiently.\n\nA named pipe is an extension of the traditional pipe concept in Unix. While a traditional pipe is “unnamed” and exists only temporarily, a named pipe can persist as long as the system is up or until it is explicitly deleted. Named pipes appear as special files in the filesystem, and multiple processes can attach to them for reading and writing, facilitating inter-process communication.\n\nA FIFO file allows two or more processes to communicate by reading from and writing to the same file. This file type is created using the ‘mkfifo()’ system call in C. Once created, any process can open the named pipe for reading or writing, similar to how it would handle an ordinary file. However, it is important to note that a named pipe must be opened simultaneously at both ends (for reading and writing) before any input or output operations can occur.\n\nHow to Create a Named Pipe (FIFO) in Unix\n\nTo create a FIFO special file, you use the ‘mkfifo()’ function in C. The function creates a named pipe with the specified pathname and permissions.\n\n\n\n‘mkfifo()’ makes a FIFO special file with name pathname. Here ‘mode’ specifies the FIFO’s permissions. It is modified by the process’s umask in the usual way: the permissions of the created file are (mode & ~umask).\n\nUsing FIFO: As named pipe(FIFO) is a kind of file, we can use all the system calls associated with it i.e. open, read, write, close.\n\nExample Programs to illustrate the named pipe: There are two programs that use the same FIFO. Program 1 writes first, then reads. The program 2 reads first, then writes. They both keep doing it until terminated.\n\n\n\nOutput: Run the two programs simultaneously on two terminals.\n\n\n\nThe Named pipes (FIFOs) are a robust method for the inter-process communication allowing data to be passed between the processes using a named file. This mechanism is useful in the scenarios where processes need to exchange data without direct knowledge of the each other. The example demonstrates a simple producer-consumer model where one process writes data to a FIFO and another reads it showcasing the basic usage of the named pipes in C.\n\nNamed Pipe or FIFO with Example C Program – FAQs\n\nWhat is the primary difference between a named pipe and an unnamed pipe?\n\nHow do I handle errors when working with FIFOs?\n\nCan multiple processes write to or read from the same FIFO?"
    },
    {
        "link": "https://stackoverflow.com/questions/4113986/example-of-using-named-pipes-in-linux-shell-bash",
        "document": "Can someone post a simple example of using named pipes in Bash on Linux?\n\nOne of the best examples of a practical use of a named pipe... Another useful behavior is using as a proxy. Both ports and hosts can be redirected. Look at this example: This starts a server on port 12345 and all the connections get redirected to . If a web browser makes a request to , the request will be sent to google but the response will not be sent to the web browser. That is because pipes are unidirectional. This can be worked around with a named pipe to redirect the input and output.\n\nThe first command creates the pipe. The second command writes to the pipe (blocking). The puts this into the background so you can continue to type commands in the same shell. It will exit when the FIFO is emptied by the next command. The last command reads from the pipe.\n\nOpen two different shells, and leave them side by side. In both, go to the directory: while read line; do echo \"What has been passed through the pipe is ${line}\"; done<myPipe First shell won't give you any prompt back until you execute the second part of the code in the second shell. It's because the fifo read and write is blocking. You can also have a look at the FIFO type by doing a and see the details of this specific type of file. Next step would be to embark the code in a script!\n\nOn Unix-likes named pipe (FIFO) is a special type of file with no content. The command creates the pipe on a file system (assigns a name to it), but doesn't open it. You need to open and close it separately like any other file. Named pipes are useful when you need to pipe from/to multiple processes or if you can't connect two processes with an anonymous pipe. They can be used in multiple ways:\n• None In parallel with another process: $ echo 'Hello pipe!' > pipe_name & # runs writer in a background $ cat pipe_name Hello pipe! Here writer runs along the reader allowing real-time communication between processes.\n• $ # open the pipe on auxiliary FD #5 in both ways (otherwise it will block), $ # then open descriptors for writing and reading and close the auxiliary FD $ exec 5<>pipe_name 3>pipe_name 4<pipe_name 5>&- $ $ echo 'Hello pipe!' >&3 # write into the pipe through FD #3 ... $ exec 3>&- # close the FD when you're done $ # (otherwise reading will block) $ cat <&4 Hello pipe! ... $ exec 4<&- In fact, communication through a pipe can be sequential, but it's limited to 64 KB (buffer size).\n\n It's preferable to use descriptors to transfer multiple blocks of data in order to reduce overhead.\n• $ handler() { > cat <&3 > > exec 3<&- > trap - USR1 # unregister signal handler (see below) > unset -f handler writer # undefine the functions > } $ $ exec 4<>pipe_name 3<pipe_name 4>&- $ trap handler USR1 # register handler for signal USR1 $ $ writer() { > if <condition>; then > kill -USR1 $PPID # send the signal USR1 to a specified process > echo 'Hello pipe!' > pipe_name > fi > } $ export -f writer # pass the function to child shells $ $ bash -c writer & # can actually be run sequentially as well $ Hello pipe! FD allows data transfer to start before the shell is ready to receive it. Required when used sequentially.\n\n The signal should be sent before data to prevent a deadlock if pipe buffer will fill up. The pipe itself (and its content) gets destroyed when all descriptors to it are closed. What's left is just a name.\n\n To make the pipe anonymous and unavailable under the given name (can be done when the pipe is still open) you could use the con­sole com­mand (it's the opposite of command):\n\nI want to say that you can create background process for pipe operation instead of main cmd. It will help you a lot with custom log processing. Let we have the following multiline command. We need to grep something from on the fly. It is hard to replace multine command with (manually or using tools like sed), so you can replace it with instead:\n\nslow_writer() { for i in $(seq 1 10); do echo $i sleep 1 done } But you want don't want to wait for it to finish and process the output in parallel with a fast process: fast_reader() { while IFS=\"\" read i; do echo $i done < /dev/stdin } Using a file for this does not work, as the does not wait for the to finish: But using a named pipe works as desired: Of course a normal pipe would do, but one can easily think of more complex examples where a named pipe is actually beneficial."
    },
    {
        "link": "https://hopeness.medium.com/master-the-linux-mkfifo-command-a-comprehensive-guide-7e64ac926228",
        "document": "This guide offers a comprehensive look into the ‘mkfifo’ command in Linux, aiming to provide beginners with an understanding of its purpose, usage, and applications. It also covers various parameters, common use cases, and special techniques, as well as highlighting precautions to take while using this command.\n\nThis guide aims to provide a detailed exploration of the Linux ‘mkfifo’ command for beginners. It will cover the command’s history, its applications, usage, parameters, common use cases, unusual techniques, and precautionary measures.\n\nThe ‘mkfifo’ command was introduced in Unix-like operating systems, including Linux, to manage Inter-Process Communication (IPC) using named pipes (FIFO).\n\nWhen and why to use it\n\n‘mkfifo’ is primarily used when two processes need to communicate with each other but do not have a parent-child relationship. A FIFO special file is an extension of pipes, which offers a pathway for data between two processes. The FIFO special file can be opened by multiple processes for reading and writing. It is especially useful in scenarios where data streaming is necessary.\n\nHow to use it\n\nThe ‘mkfifo’ command is straightforward to use. The simplest form of the command includes ‘mkfifo’ followed by the name of the FIFO file.\n\nThe ‘mkfifo’ command has a few useful parameters:\n• or sets the file permission mode of the created FIFO file. It follows the same pattern as the chmod command.\n• , Set the SELinux security context of each created directory to CTX\n• display this help and exit\n\nOne common use case of ‘mkfifo’ is to facilitate inter-process communication. For example, one process can write to the FIFO file while another process reads from it.\n\nOne tricky usage of ‘mkfifo’ is to use it for logging purposes. For instance, you can have a dedicated logging process that reads from a FIFO file and writes to a log file.\n\nWhat needs to be noted\n\nIt’s important to remember that FIFO files, like any other files, take up file system nodes (inodes). So, cleaning up unused FIFO files is essential to avoid running out of inodes.\n\nThe ‘mkfifo’ command is a powerful tool in Linux for creating named pipes, thus allowing processes to communicate more flexibly. Understanding and utilizing this command effectively can greatly aid in managing and controlling data flow between processes in Linux."
    },
    {
        "link": "https://opensource.com/article/19/4/interprocess-communication-linux-channels",
        "document": ""
    },
    {
        "link": "https://dextutor.com/program-for-ipc-using-named-pipes-mkfifo",
        "document": "The third method for IPC is using mkfifo() function. mkfifo() creates a named pipe which can be used exactly like a file. So, if you know how to read/write in a file this is a convenient method for IPC\n\nmkfifo() makes a FIFO special file with the name specified by pathname and the permissions are specified by mode. On success mkfifo() returns 0 while on error it returns -1.\n\nThe advantage is that this FIFO special file can be used by any process for reading or writing just like a normal file. This means to sender process can use the write() system call to write data into the pipe and the receiver process can use the read() system call to read data from the pipe, hence, completing the communication.\n\nIt is same as a pipe except that it is accessed as part of the filesystem. Multiple process can access it for writing and reading. When the FIFO special files is used for exchange of data by process, the entire data is passed internally without writing it on the filesystem. Hence, if you open this special file there will be no content written in it.\n\nNote: The FIFO pipe works in blocked mode(by default) i.e., the writing process must be present on one end while the reading process must be present on the other side at the same time else the communication will not happen. Operating the FIFO special file in non-blocking mode is also possible.\n\nThe entire IPC process will consist of three programs:\n\nProgram1: to create a named pipe\n\nProgram2: process that will write into the pipe (sender process)\n\nProgram3: process that will receive data from pipe (receiver process)\n\n//Now compile and run this program.\n\nThis will simply create a named pipe (fifo1) with read, write and execute permission for all users. You can change this to whatever you prefer\n\nStep 2 is to create a process which will use this pipe to send data. The below program will do that.\n\nCompile this program as\n\n$gcc -o 2 2.c\n\n//Note: If you run this you will not see any output\n\nThe above code opens the pipe created previously in writing mode (because it wants to send data). Then it uses “write” system call to write some data into it. Finally, it prints a message using printf. But when you compile and run it, it won’t run because by default the sender runs in BLOCKING mode which means that until the receiver is not there the sender process gets blocked. Hence, you need a receiver process also.\n\nThe third step is to create the receiver process. The below program does so.\n\nThis program connects to the pipe in reading mode and reads the data into buffer and prints it. But again this program will not run. Because the receiver is BLOCKED until the sender is there.\n\nTherefore, run both the object files simultaneously as\n\n$./2 & ./3\n\nand you will see the output as\n\nNamed pipes can also be used in Un-Blocked mode i.e., the sender (receiver) process will work independently of the other process. Refer the video above for more details of how to run named pipe in unblocked mode.\n\nViva Questions on Program for IPC using named pipes (mkfifo())\n\nQ1. Is named pipe bidirectional or unidirectional pipe?\n\nQ2. What is the default mode of a named pipe : blocking or non-blocking?\n\nQ3. What is meant by Blocking-Send?\n\nQ4. Can a process create two named pipes for communication with two different processes?"
    },
    {
        "link": "https://geeksforgeeks.org/input-output-system-calls-c-create-open-close-read-write",
        "document": "System calls are the calls that a program makes to the system kernel to provide the services to which the program does not have direct access. For example, providing access to input and output devices such as monitors and keyboards. We can use various functions provided in the C Programming language for input/output system calls such as create, open, read, write, etc.\n\nBefore we move on to the I/O System Calls, we need to know about a few important terms.\n\nWhat is the File Descriptor?\n\nThe file descriptor is an integer that uniquely identifies an open file of the process.\n\nFile Descriptor table: A file descriptor table is the collection of integer array indices that are file descriptors in which elements are pointers to file table entries. One unique file descriptors table is provided in the operating system for each process.\n\nFile Table Entry: File table entries are a structure In-memory surrogate for an open file, which is created when processing a request to open the file and these entries maintain file position.\n\n\n\nStandard File Descriptors: When any process starts, then that process file descriptors table’s fd(file descriptor) 0, 1, 2 open automatically, (By default) each of these 3 fd references file table entry for a file named /dev/tty\n\n\n\nRead from stdin => read from fd 0: Whenever we write any character from the keyboard, it reads from stdin through fd 0 and saves to a file named /dev/tty.\n\nWrite to stdout => write to fd 1: Whenever we see any output to the video screen, it’s from the file named /dev/tty and written to stdout in screen through fd 1.\n\nWrite to stderr => write to fd 2: We see any error to the video screen, it is also from that file write to stderr in screen through fd 2.\n\nBasically, there are total 5 types of I/O system calls:\n\nThe create() function is used to create a new empty file in C. We can specify the permission and the name of the file which we want to create using the create() function. It is defined inside <unistd.h> header file and the flags that are passed as arguments are defined inside <fcntl.h> header file.\n\nSyntax of create() in C\n• filename: name of the file which you want to create\n• mode: indicates permissions of the new file.\n• None return first unused file descriptor (generally 3 when first creating use in the process because 0, 1, 2 fd are reserved)\n\nHow C create() works in OS\n• None Create a new empty file on the disk.\n• None Set the first unused file descriptor to point to the file table entry.\n\nThe open() function in C is used to open the file for reading, writing, or both. It is also capable of creating the file if it does not exist. It is defined inside <unistd.h> header file and the flags that are passed as arguments are defined inside <fcntl.h> header file.\n\nSyntax of open() in C\n• Path: Path to the file which we want to open.\n• absolute path beginning with “/” when you are not working in the same directory as the C source file.\n• relative path which is only the file name with extension, when you are working in the same directory as the C source file.\n• flags: It is used to specify how you want to open the file. We can use the following flags.\n\nHow C open() works in OS\n• None Find the existing file on the disk.\n• None Set the first unused file descriptor to point to the file table entry.\n\nExample of C open()\n\nThe close() function in C tells the operating system that you are done with a file descriptor and closes the file pointed by the file descriptor. It is defined inside <unistd.h> header file.\n\nSyntax of close() in C\n• fd: F ile descriptor of the file that you want to close.\n\nHow C close() works in the OS\n• None Destroy file table entry referenced by element fd of the file descriptor table \n\n – As long as no other process is pointing to it!\n\nExample 1: close() in C\n\nHere, In this code first open() returns 3 because when the main process is created, then fd 0, 1, 2 are already taken by stdin, stdout, and stderr. So the first unused file descriptor is 3 in the file descriptor table. After that in close() system call is free it these 3 file descriptors and then set 3 file descriptors as null. So when we called the second open(), then the first unused fd is also 3. So, the output of this program is 3.\n\nFrom the file indicated by the file descriptor fd, the read() function reads the specified amount of bytes cnt of input into the memory area indicated by buf. A successful read() updates the access time for the file. The read() function is also defined inside the <unistd.h> header file.\n\nSyntax of read() in C\n• fd: file descriptor of the file from which data is to be read.\n• None return 0 on reaching the end of file\n• buf needs to point to a valid memory location with a length not smaller than the specified size because of overflow.\n• fd should be a valid file descriptor returned from open() to perform the read operation because if fd is NULL then the read should generate an error.\n• cnt is the requested number of bytes read, while the return value is the actual number of bytes read. Also, some times read system call should read fewer bytes than cnt.\n\nExample of read() in C\n\nSuppose that foobar.txt consists of the 6 ASCII characters “foobar”. Then what is the output of the following program?\n\nThe descriptors fd1 and fd2 each have their own open file table entry, so each descriptor has its own file position for foobar.txt. Thus, the read from fd2 reads the first byte of foobar.txt, and the output is c = f, not c = o.\n\nWrites cnt bytes from buf to the file or socket associated with fd. cnt should not be greater than INT_MAX (defined in the limits.h header file). If cnt is zero, write() simply returns 0 without attempting any other action.\n\nThe write() is also defined inside <unistd.h> header file.\n\nSyntax of write() in C\n• None returns the number of bytes written on success.\n• None return 0 on reaching the End of File.\n• None The file needs to be opened for write operations\n• buf needs to be at least as long as specified by cnt because if buf size is less than the cnt then buf will lead to the overflow condition.\n• cnt is the requested number of bytes to write, while the return value is the actual number of bytes written. This happens when fd has a less number of bytes to write than cnt.\n• None If write() is interrupted by a signal, the effect is one of the following:\n• None If write() has not written any data yet, it returns -1 and sets errno to EINTR.\n• None If write() has successfully written some data, it returns the number of bytes it wrote before it was interrupted.\n\nExample of write() in C\n\nHere, when you see in the file foo.txt after running the code, you get a “hello geeks“. If foo.txt file already has some content in it then the write a system calls overwrite the content and all previous content is deleted and only “hello geeks” content will have in the file.\n\nExample: Print “hello world” from the program without using any printf function.\n\nIn this code, buf1 array’s string “hello world” is first written into stdin fd[0] then after that this string write into stdin to buf2 array. After that write into buf2 array to the stdout and print output “hello world“."
    },
    {
        "link": "https://geeksforgeeks.org/basics-file-handling-c",
        "document": "File handling in C is the process in which we create, open, read, write, and close operations on a file. C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc. to perform input, output, and many different C file operations in our program.\n\nWhy do we need File Handling in C?\n\nSo far the operations using the C program are done on a prompt/terminal which is not stored anywhere. The output is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program. The use of file handling is exactly what the situation calls for.\n\nIn order to understand why file handling is important, let us look at a few features of using files:\n• Reusability: The data stored in the file can be accessed, updated, and deleted anywhere and anytime providing high reusability.\n• Portability: Without losing any data, files can be transferred to another in the computer system. The risk of flawed coding is minimized with this feature.\n• Efficient: A large amount of input may be required for some programs. File handling allows you to easily access a part of a file using few instructions which saves a lot of time and reduces the chance of errors.\n• Storage Capacity: Files allow you to store a large amount of data without having to worry about storing everything simultaneously in a program.\n\nTypes of Files in C\n\nA file can be classified into two types based on the way the file stores the data. They are as follows:\n\nA text file contains data in the form of ASCII characters and is generally used to store a stream of characters.\n• None Each line in a text file ends with a new line character (‘\n\n’).\n• None It can be read or written by any text editor.\n• None They are generally stored with .txt\n• None Text files can also be used to store the source code.\n\nA binary file contains data in binary form (i.e. 0’s and 1’s) instead of ASCII characters. They contain data that is stored in a similar manner to how it is stored in the main memory.\n• None The binary files can be created only from within a program and their contents can only be read by a program.\n• None More secure as they are not easily readable.\n• None They are generally stored with .bin\n\nC file operations refer to the different possible operations that we can perform on a file in C such as:\n• fopen() with attributes as “a” or “a+” or “w” or “w+”\n\nThe highlighted text mentions the C function used to perform the file operations.\n\nA file pointer is a reference to a particular position in the opened file. It is used in file handling to perform all file operations such as read, write, close, etc. We use the FILE macro to declare the file pointer variable. The FILE macro is defined inside <stdio.h> header file.\n\nFile Pointer is used in almost all the file operations in C.\n\nFor opening a file in C, the fopen() function is used with the filename or file path along with the required access modes.\n• file_name: name of the file when present in the same directory as the source file. Otherwise, full path.\n• access_mode: Specifies for what operation the file is being opened.\n• None If the file is opened successfully, returns a file pointer to it.\n• None If the file is not opened, then returns NULL.\n\nFile opening modes or access modes specify the allowed operations on the file to be opened. They are passed as an argument to the fopen() function. Some of the commonly used file access modes are listed below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) returns NULL. Open for reading in binary mode. If the file does not exist, fopen( ) returns NULL. Open for writing in text mode. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens only in the append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. If the file does not exist, it will be created. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file does not exist, fopen( ) returns NULL. Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist a new file is created. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens the file in both reading and append mode. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. If the file does not exist, it will be created.\n\nAs given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”.\n\nThe file is not opened because it does not exist in the source directory. But the fopen() function is also capable of creating a file if it does not exist. It is shown below\n\nThe fopen() function can not only open a file but also can create a file if it does not exist already. For that, we have to use the modes that allow the creation of a file if not found such as w, w+, wb, wb+, a, a+, ab, and ab+.\n\nThe file read operation in C can be performed using functions fscanf() or fgets(). Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. There are also other functions we can use to read from a file. Such functions are listed below:\n\nSo, it depends on you if you want to read the file line by line or character by character.\n\nThe getc() and some other file reading functions return EOF (End Of File) when they reach the end of the file while reading. EOF indicates the end of the file and its value is implementation-defined.\n\nThe file write operations can be performed by the functions fprintf() and fputs() with similarities to read operations. C programming also provides some other functions that can be used to write data to a file such as:\n\nThe fclose() function is used to close the file. After successful file operations, you must always close a file to remove it from the memory.\n\nwhere the file_pointer is the pointer to the opened file.\n\nExamples of File Handing in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nThis program will create a file named GfgTest.c in the same directory as the source file which will contain the following text: “GeeksforGeeks-A Computer Science Portal for Geeks”.\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nThis program reads the text from the file named GfgTest.c which we created in the previous example and prints it in the console.\n\nTill now, we have only discussed text file operations. The operations on a binary file are similar to text file operations with little difference.\n\nTo open a file in binary mode, we use the rb, rb+, ab, ab+, wb, and wb+ access mode in the fopen() function. We also use the .bin file extension in the binary filename.\n\nWe use fwrite() function to write data to a binary file. The data is written to the binary file in the from of bits (0’s and 1’s).\n• ptr: pointer to the block of memory to be written.\n• size: size of each element to be written (in bytes).\n\nExample: Program to write to a Binary file using fwrite()\n\nThe fread() function can be used to read data from a binary file in C. The data is read from the file in the same form as it is stored i.e. binary form.\n• ptr: pointer to the block of memory to read.\n• size: the size of each element to read(in bytes).\n\nExample: Program to Read from a binary file using fread()\n\nIf we have multiple records inside a file and need to access a particular record that is at a specific position, so we need to loop through all the records before it to get the record. Doing this will waste a lot of memory and operational time. To reduce memory consumption and operational time we can use fseek() which provides an easier way to get to the required data. fseek() function in C seeks the cursor to the given record in the file.\n\nThe rewind() function is used to bring the file pointer to the beginning of the file. It can be used in place of fseek() when you want the file pointer at the start.\n\nMore Functions for C File Operations\n\nThe following table lists some more functions that can be used to perform file operations or assist in performing them."
    },
    {
        "link": "https://damienct.medium.com/mastering-file-navigation-with-lseek-in-c-c-798af5e0043d",
        "document": "Today we will delve deeper into the field of file manipulation in C/C++ to with the lseek() function.\n\nWhen working with files in C/C++, you may encounter the challenge of accessing specific portions of a large file. This is precisely where the lseek() function becomes your ally. It allows you to move the read or write pointer inside a file, providing precise control over your operations.\n\nThe signature of the lseek() function is as follows:\n\nfd: The file descriptor on which you want to perform the seek operation.\n\noffset: The offset to apply relative to the reference position, measured in bytes.\n\nwhence: The reference position from which the offset is calculated. C\n\nommon values are SEEK_SET, SEEK_CUR, and SEEK_END, representing the beginning, current position, and end of the file respectively.\n\nLet’s say we have a file named “data.txt” containing structured data and we want to move it to a specific position for reading. Here’s how to use lseek() to achieve this:\n\nWe start by accessing the “data.txt” file in a way that restricts us to read-only. Next, we use the lseek() function to move the read pointer to position 100 from the starting point of the file (`SEEK_SET`). With this adjustment complete, we are now ready to engage in reading activities from this new point.\n\nNavigating to the Last Line of a Log File\n\nAssume we have a log file named “journal.log” and we want to extract the last line. Here’s how to use lseek() to reach the end of the file and extract the line:\n\nWe initiate access to the log file “journal.log” in a mode that only permits reading. Through the utilization of the lseek() function, we shift the reading indicator towards the conclusion of the file (`SEEK_END`). Upon reaching this terminal point, we are enabled to peruse the content within the ultimate line.\n\nIf we have a text file “sample.txt” with several paragraphs, and we want to extract and display the second paragraph. Here’s how you can achieve that:\n\nWe open the text file “sample.txt” in read-only mode. We loop through the file until we reach the second paragraph, counting the newline characters (`’\n\n’`). Once we have identified the position at the beginning of the second paragraph, we use lseek() to move there (`SEEK_SET`). Finally, we read and display the contents of this paragraph.\n\nKudos, you now have a firm understanding of lseek() in C/C++, a potent tool for file management. Bon voyage in the fascinating world of file manipulation in C/C++."
    },
    {
        "link": "https://stackoverflow.com/questions/58052828/using-lseek-system-call-in-c-to-read-a-structure-written-in-a-file",
        "document": "I have written a structure Student into a file and read the whole structure to the console. Now, I want to reposition the file pointer to read information about a specific student. I want to use system calls only to write to the file (read(), write(), lseek())\n\nHere is the code used to write the structure to the file:\n\nHere is the code to read the whole structure written into the file:\n\nHere is the code to read information about a specific student:\n\nCould you help me read the information of a specific student from the file using lseek() to position the file pointer?"
    },
    {
        "link": "https://quora.com/What-are-the-basic-file-operations-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://geeksforgeeks.org/named-pipe-fifo-example-c-program",
        "document": "Named Pipe or FIFO with example C program\n\nIn computing, a named pipe, also known as a FIFO (First In, First Out), is a powerful mechanism for inter-process communication (IPC). Unlike unnamed pipes, which are temporary and exist only as long as the process that created them is running, named pipes provide a persistent communication channel between processes, surviving beyond the life of the process that created them. This makes named pipes an essential tool for developers who need processes to exchange data reliably and efficiently.\n\nA named pipe is an extension of the traditional pipe concept in Unix. While a traditional pipe is “unnamed” and exists only temporarily, a named pipe can persist as long as the system is up or until it is explicitly deleted. Named pipes appear as special files in the filesystem, and multiple processes can attach to them for reading and writing, facilitating inter-process communication.\n\nA FIFO file allows two or more processes to communicate by reading from and writing to the same file. This file type is created using the ‘mkfifo()’ system call in C. Once created, any process can open the named pipe for reading or writing, similar to how it would handle an ordinary file. However, it is important to note that a named pipe must be opened simultaneously at both ends (for reading and writing) before any input or output operations can occur.\n\nHow to Create a Named Pipe (FIFO) in Unix\n\nTo create a FIFO special file, you use the ‘mkfifo()’ function in C. The function creates a named pipe with the specified pathname and permissions.\n\n\n\n‘mkfifo()’ makes a FIFO special file with name pathname. Here ‘mode’ specifies the FIFO’s permissions. It is modified by the process’s umask in the usual way: the permissions of the created file are (mode & ~umask).\n\nUsing FIFO: As named pipe(FIFO) is a kind of file, we can use all the system calls associated with it i.e. open, read, write, close.\n\nExample Programs to illustrate the named pipe: There are two programs that use the same FIFO. Program 1 writes first, then reads. The program 2 reads first, then writes. They both keep doing it until terminated.\n\n\n\nOutput: Run the two programs simultaneously on two terminals.\n\n\n\nThe Named pipes (FIFOs) are a robust method for the inter-process communication allowing data to be passed between the processes using a named file. This mechanism is useful in the scenarios where processes need to exchange data without direct knowledge of the each other. The example demonstrates a simple producer-consumer model where one process writes data to a FIFO and another reads it showcasing the basic usage of the named pipes in C.\n\nNamed Pipe or FIFO with Example C Program – FAQs\n\nWhat is the primary difference between a named pipe and an unnamed pipe?\n\nHow do I handle errors when working with FIFOs?\n\nCan multiple processes write to or read from the same FIFO?"
    },
    {
        "link": "https://stackoverflow.com/questions/10958438/communication-between-two-processes-using-named-pipes-and-semaphores",
        "document": "I'm trying to communicate between two processes (like a chat room). Each process has its own terminal window opened. I'm using named pipes for communication.\n\nI have a FIFO_FILE named \"MYFILE\". Process A writes a new line to MYFILE and process B reads from MYFILE and outputs the line to process B's terminal display. However, if process B wants to write a new line to MYFILE, (from what I understand about semaphore) process A will be blocked from reading/writing to MYFILE until process B finishes writing.\n\nWhat I want to achieve is: When two processes want to write, no process should be blocked when other process is ahead of it writing to the file.\n\nThe only way I can think of is to have two FIFO_FILEs. But How to achieve this implementation? Or is there other way to achieve?\n\nI was told to use Consumer-Producer pattern but I don't see how this will solve my problem.\n\nAny help would be great. Thanks!!"
    },
    {
        "link": "https://stackoverflow.com/questions/67286729/c-linux-program-using-named-pipes-works-as-expected-when-one-process-at-a-time-w",
        "document": "My program has a consumer and multiple producers. The producers each read a different file and write their content into a FIFO in N-sized chunks, with a leading parameter for the consumer to interpret.\n\nThe consumer is supposed to take these chunks and compose an output file where each line corresponds to one producer. The leading parameter from the chunk is used to determine the owner of the chunk and where to write it (it's a line number number in the output file).\n\nMy problem is, even though it works mostly fine when there's one producer, any more make the resulting file a mess. Also there are some unexpected excessive but they aren't critical.\n\nThis is my expected output:\n\nbut that's what I get:\n\nThere's an unexpected cutoff in the later lines and the chunks become mixed up.\n\nI think it's a problem with how I handle the named pipes, because I'm printing the \"raw input\" before further processing and I can see that I'm reading invalid data from the pipe. But AFAIK Linux has atomic writes for small chunks of data for FIFO. Maybe the reads aren't caring about the writes and that's where lies the problem?\n\nAfter running both the producer and the consumer the communication should start working and after some time there should be an output file. After each such execution you have to manually remove the file, because I didn't really consider the situation where it has existed before.\n\nExample start (each line should be in a different terminal):\n\nThere are a lot of debug prints, I'm not sure if they are helpful or not but I'm leaving them in."
    },
    {
        "link": "https://opensource.com/article/19/4/interprocess-communication-linux-channels",
        "document": ""
    },
    {
        "link": "https://quora.com/How-can-I-write-successfully-to-a-named-pipe-in-a-C-program",
        "document": "Something went wrong. Wait a moment and try again."
    }
]