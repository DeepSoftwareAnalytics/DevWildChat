[
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/create-csharp-winform-visual-studio?view=vs-2022",
        "document": "Tutorial: Create a Windows Forms app in Visual Studio with C#\n\nIn this tutorial, you create a simple C# application that has a Windows-based user interface (UI). The app has a button that changes the text of a label. This simple app has all the components used for more complicated Windows Forms programs.\n\nFirst, create a C# application project. The project type comes with all the template files you need to create your application.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text, change the name from Button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from Button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of Label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose View Code or select F7 from the shortcut menu on Form1.cs.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Expand Common Controls and select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text. Change the name from button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose Form1.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n• None Select the Start button to run the application. Several things happen. In the Visual Studio IDE, the Diagnostics Tools window opens, and an Output window opens, too. But outside of the IDE, a Form1 dialog box appears. It includes your Click this button and text that says label1.\n• None Select the Click this button in the Form1 dialog box. Notice that the label1 text changes to Hello World!.\n• None Close the Form1 dialog box to stop running the app.\n\nCongratulations on completing this tutorial. To learn more, continue with the following tutorial:\n\nOr try these other tutorials:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-add-to-a-form?view=netdesktop-9.0",
        "document": "Most forms are designed by adding controls to the surface of the form to define a user interface (UI). A control is a component on a form used to display information or accept user input.\n\nThe primary way a control is added to a form is through the Visual Studio Designer, but you can also manage the controls on a form at run time through code.\n\nVisual Studio uses the Forms Designer to design forms. There is a Controls pane which lists all the controls available to your app. You can add controls from the pane in two ways:\n\nWhen a control is double-clicked, it is automatically added to the current open form with default settings.\n\nSelect the control by clicking on it. In your form, drag-select a region. The control will be placed to fit the size of the region you selected.\n\nControls can be created and then added to a form at run time with the form's Controls collection. This collection can also be used to remove controls from a form.\n\nThe following code adds and positions two controls, a Label and a TextBox:"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/l4n6y1/whats_the_best_way_to_develop_something_with_gui",
        "document": "Getting used to C# here and now I want to develop my own projects BUT I learned only how to do console applications and end users in general almost have a stroke looking at any terminal so...\n\nHow people usually do this stuff?\n\nWas thinking about learning how to use the Windows Forms but I was told this is very 'unprofessional' and nobody take it serious even after finished so I really don't know where to go now.\n\nThere's this UWP but apparently this is also a problem because anything from it only runs on Windows 10, but it's the evolution from WPF and this makes it the better option? I'm just lost.\n\nI really don't know... Unity uses C# but I'm not interested in game development.\n\nHow people build good desktop/mobile applications with C#?"
    },
    {
        "link": "https://medium.com/mesciusinc/the-definitive-guide-to-winforms-controls-f7f12196563a",
        "document": "WinForms (Windows Forms) is the original .NET platform for building desktop applications for Windows PCs. A WinForms application is composed of various code and resource files compiled into a runtime executable. Every part of the WinForms application — including the user interface — is defined by writing extensive C# .NET or VB.NET code — a process made easier using the Visual Studio designer.\n\nWinForms UI controls are reusable design elements that help developers implement a wide variety of features. Technically, you can create anything you want in .NET Windows Forms with enough code, but UI controls save you time by providing a collection of commonly used concepts like buttons, text boxes, and so on.\n\nControls have an API (application programmable interface), which lets you configure how the control will work for your specific application. Consider a Button control, for example. It has a “Text” property, which can be set to the text you want displayed in the button. It also has size properties like “Width” and “Height.” It also has event triggers when actions occur, such as a “Clicked” event that fires when the user clicks the button. Complex controls have richer APIs.\n\nThe base controls included with .NET are often known as “standard” or “basic” controls. These controls are a part of the base .NET libraries. Standard .NET WinForms controls typically fall into three main categories: input, layout, and data display.\n• Input controls are used to collect input from the user or provide text editing.\n• Layout controls define the window or frame layout, including containers and toolbars.\n• Data controls are used to display and sometimes edit collections of data.\n\nBelow is a table containing the common WinForms controls.\n\nThis table leaves out some additional non-UI components and dialogs that don’t display on the form but can impact the usability of the application. For complete lists of UI controls, check out the .NET documentation.\n\nThe datagrid control is often the heart or brain of the application, providing the most data-centric functionality in one control. Users can view, edit, and analyze their data with one powerful control. The standard datagrid, DataGridView, supports basic functions like data-binding, sorting, cell formatting, column reordering, and selection.\n\nAdvanced and niche features can be achieved using a third-party datagrid. These features include exporting to Microsoft Excel, multi-level hierarchical views, transposing the rows and columns, multi-line rows, and so much more. You can save a lot of time by licensing a third-party datagrid library rather than implementing those features yourself — which involves extending the DataGridView and overriding a lot of rendering. Continue reading for more information.\n\nMicrosoft made the .NET frameworks extensible, allowing developers to further extend the capabilities of their applications themselves. Third-party control suites typically fill the gap for input controls, as well as provide new and innovative layout and data-centric controls. Unlike most free control suites, they come with complete samples and documentation and are regularly updated and tested.\n\nYou can find some free WinForms controls on GitHub. You can even invest in professionally developed UI controls from companies like DevExpress, Mescius (formerly GrapeCity), Progress (formerly Telerik), and SyncFusion.\n\nWe’ve analyzed the install data to see the most downloaded third-party WinForms controls. Just looking at the ComponentOne WinForms controls, which have been developed for over 20 years since .NET 1.0, here are the most popular five controls:\n\n1.FlexGrid — It may be no surprise that FlexGrid is the most popular datagrid. It’s one of the longest-running controls originating from the VB6 VSFlexGrid control for ActiveX. The most useful feature of FlexGrid is the simple Subtotal method, which groups the grid by any column and aggregates, or subtotals, that column to display the total in the group header row. You can read more about how the standard DataGridView stacks up against FlexGrid in our previous article.\n\n2. Ribbon — A WinForms Ribbon UI provides a complete toolbar and menu system for a Windows desktop app that wants to replicate the same UI from Microsoft Office. One of the most versatile features is the ability to collapse the ribbon into a condensed toolbar. End users can toggle this runtime feature according to their preferences.\n\n3. DockingTab — The DockingTab control provides WinForms floating panel behavior, where the whole control or individual panels (tabs) can be torn off and automatically docked to any other edge of the application or floated in a separate window. The DockingTab control provides a customizable workspace framework, similar to complex designer applications like Adobe Photoshop and Premiere.\n\n4. Charts — Charts are consistently among the most popular third-party .NET UI controls because they are complex and difficult to write from scratch independently. ComponentOne FlexChart makes this list along with its family of specialized components: FlexPie, FlexRadar, Sunburst, Treemap, and FinancialChart.\n\n5. Input -The C1TextBox and C1Button controls (as well as every ComponentOne Input control) support application-wide theming, the key feature not supported by the standard input controls. This means you can make all your text boxes and buttons blend seamlessly with whatever theme you have, whether it be white, modern, dark, material, or any other.\n\nHow to Add WinForms Controls to Your .NET Applications\n\nWindows Forms provides one of the most productive ways to create desktop apps based on the visual designer provided in Visual Studio.\n\nLet’s start by creating the .NET Windows Forms application that targets .NET 8.\n• Open Visual Studio (note that you can build complete WinForms applications using the free Community edition of Visual Studio).\n\nHow to Add Standard Controls through the Designer\n\nUI controls can be added to a Windows Form by dragging and dropping them from the toolbox. Visual Studio generates the code-behind that instantiates, which can be specified as C# .NET or VB.NET, and positions the controls on the form.\n\nDrag and drop some buttons and other controls to test it out.\n\nWhile writing this code yourself would not be too difficult, it is very tedious. The WinForms visual designer saves a lot of time generating the application UI.\n\nThird-party WinForms controls are also added to the UI from the toolbox, but first, we must add them to the toolbox. There are two methods for adding third-party controls to the toolbox: DLL reference and NuGet package.\n• DLL Reference — This is the original approach and can be used if you’ve downloaded a library assembly file (.dll) for your third-party control. Right-click the toolbox and select “Choose Items…”. From there, you can browse and locate your library.\n• NuGet Package — This is the new way to work with all .NET components. Under the Visual Studio “Tools” menu, you can launch the “NuGet Package Manager” for the solution. Then, browse for your library from the public nuget.org source or any custom source. Once the package is installed, its controls will appear in your toolbox.\n\nThe major difference between these approaches is that adding the DLLs to the toolbox does not add them to the project. The control must be dropped to the design surface for the project reference to be added. With the NuGet package, you are first adding the project reference.\n\nTo test this out, browse for the C1.Win.FlexGrid package and install the latest version. You’ll observe this adds the C1FlexGrid control to your toolbox in its own group.\n\nThe primary purpose of the UI controls is to collect input and display data to the user. Data binding is the process of “automatically” populating the UI controls with data from a data source, such as a database. When controls are data-bound, .NET handles most of the code for you. You simply have to specify what collection and field to bind.\n\nConsider the following C# ViewModel class, which generates a collection of weather data. With the MVVM (Model-View-ViewModel) architectures, we specify a Model class for each business object (table in our data set). The UI controls are then bound to a collection of the business objects through this ViewModel.\n\nAt design time, WinForms controls rely on a BindingSource component, which acts as an intermediary that provides binding and currency management services. You bind the BindingSource to a collection of your objects, then set the DataSource property of your UI control to the BindingSource. However, in code, you can simply set it to any collection that inherits IList, IBindingList, or IEnumerable. Note that the code above returns an IEnumerable array and that the different collection types provide different data features.\n\nVisual appearance is another important factor to consider when using WinForms controls. Windows Forms is the oldest framework in .NET, but over the past two decades, the overall look and feel of the application has not improved. The intentional design of WinForms is to match the user’s Windows operating system. Thus, the WinForms UI controls inherit their style from the operating system colors.\n\nUnfortunately, it’s not easy to customize the system colors for a single application. The solution is to inherit the control and create your own version that can override the low-level rendering. This allows you to customize the look of a WinForms UI control beyond its API. It’s not a typical task for a .NET developer, which is why third-party WinForms UI controls are very popular.\n\n.NET WinForms control suites often include built-in themes and tools to customize the theme for you. For example, check out these advanced WinForms UI controls.\n\nWPF (Windows Presentation Foundation) was released with .NET 3.0 as a potential replacement for WinForms. To this day, both platforms remain viable solutions for developing .NET desktop applications. The main difference is that WPF components are implemented using XAML, which can make customization easier but can arguably make the overall UI development a bit more complicated than WinForms.\n\nSome key arguments in the debate include:\n• XAML is easier to customize and data bind\n• WinForms controls are more abundant and easier to build\n• WPF can achieve the best performance\n• Both are built on Win32 and support .NET Core\n\nXAML is Easier to Customize and Data Bind\n\nWPF uses XAML (similar to XML) to define and separate the user interface from business logic. WPF (and other XAML-based frameworks like WinUI) allow you to set properties and data binding directly in the markup. WPF is typically considered more MVVM-friendly because data binding is very straightforward, thanks to the DataContext concept. In the WPF XAML example below, we set the DataContext for the Window so that its children can easily bind the ViewModel.\n\nXAML-based components are inherently more customizable with styles and control templates. Styles encapsulate properties into reusable resources (i.e., you can design one style that is applied across an entire application). If you need to customize a WPF UI control further, you can customize its XAML template — which is generally considered a step easier than overriding WinForms renderers but still is not a simple task for the average developer.\n\nMany third-party libraries offer a rich API for appearance customization that saves a lot of development time. ComponentOne WPF controls provide extensive brush and color properties that allow you to customize the look of controls without needing themes or custom templates. Plus, some built-in themes, such as Google’s Material and Microsoft Office-inspired themes, are provided.\n\nWinForms Controls are More Abundant and Easier to Build\n\nWinForms has been around longer and still has a higher adoption rate than WPF, which means there are more WinForms controls on the market. So, if your application has some specific niche requirement, you’ll have more luck finding a WinForms control for that.\n\nSince WinForms UIs are defined using C#, it’s not as visual on its own. Microsoft had to develop the “design time” experience for WinForms with a drag-and-drop feature and many click-through wizards to configure parts of the application. As a result, WinForms design time is richer and more evolved than WPF, and it’s the reason many developers still prefer WinForms.\n\nWPF Can Achieve the Best Performance\n\nWPF is built upon DirectX, a lower-level rendering engine that allows optimal performance on Windows. WinForms, on the other hand, typically uses GDI+ (graphics device interface), which is a legacy graphics drawing library. Generally, DirectX is considered superior.\n\nWPF is also more scalable than WinForms due to its XAML architecture. Every non-web .NET framework that Microsoft has developed since WPF has used the same markup language (XAML), including WinUI. WinUI is used to create modern, Universal Windows applications, otherwise known as Microsoft Store apps. It uses XAML UI components, which are similar to WPF.\n\nDue to the .NET framework’s extensibility, anyone can build their own WinForms UI controls. A custom UI control is just a few C# classes that contain some public properties, events, and methods that handle things like rendering and recycling.\n\nDepending on how complex your custom control is, you may be able to take advantage of the .NET UserControl class. This provides a lot of the work for you, allowing you to focus directly on the logic. UserControls are often built using a combination of other existing UI controls, but they will enable you to embed your own custom logic into a reusable package.\n\nFor example, if your custom control can be created by combining a ComboBox and a Button, you can use the UserControl template in Visual Studio. If your custom control can’t be created by simply using standard controls, then you have to build a completely custom control from scratch. See how to create custom controls in .NET for more information.\n\nWhen to Buy vs Build a WinForms Control\n\nYou and your boss may wonder when you should purchase third-party WinForms controls instead of building them yourself. Obviously, the cost for developers is high, so you should consider the time and maintenance put into developing the controls yourself.\n\nIt’s recommended to build your own custom UI controls if:\n• You can afford the extra development time\n• You have enough time\n• You have a particular requirement that may not be supported in an “off-the-shelf” control\n• The application is a one-off that will not need to be maintained\n\nYou may have heard the saying, “Fast, cheap, or good: pick two.” It means if you want it to be cheap and good, don’t expect to get it any time soon; if you want it to be fast and good, expect to spend a lot of money.\n\nIt’s best to purchase UI controls when:\n• Your developers are also the support team\n• You can afford it\n\nIf you’re the developer, the designer, the QA, and everything in between, a licensed toolkit from a respected company will be invaluable. The amount of time you save using third-party controls during the initial development period is multiplied over time, meaning five to ten years down the road, you’ve saved five to ten times more effort than you would otherwise spend maintaining your own custom controls. Yes, it’s an added annual cost. Still, for that price, you get an extended support team, a community of users, and, in the case of ComponentOne WinForms controls, frequent updates that resolve inevitable issues like browser and .NET version compatibility.\n\nWindows Forms is a powerful .NET platform for building fast software applications on Windows. The WinForms UI controls are an essential feature for the fast development cycle. When you combine standard WinForms controls with third-party controls, you can achieve all of your application requirements rapidly.\n\nDespite being one of the oldest .NET technologies, WinForms continues to be widely adopted and is still used in new application development in 2024. Its replacements, such as WPF and WinUI, do offer some benefits, but they do not mark the end for WinForms, as it will continue to be a powerful and wise choice for desktop development."
    },
    {
        "link": "https://stackoverflow.com/questions/42710514/create-a-scrollable-button-list-panel-in-windows-form-c-sharp-application",
        "document": "I'm trying to add a scrollable list of buttons inside a panel from C# scripting inside Visual Studio.\n\nI can make the scrollbar and attach it to a panel and manually add buttons inside the panel from the UI but I want to code for the entire panel along with scrollbar and create buttons inside that newly created panel.\n\nCan anyone help me with this?\n\nIn Unity I can use the OnGUI function and use the GUI class to add these features but I dont know how to do that in Winform application."
    },
    {
        "link": "https://stackoverflow.com/questions/2706500/how-do-i-generate-a-random-integer-in-c",
        "document": "The question looks very simple but the answer is bit complicated. If you see almost everyone has suggested to use the Random class and some have suggested to use the RNG crypto class. But then when to choose what.\n\nFor that we need to first understand the term RANDOMNESS and the philosophy behind it.\n\nI would encourage you to watch this video that I made which goes in depth in the philosophy of RANDOMNESS using C# https://www.youtube.com/watch?v=tCYxc-2-3fY\n\nFirst thing let us understand the philosophy of RANDOMNESS. When we tell a person to choose between RED, GREEN and YELLOW what happens internally. What makes a person choose RED or YELLOW or GREEN?\n\nSome initial thought goes into the persons mind which decides his choice, it can be favorite color , lucky color and so on. In other words some initial trigger which we term in RANDOM as SEED.This SEED is the beginning point, the trigger which instigates him to select the RANDOM value.\n\nNow if a SEED is easy to guess then those kind of random numbers are termed as PSEUDO and when a seed is difficult to guess those random numbers are termed SECURED random numbers.\n\nFor example a person chooses is color depending on weather and sound combination then it would be difficult to guess the initial seed.\n\nNow let me make an important statement:-\n\n*“Random” class generates only PSEUDO random number and to generate SECURE random number we need to use “RNGCryptoServiceProvider” class.\n\nRandom class takes seed values from your CPU clock which is very much predictable. So in other words RANDOM class of C# generates pseudo random numbers , below is the code for the same.\n\nWhile the class uses OS entropy to generate seeds. OS entropy is a random value which is generated using sound, mouse click, and keyboard timings, thermal temp etc. Below goes the code for the same.\n\nTo understand OS entropy see this video of mine starting at 14:30 https://www.youtube.com/watch?v=tCYxc-2-3fY where the logic of OS entropy is explained. So putting in simple words RNG Crypto generates SECURE random numbers."
    },
    {
        "link": "https://dev.to/rasheedmozaffar/working-with-the-random-class-in-c-57i0",
        "document": "...\n\n If you want to generate a basic random number, be it for a number guessing game or generating test data, you will need a way to generate the random numbers, and luckily, the Random class in C# provides the essentials for doing just that.\n\nHow does it work\n\nTo make use of the Random class, we need to create an instance of it, in its constructor goes something known as a seed value, this value serves a purpose for the random generator algorithm, the seed ultimately becomes the starting point for the random number sequence that the instance will generate. However, the seed value is optional, and honestly you should avoid providing one, because if the seed value is known, the random numbers can be guessed, which defeats the sole purpose of a random being a random here.\n\nA question you may ask is, what would happen if we do not supply a seed value?\n\nWhen that value isn't provided while creating the random class instance, it'll automatically use the system clock as a seed, and it's basically the moment at which the instance was created, I believe it's a very small number in like nano seconds or something, which isn't really that important, just know that when you supply a value, the produced random outcome could be guessed and that's not practical.\n\nFor demonstration purposes, I'll show you an example, the example code is written in a console app, keeping things simple as usual.\n\n\n\nNow I provided 5 as a seed value, I could've supplied any number that came to my mind, but that's not the interesting part, the code here is pretty basic, I'm just initializing a random instance and using a for loop to generate 10 Non-negative integers using the Next() method. \n\n Now, if you do a dotnet run, you'll get 10 random numbers, however, running the app again and again will yield out the same result every single time, that's because I added that seed value while creating my random instance, you're now getting the same fixed numbers every time you're running the app, which doesn't seem any useful. For instance, if you're creating a random number guessing game, the random number once guessed, will be the exact answer every time, like say the correct answer is 88, no matter how many times you re run your game, the answer is 88.\n\nAnother situation is if you created 2 random instances at the same time, without supplying any seed value, because they'll use the system clock, and they both were created at an equivalent time, the random sequences they'll generate are going to be the same, so for that reason, always create a single instance, and use the Next method when you want a new random number.\n\nThe random numbers you'll get from the next method are going to be within an unspecified range, but what if you need something within a particular range? You can specify the bounds for your random number in the call for Next().\n\nWhen calling the Next method, you can supply 2 arguments, the lower and upper bounds, or just the upper bound (In this case the lower bound will default to 0). You got to pay attention to the fact that the upper bound isn't inclusive, like if you want your higher bound to be 10, you will need to do this:\n\n\n\nBut what if I want to generate random numbers with fractions, like doubles?\n\nWell, Random got you covered, instead of calling Next(), you can call NextDouble(). This method will generate a random double between 0 and 1, the upper bound is exclusive so the highest number could be 0.999...\n\n But that's limited, If you want a number that's not only between 0 and 1, you can multiply by it, like this:\n\n\n\nAgain, remember that the upper bound isn't inclusive and thus I'm multiplying by 11 and not 10, now we can get random doubles from 0 up to 10.999...\n\nI think this post was quite concise and short, but I suppose it's a nice idea to recall such a concept that we usually learn at the beginning and then ignore for considerably a long time, overall, even if the chances are low for actually using randoms in your projects, it's still something viable to be aware of as they might come in handy at a certain time.\n\n ..."
    },
    {
        "link": "https://stackoverflow.com/questions/16034133/how-to-generate-a-random-and-then-not-show-that-random-again",
        "document": "I'm writing a card game in C#, a game of blackjack, where the user presses a button and it deals a card, the value of that card gets added to a text box. If the value of the text box goes over 21 the user has lost.\n\nI'm having a problems with the dealing of the cards, i generate a random, say 5 gets generated show the 5 of diamonds, add the value of the 5 of diamonds to the score text box and display a picture box(the 5 of diamonds playing card). However once 5 has been generated i'm having problems not generating that card again, i have the logic down of what needs to happen, i'm just not sure on the actual code itself as i'm a beginner.\n\nSo far iv tried 2 different ways, a List and a array of Boolean values and i'm still struggling, could anybody point me in the right direction in terms of code.\n\nThanks in advance, sorry about the bad grammar!"
    },
    {
        "link": "https://blog.ivankahl.com/beyond-the-random-class-cryptographic-randomness-in-net-6",
        "document": "Learn how to generate cryptographically secure random numbers in .NET applications using the RandomNumberGenerator class. Discover the importance of true randomness for security-sensitive tasks and explore best practices for generating unpredictable values.\n\nWe live in a naturally unpredictable world. Shuffling a deck of cards, picking lottery numbers, and weather patterns are all random. Software often needs to mimic this unpredictability, such as spawning enemies at random intervals in a game, selecting a random sample of data for training a machine learning model, or generating a random OTP code when authenticating a user. Computers, however, are deterministic machines. Given a particular input, the computer will always produce the same output. This makes replicating the unpredictability we live in a challenge in code.\n\nC# offers a couple of APIs for generating random numbers, with the class being a common choice. However, while useful in many scenarios, its implementation isn't always appropriate, especially in security contexts where its predictability can be exploited. In those cases, alternatives like the , which offer a higher degree of unpredictability, are better suited.\n\nIn this article, you will learn how the class functions in C#, when it's appropriate to use, when and why it's not always suitable, and what alternatives to consider.\n\nComputers follow a strict set of instructions to perform a task. Given the same input, the process will yield the same output. This is great for computers, and it's what's needed for them to perform computations accurately.\n\nWhen it comes to randomness, the computer has to cheat by relying on algorithms that generate seemingly random numbers. These algorithms are called Pseudo-Random Number Generators (PRNGs) and consist of mathematical formulas to produce a sequence of numbers that appear random but are still deterministic. PRNGs start with a seed value, which is the starting point for the sequence generation. Given the same seed value, a PRNG will always produce the same sequence of numbers. While not completely random, this predictability can sometimes be helpful where reproducibility is desired, like in unit tests or where reproducing the sequence carries little risk.\n\nHowever, there are cases where you don't want this reproducibility. If an attacker can figure out the seed used to generate the number sequence, they can \"predict\" the next numbers. In specific contexts, like security, this can result in a system getting compromised. For example, if you use a PRNG to generate OTP codes for authentication, an attacker could compromise the system by figuring out the seed and generating the same codes. This is why true randomness, which is unpredictable, is essential for security-sensitive tasks.\n\nThe class is the de facto way of generating random numbers in most applications. It's a PRNG that's been around since the beginning of the .NET Framework. Although its underlying implementation has changed over the years, its API has remained relatively unchanged. It's intuitive, efficient, and works well in most cases.\n\nTo use it, all you need to do is create a new instance of the class and then get the next random numbers:\n\nThe method generates a non-negative random integer. You can also pass in parameters to restrict the result if necessary:\n\nWhen using the overloads, the start number is inclusive (if specified), and the end number is exclusive.\n\nThe class also has methods to generate random bytes, doubles, longs, and even pick random items from an array.\n\nYou'll notice that no seed value was specified when instantiating the class above. When one isn't specified, .NET will generate the seed for you. How that seed is generated has changed over the years. In .NET Framework, the current time is used to create the seed. However, .NET Core and 5+ have improved on this by making an interop call to the operating system to generate a random seed using hardware, which is much less predictable.\n\nYou can pass in a seed using one of the constructor overloads. This is useful if you want to control the sequence of numbers generated. The snippet below demonstrates this:\n\nYou should get the same output as the snippet if you run the code below.\n\nWhen To Use It\n\nThe class is simple and very efficient since all the numbers are generated by software (and not hardware, as you'll see in the next section). The generated numbers are spread across your desired range and will seem random enough for most applications. An end user shouldn't pick up any patterns.\n\nYou'll want to avoid it, though, if being able to predict values will compromise the security of your application or the integrity of your data. For example, generating password salts, nonces, and OTPs should not use the class since predicting those values will be disastrous. Similarly, you might not want to use the class for applications like gambling and picking winners for a draw since predicting the numbers could ruin the integrity of the game.\n\nThe official Microsoft documentation advises not to re-instantiate the class every time you need a number. This makes sense, especially if you're working with .NET Framework, since seeds are generated using the system time. Two generators can have the same seed value if they are instantiated close together.\n\nHowever, even if you're working in modern .NET (i.e., .NET 5 and up), re-instantiating the generator doesn't make sense. The generator is guaranteed to choose from a range of numbers with equal probability, meaning no number is more likely to be generated than another. This is good! But you lose that guarantee if you re-instantiate the class every time.\n\nAlso, keep in mind that the class is not thread-safe. To overcome this challenge, the documentation demonstrates how you can use locks to make sure the object is never called illegally.\n\nSince computers are deterministic, generating truly random numbers is difficult. You need to incorporate entropy into the algorithm. This entropy typically comes from something in real life that exhibits random, unpredictable behaviour. Cloudflare gets entropy from a wall of lava lamps; C# gets entropy from the operating system, which, in turn, relies on underlying hardware for randomness. You can access this more secure random number generator using the class.\n\nMicrosoft recommends using the static implementation of the class, which will be demonstrated in this article.\n\nUnlike the class above, you need to specify the upper bound for the number you want to generate with the class. Another overload also lets you choose the lower bound:\n\nNotice how the output is similar to our previous example, where we used the class. However, these are far less predictable, and because of entropy, it's practically impossible to repeat the sequence of numbers generated.\n\nThe release of .NET 8 introduced several new helper methods to the class. One such method lets you provide a source string and desired length and then generates a random string of that length using the characters in the source string:\n\nThis is useful if you need to create passwords or OTPs.\n\nThe hexadecimal number system lets you represent numbers in base 16. It does this using characters and . From .NET 8 and up, you can generate random hexadecimal numbers using the static method on the class:\n\nWhen To Use It\n\nAfter seeing in action, you might wonder why you would use the class. But wait! As great as the class is, it has additional overhead. Whenever it generates a number, it calls the operating system to add entropy. This call does make the much slower, which you'll see in this benchmark.\n\nThe additional overhead means you should only use the when you actually need cryptographically random numbers. For any other use case, stick to the class.\n\nThis article explored the intricacies of generating random numbers in code, focusing specifically on the and classes in C#. You first learned how computers are deterministic and need to use PRNGs to generate seemingly random numbers. You then saw how to pick random numbers from the class, a PRNG generator. While simple and efficient, the class has limitations, especially regarding cryptographic operations.\n\nYou were then introduced to the , which uses entropy from the underlying operating system to generate cryptographically secure numbers which are practically impossible to predict. The article also demonstrated newer methods added to the class in .NET 8 and up, simplifying generating random strings and hexadecimal numbers.\n\nAs I looked through the source code for these classes, it's clear that very clever engineers have done much of the heavy lifting for us. However, it's still essential to understand how these classes work to use them effectively in your code base.\n\nIf you have any comments or feedback, please leave a comment below."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-random-int",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/collections",
        "document": "The .NET runtime provides many collection types that store and manage groups of related objects. Some of the collection types, such as System.Array, System.Span<T>, and System.Memory<T> are recognized in the C# language. In addition, interfaces like System.Collections.Generic.IEnumerable<T> are recognized in the language for enumerating the elements of a collection.\n\nCollections provide a flexible way to work with groups of objects. You can classify different collections by these characteristics:\n• Element access: Every collection can be enumerated to access each element in order. Some collections access elements by index, the element's position in an ordered collection. The most common example is System.Collections.Generic.List<T>. Other collections access elements by key, where a value is associated with a single key. The most common example is System.Collections.Generic.Dictionary<TKey,TValue>. You choose between these collection types based on how your app accesses elements.\n• Performance profile: Every collection has different performance profiles for actions like adding an element, finding an element, or removing an element. You can pick a collection type based on the operations used most in your app.\n• Grow and shrink dynamically: Most collections support adding or removing elements dynamically. Notably, Array, System.Span<T>, and System.Memory<T> don't.\n\nIn addition to those characteristics, the runtime provides specialized collections that prevent adding or removing elements or modifying the elements of the collection. Other specialized collections provide safety for concurrent access in multi-threaded apps.\n\nYou can find all the collection types in the .NET API reference. For more information, see Commonly Used Collection Types and Selecting a Collection Class.\n\nArrays are represented by System.Array and have syntax support in the C# language. This syntax provides more concise declarations for array variables.\n\nSystem.Span<T> is a type that provides a snapshot over a sequence of elements without copying those elements. The compiler enforces safety rules to ensure the can't be accessed after the sequence it references is no longer in scope. It's used in many .NET APIs to improve performance. Memory<T> provides similar behavior when you can't use a type.\n\nBeginning with C# 12, all of the collection types can be initialized using a Collection expression.\n\nAn indexable collection is one where you can access each element using its index. Its index is the number of elements before it in the sequence. Therefore, the element reference by index is the first element, index is the second, and so on. These examples use the List<T> class. It's the most common indexable collection.\n\nThe following example creates and initializes a list of strings, removes an element, and adds an element to the end of the list. After each modification, it iterates through the strings by using a foreach statement or a loop:\n\nThe following example removes elements from a list by index. Instead of a statement, it uses a statement that iterates in descending order. The RemoveAt method causes elements after a removed element to have a lower index value.\n\nFor the type of elements in the List<T>, you can also define your own class. In the following example, the class that is used by the List<T> is defined in the code.\n\nThese examples use the Dictionary<TKey,TValue> class. It's the most common dictionary collection. A dictionary collection enables you to access elements in the collection by using the key of each element. Each addition to the dictionary consists of a value and its associated key.\n\nThe following example creates a collection and iterates through the dictionary by using a statement.\n\nThe following example uses the ContainsKey method and the Item[] property of to quickly find an item by key. The property enables you to access an item in the collection by using the in C#.\n\nThe following example instead uses the TryGetValue method to quickly find an item by key.\n\nAn iterator is used to perform a custom iteration over a collection. An iterator can be a method or a accessor. An iterator uses a yield return statement to return each element of the collection one at a time.\n\nYou call an iterator by using a foreach statement. Each iteration of the loop calls the iterator. When a statement is reached in the iterator, an expression is returned, and the current location in code is retained. Execution is restarted from that location the next time that the iterator is called.\n\nFor more information, see Iterators (C#).\n\nThe following example uses an iterator method. The iterator method has a statement that is inside a loop. In the method, each iteration of the statement body creates a call to the iterator method, which proceeds to the next statement.\n\nLanguage-integrated query (LINQ) can be used to access collections. LINQ queries provide filtering, ordering, and grouping capabilities. For more information, see Getting Started with LINQ in C#.\n\nThe following example runs a LINQ query against a generic . The LINQ query returns a different collection that contains the results."
    },
    {
        "link": "https://stackoverflow.com/questions/3637984/what-does-collection-contains-use-to-check-for-existing-objects",
        "document": "I have a strongly typed list of custom objects, , which has a property , along with some other properties.\n\nLet's say that the of a defines it as unique and I want to check if my collection doesn't already have a object that has an of 1 before I add my new to the collection.\n\nI want to use , but how do I enforce the fact that only one or two properties of define it as unique?\n\nI can use ? Or do I only have to override an method? If so, I'd need to inherit something first, is that right?"
    },
    {
        "link": "https://dev.to/jlewis92/a-quick-tour-of-lists-in-c-2id5",
        "document": "Some of you might have seen my previous article around dictionaries in C#. Seemed to be fairly popular, so I thought I'd write a similar around lists in C#. AS in dictionaries, C# provides a lot of versions of a simple list. I've not seen previous articles comparing and contrasting the different versions of a list and where to use them.\n\nQuite simply, a list is a data structure in C# used to hold list of objects of the same type. They are also generic, meaning the type in the list is declared at initialization. Lists are also specifically an ordered data structure, meaning that the order you add items to the list is the order of the items in that list, including duplicate values. Finally, lists are \"designed\" to be throwaway. This is because it can be difficult to extend a list in the same way a collection can be. In fact, while collections are outside the scope of this article, it's generally considered better practice to return a collection from public methods, but in reality a list works fine 999 times out of 1000.\n\nThere is more information on lists found here.\n\nAs in the previous article, I'll run through some of the features I use most often in the \"default\" list and move onto other implementations afterwards.\n\nNote: I'm using nullable strings (i.e.: ) throughout this article to make it more clear.\n\nLists can be declared like the following example using a list of strings:\n\n\n\nIn general, data can be added, inserted or removed from the list like the following:\n\nThere are a lot of methods that can be used to find things in lists. Here's a few of the more common ones.\n\n\n\n// The simplest way to find an item // returns null if it's not in the list \"this is not in the list\" // If you want more than one, you can use .Where: // Returns an empty list if it finds nothing // There are also methods like select, which checks whether the item matches // and then returns a bool based on the match. // you can find by index like this: // You cans earch for first or last directly as well // If you don't want it to throw an error for an empty list // There are also several ways to go in the opposite direction: // If you want to find the last occurrence in the list: // There are also binary searches, but these should ONLY be used on sorted lists\n\nYou can sort lists with the method and it's overloads.\n\nFinally, there are options around copying lists:\n\n\n\nThe general list is available via the namespace.\n\nA read-only list, is a list that cannot have items added to it after initialization. It's usually used when data has to be passed to a calling method, but you don't want the calling code to have access to change the list.\n\nAs in the read-only dictionary, a read-only list can be declared like the following:\n\n\n\nYou can also create a read-only collection from a list like the following:\n\n\n\nAt the top level, a linked list works the same way as a generic list. However, it also contains additional methods to place items relative to a position in the list. As a result, if you need to retrieve or add items relative to an item in the list, they work better. Otherwise, it's better to use the normal class.\n\nExamples of some additional methods in a linked list are:\n\n\n\nLinked lists are also available via the namespace.\n\nAn immutable list is a list that returns a new version of the list whenever an item is added or removed. This means that the immutable list is provided you use functionality in C#. However, because the list creates an entirely new list every time items are added or removed, it can provide a performance hit over using a standard list.\n\nImmutable lists are a little strange, in that you don't create them the same way as a normal list as they don't have a public constructor:\n\n\n\nAs I said earlier, add and remove actually create new versions of the immutable list:\n\n\n\nA sorted list is a list that uses the to sort the list. It only supports key-value pairs and can be declared like the following:\n\n\n\nIn the same way that a Dictionary works, you cannot add duplicate keys to the list. However, where it differs is that it sorts lists based on the value. Here's an example of this in action:\n\nSorted lists also live in the namespace.\n\nReally, there's enough variations of stacks and heaps that they require their own article. However, hey still are technically lists as they maintain the order of a collection, just in slightly different ways. It's best to say that stacks and heaps in C# closely implement the stack and heap data structures.\n\nWhile it's outside the scope of this article, a stack is a first-in-last-out data structure.\n\nIf you're used to JavaScript, the syntax should be fairly familiar:\n\n\n\nQueues are essentially the opposite of a stack, in that they are first-in-first-out.\n\nYou can use them like the following:\n\n\n\nBoth the default stack and queue live in the namespace.\n\nAn array is also an ordered list of objects. However, the big difference is that you need to declare how long an array is at initialization:\n\n\n\nArrays are older data structures in C#, and while they are absolutely used within C# (such as a byte array), it's usually preferable to use a list due to the increased flexibility as arrays throw errors if you try to assign values outside the array's length.\n\nArrays are fundamental to the operation of C# and as such live in the namespace.\n\nAn array list is the forerunner to a modern list from the times before C# had generics. As such an array list accepts a list of objects, rather than a generic. This means that you do not benefit from type safety and as such, should be used with caution.\n\nFor example, the following code does not throw errors:\n\n\n\nTag lists are a little strange, in that they are and like the sorted list, accept key-value pairs. However, essentially they're used when you need to optimize for memory usage as they avoid allocating memory when you have 8 or fewer items in the collection. They also accept objects in the value field, rather than generics, meaning that you don't have the advantage of type safety when using them.\n\n\n\nTag lists actually live within the namespace"
    },
    {
        "link": "https://tutorialsteacher.com/csharp/csharp-list",
        "document": "The is a collection of strongly typed objects that can be accessed by index and having methods for sorting, searching, and modifying list. It is the generic version of the ArrayList that comes under namespace.\n• equivalent of the ArrayList, which implements IList<T>.\n• It comes under namespace.\n• can contain elements of the specified type. It provides compile-time type checking and doesn't perform boxing-unboxing because it is generic.\n• Elements can be added using the , methods or collection-initializer syntax.\n• Elements can be accessed by passing an index e.g. . Indexes start from zero.\n• performs faster and less error-prone than the .\n\nThe is a generic collection, so you need to specify a type parameter for the type of data it can store. The following example shows how to create list and add elements.\n\nIn the above example, creates a list of int type. In the same way, and are string type list. You can then add elements in a list using the method or the collection-initializer syntax.\n\nYou can also add elements of the custom classes using the collection-initializer syntax. The following adds objects of the class in the .\n\nUse the method to add all the elements from an array or another collection to List.\n\nA list can be accessed by an index, a for/foreach loop, and using LINQ queries. Indexes of a list start from zero. Pass an index in the square brackets to access individual list items, same as array. Use a or loop to iterate a collection.\n\nThe implements the interface. So, we can query a list using LINQ query syntax or method syntax, as shown below.\n\nUse the method inserts an element into the collection at the specified index.\n\nUse the method to remove the first occurrence of the specified element in the collection. Use the method to remove an element from the specified index. If no element at the specified index, then the will be thrown.\n\nUse the method to determine whether an element is in the or not.\n\nThe following diagram illustrates the hierarchy.\n\nThe following table lists the important properties and methods of class:"
    }
]