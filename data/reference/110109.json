[
    {
        "link": "https://geeksforgeeks.org/python-program-for-quicksort",
        "document": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.\n\nQuickSort works on the principle of divide and conquer, breaking down the problem into smaller sub-problems.\n\nThere are mainly three steps in the algorithm:\n• Choose a Pivot: Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).\n• Partition the Array: Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.\n• Recursively Call: Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).\n• Base Case: The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.\n\nThere are many different versions of quickSort that pick pivot in different ways.\n• None Always pick the first element as a pivot\n• None Always pick the last element as a pivot\n\nHere we will be picking the last element as a pivot. The key process in quickSort is partition(). Target of partitions is, given an array and an element ‘x’ of array as a pivot, put x at its correct position in a sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.\n\nLet us understand the working of partition algorithm with the help of the following example:\n\nTime Complexity: Worst case time complexity is O(N2) and average case time complexity is O(N log N)\n\nAuxiliary Space: O(1)\n\nQuicksort using list comprehension is a recursive algorithm for sorting an array of elements. It works by selecting a pivot element and partitioning the array around the pivot, such that all elements less than the pivot are moved to its left and all elements greater than the pivot are moved to its right. Then, it recursively applies the same process to the left and right sub-arrays until the entire array is sorted.\n\n1.If the input array has length 0 or 1, return the array as it is already sorted.\n\n2.Choose the first element of the array as the pivot element.\n\n3.Create two empty lists, left and right.\n\n4.For each element in the array except for the pivot:\n\na. If the element is smaller than the pivot, add it to the left list.\n\nb. If the element is greater than or equal to the pivot, add it to the right list.\n\n5.Recursively call quicksort on the left and right lists.\n\n6.Concatenate the sorted left list, the pivot element, and the sorted right list.\n\n7.Return the concatenated list.\n\nThe space complexity of the algorithm is O(n)"
    },
    {
        "link": "https://stackoverflow.com/questions/18262306/quicksort-with-python",
        "document": "I do not know how to concatenate the three arrays and print them.\n\nI am totally new to python and I am trying to implement quicksort in it. Could someone please help me complete my code?\n\nThis answer is an in-place QuickSort for . My answer is an interpretation of the in-place solution from Rosetta Code which works for too: import random def qsort(xs, fst, lst): ''' Sort the range xs[fst, lst] in-place with vanilla QuickSort :param xs: the list of numbers to sort :param fst: the first index from xs to begin sorting from, must be in the range [0, len(xs)) :param lst: the last index from xs to stop sorting at must be in the range [fst, len(xs)) :return: nothing, the side effect is that xs[fst, lst] is sorted ''' if fst >= lst: return i, j = fst, lst pivot = xs[random.randint(fst, lst)] while i <= j: while xs[i] < pivot: i += 1 while xs[j] > pivot: j -= 1 if i <= j: xs[i], xs[j] = xs[j], xs[i] i, j = i + 1, j - 1 qsort(xs, fst, j) qsort(xs, i, lst) And if you are willing to forgo the in-place property, below is yet another version which better illustrates the basic ideas behind quicksort. Apart from readability, its other advantage is that it is stable (equal elements appear in the sorted list in the same order that they used to have in the unsorted list). This stability property does not hold with the less memory-hungry in-place implementation presented above. def qsort(xs): if not xs: return xs # empty sequence case pivot = xs[random.choice(range(0, len(xs)))] head = qsort([x for x in xs if x < pivot]) tail = qsort([x for x in xs if x > pivot]) return head + [x for x in xs if x == pivot] + tail\n\nIn real life, we should always use the builtin sort provided by Python. However, understanding the quicksort algorithm is instructive. My goal here is to break down the subject such that it is easily understood and replicable by the reader without having to return to reference materials. The quicksort algorithm is essentially the following:\n• Move all data points less than (below) the pivot to a position below the pivot - move those greater than or equal to (above) the pivot to a position above it.\n• Apply the algorithm to the areas above and below the pivot If the data are randomly distributed, selecting the first data point as the pivot is equivalent to a random selection. First, let's look at a readable example that uses comments and variable names to point to intermediate values: def quicksort(xs): \"\"\"Given indexable and slicable iterable, return a sorted list\"\"\" if xs: # if given list (or tuple) with one ordered item or more: pivot = xs[0] # below will be less than: below = [i for i in xs[1:] if i < pivot] # above will be greater than or equal to: above = [i for i in xs[1:] if i >= pivot] return quicksort(below) + [pivot] + quicksort(above) else: return xs # empty list To restate the algorithm and code demonstrated here - we move values above the pivot to the right, and values below the pivot to the left, and then pass those partitions to same function to be further sorted. This can be golfed to 88 characters: q=lambda x:x and q([i for i in x[1:]if i<=x[0]])+[x[0]]+q([i for i in x[1:]if i>x[0]]) To see how we get there, first take our readable example, remove comments and docstrings, and find the pivot in-place: def quicksort(xs): if xs: below = [i for i in xs[1:] if i < xs[0]] above = [i for i in xs[1:] if i >= xs[0]] return quicksort(below) + [xs[0]] + quicksort(above) else: return xs Now find below and above, in-place: def quicksort(xs): if xs: return (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) else: return xs Now, knowing that returns the prior element if false, else if it is true, it evaluates and returns the following element, we have: def quicksort(xs): return xs and (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) Since lambdas return a single epression, and we have simplified to a single expression (even though it is getting more unreadable) we can now use a lambda: quicksort = lambda xs: (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) And to reduce to our example, shorten the function and variable names to one letter, and eliminate the whitespace that isn't required. q=lambda x:x and q([i for i in x[1:]if i<=x[0]])+[x[0]]+q([i for i in x[1:]if i>x[0]]) Note that this lambda, like most code golfing, is rather bad style. The prior implementation creates a lot of unnecessary extra lists. If we can do this in-place, we'll avoid wasting space. The below implementation uses the Hoare partitioning scheme, which you can read more about on wikipedia (but we have apparently removed up to 4 redundant calculations per call by using while-loop semantics instead of do-while and moving the narrowing steps to the end of the outer while loop.). def quicksort(a_list): \"\"\"Hoare partition scheme, see https://en.wikipedia.org/wiki/Quicksort\"\"\" def _quicksort(a_list, low, high): # must run partition on sections with 2 elements or more if low < high: p = partition(a_list, low, high) _quicksort(a_list, low, p) _quicksort(a_list, p+1, high) def partition(a_list, low, high): pivot = a_list[low] while True: while a_list[low] < pivot: low += 1 while a_list[high] > pivot: high -= 1 if low >= high: return high a_list[low], a_list[high] = a_list[high], a_list[low] low += 1 high -= 1 _quicksort(a_list, 0, len(a_list)-1) return a_list Not sure if I tested it thoroughly enough: This algorithm is frequently taught in computer science courses and asked for on job interviews. It helps us think about recursion and divide-and-conquer. Quicksort is not very practical in Python since our builtin timsort algorithm is quite efficient, and we have recursion limits. We would expect to sort lists in-place with or create new sorted lists with - both of which take a and argument.\n\nI think both answers here works ok for the list provided (which answer the original question), but would breaks if an array containing non unique values is passed. So for completeness, I would just point out the small error in each and explain how to fix them. For example trying to sort the following array [12,4,5,6,7,3,1,15,1] (Note that 1 appears twice) with Brionius algorithm .. at some point will end up with the less array empty and the equal array with a pair of values (1,1) that can not be separated in the next iteration and the len() > 1...hence you'll end up with an infinite loop You can fix it by either returning array if less is empty or better by not calling sort in your equal array, as in zangw answer def sort(array=[12,4,5,6,7,3,1,15]): less = [] equal = [] greater = [] if len(array) > 1: pivot = array[0] for x in array: if x < pivot: less.append(x) elif x == pivot: equal.append(x) else: # if x > pivot greater.append(x) # Don't forget to return something! return sort(less) + equal + sort(greater) # Just use the + operator to join lists # Note that you want equal ^^^^^ not pivot else: # You need to hande the part at the end of the recursion - when you only have one element in your array, just return the array. return array The fancier solution also breaks, but for a different cause, it is missing the return clause in the recursion line, which will cause at some point to return None and try to append it to a list .... To fix it just add a return to that line def qsort(arr): if len(arr) <= 1: return arr else: return qsort([x for x in arr[1:] if x<arr[0]]) + [arr[0]] + qsort([x for x in arr[1:] if x>=arr[0]])\n\nThe algorithm contains two boundaries, one having elements less than the pivot (tracked by index \"j\") and the other having elements greater than the pivot (tracked by index \"i\"). In each iteration, a new element is processed by incrementing j.\n• all elements between pivot and i are less than the pivot, and\n• all elements between i and j are greater than the pivot. If the invariant is violated, ith and jth elements are swapped, and i is incremented. After all elements have been processed, and everything after the pivot has been partitioned, the pivot element is swapped with the last element smaller than it. The pivot element will now be in its correct place in the sequence. The elements before it will be less than it and the ones after it will be greater than it, and they will be unsorted. def quicksort(sequence, low, high): if low < high: pivot = partition(sequence, low, high) quicksort(sequence, low, pivot - 1) quicksort(sequence, pivot + 1, high) def partition(sequence, low, high): pivot = sequence[low] i = low + 1 for j in range(low + 1, high + 1): if sequence[j] < pivot: sequence[j], sequence[i] = sequence[i], sequence[j] i += 1 sequence[i-1], sequence[low] = sequence[low], sequence[i-1] return i - 1 def main(sequence): quicksort(sequence, 0, len(sequence) - 1) return sequence if __name__ == '__main__': sequence = [-2, 0, 32, 1, 56, 99, -4] print(main(sequence)) A \"good\" pivot will result in two sub-sequences of roughly the same size. Deterministically, a pivot element can either be selected in a naive manner or by computing the median of the sequence. A naive implementation of selecting a pivot will be the first or last element. The worst-case runtime in this case will be when the input sequence is already sorted or reverse sorted, as one of the subsequences will be empty which will cause only one element to be removed per recursive call. A perfectly balanced split is achieved when the pivot is the median element of the sequence. There are an equal number of elements greater than it and less than it. This approach guarantees a better overall running time, but is much more time-consuming. A non-deterministic/random way of selecting the pivot would be to pick an element uniformly at random. This is a simple and lightweight approach that will minimize worst-case scenario and also lead to a roughly balanced split. This will also provide a balance between the naive approach and the median approach of selecting the pivot.\n\nMy answer is very similar to the great one from @alisianoi . However, I believe there is a slight inefficiency in his code (see my comment), which I removed. Moreover, I added more explanation and was a bit more specific about the problem of duplicate (pivot) values. def quicksort(nums, begin=0, end=None): # Only at the beginning end=None. In this case set to len(nums)-1 if end is None: end = len(nums) - 1 # If list part is invalid or has only 1 element, do nothing if begin>=end: return # Pick random pivot pivot = nums[random.randint(begin, end)] # Initialize left and right pointers left, right = begin, end while left < right: # Find first \"wrong\" value from left hand side, i.e. first value >= pivot # Find first \"wrong\" value from right hand side, i.e. first value <= pivot # Note: In the LAST while loop, both left and right will point to pivot! while nums[left] < pivot: left += 1 while nums[right] > pivot: right -= 1 # Swap the \"wrong\" values if left != right: nums[left], nums[right] = nums[right], nums[left] # Problem: loop can get stuck if pivot value exists more than once. Simply solve with... if nums[left] == nums[right]: assert nums[left]==pivot left += 1 # Now, left and right both point to a pivot value. # All values to its left are smaller (or equal in case of duplicate pivot values) # All values to its right are larger. assert left == right and nums[left] == pivot quicksort(nums, begin, left - 1) quicksort(nums, left + 1, end) return def quicksort(nums, ranges=None): if ranges is None: ranges = [[0, len(nums) - 1]] while ranges != []: [start, end] = ranges[0] ranges = ranges[1:] if start >= end: continue pivot = nums[randint(start, end)] left = start right = end while left < right: while nums[left] < pivot: left += 1 while nums[right] > pivot: right -= 1 if left != right: nums[left], nums[right] = nums[right], nums[left] if nums[left] == nums[right]: left += 1 ranges = [[start, left - 1], [left + 1, end]] + ranges\n\ndef is_sorted(arr): #check if array is sorted for i in range(len(arr) - 2): if arr[i] > arr[i + 1]: return False return True def qsort_in_place(arr, left, right): #arr - given array, #left - first element index, #right - last element index if right - left < 1: #if we have empty or one element array - nothing to do return else: left_point = left #set left pointer that points on element that is candidate to swap with element under right pointer or pivot element right_point = right - 1 #set right pointer that is candidate to swap with element under left pointer while left_point <= right_point: #while we have not checked all elements in the given array swap_left = arr[left_point] >= arr[right] #True if we have to move that element after pivot swap_right = arr[right_point] < arr[right] #True if we have to move that element before pivot if swap_left and swap_right: #if both True we can swap elements under left and right pointers arr[right_point], arr[left_point] = arr[left_point], arr[right_point] left_point += 1 right_point -= 1 else: #if only one True we don`t have place for to swap it if not swap_left: #if we dont need to swap it we move to next element left_point += 1 if not swap_right: #if we dont need to swap it we move to prev element right_point -= 1 arr[left_point], arr[right] = arr[right], arr[left_point] #swap left element with pivot qsort_in_place(arr, left, left_point - 1) #execute qsort for left part of array (elements less than pivot) qsort_in_place(arr, left_point + 1, right) #execute qsort for right part of array (elements most than pivot) def main(): import random arr = random.sample(range(1, 4000), 10) #generate random array print(arr) print(is_sorted(arr)) qsort_in_place(arr, 0, len(arr) - 1) print(arr) print(is_sorted(arr)) if __name__ == \"__main__\": main()"
    },
    {
        "link": "https://llego.dev/posts/implementing-quicksort-python-step-step-guide",
        "document": "Quicksort is one of the most efficient sorting algorithms and is based on the divide-and-conquer approach. It was developed by Tony Hoare in 1959 and is still commonly used today.\n\nIn this comprehensive guide, we will cover the following:\n\nQuicksort is based on the divide-and-conquer approach for sorting an array. It works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. This continues until the base case of empty or single-element arrays is reached, which are inherently sorted.\n\nThe steps for quicksort are:\n• Partition the array into two sub-arrays based on the pivot\n• Can be slower than other sorts for small arrays\n\nThese characteristics make quicksort very fast for a variety of applications from sorting user data to complex machine learning algorithms.\n\nLet’s now go through a step-by-step implementation of the quicksort algorithm in Python.\n\nThere are different ways to choose the pivot:\n• Always pick first, last, or random element\n• Pick median of first, middle and last elements\n\nFor simplicity, we will start with always picking the last element as the pivot:\n\nThis involves iterating through the array and swapping elements such that those less than the pivot are placed before elements greater than the pivot.\n\nWe will use a pointer that increments left to right, while swapping elements less than the pivot to the front of the array.\n\nThe final swap places the pivot element between the two partitions.\n\nWe simply call quicksort recursively on the slices from 0 to i-1 (left partition) and i+1 to the end (right partition).\n\nPutting it all together, the full quicksort implementation is:\n\nWe added a base case to handle empty or single-element arrays to avoid infinite recursion.\n\nLet’s test it on an example array:\n\nChoosing the final element as pivot is simple but not optimal. Better alternatives include:\n\nPick median of first, middle and last elements as pivot:\n\nThis reduces the chance of imbalanced partitions.\n\nSelect a random index between 0 and length-1 as the pivot:\n\nRandomness improves performance on already sorted or reversed arrays.\n\nFor partitioning, instead of swapping, we can keep track of the boundary point and only swap once. This reduces expensive swap operations.\n• Best case: O(n log n) - pivot divides array into equal halves\n\nQuicksort is very efficient on average. But worst-case occurs with poor pivots.\n\nSome optimizations to further improve quicksort:\n\nThese optimizations make quicksort faster and more robust in different scenarios.\n\nMerge has better worst-case but requires more space. Useful if stability is needed.\n\nIntrosort combines advantages of both quicksort and heapsort.\n\nSo quicksort is preferred in most cases, but alternatives have tradeoffs to consider.\n\nQuicksort is extensively used due to its excellent performance:\n\nIt’s one of the most popular sorting algorithms used in practice across domains.\n\nSome practice questions to test your quicksort skills:\n• Track the number of comparisons and swaps your quicksort algorithm makes.\n\nIn this comprehensive guide, we implemented quicksort in Python from scratch, discussed key concepts like pivot selection and partitioning schemes, analyzed complexity, compared tradeoffs with other sorts, saw real-world applications, and worked through examples.\n\nQuicksort is one of the fastest sorting algorithms due to its excellent divide-and-conquer approach. With some careful optimizations, it can be made even faster and adaptable for all kinds of sorting problems. Understanding quicksort provides a solid foundation in algorithmic thinking that is applicable across technical domains.\n\nThe implementation techniques, analysis, optimizations and examples covered in this guide will help prepare you for technical interviews. Quicksort remains a popular interview topic and being thorough with its concepts will give you an edge.\n\nThere are always opportunities to enhance the quicksort algorithm further through multi-threading, cache optimizations, hybrid schemes and more. I hope this guide provided a comprehensive overview and starting point for mastering quicksort in Python."
    },
    {
        "link": "https://scienceforums.net/topic/132087-optimizing-quick-sort-algorithm-for-efficiency-and-best-practices",
        "document": "I am currently working on implementing the Quick Sort algorithm in Python, and while my code seems to work correctly, I am eager to optimize it for better performance and adhere to best practices.\n\nI would appreciate insights from the community on how to fine-tune my Quick Sort implementation to make it more efficient, especially when dealing with large datasets. Are there specific techniques, pivot selection strategies, or partitioning schemes that are recommended for faster sorting?\n\nAdditionally, I would like to know how to handle edge cases and prevent potential issues like stack overflow during recursion, especially when dealing with arrays that are nearly sorted or already sorted.\n\nIn this implementation, the _quick_sort function handles the recursive sorting, while the partition function rearranges the elements around the pivot using the Lomuto partition scheme. We use the random pivot selection strategy to avoid worst-case scenarios and improve average performance.\n\nIt is worth mentioning that even with these optimizations, Quick Sort's worst-case time complexity is O(n^2) for an already sorted or nearly sorted array. However, the random pivot selection helps to mitigate this issue in practice, making Quick Sort generally efficient and widely used in many sorting applications.\n\nFor my initial understanding of the subject, I have been using articles on Scaler's Quick Sort Algorithm, but I'm open to suggestions and code samples that show how to optimize the Quick Sort algorithm in Python while maintaining its correctness and making sure it operates robustly in a variety of scenarios. Thank you for your valuable expertise and time!"
    },
    {
        "link": "https://vmlogger.medium.com/quick-sort-understanding-and-implementing-in-python-419f4ed3c4f2",
        "document": "Among the various sorting algorithms available, Quick Sort stands out as one of the most efficient and widely used sorting algorithms. However, it can offer a worst-case-time complexity as but it offers a best and average-case time complexity of and performs exceptionally well in practice.\n\nOverall, it is slightly faster than merge sort and heapsort for randomized data, particularly on larger distributions.[3]\n\nIn this article, we will dive into the details of the Quick Sort algorithm, understand its workings, and implement it in Python.\n\nSimilar to merge sort, quick sort is also based on the divide-and-conquer algorithm principle. It was developed by British computer scientist Tony Hoare in 1959. The algorithm’s core idea is to partition the input array into two sub-arrays, where one sub-array contains elements smaller than a chosen pivot, and the other sub-array contains elements greater than the pivot.\n\nThis process is repeated recursively on the sub-arrays until the entire array is sorted. This is the reason, why quick sort is also known as the partition-exchange sorting algorithm.\n\nThe key steps involved in the Quick Sort algorithm are as follows:\n• Choose a pivot element from the array. Rearrange the array in such a way that all elements smaller than the pivot are placed before it, and all elements greater than the pivot are placed after it. The pivot element is now in its correct sorted position.\n• Apply the partitioning step recursively to the sub-arrays formed on the left and right sides of the pivot until the entire array is sorted. This process is known as the divide-and-conquer approach.\n• Since the recursion splits the array into smaller sub-arrays, no explicit combining step is necessary. The elements are automatically combined as the recursion unwinds.\n\nThe partitioning process plays a crucial role in Quick Sort. It determines the pivot element’s correct sorted position and rearranges the array accordingly. Several approaches exist for selecting the pivot, but the most commonly used one is the\n\nThe involves the following steps:\n• Choose the rightmost element of the array as the pivot.\n• Initialise a variable to keep track of the index where elements smaller than the pivot will be placed. Initially, set i to the first element’s index, which is .\n• Iterate through the array from the leftmost element to the second-to-last element.\n• For each element encountered, compare it with the pivot element. If it is smaller, swap it with the element at the index and increment by 1. This ensures that all smaller elements are placed before the pivot.\n• After the iteration completes, swap the pivot element with the element at the index . Now, the pivot element is in its final sorted position.\n• At this point, all elements to the left of the pivot (indices less than ) are smaller than the pivot, and all elements to the right of the pivot (indices greater than ) are larger than the pivot. This partitioning step ensures that the pivot element is in its correct sorted position while dividing the array into two sub-arrays for further recursion.\n\nNow that we have a good understanding of the Quick Sort algorithm let’s proceed to implement it in Python. Here’s the Python code for Quick Sort using the Lomuto partition scheme:\n\nExplanation of the above code:\n\nThe quick_sort function takes an array arr as input and recursively performs the Quick Sort algorithm. The base case is when the array has one or fewer elements, in which case it is already sorted.\n\nThe pivot is chosen as the last element of the array \n\nThree additional lists, are initialized to store elements smaller than the pivot, elements equal to the pivot, and elements larger than the pivot, respectively.\n\nThe for loop iterates through the array, comparing each element with the pivot and appending it to the corresponding list. Finally, the function recursively calls itself on the smaller and larger lists and combines the sorted results along with the equal list. Refer to the last statement which is the statement.\n\nQuick Sort is a highly efficient sorting algorithm with an average-case time complexity of O(n log n). By cleverly choosing a pivot element and applying the divide-and-conquer approach, Quick Sort achieves fast sorting performance in practice. In this article, we explored the inner workings of the Quick Sort algorithm and implemented it in Python using the Lomuto partition scheme. Feel free to experiment with different pivot selection strategies and partitioning schemes to further enhance your understanding of this powerful sorting algorithm."
    },
    {
        "link": "https://stackoverflow.com/questions/20175380/quick-sort-python-recursion",
        "document": "This will also reverse sort. It uses one pass through the partial array to set left[], pivot[] and right[]. It does use arr[0] as a pivot. Many like mid or random pivots. Change it if you want. I used a single ternary operation to append to the correct list. On my machine it sorts 250,000 element list in about 2 seconds.\n\nHere is the code:\n\nHere it is with pivot in the middle. Notice the big change ;-)"
    },
    {
        "link": "https://geeksforgeeks.org/python-program-for-quicksort",
        "document": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.\n\nQuickSort works on the principle of divide and conquer, breaking down the problem into smaller sub-problems.\n\nThere are mainly three steps in the algorithm:\n• Choose a Pivot: Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).\n• Partition the Array: Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.\n• Recursively Call: Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).\n• Base Case: The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.\n\nThere are many different versions of quickSort that pick pivot in different ways.\n• None Always pick the first element as a pivot\n• None Always pick the last element as a pivot\n\nHere we will be picking the last element as a pivot. The key process in quickSort is partition(). Target of partitions is, given an array and an element ‘x’ of array as a pivot, put x at its correct position in a sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.\n\nLet us understand the working of partition algorithm with the help of the following example:\n\nTime Complexity: Worst case time complexity is O(N2) and average case time complexity is O(N log N)\n\nAuxiliary Space: O(1)\n\nQuicksort using list comprehension is a recursive algorithm for sorting an array of elements. It works by selecting a pivot element and partitioning the array around the pivot, such that all elements less than the pivot are moved to its left and all elements greater than the pivot are moved to its right. Then, it recursively applies the same process to the left and right sub-arrays until the entire array is sorted.\n\n1.If the input array has length 0 or 1, return the array as it is already sorted.\n\n2.Choose the first element of the array as the pivot element.\n\n3.Create two empty lists, left and right.\n\n4.For each element in the array except for the pivot:\n\na. If the element is smaller than the pivot, add it to the left list.\n\nb. If the element is greater than or equal to the pivot, add it to the right list.\n\n5.Recursively call quicksort on the left and right lists.\n\n6.Concatenate the sorted left list, the pivot element, and the sorted right list.\n\n7.Return the concatenated list.\n\nThe space complexity of the algorithm is O(n)"
    },
    {
        "link": "https://geeksforgeeks.org/quick-sort-algorithm",
        "document": "QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.\n\nQuickSort works on the principle of divide and conquer, breaking down the problem into smaller sub-problems.\n\nThere are mainly three steps in the algorithm:\n• Choose a Pivot: Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).\n• Partition the Array: Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.\n• Recursively Call: Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).\n• Base Case: The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.\n\nHere’s a basic overview of how the QuickSort algorithm works.\n\nThere are many different choices for picking pivots.\n• None Always pick the first (or last) element as a pivot . The below implementation picks the last element as pivot. The problem with this approach is it ends up in the worst case when array is already sorted.\n• None . This is a preferred approach because it does not have a pattern for which the worst case happens.\n• None Pick the median element is pivot. This is an ideal approach in terms of time complexity as we can find median in linear time and the partition function will always divide the input array into two halves. But it takes more time on average as median finding has high constants.\n\nThe key process in quickSort is a partition(). There are three common algorithms to partition. All these algorithms have O(n) time complexity.\n• Naive Partition : Here we create copy of the array. First put all smaller elements and then all greater. Finally we copy the temporary array back to original array. This requires O(n) extra space.\n• Lomuto Partition : We have used this partition in this article. This is a simple algorithm, we keep track of index of smaller elements and keep swapping. We have used it here in this article because of its simplicity.\n• Hoare’s Partition : This is the fastest of all. Here we traverse array from both sides and keep swapping greater element on left with smaller on right while the array is not partitioned. Please refer\n\nLet us understand the working of partition algorithm with the help of the following example:\n\nIn the previous step, we looked at how the partitioning process rearranges the array based on the chosen pivot. Next, we apply the same method recursively to the smaller sub-arrays on the left and right of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted.\n\nBelow image illustrates, how the recursive method calls for the smaller sub-arrays on the left and right of the pivot:\n\nQuick Sort is a crucial algorithm in the industry, but there are other sorting algorithms that may be more optimal in different cases.\n\n// Index of smaller element and indicates // the right position of pivot found so far // elements on left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot # Index of smaller element and indicates # the right position of pivot found so far # elements to the left side. Elements from low to # i are smaller after every iteration # pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot // Index of smaller element and indicates // the right position of pivot found so far // elements to the left side. Elements from low to // i are smaller after every iteration // pi is the partition return index of pivot\n• Best Case: (Ω(n log n)), Occurs when the pivot element divides the array into two equal halves.\n• Average Case (θ(n log n)), On average, the pivot divides the array into two parts, but not necessarily equal.\n• Worst Case: (O(n²)), Occurs when the smallest or largest element is always chosen as the pivot (e.g., sorted arrays).\n\nPlease refer Time and Space Complexity Analysis of Quick Sort for more details.\n• None It is a divide-and-conquer algorithm that makes it easier to solve problems.\n• None It is efficient on large data sets.\n• None It has a low overhead, as it only requires a small amount of memory to function.\n• None It is Cache Friendly as we work on the same array to sort and do not copy data to any auxiliary array.\n• None Fastest general purpose algorithm for large data when stability is not required.\n• tail recursive and hence all the can be done.\n• None It has a worst-case time complexity of O(n ), which occurs when the pivot is chosen poorly.\n• None It is not a good choice for small data sets.\n• None It is not a stable sort, meaning that if two elements have the same key, their relative order will not be preserved in the sorted output in case of quick sort, because here we are swapping elements according to the pivot’s position (without considering their original positions).\n• None Efficient for sorting large datasets with O(n log n) average-case time complexity.\n• None Used in partitioning problems like finding the kth smallest element or dividing arrays by pivot.\n• None Integral to randomized algorithms, offering better performance than deterministic approaches.\n• None Applied in cryptography for generating random permutations and unpredictable encryption keys.\n• None Partitioning step can be parallelized for improved performance in multi-core or distributed systems.\n• None Important in theoretical computer science for analyzing average-case complexity and developing new techniques.\n\nPlease refer Application of Quicksort for more details."
    },
    {
        "link": "https://stackoverflow.com/questions/18262306/quicksort-with-python",
        "document": "I do not know how to concatenate the three arrays and print them.\n\nI am totally new to python and I am trying to implement quicksort in it. Could someone please help me complete my code?\n\nThis answer is an in-place QuickSort for . My answer is an interpretation of the in-place solution from Rosetta Code which works for too: import random def qsort(xs, fst, lst): ''' Sort the range xs[fst, lst] in-place with vanilla QuickSort :param xs: the list of numbers to sort :param fst: the first index from xs to begin sorting from, must be in the range [0, len(xs)) :param lst: the last index from xs to stop sorting at must be in the range [fst, len(xs)) :return: nothing, the side effect is that xs[fst, lst] is sorted ''' if fst >= lst: return i, j = fst, lst pivot = xs[random.randint(fst, lst)] while i <= j: while xs[i] < pivot: i += 1 while xs[j] > pivot: j -= 1 if i <= j: xs[i], xs[j] = xs[j], xs[i] i, j = i + 1, j - 1 qsort(xs, fst, j) qsort(xs, i, lst) And if you are willing to forgo the in-place property, below is yet another version which better illustrates the basic ideas behind quicksort. Apart from readability, its other advantage is that it is stable (equal elements appear in the sorted list in the same order that they used to have in the unsorted list). This stability property does not hold with the less memory-hungry in-place implementation presented above. def qsort(xs): if not xs: return xs # empty sequence case pivot = xs[random.choice(range(0, len(xs)))] head = qsort([x for x in xs if x < pivot]) tail = qsort([x for x in xs if x > pivot]) return head + [x for x in xs if x == pivot] + tail\n\nIn real life, we should always use the builtin sort provided by Python. However, understanding the quicksort algorithm is instructive. My goal here is to break down the subject such that it is easily understood and replicable by the reader without having to return to reference materials. The quicksort algorithm is essentially the following:\n• Move all data points less than (below) the pivot to a position below the pivot - move those greater than or equal to (above) the pivot to a position above it.\n• Apply the algorithm to the areas above and below the pivot If the data are randomly distributed, selecting the first data point as the pivot is equivalent to a random selection. First, let's look at a readable example that uses comments and variable names to point to intermediate values: def quicksort(xs): \"\"\"Given indexable and slicable iterable, return a sorted list\"\"\" if xs: # if given list (or tuple) with one ordered item or more: pivot = xs[0] # below will be less than: below = [i for i in xs[1:] if i < pivot] # above will be greater than or equal to: above = [i for i in xs[1:] if i >= pivot] return quicksort(below) + [pivot] + quicksort(above) else: return xs # empty list To restate the algorithm and code demonstrated here - we move values above the pivot to the right, and values below the pivot to the left, and then pass those partitions to same function to be further sorted. This can be golfed to 88 characters: q=lambda x:x and q([i for i in x[1:]if i<=x[0]])+[x[0]]+q([i for i in x[1:]if i>x[0]]) To see how we get there, first take our readable example, remove comments and docstrings, and find the pivot in-place: def quicksort(xs): if xs: below = [i for i in xs[1:] if i < xs[0]] above = [i for i in xs[1:] if i >= xs[0]] return quicksort(below) + [xs[0]] + quicksort(above) else: return xs Now find below and above, in-place: def quicksort(xs): if xs: return (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) else: return xs Now, knowing that returns the prior element if false, else if it is true, it evaluates and returns the following element, we have: def quicksort(xs): return xs and (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) Since lambdas return a single epression, and we have simplified to a single expression (even though it is getting more unreadable) we can now use a lambda: quicksort = lambda xs: (quicksort([i for i in xs[1:] if i < xs[0]] ) + [xs[0]] + quicksort([i for i in xs[1:] if i >= xs[0]])) And to reduce to our example, shorten the function and variable names to one letter, and eliminate the whitespace that isn't required. q=lambda x:x and q([i for i in x[1:]if i<=x[0]])+[x[0]]+q([i for i in x[1:]if i>x[0]]) Note that this lambda, like most code golfing, is rather bad style. The prior implementation creates a lot of unnecessary extra lists. If we can do this in-place, we'll avoid wasting space. The below implementation uses the Hoare partitioning scheme, which you can read more about on wikipedia (but we have apparently removed up to 4 redundant calculations per call by using while-loop semantics instead of do-while and moving the narrowing steps to the end of the outer while loop.). def quicksort(a_list): \"\"\"Hoare partition scheme, see https://en.wikipedia.org/wiki/Quicksort\"\"\" def _quicksort(a_list, low, high): # must run partition on sections with 2 elements or more if low < high: p = partition(a_list, low, high) _quicksort(a_list, low, p) _quicksort(a_list, p+1, high) def partition(a_list, low, high): pivot = a_list[low] while True: while a_list[low] < pivot: low += 1 while a_list[high] > pivot: high -= 1 if low >= high: return high a_list[low], a_list[high] = a_list[high], a_list[low] low += 1 high -= 1 _quicksort(a_list, 0, len(a_list)-1) return a_list Not sure if I tested it thoroughly enough: This algorithm is frequently taught in computer science courses and asked for on job interviews. It helps us think about recursion and divide-and-conquer. Quicksort is not very practical in Python since our builtin timsort algorithm is quite efficient, and we have recursion limits. We would expect to sort lists in-place with or create new sorted lists with - both of which take a and argument.\n\nI think both answers here works ok for the list provided (which answer the original question), but would breaks if an array containing non unique values is passed. So for completeness, I would just point out the small error in each and explain how to fix them. For example trying to sort the following array [12,4,5,6,7,3,1,15,1] (Note that 1 appears twice) with Brionius algorithm .. at some point will end up with the less array empty and the equal array with a pair of values (1,1) that can not be separated in the next iteration and the len() > 1...hence you'll end up with an infinite loop You can fix it by either returning array if less is empty or better by not calling sort in your equal array, as in zangw answer def sort(array=[12,4,5,6,7,3,1,15]): less = [] equal = [] greater = [] if len(array) > 1: pivot = array[0] for x in array: if x < pivot: less.append(x) elif x == pivot: equal.append(x) else: # if x > pivot greater.append(x) # Don't forget to return something! return sort(less) + equal + sort(greater) # Just use the + operator to join lists # Note that you want equal ^^^^^ not pivot else: # You need to hande the part at the end of the recursion - when you only have one element in your array, just return the array. return array The fancier solution also breaks, but for a different cause, it is missing the return clause in the recursion line, which will cause at some point to return None and try to append it to a list .... To fix it just add a return to that line def qsort(arr): if len(arr) <= 1: return arr else: return qsort([x for x in arr[1:] if x<arr[0]]) + [arr[0]] + qsort([x for x in arr[1:] if x>=arr[0]])\n\nThe algorithm contains two boundaries, one having elements less than the pivot (tracked by index \"j\") and the other having elements greater than the pivot (tracked by index \"i\"). In each iteration, a new element is processed by incrementing j.\n• all elements between pivot and i are less than the pivot, and\n• all elements between i and j are greater than the pivot. If the invariant is violated, ith and jth elements are swapped, and i is incremented. After all elements have been processed, and everything after the pivot has been partitioned, the pivot element is swapped with the last element smaller than it. The pivot element will now be in its correct place in the sequence. The elements before it will be less than it and the ones after it will be greater than it, and they will be unsorted. def quicksort(sequence, low, high): if low < high: pivot = partition(sequence, low, high) quicksort(sequence, low, pivot - 1) quicksort(sequence, pivot + 1, high) def partition(sequence, low, high): pivot = sequence[low] i = low + 1 for j in range(low + 1, high + 1): if sequence[j] < pivot: sequence[j], sequence[i] = sequence[i], sequence[j] i += 1 sequence[i-1], sequence[low] = sequence[low], sequence[i-1] return i - 1 def main(sequence): quicksort(sequence, 0, len(sequence) - 1) return sequence if __name__ == '__main__': sequence = [-2, 0, 32, 1, 56, 99, -4] print(main(sequence)) A \"good\" pivot will result in two sub-sequences of roughly the same size. Deterministically, a pivot element can either be selected in a naive manner or by computing the median of the sequence. A naive implementation of selecting a pivot will be the first or last element. The worst-case runtime in this case will be when the input sequence is already sorted or reverse sorted, as one of the subsequences will be empty which will cause only one element to be removed per recursive call. A perfectly balanced split is achieved when the pivot is the median element of the sequence. There are an equal number of elements greater than it and less than it. This approach guarantees a better overall running time, but is much more time-consuming. A non-deterministic/random way of selecting the pivot would be to pick an element uniformly at random. This is a simple and lightweight approach that will minimize worst-case scenario and also lead to a roughly balanced split. This will also provide a balance between the naive approach and the median approach of selecting the pivot.\n\nMy answer is very similar to the great one from @alisianoi . However, I believe there is a slight inefficiency in his code (see my comment), which I removed. Moreover, I added more explanation and was a bit more specific about the problem of duplicate (pivot) values. def quicksort(nums, begin=0, end=None): # Only at the beginning end=None. In this case set to len(nums)-1 if end is None: end = len(nums) - 1 # If list part is invalid or has only 1 element, do nothing if begin>=end: return # Pick random pivot pivot = nums[random.randint(begin, end)] # Initialize left and right pointers left, right = begin, end while left < right: # Find first \"wrong\" value from left hand side, i.e. first value >= pivot # Find first \"wrong\" value from right hand side, i.e. first value <= pivot # Note: In the LAST while loop, both left and right will point to pivot! while nums[left] < pivot: left += 1 while nums[right] > pivot: right -= 1 # Swap the \"wrong\" values if left != right: nums[left], nums[right] = nums[right], nums[left] # Problem: loop can get stuck if pivot value exists more than once. Simply solve with... if nums[left] == nums[right]: assert nums[left]==pivot left += 1 # Now, left and right both point to a pivot value. # All values to its left are smaller (or equal in case of duplicate pivot values) # All values to its right are larger. assert left == right and nums[left] == pivot quicksort(nums, begin, left - 1) quicksort(nums, left + 1, end) return def quicksort(nums, ranges=None): if ranges is None: ranges = [[0, len(nums) - 1]] while ranges != []: [start, end] = ranges[0] ranges = ranges[1:] if start >= end: continue pivot = nums[randint(start, end)] left = start right = end while left < right: while nums[left] < pivot: left += 1 while nums[right] > pivot: right -= 1 if left != right: nums[left], nums[right] = nums[right], nums[left] if nums[left] == nums[right]: left += 1 ranges = [[start, left - 1], [left + 1, end]] + ranges\n\ndef is_sorted(arr): #check if array is sorted for i in range(len(arr) - 2): if arr[i] > arr[i + 1]: return False return True def qsort_in_place(arr, left, right): #arr - given array, #left - first element index, #right - last element index if right - left < 1: #if we have empty or one element array - nothing to do return else: left_point = left #set left pointer that points on element that is candidate to swap with element under right pointer or pivot element right_point = right - 1 #set right pointer that is candidate to swap with element under left pointer while left_point <= right_point: #while we have not checked all elements in the given array swap_left = arr[left_point] >= arr[right] #True if we have to move that element after pivot swap_right = arr[right_point] < arr[right] #True if we have to move that element before pivot if swap_left and swap_right: #if both True we can swap elements under left and right pointers arr[right_point], arr[left_point] = arr[left_point], arr[right_point] left_point += 1 right_point -= 1 else: #if only one True we don`t have place for to swap it if not swap_left: #if we dont need to swap it we move to next element left_point += 1 if not swap_right: #if we dont need to swap it we move to prev element right_point -= 1 arr[left_point], arr[right] = arr[right], arr[left_point] #swap left element with pivot qsort_in_place(arr, left, left_point - 1) #execute qsort for left part of array (elements less than pivot) qsort_in_place(arr, left_point + 1, right) #execute qsort for right part of array (elements most than pivot) def main(): import random arr = random.sample(range(1, 4000), 10) #generate random array print(arr) print(is_sorted(arr)) qsort_in_place(arr, 0, len(arr) - 1) print(arr) print(is_sorted(arr)) if __name__ == \"__main__\": main()"
    },
    {
        "link": "https://w3resource.com/python-exercises/data-structures-and-algorithms/python-search-and-sorting-exercise-28.php",
        "document": "Quicksort is a divide and conquer algorithm. It first divides the input array into two smaller sub-arrays: the low elements and the high elements. It then recursively sorts the sub-arrays.\n\nContribute your code and comments through Disqus.\n\nPrevious: Write a Python program to sort unsorted numbers using Stooge sort.\n\n Next: Write a Python program to sort a given collection of numbers and its length in ascending order using Recursive Insertion Sort."
    }
]