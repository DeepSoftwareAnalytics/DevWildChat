[
    {
        "link": "https://stackoverflow.com/questions/183589/best-practice-for-exception-handling-in-a-windows-forms-application",
        "document": "The main things I'm currently trying to work out are:\n\nWould anyone like to share any pearls of wisdom on the subject? Post any common mistakes you've seen newbies like myself make, and any general advice on handling exceptions in a way that will my application more stable and robust.\n\nI'm currently in the process of writing my first Windows Forms application. I've read a few C# books now so I've got a relatively good understanding of what language features C# has to deal with exceptions. They're all quite theoretical however so what I haven't got yet is a feel for how to translate the basic concepts into a good exception-handling model in my application.\n\nYou absolutely should have a centralized exception handling policy in place. This can be as simple as wrapping in a try/catch, failing fast with a graceful error message to the user. This is the \"last resort\" exception handler. Preemptive checks are always correct if feasible, but not always perfect. For example, between the code where you check for a file's existence and the next line where you open it, the file could have been deleted or some other issue may impede your access. You still need try/catch/finally in that world. Use both the preemptive check and the try/catch/finally as appropriate. Never \"swallow\" an exception, except in the most well-documented cases when you are absolutely, positively sure that the exception being thrown is livable. This will almost never be the case. (And if it is, make sure you're swallowing only the specific exception class -- don't ever swallow .) When building libraries (used by your app), do not swallow exceptions, and do not be afraid to let the exceptions bubble up. Do not re-throw unless you have something useful to add. Do not ever (in C#) do this: As you will erase the call stack. If you must re-throw (which is occasionally necessary, such as when using the Exception Handling Block of Enterprise Library), use the following: At the end of the day, the very vast majority of exceptions thrown by a running application should be exposed somewhere. They should not be exposed to end users (as they often contain proprietary or otherwise valuable data), but rather usually logged, with administrators notified of the exception. The user can be presented with a generic dialog box, maybe with a reference number, to keep things simple. Exception handling in .NET is more art than science. Everyone will have their favorites to share here. These are just a few of the tips I've picked up using .NET since day 1, techniques which have saved my bacon on more than one occasion. Your mileage may vary.\n\nAll of the advice posted here so far is good and worth heeding. One thing I'd like to expand on is your question \"Do handling exceptions which might be thrown have a performance hit compared with pre-emptively testing things like whether a file on disk exists?\" The naive rule of thumb is \"try/catch blocks are expensive.\" That's not actually true. Trying isn't expensive. It's the catching, where the system has to create an Exception object and load it up with the stack trace, that's expensive. There are many cases in which the exception is, well, exceptional enough that it's perfectly fine to wrap the code in a try/catch block. For instance, if you're populating a Dictionary, this: is often faster than doing this: for every single item you're adding, because the exception only gets thrown when you are adding a duplicate key. (LINQ aggregate queries do this.) In the example you gave, I'd use try/catch almost without thinking. First, just because the file exists when you check for it doesn't mean that it's going to exist when you open it, so you should really handle the exception anyway. Second, and I think more importantly, unless your a) your process is opening thousands of files and b) the odds of a file it's trying to open not existing are not trivially low, the performance hit of creating the exception is not something you're ever going to notice. Generally speaking, when your program is trying to open a file, it's only trying to open one file. That's a case where writing safer code is almost certainly going to be better than writing the fastest possible code.\n\nHere are a few guidelines that I follow\n• None Fail-Fast: This is more of a exception generating guideline, For every assumption that you make and every parameter that you are getting into a function do a check to make sure that you're starting off with the right data and that the assumptions you're making are correct. Typical checks include, argument not null, argument in expected range etc.\n• None When rethrowing preserve stack trace - This simply translates to using throw when rethrowing instead of throw new Exception(). Alternatively if you feel that you can add more information then wrap the original exception as an inner exception. But if you're catching an exception only to log it then definitely use throw;\n• None Do not catch exceptions that you cannot handle, so don't worry about things like OutOfMemoryException because if they occur you won't be able to do much anyways.\n• None Do hook global exception handlers and make sure to log as much information as possible. For winforms hook both the appdomain and thread unhandled exception events.\n• None Performance should only be taken into consideration when you've analyzed the code and seen that it's causing a performance bottleneck, by default optimize for readability and design. So about your original question on the file existence check, I would say it depends, If you can do something about the file not being there, then yes do that check otherwise if all you're going to do is throw an exception if the file's not there then I don't see the point.\n• None There are definitely times when empty catch blocks are required, I think people who say otherwise have not worked on codebases that have evolved over several releases. But they should be commented and reviewed to make sure that they're really needed. The most typical example is developers using try/catch to convert string to integer instead of using ParseInt().\n• None If you expect the caller of your code to be able to handle error conditions then create custom exceptions that detail what the un excepected situation is and provide relevant information. Otherwise just stick to built-in exception types as much as possible.\n\nThe golden rule that have tried to stick to is handle the exception as close to the source as possible. If you must re-throw an exception try to add to it, re-throwing a FileNotFoundException does not help much but throwing a ConfigurationFileNotFoundException will allow it to be captured and acted upon somewhere up the chain. Another rule I try to follow is not to use try/catch as a form of program flow, so I do verify files/connections, ensure objects have been initiated, ect.. prior to using them. Try/catch should be for Exceptions, things you can not control. As for an empty catch block, if you are doing anything of importance in the code that generated the exception you should re-throw the exception at a minimum. If there is no consequences of the code that threw the exception not running why did you write it in the first place.\n\nYou have to think about the user. The application crash is the last thing the user wants. Therefore any operation that can fail should have a try catch block at the ui level. It's not necessary to use try catch in every method, but every time the user does something it must be able to handle generic exceptions. That by no means frees you from checking everything to prevent exceptions in the first case, but there is no complex application without bugs and the OS can easily add unexpected problems, therefore you must anticipate the unexpected and make sure if a user wants to use one operation there won't be data loss because the app crashes. There is no need to ever let your app crash, if you catch exceptions it will never be in an indeterminate state and the user is ALWAYS inconvenienced by a crash. Even if the exception is at the top most level, not crashing means the user can quickly reproduce the exception or at least record the error message and therefore greatly help you to fix the problem. Certainly a lot more than getting a simple error message and then seeing only windows error dialog or something like that. That's why you must NEVER just be conceited and think your app has no bugs, that is not guaranteed. And it is a very small effort to wrap some try catch blocks about the appropriate code and show an error message / log the error. As a user, I certainly get seriously pissed whenever a brows or office app or whatever crashes. If the exception is so high that the app can't continue it's better to display that message and tell the user what to do (restart, fix some os settings, report the bug, etc.) than to simply crash and that's it."
    },
    {
        "link": "https://stackoverflow.com/questions/11146099/best-practice-with-common-event-handling",
        "document": "In a WinForms solution, you have multiple controls of the same type. You need to add an event handler to each of the control and at the current time the event handler will be doing the same thing. You do not expect there to be difference between them down the road any reason.\n\nNow is it better to sharing an single Event Handler between the different events as shown below or use different ones like in the code sample shown above?\n\nIn the following page, Microsoft seems to suggest that sharing is better, however I notice that they have not updated it since .NET 2.0 (ie: Visual Studio 2008)\n\nIs there a Guide that makes a best practices recommendation in this case?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern",
        "document": "Best Practices for Implementing the Event-based Asynchronous Pattern\n\nThe Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics. To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements. The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.\n\nFor an overview, see Implementing the Event-based Asynchronous Pattern.\n\nIf you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.\n\nAlways invoke the MethodNameCompleted event handler when you have successful completion, an error, or a cancellation. Applications should never encounter a situation where they remain idle and completion never occurs. One exception to this rule is if the asynchronous operation itself is designed so that it never completes.\n\nFor each separate MethodNameAsync method, apply the following design requirements:\n• None Define a MethodNameCompleted event on the same class as the method.\n• None Define an EventArgs class and accompanying delegate for the MethodNameCompleted event that derives from the AsyncCompletedEventArgs class. The default class name should be of the form MethodNameCompletedEventArgs.\n• None Ensure that the EventArgs class is specific to the return values of the MethodName method. When you use the EventArgs class, you should never require developers to cast the result. The following code example shows good and bad implementation of this design requirement respectively.\n• None Do not define an EventArgs class for returning methods that return . Instead, use an instance of the AsyncCompletedEventArgs class.\n• None Ensure that you always raise the MethodNameCompleted event. This event should be raised on successful completion, on an error, or on cancellation. Applications should never encounter a situation where they remain idle and completion never occurs.\n• None Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the Error property.\n• None If there was an error completing the task, the results should not be accessible. When the Error property is not , ensure that accessing any property in the EventArgs structure raises an exception. Use the RaiseExceptionIfNecessary method to perform this verification.\n• None Model a time out as an error. When a time out occurs, raise the MethodNameCompleted event and assign a TimeoutException to the Error property.\n• None If your class supports multiple concurrent invocations, ensure that the MethodNameCompleted event contains the appropriate object.\n• None Ensure that the MethodNameCompleted event is raised on the appropriate thread and at the appropriate time in the application lifecycle. For more information, see the Threading and Contexts section.\n• None If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the MethodNameAsync overload that takes an object-valued state parameter, or task ID, called . This parameter should always be the last parameter in the MethodNameAsync method's signature.\n• None If your class defines the MethodNameAsync overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler. There are helper classes available to assist. For more information on concurrency management, see How to: Implement a Component That Supports the Event-based Asynchronous Pattern.\n• None If your class defines the MethodNameAsync method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke MethodNameAsync before the prior MethodNameAsync invocation has completed raises an InvalidOperationException.\n• None In general, do not raise an exception if the MethodNameAsync method without the parameter is invoked multiple times so that there are multiple outstanding operations. You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks\n• None If there was an error during execution of the asynchronous operation, the results should not be accessible. Ensure that accessing any property in the AsyncCompletedEventArgs when Error is not raises the exception referenced by Error. The AsyncCompletedEventArgs class provides the RaiseExceptionIfNecessary method for this purpose.\n• None Ensure that any attempt to access the result raises an InvalidOperationException stating that the operation was canceled. Use the AsyncCompletedEventArgs.RaiseExceptionIfNecessary method to perform this verification.\n• None Support progress reporting, if possible. This enables developers to provide a better application user experience when they use your class.\n• None If you implement a ProgressChanged or MethodNameProgressChanged event, ensure that there are no such events raised for a particular asynchronous operation after that operation's MethodNameCompleted event has been raised.\n• None If the standard ProgressChangedEventArgs is being populated, ensure that the ProgressPercentage can always be interpreted as a percentage. The percentage does not need to be accurate, but it should represent a percentage. If your progress reporting metric must be something other than a percentage, derive a class from the ProgressChangedEventArgs class and leave ProgressPercentage at 0. Avoid using a reporting metric other than a percentage.\n• None Ensure that the event is raised on the appropriate thread and at the appropriate time in the application lifecycle. For more information, see the Threading and Contexts section.\n• None Do not expose an property if your class supports multiple concurrent invocations. For example, XML Web service proxies do not expose an property because they support multiple concurrent invocations of asynchronous methods.\n• None The property should return after the MethodNameAsync method has been called and before the MethodNameCompleted event has been raised. Otherwise it should return . The BackgroundWorker and WebClient components are examples of classes that expose an property.\n• None Support cancellation, if possible. This enables developers to provide a better application user experience when they use your class.\n• None In the case of cancellation, set the Cancelled flag in the AsyncCompletedEventArgs object.\n• None Ensure that any attempt to access the result raises an InvalidOperationException stating that the operation was canceled. Use the AsyncCompletedEventArgs.RaiseExceptionIfNecessary method to perform this verification.\n• None Ensure that calls to a cancellation method always return successfully, and never raise an exception. In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded. However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.\n• None Raise the MethodNameCompleted event when the operation is canceled.\n• Catch any exceptions that occur in the asynchronous operation and set the value of the AsyncCompletedEventArgs.Error property to that exception.\n\nFor correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including ASP.NET and Windows Forms applications. Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: AsyncOperation and AsyncOperationManager.\n\nAsyncOperationManager provides one method, CreateOperation, which returns an AsyncOperation. Your MethodNameAsync method calls CreateOperation and your class uses the returned AsyncOperation to track the lifetime of the asynchronous task.\n\nTo report progress, incremental results, and completion to the client, call the Post and OperationCompleted methods on the AsyncOperation. AsyncOperation is responsible for marshalling calls to the client's event handlers to the proper thread or context.\n\nYou can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern. For example, you may want a class operating in Windows Forms to be free threaded. You can create a free threaded class, as long as developers understand the implied restrictions. Console applications do not synchronize the execution of Post calls. This can cause events to be raised out of order. If you wish to have serialized execution of Post calls, implement and install a System.Threading.SynchronizationContext class.\n\nFor more information about using AsyncOperation and AsyncOperationManager to enable your asynchronous operations, see How to: Implement a Component That Supports the Event-based Asynchronous Pattern.\n• None Ideally, each method invocation should be independent of others. You should avoid coupling invocations with shared resources. If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.\n• None Designs that require the client to implement synchronization are discouraged. For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.\n• None If you implement a method with the multiple-invocation overload ( in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations. This collection should be protected with regions, because the various invocations add and remove objects in the collection.\n• None Consider reusing classes where feasible and appropriate. In this case, the naming is not consistent with the method name, because a given delegate and EventArgs type are not tied to a single method. However, forcing developers to cast the value retrieved from a property on the EventArgs is never acceptable.\n• None If you are authoring a class that derives from Component, do not implement and install your own SynchronizationContext class. Application models, not components, control the SynchronizationContext that is used.\n• None When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs. Before implementing any solution that uses multithreading, see Managed Threading Best Practices.\n• Deciding When to Implement the Event-based Asynchronous Pattern\n• Best Practices for Implementing the Event-based Asynchronous Pattern\n• How to: Use Components That Support the Event-based Asynchronous Pattern\n• How to: Implement a Component That Supports the Event-based Asynchronous Pattern"
    },
    {
        "link": "https://codeproject.com/Articles/20550/Csharp-Event-Implementation-Fundamentals-Best-Prac",
        "document": "Everything you need to define, implement, and understand custom events using C# is presented in this article. Toward accomplishing these objectives the fundamental building blocks that must or should be utilized are presented, in addition to event implementation best practices and conventions. This article presents both .NET 1.x and 2.0+ alternatives for publishing and subscribing to events.\n\nWhile support for the implementation of custom events has been available since the 1.0 version of the .NET Framework, additional event-related support and capabilities have been added since then. Some of the new capabilities (e.g., generic , anonymous methods, delegate inference, etc.) comprise shortcuts intended to make the implementation of events easier. While such techniques do facilitate quicker event implementations, presenting them before or in place of the fundamental building blocks would yield a less explicit presentation. Consequently, this article avoids such shortcuts until after the fundamental building blocks have been introduced.\n• Delegates\n• 3.4 Delegates Are All The Same (there are no fundamentally differing types of delegates)\n• The Relationship Between Delegates and Events\n• Event Declaration Syntax\n• 6.2 Considerations For Choosing Between Field-like Syntax and Property-like Syntax\n• 6.3 Publish/Subscribe mechanism Using Delegates Without Events (never do this)\n• Handling Events Raised by .NET Framework Components - Walkthrough and Example\n\nThis article assumes a working knowledge of .NET programming with C#, in addition to an understanding of Generics, which were introduced in the 2.0 version of the .NET Framework. If you do not understand Generics, this article can still be helpful as there are ways to implement events that do not rely on Generics. Both generic and non-generic event implementation techniques are presented in this article.\n\nThe literature presenting events and related concepts frequently makes use of multiple words or expressions to describe any given concept. The following list catalogs much of this terminology with brief explanations of the concepts behind the expressions.\n\nevent, pre-event, post-event, and state, change of state, and expected change of state\n\nThe term, event, typically means that a change in state of an object has occurred or is about to occur. The term is also used in reference to some activity taking place within an object or application — activity like the processing of a gesture from an end user (e.g., button clicked), or the reporting of progress during a long-running task.\n\nThe term, \"state,\" refers to the current set of values of one or more variables in an object or application. A change in state means the value of one or more variables within an object has changed. In the event notification process, changes in state, or expected changes in state, are primary motivations for raising events. So, we have two ways to define an event relative to a change in state: immediately prior to a change in state, or immediately after a change in state. While the former are referred to as pre-events, the latter are referred to as post-events.\n\nPost-events announce that the change in state has already occurred, and pre-events announce the fact that a change in state is about to occur. Pre-events can be implemented as cancellable — meaning that the subscriber may cancel the event before the change in state occurs, thereby preventing the change in state from occurring, or preventing the further processing of a long-running task.\n\nThese are the classes or objects of which their state is of interest to other classes or objects. Event publishers maintain their internal state, and notify other classes (subscribers) through the raising of events or similar notification mechanisms.\n\nThese are the classes or objects that are interested in changes in state (or expected changes in state) of the event publishers. These terms refer to the classes or objects that typically perform some action in response to the occurrence of an event.\n\nraise, fire, or trigger an event; notification, or event notification\n\nEvent notifications (frequently expressed as, \"fire an event\" or \"raise an event\" or \"trigger an event\") are generally in the form of the event publisher calling a method in one or more subscribers. Consequently, the raising of an event ultimately means that code in the event publisher causes code in one or more subscribers to run.\n\nIn cases where no subscribers [to an event] have registered with the publisher, the event would not be raised.\n\nPlease note that in this article, events are described as \"raised\" (not \"fired\" or \"triggered\"). This convention comes from the team of developers who authored much of the .NET Framework (Cwalina and Abrams, 2006). They prefer the term, \"raise,\" because it doesn't have the negative connotations of the expressions, \"fire\" or \"trigger.\"\n\nWhen an event is raised, the publisher will frequently include data that gets sent to the subscribers through the event notification process. This data is presumably relevant to the particular event that was raised, and would be of interest to the event subscribers.\n\nFor example, an event can be raised when a file gets renamed. Data relevant to that particular \"file renamed\" event could include (1) the name of the file before the name was changed, and (2) the name of the file after the name was changed. Those file names could comprise the event data that are sent to the subscribers during the raising of the \"file renamed\" event.\n\nA clear understanding of the .NET Delegates type is crucial to the understanding of events as implemented in the .NET Framework. Consequently, much of this article is dedicated to explaining the relationship between delegates and events.\n\nThe literature outside of this article frequently uses the term, \"event handler,\" in reference to either (1) the delegate upon which an event is defined (in the publisher), or (2) any method registered with the event (in the subscriber). Furthermore, Intellisense in Visual Studio refers to an event handling method (in the subscriber) as simply, \"handler.\" For purposes of clarity, this article uses the expression, \"event handler,\" in reference to the delegate, while using the expression,\"event handling method,\" in reference to any method registered with an event.\n\nTo summarize; an \"event handler\" is the delegate upon which an event is based, while an \"event handling method\" is a method called in the subscriber when an event is raised.\n\nEvent handlers are delegates, although delegates are not necessarily event handlers (there are many uses of delegates beyond supporting events). Delegates are presented in more detail later in this article, but only to the extent that they are relevant to events.\n\nEvents, as implemented in the .NET Framework and as described in this article, constitute a .NET optimized implementation of the Observer Pattern that was documented by the \"Gang of Four\" or \"GoF\" (Gamma et al.1995). The .NET mechanisms used to implement events (delegates in particular) substantially reduce the amount of work required to implement the Observer pattern in .NET applications.\n\nIn order to understand events, as implemented in .NET applications, one must have a clear understanding of the .NET type and the role it plays in the implementation of events.\n\nDelegates can be understood as intelligent containers that hold references to methods, as opposed to containers that hold references to objects. Delegates can contain references to zero, one, or many methods. In order for a method to be called by a particular delegate instance, that method must be registered with the delegate instance. When registered, the method is added to the delegate's internal collection of method references (the delegate's \"invocation list\"). Delegates can hold references to static methods or instance methods in any class visible to the delegate instance. Delegate instances can call their referenced methods either synchronously, or asynchronously. When called asynchronously, the methods execute on a separate thread pool thread. When a delegate instance is invoked (\"called\"), then all methods referenced by the delegate are called automatically by the delegate.\n\nDelegates cannot contain references to just any method. Delegates can hold references only to methods defined with a method signature that exactly matches the signature of the delegate.\n\nConsider the following delegate declaration:\n\nNotice that the delegate declaration looks like a method declaration, but with no method body.\n\nThe signature of the delegate determines the signature of methods that can be referenced by the delegate. So, the sample delegate above ( ) can hold references only to methods that return while accepting a single string argument. Consequently, the following method can be registered with an instance of :\n\nThe following methods, however, cannot be referenced by a instance because their signatures do not match that of .\n\nAfter a new delegate type is declared, an instance of that delegate must be created so that methods can be registered with, and ultimately invoked by, the delegate instance.\n\nAfter a delegate is instantiated, additional methods can be registered with the delegate instance, like this:\n\nAt this point, the delegate can be invoked, like this:\n\nAnd, because both and are registered with the instance (named ), that instance will invoke both and when the above line executes, passing each the string value, \"my string value.\"\n\nIn the case of an overloaded method, only the particular overload having a signature that exactly matches the signature of the delegate can be referenced by (or registered with) the delegate. When you write code that registers an overloaded method with a delegate instance, the C# compiler will automatically select and register the particular overload with a matching signature.\n\nSo, for example, if your application declared the following delegate type...\n\n... and you registered an overloaded method named with an instance of , like this...\n\n... the C# compiler will register only the particular overload with a matching signature. Of the following two overloads, only the first would be registered with the instance of the type:\n\nA single delegate cannot selectively register or call both (multiple) overloads. If you need to call both (multiple) overloads, then you would need additional delegate types — one delegate type per signature. Your application-specific logic would then determine which delegate to invoke, and therefore which overload is called (by the delegate with the corresponding signature).\n\nIf this is your first introduction to delegates, you may be wondering, \"Why bother? It's just simpler to call the method directly — so what is the benefit of going through a delegate?\"\n\nA brief answer (to the \"why bother?\" question above) is that the code we write or components we use cannot always \"know\" which specific method to call at a particular point in time. So, one important perspective of delegates is that they provide a way for .NET components to call your code — without the .NET component having to know anything about your code beyond the method signature (as mandated by the delegate type). For example, .NET Framework components, like the Timer component, frequently need to execute code that you write. Because the Timer component cannot possibly know which specific method to call, it specifies a delegate type (and therefore signature of a method) to be invoked. Then you connect your method — with the requisite signature — to the Timer component by registering your method with a delegate instance of the delegate type expected by the Timer component. The Timer component can then run your code by invoking the delegate which, in turn, calls your method. Note that the Timer component still knows nothing about your specific method. All the Timer component knows about is the delegate. The delegate, in turn, knows about your method because you registered your method with that delegate. The end result is that the Timer component causes your method to run, but without knowing anything about your specific method.\n\nJust like the Timer component example above, we can make use of delegates in a way that enables us to write our code without our code having to \"know\" the specific method that will ultimately be called at a specific point. Rather than calling a method at that point, our code can invoke a delegate instance — which, in turn, calls any methods that are registered with the delegate instance. The end result is that a compatible method is called even though the specific method to be called was not written directly into our code.\n\nAll delegates inherently provide for both synchronous and asynchronous method invocation. So, another common reason to call methods via delegate instances is to invoke methods asynchronously — in which case the called method runs on a separate thread pool thread.\n\nAs you'll see later in this article, delegates play an integral role in the implementation of events in the .NET Framework. In brief, delegates provide a necessary layer of indirection between event publishers and their subscribers. This indirection is necessary in order to maintain a clean separation between the publisher and subscriber(s) — meaning that subscribers can be added and removed without the publisher needing to be modified in any way. In the case of event publication, the use of a delegate makes it possible for an event publisher to know nothing about any of its subscribers while still broadcasting events and associated event data to any/all subscribers.\n\nDelegates serve important roles in .NET applications beyond those already listed. Those other roles will not be further presented here because the intent of this article is to focus only on the foundational role that delegates serve in the implementation of events in .NET applications.\n\nDeclaring a Delegate Results in A New Class Being Created\n\nA delegate declaration that you write is sufficient to define an entire and new delegate class. The C# compiler takes your delegate declaration and inserts a new delegate class in the output assembly. The name of that new class is the name of the delegate type you supply in your delegate declaration. The signature you specify in your delegate declaration becomes the signature of the methods in the new class used to call any/all of the delegate's referenced methods (specifically the and methods). This new class extends (inherits) . So most of the methods and properties available in your new delegate class come from . The , , and methods are inserted by the C# compiler when it creates the new class in the output assembly (these are the methods you can call to cause the delegate to invoke any/all referenced methods — for synchronous invocation, and and used in asynchronous invocations).\n\nThe new class created from your delegate declaration can be understood as being a completed and full-blown implementation that has the type name you supplied in your delegate declaration, and is capable of calling methods with the specific signature that you also supplied in your delegate declaration.\n\nAs an example, when the C# compiler encounters the following delegate declaration...\n\n... the compiler inserts a new class named into the output assembly. The , , and methods of the class include the parameter and returned value in their respective method signatures.\n\nIt should be noted that is a special class in that compilers can derive from it, but you cannot derive from it explicitly. Your use of the C# keyword and associated syntax is how you instruct the C# compiler to extend for your purposes.\n\nThe meaning of \"multicast\" in is that the delegate is capable of holding references to multiple methods — not just one method. In the case of delegate instances that hold references to multiple methods, all referenced methods are called when the delegate instance is invoked.\n\nDelegate instances are immutable — meaning that once a delegate instance is created, it cannot be modified. So, when you register a method with a delegate, what is happening is that a new delegate instance is created that includes the additional method in its invocation list. If you unregister a method from a delegate instance, a new delegate instance is returned that has the unregistered method omitted from its invocation list. If you were to create a new object variable of a particular delegate type, then set it equal to an existing delegate instance (of that particular type), you would get a complete and separate copy of the delegate. Modifications to the copy (e.g., registering an additional method) would affect only the copy. The invocation list of the original instance would remain unchanged.\n\nFinally, C and C++ programmers will recognize that delegates are similar to C-style function pointers. An important difference, though, is that a delegate is not simply a pointer to a raw memory address. Instead, delegate instances are type-safe objects that are managed by the .NET CLR and that specifically reference one or more \"methods\" (as opposed to memory addresses).\n\n3.4 Delegates Are All The Same (there are no fundamentally differing types of delegates)\n\nThese statements are all true:\n\n \"If you've seen one delegate, you've seen them all.\"\n\n or\n\n \"All delegates are created equal.\"\n\n or\n\n \"A delegate is a delegate is a delegate.\"\n\nWhen you read about different \"types\" of delegates, you should understand that, internally, all delegates are the same. This is true for delegates provided by the .NET Framework and for delegates you create for your own purposes. To say \"they are all the same\" specifically means that all delegates (1) inherit from , which in turn inherits from ; and (2) provide the same set of members, including the , , and methods, etc.\n\nWhat differentiates delegate types is nothing more than:\n• The type name of the delegate.\n• The signature of the delegate — including return type and number and types of parameters.\n• Intended usage or role of the delegate.\n\nTake, for example, the generic Predicate delegate ( ). Here is what makes it a \"Predicate delegate\":\n• The signature: returns , accepts a single typed parameter for which the type, being generic, can be specified at design time.\n• Intended usage or role: this delegate will reference a method that defines a set of criteria and determines whether the specified object meets those criteria.\n\nBeyond the type name, signature, and intended usage, the delegate has the same set of members that any other delegate has, including , , etc. Consequently, this is what is meant by the statement, \"delegates are all the same.\"\n\nTo be clear, it is not the case that the delegate has any additional methods or properties that help it to fulfill its intended role. If some delegates had properties or methods that other delegates do not have, then those delegates would have different or unique capabilities and we therefore would not be able to say they are all the same.\n\nRegarding the intended usage perspective; you are free to use any delegate for purposes not intended by the delegate's creators — as delegates are not tied to any particular usage. You could, for example, use a delegate to call any method that returns and accepts a single typed parameter — even if those methods do not determine whether the specified object meets any criteria (which is the intended usage of the delegate). Granted, you should not use delegates for purposes other than those which they are intended to serve, as much of the value in the .NET Framework providing pre-built delegates (like ) is that we can understand the role they play without having to dig through a bunch of code to find out what they are actually doing.\n\nThe name of a delegate type communicates its intended role in your code. So be sure to use the appropriate delegate type, or create your own with an informative type name, even if another delegate with the requisite signature — but a potentially misleading name given your particular usage — is available.\n\n4. The Relationship Between Delegates and Events\n\nEvents in .NET programming are based on delegates. Specifically, an event can be understood as providing a conceptual wrapper around a particular delegate. The event then controls access to that underlying delegate. When a client subscribes to an event, the event ultimately registers the subscribing method with the underlying delegate. Then, when the event is raised, the underlying delegate invokes each method that is registered with it (the delegate). In the context of events, then, delegates act as intermediaries between the code that raises events and the code that executes in response — thereby decoupling event publishers from their subscribers.\n\nEvents do not, by themselves, maintain a list of subscribers. Instead, events control access to some underlying list of subscribers — and that list is typically implemented as a delegate (although other list-type objects or collections can serve in place of a delegate).\n\nA delegate that exists in support of an event is referred to as an \"event handler\". To be clear, an \"event handler\" is a delegate, although delegates are frequently not event handlers.\n\nUnfortunately, many authors writing about events use the term, \"event handler\", in reference to both (1) the delegate upon which an event is based, and (2) a method called by the delegate when the event is raised. In order to avoid confusion resulting from this state of affairs, this article uses the expression, \"event handler,\" only in reference to the delegate, while using the expression, \"event handling method,\" in reference to any method registered with the delegate.\n\nYou can define your own event handlers (delegates), or you can use one of the event handlers provided by the .NET Framework (i.e., , or the generic ). The following sample event declaration make use of a custom event handler rather than using a Framework-provided event handler.\n\nConsider the following:\n\nLine 1 declares a delegate type for which any method can be assigned — provided that the method returns and accepts a single argument:\n• — scope specifying that objects outside of our class can reference the delegate. If the delegate type is declared within the event publishing class, then it will need to be publicly scoped so that event subscribers can see it and declare instances of it with which to register their event handling methods (more on this later).\n• — keyword used to declare custom delegates in the .NET Framework.\n• — return type. This is part of the delegate signature, and therefore the return type that registering methods must specify.\n• — type name of the delegate.\n• — the rest of the signature. Any method that registers with the event must accept a single argument (in addition to returning ).\n\nLine 2 declares an event in terms of the delegate type. Notice that the event (which is named ) is declared very much like a method declaration — but with its data type specified as the delegate type:\n• — scope specifying that objects outside of our class can subscribe to the event.\n• — keyword used to define the event.\n• — data type of the event (this is the custom delegate type defined in Line 1.)\n• — name of the event.\n\nThe delegate declared in Line 1 is just an ordinary delegate (as are all delegates), and can be used for any purpose delegates can fulfill. Line 2 (i.e., the usage of the delegate type) is what turns that delegate into an event handler. In order to communicate that a particular delegate type is being used as an event handler, a naming convention has emerged whereby the delegate type name ends with \"Handler\" (more on this later).\n\nWhile you can create your own event handlers (and sometimes you might need to), you should use one of the delegates provided by the .NET Framework in cases where one of the Framework's event handlers would work with your particular event implementation. Many events make use of event handlers that can have common or identical signatures. So, rather than clutter your source code with many delegates that differ only by type name, you can/should make use of the built-in event handlers, as doing so reduces the amount of code you would need to write and maintain, and makes your code more easily understood. If someone reading your code sees you are basing an event on the delegate, for example, then they automatically know a lot about your event implementation without having to look further.\n\nAvailable in version 1.x of the .NET Framework, the non generic delegate enforces the convention (described in greater detail below) of event handlers returning no value while accepting two parameters, the first being an -typed parameter (to hold a reference to the class raising the event) and a second parameter of type or a subclass thereof (to hold any event data). is presented later.\n\nThis is how the .NET Framework declares the delegate.\n\nAvailable since the 2.0 version of the .NET Framework, the generic delegate enforces the same signature convention as enforced by the non generic version — but accepts a generic type parameter for the second, , parameter.\n\nThe declaration of this built-in delegate enforces the constraint that the type, , be of type (including, of course, subclasses thereof):\n\nNow suppose you want to strongly type the sender, rather than having it typed as . You can leverage generics to create your own generic event handler:\n\nYou can then use this custom generic event handler to additionally specify a type-safe parameter (i.e., thereby limiting the type of object that can be communicated as having raised the event):\n\nThe intent here would be that this event will only be raised by objects of type . Subscribers to the event would therefore be able to subscribe only to events published by the class.\n\nEvent arguments — sometimes referred to as \"event args\" — constitute the data sent by the publisher of an event to the subscribers during the raising of the event. Presumably this data is relevant to the occurrence of the event. For example, when a \"file was just deleted\" event is raised, the event arguments would likely include the name of the file before the name change, as well as the name of the file after the name was changed. The event handling methods can read the event arguments (referred to as \"event data\") to learn more about the event occurrence.\n\nYou have two basic alternatives for including event arguments with your events.\n• You can encapsulate all event arguments as properties of a class that derives from . At runtime, an instance of that class is then sent to the event subscribers when the event is raised. The event subscribers read the event arguments as properties of that class.\n• You can avoid the use of and, instead, declare individual event arguments — much as you would include arguments in a method declaration. This approach is discouraged for reasons described in section 5.2.\n\nThe first alternative listed above is strongly encouraged, and support for it is built into the .NET Framework through the class. Events implemented in .NET Framework components, by convention, provide their event arguments as instances , or as event-specific subclasses of .\n\nSome events carry no data. In these cases, is used as a placeholder, primarily for purposes of keeping one consistent event handler signature across all events regardless of whether the events carry data or carry no data. In cases of events with no data, the event publisher sends the value, , during the raising of the event.\n\nThe existence of and its recommended uses are in support of the event implementation conventions. It is certainly possible for a publisher of an event to specify event data without making use of or any subclass thereof. In such cases, the delegate signature could specify each parameter type and name. The problem with this approach, however, is that such a signature ties the event publisher with all subscribers. If you want to modify the parameters in the future, then all subscribers would have to be modified as well. It is therefore recommended to encapsulate all event data in a subclass of , as doing so reduces the amount of work required to subsequently change the number and types of values sent to event subscribers.\n\nTo illustrate the tradeoffs involved in sending a subclass instance vs. sending individual event arguments, consider a scenario in which you want to add a single value to the event data. If you were to specify your event data as individual parameters in the delegate signature (rather than subclassing ), then all subscribers to your event would have to be modified to accept the additional parameter. Even subscribers that do not care about this additional value would have to be modified to accept it, as the custom event handler signature would be changed. If you had, instead, subclassed , then all you would have to do is add a new property to your class. The event signature would not change, and therefore neither would the event handler signature used in any of the existing subscribers. Subscribers that do not care about the new property would not have to be touched because the event handler signature would not be changed — and they could simply ignore the additional property. Subscribers that do care about the new value would be able to read it as a property of the subclass.\n\nHere is an example of an subclass that encapsulates a single value:\n\nis derived from , and exists in support of cancellable events. Beyond the members provided by , provides the Boolean property that, when set to by an event subscriber, is used by the event publisher to cancel the event.\n\nSection 16 of this article presents cancellable events in greater detail (click here to go there now).\n\nThe keyword is used to formally declare an event. There are two valid event declaration syntax alternatives. Regardless of the syntax you write, the C# compiler will translate both property declarations into the following three components in the output assembly.\n• Privately scoped event handler (or a functionally equivalent data structure). The delegate is privately scoped in order to prevent external code from invoking the event, and thereby preserving encapsulation.\n• publicly scoped method; used to add subscribers to the private event handler.\n• publicly scoped method used to remove subscribers from the private event handler.\n\nThe field-like syntax declares the event in one or two lines of code (one line for the event, another for the associated event handler — if/when not using a built-in delegate).\n\nThe property-like syntax appears very similar to a typical property declaration, but with explicit and blocks in place of \"getter\" and \"setter\" blocks. Instead of retrieving or setting the value of a private member variable, they add and remove incoming delegate instances to/from the underlying event handler or other data structure that servers a similar role.\n\nThe property-like syntax will be as thread safe as you make it. The following is a thread safe version:\n\nYou can omit the blocks and variable declaration if thread safety is of no concern.\n\n6. 2 Considerations For Choosing Between Field-like Syntax and Property-like Syntax\n\nWhen choosing amongst the syntax alternatives, consider that the property-like syntax gives you more control over your event implementation than is available with the field-like syntax. While the field-like syntax will be compiled into IL that very much resembles the IL generated for the property-like syntax, the field-like syntax does not afford you the same opportunities to explicitly control the event implementation.\n\nUsing the property-like syntax enables you to more carefully control the registration and unregistration of subscribers with the event handler (delegate). It also enables you to more easily and explicitly implement the specific locking mechanisms of your choice to address thread safety concerns. The property-like syntax additionally enables you to implement a custom event handler mechanism other than a delegate. You might want to do this in scenarios where you want to support many possible events, only a few of which would have any subscribers at any given point in time. In such a scenario, your event implementation would use a hash table or similar data structure, rather than an individual delegate, to maintain a list of all possible events and any associated listeners.\n\nIt should be clearly understood that events are not delegates — even though events are very much dependent upon delegates, and in some ways can be seen as a form of a delegate implementation. Events are also not delegate instances, even if they can be used in very similar ways.\n\nWhile you can omit the event keyword (and therefore the formal declaration of the event) and simply use a public delegate to provide a publish-and-subscribe notification mechanism, you should never do so. The problem with public delegates (as compared to event declaration), is that methods outside of the publishing class can cause publicly scoped delegates to invoke their referenced methods. This violates basic encapsulation principles and can be the source of major problems (race conditions, etc) that may be difficult to debug. Consequently you should implement events only through the use of the keyword. When delegates are implemented in support of events, the delegate — even if declared as a public member of the defining class — can only be invoked from within the defining class (via the raising of the event), and other classes can only subscribe to and unsubscribe from the underlying delegate via the event.\n\nFor each event, the publisher should include a protected virtual method that is responsible for raising the event. This will allow subclasses to [more] easily access base class events. Of course the recommendation to make this method protected and virtual applies only to non static events in unsealed classes.\n\nOnce an event and any associated delegate and publishing method have been defined, the publisher will need to raise the event. Raising the event should generally be a two step process. The first step would be to check to see if there are any subscribers. The second step is to raise the event, but only if there are any subscribers.\n\nIf there are no subscribers, then the delegate will test to . The following logic raises the event, but only if the event has any subscribers.\n\nThere is a possibility that the event could be cleared (by code executing in another thread) between the test for and the line that actually raises the event. This scenario constitutes a race condition. So it is recommended to create, test, and raise a copy of the event's event handler (delegate), like this:\n\nAny unhandled exceptions raised in the event handling methods in subscribers will be propagated to the event publisher. The raising of the event should therefore be attempted only within a block:\n\nEvents can have multiple subscribers — each of which is called, in turn, by the event handler (delegate) when the event handler is invoked by the [ ] line. The event handler used in the above block of code would stop iterating over it's invocation list (of subscribed event handling methods) when the first unhandled exception is raised by a subscriber. So, if there were 3 subscribers, for example, and the 2nd one threw an unhandled exception when invoked by the delegate, then the 3rd subscriber would never receive the event notification. If you want for every subscriber to receive the event notification even if other subscribers throw unhandled exceptions, then you could use the following logic which explicitly loops through the event handler's invocation list:\n\nBy design, the publisher of an event has absolutely no knowledge of any of the subscribers. Consequently, it is the job of subscribers to register or unregister themselves with the publisher of an event.\n\nIn order to subscribe to an event, the subscriber needs three things:\n• a reference to the object publishing the event of interest\n• an instance of the delegate upon which the event is defined\n• a method that will be called by the publisher when it raises the event\n\nThe subscriber then registers its event handler (delegate) instance with the publisher, like this:\n\nIn the above line...\n• is the reference to the object that will raise the event of interest. Notice how the event, , is accessed as if it were a public property of .\n• The operator is used to add the delegate instance to the invocation list of the event handler in the publisher. Remember, multiple subscribers may register with the event. Use the += operator to append the current subscriber to the underlying delegate's invocation list.\n• is a reference the particular event hander delegate to be used (if not one of the built-in delegates).\n• Finally supplies the name of the method in the subscribing class that is to be called upon the raising of the event.\n\nWARNING: Do not use the operator when registering an event subscriber with a publisher. Doing so would replace any/all currently registered event subscribers with the current subscriber. Instead, be sure to use the operator to cause the current subscriber to be appended to the event handler's invocation list.\n\nA subscriber can unregister from the publisher, like this:\n\nThe operator is used to remove the delegate instance from the invocation list in the publisher.\n\nSubscribers are automatically unregistered when an object is disposed — if the subscriber was not already explicitly unregistered from the event.\n\nAn event handling method is the method in an event subscriber that is executed by the event publisher upon the raising of an event. Be aware that some literature describing events in .NET refers to these methods as \"event handlers\" even though, to be technically precise, an \"event handler\" is a delegate upon which an event is based — and not any method referenced by a such a delegate.\n\nThe important requirement of the event handling method is that its signature must match the signature of the event handler (delegate) upon which the event is defined.\n\nYou should also carefully consider the consequences of any exceptions that may be thrown or caught in the event handling method. Exceptions not caught in the event handling method will propagate to the event publisher.\n\nThe concepts and features presented in this section were introduced in the 2.0 version of the .NET Framework. These newer features amount to shortcuts and, possibly, the simplification of your code when used smartly.\n\nThere is a risk, however, that the improper use of some of these features could make your event implementation code more difficult to understand. For example, if you made use of an \"anonymous method\" (presented below) that was comprised of 30+ lines of code, your event implementation would likely be far more difficult to read than an equivalent implementation that, instead, places those 30+ lines in a named method.\n\nIt is important to understand that these 2.0+ concepts and features do not present any fundamental change to the way events are implemented in .NET Framework applications. Instead, they are mostly intended to simplify the way we go about implementing events.\n\nIn addition to the Generic-specific features presented elsewhere in this article (e.g., ), it should be noted that any event implementation techniques that rely in any way on Generics will not be available in .NET 1.x applications, as Generics were first introduced in the 2.0 version of the .NET Framework.\n\nThe C# 2.0 (and newer) compiler is smart enough to determine the type of delegate with which a particular event is implemented. This \"delegate inference\" capability enables you to omit the declaration of the requisite delegate in the code that registers an event handling method with an event.\n\nConsider the following 1.x code that registers an event handling method with an event. This code explicitly instantiates the event handler (delegate) in order to register the associated method with the event.\n\nThe following 2.0+ code uses delegate inference to register the same method with the event. Notice the following code appears to register the event handling method directly with the event.\n\nWhen you assign the method name directly to the event like that, the C# compiler ensures that the method signature matches the signature of the event handler upon which the event is based. The C# compiler then inserts the requisite delegate registration code (i.e., ) in the output assembly.\n\nThis simplified syntax is made possible by the C# compiler, and not by any change to the fundamental ways that events are implemented in the .NET Framework. To be clear, it is not the case that events in C# 2.0 (and newer) can directly reference methods. What the compiler is doing for us is supplying the [still] requisite delegate syntax in the output assembly — as if we had explicitly instantiated the delegate.\n\nAn anonymous method is a block of code that you pass to a delegate (rather than passing the name of a method to be referenced by the delegate). When the C# compiler encounters an anonymous method, it creates a complete method in the output assembly that contains the code block you supplied. The compiler supplies a name for the method, then references that [new] method from the associated delegate instance (all this happens in the output assembly). The method is said to be \"anonymous\" because you are making use of it without knowing its name (it has no name in your source code).\n\nAnonymous methods present an opportunity for you to write simpler code. Consider the following code that registers a short event handling method with an event:\n\nThe above logic can be rewritten with an anonymous method, like this:\n\nAnonymous methods are intended to simplify our code. This simplification can happen when the code block is relatively short. In the above example, the version of the logic that uses the anonymous method syntax is easy to read because we don't have to locate any separate event handling method in order to understand how the subscriber will respond when the event is raised. The anonymous method syntax can, however, be more cumbersome to read (more so than logic that references a named method) in cases where the code block is comprised of many lines of code. Some authors suggest that code blocks containing more than three or four lines of code should not be implemented as anonymous methods. These more lengthy code blocks should, instead, go into named methods in order to improve readability.\n\nTo summarize the alternatives presented so far, the following code demonstrates three options for registering an event handling method with an event. The first demonstrates the explicit approach that works with all versions of the .NET Framework. The second demonstrates delegate inference. The third demonstrates the use of an anonymous method:\n\nPartial classes are relevant to the implementation of events in that Visual Studio will place event registration code and event handling method stubs in the partial class files associated with a given Windows Form class. Click here to go to section 15.1 which presents the implementation of events in partial classes in greater detail.\n\nThe following conventions were gleaned from a number of resources, including the authors of the .NET Framework and other well-known industry experts (see reference list at the end of this article for the complete list).\n• Choose a name that clearly communicates the state change the event represents.\n• Events can be categorized as (1) events raised before a state change occurs; and (2) events raised after a state change occurs. Consequently, the event name should be chosen to reflect the before or after [state change] aspect of the event.\n• In the case of events that must or may [someday] carry custom event data, you should create a new class that (1) extends , and (2) implements the members (e.g., properties) required to contain and expose your custom event data\n• The only time you should not subclass is when you are certain that your event will never carry event data\n• The name of your subclass should be the name of the event, with 'EventArgs' appended\n\nFor events that contain no data, and never will, it is recommended to pass . This recommended practice serves to maintain the event implementation conventions even for events that have no event data. If there is a possibility that your event may someday carry event data, even if not at initial implementation, then you should create a subclass of , and use that in your events. The primary benefit of this recommendation is that you will someday be able to add data (properties) to your subclass without breaking compatibility with existing subscribers.\n• If you are using .NET Framework 1.x, then you should use the built-in delegate\n• If you are using .NET Framework 2.0 or newer (for 'both' publishers and subscribers), then you can make use of the generic delegate\n• If you create your own delegate, then the delegate name should be comprised of the event name, with the word, 'Handler' appended\n\nAs stated above, under \"Delegate Name,\" you should use one of the delegates provided by the .NET Framework. In these cases, the delegate signature is, of course, determined for you and automatically conforms to the recommended conventions.\n\nThe following recommendations are implemented in the delegates provided by the .NET Framework. If you create your own event handlers, then you should follow these recommendations in order to remain consistent with the .NET Framework's implementation.\n• The delegate should always return . In the case of event handlers, it simply makes no sense to return a value to the event publisher. Remember, event publishers, by design, have no knowledge of their subscribers. In fact the delegate, by design, acts as an intermediary between the event publisher and its subscribers. Consequently, publishers aren't supposed to know anything about their subscribers — including the possibility of receiving returned values. It is the delegate that is calling each subscriber, so any return value would make it only as far as the delegate and would never get to the publisher anyway. This rationale holds true for avoiding output parameters that use either the or parameter modifiers. The output parameters of the subscribers would never propagate to the publisher.\n• The first parameter should be of the type and should be named . This first parameter is to hold a reference to the object that raises the event. Passing a reference to the event publisher enables the event subscriber to distinguish amongst multiple possible publishers of a given event. Without a reference to the publisher, the event handling method would have no way to identify or act on the specific publisher that raised a particular event. The data type for is object because practically any class can raise events. Avoiding a strongly-typed parameter allows for one consistent event handler signature to be employed across all events. Where necessary, the event handling method can cast the sender parameter to the specific event publisher type. Static events should pass as the value of sender, rather than omitting the parameter.\n• The second parameter should be named ' ' and should be of the type or your custom subclass of (e.g., ). In the case of cancellable events, the second parameter is either of the type or your custom subclass thereof. In the case of events that carry no event data, you should specify as the second parameter type. In such cases is specified as the value of this parameter when the event is raised. This practice is recommended to maintain conformance to the convention — so that all event handler signatures include an parameter — even for events that do not have . Apparently, according to the convention, having one consistent signature is more important than having multiple event handler signatures — even in cases where one of the parameters will never be used.\n\nExamples (with no custom data sent with the event):\n\nExamples (with custom data sent with the event):\n• Assuming the event is to be made available to code outside of the publishing class, the event would be declared with the keyword (to make it accessible to code outside of the publishing class).\n• The event handler upon which the event is based is specified as the type of the event — in a similar fashion with which a data type is specified in a typical property or method declaration.\n\nExample (makes use of a custom event handler):\n• Rather than raising an event inline throughout your code, it is recommended to create a separate method that is responsible for raising the event. You then call that method throughout your code as necessary.\n• The name of this method should be the word with the event name appended.\n• If your event makes use of a custom subclass, then the method that raises the event should accept at least one parameter that is of the particular subclass defined for the custom event data.\n• For non-static classes that are not sealed, the method should be implemented as with accessibility specified as so that derived classes can easily notify clients registered with the base class.\n• For sealed classes the accessibility of the method should of course be set to , as the raising of events should not be initiated from outside of the class.\n\nExamples (each takes a custom subclass type as an argument):\n• The convention implemented by Visual Studio, when it automatically creates an event handling method stub, is to name the method as (1) the name of the object raising the event; followed by (2) an underscore character; with (3) the event name appended.\n• Another convention for determining the name of the event handling method is the same as that described above for specifying name of the method that raises the event in the publisher. Specifically, the name of the method should be the word with the event name appended.\n• The signature of the event handling method must exactly match the delegate signature. According to the event handling conventions, as well as the delegates provided by the .NET Framework, the event handling method must return , while accepting exactly two parameters: an -typed variable named , and an (or derived class) instance named ' '.\n\nSubscribing to the Event (code that registers the Event Handling Method with the Event)\n• To register a method with an event, use the syntax, according to this pattern:\n\nWARNING: Do not use the operator when registering an event subscriber with a publisher. Doing so would replace any/all currently registered event subscribers with the current subscriber. Instead, be sure to use the operator to cause the current subscriber to be appended to the event handler's invocation list.\n\nUnsubscribing from the Event (Code that Unregisters the Event Handling Method from the Event)\n• To unregister a method with an event, use the -= syntax, according to this pattern:\n\nCamel casing is a naming convention whereby the first letter is lower case, with each subsequent \"word part\" starting with an upper case letter. By convention, variables names are camel cased.\n\nPascal casing is naming convention whereby every \"word part\" of a name starts with an upper case letter, with other letters lower case, and no underscores. By convention, names of classes, events, delegates, methods, and properties are to be Pascal cased.\n\nIn order to keep the following steps as brief as possible, little or no explanation of any given step is provided. Explanations, examples, and conventions for each step are presented elsewhere throughout this article.\n\nStep 1: EventArgs - Decide how your event will account for EventArgs.\n• Including with custom events is required to conform to the event publishing standards. , however, are not a technical requirement — you can create, raise, and handle custom events that do not make any use of .\n• If your event will never communicate custom event data, then you can satisfy this step by deciding to use the built-in class. You would later specify the value, , when raising the event.\n• If your event is not cancellable and includes custom event data, then you should create a class that extends . Your custom subclass would include any additional properties that contain the event data.\n• If your event is cancellable then you can use — which includes the Boolean property that clients can set to true to cancel the event. You can create a subclass of that has properties for any additional event-specific data.\n\nStep 2: Event Handler - Decide which event handler your event will use.\n• You have two basic alternatives — create your own event handler (delegate) or use one of the delegates provided by the .NET Framework. If you use one of the built-in event handlers, then you will have less code to maintain and your event handler signature will automatically conform to the convention of returning , while accepting the parameters, , and\n• If using .NET 1.x, consider using the built-in delegate.\n• If using .NET 2.0, consider using the built-in generic delegate.\n\nStep 3: Declare the Event — Decide which syntax to use: field-like syntax or property-like syntax.\n• The field-like syntax will suffice for many custom event implementations.\n• Consider going with the property-like syntax when your class exposes a large number of events, only a few of which are expected to be subscribed to at any given time.\n\nStep 4: Event-Raising Method — Decide whether you will raise the event from a method, or raise it inline.\n• It is generally recommended to raise events from a method that is dedicated to that task, rather than raising events inline and throughout your code.\n• Either raise the event inline, or call the method that raises the event.\n• Prior to raising the event you will need to have an instance of your subclass populated with event-specific data. If not making use of any subclass, then you should include in place of a custom class when you raise the method.\n\nBecause this article presents the event pattern ( ) implemented throughout the .NET Framework classes, the following steps will help you wire up event handling methods that work with practically all .NET Framework events, in addition to custom events you create according to the same pattern.\n• Define an event handling method with a signature that exactly matches the delegate upon which the method is defined.\n• When using either the built-in non generic , or the generic delegate in the event declaration, the resulting signature automatically matches the convention of returning and accepting the parameters ( ).\n• Declare class-level member variable that references the class or object that publishes the event of interest.\n\nStep 3: Instantiate the event handler (if necessary).\n• If the event of interest is based on a custom event handler, then create an instance of that event handler, passing in the name of the event handling method.\n• This step may be combined with Step 4 (next) by using the new keyword to instantiate the delegate in the same line in which the delegate is registered with the event\n\nStep 4: Register the subscriber (event handling method) with the event.\n• Any .NET version: Use the syntax to register the event handler with the event.\n• .NET 2.0+: Alternatively, through delegate inference, you can simply assign the method name directly to the event.\n• .NET 2.0+: Alternatively, if the event handling method is very brief (3 or so lines of code), your implementation may be easier to read if you register the event handling logic via an \"anonymous method.\"\n\nStep 5: Unregister the subscriber (event handling method) from the event.\n• When the subscriber should no longer receive event notifications from the publisher, then you can unregister the subscriber from the event.\n• This step can be considered as optional, given that subscribers are automatically unregistered from publishers when the subscriber is disposed.\n\nThis example makes use of a custom event handler, carries event data in a custom subclass, declares an event with field-like syntax, and otherwise conforms to recommended event implementation standards and guidelines. None of the .NET 2.0+ features (anonymous methods, etc) are used in order to keep the presentation as explicit as possible.\n\nThis sample event is raised when a file is moved by a \"file mover\" utility (in the sample project). The event data includes (1) the name of the file moved, (2) the source folder path, and (3) the destination file path.\n\nHere we derive a new class, , from in order encapsulate the event data sent to the subscriber.\n\nHere we declare a new delegate that conforms to the event conventions, returns and accepts two parameters; an named ' ' and named ' '.\n\nHere we declare the event using the field-like syntax.\n\nHere we declare the method that raises the event.\n\nHere we have a method that would do the work of interest (move the file). Once the work is completed, the method that raises the event is called.\n\nThis method is called when the instance raises the event. It's signature exactly matches the event handler's signature.\n\nStep 3: Instantiate the event handler as we register the subscriber (event handling method) with the event\n\nThis approach combines steps 3 and 4 from the steps listed in the section 14.2.\n\n14. Handling Events Raised by .NET Framework Components - Walkthrough and Example\n\nThe event implementation conventions described in this article can be found throughout the .NET Framework's own event implementations. The purpose of this walkthrough is to show how one .NET Framework component exposes its events, and how you can write code that runs when the event is raised. You will see that the steps required are simply a subset of the recommended steps required to implement your own events and event handling methods.\n\nThis section points out how the Framework makes use of these conventions by walking you through the component's event implementation. The is a class provided in the .NET Framework's namespace. This class can be used to notify your application when specific disk IO activity takes place in a specific folder (e.g., a new file is created, a file is modified, or deleted, etc).\n\nThe class exposes the event — which is raised by a instance when it detects that a file has been deleted in a watched folder.\n\nThis is how the .NET Framework's FileSystemWatcher class declares its Deleted event:\n\nThe delegate used is , which is declared in the .NET Framework as:\n\nNotice that the delegate conforms to the convention of accepting two parameters — the first named is of type , and the second parameter is named ' ' and is of type or a descendent thereof. In this case, the specified is a descendent (as further described below).\n\nThe event communicates information about the file or directory that was deleted through a subclass of :\n\nThe class extends by adding the following properties:\n• — Gets the type of directory change that occurred (communicated as a enumeration value of Created, Deleted, Changed, etc.)\n• — Gets the fully qualified path to the affected file or directory\n• — Gets the name of the affected file or directory\n\nWhen the event is raised, the instance sends the path, file name, etc. to the event subscribers. This means that each subscriber not only learns that a file was deleted, but specifically which file was deleted.\n\nNotice that the name of the event handler, , does not conform exactly to the naming convention that suggests the event handler name should be the name of the event followed by the word, Handler. Remember, the conventions are not laws or rules. Instead, they are just suggestions for making your code more easily understood. In the case of the class, one event handler was implemented to support a number of events, including , and — thus the minor break from a strict interpretation of the naming convention. A strict adherence to the convention would have resulted in the creation of 3 delegates that are identical except for the name (e.g., , , etc.) Alternatively the name chosen could have been something like — which would have been ridiculous. In this case a reasonable deviation from the convention was [thankfully!] chosen.\n\nGiven the above event implementation provided by the .NET Framework, the following is an example of code you could write in your class that would subscribe to the event of a instance. This code would enable your application to respond to files being deleted in the C:\\Temp directory.\n\nWindows Forms implement events of their own, as well as facilitate the handling of events raised by controls contained within the form or within container controls in the form class. Additionally, the implementation and handling of events in Windows Forms classes require careful consideration and even unique steps be taken given that Windows Forms and the controls they contain exhibit \"thread affinity\" — meaning that their properties can be updated only by code running in the same thread that created the Form or controls.\n\nThese and other Windows Forms-specific considerations are presented in this section.\n\nThe concept of \"partial class\" was introduced in the .NET Framework version 2.0. A partial class is a class declared with the keyword, and with parts of the class defined in two or more source code files. The compiler retrieves all source code defining the partial class from all files containing the partial class, and outputs one [compiled] class. That is, a partial class may exist in two or more source code files, but when the application is compiled, the \"class fragments\" are compiled into one class in the output assembly.\n\nThe benefits of partial classes include (1) multiple developers can work on different parts of the same class at the same time, by working with different source code files; and (2) automated code generating tools can write to one source code file, while human developers can maintain their code in a separate file, without concern that their changes may eventually be overwritten by the automated code generating tool. This second benefit is realized in Windows Forms projects starting with Visual Studio 2005. When you add a new form to a Windows Forms project, Visual Studio automatically creates the form as a partial class that is defined in two source code files. The file that contains code generated by Visual studio is named , while the file intended for developer code is named FormName.cs. So, for example, if you have Visual Studio 2005 create a form named MainForm, then the following two source code files will be created:\n\nWhen you add controls to the form by using the Visual Studio Windows Forms designer, the designer will add the necessary code to the FormName.Designer.cs file.\n\nDevelopers should not directly modify the source code in the FormName.Designer.cs file because it is possible that the designer would overwrite such changes. As a general rule, all developer code should be written in the FormName.cs file.\n\n.NET 1.x simply does not have partial classes. All source code — whether written by Visual Studio or a developer — goes into a single source code file. While the Visual Studio Windows Forms designer attempts to write code in just one section of that file, it is possible to have developer code and generated code in the same sections, with the possibility that the Windows Forms designer would overwrite developer-written code.\n\nWhen Visual Studio 2005 creates an event handling implementation for you, the event handler/registration code is written to the FormName.Designer.cs file, with only an event handling method stub automatically written to the FormName.cs file. The intent behind this arrangement is for the Windows Forms designer to write all of the event-related code that can be automated (wiring up the event handling method with the event handler, etc.). The only part that the designer cannot create for you is the particular programming logic that is to take place inside of the event handling method. So, when Visual Studio is finished doing everything it can for you, what you have is (1) all of the event-related \"plumbing\" code tucked away in the FormName.Designer.cs file; with (2) an event handling method stub waiting for you in the FormName.cs file. All that you must do to finish the event handling implementation is write the necessary code in the event handling method stub.\n\nThe following steps walk you through the implementation of a event handling method in a Windows Form named MainForm.\n• Using Visual Studio .NET, create a new Windows Forms project, and add a new Form named MainForm.\n• With MainForm opened in design view, right-click over an exposed portion of the form (not over a control), and select Properties from the popup menu. The Properties dialog that appears can display either form properties or events. If it is not already selected, click on the Events button (it has the lightening bolt icon) in to toolbar at the top of the properties dialog.\n• In the Events dialog, locate the event for which you want your application to respond. In our case, this is the event. Double-click anywhere in the row where is listed.\n\nTwo things happen at this point. First, the Windows Forms designer inserts the following line to the MainForm.Designer.cs file.*\n\nSecond, the Windows Forms designer inserts the following method stub into to the MainForm.cs file.*\n\n* When using .NET 1.x (which does not have partial classes), the same code is generated, but goes into the single MainForm.cs file.\n\nYou can see that nothing has been hidden from you. All code required to implement the event handling logic is present and available for you to review and possibly modify as necessary. All that the Windows Forms designer does is write the boilerplate code in a way that conforms to the recommended event standards, and places that code in the partial class files where you can then extend it for your application-specific purposes.\n\nIf you want to change the name of the event handling method that the Windows Forms designer generates for you, you are free to do so. Just be sure to change the method name in both the MainForm.cs file, and where it is registered with the event handler in MainForm.Designer.cs.\n\nOn a separate note, the event is a \"before event\" that is cancellable. This means that the event is raised before the form is closed, and the event handling procedure can cancel the event, thereby preventing the form from being closed.\n\nWhat specifically makes this event cancellable is the parameter, which is of a class type that extends . To cancel the event, you would set the Boolean property of to , like this:\n\nWindows forms and the controls they contain can have their properties and methods called only by code running on the same thread that created the control (i.e. Windows forms and controls exhibit thread affinity). You may, therefore, run into unexpected behavior or runtime exceptions when code from a non UI thread attempts to execute code that modifies UI components.\n\nBeware that you might run into threading issues related to this UI thread affinity even if you are not explicitly or knowingly employing multiple threads in your application. For example, the class automatically spawns an additional background thread for its own purposes. Consequently, you may encounter threading issues if your code makes use of the , and any of the related event handling methods ultimately cause an update to a UI control. Separately, any 3rd party components you are using may spawn additional background threads of which you are initially unaware.\n\nThere are a few ways to mitigate these threading issues:\n• Set the property (where available and relevant)\n• Make use of and and to call the code that updates the UI.\n• Component developers can make use of the , n, and classes.\n\nSome .NET components provide a property. Examples of these components include , , and the classes. Setting the enables event handling methods to be called on the same thread that created the UI component that is to be updated. So, for example, a Timer's event is raised from a thread pool thread. When the Timer component's is set to a UI component, the event handling method for the event is called on the same thread on which the UI component is running. The UI component can then be updated from the event handling method.\n\nIt should be noted that Visual Studio may automatically set the property to the control that contains the component. Consequently, you may never encounter the need to explicitly set the property.\n\nThere are scenarios, however, where the property may need to be set explicitly. For example, when you have a class library that is instantiated within a Windows Form, and that class library contains a instance. The spawns an additional background thread from which its events are raised. These events would then be handled within the class library. So far so good. The class library can handle the events because it lacks the thread affinity found with Windows Forms controls. The class library may, in response to receiving a event, raise a new event that is then handled in the containing Windows Form instance. The following exception will occur if the has not been set to that Form (or relevant control on it), or the UI updating code is not invoked via , as described next.\n\nThere are two relevant exceptions to the rule that states that Windows Forms controls cannot be accessed from a thread other than the thread on which they were created. Every control inherits the method and property, which can be accessed from other threads. takes a single argument, which is of type delegate. When called, causes the delegate to call any methods registered with it. Obviously then, any code called via will be executed on the same thread in which the control exists. So, to update UI controls running on one thread from code in another thread, simply (1) break out the code that updates the UI control into its own method; then (2) register that method with the delegate that is then (3) passed to the UI control's method.\n\nreturns true when the current code is running on a thread other than the thread on which the Control was created. You can query the value of to determine whether your code can directly update the Control, or if such updates must be routed through the method.\n\nNew to the 2.0 version of the .NET Framework, these classes provide another option for developers of components that raise events asynchronously to address the threading issues described above. An important benefit of using is that it provides the solution to the threading issues (presented above) in the event publisher (component), whereas the two alternatives presented above ( and ) place the solution with the subscribers.\n\nCancellable events are generally raised by a component that is about to perform some action that can be cancelled or otherwise prevented from happening. The Windows Form class's event is an example of a cancellable event. A typical scenario in which you'd want to prevent a form from closing would be where the user has not saved changes. In this scenario, your event handling method could implement logic that detects the presence of unsaved changes. If there are any, the logic could prompt the user to save their changes. If the user elects to save their changes, your logic would cancel the event. This would prevent the form from closing, thereby giving the user the opportunity to review their changes and possibly save them before attempting to close the form again.\n\nThe inner workings of a cancellable event can be quite straight-forward. Considering that events frequently signal to subscribers that a change in state or some other activity is \"about to\" place, this \"pre-event\" represents an ideal opportunity for the event publisher to determine if it (the publisher) should allow for the change in state (or activity) to take place. If the activity is allowed to take place (i.e., nothing tells the publisher to abort the operation), the publisher then allows for the change in state to happen and subsequently/optionally raises the post-event.\n\nIn sum, a cancellable event is really two events and some activity that takes place between those events. The \"pre-event\" happens before the activity. The activity then takes place (or not). If the activity takes place, then the \"post-event\" is typically raised. So, to be precise, no event is being cancelled even though we say we have a cancellable event. Rather, the activity that takes place between the two events is what is cancelled — and likely prevented from starting at all.\n\nIn support of the above notion of cancellable event, the .NET Framework provides us with the class that we can use directly or extend for our application-specific purposes. extends by providing the Boolean property that, when set to by an event subscriber, is used by the event publisher to cancel the event. The event publisher code creates an instance of that is sent to subscribers when the pre-event is raised. By default, event handling methods (in any/all subscribers) are run synchronously. Consequently, the change in state (or activity) signaled by the pre-event cannot happen until after all event handling methods have run to completion. Of course the event publisher retains its reference to the instance after the event is raised. So, if any event handling methods set the property to , the event publisher will see this before attempting to proceed with the change in state, and can therefore respond accordingly.\n\nThe sequence of activity could be something like this:\n• the event publisher instantiates (or subclass thereof) with the name ' '\n• the event raising method then raises the event, passing ' ' to the event subscribers (defaulting to )\n• the event handling method (in the event subscriber, of course) then sets the value of to , possibly by prompting the user\n• the event raising method then gets the value of , and responds accordingly. In the case where , the logic would then prevent the change in state or activity from taking place (e.g., form closing).\n\nIn the case where the event has multiple subscribers, the event will be cancelled if any of the event handling methods set . More specifically, the event publisher will see that when the last of the event handling methods returns (they are called synchronously).\n\nAt the end of the day, all that does for us is provide a mechanism for an event subscriber to communicate a | value to the event publisher. The actual work and meaning of \"cancelling the event\" is entirely up to you, as you would write the logic that responds to the value of .\n\nThe event cancellation scenario described above offers no mechanism for stopping some activity (or change in state) from occurring once the activity has begun. This is because the event publishing activities all happen synchronously (or sequentially). The pre-event can be used to prevent the activity from starting, but once it has started, it will run to completion because the subscriber's pre-event event handling methods have run to completion and can therefore no longer communicate with the event publisher.\n\nIf you need to enable subscribers to cancel an operation after it has begun (e.g., after the pre-event has been raised and handled), the basic event publishing mechanism described above will not be sufficient. You would need to employ a more robust event publishing mechanism in which the event publisher conducts its activity asynchronously (e.g., on a background thread). The basic idea is that the client code (in the subscriber/observer) would request some activity to take place in the event publisher. The event publisher would then initiate its activity on a background thread. While the background task is running, the client code is free to proceed with other work, perhaps processing gestures from the user — which could include a request to cancel the asynchronous operation that is in progress. The publisher would need to implement logic that periodically checks to see if the client has requested cancellation and, if so, stop doing its work.\n\nA relatively easy and safe way to get started with asynchronous processing is to become familiar with the component. The component enables you to run a task asynchronously, report progress of the task (percentage towards completion), cancel the task after it has started, and report task completion (with return value). It is beyond the scope of this article to further present asynchronous processing models and multithreading alternatives and related issues.\n\nThere is nothing fundamentally unique about the core concepts involved in the creation of events, event handlers, and event handling methods in ASP.NET Web applications. Everything presented in this article about creating custom events and event handlers applies equally well to ASP.NET Web applications as it does to Windows Forms applications and C# code libraries. What is fundamentally different about ASP.NET Web applications is the context in which events are defined, raised, and handled. The stateless nature of HTTP and its request/response model, the role of the ASP.NET HTTP request pipeline, the role of ViewState, etc. all come into play — and with implications for the raising and handling of events. Beyond event fundamentals, as presented in this article, there are ASP.NET-specific event-related concepts such as client-side events (written in ECMA Script, VBScript, or JavaScript) postbacks, and event bubbling.\n\nThis article does not attempt to address events in the context of ASP.NET Web applications because a reasonable treatment would more than double the length of this article (and this article is already long enough!). It should be noted, however, that the fundamentals presented in this article will provide the beginning Web application developer with a solid foundation upon which to build.\n• Framework Design Guidelines - Conventions, Idioms, and Patterns for Reusable .NET Libraries, by Krzysztof Cwalina and Brad Abrams, 2006.\n• CLR via C#, 2nd Edition, by Jeffrey Richter, 2006.\n• C# In Depth, by Jon Skeet. Click here for early access edition information.\n• Pro C# 2005 and the .NET 2.0 Platform, by Andrew Troelsen, 2005.\n• Design Patterns - Elements of Reusable Object-Oriented Software, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, 1995.\n• Exploring the Observer Design Pattern, by Doug Purdy and Jeffrey Richter (MSDN): http://msdn2.microsoft. com/en-us/library/ms954621.aspx\n• C# Coding Standard - Guidelines and Best Practices, version 2.21, by Juval Lowy, 2007. Available at www.idesign.net\n• Version 2.0 - October 22, 2007 - added new section on cancellable events and expanded the presentation of 1.x vs. 2.0+ differences."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/1h17n9h/what_is_a_good_structure_for_a_c_windows_forms",
        "document": "Student here, I'll soon be starting a side-gig at a company making Windows Forms applications in C#. Now currently I'm practicing for said job and while making a bigger and more complex mock-application I've encountered the slump of \"What is a good structure?\".\n\nWhen I double click, for example, a button in the Form designer it gives me a method in Form.cs. But actually putting a lot of code in there seems like a terrible thing to do that encourages spaghetti since that is no actual structure. What if you've got several Forms the application switches between? What if you want to keep application settings throughout all forms? It seems like some form of controller that manages all forms would be a good idea, but then wouldn't that Controller class be completely overloaded with Methods and variables and be practically unreadable?\n\nSo yeah, what is, in general, a good structure for a Windows Forms application? Since Google results so far have been not satisfactory I thought I'd come here for answers. Thanks in advance :3"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.file.readalllines?view=net-9.0",
        "document": "A string array containing all lines of the file.\n\nThe following code example demonstrates the use of the ReadAllLines method to display the contents of a file. In this example a file is created, if it doesn't already exist, and text is added to it.\n\nThis method opens a file, reads each line of the file, and then adds each line as an element of a string array. It then closes the file. A line is defined as a sequence of characters followed by a carriage return ('\\r'), a line feed ('\n\n'), or a carriage return immediately followed by a line feed. The resulting string does not contain the terminating carriage return and/or line feed.\n\nThis method attempts to automatically detect the encoding of a file based on the presence of byte order marks. Encoding formats UTF-8 and UTF-32 (both big-endian and little-endian) can be detected.\n• How to: Write Text to a File\n• How to: Read and Write to a Newly Created Data File"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.file.writealltext?view=net-9.0",
        "document": "Creates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is truncated and overwritten. Creates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is truncated and overwritten. Creates a new file, writes the specified string to the file using the specified encoding, and then closes the file. If the target file already exists, it is truncated and overwritten. Creates a new file, writes the specified string to the file using the specified encoding, and then closes the file. If the target file already exists, it is truncated and overwritten.\n\nCreates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is truncated and overwritten. Public Shared Sub WriteAllText (path As String, contents As ReadOnlySpan(Of Char)) The characters to write to the file. The specified path, file name, or both exceed the system-defined maximum length. The specified path is invalid (for example, it is on an unmapped drive). An I/O error occurred while opening the file. specified a file that is read-only. specified a file that is hidden. This operation is not supported on the current platform. The caller does not have the required permission. is in an invalid format. This method uses UTF-8 encoding without a Byte-Order Mark (BOM), so using the GetPreamble() method will return an empty byte array. If it is necessary to include a UTF-8 identifier, such as a byte order mark, at the beginning of a file, use the WriteAllText(String, ReadOnlySpan<Char>, Encoding) method.\n\nCreates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is truncated and overwritten. Public Shared Sub WriteAllText (path As String, contents As String) The string to write to the file. .NET Framework and .NET Core versions older than 2.1: is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the GetInvalidPathChars() method. The specified path, file name, or both exceed the system-defined maximum length. The specified path is invalid (for example, it is on an unmapped drive). An I/O error occurred while opening the file. specified a file that is read-only. specified a file that is hidden. This operation is not supported on the current platform. The caller does not have the required permission. is in an invalid format. The caller does not have the required permission. The following code example demonstrates the use of the WriteAllText method to write text to a file. In this example a file is created, if it doesn't already exist, and text is added to it. using System; using System.IO; using System.Text; class Test { public static void Main() { string path = @\"c:\\temp\\MyTest.txt\"; // This text is added only once to the file. if (!File.Exists(path)) { // Create a file to write to. string createText = \"Hello and Welcome\" + Environment.NewLine; File.WriteAllText(path, createText); } // This text is always added, making the file longer over time // if it is not deleted. string appendText = \"This is extra text\" + Environment.NewLine; File.AppendAllText(path, appendText); // Open the file to read from. string readText = File.ReadAllText(path); Console.WriteLine(readText); } } open System open System.IO let path = @\"c:\\temp\\MyTest.txt\" // This text is added only once to the file. if File.Exists path |> not then // Create a file to write to. let createText = \"Hello and Welcome\" + Environment.NewLine File.WriteAllText(path, createText) // This text is always added, making the file longer over time // if it is not deleted. let appendText = \"This is extra text\" + Environment.NewLine File.AppendAllText(path, appendText) // Open the file to read from. let readText = File.ReadAllText path printfn $\"{readText}\" Imports System.IO Imports System.Text Public Class Test Public Shared Sub Main() Dim path As String = \"c:\\temp\\MyTest.txt\" ' This text is added only once to the file. If File.Exists(path) = False Then ' Create a file to write to. Dim createText As String = \"Hello and Welcome\" + Environment.NewLine File.WriteAllText(path, createText) End If ' This text is always added, making the file longer over time ' if it is not deleted. Dim appendText As String = \"This is extra text\" + Environment.NewLine File.AppendAllText(path, appendText) ' Open the file to read from. Dim readText As String = File.ReadAllText(path) Console.WriteLine(readText) End Sub End Class This method uses UTF-8 encoding without a Byte-Order Mark (BOM), so using the GetPreamble method will return an empty byte array. If it is necessary to include a UTF-8 identifier, such as a byte order mark, at the beginning of a file, use the WriteAllText(String, String, Encoding) method overload with UTF8 encoding. Given a string and a file path, this method opens the specified file, writes the string to the file, and then closes the file.\n\nCreates a new file, writes the specified string to the file using the specified encoding, and then closes the file. If the target file already exists, it is truncated and overwritten. Public Shared Sub WriteAllText (path As String, contents As ReadOnlySpan(Of Char), encoding As Encoding) The characters to write to the file. The encoding to apply to the string. The specified path, file name, or both exceed the system-defined maximum length. The specified path is invalid (for example, it is on an unmapped drive). An I/O error occurred while opening the file. specified a file that is read-only. specified a file that is hidden. The caller does not have the required permission. This operation is not supported on the current platform. is in an invalid format.\n\nCreates a new file, writes the specified string to the file using the specified encoding, and then closes the file. If the target file already exists, it is truncated and overwritten. Public Shared Sub WriteAllText (path As String, contents As String, encoding As Encoding) The string to write to the file. The encoding to apply to the string. .NET Framework and .NET Core versions older than 2.1: is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the GetInvalidPathChars() method. The specified path, file name, or both exceed the system-defined maximum length. The specified path is invalid (for example, it is on an unmapped drive). An I/O error occurred while opening the file. specified a file that is read-only. specified a file that is hidden. This operation is not supported on the current platform. The caller does not have the required permission. is in an invalid format. The caller does not have the required permission. The following code example demonstrates the use of the WriteAllText method to write text to a file. In this example a file is created, if it doesn't already exist, and text is added to it. using System; using System.IO; using System.Text; class Test { public static void Main() { string path = @\"c:\\temp\\MyTest.txt\"; // This text is added only once to the file. if (!File.Exists(path)) { // Create a file to write to. string createText = \"Hello and Welcome\" + Environment.NewLine; File.WriteAllText(path, createText, Encoding.UTF8); } // This text is always added, making the file longer over time // if it is not deleted. string appendText = \"This is extra text\" + Environment.NewLine; File.AppendAllText(path, appendText, Encoding.UTF8); // Open the file to read from. string readText = File.ReadAllText(path); Console.WriteLine(readText); } } open System open System.IO open System.Text let path = @\"c:\\temp\\MyTest.txt\" // This text is added only once to the file. if File.Exists path |> not then // Create a file to write to. let createText = \"Hello and Welcome\" + Environment.NewLine File.WriteAllText(path, createText, Encoding.UTF8) // This text is always added, making the file longer over time // if it is not deleted. let appendText = \"This is extra text\" + Environment.NewLine File.AppendAllText(path, appendText, Encoding.UTF8) // Open the file to read from. let readText = File.ReadAllText path printfn $\"{readText}\" Imports System.IO Imports System.Text Public Class Test Public Shared Sub Main() Dim path As String = \"c:\\temp\\MyTest.txt\" Dim sw As StreamWriter ' This text is added only once to the file. If File.Exists(path) = False Then ' Create a file to write to. Dim createText As String = \"Hello and Welcome\" + Environment.NewLine File.WriteAllText(path, createText, Encoding.UTF8) End If ' This text is always added, making the file longer over time ' if it is not deleted. Dim appendText As String = \"This is extra text\" + Environment.NewLine File.AppendAllText(path, appendText, Encoding.UTF8) ' Open the file to read from. Dim readText As String = File.ReadAllText(path) Console.WriteLine(readText) End Sub End Class Given a string and a file path, this method opens the specified file, writes the string to the file using the specified encoding, and then closes the file. The file handle is guaranteed to be closed by this method, even if exceptions are raised."
    },
    {
        "link": "https://stackoverflow.com/questions/41700898/how-to-read-write-files-in-net-core",
        "document": "What are the options to read/write files in .Net Core?\n\nI am working on my first .Net Core app and looking for / functions ( from ) alternatives."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-read-and-write-a-text-file-in-c-sharp",
        "document": "How to Read and Write a Text File in C#?\n\nTermination of a program leads to the deletion of all data related to it. Therefore, we need to store the data somewhere. Files are used for permanently storing and sharing data. C# can be used to retrieve and manipulate data stored in text files.\n\nReading a Text file: The file class in C# defines two static methods to read a text file namely File.ReadAllText() and File.ReadAllLines().\n• The File.ReadAllText() reads the entire file at once and returns a string. We need to store this string in a variable and use it to display the contents onto the screen.\n• The File.ReadAllLines() reads a file one line at a time and returns that line in string format. We need an array of strings to store each line. We display the contents of the file using the same string array.\n\nThere is another way to read a file and that is by using a StreamReader object. The StreamReader also reads one line at a time and returns a string. All of the above-mentioned ways to read a file are illustrated in the example code given below.\n\nTo run this program, save the file with .cs extension and then can execute using csc filename.cs command on cmd. Or you can use the Visual Studio. Here, we have a text file named as Textfile.txt which have the content shown in the output.\n\nWriting a Text File: The File class in C# defines two static methods to write a text file namely File.WriteAllText() and File.WriteAllLines().\n• The File.WriteAllText() writes the entire file at once. It takes two arguments, the path of the file and the text that has to be written.\n• The File.WriteAllLines() writes a file one line at a time. It takes two arguments, the path of the file and the text that has to be written, which is a string array.\n\nThere is another way to write to a file and that is by using a StreamWriter object. The StreamWriter also writes one line at a time. All of the three writing methods create a new file if the file doesn’t exist, but if the file is already present in that specified location then it is overwritten. All of the above-mentioned ways to write to a text file are illustrated in the example code given below.\n\nTo run this program, save the file with .cs extension and then can execute using csc filename.cs command on cmd. Or you can use the Visual Studio.\n\nIn case you want to add more text to an existing file without overwriting the data already stored in it, you can use the append methods provided by the File class of System.IO."
    },
    {
        "link": "https://mbarkt3sto.hashnode.dev/c-the-most-possible-methods-for-writing-and-reading-files",
        "document": ""
    }
]