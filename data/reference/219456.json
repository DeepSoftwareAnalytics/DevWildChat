[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/controls/list-view-controls-overview",
        "document": "A list-view control is a window that displays a collection of items. List-view controls provide several ways to arrange and display items and are much more flexible than simple List Boxes. For example, additional information about each item can be displayed in columns to the right of the icon and label.\n\nList-view controls can display items in five different views. The control's window style specifies the default view. Additional window styles specify the alignment of items and control-specific features. The following table describes the views.\n\nThe following screen shots use views to show different amounts of information about each of seven pets. The views demonstrate how the information might appear on Windows Vista. The visual styles for the control have been set to the \"Explorer\" theme by using SetWindowTheme.\n\nThe following screen shot shows the details view.\n\nThe following screen shot shows the icon view.\n\nThe following screen shot shows the list view.\n\nThe following screen shot shows the tile view.\n\nYou can change the view type after you create a list-view control. To retrieve and change the window style, use the GetWindowLong and SetWindowLong functions. To determine the window styles of the current view, use the LVS_TYPEMASK value.\n\nYou can control the way items are arranged in icon or small icon view by specifying either the LVS_ALIGNTOP (default) or LVS_ALIGNLEFT window style.\n\nYou can change the alignment after you create a list-view control. To determine the current alignment, use the LVS_ALIGNMASK value.\n\nAdditional window styles provide other options, such as whether a user can edit labels or select more than one item at a time. For a complete list, see List-View Window Styles.\n\nThe extended list-view control styles provide options such as check boxes, flat scroll bars, grid lines, and hot-tracking. For a complete list, see Extended List-View Styles. You do not access extended list-view styles in the same manner as standard window styles. You do not use the GetWindowLong and SetWindowLong functions to make extended style changes.\n\nThere are two messages that set and retrieve extended style information, LVM_SETEXTENDEDLISTVIEWSTYLE and LVM_GETEXTENDEDLISTVIEWSTYLE. Instead of sending the messages explicitly, you can use the following corresponding macros: ListView_SetExtendedListViewStyle, ListView_SetExtendedListViewStyleEx, and ListView_GetExtendedListViewStyle.\n\nA virtual list view is a list-view control that has the LVS_OWNERDATA style. This style enables the control to handle millions of items because the owner receives the burden of managing item data. This allows you to use the virtual list-view control with large databases of information, where specific methods of data access are already in place.\n\nA virtual list-view control maintains very little item information itself. Except for the item selection and focus information, the owner of the control must manage all item information. Other processes request item information from the owner by using LVN_GETDISPINFO notification codes.\n\nBecause this type of list control is intended for large data sets, it is recommended that you cache requested item data to improve retrieval performance. The list view provides a cache-hinting mechanism to assist in optimizing the cache. The hint is implemented in the form of an LVN_ODCACHEHINT notification code.\n\nYou create virtual list-view controls using the CreateWindow or CreateWindowEx function, specifying the LVS_OWNERDATA window style as part of the dwStyle function parameter. Dynamically switching to and from the LVS_OWNERDATA style is not supported.\n\nYou can use the LVS_OWNERDATA style in combination with most other window styles, except the LVS_SORTASCENDING or LVS_SORTDESCENDING style. All virtual list-view controls default to the LVS_AUTOARRANGE style.\n\nTo enable items to be displayed in the list, you must first send the LVM_SETITEMCOUNT message, either explicitly or by using the ListView_SetItemCountEx macro.\n\nThe following messages are not supported under the LVS_OWNERDATA style: LVM_ENABLEGROUPVIEW, LVM_GETITEMTEXT, LVM_SETTILEINFO, and LVM_MAPIDTOINDEX.\n\nAll four of the list-view styles—icon, small icon, list, and report view—support the LVS_OWNERDATA style. List-view controls that have the LVS_OWNERDATA style do not store any item-specific information. Therefore, the only valid item state flags that you can apply to an item are LVIS_SELECTED and LVIS_FOCUSED. No other state information is stored. In particular, the list-view control does not maintain state or overlay images for each item. However, you can have the list-view control query your application for these images by sending it an LVM_SETCALLBACKMASK message.\n\nMost list-view control messages and the associated macros are fully supported. However, some messages have limitations or are unsupported when you use the LVS_OWNERDATA style. The following table summarizes the affected messages.\n\nList-view controls with the LVS_OWNERDATA style send the same notification codes as other list-view controls and two additional ones: LVN_ODCACHEHINT and LVN_ODFINDITEM. The following are the most common notifications that the list-view control with the LVS_OWNERDATA style sends.\n\nA list-view control with the LVS_OWNERDATA style produces a large number of LVN_GETDISPINFO notification codes and, to assist in optimizing the cache, an LVN_ODCACHEHINT message. LVN_ODCACHEHINT messages provide information about the recommended items to include within the cache. These messages are sent as WM_NOTIFY messages, with the lParam value acting as the address of an NMLVCACHEHINT structure.\n\nThe NMLVCACHEHINT structure includes two integer members, iFrom and iTo, that represent the inclusive endpoints of a range of items that most likely will be needed. The owner must be prepared to load the cache with the item information for each of the items within the recommended range.\n\nThe list control often needs item information for the first item (offset 0). The LVN_ODCACHEHINT notification code might not always include item 0, but it must always be included in the cache.\n\nThe last items in the list are accessed often. Therefore, the owner might want to keep a second cache that includes the items at the end of the list. The requested range from LVN_ODCACHEHINT can be checked against the end cache to make it available automatically instead of reloading the same end range each time.\n\nList-view controls support working areas, which are rectangular virtual areas that the list-view control uses to arrange its items. A working area is not a window and cannot have a visible border. By default, the list-view control has no working areas. By creating a working area, you can create an empty border on the left, top, or right of the items or cause a horizontal scroll bar to be displayed when there normally would not be one.\n\nWhen a working area is created, items that lie within the working area become members of the working area. Similarly, if an item is moved into a working area, the item becomes a member of that working area. If an item does not lie within any working area, it automatically becomes a member of the first (index 0) working area. To place new item within a specific working area, you must first create the item and then use either the LVM_SETITEMPOSITION or the LVM_SETITEMPOSITION32 message to move it into the desired working area.\n\nThe following illustration is an example of a list-view control that contains four working areas, each in a different quadrant of the client area.\n\nMultiple working areas can be used for creating different areas within one view. You can create areas in a single view that have different meanings. For example, a view of a file system might have an area for read/write files and another area for read-only files. The user can categorize items by placing them in different working areas. If a file is moved into the read-only area, it will automatically become read-only.\n\nMultiple working areas can intersect, but any items that lie within the intersection become members of the area with the lower index; therefore, it is best to avoid this situation. When sorting multiple work areas, the items are sorted compared to the other items in the same working area.\n\nThe number of working areas can be retrieved with the LVM_GETNUMBEROFWORKAREAS message. The working areas are changed with the LVM_SETWORKAREAS message and can be retrieved with the LVM_GETWORKAREAS message. Both of these messages take the address of an array of RECT structures as the lParam and the number of RECT structures as the wParam. The left and top members of these structures specify the coordinates of the upper-left corner (the origin) of the working area, and the right and bottom members specify the lower-right corner of the working area. All the coordinates are in client coordinates of the list view. The maximum number of working areas allowed is defined by the LV_MAX_WORKAREAS value.\n\nChanging the working area has no effect on list-view controls that have the LVS_LIST or LVS_REPORT view, but the working areas will be maintained when the view type is changed. With the LVS_ICON and LVS_SMALLICON views, the working area can be modified to change the way the items are displayed. Making the width of the working area (right - left) greater than the client width of the control causes the items to be wrapped at that width and the horizontal scroll bar to be displayed. Making the width of the working area narrower than the width of the control's client area causes the items to be wrapped within the working area and not the client area. Setting the left or top member to a positive value causes the items to be displayed starting at the working area, creating an empty space between the edge of the control and the items. An empty space can also be created between the right edge of the control and the items by making the width of the working area less than the client width of the control.\n\nBy default, a list-view control does not display item images. To display item images, you must create image lists and associate them with the control. A list-view control can have three image lists:\n• An image list that contains full-sized icons displayed when the control is in icon view.\n• An image list that contains small icons displayed when the control is in small icon view, list view, or report view.\n• An image list that contains state images, which are displayed to the left of the full-sized or small icon. You can use state images, such as checked and cleared check boxes, to indicate application-defined item states. State images are displayed in icon view, small icon view, list view, and report view.\n\nThe full-sized and small icon image lists can also contain overlay images, which are designed to be drawn transparently over the item icons.\n\nTo use overlay images in a list-view control:\n• Call the ImageList_SetOverlayImage function to assign an overlay image index to an image in the full-sized and small icon image lists. An overlay image is identified by a one-based index.\n• You can associate an overlay image index with an item when you call the ListView_InsertItem or ListView_SetItem macro. Use the INDEXTOOVERLAYMASK macro to specify an overlay image index in the state member of the item's LVITEM structure. You must also set the LVIS_OVERLAYMASK bits in the stateMask member.\n\nIf a state image list is specified, a list-view control reserves space to the left of each item's icon for a state image.\n\nTo associate a state image with an item, use the INDEXTOSTATEIMAGEMASK macro to specify a state image index in the state member of the LVITEM structure. The index identifies an image in the control's state image list. Although image list indexes are zero-based, the control uses one-based indexes to identify state images. A state image index of zero indicates that an item has no state image.\n\nBy default, when a list-view control is destroyed, it destroys the image lists assigned to it. However, if a list-view control has the LVS_SHAREIMAGELISTS window style, the application is responsible for destroying the image lists when they are no longer in use. You should specify this style if you assign the same image lists to multiple list-view controls; otherwise, more than one control might try to destroy the same image list.\n\nEach item in a list-view control has an icon, a label, a current state, and an application-defined value. By using list-view messages, you can add, modify, and delete items as well as retrieve information about items.\n\nEach item can have one or more subitems. A subitem is a string that, in report view, is displayed in a column separate from the item's icon and label. To specify the text of a subitem, use the LVM_SETITEMTEXT or LVM_SETITEM message. All items in a list-view control have the same number of subitems. The number of subitems is determined by the number of columns in the list-view control. When you add a column to a list-view control, you specify its associated subitem index.\n\nThe LVITEM structure defines a list-view item or subitem. The iItem member is the zero-based index of the item. The iSubItem member is the one-based index of a subitem or zero if the structure contains information about an item. Additional members specify the item's text, icon, state, and item data. Item data is an application-defined value associated with a list-view item.\n\nTo add an item to a list-view control, use the LVM_INSERTITEM message, specifying the address of an LVITEM structure. Before adding multiple items, you can send the control an LVM_SETITEMCOUNT message, specifying the number of items the control will ultimately contain. This message enables the list-view control to reallocate its internal data structures only once rather than every time you add an item. You can determine the number of items in a list-view control by using the LVM_GETITEMCOUNT message. If you are adding a large number of items to a list-view control, you can speed up the process by disabling redrawing before adding the items, then enable redrawing after the items are added. Use the WM_SETREDRAW message to enable and disable redrawing.\n\nTo change the attributes of a list-view item, use the LVM_SETITEM message, specifying the address of an LVITEM structure. The mask member of this structure specifies the item attributes you want to change. For example, to change only the text of an item or subitem, use the LVM_SETITEMTEXT message.\n\nTo retrieve information about a list-view item, use the LVM_GETITEM message, specifying the address of the LVITEM structure to fill in. The mask member of this structure specifies the item attributes to be retrieved. To retrieve only an item or subitem's text, use the LVM_GETITEMTEXT message.\n\nTo delete a list-view item, use the LVM_DELETEITEM message. You can delete all items in a list-view control by using the LVM_DELETEALLITEMS message.\n\nAn item's state is a value that specifies the item's availability, indicates user actions, or otherwise reflects the item's status. A list-view control changes some state bits, such as when the user selects an item. An application might change other state bits to disable or hide the item or to specify an overlay image or state image. For more information about overlay images and state images, see List-View Image Lists.\n\nAn item's state is specified by the state member of the LVITEM structure. When you specify or change an item's state, the stateMask member specifies which state bits you need to change. You can change an item's state by using the LVM_SETITEMSTATE message. You can specify an item's state when you create it or when you change its attributes by using the LVM_SETITEM message. To determine an item's current state, use the LVM_GETITEMSTATE or LVM_GETITEM message.\n\nTo set an item's overlay image, the stateMask member of the LVITEM structure must include the LVIS_OVERLAYMASK value, and the state member must include the one-based index of the overlay image shifted left 8 bits by using the INDEXTOOVERLAYMASK macro. The index can be zero to specify no overlay image.\n\nTo set an item's state image, the stateMask member of the LVITEM structure must include the LVIS_STATEIMAGEMASK value, and the state member must include the one-based index of the state image shifted left 12 bits by using the INDEXTOSTATEIMAGEMASK macro. The index can be zero to specify no state image.\n\nFor each of its items, a list-view control typically stores the label text, the image list index of the item's icons, and a set of bit flags for the item's state. You can define callback items or change the control's callback mask to indicate that the application, rather than the control, stores some or all of this information. You might want to use callbacks if your application stores some of this information.\n\nA callback item in a list-view control is an item for which the application stores the text or icon index, or both. You can define callback items when you send the LVM_INSERTITEM message to add an item to the list-view control. If the application stores the text for the item or subitem, set the pszText member of the item's LVITEM structure to LPSTR_TEXTCALLBACK. If the application stores the icon index for an item, set the iImage member of the item's LVITEM structure to I_IMAGECALLBACK.\n\nThe callback mask of a list-view control is a set of bit flags that specify the item states for which the application, rather than the control, stores the current data. The callback mask applies to all of the control's items, unlike the callback item designation, which applies to a specific item. The callback mask is zero by default, meaning that the list-view control stores all item state information. After creating a list-view control and initializing its items, you can send the LVM_SETCALLBACKMASK message to change the callback mask. To retrieve the current callback mask, send the LVM_GETCALLBACKMASK message.\n\nWhen a list-view control must display or sort a list-view item for which the application stores callback information, the control sends the LVN_GETDISPINFO notification code to the control's parent window. This message specifies an NMLVDISPINFO structure that contains the type of information required and identifies the item or subitem to retrieve. The parent window must process LVN_GETDISPINFO to provide the requested data.\n\nIf the list-view control detects a change in an item's callback information, such as a change in the text, icon, or state information, the control sends an LVN_SETDISPINFO notification code to notify you of the change.\n\nIf you change a callback item's attributes or state bits, you use the LVM_UPDATE message to force the control to repaint the item. This message also causes the control to arrange its items if it has the LVS_AUTOARRANGE style. You can use the LVM_REDRAWITEMS message to redraw a range of items by invalidating the corresponding portions of the list-view control's client area.\n\nBy effectively using callback items and the callback mask, you can ensure that each item attribute is maintained in only one place. Doing this can simplify your application, but the only space saved is the memory that would otherwise be required to store item labels and subitem text.\n\nEvery list-view item has a position and size, which you can retrieve and set using messages. You can also determine which item, if any, is at a specified position. The position of list-view items is specified in view coordinates, which are client coordinates offset by the scroll position.\n\nTo retrieve and set an item's position, use the LVM_GETITEMPOSITION and LVM_SETITEMPOSITION messages. LVM_GETITEMPOSITION works for all views, but LVM_SETITEMPOSITION works only for icon and small icon views.\n\nYou can determine which item, if any, is at a particular location by using the LVM_HITTEST message.\n\nTo retrieve the bounding rectangle for a list item or only for its icon or label, use the LVM_GETITEMRECT message.\n\nYou can use list-view messages to arrange and sort items and to find items based on their attributes or positions. Arranging repositions items to align on a grid, but the indexes of the items do not change. Sorting changes the sequence of items (and their corresponding indexes) and then repositions them accordingly. You can arrange items only in icon and small icon views, but you can sort items in any view. To find items, you send list-view messages that specify an item location or property.\n\nTo arrange items, use the LVM_ARRANGE message. You can ensure that items are arranged at all times by specifying the LVS_AUTOARRANGE window style.\n\nTo sort items, use the LVM_SORTITEMS message. When you sort using this message, you specify an application-defined callback function that the list-view control calls to compare the relative order of any two items. The control passes to the comparison function the item data associated with each of the two items. The item data is the value that was specified in the lParam member of the item's LVITEM structure when it was inserted into the list. By specifying the appropriate item data and supplying an appropriate comparison function, you can sort items by their label, by any subitem, or by any other property. Note that sorting items does not reorder the corresponding subitems. When items are reordered, their corresponding subitems are carried with them; that is, whole rows are kept together. To order the columns separately from one another, detaching the subitems from their items, you must regenerate the columns after sorting using LVM_SETITEM.\n\nYou can ensure that a list-view control is always sorted by specifying the LVS_SORTASCENDING or LVS_SORTDESCENDING window style. Controls with these styles use the label text of the items to sort them in ascending or descending order. You cannot supply a comparison function when using these window styles. If a list-view control has either of these styles, an LVM_INSERTITEM message will fail if you try to insert an item that has LPSTR_TEXTCALLBACK as the pszText member of its LVITEM structure.\n\nYou can find a list-view item with specific properties by using the LVM_FINDITEM message. You can find a list-view item that is in a specified state and has a specified relationship to a given item by using the LVM_GETNEXTITEM message. For example, you can retrieve the next selected item to the right of a specified item.\n\nColumns control the way items and their subitems are displayed in report view. Each column has a title and width and is associated with a specific subitem; subitem zero is the item's icon and label. The attributes of a column are defined by an LVCOLUMN structure.\n\nTo add a column to a list-view control, use the LVM_INSERTCOLUMN message. To delete a column, use the LVM_DELETECOLUMN message.\n\nYou can retrieve and change the properties of an existing column by using the LVM_GETCOLUMN and LVM_SETCOLUMN messages. To retrieve or change a column's width, use the LVM_GETCOLUMNWIDTH and LVM_SETCOLUMNWIDTH messages.\n\nUnless the LVS_NOCOLUMNHEADER window style is specified, column headers appear in report view. The user can click a column header, causing an LVN_COLUMNCLICK notification code to be sent to the parent window. Typically, the parent window sorts the list-view control by the specified column when this clicking occurs. The user can also drag the column guides between the headers to size the columns.\n\nList-view controls can display images next to column titles. To implement this feature, specify the LVCF_IMAGE value and assign the index of the image to the iImage member in the LVCOLUMN structure.\n\nList-view controls can set the order in which columns are displayed. To implement this feature, specify the LVCF_ORDER value and assign the column order to the iOrder member in the LVCOLUMN structure. The column order is zero-based and is in left-to-right order. For example, zero indicates the leftmost column.\n\nUnless the LVS_NOSCROLL window style is specified, a list-view control can be scrolled to show more items than can fit in the client area of the control. You can retrieve a list-view control's scroll position and related information, scroll a list-view control by a specified amount, or scroll a list-view control so that a specified list item is visible.\n\nIn icon view or small icon view, the current scroll position is defined by the view origin. The view origin is the set of coordinates, relative to the visible area of the list-view control, that correspond to the view coordinates (0, 0). To retrieve the current view origin, use the LVM_GETORIGIN message. This message should be used only in icon or small icon view; it returns an error in list or report view.\n\nIn list or report view, the current scroll position is defined by the top index. The top index is the index of the first visible item in the list-view control. To retrieve the current top index, use the LVM_GETTOPINDEX message. This message returns a valid result only in list or report view; it returns zero in icon or small icon view.\n\nYou can use the LVM_GETVIEWRECT message to retrieve the bounding rectangle of all items in a list-view control, relative to the visible area of the control.\n\nThe LVM_GETCOUNTPERPAGE message returns the number of items that fit in one page of the list-view control. This message returns a valid result only in list and report views; in icon and small icon views, it returns the total number of items.\n\nTo scroll a list-view control by a specific amount, use the LVM_SCROLL message. Using the LVM_ENSUREVISIBLE message, you can scroll the list-view control, if necessary, to ensure that a specified item is visible.\n\nA list-view control that has the LVS_EDITLABELS window style enables a user to edit item labels in place. The user begins editing by clicking the label of an item that has the focus. Alternatively, an application can begin editing automatically by using the LVM_EDITLABEL message. The list-view control notifies the parent window when editing begins and when it is canceled or completed. When editing is completed, the parent window is responsible for updating the item's label, if appropriate.\n\nWhen label editing begins, an edit control is created, positioned, and initialized. Before it is displayed, the list-view control sends its parent window an LVN_BEGINLABELEDIT notification code. If you need to modify the label editing process, you can implement a handler for this notification.\n\nOne use for an LVN_BEGINLABELEDIT notification handler is to control which labels the user can edit. To prevent label editing, return a nonzero value. To customize label editing, have the notification handler retrieve a handle to the edit control by sending an LVM_GETEDITCONTROL message to the list-view control. Once you have that handle, you can customize the edit control by sending the usual EM_XXX messages. For instance, to limit the amount of text a user can enter, send the edit control an EM_LIMITTEXT message. You can change the edit control's default text with SetWindowText. You can even subclass the edit control to intercept and discard invalid characters.\n\nWhen label editing is canceled or completed, a list-view control sends its parent window an LVN_ENDLABELEDIT notification code. The lParam parameter is the address of an NMLVDISPINFO structure. The item member of this structure is an LVITEM structure whose iItem member identifies the item. If editing is canceled, the pszText member of the LVITEM structure is NULL; otherwise, pszText is the address of the edited text. The parent window is responsible for updating the item's label if it wants to keep the new label.\n\nAn application can retrieve and set three colors for a list-view control.\n\nTo customize the appearance of a list-view control more significantly, use NM_CUSTOMDRAW (list view) or use visual styles (see Visual Styles and Enabling Visual Styles).\n\nThe grouping features of the list-view control enable you to visually group logically related sets of items. Groups can be created based on item properties, attributes, or other characteristics. These groups are typically separated on the screen by a horizontal header that contains the name of the group. The following screen shot shows grouped items.\n\nYou use the LVGROUP structure to store information about a group, such as the header and footer text, the current state of the group, and so on. The grouping API includes messages that enable you to manage groups and group elements by adding items to groups, adding groups to views, sorting group items, and querying groups for item size and other information. For example, you can set and retrieve display parameters for each group by using the ListView_SetGroupMetrics and ListView_GetGroupMetrics macros.\n\nGrouping is available in all views except list view. It is not available on controls that have the LVS_OWNERDATA style.\n\nFor more information, see Using List-View Controls.\n\nInsertion marks show users where dragged items will be placed. Insertion marks currently display when the user drags an item into the Start menu or Quick Launch bar. The insertion mark also works for lists that are set to autoarrange. When a user drags an item to a point between two other items, the insertion mark shows the item's expected new location. The following screen shot shows an insertion mark.\n\nThe insertion mark API elements enable placement of insertion marks by providing messages and flags that perform hit detection, that specify the location and appearance of the insertion mark by item, and that query for information about the current size and appearance of the insertion mark."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.listview.virtualmode?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nif ListView uses data-management operations that you provide; otherwise, . The default is .\n\nThis example illustrates a simple ListView whose contents are the first ten thousand squares. It handles searching and uses a cache for increased performance.\n\nSetting the VirtualMode property to puts the ListView into virtual mode. In Virtual mode, the normal Items collection is unused. Instead, ListViewItem objects are created dynamically as the ListView requires them.\n\nVirtual mode can be useful under many circumstances. If a ListView object must be populated from a very large collection already in memory, creating a ListViewItem object for each entry can be wasteful. In virtual mode, only the items required are created. In other cases, the values of the ListViewItem objects may need to be recalculated frequently, and doing this for the whole collection would produce unacceptable performance. In virtual mode, only the required items are calculated.\n\nIn order to use virtual mode, you must handle the RetrieveVirtualItem event, which is raised every time the ListView requires an item. This event handler should create the ListViewItem object that belongs at the specified index. In addition, the VirtualListSize property must be set to the size of the virtual list.\n\nHandling the SearchForVirtualItem event enables searching in virtual mode. If this event is not handled, the FindItemWithText and FindNearestItem methods will return .\n\nYou can handle the CacheVirtualItems event in order to maintain a cache of ListViewItem objects. If the calculation or lookup to create a ListViewItem object is expensive, maintaining a cache can improve performance.\n\nIf the View property is set to Tile, the value will automatically be changed to LargeIcon when VirtualMode is set to .\n\nIn virtual mode, the Items collection is disabled. Attempting to access it results in an InvalidOperationException. The same is true of the CheckedItems collection and the SelectedItems collection. If you want to retrieve the selected or checked items, use the SelectedIndices and CheckedIndices collections instead."
    },
    {
        "link": "http://componentowl.com/better-listview/releases%3Fsince=1.40.html",
        "document": "What's New in Better ListView since version 1.40\n\n* Fixed scrolling when all items are unselectable\n\n* Fixed drag selections (not all intersecting items were always selected) \n\n* Fixed sub-item focus rectangle display in Details view when FullRowSelect is false \n\n* Fixed sub-item background display in Details view when FullRowSelect is false \n\n* Fixed text highlighting not updating properly after automatic column resizing\n\n* Added column unsorting by middle mouse button \n\n \n\n* Fixed hit test on items in List view\n\n* Added overlay image alignments support for columns and items in Detail view \n\n \n\n* Fixed dragging empty selection when MultiSelect=False and user dragged item with Control key pressed\n\n* Added sub-item check boxes and radio buttons support \n\n* Added support for custom disabled check boxes and radio buttons \n\n \n\n* Fixed ObjectDisposedException being raised when closing Form right after clicking an item \n\n* Fixed RemoveSearchHighlight to work in item hierarchy \n\n* Fixed drawing of group header when the group is focused by keyboard\n\nChanges in version 3.9.1 (May 19, 2014)\n\n* Fixed disappearing items after scrolling and item reordering in LargeIcon view with multi-line items\n\n* Added integration with Visual Studio 2013 \n\n* Added custom date format support in BetterListViewDateTimePickerEmbeddedControl \n\n* Added ItemReordered event \n\n \n\n* Fixed FindItemsWithText method call when working with invisible items \n\n* Fixed saving form after editing tooltips in Windows Forms Designer\n\n* Fixed sorting of items with missing sub-items or Key set to null\n\n* Fixed pixel precision bug in column selection \n\n* Fixed proper scrolling on combined items using EnsureVisible method \n\n* Fixed drawing item selection on MouseUp in some cases (click directly on text of previously selected item in Details view)\n\n* Fixed search highlight in other than Details view\n\n* Added HotTracking property \n\n* Added SmoothScroll property \n\n \n\n* Improved responsiveness (optimized control refreshing on control state transitions) \n\n \n\n* Fixed BetterListViewColumnHeader.DisplayIndex property value not being updated at the time of ColumnHeaderReordered event \n\n* Fixed bug in hit test invalidation optimization causing slower redrawing when mouse moves over large control with many items and columns\n\n* Removed beep when no item is found though single keypress (keyboard search) \n\n \n\n* Fixed keyboard search\n\nChanges in version 3.7.3 (May 30, 2013)\n\n* Fixed keyboard search with 'Substring' setting and single keystroke \n\n* Fixed rare but possible NullRefereceException in OnMouseUp method\n\n* SuspendSelectionChanged renamed to SuppressSelectionChanged \n\n \n\n* Fixed selection display when FullRowSelect is false in Details view \n\n* Fixed grid lines display when HeaderStyle is None in Details view \n\n* Fixed closing floating window in Samples Explorer\n\n* Fixed possible exception when invoking context menu on an item by mouse \n\n* Fixed multi-line text when TextTrimming is set to None \n\n* Fixed public constructor parameters being obfuscated\n\n* Added BetterListViewHitTestInfo.MousePosition property \n\n \n\n* Fixed unhandled exception on web request timeout when activating over web proxy\n\n* Added separate column auto resizing for column header, column content or both (BetterListViewColumnHeaderAutoResizeStyle changed to flags enum) \n\n \n\n* Fixed DoubleClick and ItemActivate not raised when the redrawing takes too much time between successive clicks \n\n* Fixed Combined Items \n\n \n\n * Fixed check boxes and expand buttons of children in combined items being inactive \n\n * Fixed combined item not being properly measured when its child has been made invisible \n\n * Fixed insertion mark display on combined items \n\n \n\n* Fixed online activation from behind a web proxy \n\n* Fixed binding DataTable in the Data Binding sample \n\n* Fixed unnecessary refreshes during binding a table with multiple columns\n\n* Added possibility of changing label being edited by setting Label property in BeforeLabelEdit and AfterLabelEditCancel event data \n\n \n\n* Improved Visual Studio Toolbox integration for more versions of .NET Framework, including Client Profile \n\n \n\n* Fixed possible NullReferenceException during clicking on column headers (negative mouse cursor coordinates probably due to mouse movement)\n\n* Added 'Search Highlight' feature \n\n \n\n * Added SearchHighlight, SearchHighlightColor, SearchHighlightBorderColor, SearchHighlightTextColor properties \n\n * Added BetterListViewSearchOptions.UpdateSearchHighlight enum value \n\n * Added BetterListViewSubItemBounds.BoundsSearchHighlight property \n\n \n\n* Fixed IndexOf() method on collections to return -1 if an element is not contained in the collection \n\n* Fixed case where clickable/sortable/unsortable column is clicked and mouse cursor moves quickly away \n\n* Fixed column auto resizing to account for groups and hierarchical items \n\n* Fixed not allowing to put duplicate references in SelectedItems.Set(IEnumerable\n\n* Fixed moving mouse cursor over an item that is partially scrolled out so that the text boundaries have negative top coordinate \n\n* Fixed ItemActivate not raised on slow computers when item is double-clicked and mouse cursor moved quickly away\n\n* Added ColumnReorder event next to existing ColumnReordered event to allow cancelling column reordering \n\n* Added keyboard-invoked context menu placements (ContextMenuStripPlacement property) \n\n \n\n* Improved context menu placement: Keyboard-invoked context menu is displayed under the first visible selected item \n\n* Improved grid lines appearance \n\n* Improved item parts alignment when expand buttons are present \n\n \n\n* Fixed possible improper behavior on slower computers (or lagging code because of too much drawing etc.) \n\n \n\n * Fixed item not selected clicked and mouse cursor is immediately moved away \n\n * Fixed drag selection commited when item is almost double-clicked (second mouse button release not done) and then mouse is moved before button is released \n\n * Fixed DoubleClick event raised after any amount of time when item is reordered with incomplete double-click (second mouse button release not done) and then other item is clicked\n\n* Added FIPS-compliance (improved security and compatibility) \n\n \n\n* Improved horizontal multi-line text alignment \n\n* Improved Samples Explorer \n\n \n\n* Properties VisibleColumns, VisibleGroups, VisibleItems hidden from Properties window in the WinForms Designer \n\n \n\n* Fixed commencing mouse drag selecting on double-click and mouse move in quick succession \n\n* Fixed scrolling to parent item vertically when only child item have been selected \n\n* Fixed AutoResizeColumns updating just the last column \n\n* Fixed column header sort glyph placement when the column is sorted and no items are present in the list \n\n* Fixed image border color not changing when ImageBorderColor layout property changed\n\n* Added support for TypeConverters when adding custom objects to collections \n\n \n\n* Improved horizontal scrolling on items within item hierarchy \n\n \n\n* Fixed reordering item in an empty or collapsed group\n\n* Allowed setting Font property to null on column headers, groups, items and sub-items \n\n \n\n* Fixed cycling between items during keyboard search \n\n* Fixed code generation for SearchSettings property \n\n* Fixed NullReferenceException when edited sub-item is switched during label editing \n\n* Fixed multi-line text wrapping when BetterListViewItem.CheckBoxAppearance is set to None \n\n* Fixed sorted column background being drawn in other than Details view \n\n* Fixed unsufficient vertical scroll bar maximum when column headers are added in first initialization between BeginUpdate()/EndUpdate() \n\n* Fixed double-click on column containing hidden check box\n\n* Added HeaderStyle property \n\n* Added BetterListViewColumnHeaderStyle.None enum value (indicates that column header is not displayed, but corresponding sub-items are) \n\n* Added BetterListViewColumnHeaderStyle.Hidden enum value (indicates that column header is hidden, including sub-items) \n\n \n\n* Improved mouse and keyboard selections to behave more like Windows Explorer \n\n* Merged BetterListViewColumnHeaderStyle.Hidden enum value and BetterListViewColumnHeader.Value \n\n* Control+Shift modifier keys behave the same way as Control modifier key alone in Multi-column Sorting \n\n* Hidden ShowItemExpandButtons property in Express edition \n\n \n\n* Fixed possible multiselection using Control+click when MultiSelect is false\n\n* Fixed selected child items not removed from SelectedItems collection after BetterListView.Items.Clear() call \n\n* Fixed designer not supporting some BetterListViewColumnHeaderStyle enum values well\n\n* Added BetterListViewDropPart.On \n\n* Added BetterListViewLabelEditCancelEventArgs, BetterListViewLabelEditCancelEventHandler for BeforeLabelEdit, AfterLabelEditCancel events \n\n* Added OnDrawInsertionMark method, DrawInsertionMark event \n\n* Added BetterListViewInsertionLocation.Offset property \n\n* Added CollapsedItemUnselection property (child item unselection behaviors when parent item is collapsed) \n\n* Added CheckBoxesAlign property to make parent items without check boxes more distinguishable in hierarchy \n\n* Added BetterListViewLabelEditActivation.ClickThrough label editing option \n\n* BetterListViewCheckItemReorderEventArgs now inherits from DragEventArgs to provide more information relevant to Drag and Drop \n\n* Added BetterListViewCheckItemReorderEventArgs.InvalidationReasons property to allow working with different reasons for item reorder invalidation \n\n* Added BetterListViewColumnHeaderStyle.Unsortable enum value \n\n* Added BetterListViewHitTestInfo.ColumnArea enum value \n\n* Added unsorting individual columns using Control modifier key when multi-column sorting is active \n\n \n\n* Improved performance of hierarchical items \n\n* When parent item is collapsed and any of its children selected, the parent itself gets selected \n\n* Changed EnsureVisible(BetterListViewItemCollection) to EnsureVisible(ICollection ); this avoids unnecessary wrapping of collections \n\n* A new BufferedGraphicsContext is created instead of using BufferedGraphicsManager.Current to avoid possible clash with other 3rd party controls using double-buffering in the same context \n\n* GetItemAt, GetSubItemAt, GetColumnHeaderAt, GetGroupAt methods can be called even when the control is in updation state (though the fresh information is not ensured) - for example, this enables using GetDropInfo method inside ItemReorder event handler \n\n \n\n* Removed CancelEdit from AfterLabelEdit event data, AfterLabelEditCancel should be used instead \n\n \n\n* Fixed changing selection from user code within ItemDrop event handler \n\n* Fixed BetterListViewItemReorderEventArgs.Locations can contain wrong values and missing child item indices \n\n* Fixed sorting items with hierarchy when some item contains more child items than there are top-level items \n\n* Fixed begining label editing when a single item is deselected using mouse and Control modifier key is pressed \n\n* Fixed updating last selected element when selection is changed programmatically \n\n* Fixed flickering when scrolling by moving selection using arrow keys \n\n* Fixed measurement of items not resetting when expand button is displayed by adding child items \n\n* Fixed not allowing to reorder item after last child item, but on higher level \n\n* Fixed BetterListViewItemEnumerator \n\n* Fixed items not positioned properly when ShowDefaultGroupHeader property value is changed \n\n \n\nBREAKING CHANGES: \n\n \n\n* UnselectCollapsedItems property renamed to CollapsedItemUnselection\n\n* Added support for Client Profile versions of .NET Framework \n\n* Added accessibility support \n\n \n\n* Added AccessibleObject implementations \n\n* Added protected virtual methods DoDefaultAction(BetterListViewColumnHeader) and DoDefaultAction(BetterListViewItem) \n\n \n\n* Added CircularSelection property \n\n* Added BetterListViewItem.CheckBoxAppearance property \n\n* Added BetterListViewItem.CustomDropDisplayExternal, BetterListViewItem.CustomDropDisplayInternal properties \n\n* Added BetterListViewSubItem.DisplayIndex property \n\n* Added BetterListViewDragDropEffectSettingEventArgs.UpdateInsertionMark property \n\n \n\n* Added custom item/sub-item text formatting \n\n \n\n * Added BetterListView.FormatItem \n\n * Added BetterListViewSubItem.FormatText property \n\n * Added BetterListViewSubItem.DisplayText property \n\n * Added BetterListViewItem.DisplayText \n\n * Added BetterListViewItem.FormatText property \n\n * Added BetterListViewItem.OnFormat \n\n * Added BetterListViewItem.RefreshDisplayText \n\n \n\n* Added VisibleColumns, VisibleGroups, VisibleItems properties \n\n* Added BetterListViewColumnHeader.NextVisibleColumnHeader, BetterListViewColumnHeader.PreviousVisibleColumnHeader properties \n\n* Added check on setting IsValid to true in CheckItemReorder event handler \n\n \n\n* Added automatic sorting of item hierarchy \n\n \n\n * Added BetterListViewItem.AllowSortChildItems property to customize hierarchical sorting \n\n \n\n* Added detecting source of item check state change \n\n \n\n * Added BetterListViewCheckedItemsChangedEventArgs.CheckStateChangeMode \n\n * Added BetterListViewItemCheckEventArgs.CheckStateChangeMode \n\n * Added BetterListViewItemCheckedEventArgs.CheckStateChangeMode \n\n \n\n* Improved detecting clicking on empty space in multi-line text \n\n* Improved display of check box in cut state \n\n* Improved serialization and ToString methods using invariant culture whenever appropriate \n\n* Improved BetterListViewNaturalItemComparer to handle arbitrarily large numbers \n\n* When AutoResizeColumn is called between BeginUpdate() and EndUpdate(), the resizing is postponed until the EndUpdate() call \n\n \n\n* Changed type of ImageSize layout property \n\n* Renamed BetterListViewLayoutItems.ImageSizes property to BetterListViewLayoutItems.SubItemImageSizes \n\n* Removed 'sealed' modifier from BetterListViewSubItem class to allow inheritance \n\n* Removed restoring selection when ItemReorderMode is set to Custom \n\n \n\n* Fixed moving selection on group headers using left/right arrow keys in List view \n\n* Fixed BetterListViewItem.CustomHeight property not taken into account in EqualsContent and Clone methods \n\n \n\n* Fixed BetterListViewSubItemCollection \n\n \n\n * Fixed custom collection always containing a single sub-item when created \n\n * Fixed cloning \n\n \n\n* Fixed unselecting item when clicked outside items and MultiSelect = false \n\n* Fixed selecting items ranging from and item to nearest group header above it \n\n* Fixed serialization of an empty list \n\n* Fixed display of right-aligned text when image is displayed after the text (columns, groups, items/sub-items) \n\n* Fixed display of group header splitter line when the text is centered or right-aligned \n\n* Fixed display of item selection in Details view when FullRowSelect is set to false \n\n* Fixed cloning of BetterListViewItem.CheckState property \n\n* Fixed first sub-item image disappearing when sub-item ImageKey property is set to null \n\n* Fixed measurement of default group header \n\n \n\nBREAKING CHANGES \n\n \n\n* Replaced BetterListViewItem.ShowCheckBox by BetterListViewItem.CheckBoxAppearance \n\n* Replaced BetterListViewItem.AllowDropHighlight by BetterListViewItem.CustomDropDisplayExternal and BetterListViewItem.CustomDropDisplayInternal \n\n* Changed type of ImageSize layout property \n\n* Renamed BetterListViewLayoutItems.ImageSizes property to BetterListViewLayoutItems.SubItemImageSizes\n\nChanges in version 2.9.1 (May 03, 2012)\n\n* Added AlignHorizontalImage, AlignVerticalImage properties in BetterListViewItem, BetterListViewSubItem and BetterListViewColumnHeader \n\n* Added HeaderAlignmentHorizontalImage, HeaderAlignmentVerticalImage in BetterListViewGroup \n\n* Added GetDropInfo method to determine drop/insertion location during Drag and Drop from user code \n\n* Enabled group focusing by right mouse button \n\n \n\n* Improved text clipping \n\n \n\n* Fixed EqualsContent and CopyTo methods of Better ListView element classes (missing AlignVertical/HeaderAlignmentVertical property) \n\n* Fixed vertical image alignment in Tile view \n\n* Fixed display of vertically centered text in LargeIcon and Thumbnail view \n\n* Fixed NullReferenceException when InsertionMark with empty insertion location is set\n\n* Added SubItemFocusBehavior property \n\n \n\n* Fixed problem when windows theme is changed to Aero in run-time \n\n* Fixed keeping state of the control when focus is lost \n\n* Fixed rasing SelectedItemsChanged even when drag selection ended by losing focus or mouse capture change \n\n* Fixed horizontal scroll bar having SmallChange value too small when no items are visible (only groups) \n\n* Fixed column headers not refreshing properly on custom scrolling in updating mode \n\n* Fixed auto scrolling triggered during drag selecting when owner form has been minimized\n\n* Added automatic removal of items from the list when removed from a group \n\n \n\n* Fixed BetterListViewItem.IsExpanded always 'true' in cloned items \n\n* Fixed improper alignment of items when a new item with children is added to flat list \n\n* Fixed combined item not showing combined selection when added during control initialization\n\n* Fixed item redrawing when selection is changed \n\n* Fixed label editing in SmallIcon and List view\n\n* Removed unnecessary redrawing in mouse events (caused by EnsureVisible) \n\n \n\n* Fixed optimized redrawing in some cases when focus is changed\n\n* Added BetterListViewItem.CustomHeight property \n\n* Added MaximumToolTipTextLength property \n\n \n\n* Removed unnecessary spacing for expand buttons when ShowItemExpandButtons is set to false \n\n* Optimized redrawing when changing item focus or selection \n\n \n\n* Fixed possible ItemActivate after drag selection or vice verse \n\n* Fixed text wrap when the text contains ampersand symbols \n\n* Fixed activation through web proxy \n\n* Workaround for .NET performance issuewhen displaying automatic tooltips with very long text\n\n* Added support for ElementOuterPadding layout property in Details view \n\n \n\n* Changed BetterListViewFocusedItemChangedEventArgs properties FocusedSubItemOld, FocusedSubItemNew to FocusedColumnIndexOld, FocusedColumnIndexNew to avoid referencing a non-existing sub-item (when the last sub-item is focused and removed) \n\n \n\n* Resolved some issues caused by obfuscation\n\n2.5.8.0 \n\n \n\n* Enabled Better ListView to be used from C++/CLI (resolved obfuscation issues)\n\n* Improved automatic tooltips for Details view with columns \n\n \n\n* Fixed column not resizing when double-clicked on the resizing area \n\n* Fixed control not refreshing properly when Enabled property is changed on parent control \n\n* Fixed nested RefreshView call causing column headers to break in some cases \n\n* Fixed scrolling about 1 pixel after label editing (vertically scrolled) last item in Details view \n\n* Fixed possible NullReferenceException when clicking on item check box \n\n* Fixed group font problem when 'Segoe UI Regular' font is not installed\n\n* Fixed updating control while having zero dimensions \n\n* Fixed ItemActivate not raised when MultiSelect is false\n\n* Added BetterListViewLabelEditActivation.Immediate \n\n* Added sample for BetterListViewItem.Visible property \n\n* Standard label editing can be invoked by clicking outside of text area \n\n* Single-click labele editing can be invoked by clicking on item/sub-item text even if the item is not selected \n\n \n\n* Fixed Invalidate method of BetterListViewColumnHeader, BetterListViewItem, BetterListViewGroup \n\n* Fixed default button of the Form pressing after text label editing \n\n* Fixed group headers not updating when MinimumSize property of the group layout changed \n\n* Fixed possible entering inconsistent state when the control has zero dimensions \n\n\n\n2.5.3.0 \n\n \n\n* Fixed problem when all items in a group set invisible (BetterListViewItem.Visible set to false) \n\n* Fixed problem when sub-items of an item are clear while some sub-item is focused \n\n\n\n* Added BetterListViewItem.Visible property \n\n* Added ToString(bool) method in some collection classes to allow printing out list of individual items \n\n* More detailed information returned in ToString methods of Better ListView elements \n\n \n\n* Improved group header font fallback \n\n* HitTest returns BetterListViewHitTestInfo.Empty when the control is updating \n\n* When ContextMenuStrip is available, it can be used instead of ContextMenuStripItems \n\n* BufferedGraphicsContext for control double-buffering is obtained from BufferedGraphicsManager instead of creating new \n\n \n\n* Fixed changing component names in Visual Studio Component Designer (column headers, items, sub-items and groups) \n\n* Fixed calling EnsureVisible when the control is updating (scrolling postponed util EndUpdate is called) \n\n* Fixed selected item kept in SelectedItems collection when replaced using indexer (e.g. BetterListView.Items[1] = newItem) \n\n* Fixed problem when clicking on column header and quickly moving mouse pointer outside client area \n\n* Fixed return value of BetterListViewAddress.ToString \n\n* Fixed Document Outline window blinking in Windows Forms Designer when BetterListViewItem is selected and Properties window opened at the same time \n\n* Fixed group header text disappearing when changed in runtime \n\n* Fixed group image not always updating when is of same size and set in runtime \n\n* Fixed Dispose method when Array is bound to Better ListView \n\n* Fixed ForeColorGroups property serializing to designer code even when having default value \n\n* Fixed background image aligned to bottom/right side being shown under scroll bars\n\n* Extended background of combined items (both parent and child items) \n\n \n\n* Fixed link in documentation (chapter \"Hit Test\")\n\n* Added ShowDefaultGroupHeader property \n\n* Added GroupHeaderBehavior property \n\n* Added BetterListViewItem.AllowSelectChildItems property \n\n* Added BetterListViewItem.Selectable property \n\n* Added BetterListViewItem.SelectableItem property \n\n* Added BetterListViewItem.LastAvailableChildItem property \n\n* Added BetterListViewSearchOptions.SelectableItemsOnly to allow searching through selectable items only \n\n* Displayable and selectable item is recognized with hit test (the two can be different because of BetterListViewItem.AllowSelectChildItems) \n\n* When AutoSizeImages is true (the default) in item layouts corresponding to Details view, the space for image is made only when the item actually has an image \n\n* Default font of the group does not get unnecessarily serialized to designer generated code \n\n \n\n* Removed unused property ShowFocusRectangle \n\n \n\n* Fixed possibly obtaining default group instance through BottomGroup or TopGroup properties \n\n* Fixed FindItemsWithText method accepting wrong type of item index \n\n* Fixed content not scrolling horizontally in List view \n\n* Fixed not keeping focused sub-item in same column after Page Down, Home and End (Details view) \n\n* Fixed group font not creating when 'Segoe UI' is not installed (font fallback is used to 'Trebuchet MS' or to default font of the control) \n\n \n\nBreaking Changes: \n\n \n\n* Item property of BetterListViewHitTestInfo split to ItemDisplay and ItemSelection\n\n* Added LabelEditDefaultAccept property \n\n* Added EndEdit method \n\n \n\n* Fixed horizontal scrolling \n\n \n\nBreaking Changes: \n\n \n\n* When label edit is cancelled by the control (e.g. by losing focus), the default action is not accepting the edited data - this can be set by LabelEditDefaultAccept property to false\n\n* Fixed vertical scroll bar not showing up \n\n* Fixed accessing disposed back buffer Graphics object after removing control from designer surface \n\n* Fixed links to Index in Better ListView Express Documentation \n\n* Fixed project file of Visual Basic samples for Express edition\n\n* Faster initialization when BeginUpdate/EndUpdate not used and the control does not have parent / is invisible \n\n \n\n* Fixed scrolling horizontally when columns exceed width of client area in other views than Details\n\n* Added FocusedItemChanged event \n\n \n\n* Added Center layout property to allow change of item centering in Thumbnails and LargeIcon views \n\n \n\n* Added hotkey prefix display support \n\n \n\n* Every column have its own resizing style (BetterListViewColumnHeader.SmoothResize) \n\n \n\n* When a group is clicked, only the group header is scrolled into view (not the entire group) \n\n \n\n* Improved performance of multi-line items \n\n \n\n* Fixed rendering multiline text with custom newlines \n\n \n\n* Fixed group item enumerator \n\n \n\nBreaking Changes: \n\n \n\n* BetterListView.SmoothColumnResize property moved to BetterListViewColumnHeader.SmoothResize\n\n* Added ViewChanged event \n\n* Added CheckedItemsChanged event \n\n* Added scrolling to group when clicked \n\n \n\n* Fixed raising CheckItemReorder event raised every time (not only when ItemReorderMode is set to Custom) \n\n* Fixed displaying items when ShowGroups is false and the items are contained in some group in other control \n\n* Fixed problem when setting Image property of sub-item to null after changing view where the sub-item has empty image size \n\n* Fixed behavior of the BetterListViewItem.Checked property setter \n\n* Fixed ItemChecked event raising when Checked or CheckState property of BetterListViewItem changed from user code \n\n* Fixed vertical scroll bar disappearing in Details view when the control was too wide \n\n* Fixed not scrolling to leftmost part of an item in Details view when changing selection \n\n* Fixed rasing SelectedItemsChanged and ItemSelectionChanged events on disposing Better ListView containing selected items \n\n \n\nBreaking Changes: \n\n \n\n* Use CheckedItemsChanged event for handling check state changes of multiple items \n\n* properties CurrentValue, NewValue of ItemCheckedEventArgs renamed to OldCheckState, NewCheckState\n\n* Added support for newline characters in text (multi-line text) \n\n* Added BetterListViewSubItemBounds.BoundsImageFrame \n\n* Extended BetterListViewItemComparer \n\n* CheckItemReorder event is raised even when ItemReorderMode is set to Enabled (not only Custom) \n\n* Columns, items and groups get automatically removed from Better ListView when the control is disposed \n\n* Optimized changing images in runtime \n\n* Extended documentation (Multi-line Items, Selecting and Checking Items, Sorting Items) \n\n \n\n* Fixed IsAnythingSelected property \n\n* Fixed SelectedIndices collection not containing updated indices after sorting items \n\n* Fixed possible problem when sub-item is replaced by the user in IBetterListViewEmbeddedControl.SetData method during label edit operation \n\n \n\nBreaking Changes: \n\n \n\n* Renamed BetterListViewItemActivateItemActivationSource to BetterListViewItemActivationSource \n\n* For owner drawing in empty image area of custom size, use BetterListViewSubItemBounds.BoundsImageFrameBounds instead of BetterListViewSubItemBounds.BoundsImage\n\n* Added HideSelectionMode property \n\n \n\n* Fixed sub-item with TextWrapping.Space wrapping text to more lines than specified by MaximumTextLines layout property\n\n* Added BetterListViewItem.TextWrapping (BetterListViewSubItem.TextWrapping) property \n\n* Added vertical text alignment for columns, items, sub-items and groups \n\n* Added BetterListViewDrawItemEventArgs.DrawEnabled and BetterListViewDrawItemEventArgs.DrawFocused properties \n\n* Added comparation operators to BetterListViewAddress \n\n* When items are selected from user code, new selections with Shift or Control+Shift keys are made from the item with lowest index (address) value \n\n* Sub-item text aligned on top in Details view \n\n* Revised and extended documentation \n\n \n\n* Fixed item text not displaying properly on items in Thumbnails view \n\n* Fixed item images not refreshing when another ImageList is set with same image sizes \n\n* Fixed problem when modifying tree hierarchy in runtime \n\n \n\nBreaking Changes: \n\n \n\n* BetterListViewColumnHeader.Align renamed to BetterListViewColumnHeader.AlignHorizontal \n\n* BetterListViewGroup.HeaderAlignment renamed to BetterListViewGroup.HeaderAlignmentHorizontal \n\n* BetterListViewItem.Align renamed to BetterListViewItem.AlignHorizontal \n\n* BetterListViewSubItem.Align renamed to BetterListViewSubItem.AlignHorizontal \n\n* TextAlignment changed to TextAlignmentHorizontal\n\n* DefaultTextAlignment, DefaultTextTrimming layout properties made editable \n\n* Expand button is hidden on empty groups \n\n* Revised Better ListView Documentation \n\n \n\n* Fixed ArgumentOutOfRange exception when hierarchical items are re-measured in specific order \n\n* Fixed displaying images when using ImageList \n\n* Fixed adding columns and items in design-time \n\n* Fixed selections with Control-Shift pressed \n\n* Fixed problem when collapsing group emptied by item reordering \n\n* Fixed problem when reordering columns when there is a bound data source \n\n* Minor fixes in Samples Explorer \n\n \n\nBreaking Changes: \n\n \n\n* LayoutOptions property has been replaced by layout propery AutoSizeImages (e.g. LayoutItemsCurrent.AutoSizeImages)\n\n* Fixed item not refreshing after sub-items added/removed \n\n* Fixed item not refreshing after child items added/removed\n\n* Fixed ordering of items in SelectedItems collection when child items are selected \n\n* Fixed extra space in column headers when images are displayed just in some of the column headers\n\n* Improved natural item comparer to support longer numbers \n\n \n\n* Fixed adding item to end of the list when reordering items into different group \n\n* Fixed items not updating when column is auto-resized or data source changed \n\n* Fixed blank space for image not appearing on custom image layout\n\n* Added 'static' column resizing option \n\n* Added optional automatic item resizing in Details view when columns are not visible \n\n* Added special collections for selected items and indices \n\n* Added special collections for checked item indices \n\n* Added SelectedItemsChanged event \n\n* Added methods FindNearestItem and BetterListViewItem.FindNearestItem \n\n* Added automatic insertion of items into Better ListView, when added to group or group into Better ListView \n\n* Added new C# and Visual Basic samples \n\n* Added 'EqualsContent' method for 'by value' comparison of elements and collections \n\n \n\n* Optimized performance of expand/collapse operations on items and groups \n\n* Optimized performance of modifying item collection \n\n* ItemSelectionChanged event is raised per-item as in the .NET ListView \n\n* Date/time format set to Short by default in DateTimePicker embedded control \n\n* BetterListViewView enum made compatible with System.Windows.Forms.View \n\n* Revised and corrected XML documentation \n\n* Corrected access modifier of InnerList property of collections from public to private \n\n* Default column width increased to 128 pixels (was 60 pixels) \n\n \n\n* Fixed column header backround display when vertical scroll bar is visible \n\n* Fixed group header display when column headers are wider than client area and horizontally scrolling \n\n* Fixed possible initialization of sub-item, column or group with null text \n\n* Fixed BetterListViewItem.Selected setter \n\n* Fixed BetterListViewItemIndexComparer taking item hierarchy into account \n\n* Fixed BetterListViewItem.Level getter \n\n* Fixed making selection with Shift+arrow after items have been removed from the list \n\n* Fixed editing sub-item collection in Windows Forms Designer \n\n* Fixed not sorting when ItemComparer is set and sorting is suspended \n\n* Fixed property ColorInsertionMark not having effect on insertion mark color \n\n \n\n \n\nExtended documentation \n\n \n\n* Added Quick Start Tutorial \n\n* Added C# and Visual Basic sample source code \n\n* Added 'Quick Start' chapter \n\n* Extended 'Performance' chapter \n\n \n\n \n\nBreaking Changes \n\n \n\n* Behavior of ItemSelectionChanged event has been adjusted according to original .NET ListView \n\n* Removed setter of CheckedIndices, CheckedItems, SelectedIndices and SelectedItems \n\n* BetterListItem constructor with parameters (string, string) have different meaning, use (string[]) instead \n\n* BetterListViewColumnHeader constructor with paramter (int) refers to ImageIndex property, not Width property \n\n* Property IsSelected of BetterListViewItem renamed to Selected \n\n* Value comparisons of implementations of Equals and IEquatable\n\n* Added item/sub-item image border drawing option \n\n* Added customizable image border color \n\n \n\n* Images in Thumbnails view centered vertically \n\n \n\n* Fixed refreshing control when Font property set \n\n* Fixed measurement of fonts with overhang glyphs (italics)\n\n* Added 'File Explorer' in samples \n\n* Implemented CopyTo() method in element classes to allow for proper cloning of derived objects \n\n \n\n* Fixed column header display when scrolling in List view \n\n* Fixed SelectedItems property for selecting child items \n\n* Fixed selecting item when item collection changed between MouseDown and MouseUp events (e.g. during DoubleClick)\n\n* Added column hiding feature (Visible property) \n\n \n\n* Optimized column resizing and sorting with many items \n\n \n\n* Fixed label editing when MultiSelect is false \n\n* Fixed reordering item into another item in another group as a child \n\n* Fixed setting focused item after Drag and Drop, item reordering or position binding when the control is in update state\n\n* Added groups support \n\n* Added hierarchical item support \n\n* Added multi-line item support \n\n* Added data binding \n\n* Added DateTimePicker label editing \n\ncontrol \n\n* Added ItemWidth and ItemHeight layout \n\nproperties to customize item size \n\n* Added adjustable padding for each element part, element and whole layout \n\n* Added type conversions between BetterListViewEmptyText and String \n\n* Added type conversions between BetterListViewToolTipInfo and String \n\n* Added TileSize property (item sizes in any other views - including the Tile view - can be set via layout settings) \n\n* Added Horizontal grid lines (can be visible even when columns are hidden) \n\n* Added GetItemNearest methods to get item nearest to the specified location \n\n* Added 'virtual' sorting (SortVirtual property) \n\n* Added AfterLabledEditCancel event to allow cancelling label editing after the value has been commited by the user \n\n* Added CLS-compliance \n\n* Added missing XML comments \n\n* Content can saved/loaded to/from binary/XML format \n\n* Objects can be added to Better ListView collections, the control will auto-convert them \n\n* Extended item reordering capabilities \n\n* Extended insertion mark display options (enabled/disabled state, level in item hierarchy) \n\n* Sub-items and groups can be focused and the focus information can be retrieved for each element type \n\n* Items can be enumerated regardless of item hierarchy through IEnumerable implemented by BetterListView, BetterListViewItem and BetterListViewGroup \n\n* Maximum allowed lines of text can be set for items \n\n* Changed type of some item collections \n\nfrom ReadOnlyCollection to BetterListViewItemCollection (SelectedItems, CheckedItems etc.) \n\n* Extended sorting capabilities (range sorting, sorting up to specific items) \n\n* Nonclickable columns can be reordered \n\n \n\n* AllowColumnResize functionality moved to property BetterListViewColumnHeader.AllowResize (per-column basis) \n\n* Default view changed to 'Details' \n\n* FullRowSelect property is 'true' by default \n\n* Improved performance of thumbnail images display \n\n* Improved performance when working with sorted list \n\n* Improved performance of Contains and RemoveRange methods in element collections \n\n* Synchronized BeginUpdate/EndUpdate methods for thread safety \n\n* Column header area is not displayed when there are no column headers to save space \n\n* Vertically centered item content in Details view \n\n \n\n* Fixed cancelling label edit when calling BetterListView.Focus() in AferLabelEdit, AfterLabelEditEmbeddedControl event handlers \n\n* ISerializable and IXmlSerializable implementation in elements and collection classes made explicit \n\n* Fixed locked label edit state when right-clicking on Better ListView while label editing \n\n* Fixed incorrect behavior of InsertRange method in element collections \n\n* Fixed possible bug when deserializing items with sub-items using BinaryFormatter \n\n* Fixed possible bug when using sub-item collection of deserialized item \n\n* Fixed switched visual style elements of middle and right column headers (might become visible in custom themes) \n\n* Fixed hit test for column headers which are both nonclickable and nonresizable \n\n* Fixed not displaying hot state of \n\nelements when another control captured mouse \n\n* Fixed occasional flicker when checking a hot or focused item \n\n* Fixed hot state of item check box when checked by mouse (only item being checked can display check box in hot state) \n\n* Fixed EnsureVisible(Rectangle) when client size is smaller than the specified area \n\n* Fixed searching with prefix preference and without search limit \n\n* Fixed AutoResizeColumns not using BeginUpdate/EndUpdate method, thus causing visible redrawing \n\n* Fixed possible flicker or hanging in update state when refreshing or exception thrown in mouse and keyboard event handlers \n\n* Fixed not refreshing control when BackgroundImageLayout property changed\n\n* Fixed Visual Studio 2008 toolbox auto-loading \n\n \n\n* Fixed ArgumentException occuring in LargeIcon View in some rare cases \n\n \n\n* Drag selection is now allowed even when the control does not contain any items\n\n* Added SuspendSort(), ResumeSort(), IsSortSuspended members for controlling sorting while updating control \n\n* Added immediate drop down when using combo box embedded control (enabled by default) \n\n* Added separate measurement of sub-item images \n\n* Added sorting items through BetterListView.Sort() when no column are displayed \n\nImmediate label editing on SingleClick activation \n\n* Method HitTest() without arguments made public \n\n* Method ReorderColumns(int, int, bool) made public \n\n \n\n* Fixed label editing sub-items when LabelEditItems was set to None \n\n* Fixed removing embedded control when scrolling during label-editing \n\n* Fixed hiding label edit control when Better ListView loses focus \n\n* Fixed setting proper cursor during Drag and Drop operation immediately when AllowDrop is set to false \n\n* Fixed raising ColumnWidthChanged event only when column width actually changes \n\n* Fixed adjusting rendering with visual styles when theme has changed in run-time \n\n* Fixed breaking of text that contains CR or LF characters alone \n\n* Fixed item text color when BetterListViewItem.IsCut is set to true \n\n* Fixed column headers being too high in rare cases \n\n* Fixed black area flashing when calling Refresh() while resizing control and SetRedraw was called to suppress redrawing \n\n* Fixed display of ampersand (&) characters within \"empty text\", items, column headers\n\n* New samples and new samples launcher \n\n* Added Thumbnails view \n\n* Added support for image borders \n\n* Extended owner-drawing capabilities \n\n* Extended label editing capabilities \n\n \n\n* Changed type of BetterListViewDrawColumnHeaderBackgroundEventArgs.ColumnHeaderBounds from Rectangle to BetterListViewColumnHeaderBounds (more options available) \n\n \n\n* Fixed behaviour of layouts in special cases \n\n* Fixed SelectedIndexChanged event raising before Better ListView state has changed \n\n* Fixed light borders of downsampled images \n\n* Fixed redraw bug when calling some of the RemoveRange() overrides"
    },
    {
        "link": "https://stackoverflow.com/questions/9008310/how-to-speed-adding-items-to-a-listview",
        "document": "I took a look at the source code for the list view and I noticed a few things that may make the performance slow down by the factor of 4 or so that you're seeing:\n\nin ListView.cs, calls , which is where I began my audit\n\n(from line: 18120) has two passes through the entire collection of values, one to collect all the checked items another to 'restore' them after is called (they're both guarded by a check against , owner being the ) then calls .\n\n(from line: 12952), first call, has another traverse of the entire list then ArrayList.AddRange is called (probably another pass there) then another pass after that. Leading to\n\n(from line: 12952), second call (via ) another pass through where they are added to a , and a will slow it further in debug mode. If the handle isn't created, it adds the items to an , but , then it calls\n\n(from line: 3848) final pass through the list where it is actually added to the native listview. a will additionally slow down performance in debug mode.\n\nSo there are A LOT of extra passes through the entire list of items in the .net control before it ever gets to actually inserting the items into the native listview. Some of the passes are guarded by checks against the Handle being created, so if you can add items before the handle is created, it may save you some time. The method takes the and calls directly without all the extra fuss.\n\nYou can read the code in the reference source yourself and take a look, maybe I missed something.\n\nIn the March 2006 issue of MSDN Magazine there was an article called Winning Forms: Practical Tips for Boosting The Performance of Windows Forms Apps .\n\nThis article contained tips for improving the performance of ListViews, among other things. It seems to indicate that its faster to add items before the handle is created, but that you will pay a price when the control is rendered. Perhaps applying the rendering optimizations mentioned in the comments and adding the items before the handle is created will get the best of both worlds.\n\nEdit: Tested this hypothesis in a variety of ways, and while adding the items before creating the handle is suuuper fast, it is exponentially slower when it goes to create the handle. I played with trying to trick it to create the handle, then somehow get it to call InsertItemsNative without going through all the extra passes, but alas I've been thwarted. The only thing I could think might be possible, is to create your Win32 ListView in a c++ project, stuff it with items, and use hooking to capture the CreateWindow message sent by the ListView when creating its handle and pass back a reference to the win32 ListView instead of a new window.. but who knows what the side affects there would be... a Win32 guru would need to speak up about that crazy idea :)"
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/UIE-uxml-element-ListView.html",
        "document": "A ListView is a vertically scrollable area that links to and displays a list of items.\n\nNote: The horizontal and vertical Scroller elements are standard UI(User Interface) Allows a user to interact with your application. Unity currently supports three UI systems. More info\n\nSee in Glossary Toolkit Scrollers.\n\nYou can create a ListView with UI Builder, UXML, and C#. The following C# example creates a ListView:\n\nYou can use a ScrollViewA UI Control which displays a large set of Controls in a viewable area that you can see by using a scrollbar. More info\n\nSee in Glossary control to create the same functionalities as using a ListView. However, a ListView is more efficient than a ScrollView when you do the following:\n• Instantiate the number of visual elements \n\n A node of a visual tree that instantiates or derives from the C# class. You can style the look, define the behaviour, and display it on screen as part of the UI. More info required to fill a page\n\nTo refresh the collection view, in general, call the or method. However, in the following cases, call instead to refresh the collection view:\n• You change the type of the data source, such as changing from a to a .\n• You make changes to or .\n\nNote: If you call , the collection view is completely rebuilt, which can be expensive. If you call or , the collection view is only refreshed, which is less expensive.\n\nTo change how item height is used to drive content, use the VirtualizationMethod:\n• sets all items to the same height.\n• allows items to have varying heights.\n\nThe ListView has a built-in child ScrollView element that lets users scroll through the list. You can control the speed of the scroll by overriding the , , and properties of the ScrollView with C#.\n\nDrag-and-drop is a common feature in UI design. To implement the drag-and-drop operations, override the following methods:\n• To set which items are dragged, override .\n• To get item status changes, override . You can perform certain actions based on the drag position or other conditions.\n\nDuring the drag-and-drop operation, you can enable the reordering of items by dragging. To enable, set the attribute to in UI Builder, UXML, and C#.\n\nRefer to Create a drag-and-drop list and tree views between windows for an example.\n\nThe following are some frequently asked questions about the ListView control.\n\nCan I get the indices of the rows that are visible on the screen?\n\nThere are no dedicated APIs for this. You can use the and callbacks to track these indices.\n\nCan I get the list of rows that are visible in the view?\n\nThere are no dedicated APIs for this. You can use UQuery to retrieve the elements of interest.\n\nIs it mandatory for any of the overridden functions of a view controller to call ?\n\nCall this method only if you want to extend its default behavior.\n\nI’ve added a Toggle to my row. Why doesn’t the selection jump to that row when the user selects it?\n\nBy default, the row is selected only if the mouse down event is not consumed by the row’s contents. In this case, your Toggle stops the event propagation. To fix this, register a callback with on the Toggle to call .\n\nHow do I receive a callback when a user changes their selection in the view?\n\nIt is recommended to use the callback to retrieve data by index when needed. While you can also use , be aware that it returns a list of objects, which can cause boxing allocations when used with value types.\n\nThe ListView control doesn’t support horizontal layout and virtualization. It’s recommended to use a ScrollView with to layout elements horizontally. However, applying this to a ListView breaks virtualization.\n\nThe following UXML example creates a ListView:\n\nThe following C# example illustrates some of the customizable functionalities of the ListView:\n\nTo try this example live in Unity, go to Window > UI Toolkit > Samples. ​ For more examples, refer to the following:\n• Create list and tree views: Use ListView, TreeView, MultiColumnListView, and MultiColumnTreeView to create list and tree views.\n• Create a complex list view: Use ListView to create a custom Editor window with a list of characters.\n• Bind to a list with ListView: Create a list of toggles and bind the list to an underlying list of objects.\n• Create a drag-and-drop list and tree views between windows: Use ListView, TreeView, and MultiColumnListView to create a drag-and-drop UI between windows.\n\nThis element has the following member attributes:\n\nThis element inherits the following attributes from its base class:\n\nThis element also inherits the following attributes from :\n\nThe following table lists all the C# public property names and their related USS selector.\n\nYou can also use the Matching Selectors section in the Inspector or the UI Toolkit Debugger to see which USS selectors affect the components of the at every level of its hierarchy."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.listview.retrievevirtualitem?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example demonstrates a handler for this event. In this example, listView1 needs each ListViewItem to display the square of its index. This code example is part of a larger example provided for the VirtualMode property.\n\nWhen a ListView object is in virtual mode, it creates ListViewItem objects dynamically instead of using the Items collection. This event is raised when the object must create a ListViewItem object. A handler for this event should create the appropriate ListViewItem or retrieve it from the cache, and pass it back by way of the Item property.\n\nFor more information about handling events, see Handling and Raising Events."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.listview.virtualmode?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nif ListView uses data-management operations that you provide; otherwise, . The default is .\n\nThis example illustrates a simple ListView whose contents are the first ten thousand squares. It handles searching and uses a cache for increased performance.\n\nSetting the VirtualMode property to puts the ListView into virtual mode. In Virtual mode, the normal Items collection is unused. Instead, ListViewItem objects are created dynamically as the ListView requires them.\n\nVirtual mode can be useful under many circumstances. If a ListView object must be populated from a very large collection already in memory, creating a ListViewItem object for each entry can be wasteful. In virtual mode, only the items required are created. In other cases, the values of the ListViewItem objects may need to be recalculated frequently, and doing this for the whole collection would produce unacceptable performance. In virtual mode, only the required items are calculated.\n\nIn order to use virtual mode, you must handle the RetrieveVirtualItem event, which is raised every time the ListView requires an item. This event handler should create the ListViewItem object that belongs at the specified index. In addition, the VirtualListSize property must be set to the size of the virtual list.\n\nHandling the SearchForVirtualItem event enables searching in virtual mode. If this event is not handled, the FindItemWithText and FindNearestItem methods will return .\n\nYou can handle the CacheVirtualItems event in order to maintain a cache of ListViewItem objects. If the calculation or lookup to create a ListViewItem object is expensive, maintaining a cache can improve performance.\n\nIf the View property is set to Tile, the value will automatically be changed to LargeIcon when VirtualMode is set to .\n\nIn virtual mode, the Items collection is disabled. Attempting to access it results in an InvalidOperationException. The same is true of the CheckedItems collection and the SelectedItems collection. If you want to retrieve the selected or checked items, use the SelectedIndices and CheckedIndices collections instead."
    },
    {
        "link": "https://stackoverflow.com/questions/10512607/what-exactly-is-listview-retrievevirtualitem-event-c-sharp",
        "document": "A virtual ListView should only call RetreiveVirtualItem for the rows currently visible on the screen.\n\nAs you navigate in the ListView, for example, you press the page down key, the ListView will calculate what should now be the index of the top row and will then call RetrieveVirtualItem so that your code can provide the item to use at each row index.\n\nUnless you cache or otherwise store the items you are providing via RetrieveVirtualItem, they will no longer exist once they are scrolled out of the listview.\n\nThis is what the Virtual in VirtualListView means - there aren't any real rows, the rows are virtual. That is how it could display a list containing hundreds of thousands of rows - because it will ever only actually contain how ever many rows are visible on screen.\n\nIn effect, the ListView is like a window that is moving up and down your internal list of data - the RetreiveVirtualItem method is what it calls to move items into that window as it moves along. It says, hey I just moved to row 15 - give me the item for that row. It will proceed to call RetreiveVirtualItem for each row index which would be visible. If the ListView was 5 rows in height on the screen, you would receive 5 calls to RetrieveVirtualItem - even if the actual data backing the listview had 3000 items. Each time the top row of the ListView changed (because of navigation), you would receive 5 calls to RetrieveVirtualItem (this is not always the case, but it is the right idea - for example, if you scroll down one row, it will simply ask you for the new last row - it will also simply discard the data that was used for the old top row that scrolled out of view).\n\nI guess it might be even easier to explain if we assume the ListView was only one row high on the display (meaning only a single row is ever actually visible on the screen) - as you move the ListView up and down your list of data (i.e. the user navigates the ListView), it would call RetrieveVirtualItem exactly one time every time it moves to a new row."
    },
    {
        "link": "https://codeproject.com/Articles/42229/Virtual-Mode-ListView",
        "document": "A WindowsForms control can be used in \"virtual mode\". When running in virtual mode, the doesn't host any data, instead the only thing it needs to know is, how many rows/lines it has. A callback method has to be provided in order to pass over the data to display, whenever the visible lines the control is able to display at a given time, scroll into view. The example is able to display about 100 million lines and represents the line number as text (German).\n\nThis simple prototype was created before I started creating the as an extension to the - also running in virtual mode - which is also available here at CodeProject: VirtualModeTreeListView.\n\nIn order for a to operate in virtual mode, we will have to set the appropriate property \" \" to . Once we place the WindowsForms control on some form, the properties window of the will appear. Be sure that the object is selected.\n\nAfter activating the virtual mode, it's a must to subscribe to the \" \" event as well, due to the fact that the control gathers for data regarding the rows that are visible/in view. If we forget to subscribe to this event, the control will fire an exception. So we kindly fulfill the requirements.\n\nNow we will have to provide some code within the callback handler of the event \" \". Whenever lines are visible, the control gathers for data in order to display data within the columns of the control. Therefore the control expects a usual object, composed with any additional objects as child objects, depending on the configured columns of the control. Keep in mind that if we were not using the virtual mode, we'd have to fill the control with such objects so that the control could view data in its columns of each row. If not, the control would just be \"empty\".\n\nThis example just takes the line numbers that are passed into the callback method and creates the textual representation of the line numbers.\n\nThe method just creates the appropriate for a certain number, the text however is in German. There is a class called which is used to create the . Please refer to the source file NumberText.cs for details.\n\nOne thing we still have to do is tell the how many rows/lines it has. I do this within the event of the like this:\n\nYou might also be interested in a running in virtual mode: VirtualModeTreeListView."
    },
    {
        "link": "https://github.com/AArnott/core-docs/blob/master/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListView.VirtualMode/cs/VirtualMode.cs",
        "document": "//stores the index of the first item in the cache\n\n//If you leave out the SearchForVirtualItem handler, this will return null.\n\n//with the required properties; in this case, the square of the index.\n\n//check to see if the requested item is currently in the cache\n\n//A cache hit, so get the ListViewItem from the cache instead of making a new one.\n\n//Manages the cache. ListView calls this when it might need a\n\n//If the newly requested cache is a subset of the old cache,\n\n//no need to rebuild everything, so do nothing.\n\n//Now we need to rebuild the cache.\n\n//If e.Index is not set, the search returns null.\n\n//Note that this only handles simple searches over the entire\n\n//and the other properties of SearchForVirtualItemEventArgs is up"
    }
]