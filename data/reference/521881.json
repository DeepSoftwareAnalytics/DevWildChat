[
    {
        "link": "https://cplusplus.com/reference/string/string",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/stdstring-class-in-c",
        "document": "C++ has in its definition a way to represent a sequence of characters as an object of the class. This class is called std:: string. The string class stores the characters as a sequence of bytes with the functionality of allowing access to the single-byte character.\n\nclass that defines objects that be represented as a stream of characters. array of characters that can be terminated by a null character. In the case of strings, memory is allocated dynamically . More memory can be allocated at run time on demand. As no memory is preallocated, no memory is wasted The size of the character array has to be allocated statically , more memory cannot be allocated at run time if required. Unused allocated memory is also wasted As strings are represented as objects, no array decay threat of array decay in the case of the character array. Strings are slower when compared to implementation than character array. a number of functionalities that allow manifold operations on strings.\n\nSpace Complexity: O(n) where n is the size of the string\n\nThis function returns the capacity allocated to the string, which can be equal to or more than the size of the string. Additional space is allocated so that when the new characters are added to the string, the operations can be done efficiently. This function changes the size of the string, the size can be increased or decreased. This function finds the length of the string. This function decreases the capacity of the string and makes it equal to the minimum capacity of the string. This operation is useful to save additional memory if we are sure that no further addition of characters has to be made.\n\nSpace Complexity: O(n) where n is the size of the string\n\nThis function returns an iterator to the beginning of the string. This function returns an iterator to the next to the end of the string. This function returns a reverse iterator pointing at the end of the string. This function returns a reverse iterator pointing to the previous of beginning of the string. This function returns a constant iterator pointing to the beginning of the string, it cannot be used to modify the contents it points-to. This function returns a constant iterator pointing to the next of end of the string, it cannot be used to modify the contents it points-to. This function returns a constant reverse iterator pointing to the end of the string, it cannot be used to modify the contents it points-to. This function returns a constant reverse iterator pointing to the previous of beginning of the string, it cannot be used to modify the contents it points-to.\n\nSpace Complexity: O(n) where n is the size of the string\n\n\n\nMust Read: C++ String Class and its Applications"
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/introduction-to-stdstring",
        "document": "While C-style string literals are fine to use, C-style string variables behave oddly, are hard to work with (e.g. you can’t use assignment to assign a C-style string variable a new value), and are dangerous (e.g. if you copy a larger C-style string into the space allocated for a shorter C-style string, undefined behavior will result). In modern C++, C-style string variables are best avoided.\n\nFortunately, C++ has introduced two additional string types into the language that are much easier and safer to work with: and (C++17). Unlike the types we’ve introduced previously, and aren’t fundamental types (they’re class types, which we’ll cover in the future). However, basic usage of each is straightforward and useful enough that we’ll introduce them here.\n\nThe easiest way to work with strings and string objects in C++ is via the type, which lives in the <string> header.\n\nWe can create objects of type just like other objects:\n\nJust like normal variables, you can initialize or assign values to std::string objects as you would expect:\n\nNote that strings can be composed of numeric characters as well:\n\nIn string form, numbers are treated as text, not as numbers, and thus they can not be manipulated as numbers (e.g. you can’t multiply them). C++ will not automatically convert strings to integer or floating point values or vice-versa (though there are ways to do so that we’ll cover in a future lesson).\n\nobjects can be output as expected using :\n\ncan handle strings of different lengths\n\nOne of the neatest things that can do is store strings of different lengths:\n\nIn the above example, is initialized with the string , which contains five characters (four explicit characters and a null-terminator). We then set to a larger string, and then a smaller string. has no problem handling this! You can even store really long strings in a .\n\nThis is one of the reasons that is so powerful.\n\nUsing with may yield some surprises! Consider the following example:\n\nHere’s the results from a sample run of this program:\n\nHmmm, that isn’t right! What happened? It turns out that when using to extract a string from , only returns characters up to the first whitespace it encounters. Any other characters are left inside , waiting for the next extraction.\n\nSo when we used to extract input into variable , only was extracted, leaving inside . When we then used to get extract input into variable , it extracted instead of waiting for us to input an color. Then the program ends.\n\nTo read a full line of input into a string, you’re better off using the function instead. requires two arguments: the first is , and the second is your string variable.\n\nHere’s the same program as above using :\n\nNow our program works as expected:\n\nWhat the heck is ?\n\nIn lesson 4.8 -- Floating point numbers, we discussed output manipulators, which allow us to alter the way output is displayed. In that lesson, we used the output manipulator function to change the number of digits of precision that displayed.\n\nC++ also supports input manipulators, which alter the way that input is accepted. The input manipulator tells to ignore any leading whitespace before extraction. Leading whitespace is any whitespace character (spaces, tabs, newlines) that occur at the start of the string.\n\nLet’s explore why this is useful. Consider the following program:\n\nHere’s some output from this program:\n\nThis program first asks you to enter 1 or 2, and waits for you to do so. All good so far. Then it will ask you to enter your name. However, it won’t actually wait for you to enter your name! Instead, it prints the “Hello” string, and then exits.\n\nWhen you enter a value using , not only captures the value, it also captures the newline character ( ) that occurs when you hit the enter key. So when we type and then hit enter, captures the string as input. It then extracts the value to variable , leaving the newline character behind for later. Then, when goes to extract text to , it sees is already waiting in , and figures we must have previously entered an empty string! Definitely not what was intended.\n\nWe can amend the above program to use the input manipulator, to tell to ignore any leading whitespace characters:\n\nNow this program will function as intended.\n\nIf we want to know how many characters are in a , we can ask a object for its length. The syntax for doing this is different than you’ve seen before, but is pretty straightforward:\n\nAlthough is required to be null-terminated (as of C++11), the returned length of a does not include the implicit null-terminator character.\n\nNote that instead of asking for the string length as , we say . The function isn’t a normal standalone function -- it’s a special type of function that is nested within called a member function. Because the member function is declared inside of , it is sometimes written as in documentation.\n\nWe’ll cover member functions, including how to write your own, in more detail later.\n\nAlso note that returns an unsigned integral value (most likely of type ). If you want to assign the length to an variable, you should it to avoid compiler warnings about signed/unsigned conversions:\n\nWhenever a std::string is initialized, a copy of the string used to initialize it is made. Making copies of strings is expensive, so care should be taken to minimize the number of copies made.\n\nDo not pass by value\n\nWhen a is passed to a function by value, the function parameter must be instantiated and initialized with the argument. This results in an expensive copy. We’ll discuss what to do instead (use ) in lesson 5.8 -- Introduction to std::string_view.\n\nWhen a function returns by value to the caller, the return value is normally copied from the function back to the caller. So you might expect that you should not return by value, as doing so would return an expensive copy of a .\n\nHowever, as a rule of thumb, it is okay to return a by value when the expression of the return statement resolves to any of the following:\n• A that has been returned by value from another function call or operator.\n• A temporary that is created as part of the return statement.\n\nIn most other cases, prefer to avoid returning a by value, as doing so will make an expensive copy.\n\nDouble-quoted string literals (like “Hello, world!”) are C-style strings by default (and thus, have a strange type).\n\nWe can create string literals with type by using a suffix after the double-quoted string literal. The must be lower case.\n\nYou probably won’t need to use literals very often (as it’s fine to initialize a object with a C-style string literal), but we’ll see a few cases in future lessons (involving type deduction) where using literals instead of C-style string literals makes things easier (see 10.8 -- Type deduction for objects using the auto keyword for an example).\n\nIf you try to define a , your compiler will probably generate an error:\n\nThis happens because isn’t supported at all in C++17 or earlier, and only works in very limited cases in C++20/23. If you need constexpr strings, use instead (discussed in lesson 5.8 -- Introduction to std::string_view).\n\nis complex, leveraging many language features that we haven’t covered yet. Fortunately, you don’t need to understand these complexities to use for simple tasks, like basic string input and output. We encourage you to start experimenting with strings now, and we’ll cover additional string capabilities later.\n\nWrite a program that asks the user to enter their full name and their age. As output, tell the user the sum of their age and the number of characters in their name (use the member function to get the length of the string). For simplicity, count any spaces in the name as a character.\n\nReminder: We need to be careful not to mix signed and unsigned values. returns an unsigned value. If you’re C++20 capable, use to get the length as a signed value. Otherwise, static_cast the return value of to an int."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/basic_string",
        "document": "The class template stores and manipulates sequences of character-like objects, which are non-array objects of TrivialType and StandardLayoutType. The class is dependent neither on the character type nor on the nature of operations on that type. The definitions of the operations are supplied via the template parameter - a specialization of std::char_traits or a compatible traits class.\n\nThe elements of a are stored contiguously, that is, for a s, &*(s.begin() + n) == &*s.begin() + n for any n in ​0​ s.size() , and *(s.begin() + s.size()) has value CharT() (a null terminator)(since C++11); or, equivalently, a pointer to s[0] can be passed to functions that expect a pointer to the first element of an array(until C++11)a null-terminated array(since C++11) of .\n\nsatisfies the requirements of AllocatorAwareContainer (except that customized / are not used for construction/destruction of elements), SequenceContainer and ContiguousContainer(since C++17).\n\nIf any of and is different from , the program is ill-formed.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nSeveral typedefs for common character types are provided:\n\nReferences, pointers, and iterators referring to the elements of a may be invalidated by any standard library function taking a reference to non-const as an argument, such as std::getline, std::swap, or , and by calling non-const member functions, except , , , , , , , , and .\n\nAlthough it is required that customized or is used when constructing or destroying elements of until C++23, all implementations only used the default mechanism. The requirement is corrected by P1072R10 to match existing practice.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/strings-in-cpp",
        "document": "In C++, strings are sequences of characters that are used to store words and text. They are also used to store data, such as numbers and other types of information in the form of text. Strings are provided by <string> header file in the form of std::string class.\n\nCreating a string means creating an instance of std::string class as shown:\n\nwhere str_name is the name of the string.\n\nInitializing means assigning some initial value to the string. This can be done by using assignment operator and the text enclosed inside “” double quotes.\n\nThe text inside “” is called string literal and it is the value that is assigned to the string variables. It doesn’t need to have any meaning. It can be any text that is the sequence of characters from the ASCII charset.\n\nA string can be referred using its name anywhere in the scope once it is declared. For example, the below example prints string using cout:\n\nThe individual characters of the strings can also be accessed using their position (or index) like arrays with [] square brackets. The index in C++ starts from 0 and goes till size – 1, so be careful not go outside this limit.\n\nThe string variable can be updated store a new string literal in a similar way it is initialized.\n\nA single character can also be changed by first accessing the character and then using assignment operator to assign value.\n\nThe following operations aims to improve your understanding of the strings in C++ and introduce you to some of the most commonly used operations provided by C++:\n\nThe string can be passed to a function in the same was as any other type of variable.\n\nC++ is a superset of C language, so it also inherits the way in which we used to create strings in C. In C, strings were nothing, but an array of characters terminated by a NULL character ‘\\0’. They were created as:\n\nDue to being array, there were limitations on C strings:\n• Fixed Size : Once declared, the size of the C string cannot be changed.\n• Lack of Easy String Operations: No high-level operations like concatenation or substring extraction. Moreover, updating was also complex.\n\nC++ strings resolve this issue by providing a lot of operations that are easy to perform. Internally, these strings are still implemented as dynamic array of characters (or more precisely vectors) Thats why we can access a single character by its index. But the std::string class act as a wrapper and provides lot of built-in functionality for easier and more efficient handling of strings.\n\nC++ String vs C Strings\n\nThe main difference between a string and a character array is that strings are immutable, while character arrays are not.\n\nKnow more about the difference between strings and character arrays in C++\n\nC++ provides some inbuilt functions which are used for string manipulation, such as the strcpy() and strcat() functions for copying and concatenating strings. Some of them are:\n\nThis function returns the length of the string. This function is used to swap the values of 2 strings. Used to find the size of string This function is used to resize the length of the string up to the given number of characters. Used to find the string which is passed in parameters This function is used to push the passed character at the end of the string This function is used to pop the last character from the string This function is used to remove all the elements of the string. This function compares at most the first num bytes of both passed strings. This function is similar to strcpy() function, except that at most n bytes of src are copied This function locates the last occurrence of a character in the string. This function appends a copy of the source string to the end of the destination string This function is used to search for a certain substring inside a string and returns the position of the first character of the substring. This function is used to replace each element in the range [first, last) that is equal to old value with new value. This function is used to create a substring from a given string. This function is used to compare two strings and returns the result in the form of an integer. This function is used to remove a certain part of a string. This function is used to find the string’s last occurrence.\n\nThese functions are discussed in this article in more detail – String Function in C++"
    },
    {
        "link": "https://geeksforgeeks.org/stringstream-c-applications",
        "document": "stringstream in C++ and its Applications\n\nA stringstream associates a string object with a stream allowing you to read from the string as if it were a stream (like cin). To use stringstream, we need to include sstream header file. The stringstream class is extremely useful in parsing input.\n• str()- To get and set string object whose content is present in the stream.\n• operator >>- Read something from the stringstream object.\n\n1. Count the number of words in a string\n\nBelow is the C++ program to implement the above approach-\n\nTime complexity: O(n), Where n is the length of the string.\n\nAuxiliary space: O(m), Where m is the number of words in the string.\n\nBelow is the C++ program to implement the above approach-\n\nTime complexity: O(n log(k)), n is the total number of words in the input string, and k is the number of unique words.\n\nAuxiliary space: O(n).\n\nSince, the insertion and extraction operators of string stream work with different data types. So that’s why it works well with integers.\n\nWe will insert an integer into the string stream and after extracting that into a string, that integer value will become a string.\n\nRemoving spaces from a string using Stringstream\n\nConverting Strings to Numbers in C/C++"
    },
    {
        "link": "https://stackoverflow.com/questions/20594520/what-exactly-does-stringstream-do",
        "document": "I am trying to learn C++ since yesterday and I am using this document: http://www.cplusplus.com/files/tutorial.pdf (page 32). I found a code in the document and I ran it. I tried inputting Rs 5.5 for price and an integer for quantity and the output was 0. I tried inputting 5.5 and 6 and the output was correct.\n\nWhat exactly does the mystring command do? Quoting from the document:\n\n\"In this example, we acquire numeric values from the standard input indirectly. Instead of extracting numeric values directly from the standard input, we get lines from the standard input (cin) into a string object (mystr), and then we extract the integer values from this string into a variable of type int (quantity).\"\n\nMy impression was that the function will take an integral part of a string and use that as input."
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/string-stream-in-cpp",
        "document": ""
    },
    {
        "link": "https://medium.com/@aintburak/mastering-stringstream-in-c-a-comprehensive-guide-7eda8a47679a",
        "document": "In C++, the class is a powerful tool that provides functionality for parsing and manipulating strings. It is part of the Standard Template Library (STL), specifically within the header. This class essentially treats a string as a stream, allowing us to perform input and output operations on it, much like we would with and . Let's explore the uses, benefits, and methods associated with .\n\nis a stream class that operates on strings, implementing input/output operations on memory-based streams. It is particularly useful for parsing inputs and converting between strings and numeric types. The class is derived from the class, inheriting its stream capabilities. Here’s a brief overview of commonly used methods and operators with :\n• Method : Gets and sets the contents of the underlying string device object.\n\nTo create a object, you must include the header and instantiate a object. Once you have a object, you can use it to perform various operations, such as inserting data into the stream or extracting data from it. Here’s an example of creating a and inserting an integer into it: std::cout << \"The number as a string is: \" << str << std::endl;\n\n return 0;\n\n} In this example, we insert an integer ( ) into the object ( ) using the operator. Then, we extract the string representation of the number using the operator and store it in a variable . Finally, we print the string to the console.\n\nis often used to parse structured text input. For instance, if you have a CSV line with comma-separated values, you could use to split the line into separate fields: In this function, we use with a custom delimiter to split the line into fields, which we add to a vector. can also be used to build complex strings with formatting. Instead of concatenating strings manually, which can be inefficient, you can use to construct a string in a streamlined manner: void formatMessage(const std::string& name, int age) {\n\n std::stringstream ss;\n\n ss << \"Hello, \" << name << \". You are \" << age << \" years old.\";\n\n std::cout << ss.str() << std::endl;\n\n} In this function, we build a personalized greeting message using the operator to append strings and variables through the .\n\nWhen Not to Use While is a convenient tool for string manipulation, it may not always be the best choice. For simple string concatenation or when performance is critical, using native string operations or string literals might be more efficient. Additionally, when dealing with large amounts of data, consider the overhead of streaming operations versus direct manipulations.\n\noffers a flexible way to manipulate strings in C++. Its ability to treat strings as streams allows for intuitive and readable code when performing complex string manipulations. Whether you're parsing CSV files, building dynamic messages, or converting between string and numeric types, is a valuable asset in any C++ programmer's toolkit. By leveraging , you can write cleaner, more maintainable code and handle string-related tasks with ease. Keep in mind the potential performance implications, especially for large datasets or high-performance scenarios, but don't let that prevent you from taking advantage of the streamlined approach provides."
    },
    {
        "link": "https://stackoverflow.com/questions/824143/working-with-string-streams",
        "document": "Say i have a stringsteam in C++, and I want to do different operations to it like:\n\nSearching for a sequence of characters, Converting block of text into int (in the middle of the line), Moving the get pointer back and forth and so on.\n\nWhat is the standard/common way of doing this kind of things with stringstreams?"
    }
]