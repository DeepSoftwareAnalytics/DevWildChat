[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://towardsdatascience.com/where-does-python-get-its-random-numbers-from-81dece23b712",
        "document": "A simple explanation of modern pseudo-random number generators (PRNGs) and their new NumPy implementation\n\nWhilst generating a sample of Normally distributed numbers I was curious about where they ‘came from’ – particularly how a computer can create numbers that follow a distribution of choice whether that’s Normal, Exponential or something more funky. Whatever method underlies creating these Normally distributed values (inversion sampling, Box-Muller or the speedy Ziggurat algorithm) they all start with one fundamental building block: a sequence of uniformly distributed values.\n\nWhich then begs the question: where do these come from? In most cases: from a ‘pseudo-random number generator’ – or PRNG. Having noticed that NumPy changed their default PRNG back in Jul 2019 in response to this NEP (despite the internet still littered with the old way to do it) I was keen to understand:\n• why they changed it\n• how do PRNGs work in the first place\n\nand then write down my thoughts in plain English with some helpful charts and code examples along the way. This is these notes, heavily guided by [this](https://www.youtube.com/watch?v=45Oet5qjlms&list=WL&index=171&t=364s) (pretty accessible) paper and this associated lecture by Melissa O’Neill – the author of the PCG family of PRNGs back in 2014 that now form the default PRNG in NumPy.\n\nBecause generating true randomness is hard – both for humans (try your luck here and see how you fare) and also machines. If we think of machines as just taking input and producing output according to what instructions we give them then by definition the output will be as random as the input.\n\nThere are ways to make sure this input is ‘truly’ random that mostly involve hardware to measure truly random things from nature (like atmospheric noise), but usually we ‘seed’ algorithms with a chosen (non-random) initial value. Even if we use the machine time (as an integer) when the generator kicks off as the seed, this is not 100% random. However we should probably question if it is worth pursuing true randomness in the first place.\n\nDo we want ‘true randomness’?\n\nIt depends on the context. If we think about randomness as the inverse of predictability, and predictability as the enemy of security, then it can be easier to answer this question. When we are using random numbers to generate keys used for security i.e. cryptography, then we want these numbers to seem as random as possible to minimise the possibility of a threat. So in this case a true random number generator is useful.\n\nIn other cases when it comes to generating simulations we might have other priorities that offset against the desire for absolute zero predictability. We might be happy with a function that whilst completely deterministic and predictable when you know the starting value (or enough of the sequence), seems random when you:\n• don’t know the starting value\n• knowing ‘enough’ of the sequence is impossible in practice\n\nWhich then begs the next question:\n\nWhat properties of PRNGs are desirable?\n\nNothing that special here – we want something that can generate a reproducible large quantity of random numbers fast and without taking up too much memory, particularly if we plan on having many of them running in various threads.\n\nIf we know that the random numbers generated will fall in the interval then we’d like each number in that interval to have an equal chance of being chosen – otherwise even though theoretically we have a lot of numbers to be chosen in practice this will be much smaller. As an example if we have possible numbers in the interval but in practise our PRNG selects only or then it’s not very random at all. On the other side of things we don’t necessarily want an algorithm that guarantees uniformity. If this were the case then if we have a range of numbers to chose from and we have already chosen numbers, then the final number is not random at all – it will simply be the number that hasn’t been selected yet. By working backwards we can see that any algorithm that guarantees uniformity will diminish in randomness as we reach the end of the range – also known as ‘period’.\n\nIf we accept that in order to get a computer to generate a sequence we have to give it a function that converts the previous number into the next number, then if we ever end up with a number we have seen before we will start repeating the sequence. This is guaranteed to happen at some point as long as we choose numbers from a bounded interval because if we select numbers in then by definition the th number must be a repeat from a number before. In other words, over a suitable size of sequence all PRNGs will duplicate and so become deterministic. To prevent this we can make the number of numbers (the ‘period’) before this happens much much larger than the length of the sequence of numbers we wish to sample.\n\nSeems like an obvious one but worth adding. For example a good algorithm to satisfy all of the above properties is simply to just ‘add 1’:\n\nwhich will be:\n• blazingly fast, small and reproducible (we just need to know the value we started with)\n• uniform: every number in a given interval will be chosen once\n• long period: it will never repeat as long as we never ‘wrap it around’ at some value to make sure the number size doesn’t get to big i.e. map a large number, , back to zero and start again\n\nIn other words the previous conditions provide the ability for a pseudo-random algorithm to appear random but do not guarantee it – we still need a good algorithm that lacks predictability when you don’t know the initial condition.\n\nThis bit is key – all PRNGs will be deterministic if you know the algorithm’s ‘state’ (as in, the last random number and the function to convert that to the next random number). The key is that without that info the numbers will appear random – just like a turkey thinking that Christmas is a ‘Black Swan’ but the farmer not (randomness is relative to your information set).\n\nLinear Congruential Generators (LCGs) are one of the oldest PRNGs and fortunately pretty simple to understand.\n\nIn other words – to get the next number in the sequence we take the previous number and:\n• multiply it by some constant\n• add some other constant to it\n• take the remainder when we divide by some other constant\n\nSo far, nothing too ‘computer science-y’ with scary words or phrases like ‘matrix linear recurrence’ or ‘Mersenne prime’. Let’s choose some values for and see what the output looks like.\n\nIn particular let’s form a generator in the style of a Lehmer 1951 generator which is dead simple – , and in order to ensure we generate 8-bit numbers let’s set . This last bit just means that numbers will remain between and so fit in 8-bits.\n\nSo what problems can we see already?\n• all the numbers are odd so we’re not uniformly touching all numbers at all (any observable pattern being the antithesis of randomness)\n• the period is short – you can see around half way through we get back to the start and then begin repeating ourselves\n\nIf LCGs are so terrible then is this relevant to PRNGs today?\n\nBecause LCGs are not terrible. The above LCG is terrible but that is less to do with LCGs as a family of number generators themselves and more to do with the way we parameterised that one. In fact, the following LCG is called and is what underlies :\n\nbut has a crucial difference with the above LCG specification.\n\nDon’t just output the ‘state’, but a function of it\n\nIn the first example we just generated the next number in the sequence and outputted it. If it was , then the next number in our sequence was . No funny business. In the above LCG implementation this is not the case – we have the following . In Python this is a bitwise operator that shifts all the bits 16 places to the right with the right-most 16-bits getting dropped as a result.\n\nWe can take an example here – if we have the number we can represent that in binary as (spacing just for ease of reading) – if we do then we end up with (which is ) i.e. we shift everything to the right by 3 places and drop the first 3 bits on the right. This is just one such type of function that illustrates a way to improve our output. We now have the following setup for our LCG algorithm:\n• generate the next number in the sequence – this is the ‘state’ of the LCG (just terminology)\n• use that ‘state’ to generate the ‘output’ – this is the number that is then used to form part of the sequence\n\nThis is how we can have a ’16-bit generator’ with an ‘8-bit output’ – because the ‘state’ of the generator is a 16-bit number but the output is an 8-bit number where that 8-bit number is created by applying some function to the 16-bit state. As we will see, the creation of PRNGs with a different output to state can drastically improve their statistical properties.\n\nIn order to gain some intuition about how random various algorithms are we need a way to visualise this randomness. To do this we’ll again borrow an idea from the paper by Melissa O’Neill. In practise random number generators are a lot bigger than what we will do (64-bit state with 32-bit output) but the following is the idea:\n• create a generator with a state of 16-bits i.e. the seed/state is in the range (where the upper bound is )\n• output an 8-bit number that is derived from that 16-bit state – i.e. every number in the output sequence will be in\n• take the sequence and group adjacent points into pairs i.e.\n• use the PRNG to generate co-ordinates and plot them where if we have no pairs for a co-ordinate then that co-ordinate is white and the more pairs we have on a given co-ordinate the more black that co-ordinate will be\n\nIn a way this will give us a nice picture of randomness. If we have a good algorithm we will have a plot with lots of dots that overall looks, well, random. This will be a lot easier to see with an example. Let’s take a well parameterised \"16-bit state, 8-bit output LCG\" and draw out a few ‘randograms’.\n\nThe top left chart shows what we get when we take the right-most 8-bits of the 16-bit state number. For example, if our ‘state’ for an iteration is the number represented in binary as , then we will output the right-most 8 bits – (or ). We do this for all numbers, group them as pairs and plot them.\n\nWe can see that the numbers don’t seem very random at all – they form neat straight lines. This is Marsaglia’s theorem and shows the issue with LCGs when we have too small a period (and so get repeating values like this). However, as we move higher up the 16-bit state things start to look a little better. There is still a clear structure in the bottom right chart, but we are doing much better in terms of covering the space.\n\nSo when looking at this we could make the following observation: the higher the group of 8-bits in the 16-bit state number generated by a LCG, the more random they seem.\n\nDespite LCGs still finding widespread practical use, they were not the default PRNG for NumPy pre-2019. Instead, before NumPy 1.17 an algorithm called Mersenne Twister was used – specifically MT19937 – named because of its (absolutely colossal) period length being a Mersenne Prime ( – power of 2 minus 1). However with the 1.17 NumPy release it switched over to have the default PRNG being a PCG – Permuted (Linear) Congruential Generator.\n\nPCGs are a family of generators created by Melissa O’Neill that make clever use of the observations from the above – especially the charts. The idea is this:\n• outputting a function of the state, rather than the state directly, seems to increase randomness\n• LCGs clearly lack randomness in the lower bits (top left chart), but the higher bits tend to be ‘more random’ (bottom right chart)\n• if we have e.g. a 16-bit state outputting an 8-bit number, then we only need to choose 8 bits to output\n• why don’t we use the top few bits of the 16-bit state, which are the most random, to choose which function we apply to the remainder of the 16-bit state to generate the 8-bit output\n• in other words, let’s use the most random part of our state to randomly select a transform function to apply to the rest of the state – a randomised algorithm of sorts\n\nLet’s have a look at a simple example.\n\nThe above 9 charts do the following: compute an 8-bit output from a 16-bit state where that 8-bits of output is generated by a pre-determined bit-shift (0 for the top left through to 8 for the bottom right). But what about instead of a fixed shift, a random shift?\n\nWhere do we get that randomness from? From the top few bits of our 16-bit state. In other words, if we have a state of ( ) we could:\n• use the top 2 bits, , to determine the shift – in this case 3\n• apply this shift to the other bits, s.t. instead of selecting the left-most 8 bits, , we shift along 3 to the right and select the bits\n\nIn a way what we are doing when looking at the above 9 charts is using the randomness of the 8–15, 9–16 plots to randomly choose whether we select a number from the – plots. Let’s see how this looks:\n\nThere’s clearly still some structure there but the improvement is huge by simply taking the top 2 bits of the 16-bit state and using this to select a permutation to the rest of the state – hence the name Permuted (Linear) Congruential Generators. But this is just one such transform – a bit shift.\n\nWhat about other transforms? There are a whole host of transforms available (xor, rotation etc) that create the family of PCGs where the top bits randomly select which permutation to apply to the linearly generated state. Let’s look at 2 other such permutations that could be used.\n\nOne such transform that we can (randomly) select is that of a ‘rotation’ of the bits. Just as earlier with the operator we shifted the bits to the right and dropped the overflow, with a rotation we shift one direction but then instead of dropping the overflow we bring it round the other side.\n\nIf we have the number , represented in binary as , we can perform a ‘right rotation’ of to create , or . Here we have taken the 2 right-most bits ( ) and rotated them around to the very start and shifted everything down.\n\nAnother transform we could apply is that of an ‘xorshift’. Again, let’s illustrate with the same example. Again taking ( ) we could:\n• ‘shift’ it down by an amount e.g. 2 to get\n• apply the bitwise exclusive or function to the original number and the shifted number\n\nIn this case we would compute (or in python) on and to get (1s when only 1-bit is 1, 0 if either both are 1 or 0).\n\nNow let’s look at the randograms for 2 common PCGs and see how they compare to above. They are:\n• PCG XSH-RS: first compute an xorshift operation, then randomly shift the resulting bits\n• PCG XSH-RR: first compute an xorshift operation, then randomly rotate the resulting bits\n\nAgain, there’s still structure but they are a marked improvement. This structure exists because we are using ‘small’ generators. Just as the top 8-bits are more random than the bottom 8-bits of a 16-bit state, the top 16-bits are more random than the bottom in a 32-bit state. Also as we use a bigger and bigger state we naturally increase the period. Taking these two things together is why even very large (96-bit state, 32-bit output) LCGs can pass Big Crush – the extensive set of statistical tests packaged up by Pierre L’Ecuyer and Richard Simard to test PRNGs for the desirable properties mentioned earlier.\n\nGiven the added randomness of the randomly selected permutation(s), PCGs perform much better than LCGs and as a result don’t need such large states to pass the test suite. It’s for this reason that they have been adopted as the default PRNG in NumPy – with the exact algorithm being the PCG XSL RR 128/64."
    },
    {
        "link": "https://geeksforgeeks.org/generating-random-number-list-in-python",
        "document": "In Python, we often need to generate a list of random numbers for tasks such as simulations, testing etc. Python’s random module provides multiple ways to generate random numbers. For example, we might want to create a list of 5 random numbers ranging from 1 to 100. This article explores different methods to generate a random number list in Python.\n\nrandom.sample() method is ideal for generating a list of unique random numbers.\n• None random.sample() selects n unique random numbers from the specified range.\n• None It ensures that there are no duplicate values in the output.\n• None This method is efficient and concise when uniqueness is required.\n\nLet’s explore some more ways and see how we can generate random number list in Python.\n\nrandom.randint() function can be used in a list comprehension to generate random numbers, including duplicates.\n• None random.randint(1, 100) generates a random number in the range 1 to 100 (inclusive).\n• None The list comprehension runs the function n times to create the list.\n\nrandom.choices() function generates a list of random numbers, allowing duplicates and providing more control over probabilities.\n• None It allows for duplicate numbers in the output.\n• None This method is slightly less efficient than random.sample() but useful when duplicates are acceptable.\n\nIf we are working with large datasets or need high performance, NumPy provides an efficient way to generate random numbers.\n• None The size parameter determines the number of numbers generated.\n• None Converts the result to a Python list using .tolist().\n\nIf we need random numbers in a specific range, we can shuffle the range and slice it.\n• None randomizes the order of elements in a list.\n• None Slicing gives the desired number of random numbers.\n• None Suitable when the range and size are fixed."
    },
    {
        "link": "https://stackoverflow.com/questions/39714326/random-number-generation-using-python",
        "document": "Since you are forced to use on online IDE, I will assume that this is course work and you do not need the latest and greatest and most reliable random number generator. Instead, you simply need something just adequate for completing ephemeral class assignments.\n\nIf that is the case, a common algorithm for generating random numbers is the linear congruential generator. With typical parameters:\n\nThis algorithm returns supposedly random integers from 0 to (2**32)-1.\n\nHere are some sample results:\n\nYou can read more about this algorithm here.\n\nThis algorithm will always start from the same point after the function is defined unless you change the seed.\n\nAgain, this is not for serious work for which the quality of the results is important.\n\nTo return a \"random\" number between zero and one, , and using the above function :\n\nIf the value in is changed, then should be changed here as well."
    },
    {
        "link": "https://w3schools.com/python/numpy/numpy_random.asp",
        "document": "Random number does NOT mean a different number every time. Random means something that can not be predicted logically.\n\nComputers work on programs, and programs are definitive set of instructions. So it means there must be some algorithm to generate a random number as well.\n\nIf there is a program to generate random number it can be predicted, thus it is not truly random.\n\nCan we make truly random numbers?\n\nYes. In order to generate a truly random number on our computers we need to get the random data from some outside source. This outside source is generally our keystrokes, mouse movements, data on network etc.\n\nWe do not need truly random numbers, unless it is related to security (e.g. encryption keys) or the basis of application is the randomness (e.g. Digital roulette wheels).\n\nIn this tutorial we will be using pseudo random numbers.\n\nNumPy offers the module to work with random numbers.\n\nThe random module's method returns a random float between 0 and 1.\n\nIn NumPy we work with arrays, and you can use the two methods from the above examples to make random arrays.\n\nThe method takes a parameter where you can specify the shape of an array.\n\nThe method also allows you to specify the shape of the array.\n\nThe method allows you to generate a random value based on an array of values.\n\nThe method takes an array as a parameter and randomly returns one of the values.\n\nThe method also allows you to return an array of values.\n\nAdd a parameter to specify the shape of the array."
    },
    {
        "link": "https://stackoverflow.com/questions/31852533/formatting-telephone-number-to-match-specific-pattern",
        "document": "I was wondering if there is a nice way to format a number against a set string pattern, I want to use different phone numbers like that gets output as and that gets output as etc. I was thinking of having the pattern as a data attribute on the input like or depending on what is selected then trying to match the input number to this pattern but completely sure how to achieve this or if it's the correct approach? This format doesn't need to be reflected in the input, the format will be used in presenting the number in a summary.\n\nShould I split the number, loop through each character and .replace the corresponding pattern character whilst avoiding the dashes somehow?"
    },
    {
        "link": "https://stackoverflow.com/questions/71103726/how-to-look-for-patterns-in-numbers-in-javascript",
        "document": "Given any array of numbers, similar in nature to the following:\n\nI want to be able to evaluate this(or any) series of numbers and look for musically meaningful patterns, and I'm not sure how to start going about it.\n\nFor example, if I subtract 48 from every number I would get this:\n\n...one will notice that the 1st, 2nd and 5th numbers are 12 apart from each other, which is a meaningful pattern in music, as 12 steps is one octave. This is one of the things I would want to be able to figure out by just looking at the numbers.\n\nNow, if I take the middle three numbers and subtract 12 from each one I get:\n\n...which is the numerical pattern of steps on a keyboard that would create a Major Triad, which is another example of something I would want to be able to evaluate from a series of numbers.\n\nSo, in the end, the original series of numbers:\n\n...which is a C Major Triad , , with the root doubled down one octave and doubled up one octave as well.\n\nWhat I want to do is write some code that takes in any series of midi message numbers, like the example above, evaluates them, then tells the user what musical entity they have played, including inversions, doublings, other possible interpretations, etc...\n\nThere would be a database/dictionary/object/array/data-thing of some type that contains many different patterns, then the code would compare the incoming numbers to this set of patterns to find the correct one(s)...\n\nNot looking for code answers as much as an idea as to how to go about even getting started with such a thing in javascript, as this would be for the web...\n\nI just don't really have any idea how to start going about this, but any thoughts or examples or resources that could point me in the right direction would be most appreciated."
    },
    {
        "link": "https://kyleshevlin.com/pattern-matching",
        "document": "Today, I want to share with you a coding pattern I frequently use when writing conditional JavaScript. I’ve made several tweets about it throughout the years and it’s high time that I finally write a blog post that I can use as a reference. In fact, I use this pattern so often that my manager at work started to call it the “Kyle pattern”. It shouldn’t be called that, but I’ll take it as a compliment.\n\nI call what I’m about to show you “a poor person’s pattern matching” or “makeshift pattern matching”. It’s not quite the real thing, but it does a pretty good job of coming close to it and is plenty useful.\n\nBefore you go further, you should understand statements pretty well. If you’re not familiar with how they work in JavaScript, I recommend reading the MDN docs on . With that, let’s get to it.\n\nI first encountered “pattern matching” when I started to learn ReasonML a few years ago. In ReasonML, a strongly typed functional language, you have variants. A variant is a union type, but unlike TypeScript, we can have conditional logic based on the type of value passed in, not just the value itself. This is a really powerful mechanism for handling conditional functionality in our programs.\n\nWith ReasonML’s , when we pass in a value, we look at the value’s type and choose different logical paths accordingly. On their home page, they share this example:\n\nThis mechanism quickly becomes the most robust way of doing conditional logic as you use the language. As you work with it, you get comfortable thinking in variants instead of thinking in s or ternaries. But ReasonML’s and JavaScript’s are a bit different, so how can we recreate some of this magic in JavaScript?\n\nWhen using a statement in JavaScript, we most commonly use the expression (the part in parentheses, which makes this parenthetical kind of meta) as if it’s the left half of a strictly equals check ( ), and each as the right half. An example of this I expect a lot of you to be familiar with would be a state reducer a la Redux and/or React.\n\nAs we make calls to , our tries to match the to the with the same string. However, this limits how useful our can be because we can only operate on a single value in the expression. Is there a way around this limitation?\n\nThere sure is.\n\nRhetorical question incoming. What are we doing with the expression and the s exactly? We’re strictly comparing ( ) two values and seeing if they come out or .\n\nInstead, what if we use and make each of our s an expression? This opens up some possibilities.\n\nWith each as an expression, we can do things we couldn’t before, such as:\n• Do multiple comparisons on the same value\n• Use multiple values in those predicate functions\n• and whatever else you can dream up\n\nThe key to using in this way is to think of each expression as a pattern. Sure, we can’t match on variants in the wonderful way that ReasonML can, but we can use the tools we have to get the matches we want. Let’s look at some examples.\n\nIn this first example, I’ve created an function. It generates responses to that annoying question based on the .\n\nPersonally, I find this easier to read than the same code with s. You might disagree, that’s ok. Stick with me.\n\nThe next thing that makes similar to pattern matching is the ability to now use functions in each to generate matches. Let’s consider the ReasonML example above, and adapt it a bit to JavaScript.\n\nThere are other benefits to using a this way, such as fall-throughs. Rather than writing it as an OR expression ( ), you could write two s that use fall-throughs to respond the same way. I’ll “sanitize” a little snippet of an idea from work to show this.\n\nThere are a few other patterns to try with this, but I feel like I’ve given you a pretty good idea of how to get started. I’m trusting you to try it out and practice the pattern.\n\nIf you want an idea to get started with, you might try to solve the “Gilded Rose” kata with and regexes. I was once given this kata as an interview question and I found my pattern matching trick to be a useful way to solve the problem.\n\nThere is a TC39 proposal to add pattern matching to JavaScript, but it’s been stalled at Stage 1 for quite some time. You can find the proposal repo here.\n\nThere is an interesting package called created by my Webflow coworker @suchipi. Check it out if you’re interested in pattern matching with TypeScript.\n\nAnother popular TypeScript package for pattern matching is . It’s highlighted feature is that it can be exhuastive, ensuring every possible type case is covered.\n\nUpdate: Years after writing this post, I decided to try and make a simple, type-safe pattern matching library of my own. I called it . It’s not remarkably more useful than simply using , but it was an interesting exercise that involved some TypeScript shenanigans with the “builder pattern”. You can find it here: https://github.com/kyleshevlin/kase"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions",
        "document": "You construct a regular expression in one of two ways:\n• Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows: Regular expression literals provide compilation of the regular expression when the script is loaded. If the regular expression remains constant, using this can improve performance.\n• Or calling the constructor function of the object, as follows: Using the constructor function provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.\n\nWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern. For example, to match a single followed by zero or more s followed by , you'd use the pattern : the after means \"0 or more occurrences of the preceding item.\" In the string , this pattern will match the substring . The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples. Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions). Distinguish different types of characters. For example, distinguishing between letters and digits. Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression. Indicate numbers of characters or expressions to match. If you want to look at all the special characters that can be used in regular expressions in a single table, see the following: Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).\n\nIf you need to use any of the special characters literally (actually searching for a , for instance), you must escape it by putting a backslash in front of it. For instance, to search for followed by followed by , you'd use — the backslash \"escapes\" the , making it literal instead of special. Similarly, if you're writing a regular expression literal and need to match a slash (\"/\"), you need to escape that (otherwise, it terminates the pattern). For instance, to search for the string \"/example/\" followed by one or more alphabetic characters, you'd use —the backslashes before each slash make them literal. To match a literal backslash, you need to escape the backslash. For instance, to match the string \"C:\\\" where \"C\" can be any letter, you'd use — the first backslash escapes the one after it, so the expression searches for a single literal backslash. If using the constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level. and create the same expression, which searches for \"a\" followed by a literal \"*\" followed by \"b\". The function returns a new string where all special characters in regex syntax are escaped. This allows you to do to create a regular expression that matches only the string .\n\nRegular expressions are used with the methods and and with the methods , , , , , and . Executes a search for a match in a string. It returns an array of information or on a mismatch. Tests for a match in a string. It returns or . Returns an array containing all of the matches, including capturing groups, or if no match is found. Returns an iterator containing all of the matches, including capturing groups. Tests for a match in a string. It returns the index of the match, or if the search fails. Executes a search for a match in a string, and replaces the matched substring with a replacement substring. Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring. Uses a regular expression or a fixed string to break a string into an array of substrings. When you want to know whether a pattern is found in a string, use the or methods; for more information (but slower execution) use the or methods. If you use or and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, . If the match fails, the method returns (which coerces to ). In the following example, the script uses the method to find a match in a string. If you do not need to access the properties of the regular expression, an alternative way of creating is with this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); // similar to 'cdbbdbsbz'.match(/d(b+)d/g); however, // 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ \"dbbd\" ] // while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ] If you want to construct the regular expression from a string, yet another alternative is this script: With these scripts, the match succeeds and returns the array and updates the properties shown in the following table. In this example The matched string and all remembered substrings. The 0-based index of the match in the input string. The index at which to start the next match. (This property is set only if the regular expression uses the g option, described in Advanced Searching With Flags.) The text of the pattern. Updated at the time that the regular expression is created, not executed. As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable. If you do, however, every occurrence is a new regular expression. For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression. For example, assume you have this script: const myRe = /d(b+)d/g; const myArray = myRe.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${myRe.lastIndex}`); // \"The value of lastIndex is 5\" However, if you have this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`); // \"The value of lastIndex is 0\" The occurrences of in the two statements are different regular expression objects and hence have different values for their property. If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.\n\nRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching. These flags can be used separately or together in any order, and are included as part of the regular expression. Makes and match the start and end of each line instead of those of the entire string. An upgrade to the mode with more Unicode features. Perform a \"sticky\" search that matches starting at the current position in the target string. To include a flag with the regular expression, use this syntax: Note that the flags are an integral part of a regular expression. They cannot be added or removed later. For example, creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string. You could replace the line: The flag is used to specify that a multiline input string should be treated as multiple lines. If the flag is used, and match at the start or end of any line within the input string instead of the start or end of the entire string. The , , and flags can be enabled or disabled for specific parts of a regex using the modifier syntax. Using the global search flag with exec() method with the flag returns each match and its position iteratively. In contrast, method returns all matches at once, but without their position. The flag is used to create \"unicode\" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode \"word\": Unicode regular expressions have different execution behavior as well. contains more explanation about this."
    },
    {
        "link": "https://medium.com/@onix_react/exploring-javascript-design-patterns-with-code-examples-35e56fce6b72",
        "document": "In this article we’ll explain what design patterns are and why they’re useful. Additionally, we’ll go over some of the most widely used design patterns and provide examples for each one.\n\nA design pattern is a general reusable solution to a common problem that occurs in software design. These patterns provide a structured and tested approach to solving specific design problems, making them a valuable resource for software developers. They offer several benefits, including:\n• Reusable Reusability saves time and effort in the development process, as developers can leverage established patterns for different aspects of the application. It leads to a more consistent and standardized codebase, which is easier to maintain and extend.\n• Reduce the code size Design patterns encapsulate efficient solutions, reducing the need for custom code. This results in a more concise codebase. Smaller code size simplifies code management and makes the project more understandable. Reduced code complexity enhances overall performance and resource efficiency.\n• No need to refactor the code Properly applied design patterns offer stability to the codebase. When changes are required, they can often be made without the need for major refactoring. It streamlines the development process, as developers can focus on adding new features or addressing specific issues rather than constantly refactoring the existing code.\n• Expressive and understandable Standard design patterns create a common language for developers. The code becomes more expressive as it adheres to established conventions, making it clear and readable. Expressive and understandable code facilitates collaboration and knowledge transfer within the development team, ultimately improving productivity and code quality.\n\nDesign patterns serve as proven templates for solving recurring problems in software design, providing a structured foundation for developers to build upon. They contribute to efficient, maintainable, and high-quality software development.\n\nCreational Design Patterns are a subset of design patterns that deal with the process of object creation in software development. These patterns provide various ways to create objects and manage their instantiation. They help make a system independent of how its objects are created, composed, and represented, and also encapsulate the knowledge about which concrete classes the system uses. Some common creational design patterns include:\n\nDescription: The Module pattern is a popular design pattern in JavaScript used for creating encapsulated modules. It allows developers to create private and public access levels, promoting code maintainability and reusability. In the Module pattern, data and behavior are enclosed within a module, shielding its contents from external scopes to ensure data integrity and reduce the risk of errors and conflicts.\n\nUse Cases: The Module pattern is widely used in JavaScript to structure code and create reusable components with encapsulated data and functionality. It’s particularly helpful for organizing and isolating code within large applications to prevent global scope pollution and provide a clear and organized structure.\n\nExample of the Module Design Pattern\n\nIn this example, and are encapsulated within the module's private scope, and only the properties and methods explicitly returned in the object are accessible from outside the module. This pattern promotes encapsulation, avoids global scope pollution, and contributes to the creation of more maintainable and reusable code.\n\nDescription: The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. It’s often used when you need to control a single point of coordination or state within an application.\n\nUse Cases: Singleton pattern can be applied in scenarios where you want to avoid multiple instances of a class to maintain global state, configuration, or a single source of data.\n\nExample of the Singleton Design Pattern\n\nIn this example, we create a class that follows the Singleton Pattern, ensuring only one instance exists. It provides methods to get, increment, and decrement a shared counter value. Even though we create two instances, and , they share the same counter value, illustrating the Singleton Pattern's ability to maintain a single global instance for managing application state.\n\nDescription: The Prototype pattern leverages JavaScript’s prototypal inheritance to create objects by cloning existing prototypes. It’s used when you want to create new objects efficiently without repeating complex initialization processes.\n\nUse Cases: Prototype pattern is useful when you have objects with shared behaviors and you want to avoid the overhead of recreating those behaviors for each new object.\n\nExample of the Prototype Design Pattern\n\nThe Prototype class in this JavaScript illustration has a counter property and a clone method. Both objects inherit the same counter property when you create a prototype object, set its counter to 5, and then clone it to create . As a result, altering the counter in one object has an impact on the other.\n\nDescription: The Factory pattern abstracts object creation by providing a method or function to create objects without specifying their exact class or constructor. It allows for dynamic object creation based on conditions or input.\n\nUse Cases: Factory pattern is helpful when you need to create objects that share common behaviors but may have variations or when you want to centralize object creation logic.\n\nExample of the Factory Design Pattern\n\nThe code presents a factory function, createUser, that generates user objects with and properties. Each user object includes a method to combine the first and last names. Two user instances, and , are created with different names, showcasing how the Factory Pattern simplifies object creation and promotes code consistency.\n\nDescription: The Constructor pattern allows you to create multiple instances of the same script or plugin with shared properties and methods. It supports inheritance and separates concerns between different instances.\n\nUse Cases: Constructor pattern is suitable for creating multiple instances of objects with shared characteristics and behaviors while allowing for customization.\n\nExample of the Constructor Design Pattern\n\nIn this code, the core element is the constructor function, which exemplifies the Constructor Pattern. Within this function, and 'scientific name' properties are defined, along with a critical method. This constructor efficiently encapsulates the properties and behaviors of tree objects. The example aligns with the Constructor Pattern, offering an organized way to create tree instances with shared properties and methods, enhancing code reusability and maintainability.\n\nDescription: The Observer pattern facilitates a subscription model where objects (observers) subscribe to events and get notified when the events occur in another object (subject or observable). It promotes loose coupling and event-driven programming.\n\nUse Cases: Observer pattern is useful when you want to establish a decoupled system where changes in one part of the application trigger updates in other parts without tight dependencies.\n\nExample of the Observer Design Pattern\n\nThe code provided demonstrates the Observer pattern, a behavioral design pattern. It consists of an class, which represents the subject. This class allows observers to subscribe, unsubscribe, and be notified of changes. It's commonly used for implementing event handling and reactive systems in JS.\n• notify(data): Notifies all observers by calling their functions with the provided data.\n\nThis article has highlighted the importance of design patterns in software development, focusing on their application in JavaScript. Design patterns offer solutions to common problems, enhancing code reusability and maintainability.\n\nWe explored several creational design patterns in JavaScript, such as the Module, Singleton, Prototype, Factory, Constructor, and Observer patterns. These patterns provide structured approaches to object creation and management.\n\nIt’s crucial to select design patterns thoughtfully, aligning them with the project’s specific requirements. Proper utilization of these patterns can significantly improve coding practices, making software more robust and maintainable.\n\nIf you have any questions, leave them in the comments section. We hope you found this article informative and valuable. Thank you for reading."
    }
]