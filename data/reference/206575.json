[
    {
        "link": "https://realpython.com/solid-principles-python",
        "document": "When you build a Python project using object-oriented programming (OOP), planning how the different classes and objects will interact to solve your specific problems is an important part of the job. This planning is known as object-oriented design (OOD), and getting it right can be a challenge. If you’re stuck while designing your Python classes, then the SOLID principles can help you out.\n\nSOLID is a set of five object-oriented design principles that can help you write more maintainable, flexible, and scalable code based on well-designed, cleanly structured classes. These principles are a fundamental part of object-oriented design best practices.\n• Understand the meaning and purpose of each SOLID principle\n• Identify Python code that violates some of the SOLID principles\n• Apply the SOLID principles to refactor your Python code and improve its design\n\nThroughout your learning journey, you’ll code practical examples to discover how the SOLID principles can lead to well-organized, flexible, maintainable, and scalable code.\n\nTo get the most out of this tutorial, you must have a good understanding of Python object-oriented programming concepts, such as classes, interfaces, and inheritance.\n\nThe single-responsibility principle (SRP) comes from Robert C. Martin, more commonly known by his nickname Uncle Bob, who’s a well-respected figure in the software engineering world and one of the original signatories of the Agile Manifesto. In fact, he coined the term SOLID. A class should have only one reason to change. This means that a class should have only one responsibility, as expressed through its methods. If a class takes care of more than one task, then you should separate those tasks into separate classes. Note: You’ll find the SOLID principles worded in various ways out there. In this tutorial, you’ll refer to them following the wording that Uncle Bob uses in his book Agile Software Development: Principles, Patterns, and Practices. So, all the direct quotes come from this book. If you want to read alternate wordings in a quick roundup of these and related principles, then check out Uncle Bob’s The Principles of OOD. This principle is closely related to the concept of separation of concerns, which suggests that you should split your programs into different sections. Each section must address a separate concern. To illustrate the single-responsibility principle and how it can help you improve your object-oriented design, say that you have the following class: In this example, your class has two different responsibilities. It uses the and methods to manage the file. It also deals with ZIP archives by providing the and methods. This class violates the single-responsibility principle because it has two reasons for changing its internal implementation. To fix this issue and make your design more robust, you can split the class into two smaller, more focused classes, each with its own specific concern: Now you have two smaller classes, each having only a single responsibility. takes care of managing a file, while handles the compression and decompression of a file using the ZIP format. These two classes are smaller, so they’re more manageable. They’re also easier to reason about, test, and debug. The concept of responsibility in this context may be pretty subjective. Having a single responsibility doesn’t necessarily mean having a single method. Responsibility isn’t directly tied to the number of methods but to the core task that your class is responsible for, depending on your idea of what the class represents in your code. However, that subjectivity shouldn’t stop you from striving to use the SRP.\n\nThe open-closed principle (OCP) for object-oriented design was originally introduced by Bertrand Meyer in 1988 and means that: Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. To understand what the open-closed principle is all about, consider the following class: The initializer of takes a argument that can be either or . It also takes a specific set of keyword arguments using the syntax. If you set the shape type to , then you should also pass the and keyword arguments so that you can construct a proper rectangle. In contrast, if you set the shape type to , then you must also pass a argument to construct a circle. Note: This example may seem a bit extreme. Its intention is to clearly expose the core idea behind the open-closed principle. also has a method that computes the area of the current shape according to its : The class works. You can create circles and rectangles, compute their area, and so on. However, the class looks pretty bad. Something seems wrong with it at first sight. Imagine that you need to add a new shape, maybe a square. How would you do that? Well, the option here is to add another clause to and to so that you can address the requirements of a square shape. Having to make these changes to create new shapes means that your class is open to modification. That violates the open-closed principle. How can you fix your class to make it open to extension but closed to modification? Here’s a possible solution: In this code, you completely refactored the class, turning it into an abstract base class (ABC). This class provides the required interface (API) for any shape that you’d like to define. That interface consists of a attribute and a method that you must override in all the subclasses. Note: The example above and some examples in the next sections use Python’s ABCs to provide what’s called interface inheritance. In this type of inheritance, subclasses inherit interfaces rather than functionality. In contrast, when classes inherit functionality, then you’re presented with implementation inheritance. This update closes the class to modifications. Now you can add new shapes to your class design without the need to modify . In every case, you’ll have to implement the required interface, which also makes your classes polymorphic.\n\nThe Liskov substitution principle (LSP) was introduced by Barbara Liskov at an OOPSLA conference in 1987. Since then, this principle has been a fundamental part of object-oriented programming. The principle states that: Subtypes must be substitutable for their base types. For example, if you have a piece of code that works with a class, then you should be able to substitute that class with any of its subclasses, such as or , without breaking the code. Note: You can read the conference proceedings from the keynote where Barbara Liskov first shared this principle, or you can watch a short fragment of an interview with her for more context. In practice, this principle is about making your subclasses behave like their base classes without breaking anyone’s expectations when they call the same methods. To continue with shape-related examples, say you have a class like the following: In , you’ve provided the method, which operates with the and instance attributes. Because a square is a special case of a rectangle with equal sides, you think of deriving a class from in order to reuse the code. Then, you override the setter method for the and attributes so that when one side changes, the other side also changes: In this snippet of code, you’ve defined as a subclass of . As a user might expect, the class constructor takes only the side of the square as an argument. Internally, the method initializes the parent’s attributes, and , with the argument. You’ve also defined a special method, , to hook into Python’s attribute-setting mechanism and intercept the assignment of a new value to either the or attribute. Specifically, when you set one of those attributes, the other attribute is also set to the same value: Now you’ve ensured that the object always remains a valid square, making your life easier for the small price of a bit of wasted memory. Unfortunately, this violates the Liskov substitution principle because you can’t replace instances of with their counterparts. When someone expects a rectangle object in their code, they might assume that it’ll behave like one by exposing two independent and attributes. Meanwhile, your class breaks that assumption by changing the behavior promised by the object’s interface. That could have surprising and unwanted consequences, which would likely be hard to debug. While a square is a specific type of rectangle in mathematics, the classes that represent those shapes shouldn’t be in a parent-child relationship if you want them to comply with the Liskov substitution principle. One way to solve this problem is to create a base class for both and to extend: becomes the type that you can substitute through polymorphism with either or , which are now siblings rather than a parent and a child. Notice that both concrete shape types have distinct sets of attributes, different initializer methods, and could potentially implement even more separate behaviors. The only thing that they have in common is the ability to calculate their area. With this implementation in place, you can use the type interchangeably with its and subtypes when you only care about their common behavior: Here, you pass a pair consisting of a rectangle and a square into a function that calculates their total area. Because the function only cares about the method, it doesn’t matter that the shapes are different. This is the essence of the Liskov substitution principle.\n\nThe interface segregation principle (ISP) comes from the same mind as the single-responsibility principle. Yes, it’s another feather in Uncle Bob’s cap. The principle’s main idea is that: Clients should not be forced to depend upon methods that they do not use. Interfaces belong to clients, not to hierarchies. In this case, clients are classes and subclasses, and interfaces consist of methods and attributes. In other words, if a class doesn’t use particular methods or attributes, then those methods and attributes should be segregated into more specific classes. Consider the following example of class hierarchy to model printing machines: In this example, the base class, , provides the interface that its subclasses must implement. inherits from and must implement the same interface. However, doesn’t use the and methods because this type of printer doesn’t support these functionalities. This implementation violates the ISP because it forces to expose an interface that the class doesn’t implement or need. To fix this issue, you should separate the interfaces into smaller and more specific classes. Then you can create concrete classes by inheriting from multiple interface classes as needed: Now , , and are base classes that provide specific interfaces with a single responsibility each. To create , you only inherit the interface. This way, the class won’t have unused methods. To create the class, you need to inherit from all the interfaces. In short, you’ve segregated the interface. This class design allows you to create different machines with different sets of functionalities, making your design more flexible and extensible.\n\nThe dependency inversion principle (DIP) is the last principle in the SOLID set. This principle states that: Abstractions should not depend upon details. Details should depend upon abstractions. That sounds pretty complex. Here’s an example that will help to clarify it. Say you’re building an application and have a class to display data to the users in a friendly way. The app currently gets its data from a database, so you end up with the following code: In this example, the class depends on the class and its concrete implementation. You can say that both classes are tightly coupled. This coupling can lead to scalability issues. For example, say that your app is growing fast, and you want the app to be able to read data from a REST API. How would you do that? You may think of adding a new method to to retrieve the data from the REST API. However, that will also require you to modify , which should be closed to modification, according to the open-closed principle. To fix the issue, you can apply the dependency inversion principle and make your classes depend on abstractions rather than on concrete implementations like . In this specific example, you can introduce a class that provides the interface to use in your concrete classes: In this redesign of your classes, you’ve added a class as an abstraction that provides the required interface, or the method. Note how now depends on the interface provided by , which is an abstraction. Then you define the class, which is a concrete implementation for those cases where you want to retrieve the data from your database. This class depends on the abstraction through inheritance. Finally, you define the class to support retrieving the data from the REST API. This class also depends on the abstraction. Here’s how you can use the class in your code: Here, you first initialize using a object and then again using an object. Every time you call , the result will depend on the concrete data source that you use. Note that you can also change the data source dynamically by reassigning the attribute in your instance."
    },
    {
        "link": "https://medium.com/@cautaerts/all-23-oop-software-design-patterns-with-examples-in-python-cac1d3f4f4d5",
        "document": "All 23 OOP software design patterns with examples in Python\n\nObject oriented programming is probably the dominant paradigm for writing software, and has been for the last three decades. Most popular programming languages support at least some object oriented concepts. Since its inception, there has been fierce debate over whether OOP is the best thing since sliced bread or the biggest mistake made in human history. Additionally, few can agree on what constitutes good OOP.\n\nHowever, nearly all OOP practitioners will agree that “design patterns” are important. In this subdomain, the “Gang of four” (GoF) book (Design Patterns: Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson and Vlissides) might as well be the old testament. Similar to the bible, the GoF book is pretty dry, boring and arcane, which means most people in the modern age never read it but have strong opinions about the subject matter regardless. Yet it seems that reading the book is a right of passage to ascend into the ranks of elite OOP developers.\n\nPython is a popular multi-paradigm language with a bias towards OOP. Yet Python programmers are probably the last people to read the GoF book. Many people who write Python don’t have a computer science background and don’t write serious software. To them, Python is primarily a tool for data analysis and scripting. In this realm, design patterns are useless.\n\nHowever, some Python projects do eventually evolve into serious software. In this case, maintainability and good software architecture become more important, and design patterns could be helpful tools in your toolbox. Therefore, as someone who writes quite a bit of Python, I read the GoF book and present you in this article with the sparknotes version and an illustration of each pattern in Python. I hope you find it useful.\n\nNote that I do not retain exactly the same ordering of the patterns as in the book. Also, I try to use typed Python everywhere as there is limited value to explicitly defined interfaces (a core concept in the book) without types. For a more in-depth explanation on this, I’ve written another article about writing maintainable Python, which you can check it out here:\n\nTo understand the rest of this article you need to understand a few OOP concepts:\n• class: template definition of an object. A class defines the data that will be stored in the object, as well as the behavior the object will exhibit through the implemented methods. A class is defined in code. In some languages classes no longer “exist” at runtime, but in Python you can treat them kind of like objects at runtime. In Python, a class is defined as follows:\n• object: instance of a class. An object encapsulates state which may be altered at runtime by calling the object’s methods. An object only exist at runtime. Instantiating an object from a class is done as follows in Python:\n• state: data and references to other data that are stored in an object.\n• inheritance: a mechanism whereby a new class (child) inherits behavior from an existing class (parent). Multiple classes can inherit from the same parent, yielding a tree-like relationship between classes. Inheritance is typically recommended for modeling “is-a” relationships. We can inherit from in Python as follows:\n• composition: a mechanism whereby complex objects are built up by combining multiple simpler objects through references. Basically whenever one object stores a reference to another object it can be considered composition. Composition is typically recommended for modeling “has-a” relationships. An example of composition in Python could be something like:\n• interface: a contract that defines which methods should be implemented on classes in order for them to adhere to the interface. An interface is a way to enable polymorphism. In Python, we can define an interface using or .\n• polymorphism: when functions or methods accept objects of different classes as if they are from the same class. To illustrate in Python:\n• abstraction: writing code at a higher level hiding implementation details. Polymorphism is a form of abstraction because functions that code to interfaces don’t know anything about underlying implementations.\n• dependency injection: passing one object into another object’s methods or constructor, as opposed to creating these objects internally.\n• mocking: passing a minimal implementation that adheres to the correct interface into functions/methods for the purpose of testing.\n• encapsulation: the idea that related data and operations on that data should be grouped together in a class. It is also related to the idea that a class has public and private data and methods, which allows the class to hide internal implementation details. In Python we can do this as follows:\n\nCreational patterns deal with how objects get created.\n\nImplementing a class such that it can only ever be instantiated once. Instantiating the class again just returns a reference to the existing object.\n\nCreating a Singleton in Python requires us to override the special method that defines how an object is created:\n\nThe intermediate variable serves to satisfy the static type checker, since if we return it will always be considered as having the type which conflicts with the signature (we never return .\n\nWe can now use and verify our singleton as follows:\n\nEven though we call the constructor twice and bind each result to separate variables, the variables point to exactly the same instance.\n\nAdvantages and when to use\n\nA singleton provides an alternative to a global variable, however with some added benefits:\n• Cleaner namespace. We only need the class itself in the namespace, not an additional variable pointing to an instance of the class.\n• If properly implemented it is not possible to create another instance of the same class and bind it to another variable; all variables will point to the same instance.\n• It’s should be possible to change our mind later to allow for more instances of the same class.\n• The singleton can control how and when clients access its data.\n• Because the creation of the object only happens when the constructor is first called, it can be created by passing it data that is only known at runtime.\n\nSingletons introduce globally shared, potentially mutable, state. If many objects reference the singleton that can create very tricky to debug applications, as from each object’s perspective it is unclear which other objects may depend on the singleton. It also makes singletons difficult to test in isolation, because by their very nature they become highly coupled to other classes. Classes that depend on the singleton can also not be tested without the singleton i.e. by using mocks and dependency injection. For all these same reasons, singletons can be tricky to deal with in multi-threaded applications.\n• There are a number of other possible implementations as described in this StackOverflow thread.\n\nThe Factory Method pattern is a way to abstract the creation of different objects that adhere to the same interface. The Factory Method pattern should not be confused with a factory method. A factory method is simply a function or method that creates and returns an object.\n\nWe define a interface that describes the creation flow of objects that adhere to the interface:\n\nIn this case, classes that adhere to the interface must implement a factory method that returns an object that adheres to the interface. We can define a client function that uses the creator to make a product, which is then consumed:\n\nThe client function neither has to care about how is created, nor about which concrete is produced; it is completely decoupled from implementation details.\n\nWe can now create multiple different concrete implementations of creators and products:\n\nHere we use a one-to-one mapping, but one can also imagine a scenario where there are multiple creators for making the same product in different ways.\n\nThese can now be used in the client function. Putting it all together:\n\nAdvantages and when to use\n• If it is not a priori known which product should be created, the Factory Method pattern gives us flexibility (we can reuse the same code with different types of objects) and extensibility (we can easily create new products and creators).\n• The object creation process is encapsulated in separate objects which should make this behavior easier to modify.\n• We separate high level code that only cares about interfaces (the client function) from lower level implementation. This separation should make code easier to test, since we can easily create and insert mock objects that adhere to the same interface as and .\n\nLike many other design patterns we will discuss below, the Factory Method pattern results in additional complexity and a proliferation of classes. This may make the code more difficult to navigate and understand.\n• In the example implementation above, the factory method only calls the constructor of the concrete product. Therefore the factory objects are not so useful, because we could just pass the different concrete products directly into the client function. This construction only becomes useful when the creation of the object requires some more complex logic.\n• The book mentions a number of variations on the Factory method. In our example above, the creator is an interface, which is supposed to be a purely abstract type. However, the creator may also be a concrete class. Variations in the type of product that is created can be built through subclassing and overriding some of the methods. If the creator is a concrete class, it may use the product itself instead of relying on a client function. Finally, the creator can implement a default factory method that maps onto a default product.\n\nThe abstract factory is way to abstract entire families of objects and their creation process. It can be viewed as an additional layer of abstraction above, or a generalization of, the Factory Method pattern.\n\nWe define an interface for a factory object that can create a number of related products. Also these products are abstracted.\n\nWe can then have a client function that uses the factory to create products, so that it can consume them:\n\nNow we can create different implementations of the factory and the products:\n\nWe can then use our client function with the two concrete factories as follows:\n\nAdvantages and when to use\n\nMost of the advantages mentioned in the Factory Method pattern apply here as well. An additional one is that it promotes consistency among products, i.e. that it enforces an application to use all objects from a single family.\n\nMost of the same disadvantages mentioned in the Factory Method also apply. Additionally, by grouping products into a family and tying them together with a factory it becomes difficult to modify this structure. For example, to add a new product, all product families must be modified.\n• The book notes that concrete factories are often implemented as singletons. In Python we can simply define factory methods on factory classes as a or a , which means we could avoid instantiation altogether.\n• While the book notes that factory methods are the most common approaches for creating objects in the concrete factories, this need not be the case and the prototype pattern (see below) can be used instead. By using the prototype, we can avoid having to create a new factory for each new product family.\n• To avoid having to modify each family when adding a new product, one could define a single factory method instead of creating a factory method for each product. The single factory method would then take an argument that indicates which product to make. The downside of this approach is that the return type of becomes a or very generic type, which means that clients can not safely use specific operations defined on only specific products.\n\nThe prototype pattern creates new objects by cloning a prototype instance and potentially modifying it.\n\nThe prototype interface simply needs to implement a way to clone itself. We will also implement some operations on it to modify its internal state and for it to be useful to a client.\n\nSuppose we have two concrete implementations of the prototype:\n\nA client class could then use these prototypes in another operation like :\n\nWe can now use our prototypes with our client as follows:\n\nThe client could also directly use the newly created objects.\n\nAdvantages and when to use\n\nPrototypes can reduce the number of classes that need to be defined, especially compared to patterns like Factory Method or Abstract Factory. Instead of defining products and creators in a class hierarchy and using factory methods, different products can be defined using instances. A new product “class” can be created dynamically at runtime through composing different objects and registering it as a prototype. The prototype can be helpful if construction logic for objects is complicated and should not be duplicated across the code base.\n\nThe main challenge with prototypes is that it is unclear whether a deep or shallow copy is (or should be) made. In the example above we only used integers for internal state, but if we are dealing with complex composite objects one should consider whether all data should be copied or only all references. In the case of shallow copies, a mutation in the state will mutate all objects deriving from the same prototype. Deep copies can be problematic when dealing with circular references.\n• The book notes that the prototype pattern may be less useful in dynamic languages like Python. In Python it is possible to directly store a reference to a class in a variable, so it can be used directly as a prototype instead of creating an instance of a class and cloning it. This is not possible in some other languages like C++.\n• In the example above, the client manages the prototype directly. However, the management of different prototypes could be delegated to a prototype manager, e.g. some global dictionary, where clients access specific prototypes.\n\nThe builder pattern aims to separate the construction logic of a complex object from the object itself, so that the construction logic can be reused to configure an entirely different object.\n\nSuppose we want to create a product that consists of multiple parts:\n\nWe can create a builder class for this product as follows:\n\nThe responsibility of operating the builder is handed to a . To allow the director to handle multiple builders, we can also put a builder interface in between:\n\nFinally, we can use our builder as follows:\n\nAdvantages and when to use\n\nBuilders are mainly useful for complex objects that be configured in many different ways. A key benefit is the splitting of the instantiation process into multiple stages, which contrasts with most other creational patterns. Separating the creation logic from a product can make the product implementation simpler.\n\nMostly added complexity and additional classes. When factory methods are enough, builders are probably overkill.\n• In the example above, all state is directly stored and mutated in the product class itself. It is also common to store configurable state inside the builder and only instantiate the product when or are called. In this way products can be made immutable while still building them in an iterative way.\n• Often builder patterns do not abstract the builder class or implement a . These are only relevant if multiple products need to be built in a similar way and builders can be made to adhere to the same interface. The point of the director is to hide the construction logic from the client. The client only needs to know which builder is needed and the director is responsible for operating it.\n\nStructural patterns are ways in which objects can be combined to create larger structures with additional functionality.\n\nAn adapter is a pattern to make incompatible objects work together. The idea is to create a middle layer that converts the interface of one object to another. A common alternative name for adapter is wrapper.\n\nSuppose we have a client function that expects an object that adheres to a particular target interface\n\nSuppose we now want to use for the following incompatible class:\n\nWe want to be able to use in the without modifying anything. For this we can create an adapter as follows:\n\nOur is compatible with the . We can then use it as follows:\n\nAdvantages and when to use\n\nThe adapter pattern is useful for integrating code that does not work well together, without modifying any existing code. This is an example of the open-closed principle: without modifying existing source code, existing modules can be extended.\n\nIn the simplest case, it can be used for aliasing methods, in more complex cases it can be used to entirely change the behavior of an object. Adapters can be useful when the objects that need to be adapted come from third-party libraries that can not be modified.\n• There can be additional performance overhead due to transformation operations in the adapter.\n• It can complicate the code base.\n\nIn the example above, we use an object adapter, where adaption occurs through composition: we create an object that takes as argument the object we want to adapt. There are also class adapters that are implemented through multiple inheritance of both the target interface and the incompatible class. Class adapters can be more challenging to get right.\n\nA bridge puts a layer between an interface (or abstract class) and an implementation (or concrete class), so that they can vary independently. In some ways it is like adding an interface above an interface, which means that the interface expected by the client can vary independently from the interface exposed by classes that do the heavy lifting.\n\nSuppose we again have a client function that expects an interface:\n\nSuppose we now have a number of implementation classes that adhere to a common but different interface\n\nWe can now create an implementation of the interface expected by the client that creates a bridge to the :\n\nWe can then use this object with the :\n\nAdvantages and when to use\n\nAdding an interface above an interface decreases coupling, since the abstraction the client depends on can be changed independent from the implementation. We can independently create more classes that adhere to the as well as new classes that adhere to the interface.\n\nThe bridge is very similar to the adapter, but it is typically introduced in a design phase, whereas an adapter is usually created after the fact.\n\nDue to the similarity with the adapter, a bridge has the same disadvantages of potentially decreased performance and increased complexity of the code base.\n\nIn the book the is not a pure interface, but already contains some implementation code like a constructor with a link to the . This means the bridge is hard-coded at this level. Extension of this class then happens through inheritance.\n\nThe composite pattern is one way to treat a complex combination of objects as a single object. The composite requires that the objects relate to each other as nodes in a tree-like hierarchy. The pattern ensures that the client can deal with a tree of any shape.\n\nSuppose we have a client function that expects an object with a particular interface :class Component(Protocol):\n\n def operation(self) -> int:\n\n ...\n\n\n\ndef client_function(obj: Component) -> str:\n\n integer = obj.operation()\n\n return f\"The number was {integer}\"\n\nWe can create a composite that models a hierarchic structure but still adheres to the interface as follows:\n\nThe class represents the key component that allows us to build a tree structure, as instances can refer to other instances of itself (additional layers in the tree) or base instances that don’t have children (in this case and ). We can build up a composite tree and use it in the client function as follows:\n\nThe method will be called recursively to add up the result from all the leaf nodes. The client does not have to care about the structure of the composite; the behavior is fully controlled by the structure of the tree.\n\nAdvantages and when to use\n\nComposite is convenient when you need a uniform way to deal both with simple and complex objects. In the book, the examples are primarily focused on graphical applications: a picture might be composed of sub-pictures, which in turn may be composed of primitive shapes like lines and rectangles.\n• It can be difficult to reason about the behavior of the code since the structure of the tree may be dynamic.\n• There may be a tendency for different leaf classes to proliferate, which can make the design too general. This means type checking will be less useful.\n• You can also implement references from child classes to their parent class to make traversing the tree easier.\n• In the example above, and are only part of the class, not of the interface. For this example, only is relevant to the interface, so leaves and composites are identical. However, one could envision a scenario where it is desired to dynamically update the tree, and then leaves and composite nodes no longer have compatible interfaces. It is possible to include the tree updating operations in the interface, but then they also need to be implemented on leaves, which is meaningless. How to best deal with this dilemma depends on the specifics of the problem.\n• The recursive may become computationally expensive if the tree grows in size. If this is the case, one should look into caching some results.\n• Children don’t need to be stored in a list, one could implement something similar with a dictionary.\n\nA decorator adds additional functionality to an object dynamically. Just like an adapter, a decorator is sometimes called a wrapper. But unlike an adapter, a decorator should not change the interface of the object; it only gives it additional responsibilities.\n\nSuppose we have a client that expects an object with a particular interface:\n\nWe can create an implementation of :\n\nThe decorator should also adhere to the interface, but must be able to reference an existing :\n\nWe can now use the decorator as follows:\n\nAdvantages and when to use\n\nDecorators allow objects to be extended without subclassing, so it is very flexible. Specific extension functionality implemented in decorators can be reused and applied to many different objects. The book gives the example of adding a border to a window in a graphical application. Decorators are also used extensively in Python web frameworks like Flask, where functions can be turned into web pages.\n\nDecorators can typically be stacked, which leads to a lot of nested functionality of small components. This can make the program difficult to understand and debug. There may also be a performance cost.\n\nPython has special syntax to apply decorators. Functions, classes and methods can be decorated using the following scheme:\n\nThe downside of this syntax is that the decorator is applied to all objects of the class, so it is not as dynamic as the decorator design pattern intends.\n\nA facade aims to provide a simplified interface to a complex subsystem. It aims to hide the functionality of related classes or modules and expose only the essentials to clients outside the subsystem. In a sense, this is the extension of the idea of public vs. private functionality at the level of multiple classes and/or modules. Classes inside the subsystem may be more coupled than would be desirable if there is no facade.\n\nSuppose we have a number of classes that together form a subsystem\n\nA facade may then expose some or a combination of the underlying functionality\n\nAll clients should then make use of the , instead of crafting custom interactions with or .\n\nAdvantages and when to use\n\nEspecially in large software projects, a facade can be helpful to reduce complexity and increase abstraction. It also decouples clients from the components in the subsystem, allowing the subsystem to evolve independent from any clients. The facade is pretty loosely defined in terms of implementation; most software projects make use of some kind of facade to hide complexity of low level objects.\n\nIf the abstractions are not properly thought out in advance, different clients may require different facades to the same subsystem. This can lead to additional complexity and a pile-up of different interfaces.\n\nThe objects in the subsystem should not depend on or refer to the facade; the link is only one-way.\n\nThe flyweight pattern is a technique to reduce an applications memory footprint and share as much information as possible. Instead of instantiating multiple objects with the same data, flyweight objects can be shared and reused to provide the illusion of many objects.\n\nThe flyweight pattern relies on a to manage the objects. A client should always request flyweight objects through this factory; the factory is then in charge of either returning an existing object or create and store a new one:\n\nIn a real application, the function might be called instead, which would obscure the fact that a new object may or may not actually be created.\n\nAdvantages and when to use\n\nThe flyweight should really only be used if memory constraints are a concern and the application calls for the use of a huge number of objects. The book provides the example of a text editor, where each character can be modeled as an object. Instead of storing each character with all of its formatting individually inside the objects, the characters are flywheels and their formatting is stored as external data in objects.\n• reduced encapsulation. In order to use flyweights effectively, state that is not shared between all virtual instances of an object must be factored out and stored elsewhere as external state. In the example from the book, fonts and styling for characters was moved to external state.\n• potential thread safety issues if multiple threads access the same underlying object simultaneously.\n• potentially increased computational inefficiency. External state needs to be supplied to the operations defined on the flyweight in order to modify the behavior; this may require operations to be recomputed multiple times.\n\nA proxy is an object that acts as an intermediary between a client and a real object. It pretends to be the real object and should have the same interface.\n\nA proxy can be used as an intermediate for an object that may use a lot of resources (memory, cpu, …). The proxy object can then delay using these resources until a specific operation needs it. For example, consider an object that reads a file and stores its data:\n\nThe data is really only necessary when is called but the way the class is defined means that we need the data up front. We can create a proxy with an identical interface that delays the creation of the until when it is strictly necessary:\n\nThe proxy object can then be passed around as if it were the real object, but it acts as intermediary.\n\nThen it can be used as follows:\n\nAdvantages and when to use\n\nA proxy is mainly used for three purposes:\n• delaying the creation of expensive objects or execution of expensive operations.\n• hiding the fact that an object may exist remotely.\n• adding additional logic before and after calls to an object, for example authorization logic.\n\nIdentical to the decorator: decreased performance and increased code complexity.\n\nThe implementation of a proxy is very similar to a decorator. However, the reason for using either is different. The decorator aims to add additional responsibilities to an object. The proxy aims to modify the way an object is accessed.\n\nBehavioral patterns are concerned with the way objects interact and how responsibilities are distributed. Whereas structural patterns provide a somewhat static description of how objects are related, behavioral patterns describe the dynamics and ways of communication.\n\nIn the chain of responsibilities, multiple linked objects may handle a request. If the first object in the chain does not handle a request, it passes it along the chain and so on until it arrives at the object that will handle the request. In case there is a return value, it is propagated back up the chain.\n\nA client function expects an object with an interface that can handle a request:\n\nWe can implement a concrete handler that shows the chain of responsibility model as follows:\n\nThe key idea here is that our handler can optionally store a reference to a successor, which is also a handler. In , the handler first tries to handle the request. If this fails, it checks if the handler has a successor, and if so tries to pass the request along. If we’ve reached the end of the chain and the request has not been handled we return .\n\nIn this example we also use a form of the strategy pattern (see further) to change the behavior of the . The object stored in the handler determines how the handler treats the request. Alternatively, the chain of command pattern can also be implemented using inheritance, by defining the initialization and logic of passing the request along the chain in the parent class and creating multiple different concrete handler classes.\n\nWe can use our example as follows:\n\nAdvantages and when to use\n\nIt is one way to reduce coupling between sender and receiver, since the receiver does not know which receiver will handle the request. The chain can be built up and modified at runtime, giving a lot of flexibility. In some ways it can be seen as a very dynamic if-else or try-except stack.\n• Possible performance issues if the chain is long or the intermediate operations are complex. This is a similar concern with linked list data structure.\n• It may be difficult to deduce which object will handle the request.\n• The chain is only as robust as the weakest link. If one object in the chain handles the request incorrectly, the rest of the chain will likely function incorrectly.\n\nThe chain of responsibility can be used in conjunction with the composite structural pattern, where a parent (if stored in the children) can be used as the successor.\n\nThe command pattern encapsulates a request or action as an object. This allows one to parametrize the request, and add additional functionality to it (such as an undo operation).\n\nThe command interface could be as simple as:\n\nWe want a command to communicate with and invoke methods on a receiver object:\n\nA concrete command would store a reference to the receiver and perform when is called:\n\nFinally, we need an object to work with, potentially store, and execute the commands, the :\n\nPutting it all together:\n\nThe and could be expanded to include undo operations.\n\nAdvantages and when to use\n• Decoupling: it’s easier to extend the system by creating more concrete commands without modifying the .\n• Adding extra functionality by default to operations like logging, undo, scheduling, … which is difficult to do with a simple function call.\n\nA lot of additional complexity which may not be necessary, and a potential explosion in the number of concrete command classes.\n\nIn Python, one does not necessarily need to create a custom object to implement the command pattern. Since functions are also objects, you can also pass them around, then call them when appropriate. The book notes that the command pattern is the OOP equivalent of callback functions.\n\nThe interpreter pattern provides a way to define a grammar and evaluate expressions based on it. A grammar is essentially a language of which you invent the rules. Rules are represented by classes. A valid expression can then be represented by composing objects of these rules classes. Interpreter is design-pattern-ception when it comes to Python. Python, the programming language, is text which can be parsed as expressions, then subsequently evaluated by the Python interpreter. The interpreter and grammar are written in C. The interpreter pattern therefore gives you a way to create a new language using another language.\n\nSuppose we want to create a language to represent basic arithmetic. First, we represent an expression with an interface that just has an method. The method takes a variable, in this case a dictionary (but it does not need to be), which represents some global state for the interpreter.\n\nSecond, we should have two types of expressions: terminal expressions and non terminal expressions. The terminal expressions represent the atoms of the language, something which can not be broken down further and can only be literally interpreted. Non terminal expressions represent combinations of expressions. They both have the same interface, but we can define them explicitly for differentiation in the types of concrete classes.\n\nIn our example, our terminal expressions would be numbers (for now let’s just define integers):\n\nOur non-terminal expressions would be arithmetic operations like:\n\nWe can then express integer arithmetic with addition and multiplication by combining these classes:\n\nThis example is of course a silly example, as it is a very verbose way to express simple concepts. Additionally, if one would want to represent the language in a string so that one could code in it, then a parser would also be necessary.\n\nAdvantages and when to use\n\nThe interpreter pattern makes most sense for creating a domain specific language, where high flexibility is needed on the types of operations that need to be represented. An example would be regular expressions, which provide a condensed way to match patterns in strings.\n\nWriting a useful interpreter can be quite complex. There will also be a performance penalty associated with parsing and evaluating a complex hierarchy of objects, compared to hard-coding the logic in the lower level language.\n\nThe interpreter may create a very large number of objects, so it may be useful to combine with the flyweight pattern, especially for keeping track of the terminal expressions. The interpreter pattern is effectively a specialized form of the composite pattern.\n\nThe iterator is a way to access elements of a collection sequentially without exposing how the elements are represented or how the collection is implemented. Typically, we think of looping over the elements of a list, but an iterator is more abstract than that. The elements do not even have to exist in memory, but can be generated on the fly as we loop over the elements. This idea can be used to represent data streams, which are never ending iterators.\n\nPython already has a lot of built-in magic to make it very easy to create custom iterators. I’ll describe some of that further in additional notes. Here we will take a more first principles approach, which is not recommended for a real application.\n\nFirst we define the interface an iterator must adhere to (according to the book):\n\nTo use our iterator, we can define a client function as follows:\n\nWe can then implement different ways to iterate over a collection, for example traversing a list in the forward and backwards directions:\n\nWe can then use the iterators as follows:\n\nAdvantages and when to use\n\nThe main advantage of the iterator is separation of concerns. An aggregate does not need to be concerned about how its elements should be returned in sequence. By defining custom iterators, we can iterate over the same collection simultaneously using different traversal strategies as in the example above.\n\nThe iterator makes the most sense for linear data structures and less so for e.g. tree-like data structures. Writing custom iterators as in the example above introduces unnecessary complexity and a potential performance hit.\n\nis a protocol which already exists in the standard library. To implement a Python native iterator, only two “dunder” methods must be implemented: and . The method is a concatenation of the , , and methods from our example above: calling immediately returns the current item and changes the internal state of the iterator to go to the next item in the next iteration. If there are no more elements, a exception is raised, which is used to break out of the loop.\n\nWe can implement our more simply as:\n\nThe advantage is that we can now simply use a Python loop on the iterator:\n\nThis is because when you use the Python loop, Python will call the method on the object you try to iterate over, and then continue to call until a is raised. An iterator typically just returns itself in the method, but there are also other objects, e.g. custom collections, that implement which returns a default iterator to iterate over the object. These objects are called This is why you can use the loop syntax directly on default python collection objects like lists, dictionaries and sets. The details are wonderfully explained by this Real Python article.\n\nWhen many objects need to communicate with each other, the network of references can become very complex. A mediator is an object that serves as a central object to receive and pass messages between objects. Typically objects that act as mediators are also called “managers”, “directors” or “controllers”.\n\nSuppose we have many objects that send messages to each other. These we call “colleagues”. Each object keeps track of the messages it receives. In order to send a message to all other colleagues but avoid storing a reference to them in every colleague, it is more convenient to pass through a mediator and store a single reference:\n\nColleagues don’t store references to other colleagues but pass on their message to the mediator. It is then the job of the mediator to call on the other colleagues. This can be implemented as follows:\n\nThe mediator stores a list of references to colleagues, which can be updated with . When is called, the mediator will go through the list of colleagues and call , except on the sender. To demonstrate our set-up:\n\nIn this example all the colleagues are instances of the same class, but this does not have to be the case.\n\nAdvantages and when to use\n\nThe mediator pattern is useful to convert many-to-many relationships, which is very hard to reason about, to one-to-many relationship, which is much easier to understand. If you have a complex system with a convoluted network of interactions between objects, it may be beneficial to centralize control. An additional advantage is that colleagues become decoupled from each other.\n\nThe centralization of interaction protocols between objects into the mediator can make this class complex, monolithic, and hard to maintain.\n\nA memento is an object that stores snapshots of (part of) another object’s state. The memento can then be used later to restore the object to a previous state. Mementos can be useful for undo/redo operations and tracking history.\n\nSuppose we have an object for which we want to keep mementos of the state. The book calls this the . In our example, the only state being stored in the originator is an integer:\n\nThe memento is a simple object that just implements a getter:\n\nThe originator is not responsible for keeping track of mementos; this is the responsibility of the . We can achieve this with a simple wrapper over a list:\n\nThe caretaker should not have to know anything about the implementation of and should not have to look inside. The book notes that ideally only may know about the internals of , however this is very difficult to actually enforce in Python. We can use our example as follows:\n\nAdvantages and when to use\n\nThe memento pattern enhances encapsulation. The originator can have a complex internal state and yet doesn’t need to expose it. Instead, a black box is sent out to store the necessary state elsewhere. By offloading the responsibility of tracking state history to other objects, the originator object can be kept as simple as possible.\n\nConcerns may surface around memory usage, especially if there is a lot of state to store. A possible mitigation strategy recommended by the book is to use mementos to store changes in state, instead of snapshots of state. This does mean that in order to return to an earlier point in history, one must traverse and apply all the changes until the desired point is reached. An additional concern is that complexity is offloaded from the originator to the caretaker.\n• The book recommends that the originator sees a “wide” interface to the memento, while the caretaker sees a “shallow” interface, i.e. it should not be able to access the internal state. As mentioned, it may be difficult to enforce this in Python, but you can try to implement the rule with static type analysis using different definitions.\n• In the example above we use a list to track the mementos. The caretaker can be implemented in any number of ways, and the best way depends on your application. For example, for undo/redo, a stack may be more appropriate.\n• There seems to be no clear guidance on how the caretaker and originator should relate to each other. In our example above they are independent and it is assumed something else manages the communication between them. One could also imagine that the caretaker stores a reference to the originator, and calls originator methods directly in order to create and store snapshots. Finally, a reference to a caretaker could also be stored in the originator, which would be equivalent to the originator managing its own history.\n\nThe observer pattern is also known as the pub-sub pattern. It is one way to organize the communication between objects that need their state to remain in sync, i.e. the state in one object needs to change when the state in another object it changed.\n\nThere are two elements to the observer pattern: observers and subjects. Observers can subscribe to a subject. Whenever the state in the subject changes, all the subscribed observers are notified.\n\nSuppose we have a subject class storing a counter. Whenever the counter is incremented, we would like to notify any observers. The subject could be implemented as follows:\n\nWe can then implement different classes that adhere to the interface and thus can subscribe to the subject. For example, an observer that has its own internal state that depends on the value of the subject’s counter:\n\nIn this implementation, the observer stores a reference to the subject and when notified of the update pulls the state of the subject to update its own state.\n\nWe can now use our subject and observer as follows:\n\nAdvantages and when to use\n\nThe observer pattern promotes loose coupling among observers and somewhat between subject and observers.\n\nObservers don’t know anything about other observers, but through the subject can still stay synced. The book uses as motivating example a graphical application with multiple widgets that rely on the same data back-end. If the data is modified by interacting with one widget, all the other widgets should be updated accordingly.\n\nThe subject doesn’t care about the implementation of the observers, and just has to worry about its internal state and exposing the relevant bits. This means that we can easily extend the system in the future with additional observers.\n\nOnly observers can become somewhat tightly coupled to the subjects they observe.\n\nIn our example above, we manually called increment and have a good overview of which observers are subscribed to the subject. However, an observer does not know how many other observers there are. Typically in real applications, it is the observers that modify the state of the subject. This update could be very costly depending on the type and number of other observers, but the updating observer is blind to this.\n\nAdditionally, the observers are only notified that there has been a change in the subject, but not what has changed. Depending on what the observer needs to do, it could be costly for the observer to figure out what the change was. This can be partially resolved by defining different “events” on the subject, and allowing observers to subscribe only to specific events.\n\nThere are many variations on the observer pattern that all have their advantages and disadvantages:\n• In our example above, is called inside the subject when the state is updated. However, one could also imagine that notify is called from elsewhere, e.g. from an observer that updates the subject state. The advantage of the latter is that multiple state change operations may be necessary before a notify is required, so it can be more performant. The downside is that it is more easy to forget, so you can more easily end up in an unsynced situation.\n• The method could be altered to take some arguments that indicate what has changed, which can reduce the amount of work observers have to do to figure out what changed in the subject. The book calls this the push model, in contrast to the pull model in the example above. For example, in a scenario where observers are subscribed to multiple subjects, it is helpful to pass a reference to the subject on which notify was called in the method. The downside of the push model is that it increases coupling, because the subject has to be aware of the needs of its observers.\n• If there are many interrelated objects and subjects, it may be helpful to combine the observer pattern with the mediator pattern.\n\nThe state pattern is a way to change the behavior of an object through its internal state. The state itself is represented by different classes that adhere to the same interface.\n\nWe have a class, of which the behavior changes with its internal state.\n\nIn this case, has a very simple interface, simply requiring a method to be implemented.\n\nWe can then make two different states, for example representing “on” and “off”.\n\nWe can then use our context and states as follows\n\nAdvantages and when to use\n\nThe main advantage of using the state pattern is that one can avoid long and complex conditional logic. The branches of conditional logic are factored out into their own class. This should make it easier to extend the code with additional states.\n\nThe state pattern also encodes state into a type, which provides additional safety. Typically, all state of the context object is represented by a single variable, so reaching inconsistent states due to erroneous combinations of variables is not possible.\n\nThe state pattern is a very basic example of composition/polymorphism. Its application makes the most sense if there are lots of states.\n\nYou get more classes which may bloat and complicate the codebase. While the code for a single state is now localized in one class and easier to understand, it may be harder to understand how the class will behave given the many classes and the transitions between them.\n• The state pattern does not specify how state objects should be kept track of and who is responsible. If state objects don’t have internal state themselves, and all state is encoded in the type, then they can be reused through the flyweight pattern.\n• The state pattern does not specify how state transitions should be done and who is responsible. State transition logic can be implemented in , in an external object that has a reference to (in the example above we just use the REPL), or in the state objects themselves. The book suggests that the latter may be most preferable if the possible state transitions are known. However, this does introduce dependencies between state classes.\n\nThe strategy pattern aims to encapsulate algorithms and or behaviors, expose them through identical interfaces, so that clients can use them interchangeably. Similar to the state pattern, it allows us to change the behavior of an object based on the selected strategy.\n\nThe class structure is nearly identical to the state pattern. We have a class of which we want to modify behavior through different strategies:\n\nThe interface requires the method to be implemented\n\nTwo different example strategies:\n\nWe can then use our context and strategy as follows:\n\nAdvantages and when to use\n\nSimilar to the state pattern, the strategy pattern avoids long conditional statements and replaces it with polymorphism. This also makes the code more extendable. If the strategies encapsulate a reusable algorithm, this can also promote code reuse as multiple clients can use the same strategies. Precisely like the state pattern, the strategy can be swapped out at run time to give objects very dynamic behavior.\n\nSimilar to the state pattern, we may get a proliferation of classes which may complicate the code base. Because the strategies are now scattered, it may not be clear to clients which strategies are available.\n• The strategy may need data from the context in order to work. There are multiple options to achieve this. First, the context can pass in this data into the methods of the strategy. This makes the strategies most decoupled from the context. However, because strategies must have the same interface, it may mean that we have to pass in data from the context to some strategies that the strategy does not need, in order to satisfy another strategy. Second, the context can pass itself to the strategy methods. However, this requires that the strategies become aware of the context interface.\n• The strategy pattern is often used to illustrate composition versus inheritance. Instead of defining different behaviors in sub-classes (inheritance), the strategy pattern uses composition to factor out unique behavior.\n\nThe template method is a method in a parent or base class that calls other abstract methods that must be implemented in child classes.\n\nWe define an algorithm in an abstract class as a template method:\n\nThe template method relies on two operations which must be implemented in child classes, for example:\n\nWe can then use our “algorithm” as follows:\n\nBy implementing other classes that inherit from , we can reuse the implementation of the algorithm and get a different behavior. This example is silly, but if we have a very long algorithm that just requires a few repeats with minor differences it may make sense to factor out the commonality in a template method, and the differences in custom operations implemented in child classes.\n\nAdvantages and when to use\n• It is a convenient and easy way to factor out common behavior and duplication with minimal repetition or boilerplate.\n• If base classes do a lot of heavy lifting, it can be easy to implement new child classes with very little new code.\n• If there is a clear “is-a” relationship to be found between classes.\n• In compiled languages, inheritance can be more performant than composition, because functions can be inlined at compile time.\n\nAll the disadvantages of using inheritance beyond interface inheritance:\n• It is more difficult to understand where behavior and state is defined, especially if (as is often the case) there are multiple layers of inheritance.\n• The template is inflexible. A change in the template requires a change in all child classes.\n• Child classes are fixed in a potentially non existent hierarchical relationship.\n• Base classes tend to become bloated to accommodate diverging needs of child classes.\n\nThe book notes that instead of using abstract methods one can also implement “operation” methods on the base class, which can be overridden by child classes. The implementation on the base class then serves as a default.\n\nThe visitor pattern describes a way of operating on elements of a potentially heterogeneous collection or structure of objects. It can be seen as a generalization of an Iterator.\n\nConsider multiple classes of which we will create multiple instances and store in one collection. The one shared trait these objects must have is that they “accept” a visitor, i.e. they adhere to a very simple interface:\n\nA is then an interface that implements a visit method for each concrete element class:\n\nWe can then implement concrete visitors that “do something” when visiting each element in the structure/collection. For example, a visitor that keeps a record of the sum of all element values returned by :\n\nWe can now use our elements and visitor as in the following example:\n\nAdvantages and when to use\n\nThe visitor pattern should mainly be used when a composite structure or collection of objects have elements that all have very different interfaces, yet you want to perform different operations on the whole structure. In this case, the visitor factors out thematically related operations into a single class — a concrete visitor — with the only drawback that all elements must implement the very minimal method. This keeps the element classes clean and is in line with the single responsibility principle. Adding a new visitor is easy, however adding a new element is hard (see disadvantages). So the visitor pattern should mainly be used when the structure and composing elements are static, whereas the number of operations that need to be performed on the structure changes often.\n• It can be tricky to implement a new element, since if you have a lot of different visitors, it means the interface needs to be extended as well as all concrete visitor implementations.\n• Visitors and elements are tightly coupled, because the visitor needs to access internal state of the elements in order to do anything.\n\nThe visitor pattern is very flexible and there exist many variations:\n• In the example above, the visitor is responsible for accumulating state as it visits all the elements. It is also possible for the visitor to be stateless and the accept method to return a result which is stored in the client function. However, this restricts the flexibility in implementing new visitors.\n• In the example above, the iteration is defined by the collection object (the list). However, it is also possible to put this responsibility on a custom iterator (if we need an alternative way of traversing the list, e.g. in reverse) or on the visitor itself. The last case is typically only relevant if the traversal depends on the result of a visit.\n\nAn now, after reading 12K words, you are obviously an OOP expert. Or not. The book notes in its own conclusion that it probably didn’t achieve much in terms of showing you how to architect software. It suggests the real value in studying design patterns provide:\n• A shared vocabulary. Now if you hear builder, visitor, factory or strategy, you will have a vague idea of what is meant. You can use these terms to name your classes to indicate to colleagues (who also know design patterns) what the role and intent of a class is.\n• A better insight into existing systems. When you encounter a codebase, you may better appreciate certain design decisions and get a quicker grasp of how different components are related.\n• Tools for more effective refactoring. After you’ve built an iteration of software, you may realize what the system should actually look like and design patterns may be good targets to work towards.\n\nUltimately though, design patterns do not exist in isolation and are somewhat arbitrary constructs with an infinite number of variations made from four basic concepts: classes, objects, composition and inheritance. All patterns can and should be combined into larger constructs. How to do that depends on the requirements of the application and different tradeoffs you want to make in terms of performance, flexibility, readability, maintainability, and extensibility. There is no book that will teach you how to do that, and seems to be more of an art than a science."
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://matematika-mipa.unsri.ac.id/wp-content/uploads/2022/05/Object-Oriented-Python-Master-OOP-by-Building-Games-and-GUIs-Irv-Kalb-z-lib.org_.pdf",
        "document": ""
    },
    {
        "link": "https://toptal.com/python/python-design-patterns",
        "document": "Let’s say it again: Python is a high-level programming language with dynamic typing and dynamic binding. I would describe it as a powerful, high-level dynamic language. Many developers are in love with Python because of its clear syntax, well structured modules and packages, and for its enormous flexibility and range of modern features.\n\nIn Python, nothing obliges you to write classes and instantiate objects from them. If you don’t need complex structures in your project, you can just write functions. Even better, you can write a flat script for executing some simple and quick task without structuring the code at all. As a result, Python program design can be unconstrained and straightforward.\n\nAt the same time Python is a 100 percent object-oriented language. How’s that? Well, simply put, everything in Python is an object. Functions are objects, first class objects (whatever that means). This fact about functions being objects is important, so please remember it.\n\nSo, you can write simple scripts in Python, or just open the Python terminal and execute statements right there (that’s so useful!). But at the same time, you can create complex frameworks, applications, libraries and so on. You can do so much in Python. There are of course a number of limitations, but that’s not the topic of this article.\n\nHowever, because Python is so powerful and flexible, we need some rules (or patterns) when programming in it. So, let see what patterns are, and how they relate to Python. We will also proceed to implement a few essential Python design patterns.\n\nWhy Is Python Good For Patterns?\n\nAny programming language is good for patterns. In fact, patterns should be considered in the context of any given programming language. Both the patterns, language syntax and nature impose limitations on our programming. The limitations that come from the language syntax and language nature (dynamic, functional, object oriented, and the like) can differ, as can the reasons behind their existence. The limitations coming from patterns are there for a reason, they are purposeful. That’s the basic goal of patterns; to tell us how to do something and how not to do it. We’ll speak about patterns, and especially Python design patterns, later.\n\nPython is a dynamic and flexible language. Python design patterns are a great way of harnessing its vast potential.\n\nPython’s philosophy is built on top of the idea of well thought out best practices. Python is a dynamic language (did I already said that?) and as such, already implements, or makes it easy to implement, a number of popular design patterns with a few lines of code. Some design patterns are built into Python, so we use them even without knowing. Even a moderately experienced developer could search existing Python code for design patterns and identify them at a glance. Other patterns are not needed due of the nature of the language.\n\nFor example, Factory is a structural Python design pattern aimed at creating new objects, hiding the instantiation logic from the user. But creation of objects in Python is dynamic by design, so additions like Factory are not necessary. Of course, you are free to implement it if you want to. There might be cases where it would be really useful, but they’re an exception, not the norm.\n\nWhat is so good about Python’s philosophy? Let’s start with this (explore it in the Python terminal):\n\nThese might not be Python patterns in the traditional sense, but these are rules that define the “Pythonic” approach to programming in the most elegant and useful fashion.\n\nWe have also PEP-8 code guidelines that help structure our code. It’s a must for me, with some appropriate exceptions, of course. By the way, these exceptions are encouraged by PEP-8 itself:\n\nCombine PEP-8 with The Zen of Python (also a PEP - PEP-20), and you’ll have a perfect foundation to create readable and maintainable code. Add Design Patterns and you are ready to create every kind of software system with consistency and evolvability.\n\nEverything starts with the Gang of Four (GOF). Do a quick online search if you are not familiar with the GOF.\n\nDesign patterns are a common way of solving well known problems. Two main principles are in the bases of the design patterns defined by the GOF:\n• Program to an interface not an implementation.\n\nLet’s take a closer look at these two principles from the perspective of Python programmers.\n\nProgram to an interface not an implementation\n\nThink about Duck Typing. In Python we don’t like to define interfaces and program classes according these interfaces, do we? But, listen to me! This doesn’t mean we don’t think about interfaces, in fact with Duck Typing we do that all the time.\n\nLet’s say some words about the infamous Duck Typing approach to see how it fits in this paradigm: program to an interface.\n\nIf it looks like a duck and quacks like a duck, it's a duck!\n\nWe don’t bother with the nature of the object, we don’t have to care what the object is; we just want to know if it’s able to do what we need (we are only interested in the interface of the object).\n\nCan the object quack? So, let it quack!\n\nDid we define an interface for our duck? No! Did we program to the interface instead of the implementation? Yes! And, I find this so nice.\n\nAs Alex Martelli points out in his well known presentation about Python software design patterns, “Teaching the ducks to type takes a while, but saves you a lot of work afterwards!”\n\nNow, that’s what I call a Pythonic principle! I have created fewer classes/subclasses compared to wrapping one class (or more often, several classes) in another class.\n\nInstead of doing this:\n\nWe can do something like this:\n\nThe advantages are obvious. We can restrict what methods of the wrapped class to expose. We can inject the persister instance in runtime! For example, today it’s a relational database, but tomorrow it could be whatever, with the interface we need (again those pesky ducks).\n\nComposition is elegant and natural to Python.\n\nBehavioural Patterns involve communication between objects, how objects interact and fulfil a given task. According to GOF principles, there are a total of 11 behavioral patterns in Python: Chain of responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template, Visitor.\n\nI find these patterns very useful, but this does not mean the other pattern groups are not.\n\nIterators are built into Python. This is one of the most powerful characteristics of the language. Years ago, I read somewhere that iterators make Python awesome, and I think this is still the case. Learn enough about Python iterators and generators and you’ll know everything you need about this particular Python pattern.\n\nThis pattern gives us a way to treat a request using different methods, each one addressing a specific part of the request. You know, one of the best principles for good code is the Single Responsibility principle.\n\nEvery piece of code must do one, and only one, thing.\n\nThis principle is deeply integrated in this design pattern.\n\nFor example, if we want to filter some content we can implement different filters, each one doing one precise and clearly defined type of filtering. These filters could be used to filter offensive words, ads, unsuitable video content, and so on.\n\nThis is one of the first Python design patterns I implemented as a programmer. That reminds me: Patterns are not invented, they are discovered. They exist, we just need to find and put them to use. I discovered this one for an amazing project we implemented many years ago: a special purpose WYSIWYM XML editor. After using this pattern intensively in the code, I read more about it on some sites.\n\nThe command pattern is handy in situations when, for some reason, we need to start by preparing what will be executed and then to execute it when needed. The advantage is that encapsulating actions in such a way enables Python developers to add additional functionalities related to the executed actions, such as undo/redo, or keeping a history of actions and the like.\n\nLet’s see what a simple and frequently used example looks like:\n\nLet’s start by pointing out that creational patterns are not commonly used in Python. Why? Because of the dynamic nature of the language.\n\nSomeone wiser than I once said that Factory is built into Python. It means that the language itself provides us with all the flexibility we need to create objects in a sufficiently elegant fashion; we rarely need to implement anything on top, like Singleton or Factory.\n\nIn one Python Design Patterns tutorial, I found a description of the creational design patterns that stated these design “patterns provide a way to create objects while hiding the creation logic, rather than instantiating objects directly using a new operator.”\n\nThat pretty much sums up the problem: We don’t have a new operator in Python!\n\nNevertheless, let’s see how we can implement a few, should we feel we might gain an advantage by using such patterns.\n\nThe Singleton pattern is used when we want to guarantee that only one instance of a given class exists during runtime. Do we really need this pattern in Python? Based on my experience, it’s easier to simply create one instance intentionally and then use it instead of implementing the Singleton pattern.\n\nBut should you want to implement it, here is some good news: In Python, we can alter the instantiation process (along with virtually anything else). Remember the method I mentioned earlier? Here we go:\n\nIn this example, Logger is a Singleton.\n\nThese are the alternatives to using a Singleton in Python:\n• Create one instance somewhere at the top-level of your application, perhaps in the config file.\n• Pass the instance to every object that needs it. That’s a dependency injection and it’s a powerful and easily mastered mechanism.\n\nI don’t intend to get into a discussion on whether dependency injection is a design pattern, but I will say that it’s a very good mechanism of implementing loose couplings, and it helps make our application maintainable and extendable. Combine it with Duck Typing and the Force will be with you. Always.\n\nI listed it in the creational pattern section of this post because it deals with the question of when (or even better: where) the object is created. It’s created outside. Better to say that the objects are not created at all where we use them, so the dependency is not created where it is consumed. The consumer code receives the externally created object and uses it. For further reference, please read the most upvoted answer to this Stackoverflow question.\n\nIt’s a nice explanation of dependency injection and gives us a good idea of the potential of this particular technique. Basically the answer explains the problem with the following example: Don’t get things to drink from the fridge yourself, state a need instead. Tell your parents that you need something to drink with lunch.\n\nPython offers us all we need to implement that easily. Think about its possible implementation in other languages such as Java and C#, and you’ll quickly realize the beauty of Python.\n\nLet’s think about a simple example of dependency injection:\n\nWe inject the authenticator and authorizer methods in the Command class. All the Command class needs is to execute them successfully without bothering with the implementation details. This way, we may use the Command class with whatever authentication and authorization mechanisms we decide to use in runtime.\n\nWe have shown how to inject dependencies through the constructor, but we can easily inject them by setting directly the object properties, unlocking even more potential:\n\nThere is much more to learn about dependency injection; curious people would search for IoC, for example.\n\nBut before you do that, read another Stackoverflow answer, the most upvoted one to this question.\n\nAgain, we just demonstrated how implementing this wonderful design pattern in Python is just a matter of using the built-in functionalities of the language.\n\nLet’s not forget what all this means: The dependency injection technique allows for very flexible and easy unit-testing. Imagine an architecture where you can change data storing on-the-fly. Mocking a database becomes a trivial task, doesn’t it? For further information, you can check out Toptal’s Introduction to Mocking in Python.\n\nYou may also want to research Prototype, Builder and Factory design patterns.\n\nThis may very well be the most famous Python design pattern.\n\nImagine you have a system with a considerable number of objects. Every object is offering a rich set of API methods. You can do a lot of things with this system, but how about simplifying the interface? Why not add an interface object exposing a well thought-out subset of all API methods? A Facade!\n\nFacade is an elegant Python design pattern. It's a perfect way of streamlining the interface.\n\nThere is no surprise, no tricks, the class is a Facade, and that’s all.\n\nIf Facades are used for interface simplification, Adapters are all about altering the interface. Like using a cow when the system is expecting a duck.\n\nLet’s say you have a working method for logging information to a given destination. Your method expects the destination to have a method (as every file object has, for example).\n\nI would say it is a well written method with dependency injection, which allows for great extensibility. Say you want to log to some UDP socket instead to a file,you know how to open this UDP socket but the only problem is that the object has no method. You need an Adapter!\n\nBut why do I find adapter so important? Well, when it’s effectively combined with dependency injection, it gives us huge flexibility. Why alter our well-tested code to support new interfaces when we can just implement an adapter that will translate the new interface to the well known one?\n\nYou should also check out and master bridge and proxy design patterns, due to their similarity to adapter. Think how easy they are to implement in Python, and think about different ways you could use them in your project.\n\nOh how lucky we are! Decorators are really nice, and we already have them integrated into the language. What I like the most in Python is that using it teaches us to use best practices. It’s not that we don’t have to be conscious about best practices (and design patterns, in particular), but with Python I feel like I’m following best practices, regardless. Personally, I find Python best practices are intuitive and second nature, and this is something appreciated by novice and elite developers alike.\n\nThe decorator pattern is about introducing additional functionality and in particular, doing it without using inheritance.\n\nSo, let’s check out how we decorate a method without using built-in Python functionality. Here is a straightforward example.\n\nWhat is not so good here is that the function does much more than executing something. We are not following the single responsibility principle to the letter.\n\nIt would be good to simply write just following:\n\nWe can implement any authorization and authentication functionality in another place, in a decorator, like so:\n\nNow the method is:\n• Does only one thing (at least when looking at the code)\n\nWe write the same using Python’s integrated decorator syntax:\n\nIt is important to note that you are not limited to functions as decorators. A decorator may involve entire classes. The only requirement is that they must be callables. But we have no problem with that; we just need to define the method.\n\nYou may also want to take a closer look at Python’s functools module. There is much to discover there!\n\nI have shown how natural and easy is to use Python’s design patterns, but I have also shown how programming in Python should be easy going, too.\n\n“Simple is better than complex,” remember that? Maybe you have noticed that none of the design patterns is fully and formally described. No complex full-scale implementations were shown. You need to “feel” and implement them in the way that best fits your style and needs. Python is a great language and it gives you all the power you need to produce flexible and reusable code.\n\nHowever, it gives you more than that. It gives you the “freedom” to write really bad code. Don’t do it! Don’t Repeat Yourself (DRY) and never write code lines longer than 80 characters. And don’t forget to use design patterns where applicable; it’s one of the best ways to learn from others and gain from their wealth of experience free of charge."
    },
    {
        "link": "https://stackoverflow.com/questions/32673540/python-how-to-properly-extend-classes-to-modify-the-operation-of-base-methods",
        "document": "I am using some open-source python code that I need to make a slight modification to. Here is the starting situation.\n\nExternally, this would get used as follows:\n\nWhat I need to change\n\nWhat I need to do is two things:\n• None Have return it's with an inserted modification that changes each time it gets called. For example, the first time it gets called I get , the second time I get , etc.\n• None Modify to call in a loop (until some stopping condition), each time setting with which by #1 returns a different string with each call.\n\nwith the following restriction\n• The base code I am using is regularly updated and I don't want to modify that code at all; I want to be able to clone the repo I get it from and only possibly have to modify my \"extended\" code. It's ok to assume the names of the and classes don't change in the base code, nor do the names of the methods I care about here, though some auxiliary methods that I don't need to modify will get updated (which is key for me).\n\nMy main question is what is the best, most Pythonic, way to do this?\n\nGiven the restriction I mentioned, my first inclination is to write derived classes of both and which make the changes I need by writing new versions of the and methods respectively. But, I have a feeling that I should use function decorators to do this. I've read up on them a little and I get the basic idea (they wrap a function so that you can control/modify parameters passed to or values returned from the function you are wrapping without modifying that function?; please correct me if I am missing something crucial). But, I don't know how to implement this in the derived class, neither syntactically nor logically. For example, do I have to give the function decorator that I write a decorator? If so, why?\n\nHere is what I did. It works but I want to learn and understand a) what is the right way to do what I want and b) how to actually do it.\n\nI would then call it just as above but create derived instances and call their methods instead of the base class one's.\n\nBut, there are problems with this that don't satisfy my goal/requirement above: both and perform a lot of other functionality which I would have to just copy into my new functions (see the comment in them). This means when the code I'm using gets updated I have to do the copying to update my derived classes. But, I am ONLY changing what you see here: inserting something into the string that changes with each call and putting a loop at the end of . This is why I have a feeling that function decorators are the way to go. That I can wrap both and so that for the former I can modify the string with each call by looking at a local counter and for the second I can just have a loop that calls the base in a loop and passes a different string each time (it's ok to call multiple times).\n\nAny help with suggestions on the best way to do this and how would be very greatly appreciated."
    },
    {
        "link": "https://stackoverflow.com/questions/71598358/extend-a-python-class-functionality-from-a-different-class",
        "document": "I have a number of Python classes, Say, , , etc from a library/package. I want to extend all of the classes with some common functionalities. If I extend each class individually, we introduce a lot of redundancy and break the \"Don't Repeat Yourself\" acronym. So, my thought is to have a class and use it extend other classes. For example:\n\nSo we can extend , and so on using maybe Multiple inheritances. Say,\n\nSo that at last when I create an object of , etc., I can use the class attributes and methods. Like;\n\nPlease explain how to implement the , etc, to extend the class.\n\nAny help is highly appreciated. Thank you."
    },
    {
        "link": "https://datacamp.com/tutorial/python-inheritance",
        "document": "Inheritance is one of the foundational pillars of object-oriented programming (OOP) that allows one class (called the child class) to derive attributes and methods from another class (called the parent class). This feature is central to code reuse and simplifies maintenance, making it easier to build scalable and efficient programs.\n\nBefore going further, let's explore the relationship between parent and child classes.\n\nLet’s start with the parent class. A parent class is the base class from which child classes derive. It encapsulates shared attributes and methods.\n\nUsing Python, here is how we define a parent class:\n\nA child class inherits attributes and methods from the parent class. This allows it to use the functionality defined in the parent class. The following code shows how a child class inherits attributes and methods from a parent class:\n\nThis simple syntax allows the child class to utilize and extend the functionality defined in the parent class.\n\nLet’s create a practical example with a class as the parent and a class as the child.\n\nThe class contains shared attributes and a method to display information:\n\nThe class inherits from and adds a new method .\n• The class uses the method from to initialize and .\n• The method is unique to the class, extending its functionality.\n• The method is inherited directly from .\n\nInheritance in Python allows classes to inherit attributes and behaviors from other classes, promoting code reuse and clean design, as we talked about earlier. In this section, we can talk about the different types of Python inheritance, which includes single, multiple, hierarchical, and hybrid inheritance as separate categories.\n\nSingle inheritance occurs when a child class inherits from a single parent class, allowing it to extend the functionality of the parent. This is useful when an object type shares common properties with a broader category but also requires additional attributes or behavior.\n\nThe example I started to work through earlier was single inheritance, but let's now look a bit more closely: In a school management system, all individuals, including students, teachers, and staff, share some common details like and . However, students also have academic records such as grades and enrolled courses. Using single inheritance, we can create a class for shared attributes and extend it with a class for academic details.\n\nHere’s a good example of the above scenario:\n\nThe class inherits the method from but extends it to include and . This is a good example of how single inheritance promotes what is known as modular code.\n\nMultiple inheritance, like a family tree, in a way, allows a child class to inherit from more than one parent class, combining attributes and behaviors from each. This can lead to potential conflicts, which Python resolves using method resolution order (MRO).\n\nWe see that the class inherited attributes and methods from both and . Without any additional effort, the class has access to the method from the parent class and the method from the parent class. We are effectively combining functionality from multiple sources.\n\nHowever, inheriting from multiple classes can lead to conflicts. What if both parent classes define a method or attribute with the same name? I mentioned something about method resolution order earlier but let me know say a little something more about it. Method resolution order determines the order in which classes are searched for methods and attributes. The MRO follows a depth-first, left-to-right approach.\n\nYou can view the MRO of a class using the attribute or the method:\n\nPython also supports more complex inheritance structures. I'll show these more complex ideas using the same example.\n\nMultilevel inheritance happens when a child class inherits from another child class, and that child class inherits from a parent class. This creates a chain of inheritance.\n\nHere, each class in the chain adds something new: manages names and IDs, includes grades, and introduces a thesis. Thanks to , we reuse the initialization logic without duplicating code. It’s efficient, neat, and ensures every level of the “inheritance ladder”, as I think of it, works.\n\nIn hierarchical inheritance, multiple child classes inherit from a single parent class, allowing for shared behavior across subclasses with unique attributes.\n\nLet’s look at a good example together:\n\nHere, the class serves as the foundation, offering common attributes and methods ( , , and ). The and classes then extend this functionality by adding their unique properties ( and ) and customizing the method to reflect their specific contexts.\n\nWith this approach, shared functionality stays in one place (the class), while specialized behavior is neatly encapsulated in the subclasses.\n\nHybrid inheritance combines multiple inheritance types, such as multilevel or multiple inheritance, to model more complex relationships.\n\nLet’s look at an example that shows the complexity of hybrid inheritance.\n\nIn this example, the class demonstrates hybrid inheritance by inheriting attributes and methods from both (which itself inherits from ) and . This combines hierarchical inheritance (where inherits from ) and multiple inheritance (where inherits from both and ).\n\nNow, it's time to see the strengths and weaknesses:\n• Reusability: With inheritance you can write code once in the parent class and reuse it in the child classes. Using the example, both and can inherit a method from the parent class.\n• Simplicity: Inheritance models relationships clearly. A good example is the class which “is-a” type of the parent class.\n• Scalability: It also add new features or child classes without affecting existing code. For example, we can easily add a new class as a child class.\n• Complexity: This won't be surprising, but too many levels of inheritance can make the code hard to follow. For example, if an has too many child classes like , , , etc., it may become confusing.\n• Dependency: Changes to a parent class can unintentionally affect all subclasses. If you modify for example, it might break or .\n• Misuse: Using inheritance when it is not the best fit can complicate designs. You would not want to create a solution where inherits from just to reuse . The relationship doesn’t make sense.\n\nNow that we have explored the basics of inheritance, let’s look at some advanced techniques. These techniques, like method overriding, , abstract base classes, and polymorphism, enhance code flexibility and allow for more sophisticated design patterns.\n\nMethod overriding allows a child class to provide a specific implementation for a method already defined in its parent class. This is useful when the inherited behavior doesn’t fully meet the requirements of the child class.\n\nHere, the class overrides the method from the class to give its own specific implementations. This allows the child class to have its own behavior while still following the same method name.\n\nSo why do we override? We override because we want to customize inherited behavior and also because we want to tailor the functionality of a parent method to a child class’s unique requirements.\n\nThe function is used to call methods in the parent class from the child class. This is particularly useful when you want to extend or modify the functionality of a parent class method, such as the constructor method.\n\nSo why do we use the function? We use the super function because we want to call and initialize the parent class’s constructor and also because we want to avoid explicitly naming the parent class. This is helpful, especially in cases of multiple inheritance.\n\nHere, the class uses to call the method of the parent class, so it does not need to repeat code to initialize the and attributes. The child class then introduces a attribute, which is specific to the class.\n\nAn abstract base class (ABC) is a class that cannot be directly used to create objects. It is meant to define a common set of methods that other classes should implement. So ABCs are useful when you want to ensure that certain methods are always present in the child classes.\n\nThe class here is an abstract class that requires any child class to implement the method. This method is being later implemented by the child class, .\n\nPolymorphism means many shapes. In Python, it allows different classes to use the same method name, but each can implement that method in a different way.\n\nPolymorphism helps us write code that can work with objects of different classes, even if those classes have different behaviors:\n\nIn this example, the function can accept any object of type , but it will call the appropriate method based on whether the object is a or a .\n\nWhile inheritance is powerful, it is easy to misuse. I will share some ideas to help you make the most of the ideas.\n\nWhen a child class overrides a method from its parent, the behavior can change.\n\nFor example, if the parent class has a method, and the child class overrides it without considering all scenarios, it might produce incorrect pay calculations.\n\nThe best practice, in this case, is to always test overridden methods thoroughly and document their behavior.\n\nI know this article is about inheritance, but it is not always the right approach. Sometimes, composition, where you build classes by combining objects rather than extending them might be a better fit with whatever you are doing.\n\nTo distll the differences in the most basic way, think that:\n• Inheritance refers to “Is-a” relationships. For example, a is an .\n• Composition refers to “Has-a” relationships. For example, a has an .\n\nSo, how do you know when composition is the best approach to use? Use composition when the relationship is not strictly hierarchical and/or when you want to reduce tight coupling between classes.\n\nOr, we could also say that, while inheritance models relationships, composition focuses on functionality. To help, consider this:\n• Use inheritance when objects are naturally hierarchical. For example, .\n• Use composition when objects share functionality but are not related. For example, a and both use a .\n\nDeep inheritance chains (many levels of parent-child relationships) can make your code hard to read and maintain. This is a problem because changes to a parent class may unintentionally affect many child classes. Also, debugging becomes complex as behavior is spread across multiple levels.\n\nThe best practice in this case is to keep hierarchies shallow. Also, consider using composition (as I mentioned earlier) or breaking a chain into separate hierarchies if you find it is becoming too deep.\n\nInheritance is a major pillar of object-oriented programming that enables developers like you to create reusable, modular, and scalable code. If you can master inheritance, you will find it easy to simplify complex systems.\n\nA good way to deepen your understanding is to try building inheritance structures in your projects. Start simple, then experiment with more complex hierarchies to see how they work in practice.\n\nIf you are eager to explore even deeper, you can check out our Programming Paradigm Concepts course for a deeper understanding of inheritance and other ideas. Our Python Developer career track is also a good resource that offers a comprehensive path to developing advanced programming skills that will equip you for software development."
    },
    {
        "link": "https://realpython.com/inheritance-composition-python",
        "document": "In Python, understanding inheritance and composition is crucial for effective object-oriented programming. Inheritance allows you to model an is a relationship, where a derived class extends the functionality of a base class. Composition, on the other hand, models a has a relationship, where a class contains objects of other classes to build complex structures. Both techniques promote code reuse, but they approach it differently.\n\nBy the end of this tutorial, you’ll understand that:\n• Composition and inheritance in Python model relationships between classes, enabling code reuse in different ways.\n• Composition is achieved by creating classes that contain objects of other classes, allowing for flexible designs.\n• Inheritance models an is a relationship, allowing derived classes to extend base class functionality.\n• Inheritance in Python is achieved by defining classes that derive from base classes, inheriting their interface and implementation.\n\nExploring the differences between inheritance and composition helps you choose the right approach for designing robust, maintainable Python applications. Understanding how and when to apply each concept is key to leveraging the full power of Python’s object-oriented programming capabilities.\n\nAn Overview of Inheritance in Python Everything in Python is an object. Modules are objects, class definitions and functions are objects, and of course, objects created from classes are objects too. Inheritance is a required feature of every object-oriented programming language. This means that Python supports inheritance, and as you’ll see later, it’s one of the few languages that supports multiple inheritance. When you write Python code using classes, you’re using inheritance even if you don’t know that you’re using it. Next up, take a look at what that means. The easiest way to see inheritance in Python is to jump into the Python interactive shell and write a little bit of code. You’ll start by writing the simplest class possible: You declared , which doesn’t do much, but it’ll illustrate the most basic inheritance concepts. Now that you have the class declared, you can create an instance of the class and use the function to list its members: The function returns a list of all the members in the specified object. You haven’t declared any members in , so where’s the list coming from? You can find out using the interactive interpreter: As you can see, the two lists are nearly identical. There are three additional members in : However, every single member of the class is also present in . This is because every class that you create in Python implicitly derives from . You could be more explicit and write , but it’s redundant and unnecessary. Note: In Python 2, you had to explicitly derive from for reasons beyond the scope of this tutorial, but you can read about it in the new-style and classic classes section of the Python 2 documentation. Okay, it’s not entirely true that every class in Python derives from . There’s one aptly named exception, which you’ll learn about next. Every class that you create in Python will implicitly derive from . However, there’s one exception to this rule: classes used to indicate errors by raising an exception. If you try to treat a normal Python class like an exception and it, then Python will present you with a : You created a new class to indicate a type of error. Then you tried to raise the class to signal an exception. Python does indeed raise an exception, but the output states that the exception is of type , not , and that all . is a base class provided for all error types. To create a new error type, you must derive your class from or one of its derived classes. The convention in Python is to derive your custom error types from , which in turn derives from . The correct way to define your error type is the following: In this example, explicitly inherits from instead of implicitly inheriting from . With that change, you’ve fulfilled the requirements for creating a custom exception, and you can now raise your new exception class. When you raise , the output correctly states that Python raised an error of the type . Inheritance is the mechanism that you’ll use to create hierarchies of related classes. These related classes will share a common interface that the base classes will define. Derived classes can specialize the interface by providing a particular implementation where applicable. In this section, you’ll start modeling an HR system. Along the way, you’ll explore the use of inheritance and see how derived classes can provide a concrete implementation of the base class interface. The HR system needs to process payroll for the company’s employees, but there are different types of employees depending on how their payroll is calculated. You start by implementing a class that processes payroll: implements a method that takes a collection of employees and prints their , , and check amount using the method exposed on each employee object. Now, you implement a base class, , that handles the common interface for every employee type: is the base class for all employee types. It’s constructed with an and a . What you’re saying is that every must have an as well as a assigned. The HR system requires that every processed must provide a interface that returns the weekly salary for the employee. The implementation of that interface differs depending on the type of . For example, administrative workers have a fixed salary, so every week they get paid the same amount: You create a derived class, , that inherits from . The class initializes with the and required by the base class, and you use to initialize the members of the base class. You can read all about in Supercharge Your Classes With Python . also requires a initialization parameter that represents the amount that the employee makes per week. The class provides the required method that the HR system uses. The implementation just returns the amount stored in . The company also employs manufacturing workers who are paid by the hour, so you add to the HR system: The class is initialized with and , like the base class, plus the and the required to calculate the payroll. You implement the method by returning the hours worked times the hourly rate. Finally, the company employs sales associates who are paid through a fixed salary plus a commission based on their sales, so you create a class: You derive from because both classes have a to consider. At the same time, you initialize with a value that’s based on the sales for the employee. With , you leverage the implementation of the base class to retrieve the salary, and you add the commission value. Since derives from , you have access to the property directly, and you could’ve implemented using the value of that property. The problem with accessing the property directly is that if the implementation of changes, then you’ll have to also change the implementation of . It’s better to rely on the already-implemented method in the base class and extend the functionality as needed. You’ve created your first class hierarchy for the system. The UML diagram of the classes looks like this: The diagram shows the inheritance hierarchy of the classes. The derived classes implement the interface, which the requires. The implementation requires that the objects in the collection contain an , , and implementation. Note: Interfaces are represented similarly to classes in UML diagrams, with the word Interface above the interface name. Interface names are usually prefixed with a capital . In Python, you don’t implement interfaces explicitly. Instead, interfaces are defined by the attributes used and methods called by other functions and methods. Next, create a new file and call it . This program creates the employees and passes them to the payroll system to process payroll: You can run the program in the command line and see the results: The program creates three employee objects, one for each of the derived classes. Then, it creates the payroll system and passes a list of the employees to its method, which calculates the payroll for each employee and prints the results. Notice how the base class doesn’t define a method. This means that if you were to create a plain object and pass it to the , then you’d get an error. You can try it in the Python interactive interpreter: While you can instantiate an object, can’t use the object. Why? Because it can’t call for . To be more explicit about the requirements of , you can convert the class, which is currently a concrete class, to an abstract class. That way, no employee is ever just an , but instead always a derived class that implements . The class in the example above is what is called an abstract base class. Abstract base classes exist to be inherited, but never instantiated. Python provides the module to formally define abstract base classes. You can use leading underscores in your class name to communicate that objects of that class shouldn’t be created. Underscores provide a friendly way to prevent misuse of your code, but they don’t prevent eager users from creating instances of that class. The module in the Python standard library provides functionality to prevent creating objects from abstract base classes. You can modify the implementation of the class to ensure that it can’t be instantiated: You derive from , making it an abstract base class. Then, you decorate the method with the decorator. This change has two nice side-effects:\n• You’re telling users of the module that objects of type can’t be created.\n• You’re telling other developers working on the module that if they derive from , then they must override the abstract method. You can see that you can’t create objects of type anymore using the interactive interpreter: The output shows that you can’t instantiate the class because it contains an abstract method, . Derived classes must override the method to allow creating objects of their type. When you derive one class from another, the derived class inherits both of the following:\n• The base class interface: The derived class inherits all the methods, properties, and attributes of the base class.\n• The base class implementation: The derived class inherits the code that implements the class interface. Most of the time, you’ll want to inherit the implementation of a class, but you’ll want to implement multiple interfaces so that you can use your objects in different situations. Modern programming languages are designed with this basic concept in mind. They allow you to inherit from a single class, but you can implement multiple interfaces. In Python, you don’t have to explicitly declare an interface. Any object that implements the desired interface can be used in place of another object. This is known as duck typing. Duck typing is usually explained as if it walks like a duck and it quacks like a duck, then it must be a duck. In other words, it’s enough to behave like a duck to be considered a duck. To illustrate this, you’ll now add a class to the example above, and it won’t derive from . Create a new file called and add the following code: The class doesn’t derive from , but it exposes the same interface that requires. Remember that requires a list of objects that implement the following interface:\n• An property or attribute that returns the employee’s ID\n• A property or attribute that represents the employee’s name\n• A method that doesn’t take any parameters and returns the payroll amount to process The class meets all these requirements, so can still calculate its payroll. You can modify the program to use the class: The program creates a object and adds it to the list that processes. You can now run the program and see its output: As you can see, the can still process the new object because it meets the desired interface. Since you don’t have to derive from a specific class for your objects to be reusable by the program, you may be asking why you should use inheritance instead of just implementing the desired interface. The following rules may help you to make this decision:\n• Use inheritance to reuse an implementation: Your derived classes should leverage most of their base class implementation. They must also model an is a relationship. A class might also have an and a , but a is not an , so in this case, you shouldn’t use inheritance.\n• Implement an interface to be reused: When you want your class to be reused by a specific part of your application, you implement the required interface in your class, but you don’t need to provide a base class, or inherit from another class. You can now clean up the example above to move on to the next topic. You can delete the file and then modify the module to its original state: You removed the import of the module since the class doesn’t need to be abstract. You also removed the abstract method from it since it doesn’t provide any implementation. Basically, you’re inheriting the implementation of the and attributes of the class in your derived classes. Since is just an interface to the method, you don’t need to implement it in the base class. Notice how the class derives from . This means that inherits the implementation and interface of . You can see how the method leverages the base class implementation because it relies on the result from to implement its own version. If you’re not careful, inheritance can lead you to a huge hierarchical class structure that’s hard to understand and maintain. This is known as the class explosion problem. You started building a class hierarchy of types used by the to calculate payroll. Now, you need to add some functionality to those classes so that you can use them with the new . tracks productivity based on employee roles. There are different employee roles:\n• Managers: They walk around yelling at people, telling them what to do. They’re salaried employees and make more money.\n• Secretaries: They do all the paperwork for managers and ensure that everything gets billed and payed on time. They’re also salaried employees but make less money.\n• Sales employees: They make a lot of phone calls to sell products. They have a salary, but they also get commissions for sales.\n• Factory workers: They manufacture the products for the company. They’re paid by the hour. With those requirements, you start to see that and its derived classes might belong somewhere other than the module because now they’re also used by the . You create an module and move the classes there: The implementation remains the same, but you move the classes to the module. Your module is now much smaller and focused on the payroll system: With both and in place, you can now update your program to support the change: You run the program and verify that it still works: With everything in place, you start adding the new classes: First, you add a class that derives from . The class exposes a method that the productivity system will use. The method takes the that the employee worked. Then you add , , and and then implement the interface, so they can be used by the productivity system—which you haven’t created yet. As a next step, you can create a new file called and add the class: The class tracks employees in the method that takes a list of employees and the number of hours to track. As outlined above, the productivity system makes use of on each of the objects in to accomplish the tracking. You can now add the productivity system to your program, and update it to represent different types of employees: Your updated program creates a list of employees of different types. The employee list is sent to the productivity system to track their work for forty hours. Then the same list of employees is sent to the payroll system to calculate their payroll. You can run the program to see the output: The program shows the employees working for forty hours through the productivity system. Then it calculates and displays the payroll for each of the employees. The program works as expected, but you had to add four new classes to support the changes. As new requirements come, your class hierarchy will inevitably grow, leading to the class explosion problem where your hierarchies will become so big that they’ll be hard to understand and maintain. The following diagram shows the new class hierarchy: The diagram shows how the class hierarchy is growing. Additional requirements might have an exponential effect on the number of classes with this design. Python is one of the few modern programming languages that supports multiple inheritance. Multiple inheritance is the ability to derive a class from multiple base classes at the same time. Multiple inheritance has a bad reputation to the extent that most modern programming languages don’t support it. Instead, modern programming languages support the concept of interfaces. In those languages, you inherit from a single base class and then implement multiple interfaces, so you can reuse your classes in different situations. This approach puts some constraints in your designs. You can only inherit the implementation of one class by directly deriving from it. You can implement multiple interfaces, but you can’t inherit the implementation of multiple classes. This constraint is good for software design because it forces you to design your classes with fewer dependencies on each other. You will see later in this tutorial that you can leverage multiple implementations through composition, which makes software more flexible. This section, however, is about multiple inheritance, so take a look at how it works. It turns out that sometimes temporary secretaries are hired when there’s too much paperwork to do. The class performs the role of a in the context of the , but for payroll purposes, it’s an . You look at your class design. It’s grown a little bit, but you can still understand how it works. It seems you have two options:\n• Derive from : You can derive from to inherit the method for the role, and then override the method to implement it as an .\n• Derive from : You can derive from to inherit the method, and then override the method to implement it as a . Then, you remember that Python supports multiple inheritance, so you decide to derive from both and : Python allows you to inherit from two different classes by specifying them between parentheses in the class declaration, and separating them with commas. Now, you modify your program to add the new temporary secretary employee: You run the program to test it: python program.py TypeError: SalaryEmployee.__init__() takes 4 positional arguments but 5 were given You get a exception saying that positional arguments where expected, but were given. This is because you derived first from and then from , so the interpreter is trying to use to initialize the object. Okay, go ahead and reverse it: Now, run the program again and see what happens: Now it seems that you’re missing a parameter, which is necessary to initialize , but that parameter doesn’t make sense in the context of a because it’s an . Maybe implementing will help: That didn’t work either. Okay, it’s time for you to dive into Python’s method resolution order (MRO) to see what’s going on. When a method or attribute of a class is accessed, Python uses the class MRO to find it. The MRO is also used by to determine which method or attribute to invoke. You can learn more about in Supercharge Your Classes With Python . You can evaluate the class MRO using the interactive interpreter: The MRO shows the order in which Python is going to look for a matching attribute or method. In the example, this is what happens when you create the object:\n• calls , which the MRO is going to match to , which is inherited from . You can bypass parts of the MRO. In this case, you want to skip the initialization of and . You can do this by reversing the inheritance order again back to how you had it initially. Then, you’ll directly call : When you put before , then the MRO of looks like the following: Because you explicitly specified that should use , you’re effectively skipping and in the MRO when initializing an object. That solves the problem of creating the object, but you’ll run into a similar problem when trying to calculate payroll. You can run the program to see the problem: The problem now is that because you reversed the inheritance order, the MRO is finding the method of before the one in . You need to override in and invoke the right implementation from it: The new method now directly invokes to ensure that you get the correct result. You can run the program again to see it working: The program now works as expected because you’re forcing the method resolution order by explicitly telling the interpreter which method you want to use. As you can see, multiple inheritance can be confusing, especially when you run into the diamond problem. The following diagram shows the diamond problem in your class hierarchy: The diagram shows the diamond problem with the current class design. uses multiple inheritance to derive from two classes that ultimately also derive from . This causes two paths to reach the base class, which is something you want to avoid in your designs. The diamond problem appears when you’re using multiple inheritance and deriving from two classes that have a common base class. This can cause the wrong version of a method to be called. As you’ve seen, Python provides a way to force the right method to be invoked, and analyzing the MRO can help you understand the problem. Still, when you run into the diamond problem, it’s better to rethink the design. You’ll now make some changes to leverage multiple inheritance, avoiding the diamond problem. Two different systems use the derived classes:\n• The payroll system that calculates the employee payroll This means that everything related to productivity should be together in one module, and everything related to payroll should be together in another. You can start making changes to the productivity module: The module implements the class, as well as the related roles that it supports. The classes implement the interface required by the system, but they don’t derive from . You can do the same with the module: The module implements the , which calculates payroll for the employees. It also implements the policy classes for payroll. As you can see, the policy classes don’t derive from anymore. You can now add the necessary classes to the module: The module imports policies and roles from the other modules and implements the different types. You’re still using multiple inheritance to inherit the implementation of the salary policy classes and the productivity roles, but the implementation of each class only needs to deal with initialization. Notice that you still need to explicitly initialize the salary policies in the constructors. You probably saw that the initializations of and are identical. Also, the initializations of and are the same. You won’t want to have this kind of code duplication in more complex designs, so you have to be careful when designing class hierarchies. Here’s the UML diagram for the new design: The diagram shows the relationships to define the and using multiple inheritance, but avoiding the diamond problem. You can run the program and see how it works: You’ve seen how inheritance and multiple inheritance work in Python. You can now explore the topic of composition.\n\nComposition is an object-oriented design concept that models a has a relationship. In composition, a class known as composite contains an object, or component, of another class. In other words, a composite class has a component of another class. Composition allows composite classes to reuse the implementation of the components it contains. The composite class doesn’t inherit the component class interface, but it can leverage its implementation. The composition relation between two classes is considered loosely coupled. That means that changes to the component class rarely affect the composite class, and changes to the composite class never affect the component class. This provides better adaptability to change and allows applications to introduce new requirements without affecting existing code. When looking at two competing software designs, one based on inheritance and another based on composition, the composition solution usually is more flexible. You can now look at how composition works. You’ve already used composition in your examples. If you look at the class, then you’ll see that it contains two attributes:\n• to contain the name of the employee These two attributes are objects that the class has. Therefore, you can say that an has an and has a . Another attribute for an might be an . Create a new Python file called and add code for an class: You implemented a basic address class that contains the usual components for an address. You made the attribute optional because not all addresses will have that component. You implemented to provide a pretty representation of an . You can see this implementation in the interactive interpreter: When you the variable, you’re invoking the special method . Since you overloaded the method to return a string formatted as an address, you get a nice, readable representation. Operator and Function Overloading in Custom Python Classes gives a good overview of the special methods available in classes that you can implement to customize the behavior of your objects. You can now add to the class through composition: You initialize the attribute to for now to make it optional, but by doing that, you can now assign an to an . Also notice that there’s no reference in the module to the module. Composition is a loosely coupled relationship that often doesn’t require the composite class to have knowledge of the component. The UML diagram representing the relationship between and looks like this: The diagram shows the basic composition relationship between and . You can now modify the class to leverage the attribute in : You check to see if the object has an address, and if it does, you print it. You can now modify the program to assign some addresses to the employees: You added a couple of addresses to the and objects. When you run the program, you’ll see the addresses printed: Notice how the payroll output for the and objects shows the addresses where the checks were sent. The class leverages the implementation of the class without any knowledge of what an object is or how it’s represented. This type of design is so flexible that you can change the class without any impact to the class. Composition is more flexible than inheritance because it models a loosely coupled relationship. Changes to a component class have minimal or no effects on the composite class. Designs based on composition are more suitable to change. You change behavior by providing new components that implement those behaviors instead of adding new classes to your hierarchy. Take a look at the multiple inheritance example above. Imagine how new payroll policies will affect the design. Try to picture what the class hierarchy will look like if new roles are needed. As you saw before, relying too heavily on inheritance can lead to class explosion. The biggest problem isn’t so much the number of classes in your design, but how tightly coupled the relationships between those classes are. Tightly coupled classes affect each other when changes are introduced. In this section, you’re going to use composition to implement a better design that still fits the requirements of the and the . You can start by implementing the functionality of the : The updated class defines some roles using a string identifier mapped to a role class that implements the role. It exposes a method that, given a role identifier, returns the role type object. If the role isn’t found, then Python raises a exception. It also exposes the previous functionality in the method, where given a list of employees, it tracks the productivity of those employees. You can now implement the different role classes: Each of the roles that you implemented exposes its own method that takes the number of worked. These methods return a string representing the duties. Note: If you’ve followed along throughout the section on inheritance, then you’ll notice that these roles are similar, but slightly different from that example. Feel free to continue working with the roles that you previously defined and their methods if you prefer. You’ll just need to adapt the relevant names to account for the change. The role classes are independent of each other, but they expose the same interface, so they’re interchangeable. You’ll see later how they’re used in the application. Now, you can implement the for the application: keeps an internal database of payroll policies for each employee. It exposes a method that, given an employee , returns its payroll policy. If a specified doesn’t exist in the system, then the method raises a exception. The implementation of works the same as before. It takes a list of employees, calculates the payroll, and prints the results. You can now implement the payroll policy classes: You first implement a class that serves as a base class for all the payroll policies. This class tracks the , which is common to all payroll policies. The other policy classes derive from . You use inheritance here because you want to leverage the implementation of . Also, , , and are a . is initialized with a value that then uses. is initialized with and implements by leveraging the base class . The class derives from because it wants to inherit its implementation. It’s initialized with the parameters, but it also requires a parameter. The is used to calculate the , which is implemented as a property so it gets calculated when requested. In the example, you’re assuming that a sale happens every five hours worked, and the is the number of sales times the value. implements the method by first leveraging the implementation in and then adding the calculated commission. You can now add an class to manage employee addresses: The class keeps an internal database of objects for each employee. It exposes a method that returns the address of the specified employee . If the employee doesn’t exist, then it raises a . The class implementation remains the same as before: The class manages the address components and provides a pretty representation of an address. So far, the new classes have been extended to support more functionality, but there are no significant changes to the previous design. This is going to change with the design of the module and its classes. You can start by implementing an class: keeps track of all the employees in the company. For each employee, it tracks the , , and . It has an instance of the , the , and the . These instances are used to create employees. It exposes an property that returns the list of employees. The objects are created in an internal method. Notice that you don’t have different types of classes. You just need to implement a single class: You initialize the class with the , , and attributes. This class also requires the productivity for the employee and the policy. The class exposes a method that takes the hours worked. This method first retrieves the from the . In other words, it delegates to the object to perform its duties. In the same way, it delegates to the object to track the work . The , as you saw, uses those hours to calculate the payroll if needed. The following diagram shows the composition design used: The diagram shows the design of composition-based policies. There’s a single that’s composed of other data objects like and depends on the and interfaces to delegate the work. There are multiple implementations of these interfaces. You can now use this design in your program: You can run the program to see its output: This design is what’s called policy-based design, where classes are composed of policies, and they delegate to those policies to do the work. Policy-based design was introduced in the book Modern C++ Design, and it uses template metaprogramming in C++ to achieve the results. Python doesn’t support templates, but you can achieve similar results using composition, as you saw in the example above. This type of design gives you all the flexibility you’ll need as requirements change. Imagine that you need to change the way payroll is calculated for an object at runtime. If your design relies on inheritance, then you need to find a way to change the type of an object to change its behavior. With composition, you just need to change the policy that the object uses. Imagine that your all of a sudden becomes a temporary employee who gets paid by the hour. You can modify the object during the execution of the program in the following way: The program gets the employee list from the and retrieves the first employee, which is the manager you want. Then it creates a new initialized at 55 dollars per hour and assigns it to the manager object. The new policy is now used by the , modifying the existing behavior. You can run the program again to see the result: The check for Mary Poppins, your manager, is now for 2200 dollars instead of the fixed weekly salary of 3000 dollars that she used to have. Notice how you added that business rule to the program without changing any of the existing classes. Consider what type of changes would’ve been required with an inheritance design. You would’ve had to create a new class and change the type of the manager employee. There’s no chance that you could’ve changed the policy at runtime.\n\nChoosing Between Inheritance and Composition in Python So far, you’ve seen how inheritance and composition work in Python. You’ve seen that derived classes inherit the interface and implementation of their base classes. You’ve also seen that composition allows you to reuse the implementation of another class. You’ve implemented two solutions to the same problem. The first solution used multiple inheritance, and the second one used composition. You’ve also seen that Python’s duck typing allows you to reuse objects with existing parts of a program by implementing the desired interface. In Python, it isn’t necessary to derive from a base class to reuse your classes. At this point, you might be asking when to use inheritance vs composition in Python. They both enable code reuse. Inheritance and composition can tackle similar problems in your Python programs. The general advice is to use the relationship that creates fewer dependencies between two classes. This relation is composition. Still, there’ll be times where inheritance will make more sense. The following sections provide some guidelines to help you make the right choice between inheritance and composition in Python. You should only use inheritance to model an is a relationship. Liskov’s substitution principle says that an object of type , which inherits from , can replace an object of type without altering the desirable properties of a program. Liskov’s substitution principle is the most important guideline to determine if inheritance is the appropriate design solution. Still, the answer might not be straightforward in all situations. Fortunately, there’s a simple test that you can use to determine if your design follows Liskov’s substitution principle. Let’s say you have a class, , that provides an implementation and interface you want to reuse in another class, . Your initial thought is that you can derive from and inherit both the interface and the implementation. To be sure this is the right design, you follow theses steps:\n• Evaluate is an : Think about this relationship and justify it. Does it make sense?\n• Evaluate is a : Reverse the relationship and justify it. Does it also make sense? If you can justify both relationships, then you should never inherit those classes from one another. Look at a more concrete example. You have a class that exposes an property. You need a class, which also has an . It seems that a is a special type of , so maybe you can derive from it and leverage both the interface and implementation. Before you jump into the implementation, you use Liskov’s substitution principle to evaluate the relationship. A is a because its area is calculated from the product of its times its . The constraint is that and must be equal. It makes sense. You can justify the relationship and explain why a is a . Now reverse the relationship to see if it makes sense. A is a because its area is calculated from the product of its times its . The difference is that and can change independently. It also makes sense. You can justify the relationship and describe the special constraints for each class. This is a good sign that these two classes should never derive from each other. You might have seen other examples that derive from to explain inheritance. You might be skeptical with the little test that you just did. Fair enough. Next, you’ll write a program that illustrates the problem with deriving from . First, you implement . You’re even going to encapsulate the attributes to ensure that you’re meeting all the constraints: You initialize the class with a and a , and the class provides an property that returns the area. The and are encapsulated as and to avoid changing them directly. Now, you derive from and override the necessary interface to meet the constraints of a : You initialize the class with a , which is used to initialize both components of the base class. Now, you write a small program to test the behavior: The program creates a and a and asserts that their is calculated correctly. You can run the program and see that everything is so far: The program executes correctly, so it seems that is just a special case of a . Later on, you need to support resizing objects, so you make the appropriate changes to the class: Your method takes the and for the object. You can add the following code to the program to verify that it works correctly: You resize the rectangle object and assert that the new area is correct. You can run the program to verify the behavior: The assertion passes, and you see that the program runs correctly. So, what happens if you resize a square? Modify the program, and try to modify the object: You pass the same parameters to that you used with , and print the area. When you run the program you see: The program shows that the new area is like the object. The problem now is that the object no longer meets the class constraint that the length and height must be equal. How can you fix that problem? You can try several approaches, but all of them will be awkward. You can override in and ignore the parameter. However, that will be confusing for people looking at other parts of the program where objects are being resized and some of them are not getting the expected areas because they’re really objects. In a small program like this one, it might be easy to spot the causes of the weird behavior, but in a more complex program, the problem will be harder to find. The reality is that if you’re able to justify an inheritance relationship between two classes both ways, then you shouldn’t derive one class from another. In the example, it doesn’t make sense that inherits the interface and implementation of from . That doesn’t mean that objects can’t be resized. It means that the interface is different because it only needs a parameter. This difference in interface justifies not deriving from , like the test above advised. One of the uses of multiple inheritance in Python is to extend class features through mixins. A mixin is a class that provides methods to other classes but isn’t considered a base class. A mixin allows other classes to reuse its interface and implementation without becoming a superclass. It implements a unique behavior that you can aggregate to other unrelated classes. Mixins are similar to composition, but they create a stronger relationship. Say you want to convert objects of certain types in your application to a dictionary representation of the object. You could provide a method in every class that you want to support this feature, but the implementation of seems to be very similar. This could be a good candidate for a mixin. You start by slightly modifying the class from the composition example: The changes are minimal. You just changed the and attributes to be internal by adding a leading underscore to their names. You’ll see soon why you’re making that change. Now, you create an class in a new file called : The class exposes a method that returns the representation of itself as a dictionary. The method is implemented as a comprehension that creates a dictionary mapping to for each item in if the isn’t internal. Note: This is why you made the role and payroll attributes internal in the class—because you don’t want to represent them in the dictionary. As you saw at the beginning, creating a class inherits some members from , and one of those members is , which is basically a mapping of all the attributes in an object to their values. You iterate through all the items in and filter out the ones that have a name that starts with an underscore using . With , you check the specified value. If the value is an , then the method looks to see if it also has a member and uses it to represent the object. Otherwise, it returns a string representation. If the value isn’t an , then it simply returns the value. You can modify the class to support this mixin: All you have to do is inherit the to support the functionality. It’ll be nice to support the same functionality in the class, so you represent the attribute in the same way: You apply the mixin to the class to support the feature. Now, you can write a small program to test it: The program implements , which converts the dictionary to a JSON string using indentation so the output looks better. Then, it iterates through all the employees, printing the dictionary representation provided by . You can run the program to see its output: You leveraged the implementation of in both and classes even when they’re not related. Because only provides behavior, you can reuse it with other classes without causing problems. Composition models a has a relationship. With composition, a class has an instance of the class and can leverage its implementation. You can reuse the class in other classes completely unrelated to the . In the composition example above, the class has an object. implements all the functionality to handle addresses, and other classes can reuse it. Other classes like or can reuse without being related to . They can leverage the same implementation, ensuring that addresses are handled consistently across the application. A problem that you may run into when using composition is that some of your classes may start growing by using multiple components. Your classes may require multiple parameters in the constructor just to pass in the components that they’re made of. This can make your classes hard to use. A way to avoid the problem is by using the factory method to construct your objects. You did that with the composition example. If you look at the implementation of the class, then you’ll notice that it uses to construct an object with the right parameters. This design will work, but ideally, you should be able to construct an object just by specifying an ID, for example . The following changes might improve your design. You can start with the module: First, you make the class internal by prepending an underscore to the class name. Then you provide a internal variable to the module. You’re communicating to other developers that they shouldn’t create or use directly. Instead, you provide two functions, and , as the public interface to the module. This is what other modules should use. What you’re saying is that is a singleton, and there should only be one object created from it. Now, you can do the same with the module: Again, you make internal and provide a public interface to it. The application will use the public interface to get policies and calculate payroll. You’ll now do the same with the module: You’re basically saying that there should only be one , one , and one . Again, this design pattern is called the singleton design pattern, which comes in handy for classes from which there should only be one single instance. Now, you can work on the module. You’ll also mark the as internal and make a singleton out of it, but you’ll make some additional changes: You first import the relevant public functions and classes from other modules. You make internal, and at the bottom, you create a single instance. This instance is public and part of the interface because you’ll want to use it in the application. You changed the attribute to a dictionary where the key is the employee ID and the value is the employee information. You also exposed a method to return the information for the specified employee . The property now sorts the keys to return the employees sorted by their . You replaced the method that constructed the objects with calls to the initializer directly. The class now is initialized with the ID and uses the public functions exposed in the other modules to initialize its attributes. You can now change the program to test the changes: You import the relevant functions from the and modules, as well as the and class. The program is cleaner because you exposed the required interface and encapsulated how to access objects. Notice that you can now create an object directly just using its ID. You can run the program to see its output: The program works the same as before, but now you can see that you can create a single object from its ID and display its dictionary representation. Take a closer look at the class: The class is a composite that contains multiple objects providing different functionality. It contains an that implements all the functionality related to where the employee lives. also contains a productivity role from the module, and a payroll policy from the module. These two objects provide implementations that the class leverages to track work in the method and to calculate the payroll in the method. You’re using composition in two different ways. The class provides additional data to , while the role and payroll objects provide additional behavior. Still, the relationship between and those objects is loosely coupled, which provides some interesting capabilities that you’ll see in the next section. Inheritance, as opposed to composition, is a tightly coupled relationship. With inheritance, there’s only one way to change and customize behavior. Method overriding is the only way to customize the behavior of a base class. This creates rigid designs that are difficult to change. Composition, on the other hand, provides a loosely coupled relationship that enables flexible designs and can be used to change behavior at runtime. Imagine you need to support a long-term disability (LTD) policy when calculating payroll. The policy states that an employee on LTD should be paid 60 percent of their weekly salary, assuming forty hours of work. With an inheritance design, this can be a very difficult requirement to support. Adding it to the composition example is a lot simpler. Start by adding the policy class: Notice that doesn’t inherit from , but implements the same interface. This is because the implementation is completely different, so you don’t want to inherit any of the implementation. The initializes to and provides an internal method that raises an exception if the hasn’t been applied. Then, it provides an method to assign . The public interface first checks that has been applied, and then it implements the functionality in terms of that base policy. The method just delegates to the base policy, and uses it to calculate the and then return the 60 percent. You can now make a small change to the class: You added an method that applies the existing payroll policy to the new policy and then substitutes it. You can now modify the program to apply the policy to an object: The program accesses located at index , creates the object, and applies the policy to the employee. When you call , the change is reflected. You can run the program to evaluate the output: The check amount for employee Kevin Bacon, who’s the sales employee, is now for 1080 dollars instead of 1800 dollars. That’s because the has been applied to the salary. As you can see, you were able to support the changes just by adding a new policy and modifying a couple of interfaces. This is the kind of flexibility that policy design based on composition gives you. Choosing Between Inheritance and Composition in Python Python, as an object-oriented programming language, supports both inheritance and composition. You saw that inheritance is best used to model an is a relationship, whereas composition models a has a relationship. Sometimes, it’s hard to see what the relationship between two classes should be, but you can follow these guidelines:\n• Use inheritance over composition in Python to model a clear is a relationship. First, justify the relationship between the derived class and its base. Then, reverse the relationship and try to justify it. Only if you can’t justify the relationship in both directions should you use inheritance between them.\n• Use inheritance over composition in Python to leverage both the interface and implementation of the base class.\n• Use inheritance over composition in Python to provide mixin features to several unrelated classes when there’s only one implementation of that feature.\n• Use composition over inheritance in Python to model a has a relationship that leverages the implementation of the component class.\n• Use composition over inheritance in Python to create components that multiple classes in your Python applications can reuse.\n• Use composition over inheritance in Python to implement groups of behaviors and policies that can be applied interchangeably to other classes to customize their behavior.\n• Use composition over inheritance in Python to enable runtime behavior changes without affecting existing classes. With that, you have a strong understanding of when to use inheritance vs composition."
    },
    {
        "link": "https://geeksforgeeks.org/inheritance-in-python",
        "document": "Inheritance is a fundamental concept in object-oriented programming (OOP) that allows a class (called a child or derived class) to inherit attributes and methods from another class (called a parent or base class). This promotes code reuse, modularity, and a hierarchical class structure. In this article, we’ll explore inheritance in Python.\n\nInheritance allows us to define a class that inherits all the methods and properties from another class.\n• None Animal is the parent class with an __init__ method and a speak method.\n• None Dog is the child class that inherits from Animal.\n• None The speak method is overridden in the Dog class to provide specific behavior.\n• Parent Class\n• None This is the base class from which other classes inherit.\n• None It contains attributes and methods that the child class can reuse.\n• Child Class:\n• None This is the derived class that inherits from the parent class.\n• None The syntax for inheritance is class ChildClass(ParentClass).\n• None The child class automatically gets all attributes and methods of the parent class unless overridden.\n\nIn object-oriented programming, a parent class (also known as a base class) defines common attributes and methods that can be inherited by other classes. These attributes and methods serve as the foundation for the child classes. By using inheritance, child classes can access and extend the functionality provided by the parent class.\n\nHere’s an example where Person is the parent class:\n• None The Person class has two attributes: name and id. These are set when an of the class is created.\n• None The display method prints the name and id of the person.\n\nA child class (also known as a subclass) is a class that inherits properties and methods from its parent class. The child class can also introduce additional attributes and methods, or even override the ones inherited from the parent.\n\nIn this case, Emp is the child class that inherits from the Person class:\n• Emp class inherits the name and id attributes and the display method from the Person class.\n• __init__ method in Emp calls super().__init__(name, id) to invoke the constructor of the Person class and initialize the inherited attributes.\n• Emp introduces an additional attribute, role, and also overrides the display method to print the role in addition to the name and id.\n\n__init__() function is a constructor method in Python. It initializes the object’s state when the object is created. If the child class does not define its own __init__() method, it will automatically inherit the one from the parent class.\n\nIn the example above, the __init__() method in the Employee class ensures that both inherited and new attributes are properly initialized.\n• __init__() method in Person initializes name and idnumber.\n• super().__init__(name, idnumber) to initialize the name and idnumber inherited from the Person class and adds salary and post.\n\nsuper() function is used to call the parent class’s methods. In particular, it is commonly used in the child class’s __init__() method to initialize inherited attributes. This way, the child class can leverage the functionality of the parent class.\n• None The super() function is used inside the __init__() method of Employee to call the constructor of Person and initialize the inherited attributes (name and idnumber).\n• None This ensures that the parent class functionality is reused without needing to rewrite the code in the child class.\n\nOnce inheritance is established, both the parent and child classes can have their own properties. Properties are attributes that belong to a class and are used to store data.\n• None Person class has properties name and idnumber\n• None The properties are initialized when an object is created, and they represent the specific data related to the Person and Employee.\n• Multiple Inheritance : A child class inherits from more than one parent class.\n• Multilevel Inheritance : A class is derived from a class which is also derived from another class.\n• Hybrid Inheritance : A combination of more than one type of inheritance.\n• Multiple Inheritance: EmployeePersonJob inherits from both Employee and Job, allowing access to both name and salary.\n• Multilevel Inheritance: Manager inherits from EmployeePersonJob, which already includes Employee and Job.\n• Hierarchical Inheritance : AssistantManager also inherits from EmployeePersonJob, demonstrating multiple child classes inheriting from the same parent.\n• Hybrid Inheritance : SeniorManager inherits from both Manager (multilevel) and AssistantManager (hierarchical), combining two inheritance types.\n\nFor more details please read this article: Types of inheritance in Python"
    }
]