[
    {
        "link": "https://stackoverflow.com/questions/41550819/static-method-in-java-best-practice",
        "document": "I'm wondering, that using static method, like in example below, is good or bad behavior. Let me know, what you think :)\n\nThis is pure example, but I'm using this kind of method a lot. Always I'm passing all required params, never use any content in method class."
    },
    {
        "link": "https://docs.oracle.com/javase/7/docs/technotes/guides/language/static-import.html",
        "document": "In order to access static members, it is necessary to qualify references with the class they came from. For example, one must say:In order to get around this, people sometimes put static members into an interface and inherit from that interface. This is a bad idea. In fact, it's such a bad idea that there's a name for it: the(see Effective Java Item 17). The problem is that a class's use of the static members of another class is a mere implementation detail. When a class implements an interface, it becomes part of the class's public API. Implementation details should not leak into public APIs.\n\nThe static import construct allows unqualified access to static members without inheriting from the type containing the static members. Instead, the program imports the members, either individually:\n\nor en masse:Once the static members have been imported, they may be used without qualification:The static import declaration is analogous to the normal import declaration. Where the normal import declaration imports classes from packages, allowing them to be used without package qualification, the static import declaration imports static members from classes, allowing them to be used without class qualification.\n\nSo when should you use static import? Very sparingly! Only use it when you'd otherwise be tempted to declare local copies of constants, or to abuse inheritance (the Constant Interface Antipattern). In other words, use it when you require frequent access to static members from one or two classes. If you overuse the static import feature, it can make your program unreadable and unmaintainable, polluting its namespace with all the static members you import. Readers of your code (including you, a few months after you wrote it) will not know which class a static member comes from. Importing all of the static members from a class can be particularly harmful to readability; if you need only one or two members, import them individually. Used appropriately, static import can make your program more readable, by removing the boilerplate of repetition of class names."
    },
    {
        "link": "https://stackoverflow.com/questions/7530535/java-coding-convention-about-static-method",
        "document": "It is a very simple question, but I think it is a little bit controversial.\n\nWhen I code Java classes I use the following order.\n\nI read an article that says:\n\n (From http://code.google.com/webtoolkit/makinggwtbetter.html#codestyle)\n\nJava types should have the following member order:\n\nNested Types (mixing inner and static classes is okay)\n\n Static Fields\n\n Static Initializers\n\n Static Methods\n\n Instance Fields\n\n Instance Initializers\n\n Constructors\n\n Instance Methods\n\nIf I follow the article, the order above should be\n\nIn the case of the latter, I feel uncomfortable having some methods before constructors. Which one is the more widely-used convention?"
    },
    {
        "link": "https://geeksforgeeks.org/static-method-in-java-with-examples",
        "document": "The static keyword is used to construct methods that will exist regardless of whether or not any instances of the class are generated. Any method that uses the static keyword is referred to as a static method.\n• None A static method in Java is a method that is part of a class rather than an instance of that class.\n• None Every instance of a class has access to the method.\n• None Static methods have access to class variables (static variables) without using the class’s object (instance).\n• None Only static data may be accessed by a static method. It is unable to access data that is not static (instance variables).\n• None In both static and non-static methods, static methods can be accessed directly.\n\nThe name of the class can be used to invoke or access static methods.\n\nExample 1: The static method does not have access to the instance variable\n\nThe JVM runs the static method first, followed by the creation of class instances. Because no objects are accessible when the static method is used. A static method does not have access to instance variables. As a result, a static method can’t access a class’s instance variable.\n\nExample 2: In both static and non-static methods, static methods are directly accessed.\n• None To access and change static variables and other non-object-based static methods.\n• None Non-static data members or non-static methods cannot be used by static methods, and static methods cannot call non-static methods directly.\n• None In a static environment, this and super aren’t allowed to be used.\n\nWhy is the main method in Java static?\n\nIt’s because calling a static method isn’t needed of the object. If it were a non-static method, JVM would first build an object before calling the main() method, resulting in an extra memory allocation difficulty.\n\nDifference Between the static method and instance method"
    },
    {
        "link": "https://baeldung.com/java-static",
        "document": "In this tutorial, we’ll explore the static keyword of the Java language in detail. The static keyword means that a member – like a field or method – belongs to the class itself, rather than to any specific instance of that class. As a result, we can access static members without the need to create an instance of an object.\n\nWe’ll begin by discussing the differences between static and non-static fields and methods. Then, we’ll cover static classes and code blocks, and explain why non-static components can’t be accessed from a static context.\n\nIn Java, when we declare a field static, exactly a single copy of that field is created and shared among all instances of that class.\n\nIt doesn’t matter how many times we instantiate a class. There will always be only one copy of static field belonging to it. The value of this static field is shared across all objects of the same class. From the memory perspective, static variables are stored in the heap memory.\n\nImagine a class with several instance variables, where each new object created from this class has its own copy of these variables. However, if we want a variable to track the number of objects created we use a static variable instead. This allows the counter to be incremented with each new object:\n\nAs a result, the static variable numberOfCars will be incremented each time we instantiate the Car class. Let’s create two Car objects and expect the counter to have a value of two:\n\nAs we can see static fields can come in handy when:\n• the value of the variable is independent of objects\n• the value is supposed to be shared across all objects\n\nLastly, it’s important to know that static fields can be accessed through an instance (e.g. ford.numberOfCars++) or directly from the class (e.g. Car.numberOfCars++). The latter is preferred, as it clearly indicates that it’s a class variable rather than an instance variable.\n\nSimilar to static fields, static methods also belong to a class instead of an object. So, we can invoke them without instantiating the class. Generally, we use static methods to perform an operation that’s not dependent upon instance creation.\n\nFor example, we can use a static method to share code across all instances of that class:\n\nAdditionally, we can use static methods to create utility or helper classes. Some popular examples are the JDK’s Collections or Math utility classes, Apache’s StringUtils, and Spring Framework’s CollectionUtils.\n\nThe same as for static fields, static methods can’t be overridden. This is because static methods in Java are resolved at compile time, while method overriding is part of Runtime Polymorphism.\n\nThe following combinations of the instance, class methods, and variables are valid:\n• instance methods can directly access both instance methods and instance variables\n• instance methods can also access static variables and static methods directly\n• static methods can access all static variables and other static methods\n• static methods can’t access instance variables and instance methods directly. They need some object reference to do so.\n\nGenerally, we’ll initialize static variables directly during declaration. However, if the static variables require multi-statement logic during initialization we can use a static block instead.\n\nFor instance, let’s initialize a List object with some predefined values using static block of code:\n\nAs we can see, it wouldn’t be possible to initialize a List object with all the initial values along with the declaration. So, this is why we’ve utilized the static block here.\n\nA class can have multiple static members. The JVM will resolve the static fields and static blocks in the order of their declaration. To summarize, the main reasons for using static blocks are:\n• to initialize static variables needs some additional logic apart from the assignment\n\nJava allows us to create a class within a class. It provides a way of grouping elements we use in a single place. This helps to keep our code more organized and readable.\n\nIn general, the nested class architecture is divided into two types:\n• nested classes that we declare static are called static nested classes\n• nested classes that are non-static are called inner classes\n\nThe main difference between these two is that the inner classes have access to all members of the enclosing class (including private ones), whereas the static nested classes only have access to static members of the outer class.\n\nStatic nested classes behave exactly like any other top-level class – but are enclosed in the only class that will access it, to provide better packaging convenience.\n\nFor example, we can use a nested static class to implement the singleton pattern:\n\nWe use this method because it doesn’t require any synchronization and is easy to learn and implement.\n\nAdditionally, we can use a nested static class where visibility between parent and nested members is displayed, and vice versa:\n\nThe result when we run the main method is:\n\nBasically, a static nested class doesn’t have access to any instance members of the enclosing outer class. It can only access them through an object’s reference. The main reasons for using static inner classes in our code are:\n• grouping classes intended for use in only one place increases encapsulation.\n• to bring the code closer to the only place that will use it. This increases readability, and the code is more maintainable.\n• if a nested class doesn’t require any access to its enclosing class instance members, it’s better to declare it as static. This way, we won’t couple it to the outer class, and they won’t require any heap or stack memory.\n\nThe error “Non-static variable cannot be referenced from a static context” occurs when a non-static variable is used inside a static context. As we saw earlier, the JVM loads static variables at class load time, and they belong to the class. On the other hand, we need to create an object to refer to non-static variables.\n\nSo, the Java compiler complains because there’s a need for an object to call or use non-static variables.\n\nNow that we know what causes the error, let’s illustrate it using an example:\n\nAs we can see, we used instanceVariable, which is a non-static variable, inside the static method staticMethod(). Consequently, we’ll get the error Non-static variable cannot be referenced from a static context.\n\nIn this article, we saw the static keyword in action and discussed the main reasons for using static fields, methods, blocks, and inner classes.\n\nFinally, we learned what causes the compiler to fail with the error “Non-static variable cannot be referenced from a static context”."
    },
    {
        "link": "https://baeldung.com/java-21-sequenced-collections",
        "document": "Java 21 is expected to be released on September 2023, being the next long-term support release after Java 17. Among the new features, we can identify an update of Java’s collections framework called Sequenced Collections.\n\nThe Sequenced Collections proposal stands out as a game-changing enhancement that promises to redefine how developers interact with collections. This feature injects new interfaces into the existing hierarchy, offering a seamless mechanism to access the first and last elements of a collection using built-in default methods. Moreover, it provides support to obtain a reversed view of the collection.\n\nIn this article, we will explore this new enhancement, its potential risks, and the advantages it brings.\n\nThe absence of a universal supertype for collections with a defined encounter order has been a repeated source of problems and complaints. Additionally, the lack of uniform methods for accessing first and last elements and iterating in reverse order has been a persistent limitation of Java’s collections framework.\n\nWe can take as an example List and Deque: both define an encounter order, but their common supertype, Collection, does not. Similarly, Set does not define an encounter order, but some subtypes, such as SortedSet and LinkedHashSet, do. Support for encounter order is thus spread across the type hierarchy, and operations related to encounter order are either inconsistent or missing.\n\nIn order to demonstrate the inconsistency, let’s make a comparison of accessing the first and last elements of different collection types:\n\nThe same thing happens when trying to get a reversed view of a collection. While iterating the elements of a collection from the first to the last element follows a clear and consistent pattern, doing so in the opposite direction presents challenges.\n\nTo illustrate, when dealing with a NavigableSet, we can use the descendingSet() method. For a Deque, the descendingIterator() method proves useful. Similarly, when dealing with a List, the listIterator() method works well. However, this is not the case for LinkedHashSet, as it doesn’t provide any support for reverse iteration.\n\nAll these differences led to fragmented codebases and complexity, making it challenging to express certain useful concepts in APIs.\n\nThis new feature introduces three new interfaces for sequenced collections, sequenced sets, and sequenced maps, which are added to the existing hierarchy of collections:\n\nThis image is part of the official documentation for JEP 431: Sequenced Collections (source).\n\nA sequenced collection is a Collection whose elements have a defined encounter order. The new SequencedCollection interface provides methods to add, retrieve, or remove elements at both ends of the collection, along with a method to get a reverse-ordered view of the collection.\n\nAll methods, except reversed(), are default methods, provide a default implementation, and are promoted from Deque. The reversed() method provides a reversed-order view of the original collection. Also, any modifications to the original collection are visible in the reversed view.\n\nThe add*() and remove*() methods are optional and throw an UnsupportedOperationException in their default implementation, primarily to support the case of unmodifiable collections and collections with an already defined sorting order. The get*() and remove*() methods throw NoSuchElementException if the collection is empty.\n\nA sequenced set can be defined as a specialized Set which functions as a SequencedCollection, ensuring the absence of duplicate elements. The SequencedSet interface extends SequencedCollection and overrides its reversed() method. The only difference is that the return type of SequencedSet.reversed() is SequencedSet.\n\nA sequenced map is a Map whose entries have a defined encounter order. The SequencedMap does not extend SequencedCollection and provides its own methods to manipulate elements at either end of the collection.\n\nSimilar to SequencedCollection, put*() methods throw UnsupportedOperationException for unmodifiable maps or maps with an already defined sorting order. Also, calling one of the methods promoted from NavigableMap on an empty map leads to throwing a NoSuchElementException.\n\nThe introduction of the new interfaces is supposed not to affect code that simply uses collections implementations. However, there are several kinds of conflicts that may appear if custom collection types would be defined in our codebases:\n• method naming: new methods introduced might clash with methods on existing classes. For example, if we have a custom implementation of the List interface that already defines a getFirst() method but with a different return type than getFirst() defined in SequencedCollection, it will create a source incompatibility when upgrading to Java 21.\n• covariant overrides: both List and Deque provide covariant overrides of the reversed() method, one returning List and the other one returning Deque. Therefore, any custom collection that implements both interfaces will lead to a compile-time error when upgrading to Java 21 because the compiler can’t choose one over the other.\n\nThe report JDK-8266572 contains a full analysis of the incompatibility risk.\n\nIn conclusion, Sequenced Collections marks a significant leap forward for the Java Collections. By addressing the long-standing need for a unified way to handle collections with a defined encounter order, Java empowers developers to work more efficiently and intuitively. The new interfaces establish a clearer structure and consistent behavior, resulting in more robust and readable code."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/22/core/creating-sequenced-collections-sets-and-maps.html",
        "document": "Three interfaces introduced in JDK 21 represent collections with a defined encounter order. Each collection has a well-defined first element, second element, and so forth, up to the last element. They provide uniform APIs for accessing their first and last elements, and processing their elements in forward and reverse order. Prior to JDK 21, the Java Collections Framework lacked a collection type that represented a sequence of elements with a defined encounter order. For example, List and Deque defined an encounter order but their common supertype, Collection, did not. Similarly, Set and subtypes such as HashSet do not define an encounter order, while subtypes such as SortedSet and LinkedHashSet do. Given the lack of a collection type with a defined encounter order, there is no uniform set of operations that respect encounter order. While there are operations that respect encounter order, they're not uniform. An example of where a common order-significant operation is missing in the Collections Framework is to get the first element of a Deque and of a List. To get the first element of a Deque, you use the method. However, to get the first element of a List, you use . Support for encounter order was spread across the type hierarchy, making it difficult to express certain useful concepts in APIs. Neither Collection nor List could describe a parameter or return value that had an encounter order. Collection was too general, relegating such constraints to the specification, and possibly leading to hard-to-debug errors. If an API wanted to receive a collection with a defined encounter order, then using was too specific, because it excluded and . A related problem was that view collections were often forced to downgrade to weaker semantics. For example, wrapping a LinkedHashSet with yields a Set that discards the information about encounter order. Without interfaces to define them, operations related to encounter order were either inconsistent or missing. Many implementations support getting the first or last element, but each collection defines its own approach, and some are not obvious or are missing entirely. Beginning with JDK 21, JEP 431 introduces three Java Collections Framework interfaces for creating sequenced collections, sequenced sets, and sequenced maps: These three interfaces provide the Java Collections Framework with a collection type that represents a sequence of elements with a defined encounter order and with a uniform set of operations applied across the collections. The interfaces fit into the collections type hierarchy as shown in the following diagram. , , and interfaces into the Java Collections Framework hierarchy of classes and interfaces:\n• has as its immediate superinterface.\n• has as its immediate superinterface.\n• has as its immediate superinterface.\n• has as its immediate superinterface.\n• Covariant overrides for the method are defined in the appropriate places. For example, is overridden to return a value of type rather than a value of type .\n• Methods added to the utility class create unmodifiable wrappers for three new types: The diagram shows the following adjustments that integrated the, andinterfaces into the Java Collections Framework hierarchy of classes and interfaces: See JEP 431 for background information about the interfaces for sequenced collections, sequenced sets, and sequenced maps.\n\nA SequencedCollection is a collection type added in JDK 21 that represents a sequence of elements with a defined encounter order. A SequencedCollection has first and last elements with the elements between them having successors and predecessors. A SequencedCollection supports common operations at either end, and it supports processing the elements from first to last and from last to first (such as, forward and reverse). The method provides a reverse-ordered view of the original collection. Any modifications to the original collection are visible in the view. The encounter order of elements in the returned view is the inverse of the encounter order of elements in this collection. The reverse ordering affects all order-sensitive operations, including those on the view collections of the returned view. Changes to the underlying collection might or might not be visible in the reversed view, depending upon the implementation. If permitted, modifications to the view \"write through\" to the original collection. The reverse-ordered view enables all the different sequenced types to process elements in both directions, using all the usual iteration mechanisms: For example, obtaining a reverse-ordered stream from a was previously quite difficult; now it is simply: The method is essentially a renamed , promoted to . are promoted from . They support adding, getting, and removing elements at both ends:\n• The and methods are optional, primarily to support the case of unmodifiable collections. The and methods throw a if the collection is empty. There are no definitions of and in because its subinterfaces have conflicting definitions. The following methods ofare promoted from. They support adding, getting, and removing elements at both ends:\n\nA SequencedSet is both a SequencedCollection and a Set. A SequencedSet can be thought of either as a Set that also has a well-defined encounter order, or as a SequencedCollection that also has unique elements. This interface has the same requirements on the and methods as defined by and . A Set and a SequencedSet compare if and only if they have equal elements, irrespective of ordering. defines the method, which provides a reverse-ordered view of this set. The only difference from the method is that the return type of is . , the methods of the perform the following:\n• - Adds an element as the first element of the collection.\n• - Adds an element as the last element of the collection. In, themethods of theperform the following: The methods of the SequencedCollection also have the following special-case behaviors for LinkedHashSet and SortedSet.\n• The and methods have special-case semantics for collections such as . repositions the entry if it is already present in the set. If the element is already present in the set then it is moved to the appropriate position. This remedies a long-standing deficiency in , namely the inability to reposition elements.\n• Collections such as , which position elements by relative comparison, cannot support explicit-positioning operations such as the and methods declared in the superinterface. These methods throw an .\n\nA SequencedMap provides methods to add mappings, to retrieve mappings, and to remove mappings at either end of the map's encounter order. This interface also defines the , which provides a reverse-ordered view of this map. A SequencedMap has a well-defined encounter order that supports operations at both ends and is reversible. A map's reverse-ordered view is generally not serializable, even if the original map is serializable. The encounter order of a SequencedMap is similar to that of the elements of a , but the ordering applies to mappings instead of individual elements: The sequencedKeySet(), sequencedValues(), and sequencedEntrySet()methods are exactly analogous to the keySet(), values(), and entrySet() methods of Map interface. All of these methods return views of the underlying collection; where modifications to the view are visible in the underlying collection and vice versa. The encounter order of these views exactly corresponds to the encounter order of the underlying map. interface methods and the methods of is that the methods have a sequenced return type:\n• In , the implemention returns a view of the map's and behaves as follows:\n• method returns the view of the reversed view of the map.\n• Its other methods call the corresponding methods of the view of the map.\n• In , the implemention returns a view of the map's collection and behaves as follows:\n• method returns the view of the reversed view of the map.\n• and methods are inherited from .\n• Its other methods call the corresponding methods of the view of the map.\n• In , the implemention returns a view of the map's and behaves as follows:\n• method returns the view of the reversed view of the map.\n• Its other methods call the corresponding methods of the view of the map. The difference between theinterface methods and the methods ofis that themethods have a sequenced return type: methods have special-case semantics, similar to the corresponding methods of :\n• For maps such as , they have the additional effect of repositioning the entry if it is already present in the map.\n• For maps such as , these methods throw . Themethods have special-case semantics, similar to the correspondingmethods of are promoted from . They support getting and removing entries at both ends: The following methods ofare promoted from. They support getting and removing entries at both ends: The methods , , , and return instances that represent snapshots of mappings as of the time of the call. They do not support mutation of the underlying map via the optional method.\n\nSeveral scenarios are provided of using the sequenced interfaces in the Collections Framework.\n• Demonstrating SequencedMap Does Not Support Mutation of the Underlying Map The following example demonstrates how the method of the sequenced interfaces produces a reverse-ordered view of a collection, how modifications to a reversed view affect the original collection, and how modifications to the original collection are visible in the reversed view. The reversed view is \"live\" and not a snapshot of a collection. This characteristic is illustrated in the following examples by using an and its reversed view. Unessential output is not included in the following example code. Unessentialoutput is not included in the following example code. Start a session and use the class to create a list of objects. jshell> var list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\")) list ==> [a, b, c, d, e] Next, use the method to produce a reverse-ordered view of the collection. When you modify the reversed view, it affects the original collection. Add as an entry to the reverse-ordered view and then verify that it is added to the original collection. When you modify the original collection, your modifications are visible in the reversed view. Set the element at index 2 to , verify it is added to the collection, and then produce a reverse-ordered view of the modified collection. In addition to using , a view can also be composed of other views such as or and . The and views are functionally equivalent and are illustrated by using the class in the following example code. Start a session and use the class to create a of objects. Next, use the method to produce a reverse-ordered view of the view of the original collection. Demonstrating SequencedMap Does Not Support Mutation of the Underlying Map This demonstration illustrates the final statement in the section that , , , and methods do not support mutation of the underlying map through use of the optional method. Attempting to change an entry in the underlying map by using with these methods will throw an . This is in contrast to changing a map entry obtained by iterating the . If you call to return a map entry and then call on the entry, it will modify the original map. Open a session and use the map produced in Demonstrating Composition of LinkedHashMap Views. Call to return the first map entry. Use to change the value of the map entry to . The entry was obtained by iterating the so it can be modified in the original . Verify that the value in changed to . The ability to call on the entry returned by the iterator is not a new behavior introduced in JDK 21. The ability to callon the entry returned by the iterator is not a new behavior introduced in JDK 21. Use to try and change the map entry to . Because the map entry was not obtained by iterating with , it throws an . jshell> entry = map.firstEntry() entry ==> a=77 jshell> entry.setValue(999) | Exception java.lang.UnsupportedOperationException: not supported | at NullableKeyValueHolder.setValue (NullableKeyValueHolder.java:126) | at (#22:1)"
    },
    {
        "link": "https://openjdk.org/jeps/431",
        "document": ""
    },
    {
        "link": "http://web.mit.edu/javadev/packages/jgl_2_0/doc/user/Sequences.html",
        "document": "A sequence is a linear container that allows index-based random access and automatically expands to accommodate new elements. JGL includes four different kinds of sequences:\n• An stores its elements internally in a single contiguous structure for very high performance random access. This storage approach allows elements to be added very efficiently to the end of the container, but much slower in other places. An is similar to a JDK except that it is easier to apply JGL algorithms to an and it is possible to construct an from an existing native Java array.\n• A is a double-ended queue that has almost the same interface as an but stores its elements internally in an array of arrays. This implementation difference results in random access that is slower than that of an but allows fast insertion at its beginning or end.\n• A stores its elements internally as a doubly linked list of nodes in which every node has a reference to a single element and a reference to its next and previous nodes. This approach yields very fast insertion at any point in the data structure but relatively slow random access as the must be traversed from its beginning to the target node.\n• An stores its elements internally as a singly linked list of nodes in which every node has a reference to a single element and a reference to the next node. This approach uses less storage space than a but only allows high performance insertion at its beginning or its end.\n\nEach of these classes implements the interface, which in turn extends the interface. Here is a diagram that illustrates these relationships: \n\n \n\n All classes that implement the interface support the following methods:\n• - insert an item at the beginning/end\n• - remove and return the item at the beginning/end\n• - return/replace the item at a specified index\n• - replace one value with another\n• - return the index of a particular element\n• - return if a particular element is present\n\n, , and include additional functionality that is unique to their class. The rest of this chapter describes these classes and methods in detail.\n\n \n\n\n\nAll sequences allow you to read/write an element at a particular index using and respectively. The first element of a sequence has index 0. If an attempt is made to access an element at an illegal index, an is thrown. and are synonymous. The following example demonstrates all of the functions for pushing, popping, and index-based access using an . \n\n\n\nAll sequences include a wide range of useful methods for counting, finding, removing, and replacing elements. Many of these methods have two variations - one for performing the operation on the entire container, and another for performing the operation on a sub-range. The following example shows some of these variations in action using a . \n\n\n\nAll sequences support a comprehensive range of insert methods that allow you to insert one or more elements at a specific index. The following example illustrates these features using a . \n\n\n\nAn has a greater control of its underlying storage capacity than any other sequence. An internal storage is a native Java array of objects whose default size is 10. When an element is added that causes the internal storage to overflow, an automatically allocates another native Java array with additional capacity and then copies the contents of the old array into the new array using the fast method. The old storage is then discarded. This process is repeated when necessary. Note that the current implementation only ever expands the internal storage capacity of an , and never shrinks it.\n\n\n\nAlthough this process is generally very efficient, you may manually force an to pre-allocate a specified amount of internal storage by using This function is useful if you know in advance the eventual size of a large . You can find out the current size of an internal storage by using the method. To set an capacity to the minimum amount of space required to hold its elements, use . The next example illustrates the automatic capacity increase and the effect that and have on the amount of internal storage.\n\n\n\nJGL makes it very easy and efficient to construct an from a native Java array of objects. If you pass the constructor an existing array, the will adopt its storage without performing a copy. Operations like and will operate on the original Java array. However, if you add an element using or the original array is copied to an new enlarged storage structure and is then no longer used by the . You may efficiently copy an elements into a native Java array by using The following example illustrates these features.\n\n\n\nThe and classes support splicing operations that allow you to cut a single node or range of nodes from one list and paste them into another list. The following example uses an to show splicing in action.\n\n\n\nThe class supports a couple of miscellaneous operations. collapses neighboring nodes that contain the same element into a single node, and efficiently reverses the elements of a list. The following example illustrates both of these methods."
    },
    {
        "link": "https://docs.informatica.com/data-integration/common-content-for-data-integration/10-5-8/user-guide/custom-script-components/developing-a-custom-component/java-interface-example.html",
        "document": "method of the object returns a vector containing the property values. Input parameter. An object containing the properties that the Script passes to the component. Themethod of the object returns a vector containing the property values.\n\nInput parameter. The full path of the file that the component operates on.\n\nOptional output parameter. The path of a temporary directory where the component writes files. At the end of processing, the Script deletes the entire directory content.\n\nInput parameter. An object providing the report method, which the component can use to write events to the event log."
    },
    {
        "link": "https://medium.com/@balloon.helps/recursion-with-java-171aca9c73a5",
        "document": "Recursion is a valuable concept for simplifying complex problems and maintainable code. The developer must understand the recursion concept clearly to prevent stack overflow or unexpected issues when implemented in an application.\n\nStack Overflow: Each recursive call consumes memory on the call stack, leading to a stack overflow error.\n\nPerformance Overhead: Recursive function calls incur overhead due to the creation of additional stack frames.\n\nDebugging Complexity: Recursive code can sometimes be harder to debug and reason about than iterative code. Understanding the execution flow and tracking recursive calls can be challenging, especially in deeply nested or complex recursion.\n\nClarity and Conciseness: making the code easier to understand and maintain.\n\nFunctional Programming Paradigm: Recursion is a fundamental concept in functional programming.\n\nReusability: Recursive functions often follow the divide-and-conquer approach and reduce redundancy in code.\n\nThis Example will demonstrate the implementation of recursion in a real-life…"
    },
    {
        "link": "https://stackoverflow.com/questions/11853459/java-recursion-and-performance",
        "document": "Does the recursion heavily impose on processor and ram? I mean, that one of my threads has a method, that is very likely to call itself. Let's say that It can self-call about one time per second. My app should run for at least 24 hours without stopping, so it gives (60*60*24) 86400 self-called methods.\n\nHow does it influence on the second (main) thread?\n\nSorry for my bad english, and for no code, but im not writing from home."
    },
    {
        "link": "https://codingzap.com/recursion-in-java",
        "document": "Recursion In Java is a key concept that is used in many applications. Do you want to learn how to use recursion in Java effectively? Well then, you have already reached your destination!\n\n This article will cover every detail about recursion so that you can learn it easily. As we progress through the article, we will see various code examples you can implement to strengthen your learning. So, ready to begin? Let’s dive in!\n• None Recursion in Java occurs when a function or method calls itself over and over until a condition is met.\n• None It has three main components – base case, recursive case, and recursive step.\n• None Recursion allows us to simplify complex problems and write algorithms efficiently using stack memory.\n\nIn programming, recursion is the process where a function or a method is invoked by itself. The function keeps on calling itself until a certain condition is met. We can use recursion in various cases, for example, to find the factorial of a number, perform sorting of an array, etc. Now, let us consider that we must find the factorial of 3. We can achieve this by running a loop, or by calling a recursive function. In the latter case, we will call the function until the last number is 1. Don’t worry if you don’t understand it right now. We will implement this as we go. First, let us talk some more about the basic concepts of recursion in Java. We will see what are the components of a recursive function below which will help us write our code effectively. If you’re new to Java programming, understanding recursion is just one step—it’s also important to learn about loops, exception handling, and data structures.\n\nBefore jumping into the code examples for implementing recursion, let me tell you some of the real-world applications of recursion or recursive methods. An insight into these will help you understand the concept better. You must know about data structures in programming. One of the recursive data structures is a tree and the concept is applied to traverse the tree. It allows us to traverse hierarchical data structures efficiently. Furthermore, tree traversal is used in file systems, XML/JSON parsing, and even in abstract syntax trees that are used in compilers for parsing code. Recursion is also used in 2 of the most used searching algorithms. These are DFS – Depth First Search and BFS – Breadth First Search for backtracking. It can be used in solving maze paths or puzzle games like Sudoku or N-Queens. Recursion is widely used in AI and ML algorithms. These are called recursive algorithms. The decision tree and random forest algorithms use recursion to classify data. Similarly, AI games like chess use recursion for backtracking. Moreover, neural networks utilize recursion for gradient calculations.\n\nWhile performing recursion in Java, you should be careful about a few things. These are vital to understand and look out for as they may affect the performance of your application. Let us see what can we do for performance optimization with recursion in the below points. Recursion consumes stack memory and often at times can lead to stack overflow errors. For example, if in the above program if we try to find the factorial of 20000 it will consume a lot of memory for computation and may also lead to unexpected termination. To solve this, you can use Tail Recursion Optimization or use loops for iteration rather than using recursive methods. Recursive algorithms for complex processes sometimes also lead to high time complexity, for example, finding a Fibonacci sequence leads to exponential time complexity. It also gives us redundant calculations. You should keep the time complexity in mind and try to use the concept of memorization so that the previously calculated values are stored separately. Since we are calling one function again and again, it will require a lot of memory to store variables, results, and other key values in your algorithms. Thus, it may also lead to memory consumption. Like Stack Overflow Risks, you can also limit the memory consumption by using iteration, rather than recursion for larger tasks. This kind of situation occurs when the base case or terminating condition is not well-defined. In such cases, the function keeps on calling itself and does not know when to stop. Thus, it goes into an infinite loop which can lead to system crash and depletion of memory. If you’re concerned about the efficiency of your recursive algorithms, you might also want to explore Assignment Operators In Python to see how different programming techniques affect performance.\n\nI hope that by now you have all you need to understand and write your recursion algorithms. You can start with writing simpler codes like factorial, prime numbers, and Fibonacci sequences with recursion and later move on the solve sorting algorithms using recursive data structures. Remember to keep in mind all the performance considerations and best practices that we discussed above to avoid any unexpected outputs. You can also solve recursion problems on an online coding platform to strengthen your Java coding skills. If you’re also working with C++, you might want to check out our guide on Recursion In C++ to see how recursion works in a different programming language.\n• None To perform recursion in Java effectively, we should keep in mind the complexity of our code as well as the requirements of the algorithms used in it.\n• None It is advisable to maintain a balance between recursion and iteration wherever possible so as to use memory space efficiently.\n• None One of the important steps to keep in mind while using recursion is to write a well-defined terminating case to avoid infinite recursion."
    },
    {
        "link": "https://medium.com/@YodgorbekKomilo/recursion-in-java-a-comprehensive-guide-65cba5434044",
        "document": "Recursion is a powerful programming concept in which a method calls itself to solve a problem. This technique allows developers to tackle complex problems by breaking them into smaller, more manageable sub-problems. In Java, recursion can be particularly useful for tasks involving repetitive or hierarchical data, such as tree traversal, factorial computation, and solving puzzles like the Tower of Hanoi.\n\nThis post will cover the fundamentals of recursion, its structure, applications, advantages, disadvantages, and practical examples in Java.\n\nRecursion occurs when a method calls itself directly or indirectly to solve a problem. A recursive method must have:\n• Base Case: A condition that stops the recursion to prevent infinite loops.\n• Recursive Case: The part of the method where the problem is divided into smaller instances of itself.\n\nHere is the general structure of a recursive method:\n\nFactorial of a number n is the product of all positive integers less than or equal to n\n\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones.\n• Problem Solving: Solving puzzles like the Tower of Hanoi.\n• Simplifies Code: Reduces code complexity for problems that are naturally recursive.\n• Natural Fit: Suitable for problems like tree traversal and divide-and-conquer algorithms.\n• Performance Overhead: Recursive calls consume more stack memory, which can lead to stack overflow for large inputs.\n• Inefficiency: Without optimization (e.g., memoization), recursion can lead to redundant computations.\n\nThe Tower of Hanoi problem involves moving a stack of disks from one peg to another, following specific rules.\n\nTail recursion is a specific type of recursion in which the recursive call is the last operation in the method. It allows the compiler to optimize to reuse the current stack frame.\n\nBest Practices for Using Recursion\n• Identify Base Case Clearly: Ensure there is a termination condition to avoid infinite recursion.\n• Tail Recursion: Use tail recursion where possible for compiler optimizations.\n• Limit Depth: Avoid deep recursion for problems that can grow exponentially.\n\nRecursion is a versatile tool in Java, enabling developers to solve complex problems elegantly. However, it requires careful implementation to avoid pitfalls like stack overflow and inefficiency. By understanding its principles and mastering its applications, you can leverage recursion to write clean, efficient, and effective Java programs"
    },
    {
        "link": "https://geeksforgeeks.org/recursion-in-java",
        "document": "In Java, Recursion is a process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily. A few Java recursion examples are Towers of Hanoi (TOH), Inorder/Preorder/Postorder Tree Traversals, DFS of Graph, etc.\n\nIn the recursive program, the solution to the base case is provided and the solution to the bigger problem is expressed in terms of smaller problems.\n\nIn the above example, the base case for n < = 1 is defined and the larger value of a number can be solved by converting it to a smaller one till the base case is reached.\n\nThe idea is to represent a problem in terms of one or more smaller sub-problems and add base conditions that stop the recursion. For example, we compute factorial n if we know the factorial of (n-1). The base case for factorial would be n = 0. We return 1 when n = 0.\n\nBelow is the implementation of the factorial:\n\nBelow is the implementation of the Fibonacci Series:\n\nIf the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this.\n\nIf fact(10) is called, it will call fact(9), fact(8), fact(7) and so on but the number will never reach 100. So, the base case is not reached. If the memory is exhausted by these functions on the stack, it will cause a stack overflow error.\n\nHow is memory allocated to different function calls in recursion?\n\nWhen any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for the called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.\n\nLet us take the example of recursion by taking a simple function.\n\nExplanation of the above Program\n\nWhen printFun(3) is called from main(), memory is allocated to printFun(3), a local variable test is initialized to 3, and statements 1 to 4 are pushed on the stack as shown below diagram. It first prints ‘3’.\n\nIn statement 2, printFun(2) is called and memory is allocated to printFun(2), a local variable test is initialized to 2, and statements 1 to 4 are pushed in the stack. Similarly, printFun(2) calls printFun(1) and printFun(1) calls printFun(0). printFun(0) goes to if statement and it return to printFun(1).\n\nThe remaining statements of printFun(1) are executed and it returns to printFun(2) and so on. In the output, values from 3 to 1 are printed and then 1 to 3 are printed.\n\nThe memory stack is shown in the below diagram:\n\nThe advantages of recursive programs are as follows:\n• None Recursion provides a clean and simple way to write code.\n• None Some problems are inherently recursive like tree traversals, , etc. For such problems, it is preferred to write recursive code.\n\nThe disadvantages of recursive programs is as follows:\n• None The recursive program has greater space requirements than the iterative program as all functions will remain in the stack until the base case is reached.\n• None It also has greater time requirements because of function calls and returns overhead.\n\nQ1. What is recursion in Java?\n\nWhat is the difference between direct and indirect recursion?\n\nWhat is the difference between tailed and non-tailed recursion?"
    }
]