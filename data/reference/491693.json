[
    {
        "link": "https://medium.com/@pallavidipke07/method-swizzling-in-swift-5c9d9ab008e4",
        "document": "If you know about method dispatch then method swizzling is not new for you. Even after being big fan of OOP, I didn’t know much about Method Swizzling before. I did digging into for few days and came up with clear picture of Method Swizzling. So let’s explore this topic today without wasting time.\n\nWhat are use cases of method swizzling?\n\nLet’s say you got a task to to keep track of all the screens user is visiting. Its very simple right? Simply create a subclass of UIViewController that will hold a function which will perform the tracking logic and we will call that function in viewWillAppear(_ animated: Bool) then only thing is left is, use that UIViewController class as a base class for all the controllers. But this is not proper solution as, It has following issues.\n• You have one UITableViewController class and that also need to be logged but when I tried to use our base class as a super class of UITableViewController it showed following error. The reason behind this error is UITableViewController is child of UIViewController. Swift doesn’t allow to perform multiple inheritance.\n\n2. You might be using other frameworks and libraries which may have UIViewControllers, also UITableViewControllers which need to be logged. Now the question here is how you will inherit those UIViewControllers and UITableViewControllers?\n\n3. Same point 2 in reverse order. If you are a framework developer and you have to track the screens. You can not ask your users to sub class all the screens with your controller so that tracking of screens will be performed.\n• Here, You may write to the library author to use your class as base class so that you can fulfil your requirement with this approach.\n• Else, You would have studied about method swizzling and completed the task.\n\nIf you ask me I would have given the task to other teammate and relaxed 😁😁. Joke a part, I would have gone with Method swizzling.\n\nNow first question pop up in my mind that what exactly happens at the memory level when method swizzling (Message Dispatch) happens. Here what happens -\n• In case of message dispatch compiler does not have any direct dispatch mechanism nor witness table to look into to execute the function. Actually compiler crawl to the hierarchy of classes to determine which method to invoke. This is comparatively very slow compared to direct and table dispatch but still there are some use cases where is no option out there.\n\nHow to achieve it?\n\nFollowing code will creates an extension of UIViewController. Let’s understand the code now.\n• swizzle() function holds a logic for swizzling. Here it will get the references of the methods which we want to exchange at runtime.\n• create a function which we want to execute at runtime when the message dispatches for particular method. In example. We have created _tracked_viewWillAppear(_ animated: Bool). Here we can write the logic of tracking the screens which is our problem statement.\n• class_getInstanceMethod(_ cls: AnyClass?, _ name: Selector) -> Method? This objective C function which will return the pointers for the function. It takes two parameters, one is type of AnyClass, We will set self here and method selector is second parameter which will be #selector.\n• Here we have to get pointers of two methods and store it in a local variable. In example we have to get pointers of _tracked_viewWillAppear(_:) and viewDidLoad.\n• Then the last step for this function is exchange the implementation by using method_exchangeImplementations(_ m1: Method, _ m2: Method) function.\n• To execute this throughout the app just call the method from AppDelegate. Tired 😟?? Relax now, you are all done with the coding for the given problem statement.\n• You might wonder we are calling _tracked_viewWillAppear(animated) inside _tracked_viewWillAppear(_:). This may call the same function infinite times and it will never come out of loop. But it’s not like that. In fact it will call the viewDidLoad() with _tracked_viewWillAppear(_:) call.\n\nHere is output of this code:-\n\nThings to be careful for\n• Method swizzling is very dynamic in nature as takes decision at runtime, hence we have to be very careful while using it as it has ability to mess up the app if you are not using it properly.\n• Trouble shooting can be very difficult if something goes wrong.\n• The order of swizzle matters, so be careful when swizzling multiples classes. For example if you swizzle UIView and UIButton you must be careful because UIButton inherits from UIView through UIControls.\n• You have to keep track of iOS releases and have to check that your code is running properly with the updates. Even Firebase does swizzling for few methods but it allows us to disable the it.\n• Uses subclassing wherever possible until its necessary to go with swizzling.\n\nThis is all for now on this topic, Hope it improved your understanding about Method swizzling.\n\nArticles that inspired me to learn about swizzling."
    },
    {
        "link": "https://stackoverflow.com/questions/38778274/method-swizzling-for-property-in-swift",
        "document": "While it is possible to replace method in obj-c, I'm wondering how to do it in swift?\n\nFor example I want to replace :\n\n...but after execution contains . So, how to pass setter method of property to ?"
    },
    {
        "link": "https://abhimuralidharan.medium.com/method-swizzling-in-ios-swift-1f38edaf984f",
        "document": "Today, I was integrating FCM in my iOS app. I saw the same word method swizzling again in the firebase documentation. It said:\n\nSo, its an important thing to know. Let’s understand what it is.\n\nMethod swizzling is the process of changing the implementation of an existing selector at runtime. Simply speaking, we can change the functionality of a method at runtime.\n\nFor example: If you want to track the keys and values added to the and add a prefix string before…"
    },
    {
        "link": "https://stackoverflow.com/questions/24019683/swift-function-swizzling-runtime",
        "document": "A safe, easy, powerful and efficient hook framework for iOS (Support Swift and Objective-C). https://github.com/623637646/SwiftHook\n\nFor example, this is your class\n\nThe key words of methods and are necessary\n\nThe class doesn't have to inherit from NSObject. If the class is written by Objective-C, Just hook it without any more effort\n• Perform the hook closure before executing specified instance's method.\n• Perform the hook closure after executing specified instance's method. And get the parameters.\n\nThe key word is necessary\n\nFor hook at and . The closure's args have to be empty or the same as method. The return type has to be\n• Totally override the mehtod for specified instance. You can call original with the same parameters or different parameters. Don't even call the original method if you want.\n\nFor hook with . The closure's first argument has to be a closure which has the same types with the method. The rest args and return type have to be the same as the method.\n• Perform the hook closure before executing the method of all instances of the class.\n• Perform the hook closure before executing the class method."
    },
    {
        "link": "https://mehmetbaykar.com/posts/understanding-method-swizzling-in-swift",
        "document": "In this post, we’ll explore what method swizzling is, why it’s useful, and how to implement it in Swift using an example with .\n\nMethod swizzling is a feature of the Objective-C runtime that lets you modify or extend the behavior of existing classes at runtime without subclassing or changing their source code. It’s commonly used in iOS to tweak system class behaviors, similar to overriding methods but done dynamically.\n• Customization: Modify system behaviors to fit your app’s needs.\n\nNote: Use method swizzling carefully to avoid unpredictable side effects, as it directly modifies system classes.\n\nHere’s a simple example to use method swizzling for logging every network request made by .\n\nActivate swizzling before any data tasks are created. This can be done in .\n\nHow Does It Work?\n• Method Exchange: Swaps the original method with the custom one.\n• Calling Original Method: Calls , which now points to the original implementation.\n• Non-Invasive: No need to modify existing code.\n• Centralized Logging: Reuse and manage logging logic in one place.\n• Easy to Enable/Disable: Control logging by simply deciding when to activate swizzling.\n• Thread Safety: Ensure swizzling is performed in a thread-safe way.\n• One-Time Swizzling: Swizzle methods only once to avoid infinite loops.\n• System Compatibility: System updates can impact swizzled methods, so be cautious.\n\nMethod swizzling is a powerful way to enhance and customize the behavior of system classes in Swift. Use it responsibly to avoid unintended consequences, and leverage its potential to address specific challenges effectively.\n\nShare your thoughts or experiences in the comments below!"
    },
    {
        "link": "https://developer.apple.com/documentation/webkit/wkwebview/isinspectable",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "https://github.com/pichillilorenzo/flutter_inappwebview/issues/1629",
        "document": "\n• I have read the Getting Started section\n• I have already searched for the same problem\n\nI already check this link: https://inappwebview.dev/docs/debugging-webviews#inspect-ios-and-macos-webviews\n\n And WKWebView.isInspectable option have been added since iOS 16.4.\n\nI just add some code in InAppWebView/InAppWebView.swift and Inspecting Application works.\n\nplease add like this :)"
    },
    {
        "link": "https://webkit.org/blog/13936/enabling-the-inspection-of-web-content-in-apps",
        "document": "Web Inspector is a powerful tool that allows you to debug the layout of web pages, step through JavaScript, read messages logged to the console, and more. In Safari on macOS, you can use Web Inspector to inspect web pages, extensions, and service workers. iOS and iPadOS allow inspection of the same content as macOS, with the addition of Home Screen web apps.\n\nWeb content and JavaScript is used for various purposes in apps, from providing UI from a webpage to enabling apps to be scriptable. Previously, Web Inspector supported inspecting developer-provisioned apps built directly from Xcode for local development, meaning developers could debug this content so long as the app is installed for development. However, released versions of apps had no way to inspect dynamic web content or scripts, leaving developers and users to have to resort to more complicated workflows to get information that would otherwise be made available by Web Inspector. Now, this same functionality is available through an API on and .\n\nAcross all platforms supporting or , a new property is available called ( in Objective-C). It defaults to , and you can set it to to opt-in to content being inspectable. This decision is made for each individual and to prevent unintentionally making it enabled for a view or context you don’t intend to be inspectable. So, for example, to make a , you would:\n\nFor , matching API is available, with the addition of C API for developers using :\n\nThe property can be changed at any point during the lifetime of your or . Disabling inspection while Web Inspector actively inspects the content will automatically close Web Inspector, and no further information about the content will be available.\n\nOnce you’ve enabled inspection for your app, you can inspect it from Safari’s Develop menu in the submenu for either your current computer or an attached device. For iOS and iPadOS, you must also have enabled Web Inspector in the Settings app under Safari > Advanced > Web Inspector. You do not need to enable Web Inspector for simulators; it is always enabled. Learn more about enabling Web Inspector…\n\nWhen should I consider making content inspectable?\n\nA common situation in which you may want the content of to be inspectable is in an in-app web browser. The browser shows ordinary web content that would be inspectable when loaded in Safari. It can be beneficial both for the app developer, as well as web authors, to be able to inspect content in these views, as the size of the view may not match that of Safari’s, or the app developer may be injecting script into the view to provide integration with their app.\n\nWeb content is often dynamic, delivered by a server—not in the app—and easily changed over time. Unfortunately, not all issues can or will get debugged by folks with access to a developer-provisioned copy of your app.\n\ncan also enable scripting in an app whereby the customer provides the scripts to augment the app. Without the ability for a release version of your app to adopt inspectability, your customers may have no way to debug the scripts they have written. It makes it harder for customers to use this functionality of your app.\n\nUnlike , which automatically gets a name based on the page currently loaded in the view, every with enabled will be listed as JSContext in Safari’s Develop menu. We recommend providing a unique, human-readable name for each inspectable to make it easier for you and your customers to determine what the represents. For example, if your app runs different pieces of JavaScript on behalf of the user, you should give each a name based on what runs inside the context.\n\nAPI is available to set the user-visible of a :\n\nWorking with older versions of macOS and iOS\n\nFor apps linked against an SDK before macOS 13.3 and iOS 16.4 s and s will continue to follow the previous behavior of always being inspectable when built for debugging from Xcode.\n\nApps that support older versions of macOS and iOS while linked against the most recent SDK will not get the previous behavior of all content being inspectable in debug builds to avoid confusion about what will and will not be inspectable by customers. Apps targeting older OS versions but linking against the new SDK can use this new API conditionally on OS versions that support it. To conditionally guard usage of the API:\n\nYou can learn more about guarding usage of new API on developer.apple.com.\n\nAs you explore this new API, please help us by providing feedback if you encounter problems. For issues using this new API, please file feedback from your Mac, iPhone, or iPad. Feedback Assistant will collect the information needed to help us understand what’s happening. For any issues you may experience with Web Inspector itself once inspecting your app’s content, please file a bug on bugs.webkit.org.\n\nAlso, we love hearing from you. You can find us on Mastodon at @patrickangle@hachyderm.io, @jensimmons@front-end.social, and @jondavis@mastodon.social."
    },
    {
        "link": "https://developer.apple.com/documentation/safari-developer-tools/enabling-inspecting-content-in-your-apps",
        "document": "Please turn on JavaScript in your browser and refresh the page to view its content."
    },
    {
        "link": "https://github.com/react-native-webview/react-native-webview/issues/2914",
        "document": "With iOS 16.4 comes a WebKit update which requires to enable the possibility to inspect the app for debugging WebView via Safari, by default it's false. So now debugging isn't working.\n\nPlease see details on the official WebKit resource\n• Run React Native iOS app with WebView and any web page\n\nThe web page should be available for inspection"
    },
    {
        "link": "https://medium.com/@pallavidipke07/method-swizzling-in-swift-5c9d9ab008e4",
        "document": "If you know about method dispatch then method swizzling is not new for you. Even after being big fan of OOP, I didn’t know much about Method Swizzling before. I did digging into for few days and came up with clear picture of Method Swizzling. So let’s explore this topic today without wasting time.\n\nWhat are use cases of method swizzling?\n\nLet’s say you got a task to to keep track of all the screens user is visiting. Its very simple right? Simply create a subclass of UIViewController that will hold a function which will perform the tracking logic and we will call that function in viewWillAppear(_ animated: Bool) then only thing is left is, use that UIViewController class as a base class for all the controllers. But this is not proper solution as, It has following issues.\n• You have one UITableViewController class and that also need to be logged but when I tried to use our base class as a super class of UITableViewController it showed following error. The reason behind this error is UITableViewController is child of UIViewController. Swift doesn’t allow to perform multiple inheritance.\n\n2. You might be using other frameworks and libraries which may have UIViewControllers, also UITableViewControllers which need to be logged. Now the question here is how you will inherit those UIViewControllers and UITableViewControllers?\n\n3. Same point 2 in reverse order. If you are a framework developer and you have to track the screens. You can not ask your users to sub class all the screens with your controller so that tracking of screens will be performed.\n• Here, You may write to the library author to use your class as base class so that you can fulfil your requirement with this approach.\n• Else, You would have studied about method swizzling and completed the task.\n\nIf you ask me I would have given the task to other teammate and relaxed 😁😁. Joke a part, I would have gone with Method swizzling.\n\nNow first question pop up in my mind that what exactly happens at the memory level when method swizzling (Message Dispatch) happens. Here what happens -\n• In case of message dispatch compiler does not have any direct dispatch mechanism nor witness table to look into to execute the function. Actually compiler crawl to the hierarchy of classes to determine which method to invoke. This is comparatively very slow compared to direct and table dispatch but still there are some use cases where is no option out there.\n\nHow to achieve it?\n\nFollowing code will creates an extension of UIViewController. Let’s understand the code now.\n• swizzle() function holds a logic for swizzling. Here it will get the references of the methods which we want to exchange at runtime.\n• create a function which we want to execute at runtime when the message dispatches for particular method. In example. We have created _tracked_viewWillAppear(_ animated: Bool). Here we can write the logic of tracking the screens which is our problem statement.\n• class_getInstanceMethod(_ cls: AnyClass?, _ name: Selector) -> Method? This objective C function which will return the pointers for the function. It takes two parameters, one is type of AnyClass, We will set self here and method selector is second parameter which will be #selector.\n• Here we have to get pointers of two methods and store it in a local variable. In example we have to get pointers of _tracked_viewWillAppear(_:) and viewDidLoad.\n• Then the last step for this function is exchange the implementation by using method_exchangeImplementations(_ m1: Method, _ m2: Method) function.\n• To execute this throughout the app just call the method from AppDelegate. Tired 😟?? Relax now, you are all done with the coding for the given problem statement.\n• You might wonder we are calling _tracked_viewWillAppear(animated) inside _tracked_viewWillAppear(_:). This may call the same function infinite times and it will never come out of loop. But it’s not like that. In fact it will call the viewDidLoad() with _tracked_viewWillAppear(_:) call.\n\nHere is output of this code:-\n\nThings to be careful for\n• Method swizzling is very dynamic in nature as takes decision at runtime, hence we have to be very careful while using it as it has ability to mess up the app if you are not using it properly.\n• Trouble shooting can be very difficult if something goes wrong.\n• The order of swizzle matters, so be careful when swizzling multiples classes. For example if you swizzle UIView and UIButton you must be careful because UIButton inherits from UIView through UIControls.\n• You have to keep track of iOS releases and have to check that your code is running properly with the updates. Even Firebase does swizzling for few methods but it allows us to disable the it.\n• Uses subclassing wherever possible until its necessary to go with swizzling.\n\nThis is all for now on this topic, Hope it improved your understanding about Method swizzling.\n\nArticles that inspired me to learn about swizzling."
    },
    {
        "link": "https://stackoverflow.com/questions/76971906/ensuring-safe-and-effective-implementation-of-method-swizzling",
        "document": "First, swizzling cannot be done in a safe manner. It is, by its nature, dangerous. It requires you to rely on internal implementation details of the modified class that are subject to change. I'm not saying that it should never be used (though in over 15 years of Cocoa development, I've never needed to write a swizzle for anything but debugging), but it must only be used with great care. You should only use it in proportion to how well you believe you know what Apple is doing internally and what they will possibly change in the future. If Apple changes something you didn't expect, the bugs can be extremely hard to understand.\n\nAnd woe to the developer who discovers some other developer decided to swizzle the same thing. Never implicitly swizzle in libraries. (I'm looking at you, Firebase.) Multiple swizzles technically work and there's nothing inherently wrong about them, but they magnify how confusing things can get when something goes wrong. If you feel you must swizzle in a library, have the caller opt-in by calling some \"setup\" method, and clearly document what swizzles you're applying and their behavior.\n\nThe primary concern with threading and swizzling is that you might swizzle a class or object that already is doing things, and swizzling is not thread safe. You should strongly avoid doing that. Swizzle objects as soon as they come into existence, or as early in the program as possible. Class swizzling should ideally be done in method to make sure it happens before the class is used. If that's not possible, then . If that's not possible, then .\n\nIf you find yourself needing synchronization beyond , you are probably doing too much, or in too complicated a way, and you should try to simplify your implementation (ideally removing the swizzle entirely) rather than devising elaborate synchronization. If you still require that, you're on your own to devise an approach that works for your situation.\n\nThe most famous use of swizzling is KVO, and it introduces a lot of threading headaches. For a taste of how hard it is to solve the KVO threading problems, see PMKVObserver. This would be the closest to an example of how to address your question as I know.\n\nIf you have something as dynamic as KVO, the best answer is generally to require the type to only be accessed on the main thread. If it's not one you control, that may be hard. That's part of why swizzling is a tricky tool."
    },
    {
        "link": "https://akhmedovgg.medium.com/using-method-swizzling-in-swift-a4d27f05d630",
        "document": "Let’s see what is it and how it works\n\nMethod Swizzling in iOS Development is a runtime feature used to change the implementation of an existing method at runtime. Prior to Swift 5.1, we could change the implementation of Objective-C methods marked with the @objc attribute. In Swift 5.1, Apple added an alternative feature to Swift to change the implementation of Swift methods at runtime.\n\nWhy is it needed?\n\nLet’s imagine that you have a third-party library in your project that contains a method in some class, and the implementation of this method does not work correctly or not the way you want and you want to change the implementation of this method. You can do this using the Method Swizzling feature.\n\nWhen is this even useful?\n\nLet’s imagine you are writing applications for iOS/iPadOS and at some point you want to change the language of the application on the fly (at runtime) without reloading the application. At this time, applying Method Swizzling would be useful.\n\nMethod swizzling in Swift is a powerful technique that allows developers to modify the behavior of existing methods at runtime. It enables us to intercept calls to methods and replace them with our custom implementations. This technique has proven to be immensely useful in many scenarios, such as adding logging, measuring performance, or extending functionality of existing classes without modifying their original source code. To understand how method swizzling works, let’s delve into the core concepts of this technique. Method swizzling is essentially an approach to exchange the implementation of two methods in a class. In Swift, this can be achieved by leveraging the Objective-C runtime library, which is fully compatible with Swift. To perform method swizzling, we need to perform the following steps:\n• Identify the Class and the Methods: First, we need to identify the class whose methods we want to swizzle. We also need to identify the two methods that we want to exchange their implementations.\n• Get Method Pointers: Once we have identified the class and methods, we need to retrieve their implementation pointers. This can be done using the `class_getInstanceMethod` function from the Objective-C runtime library. We can pass the class and the method name as parameters to obtain the pointer to the method’s implementation.\n• Create New Methods: After obtaining the pointers to the original methods, we need to create replacements for them. These new methods will have the desired behavior that we want to inject into the class. We can write our custom implementation as separate functions or methods.\n• Add New Implementations to Class: Now, we have the original methods and our custom methods ready. To perform the swizzling, we need to associate the original implementations with our custom methods and associate the custom implementations with the original methods. We can use the `method_exchangeImplementations` function from the Objective-C runtime library to achieve this.\n• Verify Swizzling: Finally, we need to verify that the swizzling was successful by invoking the original methods. We should see that the behavior has been modified as per our custom implementations. It’s important to note that method swizzling should be used judiciously. Modifying the behavior of existing methods can lead to unexpected consequences and introduce hard-to-debug issues if not done carefully. It’s recommended to thoroughly test the swizzling code and ensure that it doesn’t interfere with the existing functionality of the classes. Let’s illustrate method swizzling with a simple example. Consider a scenario where we want to add logging to the viewWillAppear method of a view controller. We can accomplish this by swizzling the method:\n\nIn this example, we extend the `UIViewController` class and define a new method called `logging_viewWillAppear`, which includes our logging logic and invokes the original `viewWillAppear` method using the `self` reference. Then, we use the `class_getInstanceMethod` and `method_exchangeImplementations` functions to swizzle the original `viewWillAppear` method with our custom implementation. To enable the swizzling, we just need to call the `swizzleViewWillAppear` method at an appropriate point, such as during app launch or in the `applicationDidFinishLaunching` method.\n\nWith this swizzling in place, every time the `viewWillAppear` method is called on a `UIViewController` instance, our custom implementation will be invoked, printing a log statement before the actual `viewWillAppear` code executes. In conclusion, method swizzling in Swift is a powerful technique that allows developers to modify the behavior of existing methods at runtime. By leveraging the Objective-C runtime library, we can exchange the implementations of two methods in a class, thereby injecting custom logic into existing classes without modifying their original source code. However, method swizzling should be used with caution and thoroughly tested to avoid unintended consequences."
    },
    {
        "link": "https://stackoverflow.com/questions/37217849/swift-extending-a-class-only-when-it-conforms-to-a-protocol-to-use-method-swiz",
        "document": "As of swift 3.0 as I understand that (semantically) what you ideally want to do is the following:\n\nNotice I've changed the order of the extension declaration, since what you want is not a default implementation of the protocol, but a default implementation of the class WHEN the specific subclass conforms to . The thing is, currently that syntax does not compile!!, we can't add requirements to class extensions =( (I feel your pain).\n\nOn the other hand, what you actually tried to do (protocol extension with requirement) compiles well, but the problem is that you can't override class methods inside a protocol extension, and by trying to swizzle you:\n\nWhat you CAN do when adding requirements to a protocol extension is to invoke any public API the class (in this case ) offers, so you can do things like:\n\nI hope you find the explanation useful, and I'm sorry to be the bearer of bad news, but currently what you want to achieve does not really seem feasible to me in a Swifty type-safe manner.\n\nBut worry not!, life continues!. When I ran into the same use case and hit the same wall as you did, I managed to get things working, but it has a bit of a drawback: it's not the Swifty type-safe way of doing things (maybe we can improve on this in a later release of Swift if it allows for Self requirements on class extensions #fingersCrossed)\n\nIn a nutshell, the solution goes like this (using your original code as example):\n• Not \"the Swift way\" of doing things\n• The swizzling method will be invoked and take effect on ALL , even though we validate for only those that conform to the protocol to run the sensitive lines of code.\n\nI very much hope it helps. If anyone found another (better) way of doing it, it would be great to hear it!"
    },
    {
        "link": "https://innominds.com/blog/method-swizzling-in-ios-development",
        "document": ""
    }
]