[
    {
        "link": "https://flask.palletsprojects.com/en/stable/errorhandling",
        "document": "Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors:\n• None the client terminated the request early and the application was still reading from the incoming data\n• None the database server was overloaded and could not handle the query\n• None a programming error in a library you are using\n• None network connection of the server to another system failed\n\nAnd that’s just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, and an exception is raised Flask will display a very simple page for you and log the exception to the .\n\nBut there is more you can do, and we will cover some better setups to deal with errors including custom exceptions and 3rd party tools.\n\nWhen an error occurs in Flask, an appropriate HTTP status code will be returned. 400-499 indicate errors with the client’s request data, or about the data requested. 500-599 indicate errors with the server or application itself. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a . The status code of the response will not be set to the handler’s code. Make sure to provide the appropriate HTTP status code when returning a response from a handler. Register handlers by decorating a function with . Or use to register the function later. Remember to set the error code when returning the response. # or, without the decorator subclasses like and their HTTP codes are interchangeable when registering handlers. ( ) Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of with the appropriate code and register and raise that exception class. Handlers can be registered for any exception class, not just subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class. When building a Flask application you will run into exceptions. If some part of your code breaks while handling a request (and you have no error handlers registered), a “500 Internal Server Error” ( ) will be returned by default. Similarly, “404 Not Found” ( ) error will occur if a request is sent to an unregistered route. If a route receives an unallowed request method, a “405 Method Not Allowed” ( ) will be raised. These are all subclasses of and are provided by default in Flask. Flask gives you the ability to raise any HTTP exception registered by Werkzeug. However, the default HTTP exceptions return simple exception pages. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. When Flask catches an exception while handling a request, it is first looked up by code. If no handler is registered for the code, Flask looks up the error by its class hierarchy; the most specific handler is chosen. If no handler is registered, subclasses show a generic message about their code, while other exceptions are converted to a generic “500 Internal Server Error”. For example, if an instance of is raised, and a handler is registered for and , the more specific handler is called with the exception instance to generate the response. Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined. It is possible to register error handlers for very generic base classes such as or even . However, be aware that these will catch more than you might expect. For example, an error handler for might be useful for turning the default HTML errors pages into JSON. However, this handler will trigger for things you don’t cause directly, such as 404 and 405 errors during routing. Be sure to craft your handler carefully so you don’t lose information about the HTTP error. \"\"\"Return JSON instead of HTML for HTTP errors.\"\"\" # start with the correct headers and status code from the error An error handler for might seem useful for changing how all errors, even unhandled ones, are presented to the user. However, this is similar to doing in Python, it will capture all otherwise unhandled errors, including all HTTP status codes. In most cases it will be safer to register handlers for more specific exceptions. Since instances are valid WSGI responses, you could also pass them through directly. Error handlers still respect the exception class hierarchy. If you register handlers for both and , the handler will not handle subclasses because the handler is more specific. When there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See for information about this behavior. If there is an error handler registered for , this will be invoked. As of Flask 1.1.0, this error handler will always be passed an instance of , not the original unhandled error. The original error is available as . An error handler for “500 Internal Server Error” will be passed uncaught exceptions in addition to explicit 500 errors. In debug mode, a handler for “500 Internal Server Error” will not be used. Instead, the interactive debugger will be shown.\n\nSometimes when building a Flask application, you might want to raise a to signal to the user that something is wrong with the request. Fortunately, Flask comes with a handy function that aborts a request with a HTTP error from werkzeug as desired. It will also provide a plain black and white error page for you with a basic description, but nothing fancy. Depending on the error code it is less or more likely for the user to actually see such an error. Consider the code below, we might have a user profile route, and if the user fails to pass a username we can raise a “400 Bad Request”. If the user passes a username and we can’t find it, we raise a “404 Not Found”. # a username needs to be supplied in the query args # a successful request would be like /profile?username=jack # if a username isn't supplied in the request, return a 400 bad request # if a user can't be found by their username, return 404 not found Here is another example implementation for a “404 Page Not Found” exception: # note that we set the 404 status explicitly An example template might be this: Page Not Found Page Not Found What you were looking for is just not there. go somewhere nice The above examples wouldn’t actually be an improvement on the default exception pages. We can create a custom 500.html template like this: Internal Server Error Internal Server Error Oops... we seem to have made a mistake, sorry! Go somewhere nice instead It can be implemented by rendering the template on “500 Internal Server Error”: # note that we set the 500 status explicitly When using Modular Applications with Blueprints:\n\nIn Modular Applications with Blueprints, most error handlers will work as expected. However, there is a caveat concerning handlers for 404 and 405 exceptions. These error handlers are only invoked from an appropriate statement or a call to in another of the blueprint’s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not “own” a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the proxy object. # if a request is in our blog URL space # otherwise we return our generic site-wide 404 page # if a request has the wrong method to our API # we return a json saying so\n\nWhen building APIs in Flask, some developers realise that the built-in exceptions are not expressive enough for APIs and that the content type of text/html they are emitting is not very useful for API consumers. Using the same techniques as above and we can return JSON responses to API errors. is called with a parameter. The error handler will use that as the JSON error message, and set the status code to 404. We can also create custom exception classes. For instance, we can introduce a new custom exception for an API that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error. This is a simple example: # an API app route for getting user information A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the parameter."
    },
    {
        "link": "https://stackoverflow.com/questions/60324360/what-is-best-practice-for-flask-error-handling",
        "document": "For returning a response to clients in a webapp, I've seen the following conventions:\n\nWhat are the difference and when would one be preferred?\n\nComing from , I am used to defining a custom exception with a status code associated with it and then anytime the application throws that exception, a response with that status code is automatically returned to the user (instead of having to explicitly catch it and return a response as shown above). Is this possible in ? This is my little wrapped attempt\n\nThen to use"
    },
    {
        "link": "https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling",
        "document": "This is the seventh installment of the Flask Mega-Tutorial series, in which I'm going to tell you how to do error handling in a Flask application.\n\nYou are reading the 2024 edition of the Flask Mega-Tutorial. The complete course is also available to order in e-book and paperback formats from Amazon. Thank you for your support!\n\nIf you are looking for the 2018 edition of this course, you can find it here.\n\nFor your reference, here is the complete list of articles in this series:\n\nIn this chapter I'm taking a break from coding new features into my microblog application, and instead will discuss a few strategies to deal with bugs, which invariably make an appearance in every software project. To help illustrate this topic, I intentionally let a bug slip in the code that I've added in Chapter 6. Before you continue reading, see if you can find it!\n\nThe GitHub links for this chapter are: Browse, Zip, Diff.\n\nWhat happens when an error occurs in a Flask application? The best way to find out is to experience it first hand. Go ahead and start the application, and make sure you have at least two users registered. Log in as one of the users, open the profile page and click the \"Edit\" link. In the profile editor, try to change the username to the username of another user that is already registered, and boom! This is going to bring a scary looking \"Internal Server Error\" page:\n\nIf you look in the terminal session where the application is running, you will see a stack trace of the error. Stack traces are extremely useful in debugging errors, because they show the sequence of calls in that stack, all the way to the line that produced the error:\n\nThe stack trace helps you determine what is the bug. The application allows a user to change the username, but it does not validate that the new username chosen does not collide with another user already in the system. The error comes from SQLAlchemy, which tries to write the new username to the database, but the database rejects it because the column is defined with the option.\n\nIt is important to note that the error page that is presented to the user does not provide much information about the error, and that is good. I definitely do not want users to learn that the crash was caused by a database error, or what database I'm using, or what are some of the table and field names in my database. All that information should be kept internal.\n\nBut there are a few things that are far from ideal. I have an error page that is very ugly and does not match the application layout. I also have important application stack traces being dumped on a terminal that I need to constantly watch to make sure I don't miss any errors. And of course, I have a bug to fix. I'm going to address all these issues, but first, let's talk about Flask's debug mode.\n\nThe way you saw that errors are handled above is great for a system that is running on a production server. If there is an error, the user gets a vague error page (though I'm going to make this error page nicer), and the important details of the error are in the server process output or in a log file.\n\nBut when you are developing your application, you can enable debug mode, a mode in which Flask outputs a really nice debugger directly on your browser. To activate debug mode, stop the application, and then set the following environment variable:\n\nIf you are on Microsoft Windows, remember to use instead of .\n\nAfter you set , restart the server. The output on your terminal is going to be slightly different than what you are used to see:\n\nNow make the application crash one more time to see the interactive debugger in your browser:\n\nThe debugger allows you expand each stack frame and see the corresponding source code. You can also open a Python prompt on any of the frames and execute any valid Python expressions, for example to check the values of variables.\n\nIt is extremely important that you never run a Flask application in debug mode on a production server. The debugger allows the user to remotely execute code in the server, so it can be an unexpected gift to a malicious user who wants to infiltrate your application or your server. As an additional security measure, the debugger running in the browser starts locked, and on first use it will ask for a PIN, which you can see in the output of the command.\n\nSince I am on the topic of debug mode, I should mention the second important feature that is enabled with debug mode, which is the reloader. This is a very useful development feature that automatically restarts the application when a source file is modified. If you run while in debug mode, you can then work on your application and any time you save a file, the application will restart to pick up the new code.\n\nFlask provides a mechanism for an application to install its own error pages, so that your users don't have to see the plain and boring default ones. As an example, let's define custom error pages for the HTTP errors 404 and 500, the two most common ones. Defining pages for other errors works in the same way.\n\nTo declare a custom error handler, the decorator is used. I'm going to put my error handlers in a new app/errors.py module.\n\nThe error functions work very similarly to view functions. For these two errors, I'm returning the contents of their respective templates. Note that both functions return a second value after the template, which is the error code number. For all the view functions that I created so far, I did not need to add a second return value because the default of 200 (the status code for a successful response) is what I wanted. In this case these are error pages, so I want the status code of the response to reflect that.\n\nThe error handler for the 500 errors could be invoked after a database error, which was actually the case with the username duplicate above. To make sure any failed database sessions do not interfere with any database accesses triggered by the template, I issue a session rollback. This resets the session to a clean state.\n\nHere is the template for the 404 error:\n\nAnd here is the one for the 500 error:\n\nBoth templates inherit from the template, so that the error page has the same look and feel as the normal pages of the application.\n\nTo get these error handlers registered with Flask, I need to import the new app/errors.py module after the application instance is created:\n\nIf you set in your terminal session (or delete the variable), and then trigger the duplicate username bug one more time, you are going to see a slightly more friendly error page.\n\nThe other problem with the default error handling provided by Flask is that there are no notifications. The stack traces for any errors are printed to the terminal, which means that the output of the server process needs to be monitored to discover errors. When you are running the application during development, this is perfectly fine, but once the application is deployed on a production server, nobody is going to be looking at the output of the server, so a more robust solution needs to be put in place.\n\nI think it is very important to take a proactive approach regarding errors. If an error occurs on the production version of the application, I want to know right away. So my first solution is going to be to configure Flask to email me immediately after an error, with the stack trace of the error in the email body.\n\nThe first step is to add the email server details to the configuration file:\n\nThe configuration variables for email include the server and port, a boolean flag to enable encrypted connections, and optional username and password. The five configuration variables are sourced from their environment variable counterparts. If the email server is not set in the environment, then I will use that as a sign that emailing errors needs to be disabled. The email server port can also be given in an environment variable, but if not set, the standard port 25 is used. Email server credentials are by default not used, but can be provided if needed. The configuration variable is a list of the email addresses that will receive error reports, so your own email address should be in that list.\n\nFlask uses Python's package to write its logs, and this package already has the ability to send logs by email. All I need to do to get emails sent out on errors is to add a SMTPHandler instance to the Flask logger object, which is :\n\nAs you can see, I'm only going to enable the email logger when the application is running without debug mode, which is indicated by being , and also when the email server exists in the configuration.\n\nSetting up the email logger is somewhat tedious due to having to handle optional security options that are present in many email servers. But in essence, the code above creates a instance, sets its level so that it only reports errors and not warnings, informational or debugging messages, and finally attaches it to the object from Flask.\n\nThere are two approaches to test this feature. The easiest one is to use an SMTP debugging server. This is a fake email server that accepts emails, but instead of sending them, it prints them to the console. To run this server, open a second terminal session, activate the virtual environment, and install the package:\n\nThen run the following command to start a debugging email server:\n\nThis command will not print anything yet, but will wait for clients to connect. Leave the debugging SMTP server running and go back to your first terminal and configure your email server as follows:\n\nAs always, use instead of if you are on Microsoft Windows. Make sure the variable is set to 0 or not set at all, since the application will not send emails in debug mode. Run the application and trigger the SQLAlchemy error one more time to see how the terminal session running the fake email server shows an email with the full stack trace of the error.\n\nA second testing approach for this feature is to configure a real email server. Below is the configuration to use your Gmail account's email server:\n\nIf you are using Microsoft Windows, remember to use instead of in each of the statements above.\n\nThe security features in your Gmail account may prevent the application from sending emails through it unless you explicitly allow \"less secure apps\" access to your Gmail account. You can read about this here, and if you are concerned about the security of your account, you can create a secondary account that you configure just for testing emails, or you can enable less secure apps only temporarily to run this test and then revert to the default.\n\nYet another alternative is to use a dedicated email service such as SendGrid, which allows you to send up to 100 emails per day on a free account.\n\nReceiving errors via email is nice, but sometimes this isn't enough. There are some failure conditions that do not end in a Python exception and are not a major problem, but they may still be interesting enough to save for debugging purposes. For this reason, I'm also going to maintain a log file for the application.\n\nTo enable a file based log another handler, this time of type RotatingFileHandler, needs to be attached to the application logger, similarly to the email handler.\n\nI'm writing the log file with name in a logs directory, which I create if it doesn't already exist.\n\nThe class is nice because it rotates the logs, ensuring that the log files do not grow too large when the application runs for a long time. In this case I'm limiting the size of the log file to 10KB, and I'm keeping the last ten log files as backup.\n\nThe class provides custom formatting for the log messages. Since these messages are going to a file, I want them to have as much information as possible. So I'm using a format that includes the timestamp, the logging level, the message and the source file and line number from where the log entry originated.\n\nTo make the logging more useful, I'm also lowering the logging level to the category, both in the application logger and the file logger handler. In case you are not familiar with the logging categories, they are , , , and in increasing order of severity.\n\nAs a first interesting use of the log file, the server writes a line to the logs each time it starts. When this application runs on a production server, these log entries will tell you when the server was restarted.\n\nI have used the username duplication bug for too long. Now that I have showed you how to prepare the application to handle these types of errors, I can go ahead and fix it.\n\nIf you recall, the already implements validation for usernames, but the requirements of the edit form are slightly different. During registration, I need to make sure the username entered in the form does not exist in the database. On the edit profile form I have to do the same check, but with one exception. If the user leaves the original username untouched, then the validation should allow it, since that username is already assigned to that user. Below you can see how I implemented the username validation for this form:\n\nThe implementation is in a custom validation method, but there is an overloaded constructor that accepts the original username as an argument. This username is saved as an instance variable, and checked in the method. If the username entered in the form is the same as the original username, then there is no reason to check the database for duplicates.\n\nTo use this new validation method, I need to add the original username argument in the view function, where the form object is created:\n\nNow the bug is fixed and duplicates in the edit profile form will be prevented in most cases. This is not a perfect solution, because it may not work when two or more processes are accessing the database at the same time. In that situation, a race condition could cause the validation to pass, but a moment later when the rename is attempted the database was already changed by another process and cannot rename the user. This is somewhat unlikely except for very busy applications that have a lot of server processes, so I'm not going to worry about it for now.\n\nAt this point you can try to reproduce the error one more time to see how the new form validation method prevents it.\n\nFlask's debug mode is so useful that you may want to have it turned on by default. This can be done by adding the environment variable to the .flaskenv file.\n\nWith this change, debug mode will be enabled when you start the server with the command.\n\nContinue on to the next chapter."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-handle-errors-in-a-flask-application",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language.\n\nWhen you’re developing a web application, you will inevitably run into situations where your application behaves in a way contrary to what you expected. You might misspell a variable, misuse a loop, or construct an statement in a way that raises a Python exception, like calling a function before declaring it, or simply looking for a page that doesn’t exist. You’ll find it easier and smoother to develop your Flask applications if you learn how to handle errors and exceptions properly.\n\nIn this tutorial, you’ll build a small web application that demonstrates how to handle common errors one encounters when developing a web application. You’ll create custom error pages, use the Flask debugger to troubleshoot exceptions, and use logging to track events in your application.\n• A local Python 3 programming environment. You can follow the tutorial for your distribution in How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial we’ll call our project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n\nIn this step, you’ll create an application that has a few errors and run it without debug mode to see how the application responds. Then you’ll run it with debug mode on and use the debugger to troubleshoot application errors.\n\nWith your programming environment activated and Flask installed, open a file called for editing inside your directory:\n\nAdd the following code inside the file:\n\nIn the above code, you first import the class from the package. Then you create a Flask application instance called . You use the decorator to create a view function called , which calls the function as the return value, which in turn renders a template called . There are two errors in this code: the first is that you did not import the function, and the second one is that the template file does not exist.\n\nNext, inform Flask about the application using the environment variable using the following command (on Windows, use instead of ):\n\nThen run the application server using the command:\n\nYou will see the following information in your terminal:\n\nThis output provides the following information:\n• The Flask application being served ( in this case)\n• The environment, which is here. The warning message stresses that this server is not for a production deployment. You’re using this server for development, so you can ignore this warning, but for more information, see the Deployment Options page on the Flask documentation. You can also check out this Flask deployment tutorial with Gunicorn, or this one with uWSGI, or you can use DigitalOcean App Platform to deploy your Flask application by following the How To Deploy a Flask App Using Gunicorn to App Platform tutorial.\n• The debug mode is off, which means that the Flask debugger is not running, and you won’t receive helpful error messages in your application. In a production environment, displaying detailed errors exposes your application to security vulnerabilities.\n• The server is running on the URL. To stop the server, use , but don’t do that just yet.\n\nNow, visit the index page using your browser:\n\nYou will see a message that looks like the following:\n\nThis is the 500 Internal Server Error, which is a server error response that indicates that the server encountered an internal error in the application code.\n\nIn the terminal, you’ll see the following output:\n\nThe traceback above goes through the code that triggered the internal server error. The line NameError: name 'render_template' is not defined gives the root cause of the problem: the function has not been imported.\n\nAs you can see here, you have to go to the terminal to troubleshoot errors, which is not convenient.\n\nYou can have a better troubleshooting experience by enabling the debug mode in your development server. To do so, stop the server with and set the environment variable to , so you can run the application in development mode (which enables the debugger), using the following command (on Windows, use instead of ):\n\nYou’ll see an output similar to the following in the terminal:\n\nHere you see that the environment is now , debug mode is on, and the debugger is active. The is a PIN you need to unlock the console in your browser (an interactive python shell you can access by clicking the little terminal icon encircled in the image below).\n\nRefresh the index page on your browser and you’ll see the following page:\n\nHere, you see the error message displayed in a manner that’s easier to understand. The first heading gives you the name of the Python exception that caused the problem ( in this case). The second line gives you the direct reason ( is not defined, which means it’s not imported in this case). Following that, you have the traceback going through the inner Flask code that was executed. Read the traceback from the bottom upward, because the last line in the traceback usually has the most useful information.\n\nTo fix this issue, leave the server running, open a new terminal window, activate your environment, and open your file:\n\nModify the file to look as follows:\n\nHere you imported the function that was missing.\n\nWith the development server running, refresh the index page on your browser.\n\nThis time you’ll see an error page with information that looks like so:\n\nThis error message indicates that the template does not exist.\n\nTo fix this, you’ll create a template file other templates will inherit from to avoid code repetition, then an template that extends the base template.\n\nCreate the directory, which is the directory where Flask looks for template files. Then open a file using your favorite editor:\n\nAdd the following code to your file:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has two links, one for the index page where you use the helper function to link to the view function, and the other for an About page if you choose to include one in your application.\n\nNext, open a template file called , which will inherit from the base template.\n\nAdd the following code to it:\n\nIn the code above, you extend the base template and override the block. You then set a page title and display it in an header using the block, and display a greeting in an header.\n\nWith the development server running, refresh the index page on your browser.\n\nYou’ll see that the application displays no more errors and the index page is displayed as expected.\n\nYou’ve now used debug mode and seen how to handle error messages. Next, you’ll abort a request to respond with an error message of your choice, and see how to respond with custom error pages.\n\nIn this step, you’ll learn how to abort requests and respond with a 404 HTTP error message for when the user requests data that does not exist on the server. You will also learn how to create custom error pages for common HTTP errors, such as the error, and the error.\n\nTo demonstrate how to abort requests and respond with a custom 404 HTTP error page, you’ll create a page that displays a few messages. If the requested message does not exist, you’ll respond with a 404 error.\n\nFirst, open your file to add a new route for the messages page:\n\nAdd the following route at the end of the file:\n\nIn the route above, you have a URL variable . This is the index that will determine what message will be displayed. For example, if the URL is , the first message ( ) will be displayed. You use the converter to accept only positive integers, because URL variables have string values by default.\n\nInside the view function, you have a regular Python list called with three messages. (In a real-world scenario, these messages would come from a database, an API, or another external data source.) The function returns a call to the function with two arguments, as the template file, and a variable that will be passed to the template. This variable will have a list item from the list depending on the value of the variable in the URL.\n\nAdd the following code to it:\n\nIn the code above, you extend the base template and override the block. You add a title ( ) in an H1 heading, and display the value of the variable in an H2 heading.\n\nWith the development server running, visit the following URLs on your browser:\n\nYou’ll see that the contains the text , , or respectively on each one of the first three URLs. However, on the fourth URL, the server will respond with an error message. In a production environment, the response would’ve been a , but the proper response here is a to indicate that the server can’t find a message with an index of .\n\nYou can respond with a error using Flask’s helper function. To do so, open the file:\n\nEdit the first line to import the function. Then edit the view function by adding a clause as shown in the highlighted parts below:\n\nIn the code above, you import the function, which you use to abort the request and respond with an error. In the view function, you use a clause to wrap the function. You first try to return the template with the message that corresponds to the index in the URL. If the index has no corresponding message, the exception will be raised. You then use the clause to catch that error, and you use to abort the request and respond with a HTTP error.\n\nWith the development server running, use your browser to revisit the URL that responded with an earlier (or visit any URL with an index greater than 2):\n\nYou will see the following response:\n\nYou now have a better error message that indicates that the server could not find the requested message.\n\nNext, you’ll make a template for the 404 error page and one for the 500 error page.\n\nFirst, you’ll register a function with the special decorator as a handler for the error. Open the file for editing:\n\nEdit the file by adding the highlighted part as follows:\n\nHere you use the decorator to register the function as a custom error handler. The function takes the error as an argument, and it returns a call to the function with a template called . You will create this template later, and you can use another name if you want. You also return the integer after the call. This tells Flask that the status code in the response should be . If you don’t add it, the default status code response will be , which means that the request has succeeded.\n\nAdd the following code to it:\n\nJust like any other template, you extend the base template, you replace the content of the and blocks, and you add your own HTML code. Here you have an heading as the title, a tag with a custom error message telling the user the page was not found, and a helpful message for users who might have entered the URL manually.\n\nYou can use whatever HTML, CSS, and JavaScript you want in your error pages in the same way you would in other templates.\n\nWith the development server running, use your browser to revisit the following URL:\n\nYou’ll see the page now has the navigation bar that’s in the base template and the custom error message.\n\nSimilarly, you can add a custom error page for your errors. Open the file:\n\nAdd the following error handler below the error handler:\n\nHere you use the same pattern as you did for the error handler. You use the decorator with a argument to make a function called into an error handler. You render a template called , and respond with a status code of .\n\nThen to demonstrate how the custom error will be presented, add a route that responds with a HTTP error at the end of the file. This route will always give a regardless of whether the debugger is running or not:\n\nHere you make a route and use the function to respond with a HTTP error.\n\nNext, open the new template:\n\nAdd the following code to it:\n\nHere, you do the same thing you did with the template. You extend the base template, and replace the content block with a title and two custom messages informing the user about the internal server error.\n\nWith the development server running, visit the route that responds with a error:\n\nYour custom page will appear instead of the generic error page.\n\nYou now know how to use custom error pages for HTTP errors in your Flask application. Next, you’ll learn how to use logging to track events in your application. Tracking events helps you understand how your code behaves, which in turn helps with development and troubleshooting.\n\nStep 3 — Using Logging to Track Events in Your Application\n\nIn this step, you will use logging to track events that happen when the server is running and the application is being used, which helps you see what is going on in your application code so you can troubleshoot errors easier.\n\nYou have already seen logs whenever the development server is running, which typically look like this:\n\nIn these logs, you can see the following information:\n• : The host the server was running on.\n• : The date and time of the request.\n• : The HTTP request method. In this case, is used to retrieve data.\n• or : The status code of the response.\n\nThese logs help you diagnose problems that occur in your application. You can log more information when you want to know more details about certain requests using the logger Flask provides.\n\nWith logging, you can use different functions to report information on different logging levels. Each level indicates an event happened with a certain degree of severity. The following functions can be used:\n• : For detailed information about the event.\n• : Confirmation that things are working as expected.\n• : Indication that something unexpected happened (such as “disk space low”), but the application is working as expected.\n• : An error occurred in some part of the application.\n\nTo demonstrate how to use the Flask logger, open your file for editing to log a few events:\n\nEdit the view function to look as follows:\n\nHere, you logged a few events on different levels. You use to log an event that’s working as expected (which is an level). You use for detailed information ( level), mentioning that the application is now getting a message with a specific index. Then you use to log the fact that an exception has been raised with the specific index that caused the issue ( level, because an error occurred).\n\nYou’ll see the following information in the terminal where your server is running:\n\nHere you see the message logs, and the message with the index number that you logged using .\n\nNow visit a URL for a message that does not exist:\n\nYou’ll see the following information in the terminal:\n\nAs you can see, you have and logs that you’ve seen before, and a new log because a message with an index of does not exist.\n\nLogging events, detailed information, and errors helps you identify where something went wrong and makes troubleshooting easier.\n\nYou’ve learned in this step how to use the Flask logger. Check out How To Use Logging in Python 3 for a better understanding of logging. For an in-depth look at logging, see the Flask logging documentation and the Python documentation for logging.\n\nYou now know how to use debug mode in Flask, and how to troubleshoot and fix some common errors you may encounter when developing a Flask web application. You’ve also created custom error pages for common HTTP errors, and you’ve used the Flask logger to track events in your application to help you inspect and figure out how your application behaves.\n\nIf you would like to read more about Flask, check out the Flask topic page."
    },
    {
        "link": "https://stackoverflow.com/questions/67364865/what-is-error-handling-best-practice-in-flask-restapi",
        "document": "I am building a restAPI that is serving machine learning model. My co-worker who will be sending request to my restAPI and use the outcome to send it to users wants me to send him appropriate error message as well with status_code.\n\nI've did a lot of searching on how to properly handle errors in Python Flask however I am still stuck on what would be a best practice for scalable and maintainable restAPI.\n\nCurrently whenever some error occurs I simply return dictionary with message and status code. There are some problems with this method that I want to mitigate:\n• None If error occurs inside a function it has to return dictionary containing error messages to where the function was called and at need to check if it was actually an error, if yes then return error message def add_data(x,y): \"\"\"return addition of x,y. They both need to be integers\"\"\" if type(x) != int: return \"x has wrong datatype\" if type(y) != int: return \"y has wrong datatype\" return x+y @app.route(\"/predict\", methods=[\"POST\"]) def predict(): data = request.get_json() result = add_data(data[\"x\"], data[\"y\"]) if type(result) == str: return {\"message\":\"input error\", \"status\":222}\n• \n• What is best practice for flask error handling? I've changed my code to following: class InputError(Exception): status_code = 400 def __init__(self, message, status_code=None): Exception.__init__(self) self.message = message if status_code is not None: self.status_code = status_code def __str__(self): return repr(self.status_code) def add_data(x,y): if type(x) != int: raise InputError(\"x has wrong datatype\", status_code=222) if type(y) != int: raise InputError(\"y has wrong datatype\", status_code=222) return x+y This does break the code where error is found however I cannot find out how to return dictionary just like before.\n\nHow can I do this and which practice is considered a best practice?"
    },
    {
        "link": "https://docs.netlify.com/functions/get-started",
        "document": "Start by adding the module to your project, which exports all the types you need to create type-safe functions.\n\nYou don’t need any additional tooling or configuration to use TypeScript functions, but you can choose to provide your own file if you want to extend the base configuration in order to rewrite import paths, for example.\n\nOur build system will load any files from your functions directory, the repository root directory, or the base directory, if set.\n\nTo add a serverless function to your project, create a TypeScript file in your functions directory.\n\nYou can store your function file directly under the functions directory or in a subdirectory dedicated to the function. If you choose a subdirectory, the function entry file must be named or have the same name as the subdirectory.\n\nFor example, any of the following files would create a function called :\n\nA function file must be written using the JavaScript modules syntax and have a default export with a handler function.\n\nThe handler function receives the following arguments:\n• A Netlify-specific object with metadata related to the client and the site\n\nFor synchronous functions, the return value of the handler function may be used as the HTTP response to be delivered to the client.\n\nA synchronous function lets you implement a traditional client/server interaction, where the connection is kept open until the function execution is finished, allowing the client to wait for a response before rendering a page or moving on to the next task.\n\nThe handler function should return a object representing the HTTP response to be delivered to the client, including any caching headers you want to set. If no value is returned, the client will receive an empty response with a 204 status code.\n\nYou can also use to handle background tasks without delaying the response. This is useful for logging, analytics, or other operations that don’t need to block the client.\n\nSynchronous functions can stream data to clients as it becomes available, rather than returning a buffered payload at the end of the computation. This lets developers and frameworks create faster experiences by using streaming and partial hydration to get content and interactions in front of people as quickly as possible.\n\nTo stream a function’s response, return a as the property of the object.\n\nWhen returning a stream, keep the following limitations in mind:\n• 10 second execution limit. If the limit is reached, the response stops streaming.\n• 20 MB response size limit. Responses larger than 20 MB cannot be streamed.\n\nWith background functions, the function invocation is placed into a queue and the client connection is terminated immediately. This pattern lets you perform longer-running operations without forcing clients to wait for a response.\n\nThe handler function does not need to return anything, as the client will always receive an empty response with a 202 status code. Any response returned by the handler function will be ignored.\n\nTo define a background function, the name of the function needs to have a suffix (for example, or ).\n\nNetlify automatically creates a dedicated endpoint for every function you create, using the format .\n\nAdditionally, you can configure the function to run on any path of your choice by defining a property in the export of your function.\n\nYou can choose to run a function on one or more URL paths. To configure multiple paths, set the property as an array.\n\nYou can leverage the syntax from the web platform to define wildcards and named groups, which are matched against the incoming request URL and exposed to the function in the object.\n\nWhen needed, use as an optional exclusion to limit the routes matched by . Must also start with , for example . Accepts a single string or an array of strings.\n\nBy default, a function runs for any requests to its configured paths regardless of whether or not static assets exist on those paths. To prevent the function from shadowing files on the CDN, set to .\n\nNetlify Functions have access to environment variables in the runtime environment via the global object.\n\nIf you have the option to set specific scopes for your environment variables, the scope must include Functions to be available to functions during runtime.\n\nYou can also leverage build environment variables to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.\n\nLearn more about how to set and use environment variables with functions.\n\nNetlify Functions run in Node.js, using the version configured for your site. Node.js version 18.0.0 is the minimum version required because functions use the standard Fetch API, which was only added natively to Node.js in version 18.0.0.\n\nNode.js supports two distinct module formats with different capabilities and APIs: ECMAScript modules (or ES modules), an official standard format for JavaScript packages, and CommonJS, a legacy format specific to Node.js.\n\nThe module format for each function will be determined by the file extension of its entry file:\n• Functions with the extension are always executed as ES modules\n• Functions with the extension are always executed as CommonJS\n• Functions with the extension are executed as ES modules if the closest file has a property with the value ; otherwise they are executed as CommonJS\n\nChoosing a module format has implications on how you write your function, especially when it comes to importing npm packages:\n• CommonJS functions cannot use a static to load npm packages written as ES modules and must use a dynamic import\n• ES modules functions cannot use named imports (for example, ) when referencing npm packages written in CommonJS, and should instead use a default import (for example, )\n• In ES modules, Node.js built-in primitives like and are not available and should be replaced with\n\nNetlify Functions support an alternative API surface that is compatible with AWS Lambda. This may be useful if you’re looking to migrate Lambda workflows into Netlify with minimal refactoring required.\n\nTo opt-in, your handler function must be exported using a named export.\n\nFor more information about this API, refer to Lambda compatibility.\n\nTo streamline writing and testing your functions on Netlify, run a local development environment with Netlify Dev. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.\n\nBy default, the location used is the location of your local environment. To override this to a default mock location of San Francisco, CA, USA, use the flag. To mock a specific country, use with a two-letter country code. For more information about the flag, visit the CLI docs.\n\nPush your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about other workflows for deploying your functions including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.\n\nMonitor function logs and metrics in the Netlify UI to observe and help troubleshoot your deployed functions.\n\nNetlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the Netlify CLI."
    },
    {
        "link": "https://netlify.com/blog/intro-to-serverless-functions",
        "document": "Serverless is a term we hear a lot in this industry, but what does serverless really mean? Serverless doesn’t really mean you don’t have servers, it’s more like servers as a service. Instead of owning and maintaining your own servers, you let a service do the work for you. You can focus on the business needs and developing a better quality application instead of worrying about the infrastructure and maintenance of a traditional server.\n\nServerless functions, branded as Netlify Functions when running on Netlify, are a way to deploy server-side code as API endpoints. These will spin up automatically when triggered by an event, handle and process server ran code, and then spin down until the next event. Using Netlify for your serverless functions creates a seamless workflow that allows you to write and test your functions locally with the Netlify CLI, build and deploy your applications, and avoid the setup, cost, and maintenance of a physical server.\n\nOn Netlify, there are several options when it comes to using serverless functions. This post is going to focus on traditional serverless functions, but you may also want to explore background functions or the new edge functions that can be distributed closer to your users.\n\nWhat’s thought of as a traditional serverless function, is a short running synchronous function written in JavaScript, TypeScript, or Go that is hosted as an endpoint. It performs some server side code and then returns a response to the client immediately. These are AWS Lambda functions with a default region of . They have a 10 second time limit and a memory limit of 1024 megabytes.\n\nEverything that we do in technology has a tradeoff, there are pros and cons no matter what it is. Let’s look at both for serverless functions.\n• abstracts away the setup and maintenance of a physical server\n• cold starts - referring to the time it takes to start up when a function is invoked or ephemeral containers\n\nNow we are going to walk through the steps to get a serverless function up and running on Netlify. To get started with this project, having some understanding of HTML, JavaScript, the command line, npm, and git will be helpful. Also, if you don’t already have a Netlify account, you can sign up for free here.\n• Open the explorers up and running with serverless functions repository on Netlify’s GitHub.\n• Click the Use this template button in order to create this repo inside of your own account.\n• Give your cloned repo a name and click the Create repository from template button.\n• Once you have created the new repository, click the Code button and copy the link to clone the repository.\n• Open up a terminal to the location you want the project to be placed at, then run the command and paste your link that you copied in the last step.\n• You can change directory with into your new project folder directly from the terminal or open your folder in your favorite code editor.\n• Currently there is only a and file and a folder inside.\n\nNow that you have the project cloned and up setup locally, we need to install the packages needed to run the serverless functions locally. First, make sure you have Node.js installed on your machine. You can check if you have it and what version by running . Now, we need to install the Netlify Command Line Interface, or CLI. Run the following command in the terminal to install it globally on your machine.\n\nYou can either use the or the shorthand to run cli commands. I’ll be using the shorthand versions for the remainder of the tutorial. Check the version you are running of the cli with .\n\nIf you don’t already have a Netlify account, you can sign up for free here. Then you can login with the CLI by running and authorize the application.\n\nNow we need to initialize the application by running and go through the steps to create a new site on Netlify.\n• Select the team you want to use.\n• Name your site or leave it blank for a random name.\n• The site is now created. You should see your admin URL, the main URL, and the site id listed in the terminal.\n• The CLI will prompt us for the build command, leave this blank and the CLI will fill in .\n• Fill in the directory to deploy as the folder.\n• In this step, leave the default folder.\n• And since we haven’t created a file yet, in this step, enter to generate one with the settings you specified.\n• Once you see the Success! message, your site is ready to deploy. There are some next steps listed, to trigger a deploy or run to open your new site’s dashboard.\n\nThe basic anatomy of any serverless function has three basic parts. It must export a handler asynchronous function and then return an object with a and property, which typically has a JSON object that needs to be converted to a string using the method for the to be read.\n\nNow that the project is set up locally and linked to a Netlify url, we can start looking through the project.\n\nOpen up the directory you created in your favorite code editor and navigate inside the public directory to the file and open it up.\n\nIf you look inside the tag, you should see an tag, a with an , and a placeholder for the response. In the tag below, there is an event listener that listens for a click on the button and inserts the response into the placeholder area.\n\nThe next file to look at is the file that we setup with the Netlify CLI. The build settings should be set up as follows.\n\nThe directory for the functions defined in the toml file hasn’t been created yet. At the root of your project, create a new folder named netlify and another folder inside it named functions. The new project structure should look like this.\n\nInside of the new directory, create a new file . Use the syntax and create an async function called , that returns a of 200 and a with the that is stringified with the method.\n\nNow, let’s configure the client side JavaScript we will use to fetch the response over in the file. In the tag below the markup, there is a event listener set up to listen for a click on the button in the markup. Here we need to make the function , create a variable to fetch the serverless function endpoint, and return the response. One interesting thing to point out, is when we fetch the serverless function, we need to call it at the directory , with a dot in front of it. This is to avoid name collisions with other APIs.\n\nOnce the function is setup, we can run in the console to run the development server and test the function. Open up in the browser, open the developer console, and navigate to the network panel.\n\nWhen you click on the fetch button, you will see the call come into the network panel.\n\nYou can see the status and if you click on the function and navigate to the Preview tab, you can see the object message of “Hello World!”.\n\nYou may notice the text is printing , this is because we need to stringify the response in the event listener function. Add the method and save the file.\n\nIf you reload the site and click the Fetch button again, now the message will display correctly.\n\nExternal APIs can be integrated with a serverless function to grab data, that can then be used in the response. We are going to work with the Poke API, which allows you to get all kinds of information about the Pokémon world.\n\nBack in the code editor, we need to create a new file in our directory named that will house our new endpoint. This time, create a constant for the url , await the fetch call to the url, and create a new constant, , and await the . Next, we’ll return the and stringify the data response in the body.\n\nBack in the file, first we will need to add a new button to fetch the endpoint we just created. Add a new button to the markup, with the id and the text Fetch Pokedex.\n\nNext in the tag, create a constant and add the element selector.\n\nAnd finally, create a new event listener function for a click on the to add the stringified data to the of the variable set to the tag.\n\nAt this point, if you run the server with , you will see both of the buttons we created, but the Fetch Pokedex button will return an error. Checking the network panel and the terminal for the issue, we’ll see a 500 error and an .\n\nThis happens because the serverless function running at the endpoint is on a Node.JS server. Node does not have access to the native fetch API provided inside the browser. As a result, we need to install a dependency that will allow us to run fetch on a Node server. Shut down the server with and follow the next steps to set up server-side fetch.\n\nTo install packages inside of our application, we need to create initialize this as a project. To do that, run in the root directory of your project. This will walk through steps to create a file. You can leave everything as default by hitting through each step or change anything by typing it in and then hitting . Once complete, it will ask you “Is this OK?” and you hit for yes or type no if you wish to start over.\n\nOnce you say yes and hit , a new file will be created at the root of your project with the above information.\n\nThis file is responsible for keeping track of any dependencies and some basic details of the project.\n\nAs of Node.js version , ESM, or ECMAScript modules, support became available in any Node.js application. Some libraries, like the one we will be installing next, have made the ESM migration. While you can use libraries with or without ESM, you can’t pick and choose the syntax you use. You must completely convert your application to ESM or stick with the old syntax. The original videos this tutorial is based on used the older syntax for the serverless functions. We have since updated the repo and this guide is using the newer ESM supported syntax. To convert over to ESM, add a to the file and switch the to . If you have any imports using the syntax, they will also need to be converted to syntax.\n\nWe also need to update the file to tell Netlify to use for the serverless functions when they are deployed. Add the setting under\n\nNow that we have the file created, we can install a Node fetch library. In the terminal, run the command . Once it is completed, you will see a new property with the library in the file and a new file created automatically.\n\nYour version will probably look different than mine. If you run into any issues, try removing with the command and then install to install the save version.\n\nHead back to the file where we need to import and use the library we just installed. We’ll need to use the syntax, since version 3 and greater of the library uses ESM syntax. Add this line to the beginning of the file.\n\nDon’t forget, you also have to update the file with a property if you didn’t already to tell it to use ESM as well.\n\nNow if you start the server again with and navigate to in the browser, you can see the function run successfully.\n\nEarlier we setup and linked a site to Netlify with the Netlify CLI. Any time we make a push to the git repository that is linked to the Netlify site, a deploy will automatically trigger. Let’s go ahead and run the commands to push our code and trigger a deploy.\n• Shut down your server, if it isn’t already, with .\n• Add all of the files with the command, I have 7 changes to commit.\n• Commit the files with a message about what was changed.\n• Push the changes up to your git provider with or .\n\nThat push will have set off a deployment on Netlify. You can run to open the Netlify dashboard linked to your site. Once there, you can click directly on the url to open the site or click on the Deploys tab to see the last deployment log.\n\nTo see the serverless functions we created, click on the Functions tab.\n\nYou should then see the 2 functions listed by the name of the files.\n\nYou can further click into each function to see the times and logs from when they were ran.\n\nAny serverless function can do stuff to the data before it returns to the frontend. It can be customized in whatever way you need it and only return the things you want to use. In our example the is returning all of the data about every Pokémon and wasting space on information we probably don’t need. Back in the file in your code editor, customize the object being returned in the to limit it to only the .\n\nThis will limit what is returned to just a list of the Pokémon without some of the extra data.\n\nBack in the file, we’ll add another button and update our current one to grab 2 different types of data. Update the button with the id to the id . Then add a new button with an id of .\n\nWe’ll also need to update the variables and functions in the script tag. Replace the line with the new variables that grab the new ids.\n\nNext, we have to update the event listener functions to grab the different data types. First, update the name on the current event listener to be . Now we can edit the data coming back by using the native fetch API, which takes an options object as a second parameter, to pass a method and send the custom data back to the serverless function. Here we want to specify the kanto region for the Pokémon API.\n\nWe also need an event listener function for the “Fetch Hoenn Pokedex” button. We’ll do the same thing, but switch out the region for .\n\nAll serverless functions accept two parameters, and . The object includes information about the request and the parameter includes information about the context that the function was called in. We can use the object to grab the custom headers we are sending along with the requests we added to our code. In the file, add the two parameters to the handler function and log the event and context with I like to wrap the variables I am logging in an object, , to see the name when it comes through.\n\nSave the file and run , click on one of the Fetch Kanto Pokedex button and in the terminal you will see a lot of data coming back. The important part here is the , which you will see is the region of the Pokémon that we sent through the method.\n\nWe are going to use this information by creating a variable to hold the parsed and then update the url that is fetched to dynamically update depending on the region sent.\n\nNow if you refresh the page and click the two Pokedex buttons, you will see two separate sets of data based on the region specified. You can add, commit, and push your code to git to kick off a new deploy of the site.\n\nGreat job! You have experienced how serverless functions can give developers superpowers to build and customize functionality in their applications. This allows you to solve business needs with a wider range of tools and techniques without needing to manage any infrastructure. Now there’s a whole realm of possibilities for you to explore with serverless functions. To learn more about how you can get the most out of serverless functions with Netlify be sure to check out the official docs where you can learn more about other solutions, such as background functions, which allow you to execute longer running scripts, using serverless techniques. I can’t wait to see what you build with Netlify functions. Remember, if your experience is different from anything written here or something didn’t work as expected, please let us know about it here and we will help you or answer any questions you have."
    },
    {
        "link": "https://daily.dev/blog/serverless-functions-netlify-a-beginners-guide",
        "document": "Starting with Serverless Functions on Netlify can revolutionize the way you build and deploy web applications, making it simpler, more cost-effective, and scalable. Here’s what you need to know in a nutshell:\n• Serverless functions are small, event-driven pieces of code that run without a dedicated server, saving you money and scaling automatically.\n• Netlify provides an easy-to-use platform for deploying these functions, especially for Node.js projects.\n• Getting started involves installing Node.js, the Netlify CLI, and possibly Git for version control.\n• Deployment is straightforward with Netlify, automating many tasks and providing tools for local testing.\n• Benefits include cost savings, automatic scaling, enhanced security, and the ability to focus on coding rather than infrastructure.\n• Functions can be used for a wide range of tasks, such as processing data, handling forms, or integrating with other services.\n\nThis guide covers everything from the basics of serverless functions and why Netlify is a great platform for them, to setting up your project and writing your first function. Whether you’re a beginner or looking to expand your skills, this guide offers a comprehensive overview to get you started with serverless functions on Netlify.\n\nServerless functions are like tiny programs that run only when they need to, based on certain triggers, like when someone visits your website. Here's what makes them special:\n• They wait for a signal - These functions start working when something specific happens, like when a file is uploaded or someone fills out a form on your site. They're not running all the time, just when needed.\n• Short-lived - They do their job quickly and don't hold onto any data. If they need information, they have to get it from somewhere else each time they run.\n• They can handle the rush - If your website suddenly gets a lot of visitors, serverless functions can scale up automatically to keep everything running smoothly.\n• You pay as you go - Costs are based on how much the functions run. If they're not being used, you're not paying for them. This can save you money compared to paying for a server all the time.\n• Quick to update - You don't need to set up or manage servers, so you can focus on improving your code. Changes can be made fast and easily.\n• Choose your language - You can write them in languages like JavaScript, Python, or others. This gives you the flexibility to use what you know best.\n\nServerless functions are great for doing things like processing data, working with files, connecting to other services, making your website interactive, automating tasks, or cleaning up data regularly.\n\nWith Netlify, these functions are super handy for adding features to websites without needing a separate server. You could use them for stuff like handling forms, making calls to other services, managing who gets to see what, and more.\n\nWhy Use Serverless Functions on Netlify?\n\nUsing Netlify for serverless functions makes things a lot easier. Here's why it's a good choice:\n• Netlify can automatically handle more visitors by adding more power as needed. This means your site stays smooth without you having to do anything extra.\n• Your code runs in its own safe space, and Netlify looks after security stuff like fighting off hackers and keeping your site secure.\n\nYou Can See How Things Are Going\n• Netlify shows you how your functions are doing right now, so you can quickly fix any issues.\n• Spend more time writing code and less on setting up servers. With Netlify Dev, you can easily work on your functions on your own computer.\n\nGreat for Websites with Static and Dynamic Parts\n• It's perfect for adding features like forms to websites that don't change much, making them more interactive.\n• When you're ready, just push your code, and Netlify takes care of the rest, like testing and making it live.\n• Netlify adjusts to your needs, whether you're getting a little or a lot of traffic. And you only pay for what you use.\n\nIn short, Netlify makes working with serverless functions simpler. It takes care of the heavy lifting so you can focus on creating.\n\nBefore you dive into using Netlify functions, there are a couple of things you need to set up first:\n\nNetlify functions run on Node.js. This means you need Node.js installed on your computer. You can get it from the official website.\n\nGo for the Long Term Support (LTS) version because it's more stable for ongoing projects.\n\nThe Netlify CLI is a tool that lets you test and deploy your functions right from your command line.\n\nTo install it, open your terminal and type:\n\nAfter installing, connect it to your Netlify account with:\n\nThis step links the tool to your account.\n\nUsing Git isn't a must, but it's super helpful. It lets you keep track of changes and easily update your project. If you don't have Git, you can grab it here.\n\nWith Node.js and the Netlify CLI ready, you're all set to start playing with Netlify functions on your local machine. And if you decide to use Git, it'll make updating your project a breeze.\n\nSetting up a new project with Netlify CLI is straightforward. It involves linking your project to a GitHub repository for easy updates and creating a configuration file.\n\nFirst, open your terminal, go to your project folder, and type:\n\nThis starts a simple step-by-step process that helps you:\n• Set up automatic updates every time you change your code\n• Give you a website link to see your project live\n\nJust follow the on-screen instructions to complete each step.\n\nLinking your project to GitHub means every time you update your code on GitHub, Netlify will automatically update your website. This is known as continuous deployment.\n\nTo do this:\n• During the process, choose this new repo\n• You might need to connect your Netlify and GitHub accounts\n\nNow, whenever you push updates to GitHub, your Netlify site will automatically get updated too.\n\nDuring setup, a file named netlify.toml will be created in your project. This file tells Netlify how to handle your project, including:\n• Build - Commands to build your site, where to find the built site\n• Functions - Where your serverless functions are stored\n• Headers - Setting rules for your site, like security policies\n\nHere's what the basic setup looks like:\n\nYou can change this file as needed to fit your project.\n\nBy following these steps, you've connected your project to both GitHub and Netlify, making it easier to manage updates and deploy your site.\n\nLet's get started with writing a basic serverless function on Netlify. Here's a step-by-step guide to creating a simple \"Hello World\" function.\n\nFirst, you need a place for your serverless functions to live. Create a folder named at the root level of your Netlify project.\n\nNext, create a new file called inside the folder. This file will contain your serverless function code. Here's a simple example that sends back a \"Hello World\" message:\n\nThis code means that whenever the function is called, it will respond with a message saying \"Hello World\".\n\nTo see if your function works, use the command in your project's main folder. This starts a local server.\n\nYou can find your function at .\n\nTry going to this link in your web browser or use a tool like Postman to send a request. If everything's set up right, you'll see the \"Hello World\" message.\n\nAnd that's it! You've just created and tested a simple serverless function on Netlify. To make it live, just push your updates to GitHub, and Netlify's Continuous Deployment will do the rest.\n\nOnce you make changes and update your code on GitHub, Netlify automatically takes care of getting your serverless functions out there and managing them, no matter how big or small the demand gets.\n\nPush your code updates, and let Netlify do the heavy lifting.\n• After you update your code on GitHub, Netlify automatically gets your functions ready and puts them online.\n• You don't have to worry about setting up servers or dealing with complex setups - Netlify handles all that.\n• This lets you focus more on coding and less on technical setup.\n\nNetlify lets you see logs for your functions, so you can understand what's happening and fix issues fast.\n• Access logs help you see when your functions are called and what's happening with them.\n• Error logs are useful for spotting and fixing problems in your functions.\n• You can check these logs on Netlify's website or by using the Netlify CLI.\n• This is really handy for when you're trying out new functions or need to figure out why something didn't work as expected.\n\nNetlify gives you detailed info on how your functions are doing, like how often they're used and how well they perform.\n• You get to see how many times your functions are run, how long they take, and how much memory they use.\n• This information helps you understand which functions are used a lot and which ones might need a bit of tweaking for better performance.\n• If a function uses too much memory or takes too long, Netlify lets you know.\n• This helps you spot and fix any slow spots in your functions, making sure everything runs smoothly.\n\nUsing Netlify for serverless functions makes things super easy. It takes care of all the technical stuff, so you can just focus on writing your code.\n\nHere's what you should remember:\n• Serverless functions are little pieces of code that run only when they're needed. This is great because you don't have to pay for a server that's running all the time.\n• Netlify can handle more visitors without you having to do anything. You can write functions in languages like JavaScript.\n• The Netlify CLI tool lets you try out your functions on your own computer before you put them online. When your code is connected to GitHub, Netlify updates your site automatically whenever you make changes.\n• You can use functions for lots of things, like when someone fills out a form on your site or uploads a file. They help make your site do more without needing a full server.\n• Netlify also shows you how your functions are doing with logs and metrics. This means you can quickly fix any problems.\n\nIn short, Netlify makes it a lot easier to use serverless functions. You don't need to know about servers or infrastructure. The platform grows with your needs and helps keep costs down.\n\nIf you want to dive deeper into how Netlify can help you with serverless functions, have a look at these resources:\n\nHow do I use Netlify serverless functions?\n\nTo start using serverless functions with Netlify, simply make a JavaScript file in your folder. Name it and write your code. Netlify looks into this folder every time you build your project, setting up each file as its own function.\n\nWhat is the limit of Netlify serverless?\n• 10 second execution limit for quick functions, including scheduled ones\n\nWhat is the difference between Netlify edge and serverless?\n\nEdge functions run closer to your users, which can make them faster. Serverless functions run on Netlify's own servers and might be easier to work with because you have more control over the code.\n\nHow do you create a serverless function?\n• Write your function in a file (like )\n• Mention this function in your under\n• Use to try it out on your computer\n• Use to put it online\n\nCheck out Netlify's tutorial for more step-by-step guidance.\n• How to Become a Full Stack Software Developer: A Primer"
    },
    {
        "link": "https://stackoverflow.com/questions/75709892/how-to-create-a-dynamic-route-with-netlifys-serverless-function",
        "document": "I'm using Netlify's serverless function with Mongo to create routes that a react app can access as rest api the endpoint.\n\nFollowing mongo's documentation, https://www.mongodb.com/developer/languages/javascript/developing-web-application-netlify-serverless-functions-mongodb/, to create a route we can use netlify's CLI.\n\nFor example the command:\n\nand to access the route it would be:\n\nThis is all well and good when the route is static. But how do I deal with a dynamic route?\n\nFor example, I want to have a route that takes a query parameter, movie_name:\n\nDepending on the the response would be different. How do I achieve that?"
    },
    {
        "link": "https://earthly.dev/blog/netlify-cloud-functions",
        "document": "The article provides a guide to Netlify Functions, focusing on optimization. Earthly streamlines the build process for Netlify Functions or whatever you are building. Learn more about Earthly.\n\nWhen building backend applications, we often have to add features that are not supported by the current stack or would slow down our applications. A possible workaround is to use cloud functions that help abstract away some of these tasks.\n\nThis tutorial will cover how to create Netlify Functions, then explain an example use case, and best practices for using Netlify Functions. We will also take a look at how Netlify Functions compare to AWS Lambda and why you might prefer one over the other.\n\nCloud functions are pieces of code that run in the cloud and are triggered by an event. They are written in a serverless language, like JavaScript, and are hosted and managed by a cloud provider, such as Netlify or AWS.\n\nCloud functions are used to respond to webhooks, process form submissions, and respond to API requests. Also used for authentication, authorization, and other security tasks. Image or video processing and manipulation, text generation, and more. Cloud functions provide an efficient way to offload processes from a main server, as they are triggered by an HTTP request and are managed by the cloud provider\n\nNetlify functions are a serverless, cloud-based function as a service (FaaS) platform; they are to help developers build and deploy their applications quickly and easily.\n\nNetlify functions are serverless functions built on top of AWS Lambda, designed to enable developers to quickly and easily deploy and manage code snippets. Functions can be written in JavaScript, Go, or TypeScript, and are triggered by an HTTP request. As mentioned, Netlify functions provide an efficient way to create powerful applications, offloading time-consuming tasks such as webhooks, form submissions, API requests, authentication, authorization, and more to the cloud.\n\nNetlify cloud functions can be used for a variety of purposes, including creating serverless backends for applications, providing custom APIs for third-party apps, or even handling real-time data processing and analysis.\n\nIn this article, we’ll take a look at the different types of Netlify functions, including background functions, trigger functions, and scheduled functions, and how they can be used to enhance your web development workflows.\n\nNetlify’s Background Functions provide a serverless function option that can take up to 15 minutes to complete and does not need to be finished before a visitor can move on to the next step on your website. This type of function may be more suitable than synchronous functions for tasks such as batch processing, web scraping, and slower API workflow execution.\n\nAt the time of writing—this is still in beta—but I’ve been using it for months, and it is great!\n\nTrigger functions are serverless functions that are triggered when a specific event occurs, such as when a webhook is sent or when a form submission is received. They are designed to respond to events and perform certain tasks, such as sending an email or updating a database, without the need for a traditional server.\n\nTrigger functions are used to quickly and easily add functionality to your web applications without the need for a lot of setup or configuration.\n\nNetlify’s Trigger Functions offer an efficient way to respond to HTTP requests, process form submissions, and respond to webhooks. They are easy to set up and configure, and can be written in JavaScript, Go, or TypeScript. Trigger functions are triggered by an HTTP request and can be used to quickly and easily add powerful functionality to your web applications.\n\nNetlify functions’ scheduled functions feature allows you to run functions on a regular and consistent basis, similar to a cron job. These functions can be used for a variety of tasks, though some are more suitable than others.\n\nHow Does Netlify Organize Its Functions?\n\nNetlify organizes its cloud functions and files using a hierarchical structure. At the top level, there is a root directory that contains all the files and folders associated with the project. Each folder contains files and subfolders related to a specific function or feature.\n\nLet’s say you are building a website that allows users to upload pictures. You want to create a cloud function that will process the pictures that are uploaded by the users. The first step would be to create a folder named “functions” in your project directory. Inside this folder, you’ll create a file called which contains the code for the cloud function. The name of this file would be included in the HTTP request to access the function.\n\nFor example, if you want to access the cloud function to process the pictures uploaded by the user, the HTTP request would look like this, . This would allow your cloud function to be accessed and used to process the pictures uploaded by the user.\n\nTo sum up: A Netlify function is simply a file that is triggered by an HTTP request. Let’s say you want to build a simple contact form for your website that stores subscribers to a firebase database. To read more on firebase and documentation.\n\nYou can create a Netlify Function that is triggered by an HTTP request and sends an email to firebase when the form is submitted. This lets you abstract the firebase credentials from being loaded on the Frontend and prevents malicious people from getting that info.\n\nThe code examples in the article can be found in this GitHub repo.\n\nCreating Netlify Functions is a fairly straightforward process. The first step is to create a Netlify Function project.\n\nRun the following command in the project directory:\n\nIf you don’t have Netlify set up, you can install it using using the following command:\n\nThis will create the necessary files and folder structure for your Netlify Functions project. You will then need to create a file to define the configuration for your functions. Here you will specify the name of your function, the runtime, the entry point, and any environment variables that your function needs.\n\nHere is a simple example:\n\nThe toml file can be broken down into sections:\n\nThis code above tells Netlify to look for functions in the “netlify/functions/” directory. This allows Netlify to deploy and run serverless functions from that directory.\n\nFor example, you might need to specify the firebase credentials for your service so that your function can store data in firebase. This can be done in the .\n\nOnce you have your file set up, you can create your function.\n\nIn this step, we are creating a configuration file for our Firebase project. This file will contain the necessary credentials to authenticate the Firebase API, and will also export an object which we can use to save data to Firebase.\n\nThe code starts by requiring the Firebase package, which will provide the necessary methods to interact with the Firebase API. We then create an object called , which contains the credentials necessary to authenticate the API. These credentials are typically stored as environment variables.\n\nOnce the configuration object is set up, we call from the Firebase package, and pass in the configuration object. This will create an instance of the Firebase app and store it in a variable.\n\nFinally, we export the Firebase app so that it can be used elsewhere in our application. This will allow us to access the Firebase API and save data to our database.\n\nNext, you’ll need to create your function that would be able to perform our action. To do that create a JavaScript file and export a function called .\n\nTo do this, create a file called in the folder.\n\nThe function is very important, this is the function that is called by Netlify, very similar to the function in python.\n\nThe code snippet above exports a function called which is an asynchronous function that takes in two parameters: and . The attempts to extract an email address. This email address is then used to create a FireBase document with the email address and the current date and save it to the FireBase database. Finally, the function returns a status code of 200 and a body of to signify that the email has been sent.\n\nIf there is an error in the code, or in the request, the function will catch the error and return an error response with a status code of 500 and an error message. This error message will help to identify and debug any issues with the code or the request.\n\nOnce your function is written, you can deploy it to Netlify and it will be available to be triggered by an HTTP request.\n\nRunning in our terminal runs our function; we can access it using a post request at http://localhost:8888/.netlify/functions/subscriber:\n\nHere are some other applications where you can try using Netlify Functions:\n\nAWS Lambda and Netlify Functions are both serverless compute services that run code in response to events and automatically manage the underlying compute resources, both are designed to be easy to use, however, they have some key differences.\n\nAWS Lambda is a fully managed service that takes care of all the operational and administrative complexities of deploying and managing your code. It is highly scalable and can be used to build applications of any size.\n\nNetlify Functions are also serverless functions, but they are designed to be used in conjunction with Netlify’s hosting and deployment services. They are best for small-scale applications and are not as scalable as AWS Lambda. Additionally, Netlify functions require minimal setup and configuration.\n\nWith Netlify, you can deploy your functions with a single command, while with AWS Lambda, you need to set up an entire serverless infrastructure. Additionally, Netlify Cloud Functions are more cost-effective than AWS Lambda, as they are billed on a per-request basis, rather than a per-hour basis.\n\nNetlify Functions offer a convenient way to include serverless functionality in your web projects, simplifying the process of creating small APIs or dynamic site elements. Now that you’re familiar with these Functions, delve deeper into Netlify’s documentation and tutorials to enhance your usage.\n\nIf you’re looking to streamline your build processes for serverless apps, you might want to give Earthly a shot. It’s an excellent tool that can help optimize your workflow."
    }
]