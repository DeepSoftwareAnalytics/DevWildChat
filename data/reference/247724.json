[
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/Explosion",
        "document": "An Explosion applies force to BaseParts within the explosion's BlastRadius. This force breaks JointInstances and WeldConstraints between parts and kills Humanoid characters not protected by a ForceField. Constraints will not be broken by an explosion. If an Explosion is parented anywhere in the data model while the experience is running, it immediately sets off and, within a few seconds, it becomes unparented. It is not destroyed with Instance:Destroy() in this case, so connections do not get disconnected and the parent is not locked. As with all instances, keeping a strong reference an Explosion will prevent it from being garbage collected. Note that an Explosion must be a descendant of Workspace for the explosion visuals to play and the physical/damaging effects to have an impact. Humanoids are killed by explosions, as the explosion breaks the character Model neck joint. Parenting a ForceField to a model will protect all of its children from the explosion kill effect. If you do not want joints between BaseParts to be broken, or you want to implement your own formula for damaging Humanoids, it's recommended that you set DestroyJointRadiusPercent to 0 and use the Hit event to handle the result of the explosion. Explosions can also be configured to damage Terrain, creating craters, as configured through the ExplosionType property. Note that the effect of an explosion is not disrupted by obstacles, meaning that parts/terrain shielded behind other parts/terrain will still be affected.\n\nUsed to determine the amount of force applied to BaseParts caught in the Explosion.BlastRadius. Currently this level of force applied does not vary based on distance from Explosion.Position. Unanchored BaseParts will accelerate equally away from the origin regardless of distance provided they are within the blast radius. The blast pressure determines the acceleration of parts due to an explosion. It does not determine the degree to which joints are broken. When Explosion.DestroyJointRadiusPercent is equal to 1 all joints between parts in the Explosion.BlastRadius will be destroyed provided BlastPressure is greater than 0. The BlastPressure also does not determine the amount of damage given to Terrain. Provided BlastPressure is greater than 0 and Explosion.ExplosionType isn't set to Enum.ExplosionType.NoCraters the size of the crater created is determined exclusively by the Explosion.BlastRadius. Setting BlastPressure to 0 eliminates the effect of the explosion and is useful when developers want to program their own custom behavior for explosions using the Explosion.Hit event. -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed. This property determines the radius of the Explosion, in studs. This property accepts any value between 0 and 100. This radius determines the area of effect of the Explosion, not the size of the Explosion's visuals. The size of the Explosion's visual effect is the same regardless of BlastRadius (even if BlastRadius is 0). BaseParts within the BlastRadius will be affected by the explosion. Meaning, if Explosion.BlastPressure is greater than 0, force will be applied to parts. The degree to which joints are broken within the BlastRadius depends on Explosion.DestroyJointRadiusPercent. Explosion.Hit will fire for any every BasePart within the radius. BaseParts are considered within Explosion.BlastRadius even if they are only partially in range. Used to set the proportion of the Explosion.BlastRadius, between 0 and 1, within which all joints will be destroyed. Anything outside of this range will only have the Explosion force applied to it. For example, if Explosion.BlastRadius is set to 100 and DestroyJointRadiusPercent is set to 0.5, any joints within a radius of 50 studs would be broken. Any joints between the ranges of 50 and 100 studs wouldn't be destroyed, but the Explosion force would still be applied to the BaseParts. This property allows developers to make Explosions 'non-lethal' to Humanoids by setting DestroyJointRadiusPercent to 0. This means the neck joint will not be broken when characters come into contact with the Explosion. -- check the part is in range to break joints -- make sure the part does not belong to a character -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed. This property determines how the Explosion will interact with Terrain. It is an Enum.ExplosionType value and can be set to one of three options.\n• None - Redundant, behaves the same as Craters If ExplosionType is set to create craters in Terrain, the radius of the crater will be roughly equal to the Explosion.BlastRadius. Craters are created in all Terrain materials other than water. The size of the crater is not influenced by the material, although some materials create rougher edges than others. This property is the position of the center of the Explosion. It is defined in world-space and not influenced by the Explosion parent. BaseParts will be influenced by the Explosion if they are within Explosion.BlastRadius studs of the explosion's position. The effect of an explosion is instantaneous. This means that although the position of an explosion can be changed after it has been set it cannot affect two different areas. Once an explosion has been 'detonated', shortly after parenting it to a descendant of the Workspace, it will not do so again. In some cases the visual effect of the explosion will move but it will have no effect. For this reason a new Explosion should be created if the developer wants an explosion to appear at a different position. A value between 0 and 1 that controls the speed of the particle effect. At 1 it runs at normal speed, at 0.5 it runs at half speed, and at 0 it freezes time. This property determines whether or not the visual effect of an Explosion is shown or not. When Visible is set to false, the explosion will still affect BaseParts in its Explosion.BlastRadius, the only difference is it will not be seen. One use for this property would be for a developer to make their own custom explosion effects using a ParticleEmitter, while retaining the default Explosion functionality.\n\nFires when the Explosion hits a BasePart within its Explosion.BlastRadius. Returns the part hit along with the distance of the part from Explosion.Position. Note that the effect of an Explosion is not disrupted by obstacles, this means parts shielded behind other parts will still be hit, even if the BasePart they are shielded behind is anchored. This event will also fire when Explosion.BlastPressure is equal to zero. This means developers can program their own custom behavior for explosions by eliminating the explosion's influence on BaseParts and Terrain. Note that this event will fire for every BasePart hit. This means it can fire multiple times for the same player character (as the character Model is made up of multiple parts). For this reason when dealing custom damage using the Explosion.Hit event it's recommended to implement a check to see if the character has already been hit by the Explosion. The BasePart hit by the Explosion. The distance of the hit from Explosion.Position. \n\n -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed."
    },
    {
        "link": "https://devforum.roblox.com/t/destroy-and-explode-part/1234842",
        "document": "Yeah, you redefined TouchPad as boolean and it most likely is just overwriting it. Just change the name of the boolean so you have two different variables.\n\nAlso, are you trying to destroy the workspace or just something in it?"
    },
    {
        "link": "https://devforum.roblox.com/t/terrain-destruction/422654",
        "document": "So my game relies on terrain for mostly everything. we try to keep buildings to a minimum which really helps our outdoors naturey effect.\n\nNow, I know that explosions destroy terrain in its radius (destroyjointradius). is there a way to do something similar but without explosions? to in a sense… mine terrain."
    },
    {
        "link": "https://devforum.roblox.com/t/full-beginners-guide-on-scripting-animefighting-vfxvisual-effects-part-1/1610853",
        "document": "Welcome to the Beginner’s Guide on scripting VFX (Visual Effects) [Part 1]\n\nNote: This is my first ever tutorial, if I made a mistake or I did not explain some parts, pls let me know\n\nWhen I started scripting VFX on Roblox, I couldn’t find any useful tutorials (neither on the Devforum nor Youtube). However, after learning scripting for a few days I was able to start scripting some VFX, which were, of course, incredibly imperfect. After 2 months of scripting I was good enough to start getting commissioned in scripting VFX for high prices, and for rather big in-development games.\n\nHere is a fraction of my work:\n\nThis is a beginner’s guide, and throughout the tutorial you will learn the basic knowledge of effectively scripting visual effects, as well as a basic fireball which this tutorial will follow. Do note this will cover:\n• VFX Spawning (Server-sided (Easy, but not recommended), Client-Replication (Not very beginner-friendly, but I highly recommend this; reasons are inside the article))\n\nImportant: You must have some experience in scripting beforehand, or some parts of this guide might confuse you.\n\nThere are two main ways of detecting inputs: For this “Beginner’s Guide” I will be using UserInputService, as it is easier to understand.\n\n Let us first get the service itself.\n\n Now that we got the service, let’s create a function to help us with firing servers, and what not later.\n\n Now let’s use the InputBegan event to detect inputs from the player, and connect it to the DetectInput() function we just created.\n\n As of now, it takes in every input - and we don’t want that. What we do want, is to detect a specific input, so we’re going to check the input that the InputBegan has returned.\n\n What we have done here is to take in the Input and GameProcessedEvent which were returned by the InputBegan event. GameProcessedEvent is true if the inputs were observed by the game (e.g typing in a textbox, typing in chat), so we will return the function if this is true. Next we’re checking if the Input is the keycode which we specifically want (in our case this is Q), if it matches the script will print (You can visit here for more information about these two parameters). Congrats, you now have a working input detection! Let’s move onto step 2\n\nNow let’s create a remote event to help us communicate between the client and server.\n\n Create a variable for the event, and let’s fire the server from the local script.\n\n The code should now look like this:\n\n Let’s now create a function on a server script, and connect it to an OnServerEvent event which listens to the FireServer() called from a local script.\n\n Now if you test it, it should be working like this:\n\n Congratulations! You now have a way to communicate between the client and the server\n\nThere are generally two main ways of creating debounces: The two ways mentioned above are both client-sided debounces which are easy to understand for beginners but they are easily exploitable, so unless you’re just practicing I highly recommend you reading the article I made on how to create server-sided debounce below. This comes incredibly handy when coming into contact with exploiters. Exploiters can do anything a local script can do, which includes firing servers and with client-sided debounces, they are granted the ability to spam FireServer(), which nobody wants. In this case, there is a simple solution; using server-sided debounces. Due to the simplicity of the first method, I will be using the bool debounce in this guide. First we’ll need to construct a table in the server script which acts as a debounce (Since there can be multiple players in a server, we cannot use a single variable - like how we do it in a local script).\n\n Our next step is to get the player from the OnServerEvent, so add a player parameter into the ServerReceived function we made earlier.\n\n We will now need a way to check if they are on cooldown or not. For this we can add an if statement to see if the player is on cooldown by simply adding their name into the table. If they are in the table, they’re currently in cooldown, else they’re not. The code should now be somewhat similar to this:\n\n Congratulations once again! You now have an extremely reliable debounce, which exploiters in no way can abuse!\n\nWe’re getting closer to the end! In this step you will learn how to handle the damage. First of all let’s start by creating a hitbox, which will not only help us visually, but also help in detecting targets. I have created a simple hitbox for the fireball:\n\n You can put it wherever the server script can access, and as for my liking I put it right under the server script with the name “Hitbox”. Let’s start by creating a variable for the hitbox. For this beginner’s tutorial, we’ll be using the Touched event to detect targets. Let’s get onto the main detection!\n\n Where the server is received, we’ll first get the player’s character, then we’ll clone this hitbox and launch it forwards (based on player’s character), and add a Touched event so it listens to parts that get touched. The code should look like this:\n\n And currently, it spawns in front of the player’s character!\n\n To launch it forwards, we’ll be using TweenService for the sole purpose of being beginner-friendly. To launch it forward relative to the character’s position we’ll use the HumanoidRootPart’s cframe and multiply it with a negative Z vector. However the Touched event will not detect movements made by cframes, so we’ll turn the cframes into position by simply doing .Position; which should look something like this:\n\n Remember to delete the hitbox once the tween is done! (In my case 1 second) Now that it’s working it’s time to connect a touched event to the hitbox so it can listen to detections.\n\n \n\n We can see that it’s working fine, however let’s just add a little filtering so it will never touch the character who casted the fireball by using IsDescendantOf().\n\n After this, let’s make it detect only viable humanoid targets and deal damage. For this we will use :FindFirstChild(). First we’ll check if Hit.Parent(Hit is a basepart and is likely to be a body part, so Hit.Parent is referring the the enemy character) contains a humanoid. If there is then take damage, else do nothing.\n\n Great we’re once again closer to the main step! However after testing for a few times, you might notice that the actual damage dealt doesn’t equate to what you really wanted to deal! \n\n In this case it’s being dealt 25 damage(we added 5 in the damage parameter!). You might or might not be wondering - why is this happening? It’s simply because it detected several times. This is an incredibly easy fix; by the usage of values and debounces. There are several ways to approach this but I will be using values so beginners can understand. We’ll need to check if a value exists in the humanoid or not, to check it we’ll use FindFirstChild and check the name of the debounce (in my case I made it use the player’s name and concatenated with a “special key”; FireballDebounce) - the code should be similar to this:\n\n For it to actually work, let’s create a value under take damage to act as our debounce, which of course we’ll need to concatenate the player’s name with FireballDebounce. This is to prevent different players getting debounced by just 1 debounce. Important Note: If you’re making different attacks you’ll want to change the name to different names or different moves will detect different debounces\n\n And finally we’ll delete it after 1-4 seconds so the debounce actually gets reset. I prefer using Debris service but you can delete it however you like. If you made it this far and all’s working fine, Congratulations yet again!\n\n The next step is the final as well as the most important step! Make sure to understand it thoroughly. If you don’t that’s fine! - feel free to ask me in the comments\n\nAs beginners, you (have) probably spawned VFX server-sided(This means spawning the vfx on a server script, which increases the server load thus increases ping tremendously)! As someone who’s been mainly doing visual effects on roblox, it is not an exaggeration to say that server-sided effects are a sin ( )! However if client-replication is too hard for you it is understandable. I, myself, made server-sided vfx for more than a month until I learned of this client-replication technique. I have created this artistically beautiful fireball to serve as our main effect.\n\n You can put it anywhere the server script can access so I’m putting it directly under the script. Let’s give it a variable:\n\n Now let’s clone it right where we clone the hitbox so they are aligned.\n\n Let’s also make it do whatever the hitbox does - of course, aside the Touched event.\n\n \n\n Scripting Practice Place - Roblox Studio (gyazo.com) Great! It’s in sync with the hitbox as of now. To spice some things up you could:\n• Make it spawn elsewhere (e.g fireballs raining from the sky, fireballs shooting from your eyes)\n• Add particle(s) or trail(s) to the fireball Congrats! You have finished the part 1 of the beginner’s guide on scripting visual effects by SushiInASuit/SushiScripter. Client-Replication VFX spawning (hard to understand for beginners, but highly recommended) Firstly, you’ll have to understand how the idea of client-replication works. A player will fire the remote to the server:\n\n The server receives this signal, and the positions of where to spawn the vfx are defined here, which are then fired to all clients with that information:\n\n Because the position sent is the same to all clients, the vfx will be positioned at the same place for everyone (reducing server load which results in faster vfx loading and doesn’t load up the server anymore). Because we’ll need them to be in sync, the cframes have to be the same so instead of this:\n\n \n\n we’ll need to do this:\n\n We’ll also need to replace the tween goal, which will be changed from this:\n\n \n\n to this:\n\n Now that we have replaced these, it’s time for the star of the show - FireAllClients().\n\n This is the leading function for client-replication, so let’s get started! Let’s call this function right under the creation of the hitbox, so it gets synced as much as possible. We’ll also add CF and Pos so the client will know where to spawn and where to tween.\n\n Now that that’s done let’s create a function to help us spawn the effects.\n\n Add the parameters CF and Pos which were sent by the server - these are incredibly important.\n\n Put it wherever the client can access it (I like putting it in ReplicatedStorage), and give it a variable.\n\n Now we’ll clone it and set cframe to the cframe sent by the server so it aligns with the hitbox (Don’t forget to delete it afterwards!).\n\n And let’s use the Position sent by the server to tween the fireball in sync with the hitbox.\n\n And…drumrolls\n\n You should now be able to acheive something like this:\n\n If u reached this far then congratulations! You may or may not have scripted your very first client-replication vfx which will play a huge role later onwards, especially if you’re going to focus on making visual effects.You have finished the part 1 of the beginner’s guide on scripting visual effects by SushiScripter/SushiInASuit.\n\nImportant: This is part 1 of the beginner’s guide, it only covers the basic structure of scripting vfx. Part 2 will feature a more complicated structure of visual effects, ranging from raycasting, how trigonometry can be used, useful math functions and tons more\n\nFeel free to ask me any questions in the comments!"
    },
    {
        "link": "https://devforum.roblox.com/t/how-to-i-make-a-part-explode/1582561",
        "document": "function Explode(hit)\n\n local hum = hit.Parent:FindFirstChild(“Humanoid”)\n\n if hum and debounce then\n\n debounce = false\n\n for ExplodeWait = 1, 6 do\n\n wait(1)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(1)\n\n if ExplodeWait <=2 then\n\n part.BrickColor = BrickColor.new(“Black”)\n\n wait(0.7)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(0.7)\n\n if ExplodeWait <=4 then\n\n part.BrickColor = BrickColor.new(“Black”)\n\n wait(0.5)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(0.5)\n\n if ExplodeWait <=6 then\n\n part.BrickColor = BrickColor.new(“Black”)\n\n wait(0.3)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(0.3)\n\n if ExplodeWait <=8 then\n\n part.BrickColor = BrickColor.new(“Black”)\n\n wait(0.2)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(0.2)\n\n if ExplodeWait <=10 then\n\n part.BrickColor = BrickColor.new(“Black”)\n\n wait(0.1)\n\n part.BrickColor = BrickColor.new(“Really red”)\n\n wait(0.1)\n\n Explode()\n\n end\n\n end\n\nEverything in the code works fine except for the “Explode()”\n\nIm pretty sure there’s a built in function for Explode() but thats either not the case or im not using it correctly."
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/Explosion",
        "document": "An Explosion applies force to BaseParts within the explosion's BlastRadius. This force breaks JointInstances and WeldConstraints between parts and kills Humanoid characters not protected by a ForceField. Constraints will not be broken by an explosion. If an Explosion is parented anywhere in the data model while the experience is running, it immediately sets off and, within a few seconds, it becomes unparented. It is not destroyed with Instance:Destroy() in this case, so connections do not get disconnected and the parent is not locked. As with all instances, keeping a strong reference an Explosion will prevent it from being garbage collected. Note that an Explosion must be a descendant of Workspace for the explosion visuals to play and the physical/damaging effects to have an impact. Humanoids are killed by explosions, as the explosion breaks the character Model neck joint. Parenting a ForceField to a model will protect all of its children from the explosion kill effect. If you do not want joints between BaseParts to be broken, or you want to implement your own formula for damaging Humanoids, it's recommended that you set DestroyJointRadiusPercent to 0 and use the Hit event to handle the result of the explosion. Explosions can also be configured to damage Terrain, creating craters, as configured through the ExplosionType property. Note that the effect of an explosion is not disrupted by obstacles, meaning that parts/terrain shielded behind other parts/terrain will still be affected.\n\nUsed to determine the amount of force applied to BaseParts caught in the Explosion.BlastRadius. Currently this level of force applied does not vary based on distance from Explosion.Position. Unanchored BaseParts will accelerate equally away from the origin regardless of distance provided they are within the blast radius. The blast pressure determines the acceleration of parts due to an explosion. It does not determine the degree to which joints are broken. When Explosion.DestroyJointRadiusPercent is equal to 1 all joints between parts in the Explosion.BlastRadius will be destroyed provided BlastPressure is greater than 0. The BlastPressure also does not determine the amount of damage given to Terrain. Provided BlastPressure is greater than 0 and Explosion.ExplosionType isn't set to Enum.ExplosionType.NoCraters the size of the crater created is determined exclusively by the Explosion.BlastRadius. Setting BlastPressure to 0 eliminates the effect of the explosion and is useful when developers want to program their own custom behavior for explosions using the Explosion.Hit event. -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed. This property determines the radius of the Explosion, in studs. This property accepts any value between 0 and 100. This radius determines the area of effect of the Explosion, not the size of the Explosion's visuals. The size of the Explosion's visual effect is the same regardless of BlastRadius (even if BlastRadius is 0). BaseParts within the BlastRadius will be affected by the explosion. Meaning, if Explosion.BlastPressure is greater than 0, force will be applied to parts. The degree to which joints are broken within the BlastRadius depends on Explosion.DestroyJointRadiusPercent. Explosion.Hit will fire for any every BasePart within the radius. BaseParts are considered within Explosion.BlastRadius even if they are only partially in range. Used to set the proportion of the Explosion.BlastRadius, between 0 and 1, within which all joints will be destroyed. Anything outside of this range will only have the Explosion force applied to it. For example, if Explosion.BlastRadius is set to 100 and DestroyJointRadiusPercent is set to 0.5, any joints within a radius of 50 studs would be broken. Any joints between the ranges of 50 and 100 studs wouldn't be destroyed, but the Explosion force would still be applied to the BaseParts. This property allows developers to make Explosions 'non-lethal' to Humanoids by setting DestroyJointRadiusPercent to 0. This means the neck joint will not be broken when characters come into contact with the Explosion. -- check the part is in range to break joints -- make sure the part does not belong to a character -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed. This property determines how the Explosion will interact with Terrain. It is an Enum.ExplosionType value and can be set to one of three options.\n• None - Redundant, behaves the same as Craters If ExplosionType is set to create craters in Terrain, the radius of the crater will be roughly equal to the Explosion.BlastRadius. Craters are created in all Terrain materials other than water. The size of the crater is not influenced by the material, although some materials create rougher edges than others. This property is the position of the center of the Explosion. It is defined in world-space and not influenced by the Explosion parent. BaseParts will be influenced by the Explosion if they are within Explosion.BlastRadius studs of the explosion's position. The effect of an explosion is instantaneous. This means that although the position of an explosion can be changed after it has been set it cannot affect two different areas. Once an explosion has been 'detonated', shortly after parenting it to a descendant of the Workspace, it will not do so again. In some cases the visual effect of the explosion will move but it will have no effect. For this reason a new Explosion should be created if the developer wants an explosion to appear at a different position. A value between 0 and 1 that controls the speed of the particle effect. At 1 it runs at normal speed, at 0.5 it runs at half speed, and at 0 it freezes time. This property determines whether or not the visual effect of an Explosion is shown or not. When Visible is set to false, the explosion will still affect BaseParts in its Explosion.BlastRadius, the only difference is it will not be seen. One use for this property would be for a developer to make their own custom explosion effects using a ParticleEmitter, while retaining the default Explosion functionality.\n\nFires when the Explosion hits a BasePart within its Explosion.BlastRadius. Returns the part hit along with the distance of the part from Explosion.Position. Note that the effect of an Explosion is not disrupted by obstacles, this means parts shielded behind other parts will still be hit, even if the BasePart they are shielded behind is anchored. This event will also fire when Explosion.BlastPressure is equal to zero. This means developers can program their own custom behavior for explosions by eliminating the explosion's influence on BaseParts and Terrain. Note that this event will fire for every BasePart hit. This means it can fire multiple times for the same player character (as the character Model is made up of multiple parts). For this reason when dealing custom damage using the Explosion.Hit event it's recommended to implement a check to see if the character has already been hit by the Explosion. The BasePart hit by the Explosion. The distance of the hit from Explosion.Position. \n\n -- this could be set higher to still apply velocity to parts -- set up a table to track the models hit -- check to see if this model has already been hit -- get the distance as a value between 0 and 1 -- flip the amount, so that lower == closer == more damage -- Roblox removes explosions after a few seconds, but does not destroy them. -- To ensure our .Hit connection gets disconnected, destroy the explosion once it's removed."
    },
    {
        "link": "https://create.roblox.com/docs/scripting/events",
        "document": "Events are occurrences within your experience that you can listen for and respond to. Many Roblox services and objects have built-in events that automatically fire in response to specific actions or changes.\n\nFor example, a player's Character touching a BasePart automatically fires a Touched event. Each time a player joins your experience, the Players.PlayerAdded event fires.\n\nDue to the sheer number of events and client-server architecture, Roblox scripting is often referred to as event-driven. This approach is different from many other game engines, which emphasize running code on a frame-by-frame basis.\n\nYou don't have to listen for events or take any action in response to them, but the events are firing and available nevertheless. When you do want to respond to an event, you connect a function to it.\n\nYou connect a function to an event using Connect() to execute code each time the event fires. Most events pass arguments to their connected functions. For example, the BasePart.Touched event passes the object that touched the part (such as a left hand or car wheel), and the Players.PlayerAdded event passes the Player that joined your experience.\n\nThe following code sample demonstrates how to connect a function named onPartTouched() to the Touched event of a part:\n\nYou can also connect anonymous functions to events when you want to use variables in the parent scope and don't need to use the function elsewhere. For example, this code sample avoids the awkward intermediary function from the similar sample in Services:\n\nThe Connect() method returns an RBXScriptConnection object. If you connect a function to an event, but don't want to call the function the next time an event fires (such as after some condition is met), disconnect it by calling Disconnect() on the RBXScriptConnection object.\n\nThe following code sample shows how to connect and disconnect a function from the Part.Touched event:\n\nIf you only want to connect a function to an event once—that is, only run the function the first time the event fires—use the Once() method as a more convenient alternative to connecting and disconnecting the function.\n\nIf you want a script to yield until a specific event fires, use the Wait() method. This method returns the event's arguments, which you can assign to variables for later use:\n• None Bindable events let you communicate between scripts on the same side of the client-server boundary.\n• None Remote events let you communicate across the client-server boundary."
    },
    {
        "link": "https://create.roblox.com/docs/reference/engine/classes/BasePart/Touched",
        "document": "The Anchored property determines whether the part will be immovable by physics. When enabled, a part will never change position due to gravity, other part collisions, overlapping other parts, or any other physics-related causes. As a result, two anchored parts will never fire the BasePart.Touched event on each other. An anchored part may still be moved by changing its CFrame or Position, and it still may have a nonzero AssemblyLinearVelocity and AssemblyAngularVelocity. Finally, if an unanchored part is joined with an anchored part through an object like a Weld, it too will act anchored. If such a joint breaks, the part may be affected by physics again. See Assemblies for more details. Network ownership cannot be set on anchored parts. If a part's anchored status changes on the server, the network ownership of that part will be affected. -- Create a ClickDetector so we can tell when the part is clicked -- This function updates how the part looks based on its Anchored state -- When the part is anchored... -- When the part is unanchored...\n\nThe CFrame property determines both the position and orientation of the BasePart in the world. It acts as an arbitrary reference location on the geometry, but ExtentsCFrame represents the actual CFrame of its physical center. When setting CFrame on a part, other joined parts are also moved relative to the part, but it is recommended that you use PVInstance:PivotTo() to move an entire model, such as when teleporting a player's character. Unlike setting BasePart.Position, setting BasePart.CFrame will always move the part to the exact given CFrame; in other words: no overlap checking is done and the physics solver will attempt to resolve any overlap unless both parts are Anchored. For keeping track of positions relative to a part's CFrame, an Attachment may be useful. -- Reset the part's CFrame to (0, 0, 0) with no rotation. -- This is sometimes called the \"identity\" CFrame -- Same as above, but use a Vector3 instead -- Set the part's CFrame to be at one point, looking at another -- Rotate the part's CFrame by pi/2 radians on local X axis -- Rotate the part's CFrame by 45 degrees on local Y axis -- Rotate the part's CFrame by 180 degrees on global Z axis (note the order!) -- Composing two CFrames is done using * (the multiplication operator) -- Unlike algebraic multiplication, CFrame composition is NOT communitative: a * b is not necessarily b * a! -- Imagine * as an ORDERED series of actions. For example, the following lines produce different CFrames: -- 2) Rotate the part 45 degrees around its Y axis. -- 1) Rotate the part 45 degrees around its Y axis. -- There is no \"CFrame division\", but instead simply \"doing the inverse operation\". -- Position a part relative to another (in this case, put our part on top of otherPart)"
    },
    {
        "link": "https://devforum.roblox.com/t/the-touched-event/951129",
        "document": "Hey Developers! I have a question. It’s not for a specific script it’s just about the event in general.\n\nFor some reason, every time I use that function, it’s for when a player touches a brick. However, apparently, the event gets called about five or six times - the record being twenty-six - when a player touches a brick once. I want it so something happens once, within a time period (probably one or two seconds). I’ve tried a bunch of things to get around this but none of them seem to work.\n\nWhat are your thoughts on this? What should I do the next time I have this situation? Thanks to whoever replies."
    },
    {
        "link": "https://devforum.roblox.com/t/touched-events-with-oop/738468",
        "document": "I’m currently working on a project where you can destroy certain parts, present in different spawn areas of the map. The user has a tool to damage and destroy a part using a .touched event client-side on the tool (with remote validation on the server).\n\nI quite like the ‘lua OOP structure’ to organise my project, allowing me to easily add more varied destructable parts. I thought about making the destructable part a class, but I’m not sure how I would handle touched events that way. I would need to find the part object (instantiated class) based on the given part (given through the touched event) in some way. This is probably possible by collecting all instantiated objects in some script (EDIT: and looping over them, finding the right part) but I already have spawner objects holding the parts for a specific area.\n\nIs there a way to do this without big overhead? Otherwise I’ll just keep my functional structure using instance values for the part properties and a general module for processing the attack on a given workspace part."
    }
]