[
    {
        "link": "https://pzwiki.net/wiki/Modding",
        "document": ""
    },
    {
        "link": "https://pzwiki.net/wiki/Java_documentation",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/projectzomboid/comments/13m5t96/best_resources_to_learn_how_to_make_mods_for_pz",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/projectzomboid/comments/12xohbc/any_good_modding_tutorials_i_could_follow",
        "document": ""
    },
    {
        "link": "https://github.com/FWolfe/Zomboid-Modding-Guide/blob/master/api/README.md",
        "document": "Project Zomboid's code is a 2-language system, using both Java and Lua. The main engine and API features are primarily Java, with large chunks of the logic in Lua. Most modding is done to the Lua component, while the Java component is generally considered non-moddable.\n\nNote: The java can be modified, but requires knowledge of java, decompiling and recompiling the .class files. Mods with Java edits also can not be installed using normal methods, these files need to go directly to Zomboid's install directory. Modifying the Java is beyond the scope of this document.\n\nUnlike the Java, Lua can be edited with the text editor of your choice and requires no other tools. Those familiar with basic Lua can skip ahead.\n\nLua is designed to be a simple and lightweight language, without a lot of bells and whistles. It is easy to learn, its syntax is simple and there are a minimal number of built-in functions and modules. It does include some concepts that can initially throw people coming from other languages.\n\nTODO: Include a brief lua tutorial here, and links to more online.\n\nOne major difference between Lua and other languages is the syntax. Unlike C based languages, are not used to contain code blocks. Brackets are used for declaring tables. Instead a keyword such as , , etc followed by contain a block.\n\nis not normally used in Lua to specify line endings, although it can be (it will be ignored by the parser). The exception is multiple statements on a single line. requires no but does.\n\nare not required around conditionals, except for complex ones.\n\nVariables are global, unless declared with the keyword. (A odd choice for the language, since one of Lua's core philosophies is to declare with as smallest scope possible)\n\nLua has very few data types. Strings, Numbers, Tables and Userdata (data and objects from other languages, normally C). Integers and floats are treated the same.\n\nThere are no objects, sorted/ordered lists or unsorted/unordered lists. These are all the same thing in Lua: a table.\n\nTables can operate as a sorted or unsorted list, or a in a object-like structure with inheritance (metatables). They can also operate as all 3, at the same time.\n\nWhen used as a sorted list, table indexes start at 1, not 0\n\nBoth and are acceptable separators for entries in a table.\n\nUsing calls a function in a table normally, while using calls it as a object method. It is the same as\n\nA example of how strange (and versatile) tables can be:\n\nZomboid's Lua is not 'pure' Lua, it is modified Kahlua, a Lua interpreter writen entirely in Java. It lacks the performance of pure Lua, but provides a almost seamless integration of the Java and Lua components. Not all Lua modules are implemented such as and\n\nJava classes and functions are 'exported' to Lua providing normal access to them, however things like java reflection will not work. These classes and functions are manually specified for export by the Zomboid developers, thus the Lua does not have full access to Java and is at least partially sandboxed.\n\nOne thing to bear in mind is functions called from Lua will often return Java objects. Java Arrays and Lists in particular can catch people off guard, since they are quite different from a Lua table list. For example iterating over a Lua table list:\n\nNow say we have a player object want a list of the known recipes:\n\nUnlike a Lua table list, our the first entry in the Java List is index 0 (not 1), and will no longer work, nor will to get the size, or to get the value at a specified index. For this we need to use the methods in Java's List class and\n\nThe upside of this is Java Lists and Arrays have shortcut methods not available in standard Lua tables, like using to test if a string is in the List. Doing this with a Lua table requires iterating over the table manually checking each index.\n\nThe Lua controls many aspects of the game. A small sample of whats in the Lua, and thus directly moddable:\n• timed actions and general interaction with the world\n• vehicle usage and events that happen over time while driving\n\nThis section of the guide covers where different aspects can be found in the files. Zomboid's Lua files are broken up into 3 main folders:\n• Used for lua scripts shared by client and server-side logic. These are the first Lua scripts that get loaded.\n• Used for client-side scripts. UI elements, context menus timed actions and the like. These get loaded after any 'shared' Lua scripts.\n• Used for server-side scripts. Item spawning, core farming, weather and other server-side events. These only get loaded when the game is actually started (loading a save, starting a server, etc).\n\nMany aspects such as farming or vehicles have both a and component.\n\ndefines all professions and traits, also hair color pallets and survivor random names and other character creation options.\n\nNote: many interface elements such as the mechanics window are listed in their corresponding sections instead of here. This section contains standalone UI elements.\n\ncontains the pre-game interface. Main menu, options and mod selection, plus the game setup and character creation screens.\n\ncontains base UI classes such as buttons or richtext boxes, as well as many specific windows and elements like tooltips and inventories.\n\ncontains the majority of timed actions, although many such as farming or reloading are not part of this folder, and listed in their corresponding sections.\n\nContains reloading, racking and firing logic. Expect major differences between PZ build 40 and 41 here.\n\ndefines where specific vehicle types can be found and spawn chances.\n\nuser interface elements such as the dashbar, radial and mechanics window.\n\nvarious timed actions such as opening windows, adding gas, hotwiring etc.\n\ncontains server callbacks in response to client actions sent with sendClientCommand().\n\ncontains callback functions in response to various vehicle events such as creation or update, mechanics callbacks on part installation or removal, and utility functions. Part condition on vehicle spawn, loss of condition while driving, fuel consumption and battery usage are a example of what can be modified here.\n\nTODO: Describe major parts of the api, common globals and the event system.\n\nThe API (application programming interface) for Project Zomboid consists of 2 parts: the Lua global functions and tables, and the Java exposed functions and classes.\n\nGiven that Project Zomboid is far from complete, its API is constantly evolving. Official documentation is outdated and sparse. The most effective way to find what's available to you is by reading the code. For Lua this is simple enough but for Java it means decompiling.\n\nThe majority of Zomboid's Lua code is triggered by a Event/Callback system. Lua functions are registered as callbacks in response to events triggered by Java. The exception is code run when the Lua files are loaded (code outside functions), and Lua functions specifically called by Java (applies only to some vanilla functions).\n\nThere is a wide variety of events that you can register a callback to including stuff like key presses, equipping a item, loot spawning, starting a game etc.\n\nRemoving callbacks is equally as easy, but you can only remove a event if you have a pointer to the callback function:\n\nA common mistake with beginners adding events is accidentally doing this:\n\nEvents are not always triggered by Java, in some instances they are triggered by Lua. A example is the ItemPicker in build 40 and below: Java directly calls the Lua ItemPicker functions, which then triggers the event.\n\nNew event types can also be added by Lua:\n\nWhen creating callbacks to events, there are a few things that need to be taken into consideration:\n• Some events are triggered more often then others, and callbacks may need to be optimized for performance.\n• Some events are only triggered client-side or server-side, thus callbacks need to be as well.\n\nDifferent events will pass different argument types to your callbacks. When using a new event its worth debugging it first, checking if its only client or server-side, how often its called, and exactly what types of arguments it has. Using the function in the following example we can easily see what arguments a event callback is getting.\n\nWhich will print something similar to this in the console:\n\nTODO: Brief outline of installing and working with a decompiler.\n\nTo truly understand Zomboid's Java API, you need to peak 'under the hood'. For those unfamiliar with Java, the code is written in .java files (standard text like .lua) then 'compiled' into .class files. Compiling is the process for turning human readable code (text) into machine readable instructions. To read Zomboid's Java we need to 'decompile' it: turn the machine readable instructions back into human readable code.\n\nIts worth mentioning that decompiling is not exact. The output code is going to be slightly different then the code as it was originally written. That's because usually in a language there are multiple ways of writing the same thing, some are more optimized then others. Part of the compilers job is to optimize the code as it converts it to machine instruction. When you decompile you're working with this modified version of the original.\n\nThere are multiple Java decompilers but the most commonly used and easiest to work with is JD-GUI.\n\nA big advantage with large parts of the game logic in Lua means vanilla code can replaced, not just added on to. Meaning core parts of the game logic can be modified. Overwriting vanilla code comes with risks though:\n\nThe more you replace the more likely it is to break across Zomboid versions, and more likely to be incompatible with other mods\n\nA common mistake is blindly copying a vanilla file into a mod with a few minor edits. If that file changes next Zomboid update, you need to check and redo your work. If some other mod also has a modified version of that file, then one mod will overwrite the other. Following a few basic rules will drastically help compatibility and reduce potential breakage:\n\nAlways overwrite as little as possible to achieve your goal. Don't replace a whole file if you can do it by overwriting a single function.\n\nUsing custom tooltips for items as a example (many mods include custom tooltips), the file that handles these tooltips is and the method that draws the tooltip is .\n\n So we could just copy that whole file and edit our render function, but that's likely to cause compatibility issues and entirely pointless anyways. is a global lua table, we can simply go:\n\nThis can be done from any file, without having to replace the original.\n\nStore the original function in a local variable. If your overwrite doesn't need to run, call the original.\n\nTo solve the problem that many different types of mods want to overwrite the method at the same time (ie: weapon and food mods), always store the functions you overwrite in a local variable, so you can call it if you dont need to run your custom code. A food related mod doesn't need to show custom tooltips for weapons and vice versa.\n\n Run a check early in your overwrite to see if its valid or if you can use the original callback.\n\nBy calling the original, multiple mods overwriting the same function have higher chances of being compatible and it will be more resilient to minor changes in the original vanilla code.\n\nObviously This not only applies to tooltips, but all overwrites.\n\nSometimes it is necessary to overwrite or patch code in another mod. There can be many reasons for needing to do this, such as the mod is broken, or outdated, or incompatible with another mod.\n\nOverwriting another mod's code is essentially the same as overwriting vanilla code, and the same basic rules apply. However there are additional things to consider:\n\nLua files from all active mods load in alphabetical order.\n\nWhen you overwrite vanilla code load order is not as important as vanilla Lua files load before mod Lua files. But when patching mod's code load order matters. You can't overwrite code that hasn't been loaded yet. One way to solve this problem is by ensuring your file gets loaded after by exploiting the alphabetical name load order.\n\nIf the original mod's file is . Naming your patch will cause your file to load first (N before O), but naming it will load after (O before P).\n\nTip: Check the console.log and pay attention to which files get loaded first\n\nAnother more robust solution is to delay overwrite code using events. Assume the mod we want to overwrite the function in a mod:\n\nExactly which event to use to inject your overwrites is up to you, and dependant on the nature of the overwrite and where the code is. Some events don't trigger serverside, some won't trigger clientside etc.\n\nIf the function you want to replace has already been as a event callback, simply overwriting the function won't help. You need to remove the callback, then add the new one. If the original mod's file is:\n\nThen we need to make some adjustments to our overwrite:\n\nNOTE: Removing a event callback is only possible if you can get a reference to the callback function. Functions declared local, then added to a event can not be removed from the event. Nor can anonymous functions such as:\n\nThere is usually many ways to produce the same outcome when code is involved, some ways are more efficient then others. Don't assume just because your mod is 'small' or 'doesn't do much' that you can forget about optimizing. It only takes one poorly written line of code to bring a system to a crawl. And its most likely people will run your mod with many other mods, which may or may not be optimized. It all adds up.\n\nThis doesn't mean you should overly worry about optimization for each part of the code. Trying to tweak each line or code block is a massive waste of time and effort. The trick is knowing where to optimize. A good guideline is the more often a block of code runs, the more you need to optimize it.\n\nCode that only runs once is not so much of a concern as code that is getting triggered by a event.\n\nEven without specific performance optimization some practices should be implemented throughout your mod to help it be less of a drag on the user's machine.\n\nGlobal variables and functions can be accessed from any file, anywhere in the code. Local variables can only be accessed from the file or block of code they were declared in. While being able to access from anywhere is a handy feature, it's often more problematic. Accessing a global is slower, they run the risk of being accidentally overwritten. One of Lua's core philosophies is to declare variables and functions in the smallest scope possible (local).\n\nOne way to think of the differences between global and local is like a phone book. Global is a entire city and local is your personal phone book, only the numbers you actually plan on calling. Its much faster to find or change things in the smaller personal book then the larger directory. By being local, you also don't have to worry about anyone else adding or changing the same name and overwriting the data.\n\nThe downside is these locals can't be accessed from outside the code block or file they were created in.\n\nLua was designed to have minimal items in the global namespace for performance reasons. Project Zomboid's global namespace is heavily polluted (ie: has too many items). The more items that are in the global space, the longer it takes to access any specific one. Performance differences in Zomboid's kahlua interpreter vs standard Lua likely exist on the global vs local aspect, however benchmarks have shown much faster access to locals.\n\nDon't forget that functions and variables are global unless declared with the keyword.\n\nVariables declared inside functions should always be local\n\nIf your function declares a variable, make it local. If you need the variable after the function runs and simply returning it is not a option, declare it local earlier in the file outside the function block.\n\nIf you need to add to the global space, only add one table\n\nOften local won't do. You need to access multiple functions and variables from other files. There is a simple effective compromise: store all your functions and variables into a single global table\n\nTables are designed to organize your data and functions. Use them. Storing everything you need in a single table will save from polluting the global namespace more (thus slowing down everything) and still give you complete access. Consider the following table structure:\n\nIf you load this table first before the rest of the mod in the shared folder, you can just add everything inside it. You'll probably want to pull the subtables into local. It gives faster access and cleaner code, especially if you need to access the subtables a lot.\n\nPart of Lua's smallest scope philosophy applies not only to declaring variables and functions, but accessing them as well. You gain performance by pulling global into the local space as it now has a shortcut then trying to find it in the global namespace every time.\n\nThis applies to everything, including Zomboid's Lua functions and tables, functions and classes in the Java API, and built-in Lua functions and modules.\n\nConsider the following:\n\nEverytime the function runs, it needs to lookup , and for every number in the table is has to lookup and . If the table is large, we can gain a performance boost by doing this:\n\nNow it only needs to lookup and once when the function is called instead of every step of the loop. But this doesn't particularly help and might actually reduce performance with very small tables. Its also still having to do lookups when the function is run. A better option would be:\n\nNow when our function runs it doesn't need to look anything up in the global space at all.\n\nIf you really want to control local namespace pollution as well and want declare things local only in parts of the file that actually need them, use the block\n\nA big part of optimizing is running as few code instructions as possible. Consider the following conditional statement which includes 2 comparison instructions:\n\nThis first checks if is true (not false or nil), then checks . If both and have 50/50% chances of both being true or false, then order doesn't matter. However if odds are different then we can tweak this for performance. Lets assume the following for this example:\n\nNow we want a conditional checking that both of these are true. With first, there is a 70% (true) chance we end up calling both conditional instructions\n\nIf we reverse the order and check first, there is only a 20% (true) chance it will continue on to check . The second part of the conditional is never executed if the first is invalid.\n\nWhen using put the most likely false first. When using this is reversed, and you need to put the most likely true first\n\nBreak from functions and loop structures as early as possible\n\nRemember you can use to exit loops once you achieve your goals.\n\nOften you don't want to break from a loop, but skip over to the next part. Sadly Lua offers no such feature. We can however fake it using a loop inside our main loop\n\nHere we use to exit the loop and continue onto the next step of the loop. And since is always true, our loop exits on the first pass instead of actually looping.\n\nFar too often you see bits of code like this:\n\nIf your going to use the return value of a function multiple times, cache the results in a local variable.\n\nIts cleaner and saves jumping back and forth from the Java to Lua. Our first example calls the Java component 6 times. The function, and the and methods all get called from lua twice (6 total). The second example only calls Java 4 times, a 33% difference and this is only with 2 checks. If we wanted to check for a 3rd item, our example differences would be 9 calls vs 5, four inventory item checks bring the difference to 12 and 6 (50% less calls to Java).\n\nNo matter how humble your code is, eventually someone is going to read it. It takes very little extra effort to write clean, readable code. Doing so will help not only other people reading and learning from your work, but also make your work more maintainable in the long run.\n\nHaving documentation or comments in the code explaining is use or intended purpose is a massive help for people trying to understand it. Not only is it a help for other people, but helps you as well if the project is large or you spend a significant time away from it.\n\nThe amount of documentation is dependant on the complexity of the code (simple bits are often self-explanatory), but don't assume that just because a function's purpose is obvious to you, its going to be obvious to others as well. For large projects you can even use programs such as LDoc or LuaDoc can auto-generate HTML documentation from comments in the code although this requires using a specific syntax for your comments. (ORGM uses LDoc to generate its HTML docs)\n\nLua allows for many different styles of writing: using line endings or not, around conditionals or not, etc. Its up to decide which style you prefer to work in, but pick one and stick with it. Don't mix line endings and no endings styles.\n\nUse a consistent naming scheme, such as tables capitalized , functions mixed (or camelCased) , and scalar variables lower cased . Again its up to you, but be consistent. It makes it easier to see the intent and use of a variable at a quick glance will show if its a table, function or something else. Some developers go the extra mile with variables and add a prefix to the name to identify scope and data types: for strings, for integers, for globals, etc.\n\nUse proper indentation levels, for both lua and the scripts .txt files. Stuff like the example below is extremely difficult to read, and FAR too common.\n\nWhat happens when you hit the key? Does it insert a tab character? or spaces? Some developers prefer spaces over tabs, the choice is yours. Just don't mix them. Again, be consistent. The indentation on a mixed tab/spaces file may look fine on your screen, but with a different editor or fonts it wont.\n\nMost editors will have a option for using tabs or multiple spaces (often 4) when the tab key is pressed. They also have a option for viewing 'whitespaces' in the file, visibly showing where all the tabs and spaces are. When copy/pasting code blocks and snippets from other sources (like the vanilla files), be aware it might not match your tab/spaces preference. Cleanup any copied code.\n\n Fortunately most editors also have a handy tool for auto-converting all tabs to spaces and vice versa."
    },
    {
        "link": "https://steamcommunity.com/sharedfiles/filedetails?id=2748451514",
        "document": ""
    },
    {
        "link": "https://github.com/FWolfe/Zomboid-Modding-Guide/blob/master/api/README.md",
        "document": "Project Zomboid's code is a 2-language system, using both Java and Lua. The main engine and API features are primarily Java, with large chunks of the logic in Lua. Most modding is done to the Lua component, while the Java component is generally considered non-moddable.\n\nNote: The java can be modified, but requires knowledge of java, decompiling and recompiling the .class files. Mods with Java edits also can not be installed using normal methods, these files need to go directly to Zomboid's install directory. Modifying the Java is beyond the scope of this document.\n\nUnlike the Java, Lua can be edited with the text editor of your choice and requires no other tools. Those familiar with basic Lua can skip ahead.\n\nLua is designed to be a simple and lightweight language, without a lot of bells and whistles. It is easy to learn, its syntax is simple and there are a minimal number of built-in functions and modules. It does include some concepts that can initially throw people coming from other languages.\n\nTODO: Include a brief lua tutorial here, and links to more online.\n\nOne major difference between Lua and other languages is the syntax. Unlike C based languages, are not used to contain code blocks. Brackets are used for declaring tables. Instead a keyword such as , , etc followed by contain a block.\n\nis not normally used in Lua to specify line endings, although it can be (it will be ignored by the parser). The exception is multiple statements on a single line. requires no but does.\n\nare not required around conditionals, except for complex ones.\n\nVariables are global, unless declared with the keyword. (A odd choice for the language, since one of Lua's core philosophies is to declare with as smallest scope possible)\n\nLua has very few data types. Strings, Numbers, Tables and Userdata (data and objects from other languages, normally C). Integers and floats are treated the same.\n\nThere are no objects, sorted/ordered lists or unsorted/unordered lists. These are all the same thing in Lua: a table.\n\nTables can operate as a sorted or unsorted list, or a in a object-like structure with inheritance (metatables). They can also operate as all 3, at the same time.\n\nWhen used as a sorted list, table indexes start at 1, not 0\n\nBoth and are acceptable separators for entries in a table.\n\nUsing calls a function in a table normally, while using calls it as a object method. It is the same as\n\nA example of how strange (and versatile) tables can be:\n\nZomboid's Lua is not 'pure' Lua, it is modified Kahlua, a Lua interpreter writen entirely in Java. It lacks the performance of pure Lua, but provides a almost seamless integration of the Java and Lua components. Not all Lua modules are implemented such as and\n\nJava classes and functions are 'exported' to Lua providing normal access to them, however things like java reflection will not work. These classes and functions are manually specified for export by the Zomboid developers, thus the Lua does not have full access to Java and is at least partially sandboxed.\n\nOne thing to bear in mind is functions called from Lua will often return Java objects. Java Arrays and Lists in particular can catch people off guard, since they are quite different from a Lua table list. For example iterating over a Lua table list:\n\nNow say we have a player object want a list of the known recipes:\n\nUnlike a Lua table list, our the first entry in the Java List is index 0 (not 1), and will no longer work, nor will to get the size, or to get the value at a specified index. For this we need to use the methods in Java's List class and\n\nThe upside of this is Java Lists and Arrays have shortcut methods not available in standard Lua tables, like using to test if a string is in the List. Doing this with a Lua table requires iterating over the table manually checking each index.\n\nThe Lua controls many aspects of the game. A small sample of whats in the Lua, and thus directly moddable:\n• timed actions and general interaction with the world\n• vehicle usage and events that happen over time while driving\n\nThis section of the guide covers where different aspects can be found in the files. Zomboid's Lua files are broken up into 3 main folders:\n• Used for lua scripts shared by client and server-side logic. These are the first Lua scripts that get loaded.\n• Used for client-side scripts. UI elements, context menus timed actions and the like. These get loaded after any 'shared' Lua scripts.\n• Used for server-side scripts. Item spawning, core farming, weather and other server-side events. These only get loaded when the game is actually started (loading a save, starting a server, etc).\n\nMany aspects such as farming or vehicles have both a and component.\n\ndefines all professions and traits, also hair color pallets and survivor random names and other character creation options.\n\nNote: many interface elements such as the mechanics window are listed in their corresponding sections instead of here. This section contains standalone UI elements.\n\ncontains the pre-game interface. Main menu, options and mod selection, plus the game setup and character creation screens.\n\ncontains base UI classes such as buttons or richtext boxes, as well as many specific windows and elements like tooltips and inventories.\n\ncontains the majority of timed actions, although many such as farming or reloading are not part of this folder, and listed in their corresponding sections.\n\nContains reloading, racking and firing logic. Expect major differences between PZ build 40 and 41 here.\n\ndefines where specific vehicle types can be found and spawn chances.\n\nuser interface elements such as the dashbar, radial and mechanics window.\n\nvarious timed actions such as opening windows, adding gas, hotwiring etc.\n\ncontains server callbacks in response to client actions sent with sendClientCommand().\n\ncontains callback functions in response to various vehicle events such as creation or update, mechanics callbacks on part installation or removal, and utility functions. Part condition on vehicle spawn, loss of condition while driving, fuel consumption and battery usage are a example of what can be modified here.\n\nTODO: Describe major parts of the api, common globals and the event system.\n\nThe API (application programming interface) for Project Zomboid consists of 2 parts: the Lua global functions and tables, and the Java exposed functions and classes.\n\nGiven that Project Zomboid is far from complete, its API is constantly evolving. Official documentation is outdated and sparse. The most effective way to find what's available to you is by reading the code. For Lua this is simple enough but for Java it means decompiling.\n\nThe majority of Zomboid's Lua code is triggered by a Event/Callback system. Lua functions are registered as callbacks in response to events triggered by Java. The exception is code run when the Lua files are loaded (code outside functions), and Lua functions specifically called by Java (applies only to some vanilla functions).\n\nThere is a wide variety of events that you can register a callback to including stuff like key presses, equipping a item, loot spawning, starting a game etc.\n\nRemoving callbacks is equally as easy, but you can only remove a event if you have a pointer to the callback function:\n\nA common mistake with beginners adding events is accidentally doing this:\n\nEvents are not always triggered by Java, in some instances they are triggered by Lua. A example is the ItemPicker in build 40 and below: Java directly calls the Lua ItemPicker functions, which then triggers the event.\n\nNew event types can also be added by Lua:\n\nWhen creating callbacks to events, there are a few things that need to be taken into consideration:\n• Some events are triggered more often then others, and callbacks may need to be optimized for performance.\n• Some events are only triggered client-side or server-side, thus callbacks need to be as well.\n\nDifferent events will pass different argument types to your callbacks. When using a new event its worth debugging it first, checking if its only client or server-side, how often its called, and exactly what types of arguments it has. Using the function in the following example we can easily see what arguments a event callback is getting.\n\nWhich will print something similar to this in the console:\n\nTODO: Brief outline of installing and working with a decompiler.\n\nTo truly understand Zomboid's Java API, you need to peak 'under the hood'. For those unfamiliar with Java, the code is written in .java files (standard text like .lua) then 'compiled' into .class files. Compiling is the process for turning human readable code (text) into machine readable instructions. To read Zomboid's Java we need to 'decompile' it: turn the machine readable instructions back into human readable code.\n\nIts worth mentioning that decompiling is not exact. The output code is going to be slightly different then the code as it was originally written. That's because usually in a language there are multiple ways of writing the same thing, some are more optimized then others. Part of the compilers job is to optimize the code as it converts it to machine instruction. When you decompile you're working with this modified version of the original.\n\nThere are multiple Java decompilers but the most commonly used and easiest to work with is JD-GUI.\n\nA big advantage with large parts of the game logic in Lua means vanilla code can replaced, not just added on to. Meaning core parts of the game logic can be modified. Overwriting vanilla code comes with risks though:\n\nThe more you replace the more likely it is to break across Zomboid versions, and more likely to be incompatible with other mods\n\nA common mistake is blindly copying a vanilla file into a mod with a few minor edits. If that file changes next Zomboid update, you need to check and redo your work. If some other mod also has a modified version of that file, then one mod will overwrite the other. Following a few basic rules will drastically help compatibility and reduce potential breakage:\n\nAlways overwrite as little as possible to achieve your goal. Don't replace a whole file if you can do it by overwriting a single function.\n\nUsing custom tooltips for items as a example (many mods include custom tooltips), the file that handles these tooltips is and the method that draws the tooltip is .\n\n So we could just copy that whole file and edit our render function, but that's likely to cause compatibility issues and entirely pointless anyways. is a global lua table, we can simply go:\n\nThis can be done from any file, without having to replace the original.\n\nStore the original function in a local variable. If your overwrite doesn't need to run, call the original.\n\nTo solve the problem that many different types of mods want to overwrite the method at the same time (ie: weapon and food mods), always store the functions you overwrite in a local variable, so you can call it if you dont need to run your custom code. A food related mod doesn't need to show custom tooltips for weapons and vice versa.\n\n Run a check early in your overwrite to see if its valid or if you can use the original callback.\n\nBy calling the original, multiple mods overwriting the same function have higher chances of being compatible and it will be more resilient to minor changes in the original vanilla code.\n\nObviously This not only applies to tooltips, but all overwrites.\n\nSometimes it is necessary to overwrite or patch code in another mod. There can be many reasons for needing to do this, such as the mod is broken, or outdated, or incompatible with another mod.\n\nOverwriting another mod's code is essentially the same as overwriting vanilla code, and the same basic rules apply. However there are additional things to consider:\n\nLua files from all active mods load in alphabetical order.\n\nWhen you overwrite vanilla code load order is not as important as vanilla Lua files load before mod Lua files. But when patching mod's code load order matters. You can't overwrite code that hasn't been loaded yet. One way to solve this problem is by ensuring your file gets loaded after by exploiting the alphabetical name load order.\n\nIf the original mod's file is . Naming your patch will cause your file to load first (N before O), but naming it will load after (O before P).\n\nTip: Check the console.log and pay attention to which files get loaded first\n\nAnother more robust solution is to delay overwrite code using events. Assume the mod we want to overwrite the function in a mod:\n\nExactly which event to use to inject your overwrites is up to you, and dependant on the nature of the overwrite and where the code is. Some events don't trigger serverside, some won't trigger clientside etc.\n\nIf the function you want to replace has already been as a event callback, simply overwriting the function won't help. You need to remove the callback, then add the new one. If the original mod's file is:\n\nThen we need to make some adjustments to our overwrite:\n\nNOTE: Removing a event callback is only possible if you can get a reference to the callback function. Functions declared local, then added to a event can not be removed from the event. Nor can anonymous functions such as:\n\nThere is usually many ways to produce the same outcome when code is involved, some ways are more efficient then others. Don't assume just because your mod is 'small' or 'doesn't do much' that you can forget about optimizing. It only takes one poorly written line of code to bring a system to a crawl. And its most likely people will run your mod with many other mods, which may or may not be optimized. It all adds up.\n\nThis doesn't mean you should overly worry about optimization for each part of the code. Trying to tweak each line or code block is a massive waste of time and effort. The trick is knowing where to optimize. A good guideline is the more often a block of code runs, the more you need to optimize it.\n\nCode that only runs once is not so much of a concern as code that is getting triggered by a event.\n\nEven without specific performance optimization some practices should be implemented throughout your mod to help it be less of a drag on the user's machine.\n\nGlobal variables and functions can be accessed from any file, anywhere in the code. Local variables can only be accessed from the file or block of code they were declared in. While being able to access from anywhere is a handy feature, it's often more problematic. Accessing a global is slower, they run the risk of being accidentally overwritten. One of Lua's core philosophies is to declare variables and functions in the smallest scope possible (local).\n\nOne way to think of the differences between global and local is like a phone book. Global is a entire city and local is your personal phone book, only the numbers you actually plan on calling. Its much faster to find or change things in the smaller personal book then the larger directory. By being local, you also don't have to worry about anyone else adding or changing the same name and overwriting the data.\n\nThe downside is these locals can't be accessed from outside the code block or file they were created in.\n\nLua was designed to have minimal items in the global namespace for performance reasons. Project Zomboid's global namespace is heavily polluted (ie: has too many items). The more items that are in the global space, the longer it takes to access any specific one. Performance differences in Zomboid's kahlua interpreter vs standard Lua likely exist on the global vs local aspect, however benchmarks have shown much faster access to locals.\n\nDon't forget that functions and variables are global unless declared with the keyword.\n\nVariables declared inside functions should always be local\n\nIf your function declares a variable, make it local. If you need the variable after the function runs and simply returning it is not a option, declare it local earlier in the file outside the function block.\n\nIf you need to add to the global space, only add one table\n\nOften local won't do. You need to access multiple functions and variables from other files. There is a simple effective compromise: store all your functions and variables into a single global table\n\nTables are designed to organize your data and functions. Use them. Storing everything you need in a single table will save from polluting the global namespace more (thus slowing down everything) and still give you complete access. Consider the following table structure:\n\nIf you load this table first before the rest of the mod in the shared folder, you can just add everything inside it. You'll probably want to pull the subtables into local. It gives faster access and cleaner code, especially if you need to access the subtables a lot.\n\nPart of Lua's smallest scope philosophy applies not only to declaring variables and functions, but accessing them as well. You gain performance by pulling global into the local space as it now has a shortcut then trying to find it in the global namespace every time.\n\nThis applies to everything, including Zomboid's Lua functions and tables, functions and classes in the Java API, and built-in Lua functions and modules.\n\nConsider the following:\n\nEverytime the function runs, it needs to lookup , and for every number in the table is has to lookup and . If the table is large, we can gain a performance boost by doing this:\n\nNow it only needs to lookup and once when the function is called instead of every step of the loop. But this doesn't particularly help and might actually reduce performance with very small tables. Its also still having to do lookups when the function is run. A better option would be:\n\nNow when our function runs it doesn't need to look anything up in the global space at all.\n\nIf you really want to control local namespace pollution as well and want declare things local only in parts of the file that actually need them, use the block\n\nA big part of optimizing is running as few code instructions as possible. Consider the following conditional statement which includes 2 comparison instructions:\n\nThis first checks if is true (not false or nil), then checks . If both and have 50/50% chances of both being true or false, then order doesn't matter. However if odds are different then we can tweak this for performance. Lets assume the following for this example:\n\nNow we want a conditional checking that both of these are true. With first, there is a 70% (true) chance we end up calling both conditional instructions\n\nIf we reverse the order and check first, there is only a 20% (true) chance it will continue on to check . The second part of the conditional is never executed if the first is invalid.\n\nWhen using put the most likely false first. When using this is reversed, and you need to put the most likely true first\n\nBreak from functions and loop structures as early as possible\n\nRemember you can use to exit loops once you achieve your goals.\n\nOften you don't want to break from a loop, but skip over to the next part. Sadly Lua offers no such feature. We can however fake it using a loop inside our main loop\n\nHere we use to exit the loop and continue onto the next step of the loop. And since is always true, our loop exits on the first pass instead of actually looping.\n\nFar too often you see bits of code like this:\n\nIf your going to use the return value of a function multiple times, cache the results in a local variable.\n\nIts cleaner and saves jumping back and forth from the Java to Lua. Our first example calls the Java component 6 times. The function, and the and methods all get called from lua twice (6 total). The second example only calls Java 4 times, a 33% difference and this is only with 2 checks. If we wanted to check for a 3rd item, our example differences would be 9 calls vs 5, four inventory item checks bring the difference to 12 and 6 (50% less calls to Java).\n\nNo matter how humble your code is, eventually someone is going to read it. It takes very little extra effort to write clean, readable code. Doing so will help not only other people reading and learning from your work, but also make your work more maintainable in the long run.\n\nHaving documentation or comments in the code explaining is use or intended purpose is a massive help for people trying to understand it. Not only is it a help for other people, but helps you as well if the project is large or you spend a significant time away from it.\n\nThe amount of documentation is dependant on the complexity of the code (simple bits are often self-explanatory), but don't assume that just because a function's purpose is obvious to you, its going to be obvious to others as well. For large projects you can even use programs such as LDoc or LuaDoc can auto-generate HTML documentation from comments in the code although this requires using a specific syntax for your comments. (ORGM uses LDoc to generate its HTML docs)\n\nLua allows for many different styles of writing: using line endings or not, around conditionals or not, etc. Its up to decide which style you prefer to work in, but pick one and stick with it. Don't mix line endings and no endings styles.\n\nUse a consistent naming scheme, such as tables capitalized , functions mixed (or camelCased) , and scalar variables lower cased . Again its up to you, but be consistent. It makes it easier to see the intent and use of a variable at a quick glance will show if its a table, function or something else. Some developers go the extra mile with variables and add a prefix to the name to identify scope and data types: for strings, for integers, for globals, etc.\n\nUse proper indentation levels, for both lua and the scripts .txt files. Stuff like the example below is extremely difficult to read, and FAR too common.\n\nWhat happens when you hit the key? Does it insert a tab character? or spaces? Some developers prefer spaces over tabs, the choice is yours. Just don't mix them. Again, be consistent. The indentation on a mixed tab/spaces file may look fine on your screen, but with a different editor or fonts it wont.\n\nMost editors will have a option for using tabs or multiple spaces (often 4) when the tab key is pressed. They also have a option for viewing 'whitespaces' in the file, visibly showing where all the tabs and spaces are. When copy/pasting code blocks and snippets from other sources (like the vanilla files), be aware it might not match your tab/spaces preference. Cleanup any copied code.\n\n Fortunately most editors also have a handy tool for auto-converting all tabs to spaces and vice versa."
    },
    {
        "link": "https://github.com/cocolabs/pz-modding-guide",
        "document": "This document will focus on explaining the methodology used to create, publish and install Project Zomboid modifications. The goal of this guide is to provide, as considered by author, the best way to create, publish and install Project Zomboid modifications. What is implied by best way is explained later in the guide.\n\nThis document is intended to be a complete guide that guides you through the process of modding various game aspects, providing detailed examples and explaining the reasoning behind the methodology used. If you are just looking for references, tutorials, code examples or a quick guide to creating simple modifications you should read Project Zomboid Modding Guide instead which serves more as an unofficial Project Zomboid wiki.\n• How to read this guide\n• Methodology\n• Version control\n• How to use VCS?\n\nDue to the large size of this guide it is not recommended to read it using your web browser.\n\nInstead you should use Typora, a free and open source markdown editor. It is beautiful, lightweight and perfect for reading and writing markdown files. It features an outline panel which allows you to see the outline structure of this document allowing you to quickly go through the document and jump to any section with one click. It also has different themes to choose from, allowing you to customize your reading experience.\n• Mod - One or more files that modify the game either directly or through third party applications.\n• Modding - The process of modifying Project Zomboid or video game files in general.\n• Mod development - The process of creating and publishing game modifications.\n• Workflow - The set of relationships between project activities, from start to finish.\n• Methodology - An organized and documented set of procedures and guidelines.\n• License - Refers to a software license which is a legal instrument governing the use or redistribution of software.\n• IDE - Refers to Integrated development environment which is an application that provides tools for software development.\n• Open source - The quality of having publicly accessible design (mostly referring to software).\n• Decompile - The process of creating a source file from a compiled class file.\n• API - Refers to Application Programing Interface which is an interface that defines interactions between multiple software applications.\n• Bug - An error in software that causes it to produce an incorrect or unexpected result.\n• Debug - The process of finding and resolving bugs within software.\n• Changelog - Log or record of all notable changes made to a project.\n• JVM - Refers to Java Virtual Machine which is a virtual machine that enables a computer to run Java programs.\n• Bytecode - Code compiled to run on a Java Virtual Machine. It is usually stored in files.\n\nReaders are encouraged to remember that all information in this guide is presented as opinion as opposed to fact. Any information directing readers to do one thing instead of another is intended to be taken as advice as opposed to an order. Statement criticizing any aspect of methodology should not be taken as a critique of personal nature. The author of this document does not assume responsibility or give warranties of any kind. This includes responsibility for offended sensibilities, mood swings, sleepless nights or damage to your software or hardware. The author of this document also make no guarantee that any and all information in this guide is accurate at any time beyond the point at which it was written.\n\nReaders should note that the methodology proposed in this guide is not presented as the only way, but rather the best way of modding Project Zomboid as perceived by the author of this guide. Readers should also be aware that the methodology proposed in this guide is currently not accepted as the recommended way of modding Project Zomboid. This makes it more difficult to find documentation and support from community channels when using said methodology.\n\nThe process of game modding is a fun and rewarding activity where players get to modify the game to create interesting and engaging content for themselves and others to enjoy. It can also be exhausting, time consuming and mind numbing experience with most time being spent on preforming tedious tasks, searching for documentation and solving unexpected problems. Not using the right tools or looking at the right places all lead to frustration and an eventual burnout.\n\nThe primary purpose of this guide is to present an alternative way of modding that benefits both mod developers and the modding community as a whole. A way of modding that allows us to create a more sustainable culture of preserving and sharing knowledge. Nobody benefits when mod developers experience regular burnouts or when they develop mods behind closed doors and use copyright licenses to prevent others from copying their work. The culture will not change just because this guide was written, but it will hopefully inspire some to embrace a more community oriented approach to developing mods.\n• Patience and dedication to learn how to use advanced tools and workflows.\n• Basic knowledge of creating content with which the readers wants to modify the game with. For example, if the reader wanted to learn how to implement a new or modify an existing 3D model in the game, the guide would assume the reader is capable of creating or modifying the model on his own and would instead focus on explaining the procedure of preparing the model and importing it in the game.\n\nIn addition to the requirements listed above the following knowledge is recommended but not required:\n• Previous knowledge of Project Zomboid or game modding in general. Having previous knowledge of game modding will make the guide much easier to follow, however the guide will explain modding methodology by assuming the reader has no previous experience modding Project Zomboid or any other game. Note that some aspects of the guide are intended for modders with intermediate and advanced modding experience and will be marked as such.\n• Basic knowledge of software development principles and practices. This is recommended because the reasoning behind much of the methodology proposed will be easier to understand for those with some experience in developing software. However, the guide will explain the development principles and practice by assuming the reader has no previous knowledge of said principles and practices.\n\nBefore we explain the different modding aspects, it is important to understand the proper principles and procedures with which we create and publish mods. In order to consistently create mods and keep motivated we have to adhere to sane workflows. To help others do the same we have to carefully document our project and keep it free (as in \"free speech\") and share it with others. Keep in mind that the methodology proposed here should be adhered to regardless of the scope or aspect of your project. The same rules apply whether you want to change a sprite texture or do a complete game overhaul.\n\nThe proposed methodology consists of advanced tools and workflows. Learning to apply this methodology to your modding process takes time and dedication. The justification for this investment in time is increased efficiency and more enjoyable experience. Increased efficiency leads to overall higher mod quality and more free time which can then be used to either create more mods or invest in other things in life. More enjoyable experience means we are less frustrated and more motivation to create even more amazing mods. It also helps create a more healthy community.\n\nHere are some of the common reasons mod developers give for not using advanced tools and workflows:\n• I am not getting paid for creating mods, it is only a hobby.\n• I do not need all the features provided by advanced tools.\n• I do not have the time to install and learn how to use these things.\n\nOn the surface these reasons might feel perfectly reasonable, but let's take a closer look at each argument.\n• The first argument claims that there is no need to put care and effort into something that is only a hobby. Take for example any major open source project that is widely used by countless users on a daily basis, like Linux distributions. Linux is free software and as such does not make any money from sales. Most contributors to Linux do not get paid and are not looking to get paid. Their main motivation is not money. If the Linux community did not want to put effort into supporting the projects because it's only a hobby and they are not getting paid for it, Linux would not be what it is today.\n• The second argument claims that since not all features of the tool are needed, using the tool makes little sense. If we think about all the advanced tools we use in our day to day life we can easily think of numerous examples of tools that offer a lot more features then what we are currently using. Take for example your mobile phone. This is an advanced tool that you are only partially utilizing because you don't need to use the countless features it has to offer, yet you are still using it. It is clear that it offers benefits that other more simplistic contraptions (such as rocks and shoestring cups) cannot match.\n• The third argument claims that the time needed to install and learn how to use advanced tools does not justify it's benefit. This argument comes from not knowing the actual benefit of said tools. If you thought that the benefit of driving a car over riding a horse is negligible, you would never buy a car and live the rest of your life as a true cowboy. The argument also does not take into account the positive impact that using these tools and workflows in your mod development process has on the whole community.\n\nIn conclusion, it should now be clear what this guide implies when labeling something as the best way. It is a way of doing things that is efficient, fun and benefits the community as a whole. As mentioned earlier, it is not the only way, and readers are always encouraged to think for themselves.\n\nMods should be designed with usability foremost in mind, provided they will be publicly available (as is encouraged in Freedom section). Many mod developers design their mods to fit their own needs without thinking much about how accessible and configurable their mod is. In most cases this is simply an oversight, but sometimes it's part of development philosophy which is a result of the \"I am not getting paid to create mods, it is only a hobby\" mentality.\n\nEach mod should have the following design qualities:\n• Inclusive - Mod names should not include names or usernames of one or more authors unless it is thematically compatible. For example, calling your clothing mod \"John's Cool Clothes\" is not acceptable, while calling your underwater diner mod \"BlueCrab's sea diner\" is acceptable since including the author fits with the theme of the mod. Including your name or username in the name of the mod communicates to everyone that this is and always will be your mod. Establishing a claim in this way prevents the idea of collective ownership and makes the community more atomized. Instead of focusing on their own ego, developers should try to focus on the mod idea itself, and welcome community participation.\n• Configurable - If possible, mods should offer a way to configure various settings so users can tailor their experience, as opposed to being forced to experience the game precisely how the author envisioned it. Configuration options should be accessible and easy to change. A list of configuration options along with configuration instructions should be present somewhere in project documentation.\n• Modular - Expansive mods that contain a lot of different elements should consider separating optional elements into modules or add-ons. These are separate mods that users can install at their discretion. Mod developers should be careful as not to create too much add-ons for any single mod as that makes it much more difficult to curate and maintain mod lists. As with configuration options, the goal here is to allow the user to tailor his experience.\n• Independent - Mods that depend on external components should try to integrate as much of those components as possible. Depending on other libraries and mods means that users have to download those libraries and mods, which makes mod management more difficult. Having a lot of mods with dependencies means uninstalling mods becomes a chore as users don't know which dependencies they need to keep and which can be safely removed.\n\nIn this section we are going to explain what version control systems (VCS) are, how to use them, and why they are an integral part in any mod development process. Always remember that game modding is just downscaled game development and is thus not excluded from software development practices.\n\nHere is a good summary of what version control is:\n\nRead more about version control in this article, after which you should know everything you need to get started with version control.\n\nThe main question you might be wondering is why you should use such a seemingly complex system in your mod development workflow. In addition to everything already said in the article linked above, the answer is simple: it benefits the whole community.\n\nWhen you are using version control in your project and hosting it on a repository hosting service such as Github you are leaving behind a complete long-term change history of every file contained within your project. This means every change made by you and others you collaborated with over the complete lifespan of development is recorded in detail. When you eventually stop developing the project it can be easily picked up by other developers and continually developed until they pass the torch to others. Introducing version control in your mod development workflow helps the community by making your development process cleaner, more readable and easier to understand and follow.\n\nImagine if every mod project you ever came across used version control. How many outdated and abandoned mods have you seen and wanted to revive but had no idea where to begin? How many active mods struggle with simple bugs authors are unable or unwilling to resolve due to spaghetti code which makes them more and more reluctant to continue development with each line of code they write? The reason for this is that the authors did not keep a clean record of what they were doing. Most developers will say that documenting code is important but very few will admit that documenting project changes is equally important.\n\nThe most widely used modern version control system in the world today is Git. When using Git every developer's working copy of the code is also a repository that can contain the full history of all changes. This ensures that your project, along with a detail record of changes is always safe as long as a single copy of your project repository is present somewhere, which should always be the case as long as you are using a repository hosting service. The recommended repository hosting service is Github due to it's great support for open source projects, intuitive web-interface and easy project management.\n• Start by installing Git. It is easy to install and works on most operating systems.\n• In addition to installing Git it is also recommended to install Github Desktop (see here for Linux version). It is a Git desktop client which makes using Git much easier. It provides a clean user interface that keeps simple Git tasks simple and provides much needed quality of life.\n• Once you have Git installed read git - the simple guide to learn the basics of using Git.\n• Download or bookmark these cheat sheets to help you out when you eventually forget Git commands:\n\nLearning how to use version control is a long but worthwhile process. Mod developers need to be encouraged to start using version control in their mod development workflows to help improve the quality of mods and provide better community support for new modders.\n\nEvery mod project should contain documentation that clearly states how to use and configure the mod. If there are special installation steps needed to make the mod work those should be documented as well. This documentation should be written in a file that should reside in the project root directory.\n\nIn addition to this, if the mod project contains code, the code itself should be sufficiently documented as to allow others to easily study and understand the code. It should also allow other developers to continue developing the project without getting in contact with the original author.\n\nLarger projects are encouraged to open and maintain a wiki where they can document different project aspects in detail. For example; a mod that expands foraging should have a wiki page that lists all the different plants that can be foraged, a mod that adds more cooking recipe should list those recipes along with recipe schematics that inform the players how to use them, a mod that overhauls zombie behavior should split each behavior category in different pages and provide a detailed explanation of how exactly different aspects of behavior differ from vanilla behavior.\n\nThe recommended way of creating and hosting wikis is with Github wikis. It allows you to write pages in Markdown and HTML format. It also allows others to contribute either directly or via pull requests, since each wiki is a Git repository with it's own detailed history of changes.\n\nThe final and most important aspect of modding methodology is licensing. Developing mods is a fun activity that most of us do for free, however this reason should not preclude ethical considerations. Mods should always be developed and distributed under ethical principles.\n\nAs mentioned in the previous section, the main reason why mod developers should learn and practice version control is to help the community. In turn the community helps them. Nobody knows everything and the value of collective knowledge always outweighs that of individual knowledge.\n\nFor this same reason mod developers should keep their mods open source, since version control does not benefit the community if it is kept secret. They should also guarantee users essential freedoms when using their mods. Keeping your project open source means that the source code and asset project files are open for anyone to use, study and modify. This principle allows others to contribute to the development and improvement of mods like a community.\n\nAs stated by GNU, free and open source software should give users the following essential freedoms:\n\nMany mod developers are hesitant to make their projects open source as they are afraid that by doing so they are allowing others to steal their work and claim it as their own. This stems from a fundamental misunderstanding of what free software is. When declaring your project open source you are not telling the world that you forgo all legal rights and that anyone can do what they want with your work. You are telling the world that they have the freedom to run, copy, distribute, study, change and improve your work, nothing more. Most open source licenses protect your work under threat of legal punishment against actions such as someone taking your work and publishing it under their name.\n\nBefore starting a mod project you should think about choosing an open source license that works best for you. The best choice for small and simple projects is the MIT License which lets people do almost anything they want with your project, like making and distributing closed source versions. However, if you are working on a more serious project it is recommended to use the GNU GPL v3 license which also lets people do almost anything they want with your project, except distributing closed source versions. Not allowing people to distribute closed source versions helps enforce the principles of free software.\n\nWhen uploading your mod to the Steam Workshop you grant Valve the following rights:\n\nThe excerpt above was taken from the Steam Subscriber Agreement. Many believe that by uploading to the Steam Workshop you grant Valve complete ownership and intellectual property rights to your work. After reading the linked subscriber agreement you can see that this is simply not true. You are irrevocably granting Valve certain rights for the duration of the intellectual property rights, but you still retain full intellectual property rights and Valve is not able to take those rights away from you. They are however able to exercise the rights you gave them for the full duration of the agreement.\n\nHere is a list of essential tools that every mod developer should use:\n• Notepad++ - Free source code editor and Notepad replacement written in C++. It should be preferred over programs like Atom and Sublime Text due to it's efficiency and simplicity. It is a very portable and powerful tool that allows for advanced text manipulation and formatting. You can use it's expansive search functionality to (recursively) find text occurrences in files across different directories from a single search action. It also support searching, marking and replacing text with regular expression. With that and a lot more advanced features at your disposal Notepad++ is your most efficient tool for searching, editing and formatting text. Note that this only applies to text, when writing code your preferred tool should always be IntelliJ IDEA.\n• IntelliJ IDEA - Integrated development environment written in Java for developing software. It allows you to read, write, decompile and search through game code. It also allows you to efficiently search through game scripts and other text based files with an easy to use user interface that supports search scopes and regular expressions. It is also used to setup your mod development environment, which is the primary reason it is recommended as an essential tool for all mod developers. Read more about setting up you development environment in Environment section. In addition to this it is important to note that this is the same program used by The Indie Stone developers to write game code.\n\nSetting up your mod development environment is the first step in creating your first mod.\n\nProperly installed mod development environment will allow you to do the following from the comfort of your IDE:\n• Write Lua code with an up-to-date API documentation attached to project.\n• Launch and debug Project Zomboid with console logging and use of breakpoints.\n• Fully automate changelog generation and create mod distributions with a click of a button.\n\nDevelopers that write code will benefit from following features in their IDE:\n\nSince the development environment includes many interconnecting systems which need to be configured in the right order, it is difficult to setup manually. This is why The Storm Project has created Capsid. It is a Gradle plugin that enables powerful IDE features and improves your modding workflow. It helps automate the process of setting up, assembling and deploying your project. Read the project for information on how to install, configure and use Capsid.\n\nProject Zomboid's codebase is divided into two main components; the frontend and backend. The frontend is written in Lua and is mainly focused on defining the user interface. The backed is written in Java and handles most of game logic, rendering objects, registering user input and much more.\n\nSince the early days of Project Zomboid there was only ever two ways of modding the game; with Lua using the official API or with Java by modifying and recompiling game classes. The following sections list the advantages and disadvantages of both approaches.\n\nOfficial modding support is implemented with modified Kahlua, which is a Lua interpreter written in Java. It reads instructions written in Lua and executes them in the Java Virtual Machine. Lua interacts with Java using an API defined in . Methods defined in are exported as global Lua functions and classes exported by are available as global Lua tables.\n• Easy to learn and write mods with.\n• Unable to access classes and members that are not directly exposed by API.\n• No type safety or on-the-fly compiler errors makes it more difficult to write code.\n• More difficult to debug due to lack of proper debugging tools.\n• Does not implement all standard Lua modules such as and .\n• Java classes that have not been directly exposed by are not accessible from Lua.\n• Java class fields are not accessible from Lua regardless of whether the owner class is directly exposed or not.\n• Numbers cannot be stored as any type other then in which degrades performance and increases memory use.\n\nThis way of modding is not officially supported and is generally frowned upon by the community. However it offers many advantages over the official way which is why this guide promotes it as the recommended way of mod development.\n\nStill, there are many examples where it makes more sense to use Lua over Java, such as when creating or modifying user interface elements. Keep in mind that your mod can mix both Lua and Java depending on the need. The golden rule here is that any mod implementation that is either impossible to implement in Lua or can be implemented easier in Java then in Lua should be written in Java. The rest should be written in Lua.\n• Type safety and access to all IDE features.\n• Easy to inspect and debug your code during runtime.\n• More difficult to learn and use.\n• Does not have officially supported API.\n• Not supported by most of the modding community.\n\nThe old way of modding with Java is by modifying and recompiling game Java classes.\n\nHere are the steps that need to be repeated for each Java class:\n• Check if new and old class have matching bytecode.\n• If the bytecode does not match, modify the new class to match bytecode.\n• Apply custom modifications to new class and build it.\n\nThere are three problems with this approach. The first one being that the process outlined above requires extensive knowledge of bytecode and is quite tedious to repeat for each class. The second problem is that every time we update the game to a new version we have to check if the game classes we are replacing have changed and then either repeat the aforementioned process or replace them with our custom classes. The last and most important problem is that there is no safe way to distribute our mods to the community. If we upload the recompiled classes anywhere online we are essentially distributing parts of Project Zomboid which is a proprietary product protected under law. This could easily result in you receiving a visit from judge Spiffo.\n\nThis method of modding is not recommended since it is tedious and not useful to the community as a whole.\n\nZomboid Storm is the new and sexy way of modding Project Zomboid.\n\nIt is a fully integrated Java modding toolchain that allows mod developers to easily create functional Java mods using a custom API. It is similar to Fabric and Forge which both provide modding capabilities for Minecraft. The project is open source and licensed under GNU GPL v3 license. It is currently in alpha stage of development and releases are publicly available on Github. Everyone is encouraged to join the testing process by downloading and using the latest pre-release. More information about Storm, including installation instructions and testing procedures can be found in the project .\n\nThe following is a list of communities where you can discuss and learn about modding:\n• Visit the PZ Modding section of the Project Zomboid forum.\n• Join the official Project Zomboid Discord server and visit the channel.\n• Join Coco Labs Discord server to meet the author of this guide and join community projects.\n• The Indie Stone for creating Project Zomboid and making it the best zombie survival game.\n• FWolfe for writing Project Zomboid Modding Guide and inspiring me to write this guide.\n• Project Zomboid modding community for helping me learn more about the game."
    },
    {
        "link": "https://pzwiki.net/wiki/Decompiling_game_code",
        "document": "Project Zomboid is written in Java, which means that the game code is compiled into Java bytecode. Decompiling the game code will convert this bytecode back into Java source code, allowing you to read and understand the code. This process is essential for modding, as it provides insights into the game's inner workings and allows you to make changes to the game code. Most decompilers will require you to have Java installed on your computer to run them. You can download the last version on Oracle's website. Make sure to restart your terminal after downloading a new java version if you are decompiling from it.\n\nZomboidDecompiler is a tool specifically designed to decompile Project Zomboid. It can be used to decompile both Build 41 and Build 42 game code. It is currently the best available option as it will take into account the Java documentation of the game and will format the code in a way that is easier to read. To use it, you will need to simply download the latest release of the tool from ZomboidDecompiler releases. You will need to have #Java installed on your computer to run it. Once downloaded, extract the zip, navigate to the `bin/` folder and run the file to launch the decompiler. It will automatically find your game files if you are using Windows and have the game installed on Steam and create two folders called with the decompiled code and . Alternatively or if you are having issues decompiling, you can launch it from a command line directly from the file folder, useful if you have weird paths for the game or are not using Windows, making it impossible to find automatically your game files: Note: on non-Windows systems, you will need to run the script instead of . The instructions are otherwise identical. You can also add the or argument to get informations about the command line parameters.\n\nBeautiful Java is a decompiling tool developped by quarantin which was spefically designed to decompile Project Zomboid. It can be used to decompile both Build 41 and Build 42 game code. It is a good decompiler for Project Zomboid because it will format variables with their type names, allowing you more easily read the game code, however ZomboidDecompiler might be a better alternative. To use it, you will need:\n• A Bash interpreter - for Windows and macOS you can use Git Bash.\n• IntelliJ - will be used by the script as the decompilation tool. You will need the path to it after downloading it. Once these are installed, you need to clone the Beautiful Java repository. To do that, you need to open the Bash interpreter:\n• You need to place yourself in the folder you want to install Beautiful Java. To do that, you can use the command to change the path you're in. By default, you should be in the folder which is your folder (you can print the exact path by using to locate it) and you can install Beautiful Java here.\n• Once in the folder you want to install Beautiful Java, type which will copy the GitHub files of Beautiful Java in the folder .\n• Move in this new folder by typing .\n• Type the command which will create a copy of the example config file with the name \"config.txt\" in the folder.\n• Open this configuration file with a text editor, and you will need to set up the different paths to IntelliJ and Project Zomboid files for your OS (Linux, macOS or Windows):\n• The IntelliJ folder should look something like .\n• The Project Zomboid folder should be something like .\n• Save the configuration file and run the decompilation with .\n• The decompiled code with be found in the folder . Files of the decompiled game code can be found in the folder .\n\nA way to decompile the java is to use Vineflower. Its advantage is that it is fully standalone from any software and simply requires java installed on your computer alongside Project Zomboid files and Vineflower itself. You will need to have #Java installed on your computer to run it.\n• Download the latest release of Vineflower (specifically the file, like , by clicking on it). Store the file in a folder of your choice.\n• Create a folder to contain the decompiled code.\n• You will have to copy the path to the files to decompile. Go in your game files and find the folder (for example: ).\n• Open a terminal and type the following commands (make sure to set the correct paths):"
    },
    {
        "link": "https://reddit.com/r/projectzomboid/comments/125rxxn/decompilingrecompiling_class_files",
        "document": "How would I modify the .class files. Say, if I wanted to edit the sandboxoptions.class file, how would i go about decompiling and recompiling the file? I used this guide: (Steam Community :: Guide :: How to decompile Project Zomboid Java code) to decompile it, but when I use javac on the command prompt to recompile it, it comes up with ~1000 errors. here is the recompile command:\n\nI have tried this recompile command on both jdk-17 and jdk-19. most (if not all) of the recompile errors come from \"cannot find symbol\". is there something missing when I decompiled it? Someone please help me, I really want to get into the java side of modding the game files. However, I would like to do this through editing the .class files directly, rather than make it as a mod. I'm free to provide more information if you need, or request it."
    }
]