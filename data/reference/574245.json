[
    {
        "link": "https://poi.apache.org",
        "document": "The Apache POI team is pleased to announce the release of 5.4.0. Several dependencies were updated to their latest versions to pick up security fixes and other improvements.\n\nA summary of changes is available in the Release Notes. A full list of changes is available in the change log. People interested should also follow the dev list to track progress.\n\nSee the downloads page for more details.\n\nWhile testing a potential Apache POI 5.4.0 release, we discovered a serious bug in log4j-api 2.24.1. This leads to NullPointerExceptions when you use a version of log4j-core that is not of the exact same version (2.24.1). We recommend that users avoid log4j 2.24.1 and use the latest 2.24.x version where this issue is fixed again.\n\nXMLBeans release 5.2.2 had the problematic log4j-api 2.24.1 dependency and thus can lead to such issues if used in some other context. In the meantime a version 5.3.0 of XmlBeans was released which avoids this issue.\n\nPlease direct any queries to the Log4j Team. The main issue is Issue 3143.\n\n4 March 2022 - CVE-2022-26336 - A carefully crafted TNEF file can cause an out of memory exception in Apache POI poi-scratchpad versions prior to 5.2.0\n\nDescription:\n\n A shortcoming in the HMEF package of poi-scratchpad (Apache POI) allows an attacker to cause an Out of Memory exception. This package is used to read TNEF files (Microsoft Outlook and Microsoft Exchange Server). If an application uses poi-scratchpad to parse TNEF files and the application allows untrusted users to supply them, then a carefully crafted file can cause an Out of Memory exception.\n\nMitigation:\n\n Affected users are advised to update to poi-scratchpad 5.2.1 or above which fixes this vulnerability. It is recommended that you use the same versions of all POI jars.\n\nThe Apache POI PMC has evaluated the security vulnerabilities reported for Apache Log4j.\n\nPOI 5.1.0 and XMLBeans 5.0.2 only have dependencies on log4j-api 2.14.1. The security vulnerabilities are not in log4j-api - they are in log4j-core.\n\nIf any POI or XMLBeans user uses log4j-core to control their logging of their application, we strongly recommend that they upgrade all their log4j dependencies to the latest version (currently v2.20.0) - including log4j-api.\n\nDescription:\n\n When parsing XML files using XMLBeans 2.6.0 or below, the underlying parser created by XMLBeans could be susceptible to XML External Entity (XXE) attacks.\n\nThis issue was fixed a few years ago but on review, we decided we should have a CVE to raise awareness of the issue.\n\nMitigation:\n\n Affected users are advised to update to Apache XMLBeans 3.0.0 or above which fixes this vulnerability. XMLBeans 4.0.0 or above is preferable.\n\nDescription:\n\n When using the tool XSSFExportToXml to convert user-provided Microsoft Excel documents, a specially crafted document can allow an attacker to read files from the local filesystem or from internal network resources via XML External Entity (XXE) Processing.\n\nMitigation:\n\n Apache POI 4.1.0 and before: users who do not use the tool XSSFExportToXml are not affected. Affected users are advised to update to Apache POI 4.1.1 which fixes this vulnerability.\n\nCredit: This issue was discovered by Artem Smotrakov from SAP\n\nThe Apache POI team is pleased to announce the release of XMLBeans 3.1.0. Featured are a handful of bug fixes.\n\nThe Apache POI project has unretired the XMLBeans codebase and is maintaining it as a sub-project, due to its importance in the poi-ooxml codebase.\n\nA summary of changes is available in the Release Notes. People interested should also follow the POI dev list to track progress.\n\nThe XMLBeans JIRA project has been reopened and feel free to open issues.\n\nWe did some work to verify that compilation with Java 11 is working and that all unit-tests pass.\n\nSee the details in the FAQ entry."
    },
    {
        "link": "https://medium.com/javarevisited/a-generic-approach-to-write-excel-using-apache-poi-17a1dfd4b98e",
        "document": "Working with Excel documents is a frequently used feature in a software application.\n\nIn this article, a way to generalize the writing to an Excel file for any type of Objects with both single and composite(array) types of fields has been achieved using Apache POI with the support of Java Reflection feature. The need for custom code for writing each type of fields and row-column processing has been reduced, you are good to go with minimum customization.\n\nApache POI (Poor Obfuscation Implementation) is a popular open source library run by the Apache Software Foundation which is developed for reading and writing files in Microsoft Office formats, such as Word, PowerPoint, and Excel.\n\nThe objective of Apache POI is to design a cross-platform API that can manipulate various file formats of Microsoft Office and Open Office Documents. Since we are focusing on writing Excel files, we will be using the following file formats of Apache POI for spreadsheets.\n\nEach of the Apache POI libraries are dedicated to manipulate each particular type of file. The XSSF library contains the classes for handling the xlsx Excel format. The figure below shows the Apache POI related interfaces and classes for manipulating xlsx Excel files.\n\nFurthermore it provides excellent support for additional excel features such as working with Formulas, creating cell styles by filling colors and borders, fonts, headers and footers, data validations, images, hyperlinks etc.\n\nLets dive in to the work.\n\nThese main steps will be followed for the implementation :\n• Setting up a Spring Boot project with Apache POI dependencies and other necessary dependencies.\n• Creating an API endpoint to send an HTTP request to download the Excel file.\n• Defining the Java Annotation interfaces which will be used for the dynamic class reflection.\n• Defining the Java POJO class which will be used to write into the Excel sheet. And setting up a POJO class to hold metadata for each field of the above class.\n• Implementing the generic Xlsx writer with dynamic class reflection and POI spreadsheet data population into the workbook.\n• Fetching the list of POJO class objects and passing to the writer and get the response as an byte array.\n• Sending API response as a data byte array with relevant header details of openxmlformats as the MediaType\n\nSetting up a Spring Boot project with Apache POI dependencies and other necessary dependencies\n\nCreating an API endpoint to receive a HTTP request to download the Excel file\n\nDefining the Java Annotation interfaces which will be used for the dynamic class reflection\n\nDefining the Java POJO class which will be used to write into the Excel sheet\n\nHere for the demonstration purpose, a POJO which includes User details with a list of DietPlan is used :\n\nAs shown above, the previously defined Annotations are used to provide metadata for the POJO class and its fields. This metadata will be evaluated at runtime for the POJO class reflection and populating the workbook in the generic writer.\n\nSetting up a POJO class to hold metadata for each field of the above class\n\nIf we observe it, the possible dataset class might most probably consist of following data structures.\n• Composite fields (List of objects that consists of single fields)\n\nSo each field is mapped to a XlsxField instance which holds metadata about the POJO class field which will be useful later.\n\nImplementing the generic Xlsx writer with dynamic class reflection and POI spreadsheet data population into workbook\n\n@Service\n\npublic class XlsxFileWriter implements XlsxWriter {\n\n\n\n\n\n private static final Logger logger = LoggerFactory.getLogger(XlsxFileWriter.class);\n\n\n\n @Override\n\n public <T> void write(List<T> data, ByteArrayOutputStream bos, String[] columnTitles, Workbook workbook) {\n\n\n\n if (data.isEmpty()) {\n\n logger.error(\"No data received to write Xls file..\");\n\n return;\n\n }\n\n\n\n long start = System.currentTimeMillis();\n\n\n\n// setting up the basic styles for the workbook\n\n Font boldFont = getBoldFont(workbook);\n\n Font genericFont = getGenericFont(workbook);\n\n CellStyle headerStyle = getLeftAlignedCellStyle(workbook, boldFont);\n\n CellStyle currencyStyle = setCurrencyCellStyle(workbook);\n\n CellStyle centerAlignedStyle = getCenterAlignedCellStyle(workbook);\n\n CellStyle genericStyle = getLeftAlignedCellStyle(workbook, genericFont);\n\n\n\n try {\n\n// using POJO class metadata for the sheet name\n\n XlsxSheet annotation = data.get(0).getClass().getAnnotation(XlsxSheet.class);\n\n String sheetName = annotation.value();\n\n Sheet sheet = workbook.createSheet(sheetName);\n\n\n\n// get the metadata for each field of the POJO class into a list\n\n List<XlsxField> xlsColumnFields = getFieldNamesForClass(data.get(0).getClass());\n\n\n\n int tempRowNo = 0;\n\n int recordBeginRowNo = 0;\n\n int recordEndRowNo = 0;\n\n\n\n// set spreadsheet titles\n\n Row mainRow = sheet.createRow(tempRowNo);\n\n Cell columnTitleCell;\n\n\n\n for (int i = 0; i < columnTitles.length; i++) {\n\n columnTitleCell = mainRow.createCell(i);\n\n columnTitleCell.setCellStyle(headerStyle);\n\n columnTitleCell.setCellValue(columnTitles[i]);\n\n }\n\n recordEndRowNo++;\n\n\n\n// get class of the passed dataset\n\n Class<?> clazz = data.get(0).getClass(); // looping the past dataset\n\n for (T record : data) {\n\n tempRowNo = recordEndRowNo;\n\n recordBeginRowNo = tempRowNo;\n\n mainRow = sheet.createRow(tempRowNo++);\n\n boolean isFirstValue;\n\n boolean isFirstRow;\n\n boolean isRowNoToDecrease = false;\n\n Method xlsMethod;\n\n Object xlsObjValue;\n\n ArrayList<Object> objValueList;\n\n \n\n// get max size of the record if its multiple row\n\n int maxListSize = getMaxListSize(record, xlsColumnFields, clazz);\n\n \n\n \n\n// looping through the fields of the current record\n\n for (XlsxField xlsColumnField : xlsColumnFields) {\n\n// writing a single field\n\n if (!xlsColumnField.isAnArray() && !xlsColumnField.isComposite()) {\n\n writeSingleFieldRow(mainRow, xlsColumnField, clazz, currencyStyle, centerAlignedStyle, genericStyle,\n\n record, workbook);\n\n\n\n// overlooking the next field and adjusting the starting row\n\n if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {\n\n isRowNoToDecrease = true;\n\n tempRowNo = recordBeginRowNo + 1;\n\n }\n\n\n\n// writing an single array field\n\n } else if (xlsColumnField.isAnArray() && !xlsColumnField.isComposite()) {\n\n xlsMethod = getMethod(clazz, xlsColumnField);\n\n xlsObjValue = xlsMethod.invoke(record, (Object[]) null);\n\n objValueList = (ArrayList<Object>) xlsObjValue;\n\n isFirstValue = true;\n\n\n\n// looping through the items of the single array\n\n for (Object objectValue : objValueList) {\n\n Row childRow;\n\n if (isFirstValue) {\n\n childRow = mainRow;\n\n writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n isFirstValue = false;\n\n } else if (isRowNoToDecrease) {\n\n childRow = getOrCreateNextRow(sheet, tempRowNo++);\n\n writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle,genericStyle, workbook);\n\n isRowNoToDecrease = false;\n\n } else {\n\n childRow = getOrCreateNextRow(sheet, tempRowNo++);\n\n writeArrayFieldRow(childRow, xlsColumnField, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n }\n\n\n\n // overlooking the next field and adjusting the starting row\n\n if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {\n\n isRowNoToDecrease = true;\n\n tempRowNo = recordBeginRowNo + 1;\n\n }\n\n\n\n// writing a composite array field\n\n } else if (xlsColumnField.isAnArray() && xlsColumnField.isComposite()) {\n\n xlsMethod = getMethod(clazz, xlsColumnField);\n\n xlsObjValue = xlsMethod.invoke(record, (Object[]) null);\n\n objValueList = (ArrayList<Object>) xlsObjValue;\n\n isFirstRow = true;\n\n\n\n// looping through the items of the composite array\n\n for (Object objectValue : objValueList) {\n\n Row childRow;\n\n List<XlsxField> xlsCompositeColumnFields = getFieldNamesForClass(objectValue.getClass());\n\n if (isFirstRow) {\n\n childRow = mainRow;\n\n for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) { \n\n writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle,centerAlignedStyle, genericStyle, workbook);\n\n }\n\n isFirstRow = false;\n\n } else if (isRowNoToDecrease) {\n\n childRow = getOrCreateNextRow(sheet, tempRowNo++);\n\n for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) {\n\n writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n isRowNoToDecrease = false;\n\n } else {\n\n childRow = getOrCreateNextRow(sheet, tempRowNo++);\n\n for (XlsxField xlsCompositeColumnField : xlsCompositeColumnFields) {\n\n writeCompositeFieldRow(objectValue, xlsCompositeColumnField, childRow, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n }\n\n }\n\n\n\n// overlooking the next field and adjusting the starting row\n\n if (isNextColumnAnArray(xlsColumnFields, xlsColumnField, clazz, record)) {\n\n isRowNoToDecrease = true;\n\n tempRowNo = recordBeginRowNo + 1;\n\n }\n\n }\n\n }\n\n\n\n// adjusting the ending row number for the current record\n\n recordEndRowNo = maxListSize + recordBeginRowNo;\n\n }\n\n\n\n// auto sizing the columns of the whole sheet\n\n autoSizeColumns(sheet, xlsColumnFields.size()); \n\n workbook.write(bos);\n\n logger.info(\"Xls file generated in [{}] seconds\", processTime(start));\n\n } catch (Exception e) {\n\n logger.info(\"Xls file write failed\", e);\n\n }\n\n}\n\n\n\n private void writeCompositeFieldRow(Object objectValue, XlsxField xlsCompositeColumnField, Row childRow,CellStyle currencyStyle, CellStyle centerAlignedStyle, CellStyle genericStyle, Workbook workbook) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n\n\n Method nestedCompositeXlsMethod = getMethod(objectValue.getClass(), xlsCompositeColumnField);\n\n Object nestedCompositeValue = nestedCompositeXlsMethod.invoke(objectValue, (Object[]) null);\n\n Cell compositeNewCell = childRow.createCell(xlsCompositeColumnField.getCellIndex());\n\n setCellValue(compositeNewCell, nestedCompositeValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n\n\n private void writeArrayFieldRow(Row childRow, XlsxField xlsColumnField, Object objectValue,\n\n CellStyle currencyStyle, CellStyle centerAlignedStyle, CellStyle genericStyle, Workbook workbook) {\n\n Cell newCell = childRow.createCell(xlsColumnField.getCellIndex());\n\n setCellValue(newCell, objectValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n\n\n private <T> void writeSingleFieldRow(Row mainRow, XlsxField xlsColumnField, Class<?> clazz, CellStyle currencyStyle,CellStyle centerAlignedStyle, CellStyle genericStyle, T record, Workbook workbook) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n\n\n Cell newCell = mainRow.createCell(xlsColumnField.getCellIndex());\n\n Method xlsMethod = getMethod(clazz, xlsColumnField);\n\n Object xlsObjValue = xlsMethod.invoke(record, (Object[]) null);\n\n setCellValue(newCell, xlsObjValue, currencyStyle, centerAlignedStyle, genericStyle, workbook);\n\n }\n\n\n\n private <T> boolean isNextColumnAnArray(List<XlsxField> xlsColumnFields, XlsxField xlsColumnField,Class<?> clazz, T record)\n\n throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n XlsxField nextXlsColumnField;\n\n int fieldsSize = xlsColumnFields.size();\n\n Method nestedXlsMethod;\n\n Object nestedObjValue;\n\n ArrayList<Object> nestedObjValueList;\n\n if (xlsColumnFields.indexOf(xlsColumnField) < (fieldsSize - 1)) {\n\n nextXlsColumnField = xlsColumnFields.get(xlsColumnFields.indexOf(xlsColumnField) + 1);\n\n if (nextXlsColumnField.isAnArray()) {\n\n nestedXlsMethod = getMethod(clazz, nextXlsColumnField);\n\n nestedObjValue = nestedXlsMethod.invoke(record, (Object[]) null);\n\n nestedObjValueList = (ArrayList<Object>) nestedObjValue;\n\n return nestedObjValueList.size() > 1;\n\n }\n\n }\n\n return xlsColumnFields.indexOf(xlsColumnField) == (fieldsSize - 1);\n\n\n\n }\n\n\n\n private void setCellValue(Cell cell, Object objValue, CellStyle currencyStyle, CellStyle centerAlignedStyle,\n\n CellStyle genericStyle, Workbook workbook) {\n\n Hyperlink link = workbook.getCreationHelper().createHyperlink(HyperlinkType.URL);\n\n if (objValue != null) {\n\n if (objValue instanceof String) {\n\n String cellValue = (String) objValue;\n\n cell.setCellStyle(genericStyle);\n\n if (cellValue.contains(\"https://\") || cellValue.contains(\"http://\")) {\n\n link.setAddress(cellValue);\n\n cell.setCellValue(cellValue);\n\n cell.setHyperlink(link);\n\n } else {\n\n cell.setCellValue(cellValue);\n\n }\n\n } else if (objValue instanceof Long) {\n\n cell.setCellValue((Long) objValue);\n\n } else if (objValue instanceof Integer) {\n\n cell.setCellValue((Integer) objValue);\n\n } else if (objValue instanceof Double) {\n\n Double cellValue = (Double) objValue;\n\n cell.setCellStyle(currencyStyle);\n\n cell.setCellValue(cellValue);\n\n } else if (objValue instanceof Boolean) {\n\n cell.setCellStyle(centerAlignedStyle);\n\n if (objValue.equals(true)) {\n\n cell.setCellValue(1);\n\n } else {\n\n cell.setCellValue(0);\n\n }\n\n }\n\n }\n\n }\n\n\n\n private static List<XlsxField> getFieldNamesForClass(Class<?> clazz) {\n\n List<XlsxField> xlsColumnFields = new ArrayList();\n\n Field[] fields = clazz.getDeclaredFields();\n\n for (Field field : fields) {\n\n XlsxField xlsColumnField = new XlsxField();\n\n if (Collection.class.isAssignableFrom(field.getType())) {\n\n xlsColumnField.setAnArray(true);\n\n XlsxCompositeField xlsCompositeField = field.getAnnotation(XlsxCompositeField.class);\n\n if (xlsCompositeField != null) {\n\n xlsColumnField.setCellIndexFrom(xlsCompositeField.from());\n\n xlsColumnField.setCellIndexTo(xlsCompositeField.to());\n\n xlsColumnField.setComposite(true);\n\n } else {\n\n XlsxSingleField xlsField = field.getAnnotation(XlsxSingleField.class);\n\n xlsColumnField.setCellIndex(xlsField.columnIndex());\n\n }\n\n } else {\n\n XlsxSingleField xlsField = field.getAnnotation(XlsxSingleField.class);\n\n xlsColumnField.setAnArray(false);\n\n if (xlsField != null) {\n\n xlsColumnField.setCellIndex(xlsField.columnIndex());\n\n xlsColumnField.setComposite(false);\n\n }\n\n }\n\n xlsColumnField.setFieldName(field.getName());\n\n xlsColumnFields.add(xlsColumnField);\n\n }\n\n return xlsColumnFields;\n\n }\n\n\n\n private static String capitalize(String s) {\n\n if (s.length() == 0)\n\n return s;\n\n return s.substring(0, 1).toUpperCase() + s.substring(1);\n\n }\n\n\n\n\n\n private <T> int getMaxListSize(T record, List<XlsxField> xlsColumnFields, Class<? extends Object> aClass)\n\n throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n\n\n List<Integer> listSizes = new ArrayList<>();\n\n for (XlsxField xlsColumnField : xlsColumnFields) {\n\n if (xlsColumnField.isAnArray()) {\n\n Method method = getMethod(aClass, xlsColumnField);\n\n Object value = method.invoke(record, (Object[]) null);\n\n ArrayList<Object> objects = (ArrayList<Object>) value;\n\n if (objects.size() > 1) {\n\n listSizes.add(objects.size());\n\n }\n\n }\n\n }\n\n\n\n if (listSizes.isEmpty()) {\n\n return 1;\n\n } else {\n\n return Collections.max(listSizes);\n\n }\n\n\n\n }\n\n\n\n private Method getMethod(Class<?> clazz, XlsxField xlsColumnField) throws NoSuchMethodException {\n\n Method method;\n\n try {\n\n method = clazz.getMethod(\"get\" + capitalize(xlsColumnField.getFieldName()));\n\n } catch (NoSuchMethodException nme) {\n\n method = clazz.getMethod(xlsColumnField.getFieldName());\n\n }\n\n\n\n return method;\n\n }\n\n\n\n private long processTime(long start) {\n\n return (System.currentTimeMillis() - start) / 1000;\n\n }\n\n\n\n private void autoSizeColumns(Sheet sheet, int noOfColumns) {\n\n for (int i = 0; i < noOfColumns; i++) {\n\n sheet.autoSizeColumn((short) i);\n\n }\n\n }\n\n\n\n private Row getOrCreateNextRow(Sheet sheet, int rowNo) {\n\n Row row;\n\n if (sheet.getRow(rowNo) != null) {\n\n row = sheet.getRow(rowNo);\n\n } else {\n\n row = sheet.createRow(rowNo);\n\n }\n\n return row;\n\n }\n\n\n\n private CellStyle setCurrencyCellStyle(Workbook workbook) {\n\n CellStyle currencyStyle = workbook.createCellStyle();\n\n currencyStyle.setWrapText(true);\n\n DataFormat df = workbook.createDataFormat();\n\n currencyStyle.setDataFormat(df.getFormat(\"#0.00\"));\n\n return currencyStyle;\n\n }\n\n\n\n private Font getBoldFont(Workbook workbook) {\n\n Font font = workbook.createFont();\n\n font.setBold(true);\n\n font.setFontHeight((short) (10 * 20));\n\n font.setFontName(\"Calibri\");\n\n font.setColor(IndexedColors.BLACK.getIndex());\n\n return font;\n\n }\n\n\n\n private Font getGenericFont(Workbook workbook) {\n\n Font font = workbook.createFont();\n\n font.setFontHeight((short) (10 * 20));\n\n font.setFontName(\"Calibri\");\n\n font.setColor(IndexedColors.BLACK.getIndex());\n\n return font;\n\n }\n\n\n\n private CellStyle getCenterAlignedCellStyle(Workbook workbook) {\n\n CellStyle cellStyle = workbook.createCellStyle();\n\n cellStyle.setAlignment(HorizontalAlignment.CENTER);\n\n cellStyle.setVerticalAlignment(VerticalAlignment.BOTTOM);\n\n cellStyle.setBorderTop(BorderStyle.NONE);\n\n cellStyle.setBorderBottom(BorderStyle.NONE);\n\n cellStyle.setBorderLeft(BorderStyle.NONE);\n\n cellStyle.setBorderRight(BorderStyle.NONE);\n\n return cellStyle;\n\n }\n\n\n\n private CellStyle getLeftAlignedCellStyle(Workbook workbook, Font font) {\n\n CellStyle cellStyle = workbook.createCellStyle();\n\n cellStyle.setFont(font);\n\n cellStyle.setAlignment(HorizontalAlignment.LEFT);\n\n cellStyle.setVerticalAlignment(VerticalAlignment.BOTTOM);\n\n cellStyle.setBorderTop(BorderStyle.NONE);\n\n cellStyle.setBorderBottom(BorderStyle.NONE);\n\n cellStyle.setBorderLeft(BorderStyle.NONE);\n\n cellStyle.setBorderRight(BorderStyle.NONE);\n\n return cellStyle;\n\n }\n\n}\n\nFetching the list of POJO class objects and passing to the writer and get the response as a byte array\n\nFor the demonstration purpose, some dummy data will be used to create the sample POJO records list.\n\nThen an instances of ByteArrayOutputStream and XSSFWorkbook are created. The titles of the spreadsheet are defined as an String array. These are passed to the writer as parameters. The passed instance of ByteArrayOutputStream is contained the byte stream of the data written into the workbook. Inside the Finally clause the ByteArrayOutputStream is closed and the byte array is returned.\n\nAn effort to implement a generic and robust Excel writer using Apache POI and Java core features such as Reflection and Annotations, which will download an Excel file using an HTTP request. This would match most of the use cases of POJO structures when its written to an Excel sheet. Hope this will help and will be easy to customize as well.\n\nThe repository for the project can be found in here.\n\nFeel free to leave a comment below. Hope you enjoyed the story..! :)"
    },
    {
        "link": "https://poi.apache.org/components/spreadsheet/quick-guide.html",
        "document": "As of version 3.8, POI has slightly different syntax to work with data validations with .xls and .xlsx formats. Check the value a user enters into a cell against one or more predefined value(s). The following code will limit the value the user can enter into cell A1 to one of three integer values, 10, 20 or 30. This code will do the same but offer the user a drop down list to select a value from. To create a message box that will be shown to the user if the value they enter is invalid. Replace 'Box Title' with the text you wish to display in the message box's title bar and 'Message Text' with the text of your error message. To create a prompt that the user will see when the cell containing the data validation receives focus The text encapsulated in the first parameter passed to the createPromptBox() method will appear emboldened and as a title to the prompt whilst the second will be displayed as the text of the message. The createExplicitListConstraint() method can be passed and array of String(s) containing interger, floating point, dates or text values. To obtain a validation that would check the value entered was, for example, an integer between 10 and 100, use the DVConstraint.createNumericConstraint(int, int, String, String) factory method. Look at the javadoc for the other validation and operator types; also note that not all validation types are supported for this method. The values passed to the two String parameters can be formulas; the '=' symbol is used to denote a formula It is not possible to create a drop down list if the createNumericConstraint() method is called, the setSuppressDropDownArrow(false) method call will simply be ignored. Date and time constraints can be created by calling the createDateConstraint(int, String, String, String) or the createTimeConstraint(int, String, String). Both are very similar to the above and are explained in the javadoc. The contents of specific cells can be used to provide the values for the data validation and the DVConstraint.createFormulaListConstraint(String) method supports this. To specify that the values come from a contiguous range of cells do either of the following: and in both cases the user will be able to select from a drop down list containing the values from cells A1, A2 and A3. The data does not have to be as the data validation. To select the data from a different sheet however, the sheet must be given a name when created and that name should be used in the formula. So assuming the existence of a sheet named 'Data Sheet' this will work: Data validations work similarly when you are creating an xml based, SpreadsheetML, workbook file; but there are differences. Explicit casts are required, for example, in a few places as much of the support for data validations in the xssf stream was built into the unifying ss stream, of which more later. Other differences are noted with comments in the code. Check the value the user enters into a cell against one or more predefined value(s). // Here the boolean value false is passed to the setSuppressDropDownArrow() // method. In the hssf.usermodel examples above, the value passed to this // Note this extra method call. If this method call is omitted, or if the // boolean value false is passed, then Excel will not validate the value the This code will do the same but offer the user a drop down list to select a value from. Note that the call to the setSuppressDropDowmArrow() method can either be simply excluded or replaced with: These both exactly mirror the hssf.usermodel so please refer to the 'Messages On Error:' and 'Prompts:' sections above. To obtain a validation that would check the value entered was, for example, an integer between 10 and 100, use the XSSFDataValidationHelper(s) createNumericConstraint(int, int, String, String) factory method. The values passed to the final two String parameters can be formulas; the '=' symbol is used to denote a formula. Thus, the following would create a validation the allows values only if they fall between the results of summing two cell ranges It is not possible to create a drop down list if the createNumericConstraint() method is called, the setSuppressDropDownArrow(true) method call will simply be ignored. Please check the javadoc for other constraint types as examples for those will not be included here. There are, for example, methods defined on the XSSFDataValidationHelper class allowing you to create the following types of constraint; date, time, decimal, integer, numeric, formula, text length and custom constraints. One other type of constraint not mentioned above is the formula list constraint. It allows you to create a validation that takes it value(s) from a range of cells. This code would create a validation that took it's values from cells in the range A1 to F1. The usefulness of this technique can be extended if you use named ranges like this; OpenOffice Calc has slightly different rules with regard to the scope of names. Excel supports both Workbook and Sheet scope for a name but Calc does not, it seems only to support Sheet scope for a name. Thus it is often best to fully qualify the name for the region or area something like this; This does open a further, interesting opportunity however and that is to place all of the data for the validation(s) into named ranges of cells on a hidden sheet within the workbook. These ranges can then be explicitly identified in the setRefersToFormula() method argument. The classes within the ss.usermodel package allow developers to create code that can be used to generate both binary (.xls) and SpreadsheetML (.xlsx) workbooks. The techniques used to create data validations share much in common with the xssf.usermodel examples above. As a result just one or two examples will be presented here. Check the value the user enters into a cell against one or more predefined value(s). Workbook workbook = new XSSFWorkbook(); // or new HSSFWorkbook // Note the check on the actual type of the DataValidation object. // If it is an instance of the XSSFDataValidation class then the // boolean value 'false' must be passed to the setSuppressDropDownArrow() // method and an explicit call made to the setShowErrorBox() method. // If the Datavalidation contains an instance of the HSSFDataValidation // class then 'true' should be passed to the setSuppressDropDownArrow() // method and the call to setShowErrorBox() is not necessary. This code will do the same but offer the user a drop down list to select a value from. Workbook workbook = new XSSFWorkbook(); // or new HSSFWorkbook // Note the check on the actual type of the DataValidation object. // If it is an instance of the XSSFDataValidation class then the // boolean value 'false' must be passed to the setSuppressDropDownArrow() // method and an explicit call made to the setShowErrorBox() method. // If the Datavalidation contains an instance of the HSSFDataValidation // class then 'true' should be passed to the setSuppressDropDownArrow() // method and the call to setShowErrorBox() is not necessary. These both exactly mirror the hssf.usermodel so please refer to the 'Messages On Error:' and 'Prompts:' sections above. As the differences between the ss.usermodel and xssf.usermodel examples are small - restricted largely to the way the DataValidationHelper is obtained, the lack of any need to explicitly cast data types and the small difference in behaviour between the hssf and xssf interpretation of the setSuppressDropDowmArrow() method, no further examples will be included in this section. In some cases, it may be necessary to present to the user a sheet which contains more than one drop down list. Further, the choice the user makes in one drop down list may affect the options that are presented to them in the second or subsequent drop down lists. One technique that may be used to implement this behaviour will now be explained. There are two keys to the technique; one is to use named areas or regions of cells to hold the data for the drop down lists, the second is to use the INDIRECT() function to convert between the name and the actual addresses of the cells. In the example section there is a complete working example- called LinkedDropDownLists.java - that demonstrates how to create linked or dependent drop down lists. Only the more relevant points are explained here. To create two drop down lists where the options shown in the second depend upon the selection made in the first, begin by creating a named region of cells to hold all of the data for populating the first drop down list. Next, create a data validation that will look to this named area for its data, something like this; Note that the name of the area - in the example above it is 'CHOICES' - is simply passed to the createFormulaListConstraint() method. This is sufficient to cause Excel to populate the drop down list with data from that named region. Next, for each of the options the user could select in the first drop down list, create a matching named region of cells. The name of that region should match the text the user could select in the first drop down list. Note, in the example, all upper case letters are used in the names of the regions of cells. Now, very similar code can be used to create a second, linked, drop down list; The key here is in the following Excel function - INDIRECT(UPPER($A$1)) - which is used to populate the second, linked, drop down list. Working from the inner-most pair of brackets, it instructs Excel to look at the contents of cell A1, to convert what it reads there into upper case – as upper case letters are used in the names of each region - and then convert this name into the addresses of those cells that contain the data to populate another drop down list.\n\nUsing Excel, it is possible to hide a row on a worksheet by selecting that row (or rows), right clicking once on the right hand mouse button and selecting 'Hide' from the pop-up menu that appears. To emulate this using POI, simply call the setZeroHeight() method on an instance of either XSSFRow or HSSFRow (the method is defined on the ss.usermodel.Row interface that both classes implement), like this: Workbook workbook = new XSSFWorkbook(); // OR new HSSFWorkbook() If the file were saved away to disc now, then the first row on the first sheet would not be visible. Using Excel, it is possible to unhide previously hidden rows by selecting the row above and the row below the one that is hidden and then pressing and holding down the Ctrl key, the Shift and the pressing the number 9 before releasing them all. To emulate this behaviour using POI do something like this: If the file were saved away to disc now, any previously hidden rows on the first sheet of the workbook would now be visible. The example illustrates two features. Firstly, that it is possible to unhide a row simply by calling the setZeroHeight() method and passing the boolean value 'false'. Secondly, it illustrates how to test whether a row is hidden or not. Simply call the getZeroHeight() method and it will return 'true' if the row is hidden, 'false' otherwise.\n\nIn Excel, you can apply a set of borders on an entire workbook region at the press of a button. The PropertyTemplate object simulates this with methods and constants defined to allow drawing top, bottom, left, right, horizontal, vertical, inside, outside, or all borders around a range of cells. Additional methods allow for applying colors to the borders. It works like this: you create a PropertyTemplate object which is a container for the borders you wish to apply to a sheet. Then you add borders and colors to the PropertyTemplate, and finally apply it to whichever sheets you need that set of borders on. You can create multiple PropertyTemplate objects and apply them to a single sheet, or you can apply the same PropertyTemplate object to multiple sheets. It is just like a preprinted form. Defines the look of the border, is it thick or thin, solid or dashed, single or double. This enum replaces the CellStyle.BORDER_XXXXX constants which have been deprecated. The PropertyTemplate will not support the older style BORDER_XXXXX constants. A special value of BorderStyle.NONE will remove the border from a Cell once it is applied. Describes the portion of the region that the BorderStyle will apply to. For example, TOP, BOTTOM, INSIDE, or OUTSIDE. A special value of BorderExtent.NONE will remove the border from the PropertyTemplate. When the template is applied, no change will be made to a cell border where no border properties exist in the PropertyTemplate. // #1) these borders will all be medium in default color // #2) these cells will have medium outside borders and thin inside borders // #3) these cells will all be medium weight with different colors for the // outside, inside horizontal, and inside vertical borders. The center // cell will have no borders. NOTE: The last pt.drawBorders() call removes the borders from the range by using BorderStyle.NONE. Like setCellStyleProperties, the applyBorders method merges the properties of a cell style, so existing borders are changed only if they are replaced by something else, or removed only if they are replaced by BorderStyle.NONE. To remove a color from a border, use IndexedColor.AUTOMATIC.getIndex(). Additionally, to remove a border or color from the PropertyTemplate object, use BorderExtent.NONE. This does not work with diagonal borders yet."
    },
    {
        "link": "https://stackoverflow.com/questions/1516144/how-to-read-and-write-excel-file",
        "document": "I want to do the following:\n\nI want to read and write an Excel file from Java with 3 columns and N rows, printing one string in each cell. Can anyone give me simple code snippet for this? Do I need to use any external lib or does Java have built-in support for it?\n\nTry the Apache POI HSSF. Here's an example on how to read an excel file: try { POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream(file)); HSSFWorkbook wb = new HSSFWorkbook(fs); HSSFSheet sheet = wb.getSheetAt(0); HSSFRow row; HSSFCell cell; int rows; // No of rows rows = sheet.getPhysicalNumberOfRows(); int cols = 0; // No of columns int tmp = 0; // This trick ensures that we get the data properly even if it doesn't start from first few rows for(int i = 0; i < 10 || i < rows; i++) { row = sheet.getRow(i); if(row != null) { tmp = sheet.getRow(i).getPhysicalNumberOfCells(); if(tmp > cols) cols = tmp; } } for(int r = 0; r < rows; r++) { row = sheet.getRow(r); if(row != null) { for(int c = 0; c < cols; c++) { cell = row.getCell((short)c); if(cell != null) { // Your code here } } } } } catch(Exception ioe) { ioe.printStackTrace(); } On the documentation page you also have examples of how to write to excel files.\n\nApache POI can do this for you. Specifically the HSSF module. The quick guide is most useful. Here's how to do what you want - specifically create a sheet and write it out. Workbook wb = new HSSFWorkbook(); //Workbook wb = new XSSFWorkbook(); CreationHelper createHelper = wb.getCreationHelper(); Sheet sheet = wb.createSheet(\"new sheet\"); // Create a row and put some cells in it. Rows are 0 based. Row row = sheet.createRow((short)0); // Create a cell and put a value in it. Cell cell = row.createCell(0); cell.setCellValue(1); // Or do it on one line. row.createCell(1).setCellValue(1.2); row.createCell(2).setCellValue( createHelper.createRichTextString(\"This is a string\")); row.createCell(3).setCellValue(true); // Write the output to a file FileOutputStream fileOut = new FileOutputStream(\"workbook.xls\"); wb.write(fileOut); fileOut.close();\n\nFirst add all these jar files in your project class path: public static void main(String[] args) { //Blank workbook XSSFWorkbook workbook = new XSSFWorkbook(); //Create a blank sheet XSSFSheet sheet = workbook.createSheet(\"Employee Data\"); //This data needs to be written (Object[]) Map<String, Object[]> data = new TreeMap<String, Object[]>(); data.put(\"1\", new Object[]{\"ID\", \"NAME\", \"LASTNAME\"}); data.put(\"2\", new Object[]{1, \"Amit\", \"Shukla\"}); data.put(\"3\", new Object[]{2, \"Lokesh\", \"Gupta\"}); data.put(\"4\", new Object[]{3, \"John\", \"Adwards\"}); data.put(\"5\", new Object[]{4, \"Brian\", \"Schultz\"}); //Iterate over data and write to sheet Set<String> keyset = data.keySet(); int rownum = 0; for (String key : keyset) { //create a row of excelsheet Row row = sheet.createRow(rownum++); //get object array of prerticuler key Object[] objArr = data.get(key); int cellnum = 0; for (Object obj : objArr) { Cell cell = row.createCell(cellnum++); if (obj instanceof String) { cell.setCellValue((String) obj); } else if (obj instanceof Integer) { cell.setCellValue((Integer) obj); } } } try { //Write the workbook in file system FileOutputStream out = new FileOutputStream(new File(\"C:\\\\Documents and Settings\\\\admin\\\\Desktop\\\\imp data\\\\howtodoinjava_demo.xlsx\")); workbook.write(out); out.close(); System.out.println(\"howtodoinjava_demo.xlsx written successfully on disk.\"); } catch (Exception e) { e.printStackTrace(); } } /* * To change this template, choose Tools | Templates * and open the template in the editor. */ public static void main(String[] args) { try { FileInputStream file = new FileInputStream(new File(\"C:\\\\Documents and Settings\\\\admin\\\\Desktop\\\\imp data\\\\howtodoinjava_demo.xlsx\")); //Create Workbook instance holding reference to .xlsx file XSSFWorkbook workbook = new XSSFWorkbook(file); //Get first/desired sheet from the workbook XSSFSheet sheet = workbook.getSheetAt(0); //Iterate through each rows one by one Iterator<Row> rowIterator = sheet.iterator(); while (rowIterator.hasNext()) { Row row = rowIterator.next(); //For each row, iterate through all the columns Iterator<Cell> cellIterator = row.cellIterator(); while (cellIterator.hasNext()) { Cell cell = cellIterator.next(); //Check the cell type and format accordingly switch (cell.getCellType()) { case Cell.CELL_TYPE_NUMERIC: System.out.print(cell.getNumericCellValue() + \"\\t\"); break; case Cell.CELL_TYPE_STRING: System.out.print(cell.getStringCellValue() + \"\\t\"); break; } } System.out.println(\"\"); } file.close(); } catch (Exception e) { e.printStackTrace(); } }\n\nYou can not read & write same file in parallel(Read-write lock). But, we can do parallel operations on temporary data(i.e. Input/output stream). Write the data to file only after closing the input stream. Below steps should be followed.\n• Open the same file to an Output Stream\n• Read and do the processing import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.sql.Date; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; public class XLSXReaderWriter { public static void main(String[] args) { try { File excel = new File(\"D://raju.xlsx\"); FileInputStream fis = new FileInputStream(excel); XSSFWorkbook book = new XSSFWorkbook(fis); XSSFSheet sheet = book.getSheetAt(0); Iterator<Row> itr = sheet.iterator(); // Iterating over Excel file in Java while (itr.hasNext()) { Row row = itr.next(); // Iterating over each column of Excel file Iterator<Cell> cellIterator = row.cellIterator(); while (cellIterator.hasNext()) { Cell cell = cellIterator.next(); switch (cell.getCellType()) { case Cell.CELL_TYPE_STRING: System.out.print(cell.getStringCellValue() + \"\\t\"); break; case Cell.CELL_TYPE_NUMERIC: System.out.print(cell.getNumericCellValue() + \"\\t\"); break; case Cell.CELL_TYPE_BOOLEAN: System.out.print(cell.getBooleanCellValue() + \"\\t\"); break; default: } } System.out.println(\"\"); } // writing data into XLSX file Map<String, Object[]> newData = new HashMap<String, Object[]>(); newData.put(\"1\", new Object[] { 1d, \"Raju\", \"75K\", \"dev\", \"SGD\" }); newData.put(\"2\", new Object[] { 2d, \"Ramesh\", \"58K\", \"test\", \"USD\" }); newData.put(\"3\", new Object[] { 3d, \"Ravi\", \"90K\", \"PMO\", \"INR\" }); Set<String> newRows = newData.keySet(); int rownum = sheet.getLastRowNum(); for (String key : newRows) { Row row = sheet.createRow(rownum++); Object[] objArr = newData.get(key); int cellnum = 0; for (Object obj : objArr) { Cell cell = row.createCell(cellnum++); if (obj instanceof String) { cell.setCellValue((String) obj); } else if (obj instanceof Boolean) { cell.setCellValue((Boolean) obj); } else if (obj instanceof Date) { cell.setCellValue((Date) obj); } else if (obj instanceof Double) { cell.setCellValue((Double) obj); } } } // open an OutputStream to save written data into Excel file FileOutputStream os = new FileOutputStream(excel); book.write(os); System.out.println(\"Writing on Excel file Finished ...\"); // Close workbook, OutputStream and Excel file to prevent leak os.close(); book.close(); fis.close(); } catch (FileNotFoundException fe) { fe.printStackTrace(); } catch (IOException ie) { ie.printStackTrace(); } } }\n\nIf you need to do anything more with office documents in Java, go for POI as mentioned. For simple reading/writing an excel document like you requested, you can use the CSV format (also as mentioned): import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.util.Scanner; public class CsvWriter { public static void main(String args[]) throws IOException { String fileName = \"test.xls\"; PrintWriter out = new PrintWriter(new FileWriter(fileName)); out.println(\"a,b,c,d\"); out.println(\"e,f,g,h\"); out.println(\"i,j,k,l\"); out.close(); BufferedReader in = new BufferedReader(new FileReader(fileName)); String line = null; while ((line = in.readLine()) != null) { Scanner scanner = new Scanner(line); String sep = \"\"; while (scanner.hasNext()) { System.out.println(sep + scanner.next()); sep = \",\"; } } in.close(); } }\n\nThis will write a JTable to a tab separated file that can be easily imported into Excel. This works. If you save an Excel worksheet as an XML document you could also build the XML file for EXCEL with code. I have done this with word so you do not have to use third-party packages. This could code have the JTable taken out and then just write a tab separated to any text file and then import into Excel. I hope this helps. import java.io.File; import java.io.FileWriter; import java.io.IOException; import javax.swing.JTable; import javax.swing.table.TableModel; public class excel { String columnNames[] = { \"Column 1\", \"Column 2\", \"Column 3\" }; // Create some data String dataValues[][] = { { \"12\", \"234\", \"67\" }, { \"-123\", \"43\", \"853\" }, { \"93\", \"89.2\", \"109\" }, { \"279\", \"9033\", \"3092\" } }; JTable table; excel() { table = new JTable( dataValues, columnNames ); } public void toExcel(JTable table, File file){ try{ TableModel model = table.getModel(); FileWriter excel = new FileWriter(file); for(int i = 0; i < model.getColumnCount(); i++){ excel.write(model.getColumnName(i) + \"\\t\"); } excel.write(\"\n\n\"); for(int i=0; i< model.getRowCount(); i++) { for(int j=0; j < model.getColumnCount(); j++) { excel.write(model.getValueAt(i,j).toString()+\"\\t\"); } excel.write(\"\n\n\"); } excel.close(); }catch(IOException e){ System.out.println(e); } } public static void main(String[] o) { excel cv = new excel(); cv.toExcel(cv.table,new File(\"C:\\\\Users\\\\itpr13266\\\\Desktop\\\\cs.tbv\")); } }"
    },
    {
        "link": "https://poi.apache.org/apidocs/4.1",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://stackoverflow.com/questions/26342891/return-excel-file-created-in-servlet-as-response",
        "document": "I've created excel file using Apache POI and tried to return it as response to ajax call. I want the browser to prompt \"save the created file\" window. The problem is that I get gibbrish in the servlet's response and no prompts or whatsoever\n\nI've found similar problems here, on StackOverflow, but the solutions to their issues doesn't work for me (or I miss something).\n\nHere the problem was solved by using html tags, but I can't (as far as I know) use them in SAPUI5.\n\nAnd here is a very similar case, which I used for my matter, but it still doesn't work.\n\nHere is the client side code:\n\nAnd here is the servlet's code:\n\nThe file is created from a database 'select' wuery result set in a loop."
    },
    {
        "link": "https://stackoverflow.com/questions/13271786/return-excel-document-from-spring-controller-using-apache-poi",
        "document": "I am trying to send a Excel file back to the user. In some way my excel file gets corrupted even if it is empty. When I open the file Excel tells me that the file is corrupt.\n\nMy XML generation is very simple. Just empty document\n\nPlease any advice. I Was thinking of Springs Excel view but I dont want a view. Just a downloaded file."
    },
    {
        "link": "https://medium.com/@bouguern.mohamed/reading-and-writing-excel-data-in-spring-boot-with-apache-poi-139753529ebe",
        "document": "The class is a Spring Boot service that provides functionalities to read from and write to Excel files using Apache POI. Below is a detailed explanation of its key components:\n\nA logger is used to log information, warnings, and errors.\n\nThis method saves an object to the database using the repository.\n\nThis method generates an Excel file with employee information and writes it to the HTTP response.\n• Retrieve Employees: Fetches all employees from the repository.\n• Create Workbook and Sheet: Initializes an and creates a sheet named \"Employees Info\".\n• Create Header Row: Sets up the header row with column names.\n• Populate Data Rows: Iterates through the employees and populates the rows with their data.\n• Auto-size Columns: Adjusts the width of the columns to fit the content.\n• Write to Response: Writes the workbook to the HTTP response output stream.\n\nThis method reads data from an existing Excel file and converts it into a list of objects.\n• Initialize Workbook: Opens the Excel file specified by .\n• Iterate Sheets: Logs the number of sheets and iterates through them.\n• Data Formatter: Uses to format cell values as strings.\n• Parse Rows: Skips the header row and parses the remaining rows to create objects.\n• Close Workbook: Ensures the workbook is closed after reading to free up resources.\n\n@Override\n\npublic List<Course> readExcelFile() {\n\n List<Course> courses = new ArrayList<>();\n\n Workbook workbook = null;\n\n\n\n try {\n\n workbook = WorkbookFactory.create(new File(CSV_FILE_LOCATION));\n\n logger.info(\"Number of sheets: \" + workbook.getNumberOfSheets());\n\n\n\n workbook.forEach(sheet -> {\n\n logger.info(\"Title of sheet => \" + sheet.getSheetName());\n\n\n\n DataFormatter dataFormatter = new DataFormatter();\n\n int index = 0;\n\n for (Row row : sheet) {\n\n if (index++ == 0) continue;\n\n Course course = new Course();\n\n\n\n if (row.getCell(0) != null && row.getCell(0).getCellType() == CellType.NUMERIC) {\n\n course.setId((int) row.getCell(0).getNumericCellValue());\n\n }\n\n\n\n if (row.getCell(1) != null) {\n\n course.setName(dataFormatter.formatCellValue(row.getCell(1)));\n\n }\n\n\n\n Cell dateCell = row.getCell(2);\n\n if (DateUtil.isCellDateFormatted(dateCell)) {\n\n LocalDate date = dateCell.getDateCellValue().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n\n course.setDate(date);\n\n }\n\n\n\n if (row.getCell(3) != null && row.getCell(3).getCellType() == CellType.NUMERIC) {\n\n course.setNumber((int) row.getCell(3).getNumericCellValue());\n\n }\n\n courses.add(course);\n\n }\n\n });\n\n } catch (EncryptedDocumentException | IOException e) {\n\n logger.error(e.getMessage(), e);\n\n } finally {\n\n try {\n\n if (workbook != null) workbook.close();\n\n } catch (IOException e) {\n\n logger.error(e.getMessage(), e);\n\n }\n\n }\n\n\n\n return courses;\n\n}\n\nHere’s the complete code for the class:\n\npackage bouguern.tuto.demo.service;\n\n\n\nimport java.io.File;\n\nimport java.io.IOException;\n\nimport java.sql.Date;\n\nimport java.time.LocalDate;\n\nimport java.time.ZoneId;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\n\n\nimport org.apache.poi.EncryptedDocumentException;\n\nimport org.apache.poi.hssf.usermodel.HSSFCell;\n\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\n\nimport org.apache.poi.hssf.usermodel.HSSFDataFormat;\n\nimport org.apache.poi.hssf.usermodel.HSSFRow;\n\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\n\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\n\nimport org.apache.poi.ss.usermodel.Cell;\n\nimport org.apache.poi.ss.usermodel.CellType;\n\nimport org.apache.poi.ss.usermodel.DataFormatter;\n\nimport org.apache.poi.ss.usermodel.DateUtil;\n\nimport org.apache.poi.ss.usermodel.Row;\n\nimport org.apache.poi.ss.usermodel.Workbook;\n\nimport org.apache.poi.ss.usermodel.WorkbookFactory;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.stereotype.Service;\n\n\n\nimport bouguern.tuto.demo.entity.Course;\n\nimport bouguern.tuto.demo.entity.Employee;\n\nimport bouguern.tuto.demo.repository.EmployeeRepository;\n\nimport jakarta.servlet.ServletOutputStream;\n\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport lombok.RequiredArgsConstructor;\n\n\n\n@Service\n\n@RequiredArgsConstructor\n\npublic class ReportServiceImpl implements ReportService {\n\n\n\n private static final Logger logger = LoggerFactory.getLogger(ReportServiceImpl.class);\n\n\n\n private final EmployeeRepository employeeRepository;\n\n\n\n /**\n\n * You must create \"demo.xlsx\" before testing this API\n\n * And enter some data inside the file with 4 columns\n\n */\n\n private static final String CSV_FILE_LOCATION = \"C:/Users/admin/Documents/demo.xlsx\";\n\n\n\n @Override\n\n public Employee saveEmployee(Employee employee) {\n\n return employeeRepository.save(employee);\n\n }\n\n\n\n @Override\n\n public void generateExcel(HttpServletResponse response) throws Exception {\n\n\n\n List<Employee> employees = employeeRepository.findAll();\n\n\n\n HSSFWorkbook workbook = new HSSFWorkbook();\n\n HSSFSheet sheet = workbook.createSheet(\"Employees Info\");\n\n HSSFRow row = sheet.createRow(0);\n\n\n\n row.createCell(0).setCellValue(\"ID employee\");\n\n row.createCell(1).setCellValue(\"First Name\");\n\n row.createCell(2).setCellValue(\"Last Name\");\n\n row.createCell(3).setCellValue(\"Started Date\");\n\n\n\n // Create date cell style\n\n HSSFCellStyle dateCellStyle = workbook.createCellStyle();\n\n HSSFDataFormat dateFormat = workbook.createDataFormat();\n\n // dateCellStyle.setDataFormat(dateFormat.getFormat(\"yyyy-mm-dd\"));\n\n dateCellStyle.setDataFormat(dateFormat.getFormat(\"dd-mm-yyyy\"));\n\n\n\n int dataRowIndex = 1;\n\n\n\n for (Employee employee : employees) {\n\n HSSFRow dataRow = sheet.createRow(dataRowIndex);\n\n dataRow.createCell(0).setCellValue(employee.getEmployeeId());\n\n dataRow.createCell(1).setCellValue(employee.getFirstName());\n\n dataRow.createCell(2).setCellValue(employee.getLastName());\n\n\n\n // Set the date value with the date format style\n\n if(employee.getStartedDateInCompany() != null) {\n\n HSSFCell dateCell = dataRow.createCell(3);\n\n dateCell.setCellValue(Date.valueOf(employee.getStartedDateInCompany()));\n\n dateCell.setCellStyle(dateCellStyle);\n\n }\n\n\n\n dataRowIndex++;\n\n }\n\n\n\n // Auto-size columns\n\n for (int i = 0; i < 4; i++) {\n\n sheet.autoSizeColumn(i);\n\n }\n\n\n\n ServletOutputStream ops = response.getOutputStream();\n\n workbook.write(ops);\n\n workbook.close();\n\n ops.close();\n\n\n\n }\n\n\n\n @Override\n\n public List<Course> readExcelFile() {\n\n\n\n List<Course> courses = new ArrayList<>();\n\n\n\n Workbook workbook = null;\n\n try {\n\n // Creating a Workbook from an Excel file (.xls or .xlsx)\n\n workbook = WorkbookFactory.create(new File(CSV_FILE_LOCATION));\n\n\n\n // Retrieving the number of sheets in the Workbook\n\n logger.info(\"Number of sheets: \" + workbook.getNumberOfSheets());\n\n\n\n // Print all sheets name\n\n workbook.forEach(sheet -> {\n\n logger.info(\"Title of sheet => \" + sheet.getSheetName());\n\n\n\n // Create a DataFormatter to format and get each cell's value as String\n\n DataFormatter dataFormatter = new DataFormatter();\n\n\n\n // Loop through all rows and columns and create Course object\n\n int index = 0;\n\n for (Row row : sheet) {\n\n if (index++ == 0)\n\n continue;\n\n Course course = new Course();\n\n\n\n if (row.getCell(0) != null && row.getCell(0).getCellType() == CellType.NUMERIC) {\n\n course.setId((int) row.getCell(0).getNumericCellValue());\n\n }\n\n\n\n if (row.getCell(1) != null) {\n\n course.setName(dataFormatter.formatCellValue(row.getCell(1)));\n\n }\n\n\n\n Cell dateCell = row.getCell(2);\n\n if (DateUtil.isCellDateFormatted(dateCell)) {\n\n LocalDate date = dateCell.getDateCellValue().toInstant().atZone(ZoneId.systemDefault())\n\n .toLocalDate();\n\n course.setDate(date);\n\n }\n\n\n\n if (row.getCell(3) != null && row.getCell(3).getCellType() == CellType.NUMERIC) {\n\n course.setNumber((int) row.getCell(3).getNumericCellValue());\n\n }\n\n courses.add(course);\n\n }\n\n });\n\n } catch (EncryptedDocumentException | IOException e) {\n\n logger.error(e.getMessage(), e);\n\n } finally {\n\n try {\n\n if (workbook != null)\n\n workbook.close();\n\n } catch (IOException e) {\n\n logger.error(e.getMessage(), e);\n\n }\n\n }\n\n\n\n return courses;\n\n }\n\n\n\n}"
    },
    {
        "link": "https://coderanch.com/t/466572/open-source/Export-Excel-servlet-POI-working",
        "document": "Export to Excel via a servlet with POI not working under internet explorer 6"
    },
    {
        "link": "https://coderanch.com/t/359231/java/Servlet-output-result-Excel-POI",
        "document": "this forum made possible by our volunteer staff, including ..."
    }
]