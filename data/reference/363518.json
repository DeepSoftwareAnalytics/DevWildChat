[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/JSON",
        "document": "JavaScript Object Notation (JSON) is a standard text-based format for representing structured data based on JavaScript object syntax. It is commonly used for transmitting data in web applications (e.g., sending some data from the server to the client, so it can be displayed on a web page, or vice versa). You'll come across it quite often, so in this article, we give you all you need to work with JSON using JavaScript, including parsing JSON so you can access data within it, and creating JSON. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What JSON is — a very commonly used data format based on JavaScript object syntax.\n• That JSON can also contain arrays.\n• Retrieve JSON as a JavaScript object using mechanisms available in Web APIs (for example, in the Fetch API).\n• Converting between objects and text using and .\n\nNo, really, what is JSON? JSON is a text-based data format following JavaScript object syntax. It represents structured data as a string, which is useful when you want to transmit data across a network. Even though it closely resembles JavaScript object literal syntax, it can be used independently from JavaScript. Many programming environments feature the ability to read (parse) and generate JSON. In JavaScript, the methods for parsing and generating JSON are provided by the object. Note: Converting a string to a native object is called deserialization, while converting a native object to a string so it can be transmitted across the network is called serialization. A JSON string can be stored in its own file, which is basically just a text file with an extension of , and a MIME type of .\n\nAs described above, JSON is a string whose format very much resembles JavaScript object literal format. The following is a valid JSON string representing an object. Note how it is also a valid JavaScript object literal — just with some more syntax restrictions. { \"squadName\": \"Super hero squad\", \"homeTown\": \"Metro City\", \"formed\": 2016, \"secretBase\": \"Super tower\", \"active\": true, \"members\": [ { \"name\": \"Molecule Man\", \"age\": 29, \"secretIdentity\": \"Dan Jukes\", \"powers\": [\"Radiation resistance\", \"Turning tiny\", \"Radiation blast\"] }, { \"name\": \"Madame Uppercut\", \"age\": 39, \"secretIdentity\": \"Jane Wilson\", \"powers\": [ \"Million tonne punch\", \"Damage resistance\", \"Superhuman reflexes\" ] }, { \"name\": \"Eternal Flame\", \"age\": 1000000, \"secretIdentity\": \"Unknown\", \"powers\": [ \"Immortality\", \"Heat Immunity\", \"Inferno\", \"Teleportation\", \"Interdimensional travel\" ] } ] } If you load this JSON in your JavaScript program as a string, you can parse it into a normal object and then access the data inside it using the same dot/bracket notation we looked at in the JavaScript object basics article. For example:\n• First, we have the variable name — .\n• Inside that, we want to access the property, so we use .\n• contains an array populated by objects. We want to access the second object inside the array, so we use .\n• Inside this object, we want to access the property, so we use .\n• Inside the property is an array containing the selected hero's superpowers. We want the third one, so we use . The key takeaway is that there's really nothing special about working with JSON; after you've parsed it into a JavaScript object, you work with it just like you would with an object declared using the same object literal syntax. Note: We've made the JSON seen above available inside a variable in our JSONTest.html example (see the source code). Try loading this up and then accessing data inside the variable via your browser's JavaScript console.\n\nAbove we mentioned that JSON text basically looks like a JavaScript object inside a string. We can also convert arrays to/from JSON. The below example is perfectly valid JSON: You have to access array items (in its parsed version) by starting with an array index, for example . The JSON can also contain a single primitive. For example, , , or are all valid JSON.\n\nTo begin with, make local copies of our heroes.html and style.css files. The latter contains some simple CSS to style our page, while the former contains some very simple body HTML, plus a element to contain the JavaScript code we will be writing in this exercise: We have made our JSON data available on our GitHub, at https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json. We are going to load the JSON into our script, and use some nifty DOM manipulation to display it, like this:\n\nThe top-level function looks like this: To obtain the JSON, we use an API called Fetch. This API allows us to make network requests to retrieve resources from a server via JavaScript (e.g. images, text, JSON, even HTML snippets), meaning that we can update small sections of content without having to reload the entire page. In our function, the first four lines use the Fetch API to fetch the JSON from the server:\n• we declare the variable to store the GitHub URL\n• we use the URL to initialize a new object.\n• we make the network request using the function, and this returns a object\n• we retrieve the response as JSON using the function of the object. Note: The API is asynchronous. You can learn about asynchronous functions in detail in our Asynchronous JavaScript module, but for now, we'll just say that we need to add the keyword before the name of the function that uses the fetch API, and add the keyword before the calls to any asynchronous functions. After all that, the variable will contain the JavaScript object based on the JSON. We are then passing that object to two function calls — the first one fills the with the correct data, while the second one creates an information card for each hero on the team, and inserts it into the .\n\nNow that we've retrieved the JSON data and converted it into a JavaScript object, let's make use of it by writing the two functions we referenced above. First of all, add the following function definition below the previous code: Here we first create an h1 element with , set its to equal the property of the object, then append it to the header using . We then do a very similar operation with a paragraph: create it, set its text content and append it to the header. The only difference is that its text is set to a template literal containing both the and properties of the object.\n\nNext, add the following function at the bottom of the code, which creates and displays the superhero cards: function populateHeroes(obj) { const section = document.querySelector(\"section\"); const heroes = obj.members; for (const hero of heroes) { const myArticle = document.createElement(\"article\"); const myH2 = document.createElement(\"h2\"); const myPara1 = document.createElement(\"p\"); const myPara2 = document.createElement(\"p\"); const myPara3 = document.createElement(\"p\"); const myList = document.createElement(\"ul\"); myH2.textContent = hero.name; myPara1.textContent = `Secret identity: ${hero.secretIdentity}`; myPara2.textContent = `Age: ${hero.age}`; myPara3.textContent = \"Superpowers:\"; const superPowers = hero.powers; for (const power of superPowers) { const listItem = document.createElement(\"li\"); listItem.textContent = power; myList.appendChild(listItem); } myArticle.appendChild(myH2); myArticle.appendChild(myPara1); myArticle.appendChild(myPara2); myArticle.appendChild(myPara3); myArticle.appendChild(myList); section.appendChild(myArticle); } } To start with, we store the property of the JavaScript object in a new variable. This array contains multiple objects that contain the information for each hero. Next, we use a for...of loop to loop through each object in the array. For each one, we:\n• Create several new elements: an , an , three s, and a .\n• Set the to contain the current hero's .\n• Fill the three paragraphs with their , , and a line saying \"Superpowers:\" to introduce the information in the list.\n• Store the property in another new constant called — this contains an array that lists the current hero's superpowers.\n• Use another loop to loop through the current hero's superpowers — for each one we create an element, put the superpower inside it, then put the inside the element ( ) using .\n• The very last thing we do is to append the , s, and inside the ( ), then append the inside the . The order in which things are appended is important, as this is the order they will be displayed inside the HTML. Note: If you are having trouble getting the example to work, try referring to our heroes-finished.html source code (see it running live also.) Note: If you are having trouble following the dot/bracket notation we are using to access the JavaScript object, it can help to have the superheroes.json file open in another tab or your text editor, and refer to it as you look at our JavaScript. You should also refer back to our JavaScript object basics article for more information on dot and bracket notation.\n\nThe above example was simple in terms of accessing the JavaScript object, because we converted the network response directly into a JavaScript object using . But sometimes we aren't so lucky — sometimes we receive a raw JSON string, and we need to convert it to an object ourselves. And when we want to send a JavaScript object across the network, we need to convert it to JSON (a string) before sending it. Luckily, these two problems are so common in web development that a built-in JSON object is available in browsers, which contains the following two methods:\n• : Accepts a JSON string as a parameter, and returns the corresponding JavaScript object.\n• : Accepts an object as a parameter, and returns the equivalent JSON string. You can see the first one in action in our heroes-finished-json-parse.html example (see the source code) — this does exactly the same thing as the example we built up earlier, except that:\n• we retrieve the response as text rather than JSON, by calling the method of the response\n• we then use to convert the text to a JavaScript object. The key snippet of code is here: As you might guess, works the opposite way. Try entering the following lines into your browser's JavaScript console one by one to see it in action: let myObj = { name: \"Chris\", age: 38 }; myObj; let myString = JSON.stringify(myObj); myString; Here we're creating a JavaScript object, then checking what it contains, then converting it to a JSON string using — saving the return value in a new variable — then checking it again."
    },
    {
        "link": "https://stackoverflow.blog/2022/06/02/a-beginners-guide-to-json-the-data-format-for-the-internet",
        "document": "As the web grows in popularity and power, so does the amount of data stored and transferred between systems, many of which know nothing about each other. From early on, the format that this data was transferred in mattered, and like the web, the best formats were open standards that anyone could use and contribute to. XML gained early popularity, as it looked like HTML, the foundation of the web. But it was clunky and confusing.\n\nThat’s where JSON (JavaScript Object Notation) comes in. If you’ve consumed an API in the last five to ten years, you’ve probably seen JSON data. While the format was first developed in the early 2000s, the first standards were published in 2006. Understanding what JSON is and how it works is a foundational skill for any web developer.\n\nIn this article, we’ll cover the basics of what JSON looks like and how to use it in your web applications, as well as talk about serialized JSON—JST and JWT—and the competing data formats.\n\nWhat JSON looks like\n\nJSON is a human-readable format for storing and transmitting data. As the name implies, it was originally developed for JavaScript, but can be used in any language and is very popular in web applications. The basic structure is built from one or more keys and values:\n\nYou’ll often see a collection of key:value pairs enclosed in brackets described as a JSON object. While the key is any string, the value can be a string, number, array, additional object, or the literals, false, true and null. For example, the following is valid JSON:\n\nJSON doesn't have to have only key:value pairs; the specification allows to any value to be passed without a key. However, almost all of the JSON objects that you see will contain key:value pairs.\n\nOne of the most common uses for JSON is when using an API, both in requests and responses. It is much more compact than other standards and allows for easy consumption in web browsers as JavaScript can easily parse JSON strings, only requiring JSON.parse() to start using it.\n\nJSON.parse(string) takes a string of valid JSON and returns a JavaScript object. For example, it can be called on the body of an API response to give you a usable object. The inverse of this function is JSON.stringify(object) which takes a JavaScript object and returns a string of JSON, which can then be transmitted in an API request or response.\n\nJSON isn’t required by REST or GraphQL, both very popular API formats. However, they are often used together, particularly with GraphQL, where it is best practice to use JSON due to it being small and mostly text. If necessary, it compresses very well with GZIP.\n\nGraphQL's requests aren’t made in JSON, instead using a system that resembles JSON, like this\n\nWhich will return the relevant data, and if using JSON, it will match very closely:\n\nIn some cases, you may want to load JSON from a file, such as for configuration files or mock data. Using pure JavaScript, it currently isn’t possible to import a JSON file, however a proposal has been created to allow this. In addition, it is a very common feature in bundlers and compilers, like webpack and Babel. Currently, you can get equivalent functionality by exporting a JavaScript Object the same as your desired JSON from a JavaScript file.\n\nNow this object will be stored in the constant, data, and will be accessible throughout your application using import or require statements. Note that this will import a copy of the data, so modifying the object won’t write the data back to the file or allow the modified data to be used in other files.\n\nOnce you have a variable containing your data, in this example data, to access a key’s value inside it, you could use either data.key or data[\"key\"]. Square brackets must be used for array indexing; for example if that value was an array, you could do data.key[0], but data.key.0 wouldn’t work.\n\nObject modification works in the same way. You can just set data.key = \"foo\" and that key will now have the value “foo”. Although only the final element in the chain of objects can be replaced; for example if you tried to set data.key.foo.bar to something, it would fail as you would first have to set data.key.foo to an object.\n\nJSON isn’t the only web-friendly data standard out there. The major competitor for JSON in APIs is XML. Instead of the following JSON:\n\nin XML, you’d instead have:\n\nJSON was standardized much later than XML, with the specification for XML coming in 1998, whereas Ecma International standardized JSON in 2013. XML was extremely popular and seen in standards such as AJAX (Asynchronous JavaScript and XML) and the XMLHttpRequest function in JavaScript.\n\nXML used by a major API standard: Simple Object Access Protocol (SOAP). This standard can be significantly more verbose than REST and GraphQL, in part due to the usage of XML and because the standard includes more information, such as describing the XML namespace as part of the envelope system. This might be a reason why SOAP usage has declined for years.\n\nAnother alternative is YAML, which is much more similar in length to JSON compared to XML, with the same example being:\n\nHowever, unlike XML, YAML doesn’t really compete with JSON as an API data format. Instead, it’s primarily used for configuration files— Kubernetes primarily uses YAML to configure infrastructure. YAML offers features that JSON doesn’t have, such as comments. Unlike JSON and XML, browsers cannot parse YAML, so a parser would need to be added as a library if you want to use YAML for data interchange.\n\nWhile many of JSONs use cases transmit it as clear text, the format can be used for secure data transfers as well. JSON web signatures (JWS) are JSON objects securely signed using either a secret or a public/private key pair. These are composed of a header, payload, and signature.\n\nThe header specifies the type of token and the signing algorithm being used. The only required field is alg to specify the encryption algorithm used, but many other keys can be included, such as typ for the type of signature it is.\n\nThe payload of a JWS is the information being transmitted and doesn’t need to be formatted in JSON though commonly is.\n\nThe signature is constructed by applying the encryption algorithm specified in the header to the base64 versions of the header and payload joined by a dot. The final JWS is then the base64 header, base64 payload, and signature joined by dots. For example:\n\nJSON Web Tokens (JWT) are a special form of a JWS. These are particularly useful for authorization: when a user logs into a website, they will be provided with a JWT. For each subsequent request, they will include this token as a bearer token in the authorization header.\n\nTo create a JWT from a JWS, you’ll need to configure each section specifically. In the header, ensure that the typ key is JWT. For the alg key, the options of HS256 (HMAC SHA-256) and none (unencrypted) must be supported by the authorization server in order to be a conforming JWT implementation, so can always be used. Additional algorithms are recommended but not enforced.\n\nIn the payload are a series of keys called claims, which are pieces of information about a subject, as JWTs are most commonly used for authentication, this is commonly a user, but could be anything when used for exchanging information.\n\nThe signature is then constructed in the same way as all other JWSs.\n\nCompared to Security Assertion Markup Language Tokens (SAML), a similar standard that uses XML, JSON allows for JWTs to be smaller than SAML tokens and is easier to parse due to the use of both tokens in the browser, where JavaScript is the primary language, and can easily parse JSON.\n\nJSON has come to be one of the most popular standards for data interchange, being easy for humans to read while being lightweight to ensure small transmission size. Its success has also been caused by it being equivalent to JavaScript objects, making it simple to process in web frontends. However, JSON isn’t the solution for everything, and alternate standards like YAML are more popular for things like configuration files, so it’s important to consider your purpose before choosing."
    },
    {
        "link": "https://stackoverflow.com/questions/12806386/is-there-any-standard-for-json-api-response-format",
        "document": "Do standards or best practices exist for structuring JSON responses from an API? Obviously, every application's data is different, so that much I'm not concerned with, but rather the \"response boilerplate\", if you will. An example of what I mean:\n\nAssuming you question is about REST webservices design and more precisely concerning success/error. I think there are 3 different types of design.\n• None Use only HTTP Status code to indicate if there was an error and try to limit yourself to the standard ones (usually it should suffice).\n• Pros: It is a standard independent of your api.\n• Cons: Less information on what really happened.\n• None Use HTTP Status + json body (even if it is an error). Define a uniform structure for errors (ex: code, message, reason, type, etc) and use it for errors, if it is a success then just return the expected json response.\n• Pros: Still standard as you use the existing HTTP status codes and you return a json describing the error (you provide more information on what happened).\n• Cons: The output json will vary depending if it is a error or success.\n• None Forget the http status (ex: always status 200), always use json and add at the root of the response a boolean responseValid and a error object (code,message,etc) that will be populated if it is an error otherwise the other fields (success) are populated.\n• None Pros: The client deals only with the body of the response that is a json string and ignores the status(?). It's up to you to choose :) Depending on the API I would choose 2 or 3 (I prefer 2 for json rest apis). Another thing I have experienced in designing REST Api is the importance of documentation for each resource (url): the parameters, the body, the response, the headers etc + examples. I would also recommend you to use jersey (jax-rs implementation) + genson (java/json databinding library). You only have to drop genson + jersey in your classpath and json is automatically supported.\n• None Solution 2 is the hardest to implement but the advantage is that you can nicely handle exceptions and not only business errors, initial effort is more important but you win on the long term.\n• None Solution 3 is the easy to implement on both, server side and client but it's not so nice as you will have to encapsulate the objects you want to return in a response object containing also the responseValid + error.\n\nI will not be as arrogant to claim that this is a standard so I will use the \"I prefer\" form. I prefer terse response (when requesting a list of /articles I want a JSON array of articles). In my designs I use HTTP for status report, a 200 returns just the payload. 400 returns a message of what was wrong with request: If there was error with processing on my side, I return 501 with a message: {\"message\" : \"Could not connect to data store.\"} From what I've seen quite a few REST-ish frameworks tend to be along these lines. JSON is supposed to be a payload format, it's not a session protocol. The whole idea of verbose session-ish payloads comes from the XML/SOAP world and various misguided choices that created those bloated designs. After we realized all of it was a massive headache, the whole point of REST/JSON was to KISS it, and adhere to HTTP. I don't think that there is anything remotely standard in either JSend and especially not with the more verbose among them. XHR will react to HTTP response, if you use jQuery for your AJAX (like most do) you can use / and / callbacks to capture errors. I can't see how encapsulating status reports in JSON is any more useful than that.\n\nFor what it's worth I do this differently. A successful call just has the JSON objects. I don't need a higher level JSON object that contains a success field indicating true and a payload field that has the JSON object. I just return the appropriate JSON object with a 200 or whatever is appropriate in the 200 range for the HTTP status in the header. However, if there is an error (something in the 400 family) I return a well-formed JSON error object. For example, if the client is POSTing a User with an email address and phone number and one of these is malformed (i.e. I cannot insert it into my underlying database) I will return something like this: Important bits here are that the \"field\" property must match the JSON field exactly that could not be validated. This allows clients to know exactly what went wrong with their request. Also, \"message\" is in the locale of the request. If both the \"emailAddress\" and \"phoneNumber\" were invalid then the \"errors\" array would contain entries for both. A 409 (Conflict) JSON response body might look like this: { \"description\" : \"Already Exists\" \"errors\" : [ { \"field\" : \"phoneNumber\", \"message\" : \"Phone number already exists for another user.\" } ], } With the HTTP status code and this JSON the client has all they need to respond to errors in a deterministic way and it does not create a new error standard that tries to complete replace HTTP status codes. Note, these only happen for the range of 400 errors. For anything in the 200 range I can just return whatever is appropriate. For me it is often a HAL-like JSON object but that doesn't really matter here. The one thing I thought about adding was a numeric error code either in the the \"errors\" array entries or the root of the JSON object itself. But so far we haven't needed it.\n\nThe point of JSON is that it is completely dynamic and flexible. Bend it to whatever whim you would like, because it's just a set of serialized JavaScript objects and arrays, rooted in a single node. What the type of the rootnode is is up to you, what it contains is up to you, whether you send metadata along with the response is up to you, whether you set the mime-type to or leave it as is up to you (as long as you know how to handle the edge cases). Build a lightweight schema that you like.\n\n Personally, I've found that analytics-tracking and mp3/ogg serving and image-gallery serving and text-messaging and network-packets for online gaming, and blog-posts and blog-comments all have very different requirements in terms of what is sent and what is received and how they should be consumed. So the last thing I'd want, when doing all of that, is to try to make each one conform to the same boilerplate standard, which is based on XML2.0 or somesuch. That said, there's a lot to be said for using schemas which make sense to you and are well thought out.\n\n Just read some API responses, note what you like, criticize what you don't, write those criticisms down and understand why they rub you the wrong way, and then think about how to apply what you learned to what you need.\n\nI used to follow this standard, was pretty good, easy, and clean on the client layer. Normally, the HTTP status 200, so that's a standard check which I use at the top. and I normally use the following JSON I also use a template for the API's dynamic response; try { // query and what not. response.payload = new { data = new { pagination = new Pagination(), customer = new Customer(), notifications = 5 } } // again something here if we get here success has to be true // I follow an exit first strategy, instead of building a pyramid // of doom. response.success = true; } catch(Exception exception){ response.success = false; response.message = exception.GetStackTrace(); _logger.Fatal(exception, this.GetFacadeName()) } return response; { \"success\": boolean, \"message\": \"some message\", \"payload\": { \"data\" : [] \"message\": \"\" ... // put whatever you want to here. } } on the client layer I would use the following: if(response.code != 200) { // woops something went wrong. return; } if(!response.success){ console.debug ( response.message ); return; } // if we are here then success has to be true. if(response.payload) { .... } notice how I break early avoiding the pyramid of doom.\n\nThere is no lawbreaking or outlaw standard other than common sense. If we abstract this like two people talking, the standard is the best way they can accurately understand each other in minimum words in minimum time. In our case, 'minimum words' is optimizing bandwidth for transport efficiency and 'accurately understand' is the structure for parser efficiency; which ultimately ends up with the less the data, and the common the structure; so that it can go through a pin hole and can be parsed through a common scope (at least initially). Almost in every cases suggested, I see separate responses for 'Success' and 'Error' scenario, which is kind of ambiguity to me. If responses are different in these two cases, then why do we really need to put a 'Success' flag there? Is it not obvious that the absence of 'Error' is a 'Success'? Is it possible to have a response where 'Success' is TRUE with an 'Error' set? Or the way, 'Success' is FALSE with no 'Error' set? Just one flag is not enough? I would prefer to have the 'Error' flag only, because I believe there will be less 'Error' than 'Success'. Also, should we really make the 'Error' a flag? What about if I want to respond with multiple validation errors? So, I find it more efficient to have an 'Error' node with each error as child to that node; where an empty (counts to zero) 'Error' node would denote a 'Success'."
    },
    {
        "link": "https://apidog.com/blog/json-api-responses",
        "document": "APIs (Application Programming Interfaces) have emerged as the cornerstone of software development, enabling disparate systems to communicate and share data seamlessly. As we delve into the world of APIs, one aspect that stands out is the format of the responses they return. The JSON (JavaScript Object Notation) format has become the de facto standard for API responses, prized for its simplicity, ease of use, and language-agnostic nature.\n\nIn this blog post, we’ll explore the intricacies of API response JSON format, often referred to as the lingua franca of the web. We’ll uncover why developers favor it, how it streamlines the process of data interchange, and the best practices for structuring JSON responses. Whether you’re a seasoned developer or just starting out, understanding the nuances of JSON will enhance your ability to design, consume, and debug APIs.\n\nAPIs, or Application Programming Interfaces, are the unsung heroes of our connected world. They are the conduits through which different software applications exchange data and functionalities, making them integral to the seamless operation of the digital ecosystem.\n\nAt their core, APIs are sets of rules and protocols that dictate how software components should interact. They enable developers to tap into existing services and platforms, leveraging their capabilities without having to reinvent the wheel. This not only saves time and resources but also fosters innovation by allowing for the integration of diverse technologies.\n\nThe significance of APIs cannot be overstated. They are the building blocks of modern software development, powering everything from web applications to mobile apps, and from cloud services to IoT devices. APIs facilitate the interoperability between systems, making it possible for your favorite apps to communicate with one another, share data, and offer a cohesive user experience.\n\nThe Role of JSON in API Responses\n\nJSON, or JavaScript Object Notation, plays a pivotal role in API responses due to its lightweight nature and easy readability. It serves as a universal language for data interchange between servers and web applications.\n• Human-readable: JSON is self-describing and easy to understand, even for those who are not developers.\n• Lightweight: Its simplicity allows for quick parsing and a smaller data footprint compared to other formats like XML.\n• Language-agnostic: JSON is supported by most programming languages, making it highly versatile for backend and frontend development.\n\nWhen an API is called, the server responds with a JSON-formatted text that represents the data requested. This could be anything from user information to a list of products. The JSON format ensures that this data can be easily parsed by the client application and used as needed.\n\nFor example, a simple API response in JSON format might look like this:\n\nIn this snippet, we see a user object with properties and values encoded in a way that’s both easy to read and easy to process programmatically.\n\nThe Impact of JSON on APIs\n\nThe adoption of JSON has streamlined the development process, enabling faster, more efficient, and more reliable data exchange. It has become the backbone of RESTful APIs, which are the standard for web services today.\n\nAnatomy of an API Response in JSON Format\n\nThe anatomy of an API response in JSON format is akin to the structure of a well-organized document. It consists of key-value pairs that represent data in a structured, hierarchical manner. Let’s dissect this anatomy to understand its components better.\n\nAt the highest level, a JSON response typically starts with a root element, which can be either an object or an array. An object is denoted by curly braces , while an array is denoted by square brackets .\n\nAn object represents a single entity and contains one or more key-value pairs. The keys are strings, and the values can be strings, numbers, objects, arrays, , , or .\n\nAn array is an ordered collection of values, which can be of any type, including objects and other arrays.\n\nThe key-value pairs within an object are the fundamental units of data representation in JSON. They are separated by commas, and the key and value are separated by a colon.\n\nIn this example:\n• The root element is an object.\n• The object contains three key-value pairs: , , and .\n• The key contains an object with its own nested key-value pairs.\n• The key within the object contains an array of values.\n• The key within the object contains another object.\n\nUnderstanding the structure of a JSON API response is crucial for developers as it allows them to parse the data correctly and integrate it into their applications. It’s the clarity and predictability of this structure that make JSON an invaluable format in the world of APIs.\n\nThe API response JSON format in Apidog is designed to be intuitive and easy to work with for developers.\n\nIt typically includes the following components:\n• Status Code: Indicates the result of the API call, such as success or error.\n• Headers: Provide metadata about the response, like content type and cache directives.\n• Body: Contains the actual data payload, formatted as a JSON object or array.\n\nFor example, a successful response from an API might look like this:\n\nApidog emphasizes clear documentation and structured responses to ensure efficient data exchange and error handling.\n\nWhen structuring JSON API responses, adhering to best practices is crucial for ensuring that the data is easily consumable and maintainable. Here are some guidelines to follow:\n\n1. Keep it Intuitive and Consistent\n• Use clear, descriptive key names that accurately reflect the data they hold.\n• Maintain a consistent structure across all API endpoints to avoid confusion.\n• While JSON allows for nesting, overdoing it can make the response complex and harder to parse. Limit nesting to what’s necessary for logical grouping.\n• Leverage HTTP status codes to indicate the success or failure of an API request. This helps clients handle responses appropriately.\n• In case of an error, include a message that explains what went wrong and possibly how to fix it.\n• For endpoints that can return large data sets, implement pagination to improve performance and usability.\n\n6. HATEOAS (Hypermedia as the Engine of Application State)\n• Consider using HATEOAS principles to include hyperlinks in your API responses, guiding clients through the available actions.\n• Be mindful of sensitive data. Ensure that private information is not exposed unintentionally in your API responses.\n• Document your API responses thoroughly. Clear documentation is invaluable for developers who will consume your API.\n\nBy following these best practices, you can create JSON API responses that are not only functional but also a pleasure to work with. Remember, the goal is to make the data exchange process as smooth and efficient as possible for all parties involved.\n\nParsing JSON API responses is a fundamental skill for developers working with APIs. It involves converting the JSON-formatted string received from an API into a data structure that can be manipulated and used within an application.\n\nUtilizing Parsed Data:Once the JSON response is parsed, the data can be used in various ways depending on the application’s requirements. For instance:\n• Processing a list of products in an e-commerce app.\n\nBest Practices for Parsing and Utilization:\n• Error Handling: Always include error handling when parsing JSON to manage unexpected or malformed data.\n• Data Validation: Validate the parsed data to ensure it meets the expected format and type.\n• Efficient Data Access: Access the data in a way that is efficient and does not hinder application performance.\n\nIn essence, JSON’s role in API responses is a testament to its efficiency and adaptability, making it an industry standard. By following best practices in JSON formatting, developers can ensure their applications are robust and user-centric. Apidog stands as a prime example of these principles in action, providing a clear path for developers to master API responses and build the interconnected applications of tomorrow."
    },
    {
        "link": "https://jsonapi.org/format",
        "document": "This page presents the latest published version of JSON:API, which is currently version 1.1. New versions of JSON:API will always be backwards compatible using a never remove, only add strategy. Additions can be proposed in our discussion forum.\n\nIf you catch an error in the specification’s text, or if you write an implementation, please let us know by opening an issue or pull request at our GitHub repository.\n\nJSON:API is a specification for how a client should request that resources be fetched or modified, and how a server should respond to those requests. JSON:API can be easily extended with extensions and profiles.\n\nJSON:API is designed to minimize both the number of requests and the amount of data transmitted between clients and servers. This efficiency is achieved without compromising readability, flexibility, or discoverability.\n\nJSON:API requires use of the JSON:API media type ( ) for exchanging data.\n\nAll document members, query parameters, and processing rules defined by this specification are collectively called “specification semantics”.\n\nCertain document members, query parameters, and processing rules are reserved for implementors to define at their discretion. These are called “implementation semantics”.\n\nAll other semantics are reserved for potential future use by this specification.\n\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.\n\nThe JSON:API specification supports two media type parameters: and , which are used to specify extensions and profiles, respectively.\n\nExtensions provide a means to “extend” the base specification by defining additional specification semantics.\n\nExtensions cannot alter or remove specification semantics, nor can they specify implementation semantics.\n\nProfiles provide a means to share a particular usage of the specification among implementations.\n\nProfiles can specify implementation semantics, but cannot alter, add to, or remove specification semantics.\n\nThe JSON:API media type MUST NOT be specified with any media type parameters other than and . The parameter is used to support extensions and the parameter is used to support profiles.\n\nExtensions and profiles are each uniquely identified by a URI. Visiting an extension’s or a profile’s URI SHOULD return documentation that describes its usage. The values of the and parameters MUST equal a space-separated (U+0020 SPACE, “ “) list of extension or profile URIs, respectively.\n\nAn extension MAY impose additional processing rules or further restrictions and it MAY define new object members as described below.\n\nAn extension MUST NOT lessen or remove any processing rules, restrictions or object member requirements defined in this specification or other extensions.\n\nAn extension MAY define new members within the document structure defined by this specification. The rules for extension member names are covered below.\n\nAn extension MAY define new query parameters. The rules for extension-defined query parameters are covered below.\n\nWhen an extension defines new query parameters or document members, the extension MUST define a namespace to guarantee that extensions will never conflict with current or future versions of this specification. A namespace MUST meet all of the following conditions:\n• A namespace MUST contain at least one character.\n• A namespace MUST contain only these characters:\n\nAn extension MUST NOT define more than one namespace. The namespace used for all query parameters and document members MUST be the same for any given extension.\n\nIn the following example, an extension with the namespace has specified a resource object member to support per-resource versioning. This member might appear as follows:\n\nThe rules for profile usage are dictated by RFC 6906.\n\nA profile MAY define document members and processing rules that are reserved for implementors.\n\nA profile MUST NOT define any query parameters except implementation-specific query parameters.\n\nA profile MUST NOT alter or remove processing rules that have been defined by this specification or by an extension. However, a profile MAY define processing rules for query parameters whose processing rules have been reserved for implementors to define at their discretion.\n\nFor example, a profile could define rules for interpreting the query parameter, but it could not specify that relationship names in the query parameter are space-separated instead of dot-separated.\n\nUnlike extensions, profiles do not need to define a namespace for document members because profiles cannot define specification semantics and thus cannot conflict with current or future versions of this specification. However, it is possible for profiles to conflict with other profiles. Therefore, it is the responsibility of implementors to ensure that they do not support conflicting profiles.\n\nIn the following example, a profile has defined a attribute. According to the profile, the attribute must be an object containing a member and a member and these members’ values must use the RFC 3339 format. With such a profile applied, a response might appear as follows:\n\nClients and servers MUST send all JSON:API payloads using the JSON:API media type in the header.\n\nClients and servers MUST specify the media type parameter in the header when they have applied one or more extensions to a JSON:API document.\n\nClients and servers MUST specify the media type parameters in the header when they have applied one or more profiles to a JSON:API document.\n\nWhen processing a JSON:API response document, clients MUST ignore any parameters other than and parameters in the server’s header.\n\nA client MAY use the media type parameter in an header to require that a server apply all the specified extensions to the response document.\n\nA client MAY use the media type parameter in an header to request that the server apply one or more profiles to the response document.\n\nIf a request specifies the header with the JSON:API media type, servers MUST respond with a status code if that media type contains any media type parameters other than or .\n\nIf a request specifies the header with an instance of the JSON:API media type modified by the media type parameter and that parameter contains an unsupported extension URI, the server MUST respond with a status code.\n\nIf a request’s header contains an instance of the JSON:API media type, servers MUST ignore instances of that media type which are modified by a media type parameter other than or . If all instances of that media type are modified with a media type parameter other than or , servers MUST respond with a status code. If every instance of that media type is modified by the parameter and each contains at least one unsupported extension URI, the server MUST also respond with a .\n\nIf the parameter is received, a server SHOULD attempt to apply any requested profile(s) to its response. A server MUST ignore any profiles that it does not recognize.\n\nServers that support the or media type parameters SHOULD specify the header with as one of its values. This applies to responses with and without any profiles or extensions applied.\n\nThis section describes the structure of a JSON:API document, which is identified by the JSON:API media type. JSON:API documents are defined in JavaScript Object Notation (JSON) [RFC8259].\n\nAlthough the same media type is used for both request and response documents, certain aspects are only applicable to one or the other. These differences are called out below.\n\nExtensions MAY define new members within the document structure. These members MUST comply with the naming requirements specified below.\n\nUnless otherwise noted, objects defined by this specification or any applied extensions MUST NOT contain any additional members. Client and server implementations MUST ignore non-compliant members.\n\nA JSON object MUST be at the root of every JSON:API request and response document containing data. This object defines a document’s “top level”.\n\nA document MUST contain at least one of the following top-level members:\n\nThe members and MUST NOT coexist in the same document.\n\nA document MAY contain any of these top-level members:\n• : a links object related to the document as a whole.\n• : an array of resource objects that are related to the primary data and/or each other (“included resources”).\n\nIf a document does not contain a top-level key, the member MUST NOT be present either.\n\nThe top-level links object MAY contain the following members:\n• : the link that generated the current response document. If a document has extensions or profiles applied to it, this link SHOULD be represented by a link object with the target attribute specifying the JSON:API media type with all applicable parameters.\n• : a link to a description document (e.g. OpenAPI or JSON Schema) for the current document.\n\nThe document’s “primary data” is a representation of the resource or collection of resources targeted by a request.\n\nPrimary data MUST be either:\n• a single resource object, a single resource identifier object, or , for requests that target single resources\n• an array of resource objects, an array of resource identifier objects, or an empty array ( ), for requests that target resource collections\n\nFor example, the following primary data is a single resource object:\n\nThe following primary data is a single resource identifier object that references the same resource:\n\nA logical collection of resources MUST be represented as an array, even if it only contains one item or is empty.\n\n“Resource objects” appear in a JSON:API document to represent resources.\n\nA resource object MUST contain at least the following top-level members:\n\nException: The member is not required when the resource object originates at the client and represents a new resource to be created on the server. In that case, a client MAY include a member to uniquely identify the resource by locally within the document.\n\nIn addition, a resource object MAY contain any of these top-level members:\n• : an attributes object representing some of the resource’s data.\n• : a relationships object describing relationships between the resource and other JSON:API resources.\n• : a links object containing links related to the resource.\n• : a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.\n\nHere’s how an article (i.e. a resource of type “articles”) might appear in a document:\n\nAs noted above, every resource object MUST contain a member. Every resource object MUST also contain an member, except when the resource object originates at the client and represents a new resource to be created on the server. If is omitted due to this exception, a member MAY be included to uniquely identify the resource by locally within the document. The value of the member MUST be identical for every representation of the resource in the document, including resource identifier objects.\n\nThe values of the , , and members MUST be strings.\n\nWithin a given API, each resource object’s and pair MUST identify a single, unique resource. (The set of URIs controlled by a server, or multiple servers acting as one, constitute an API.)\n\nThe member is used to describe resource objects that share common attributes and relationships.\n\nThe values of members MUST adhere to the same constraints as member names.\n\nA resource object’s attributes and its relationships are collectively called its “fields”.\n\nFields for a resource object MUST share a common namespace with each other and with and . In other words, a resource can not have an attribute and relationship with the same name, nor can it have an attribute or relationship named or .\n\nThe value of the key MUST be an object (an “attributes object”). Members of the attributes object (“attributes”) represent information about the resource object in which it’s defined.\n\nAttributes may contain any valid JSON value, including complex data structures involving JSON objects and arrays.\n\nKeys that reference related resources (e.g. ) SHOULD NOT appear as attributes. Instead, relationships SHOULD be used.\n\nThe value of the key MUST be an object (a “relationships object”). Each member of a relationships object represents a “relationship” from the resource object in which it has been defined to other resource objects.\n\nRelationships may be to-one or to-many.\n\nA relationship’s name is given by its key. The value at that key MUST be an object (“relationship object”).\n\nA “relationship object” MUST contain at least one of the following:\n• : a links object containing at least one of the following:\n• : a link for the relationship itself (a “relationship link”). This link allows the client to directly manipulate the relationship. For example, removing an through an ’s relationship URL would disconnect the person from the without deleting the resource itself. When fetched successfully, this link returns the linkage for the related resources as its primary data. (See Fetching Relationships.)\n• : a meta object that contains non-standard meta-information about the relationship.\n\nA relationship object that represents a to-many relationship MAY also contain pagination links under the member, as described below. Any pagination links in a relationship object MUST paginate the relationship data, not the related resources.\n\nA “related resource link” provides access to resource objects linked in a relationship. When fetched, the related resource object(s) are returned as the response’s primary data.\n\nFor example, an ’s relationship could specify a link that returns a collection of comment resource objects when retrieved through a request.\n\nIf present, a related resource link MUST reference a valid URL, even if the relationship isn’t currently associated with any target resources. Additionally, a related resource link MUST NOT change because its relationship’s content changes.\n\nResource linkage in a compound document allows a client to link together all of the included resource objects without having to any URLs via links.\n\nResource linkage MUST be represented as one of the following:\n• an array of resource identifier objects for non-empty to-many relationships.\n\nFor example, the following article is associated with an :\n\nThe relationship includes a link for the relationship itself (which allows the client to change the related author directly), a related resource link to fetch the resource objects, and linkage information.\n\nThe optional member within each resource object contains links related to the resource.\n\nIf present, this links object MAY contain a link that identifies the resource represented by the resource object.\n\nA server MUST respond to a request to the specified URL with a response that includes the resource as the primary data.\n\nA “resource identifier object” is an object that identifies an individual resource.\n\nA “resource identifier object” MUST contain a member. It MUST also contain an member, except when it represents a new resource to be created on the server. In this case, a member MUST be included that identifies the new resource.\n\nThe values of the , , and members MUST be strings.\n\nA “resource identifier object” MAY also include a member, whose value is a meta object that contains non-standard meta-information.\n\nServers MAY allow responses that include related resources along with the requested primary resources. Such responses are called “compound documents”.\n\nIn a compound document, all included resources MUST be represented as an array of resource objects in a top-level member.\n\nEvery included resource object MUST be identified via a chain of relationships originating in a document’s primary data. This means that compound documents require “full linkage” and that no resource object can be included without a direct or indirect relationship to the document’s primary data.\n\nThe only exception to the full linkage requirement is when relationship fields that would otherwise contain linkage data are excluded due to sparse fieldsets requested by the client.\n\nA compound document MUST NOT include more than one resource object for each and pair.\n\nWhere specified, a member can be used to include non-standard meta-information. The value of each member MUST be an object (a “meta object”).\n\nAny members MAY be specified within objects.\n\nWhere specified, a member can be used to represent links. The value of this member MUST be an object (a “links object”).\n\nWithin this object, a link MUST be represented as either:\n• a string whose value is a URI-reference [RFC3986 Section 4.1] pointing to the link’s target,\n• if the link does not exist.\n\nA link’s relation type SHOULD be inferred from the name of the link unless the link is a link object and the link object has a member.\n\nA link’s context is the top-level object, resource object, or relationship object in which it appears.\n\nIn the example below, the link is a string whereas the link is a link object. The link object provides additional information about the targeted related resource collection as well as a schema that serves as a description document for that collection:\n\nA “link object” is an object that represents a web link.\n\nA link object MUST contain the following member:\n• : a string whose value is a URI-reference [RFC3986 Section 4.1] pointing to the link’s target.\n\nA link object MAY also contain any of the following members:\n• : a string indicating the link’s relation type. The string MUST be a valid link relation type.\n• : a link to a description document (e.g. OpenAPI or JSON Schema) for the link target.\n• : a string which serves as a label for the destination of a link such that it can be used as a human-readable identifier (e.g., a menu entry).\n• : a string indicating the media type of the link’s target.\n• : a string or an array of strings indicating the language(s) of the link’s target. An array of strings indicates that the link’s target is available in multiple languages. Each string MUST be a valid language tag [RFC5646].\n• : a meta object containing non-standard meta-information about the link.\n\nA JSON:API document MAY include information about its implementation under a top level member. If present, the value of the member MUST be an object (a “jsonapi object”).\n\nThe jsonapi object MAY contain any of the following members:\n• - whose value is a string indicating the highest JSON:API version supported.\n• - an array of URIs for all applied extensions.\n• - an array of URIs for all applied profiles.\n\nClients and servers MUST NOT use an or member for content negotiation. Content negotiation MUST only happen based on media type parameters in header.\n\nIf the member is not present, clients should assume the server implements at least version 1.0 of the specification.\n\nImplementation and profile defined member names used in a JSON:API document MUST be treated as case sensitive by clients and servers, and they MUST meet all of the following conditions:\n• Member names MUST contain at least one character.\n• Member names MUST contain only the allowed characters listed below.\n• Member names MUST start and end with a “globally allowed character”, as defined below.\n\nTo enable an easy mapping of member names to URLs, it is RECOMMENDED that member names use only non-reserved, URL safe characters specified in RFC 3986.\n\nThe following “globally allowed characters” MAY be used anywhere in a member name:\n• U+0080 and above (non-ASCII Unicode characters; not recommended, not URL safe)\n\nAdditionally, the following characters are allowed in member names, except as the first or last character:\n\nThe following characters MUST NOT be used in implementation and profile defined member names:\n• U+002B PLUS SIGN, “+” (has overloaded meaning in URL query strings)\n• U+002C COMMA, “,” (used as a separator between relationship paths)\n• U+002E PERIOD, “.” (used as a separator within relationship paths)\n• U+005D RIGHT SQUARE BRACKET, “]” (used in query parameter families)\n• U+0040 COMMERCIAL AT, “@” (except as first character in @-Members)\n\nMember names MAY also begin with an at sign (U+0040 COMMERCIAL AT, “@”). Members named this way are called “@-Members”. @-Members MAY appear anywhere in a document.\n\nThis specification provides no guidance on the meaning or usage of @-Members, which are considered to be implementation semantics. @-Members MUST be ignored when interpreting this specification’s definitions and processing instructions given outside of this subsection. For example, an attribute is defined above as any member of the attributes object. However, because @-Members must be ignored when interpreting that definition, an @-Member that occurs in an attributes object is not an attribute.\n\nThe name of every new member introduced by an extension MUST be prefixed with the extension’s namespace followed by a colon ( ). The remainder of the name MUST adhere to the rules for implementation defined member names.\n\nData, including resources and relationships, can be fetched by sending a request to an endpoint.\n\nResponses can be further refined with the optional features described below.\n\nA server MUST support fetching resource data for every URL provided as:\n• a link as part of the top-level links object\n\nFor example, the following request fetches a collection of articles:\n\nThe following request fetches an article:\n\nAnd the following request fetches an article’s author:\n\nA server MUST respond to a successful request to fetch an individual resource or resource collection with a response.\n\nA server MUST respond to a successful request to fetch a resource collection with an array of resource objects or an empty array ( ) as the response document’s primary data.\n\nFor example, a request to a collection of articles could return:\n\nA similar response representing an empty collection would be:\n\nA server MUST respond to a successful request to fetch an individual resource with a resource object or provided as the response document’s primary data.\n\nis only an appropriate response when the requested URL is one that might correspond to a single resource, but doesn’t currently.\n\nFor example, a request to an individual article could return:\n\nIf the above article’s author is missing, then a request to that related resource would return:\n\nA server MUST respond with when processing a request to fetch a single resource that does not exist, except when the request warrants a response with as the primary data (as described above).\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nA server MUST support fetching relationship data for every relationship URL provided as a link as part of a relationship’s object.\n\nFor example, the following request fetches data about an article’s comments:\n\nAnd the following request fetches data about an article’s author:\n\nA server MUST respond to a successful request to fetch a relationship with a response.\n\nThe primary data in the response document MUST match the appropriate value for resource linkage, as described above for relationship objects.\n\nThe top-level links object MAY contain and links, as described above for relationship objects.\n\nFor example, a request to a URL from a to-one relationship link could return:\n\nIf the above relationship is empty, then a request to the same URL would return:\n\nA request to a URL from a to-many relationship link could return:\n\nIf the above relationship is empty, then a request to the same URL would return:\n\nA server MUST return when processing a request to fetch a relationship link URL that does not exist.\n\nIf a relationship link URL exists but the relationship is empty, then MUST be returned, as described above.\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nAn endpoint MAY return resources related to the primary data by default.\n\nAn endpoint MAY also support an query parameter to allow the client to customize which related resources should be returned.\n\nIf an endpoint does not support the parameter, it MUST respond with to any requests that include it.\n\nIf an endpoint supports the parameter and a client supplies it:\n• The server’s response MUST be a compound document with an key — even if that key holds an empty array (because the requested relationships are empty).\n• The server MUST NOT include unrequested resource objects in the section of the compound document.\n\nThe value of the parameter MUST be a comma-separated (U+002C COMMA, “,”) list of relationship paths. A relationship path is a dot-separated (U+002E FULL-STOP, “.”) list of relationship names. An empty value indicates that no related resources should be returned.\n\nIf a server is unable to identify a relationship path or does not support inclusion of resources from a path, it MUST respond with 400 Bad Request.\n\nFor instance, comments could be requested with an article:\n\nIn order to request resources related to other resources, a dot-separated path for each relationship name can be specified:\n\nMultiple related resources can be requested in a comma-separated list:\n\nFurthermore, related resources can be requested from a relationship endpoint:\n\nIn this case, the primary data would be a collection of resource identifier objects that represent linkage to comments for an article, while the full comments and comment authors would be returned as included data.\n\nA client MAY request that an endpoint return only specific fields in the response on a per-type basis by including a query parameter.\n\nThe value of any parameter MUST be a comma-separated (U+002C COMMA, “,”) list that refers to the name(s) of the fields to be returned. An empty value indicates that no fields should be returned.\n\nIf a client requests a restricted set of fields for a given resource type, an endpoint MUST NOT include additional fields in resource objects of that type in its response.\n\nIf a client does not specify the set of fields for a given resource type, the server MAY send all fields, a subset of fields, or no fields for that resource type.\n\nA server MAY choose to support requests to sort resource collections according to one or more criteria (“sort fields”).\n\nAn endpoint MAY support requests to sort the primary data with a query parameter. The value for MUST represent sort fields.\n\nAn endpoint MAY support multiple sort fields by allowing comma-separated (U+002C COMMA, “,”) sort fields. Sort fields SHOULD be applied in the order specified.\n\nThe sort order for each sort field MUST be ascending unless it is prefixed with a minus (U+002D HYPHEN-MINUS, “-“), in which case it MUST be descending.\n\nThe above example should return the newest articles first. Any articles created on the same date will then be sorted by their title in ascending alphabetical order.\n\nIf the server does not support sorting as specified in the query parameter , it MUST return .\n\nIf sorting is supported by the server and requested by the client via query parameter , the server MUST return elements of the top-level array of the response ordered according to the criteria specified. The server MAY apply default sorting rules to top-level if request parameter is not specified.\n\nA server MAY choose to limit the number of resources returned in a response to a subset (“page”) of the whole set available.\n\nPagination links MUST appear in the links object that corresponds to a collection. To paginate the primary data, supply pagination links in the top-level object. To paginate an included collection returned in a compound document, supply pagination links in the corresponding links object.\n\nThe following keys MUST be used for pagination links:\n• : the first page of data\n• : the last page of data\n• : the next page of data\n\nKeys MUST either be omitted or have a value to indicate that a particular link is unavailable.\n\nConcepts of order, as expressed in the naming of pagination links, MUST remain consistent with JSON:API’s sorting rules.\n\nThe query parameter family is reserved for pagination. Servers and clients SHOULD use these parameters for pagination operations.\n\nThe query parameter family is reserved for filtering data. Servers and clients SHOULD use these parameters for filtering operations.\n\nA server MAY allow resources of a given type to be created. It MAY also allow existing resources to be modified or deleted.\n\nA request MUST completely succeed or fail (in a single “transaction”). No partial updates are allowed.\n\nA resource can be created by sending a request to a URL that represents a collection of resources. The request MUST include a single resource object as primary data. The resource object MUST contain at least a member.\n\nFor instance, a new photo might be created with the following request:\n\nIf a relationship is provided in the member of the resource object, its value MUST be a relationship object with a member. The value of this key represents the linkage the new resource is to have.\n\nA server MAY accept a client-generated ID along with a request to create a resource. An ID MUST be specified with an key, the value of which MUST be a universally unique identifier. The client SHOULD use a properly generated and formatted UUID as described in RFC 4122 [RFC4122].\n\nA server MUST return in response to an unsupported request to create a resource with a client-generated ID.\n\nIf the requested resource has been created successfully and the server changes the resource in any way (for example, by assigning an ), the server MUST return a response and a document that contains the resource as primary data.\n\nThe response SHOULD include a header identifying the location of the newly created resource, in order to comply with RFC 7231.\n\nIf the resource object returned by the response contains a key in its member and a header is provided, the value of the member MUST match the value of the header.\n\nA server MAY return a response with a document that contains no primary data if the requested resource has been created successfully and the server does not change the resource in any way (for example, by assigning an or attribute). Other top-level members, such as meta, could be included in the response document.\n\nIf a request to create a resource has been accepted for processing, but the processing has not been completed by the time the server responds, the server MUST return a status code.\n\nIf the requested resource has been created successfully and the server does not change the resource in any way (for example, by assigning an or attribute), the server MUST return either a status code and response document (as described above) or a status code with no response document.\n\nA server MAY return in response to an unsupported request to create a resource.\n\nA server MUST return when processing a request that references a related resource that does not exist.\n\nA server MUST return when processing a request to create a resource with a client-generated ID that already exists.\n\nA server MUST return when processing a request in which the resource object’s is not among the type(s) that constitute the collection represented by the endpoint.\n\nA server SHOULD include error details and provide enough information to recognize the source of the conflict.\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nA resource can be updated by sending a request to the URL that represents the resource.\n\nThe URL for a resource can be obtained in the link of the resource object. Alternatively, when a request returns a single resource object as primary data, the same request URL can be used for updates.\n\nThe request MUST include a single resource object as primary data. The resource object MUST contain and members.\n\nAny or all of a resource’s attributes MAY be included in the resource object included in a request.\n\nIf a request does not include all of the attributes for a resource, the server MUST interpret the missing attributes as if they were included with their current values. The server MUST NOT interpret missing attributes as values.\n\nFor example, the following request is interpreted as a request to update only the and attributes of an article:\n\nAny or all of a resource’s relationships MAY be included in the resource object included in a request.\n\nIf a request does not include all of the relationships for a resource, the server MUST interpret the missing relationships as if they were included with their current values. It MUST NOT interpret them as or empty values.\n\nIf a relationship is provided in the member of a resource object in a request, its value MUST be a relationship object with a member. The relationship’s value will be replaced with the value specified in this member.\n\nFor instance, the following request will update the relationship of an article:\n\nLikewise, the following request performs a complete replacement of the for an article:\n\nA server MAY reject an attempt to do a full replacement of a to-many relationship. In such a case, the server MUST reject the entire update, and return a response.\n\nIf a server accepts an update but also changes the targeted resource in ways other than those specified by the request (for example, updating the attribute or a computed ), it MUST return a response and a document that contains the updated resource as primary data.\n\nA server MAY return a response with a document that contains no primary data if an update is successful and the server does not change the targeted resource in ways other than those specified by the request. Other top-level members, such as meta, could be included in the response document.\n\nIf an update request has been accepted for processing, but the processing has not been completed by the time the server responds, the server MUST return a status code.\n\nIf an update is successful and the server doesn’t change the targeted resource in ways other than those specified by the request, the server MUST return either a status code and response document (as described above) or a status code with no response document.\n\nA server MUST return in response to an unsupported request to update a resource or relationship.\n\nA server MUST return when processing a request to modify a resource that does not exist.\n\nA server MUST return when processing a request that references a related resource that does not exist.\n\nA server MAY return when processing a request to update a resource if that update would violate other server-enforced constraints (such as a uniqueness constraint on a property other than ).\n\nA server MUST return when processing a request in which the resource object’s or do not match the server’s endpoint.\n\nA server SHOULD include error details and provide enough information to recognize the source of the conflict.\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nAlthough relationships can be modified along with resources (as described above), JSON:API also supports updating of relationships independently at URLs from relationship links.\n\nA to-one relationship can be updated by sending a request to a URL from a to-one relationship link.\n\nThe request MUST include a top-level member named containing one of:\n• a resource identifier object corresponding to the new related resource.\n\nFor example, the following request updates the author of an article:\n\nAnd the following request clears the author of the same article:\n\nIf the relationship is updated successfully then the server MUST return a successful response.\n\nA to-many relationship can be updated by sending a , , or request to a URL from a to-many relationship link.\n\nFor all request types, the body MUST contain a member whose value is an empty array or an array of resource identifier objects.\n\nIf a client makes a request to a URL from a to-many relationship link, the server MUST either completely replace every member of the relationship, return an appropriate error response if some resources cannot be found or accessed, or return a response if complete replacement is not allowed by the server.\n\nFor example, the following request replaces every tag for an article:\n\nAnd the following request clears every tag for an article:\n\nIf a client makes a request to a URL from a relationship link, the server MUST add the specified members to the relationship unless they are already present. If a given and is already in the relationship, the server MUST NOT add it again.\n\nIf all of the specified resources can be added to, or are already present in, the relationship then the server MUST return a successful response.\n\nIn the following example, the comment with ID is added to the list of comments for the article with ID :\n\nIf the client makes a request to a URL from a relationship link the server MUST delete the specified members from the relationship or return a response. If all of the specified resources are able to be removed from, or are already missing from, the relationship then the server MUST return a successful response.\n\nRelationship members are specified in the same way as in the request.\n\nIn the following example, comments with IDs of and are removed from the list of comments for the article with ID :\n\nIf a server accepts an update but also changes the targeted relationship in other ways than those specified by the request, it MUST return a response and a document that includes the updated relationship data as its primary data.\n\nA server MAY return a response with a document that contains no primary data if an update is successful and the server does not change the targeted relationship in ways other than those specified by the request. Other top-level members, such as meta, could be included in the response document.\n\nIf a relationship update request has been accepted for processing, but the processing has not been completed by the time the server responds, the server MUST return a status code.\n\nIf an update is successful and the server doesn’t change the targeted relationship in ways other than those specified by the request, the server MUST return either a status code and response document (as described above) or a status code with no response document.\n\nA server MUST return in response to an unsupported request to update a relationship.\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nA resource can be deleted by sending a request to the URL that represents the resource:\n\nA server MAY return a response with a document that contains no primary data if a deletion request is successful. Other top-level members, such as meta, could be included in the response document.\n\nIf a deletion request has been accepted for processing, but the processing has not been completed by the time the server responds, the server MUST return a status code.\n\nIf a deletion request is successful, the server MUST return either a status code and response document (as described above) or a status code with no response document.\n\nA server SHOULD return a status code if a deletion request fails due to the resource not existing.\n\nA server MAY respond with other HTTP status codes.\n\nA server MUST prepare responses, and a client MUST interpret responses, in accordance with .\n\nAlthough “query parameter” is a common term in everyday web development, it is not a well-standardized concept. Therefore, JSON:API provides its own definition of a query parameter.\n\nFor the most part, JSON:API’s definition coincides with colloquial usage, and its details can be safely ignored. However, one important consequence of this definition is that a URL like the following is considered to have two distinct query parameters:\n\nThe two parameters are named and ; there is no single parameter.\n\nIn practice, however, parameters like and are usually defined and processed together, and it’s convenient to refer to them collectively. Therefore, JSON:API introduces the concept of a query parameter family.\n\nA “query parameter family” is the set of all query parameters whose name starts with a “base name”, followed by zero or more instances of empty square brackets (i.e. ), square-bracketed legal member names, or square-bracketed dot-separated lists of legal member names. The family is referred to by its base name.\n\nFor example, the query parameter family includes parameters named: , , , , , , , etc. However, is not a valid parameter name in the family, because is not a valid member name.\n\nThe base name of every query parameter introduced by an extension MUST be prefixed with the extension’s namespace followed by a colon ( ). The remainder of the base name MUST contain only the characters [a-z] (U+0061 to U+007A, “a-z”).\n\nImplementations MAY support custom query parameters. However, the names of these query parameters MUST come from a family whose base name is a legal member name and also contains at least one non a-z character (i.e., outside U+0061 to U+007A).\n\nIt is RECOMMENDED that a capital letter (e.g. camelCasing) be used to satisfy the above requirement.\n\nIf a server encounters a query parameter that does not follow the naming conventions above, or the server does not know how to process it as a query parameter from this specification, it MUST return .\n\nA server MAY choose to stop processing as soon as a problem is encountered, or it MAY continue processing and encounter multiple problems. For instance, a server might process multiple attributes and then return multiple validation problems in a single response.\n\nWhen a server encounters multiple problems for a single request, the most generally applicable HTTP error code SHOULD be used in the response. For instance, might be appropriate for multiple 4xx errors or might be appropriate for multiple 5xx errors.\n\nError objects provide additional information about problems encountered while performing an operation. Error objects MUST be returned as an array keyed by in the top level of a JSON:API document.\n\nAn error object MAY have the following members, and MUST contain at least one of:\n• : a unique identifier for this particular occurrence of the problem.\n• : a links object that MAY contain the following members:\n• : a link that leads to further details about this particular occurrence of the problem. When dereferenced, this URI SHOULD return a human-readable description of the error.\n• : a link that identifies the type of error that this particular error is an instance of. This URI SHOULD be dereferenceable to a human-readable explanation of the general error.\n• : the HTTP status code applicable to this problem, expressed as a string value. This SHOULD be provided.\n• : an application-specific error code, expressed as a string value.\n• : a short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.\n• : a human-readable explanation specific to this occurrence of the problem. Like , this field’s value can be localized.\n• : an object containing references to the primary source of the error. It SHOULD include one of the following members or be omitted:\n• : a JSON Pointer [RFC6901] to the value in the request document that caused the error [e.g. for a primary data object, or for a specific attribute]. This MUST point to a value in the request document that exists; if it doesn’t, the client SHOULD simply ignore the pointer.\n• : a string indicating the name of a single request header which caused the error.\n• : a meta object containing non-standard meta-information about the error.\n\nA query parameter is a name–value pair extracted from, or serialized into, a URI’s query string.\n\nTo extract the query parameters from a URI, an implementation MUST run the URI’s query string, excluding the leading question mark, through the parsing algorithm, with one exception: JSON:API allows the specification that defines a query parameter’s usage to provide its own rules for parsing the parameter’s value from the bytes identified in steps 3.2 and and 3.3 of the parsing algorithm. The resulting value might not be a string.\n\nSimilarly, to serialize a query parameter into a URI, an implementation MUST use the serializer, with the corresponding exception that a parameter’s value — but not its name — may be serialized differently than that algorithm requires, provided the serialization does not interfere with the ability to parse back the resulting URI.\n\nWith query parameter families, JSON:API allows for query parameters whose names contain square brackets (i.e., U+005B “[” and U+005D “]”).\n\nAccording to the query parameter serialization rules above, a compliant implementation will percent-encode these square brackets. However, some URI producers — namely browsers — do not always encode them. Servers SHOULD accept requests in which these square brackets are left unencoded in a query parameter’s name. If a server does accept these requests, it MUST treat the request as equivalent to one in which the square brackets were percent-encoded."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/json/json-data-sql-server?view=sql-server-ver16",
        "document": "Applies to: SQL Server 2016 (13.x) and later versions Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics SQL database in Microsoft Fabric\n\nJSON is a popular textual data format that's used for exchanging data in modern web and mobile applications. JSON is also used for storing unstructured data in log files or NoSQL databases such as Microsoft Azure Cosmos DB. Many REST web services return results that are formatted as JSON text or accept data that's formatted as JSON. For example, most Azure services, such as Azure Search, Azure Storage, and Azure Cosmos DB, have REST endpoints that return or consume JSON. JSON is also the main format for exchanging data between webpages and web servers by using AJAX calls.\n\nJSON functions, first introduced in SQL Server 2016 (13.x), enable you to combine NoSQL and relational concepts in the same database. You can combine classic relational columns with columns that contain documents formatted as JSON text in the same table, parse and import JSON documents in relational structures, or format relational data to JSON text.\n\nHere's an example of JSON text:\n\nBy using SQL Server built-in functions and operators, you can do the following things with JSON text:\n• Run any Transact-SQL query on the converted JSON objects.\n• Format the results of Transact-SQL queries in JSON format.\n\nThe next sections discuss the key capabilities that SQL Server provides with its built-in JSON support.\n\nThe new json data type that stores JSON documents in a native binary format that provides the following benefits over storing JSON data in varchar/nvarchar:\n• More efficient reads, as the document is already parsed\n• More efficient writes, as the query can update individual values without accessing the entire document\n• No change in compatibility with existing code\n\nUsing the JSON same functions described in this article remain the most efficient way to query the json data type. For more information on the native json data type, see JSON data type.\n\nExtract values from JSON text and use them in queries\n\nIf you have JSON text that's stored in database tables, you can read or modify values in the JSON text by using the following built-in functions:\n• JSON_QUERY (Transact-SQL) extracts an object or an array from a JSON string.\n• JSON_MODIFY (Transact-SQL) changes a value in a JSON string.\n\nIn the following example, the query uses both relational and JSON data (stored in a column named ) from a table called :\n\nApplications and tools see no difference between the values taken from scalar table columns and the values taken from JSON columns. You can use values from JSON text in any part of a Transact-SQL query (including WHERE, ORDER BY, or GROUP BY clauses, window aggregates, and so on). JSON functions use JavaScript-like syntax for referencing values inside JSON text.\n\nFor more information, see Validate, Query, and Change JSON Data with Built-in Functions (SQL Server), JSON_VALUE (Transact-SQL), and JSON_QUERY (Transact-SQL).\n\nIf you must modify parts of JSON text, you can use the JSON_MODIFY (Transact-SQL) function to update the value of a property in a JSON string and return the updated JSON string. The following example updates the value of a property in a variable that contains JSON:\n\nYou don't need a custom query language to query JSON in SQL Server. To query JSON data, you can use standard T-SQL. If you must create a query or report on JSON data, you can easily convert JSON data to rows and columns by calling the rowset function. For more information, see Parse and Transform JSON Data with OPENJSON.\n\nThe following example calls and transforms the array of objects that is stored in the variable to a rowset that can be queried with a standard Transact-SQL statement:\n\ntransforms the array of JSON objects into a table in which each object is represented as one row, and key/value pairs are returned as cells. The output observes the following rules:\n• converts JSON values to the types that are specified in the clause.\n• can handle both flat key/value pairs and nested, hierarchically organized objects.\n• You don't have to return all the fields that are contained in the JSON text.\n• You can optionally specify a path after the type specification to reference a nested property or to reference a property by a different name.\n• The optional prefix in the path specifies that values for the specified properties must exist in the JSON text.\n\nFor more information, see Parse and Transform JSON Data with OPENJSON and OPENJSON (Transact-SQL).\n\nJSON documents might have sub-elements and hierarchical data that can't be directly mapped into the standard relational columns. In this case, you can flatten JSON hierarchy by joining parent entity with sub-arrays.\n\nIn the following example, the second object in the array has sub-array representing person skills. Every sub-object can be parsed using additional function call:\n\nThe array is returned in the first as original JSON text fragment and passed to another function using operator. The second function parses JSON array and return string values as single column rowset that will be joined with the result of the first .\n\njoins first-level entity with sub-array and return flatten resultset. Due to JOIN, the second row is repeated for every skill.\n\nFormat SQL Server data or the results of SQL queries as JSON by adding the clause to a statement. Use to delegate the formatting of JSON output from your client applications to SQL Server. For more information, see Format query results as JSON with FOR JSON.\n\nThe following example uses PATH mode with the clause:\n\nThe clause formats SQL results as JSON text that can be provided to any app that understands JSON. The PATH option uses dot-separated aliases in the SELECT clause to nest objects in the query results.\n\nFor more information, see Format query results as JSON with FOR JSON and FOR Clause (Transact-SQL).\n\nJSON aggregate functions enable construction of JSON objects or arrays based on an aggregate from SQL data.\n• JSON_OBJECTAGG constructs a JSON object from an aggregation of SQL data or columns.\n• JSON_ARRAYAGG constructs a JSON array from an aggregation of SQL data or columns.\n\nUse cases for JSON data in SQL Server\n\nJSON support in SQL Server and Azure SQL Database lets you combine relational and NoSQL concepts. You can easily transform relational to semi-structured data and vice-versa. JSON isn't a replacement for existing relational models, however. Here are some specific use cases that benefit from the JSON support in SQL Server and in SQL Database.\n\nConsider denormalizing your data model with JSON fields in place of multiple child tables.\n\nStore info about products with a wide range of variable attributes in a denormalized model for flexibility.\n\nLoad, query, and analyze log data stored as JSON files with all the power of the Transact-SQL language.\n\nWhen you need real-time analysis of IoT data, load the incoming data directly into the database instead of staging it in a storage location.\n\nTransform relational data from your database easily into the JSON format used by the REST APIs that support your web site.\n\nSQL Server provides a hybrid model for storing and processing both relational and JSON data by using standard Transact-SQL language. You can organize collections of your JSON documents in tables, establish relationships between them, combine strongly typed scalar columns stored in tables with flexible key/value pairs stored in JSON columns, and query both scalar and JSON values in one or more tables by using full Transact-SQL.\n\nJSON text is stored in or columns and is indexed as plain text. Any SQL Server feature or component that supports text supports JSON, so there are almost no constraints on interaction between JSON and other SQL Server features. You can store JSON in In-memory or Temporal tables, apply Row-Level Security predicates on JSON text, and so on.\n\nHere are some use cases that show how you can use the built-in JSON support in SQL Server.\n\nJSON is a textual format so the JSON documents can be stored in columns in a SQL Database. Since type is supported in all SQL Server subsystems you can put JSON documents in tables with clustered columnstore indexes, memory optimized tables, or external files that can be read using OPENROWSET or PolyBase.\n\nTo learn more about your options for storing, indexing, and optimizing JSON data in SQL Server, see the following articles:\n\nYou can format information that's stored in files as standard JSON or line-delimited JSON. SQL Server can import the contents of JSON files, parse it by using the or functions, and load it into tables.\n• None If your JSON documents are stored in local files, on shared network drives, or in Azure Files locations that can be accessed by SQL Server, you can use bulk import to load your JSON data into SQL Server.\n• None If your line-delimited JSON files are stored in Azure Blob storage or the Hadoop file system, you can use PolyBase to load JSON text, parse it in Transact-SQL code, and load it into tables.\n\nIf you must load JSON data from an external service into SQL Server, you can use to import the data into SQL Server instead of parsing the data in the application layer.\n\nIn supported platforms, use the native json data type instead of nvarchar(max) for improved performance and more efficient storage.\n\nYou can provide the content of the JSON variable by an external REST service, send it as a parameter from a client-side JavaScript framework, or load it from external files. You can easily insert, update, or merge results from JSON text into a SQL Server table.\n\nIf you must filter or aggregate JSON data for reporting purposes, you can use to transform JSON to relational format. You can then use standard Transact-SQL and built-in functions to prepare the reports.\n\nYou can use both standard table columns and values from JSON text in the same query. You can add indexes on the expression to improve the performance of the query. For more information, see Index JSON data.\n\nIf you have a web service that takes data from the database layer and returns it in JSON format, or if you have JavaScript frameworks or libraries that accept data formatted as JSON, you can format JSON output directly in a SQL query. Instead of writing code or including a library to convert tabular query results and then serialize objects to JSON format, you can use to delegate the JSON formatting to SQL Server.\n\nFor example, you might want to generate JSON output that's compliant with the OData specification. The web service expects a request and response in the following format:\n\nThis OData URL represents a request for the ProductID and ProductName columns for the product with 1. You can use to format the output as expected in SQL Server.\n\nThe output of this query is JSON text that's fully compliant with the OData spec. Formatting and escaping are handled by SQL Server. SQL Server can also format query results in any format, such as OData JSON or GeoJSON.\n\nTo get the AdventureWorks sample database, download at least the database file and the samples and scripts file from GitHub.\n\nAfter you restore the sample database to an instance of SQL Server, extract the samples file, and then open the file from the JSON folder. Run the scripts in this file to reformat some existing data as JSON data, test sample queries and reports over the JSON data, index the JSON data, and import and export JSON.\n\nHere's what you can do with the scripts that are included in the file:\n• None Denormalize the existing schema to create columns of JSON data.\n• None Store information from , , , , and other tables that contain information related to sales order into JSON columns in the table.\n• None Store information from and tables in the table as arrays of JSON objects.\n• None Import and export JSON. Create and run procedures that export the content of the and the tables as JSON results, and import and update the and the tables by using JSON input.\n• None Run query examples. Run some queries that call the stored procedures and views that you created in steps 2 and 4.\n• None Clean up scripts. Don't run this part if you want to keep the stored procedures and views that you created in steps 2 and 4."
    },
    {
        "link": "https://geeksforgeeks.org/working-with-json-in-sql",
        "document": "JSON stands for Javascript Object Notation. It is mainly used in storing and transporting data. Mostly all NoSQL databases like MongoDB, CouchDB, etc., use JSON format data. Whenever your data from one server has to be transferred to a web page, JSON format is the preferred format for front-end applications like Android, iOS, React, Angular, etc.\n\nIn this article, we will learn how to store, retrieve, and manipulate JSON data in SQL Server using various SQL functions. We will learn how JSON fits into SQL, demonstrate how to store JSON data in SQL tables and cover the most common JSON functions like ISJSON(), JSON_VALUE(), JSON_MODIFY(), and more.\n\nWhat is JSON in SQL Server?\n\nJSON is a lightweight data-interchange format that is easy for humans to read and write. SQL Server introduced native support for JSON handling starting from SQL Server 2016. This allows you to store JSON data in NVARCHAR columns and use SQL functions to parse, query, and modify JSON data.\n\nIn SQL Server, you can store JSON data as a string in an NVARCHAR column. SQL Server treats JSON data as a string, allowing you to parse it when necessary.\n\nNow let us create a table named “Authors” and let us insert some data into it as shown below:\n\nJSON is a beautiful option for bridging NoSQL and relational worlds. Hence, in case if you have the data got exported from MongoDB and need to import them in SQL Server, we can follow below approaches\n\nJSON documents can be stored as-is in NVARCHAR columns either in LOB storage format or Relational storage format. Raw JSON documents have to be parsed, and they may contain Non-English text. By using nvarchar(max) data type, we can store JSON documents with a max capacity of 2 GB in size. If the JSON data is not huge, we can go for NVARCHAR(4000), or else we can go for NVARCHAR(max) for performance reasons.\n\nThe main reason for keeping the JSON document in NVARCHAR format is for Cross feature compatibility. NVARCHAR works with X feature i.e. all the SQL server components such as Hekaton(OLTP), temporal, or column store tables, etc. As JSON behavior is also in that way, it is represented as NVARCHAR datatype.\n\nBefore SQL Server 2016, JSON was stored in the database as text. Hence, there was a need to change the database schema and migration occurred as JSON type in NVarchar format\n\nJSON is just treated as an Object in JavaScript and hence called as Javascript Object Notation. There is no specific standardized JSON object type on client-side available similar to XmlDom object.\n\nLet us see the important functionalities available in SQL Server which can be used with JSON data.\n\nThis function is used to check whether the given input json string is in JSON format or not. If it is in JSON format, it returns 1 as output or else 0. i.e. it returns either 1 or 0 in INT format.\n\nThe output will be a scalar value from the given JSON string. Parsing of JSON string is done and there are some specific formats are there for providing the path. For example\n\nUsed to extract an array of data or objects from the JSON string.\n\nThere is an option called “JSON_MODIFY” in (Transact-SQL) function is available to update the value of a property in a JSON string and return the updated JSON string. Whenever there is a requirement to change JSON text, we can do that\n\nThis function is used for Exporting SQL Server data as JSON format. This is a useful function to export SQL data into JSON format. There are two options available with FOR JSON\n• AUTO: As it is nested JSON sub-array is created based on the table hierarchy.\n• PATH: By using this we can define the structure of JSON in a customized way.\n\nThis function is used for importing JSON as String data. We can import JSON as a text file by using OPENROWSET function and in that the BULK option should be enabled. It returns a single string field with BulkColumn as its column name.\n\nNote: Even large data also can be placed. As a sample, we showed only a single row.\n\nSINGLE_BLOB, which reads a file as varbinary(max). SINGLE_NCLOB, which reads a file as nvarchar(max) — If the contents are in Non-English text like Japanese or Chinese etc., data, we need to go in this pattern. We used SINGLE_CLOB, which reads a file as varchar(max).\n\nIt will generate a relational table with its contents from the JSON string. Each row is created which can be got by iterating through JSON object elements, OPENJSON can be used to parse the JSON as a text. Let us have a JSON placed in an external file and its contents are\n\nWe can see that for “Strings” key like “authorname” and “skills” got type as 1 and “int” key like “id” and “age” got type as 2. Similarly, for boolean, the type is 3. For arrays, it is 4 and for object, it is 5. OPENJSON parses only the root level of the JSON.\n\nIn case if the JSON is nested, we need to use Path variables\n\nWe can even make the skillsets as columns of data as\n\nSaving the rowset into Table: Here the number of columns should match the count that is present inside with:\n\nThere is an option called “JSON_MODIFY” in (Transact-SQL) function is available to update the value of a property in a JSON string and return the updated JSON string. Whenever there is a requirement to change JSON text, we can do that\n\nHandling JSON in SQL Server enables seamless interaction with modern web applications and NoSQL databases. The ability to store, query, and manipulate JSON data directly in SQL Server enhances the flexibility and efficiency of your data management system. SQL Server’s native JSON functions—such as ISJSON(), JSON_VALUE(), JSON_QUERY(), and JSON_MODIFY()—make it easier to integrate and work with JSON data without needing a separate NoSQL system."
    },
    {
        "link": "https://docs.retool.com/queries/guides/sql/query-json",
        "document": "You can create queries that use SQL statements to query JSON data, such as data from other queries, using the Query JSON with SQL resource. Instead of referencing database tables for data, you use to reference JSON arrays of objects.\n\nRetool uses the AlaSQL JavaScript library for JSON SQL queries. Some SQL syntax may differ since queries run in the browser. For example, AlaSQL uses square brackets and backticks to enclose column names that contain whitespace, rather than double quotes. Refer to the AlaSQL documentation for a complete reference on supported operations.\n\nResource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post. Resource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post.\n\nClick Save & Run to save the query and then execute it. The query results then appear in the Output tab. You can reference the query output elsewhere in the app using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values. Click ▶︎ to run the block. The query results then appear in the Data and JSON tabs. You can reference the query output further down the control flow using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values.\n\nIf you need to reference an array within a query, such as a list of values for an clause, prefix the array with ."
    },
    {
        "link": "https://stackoverflow.com/questions/17688349/sql-like-operator-to-find-words-in-stored-json",
        "document": "I have this JSON stored in a MySQL DB, column name:\n\nI want to make a search using operator to find all categories with \"Category\" word:\n\nAt the moment I'm doing it this way, but it only return a complete phrase:\n\nHow can I build a query that returns all categories containing the word \"Category\"?"
    },
    {
        "link": "https://cloud.google.com/bigquery/docs/json-data",
        "document": "Save and categorize content based on your preferences.\n\nThis document describes how to create a table with a column, insert JSON data into a BigQuery table, and query JSON data.\n\nJSON is a widely used format that allows for semi-structured data, because it does not require a schema. Applications can use a \"schema-on-read\" approach, where the application ingests the data and then queries based on assumptions about the schema of that data. This approach differs from the type in BigQuery, which requires a fixed schema that is enforced for all values stored in a column of type.\n\nBy using the data type, you can load semi-structured JSON into BigQuery without providing a schema for the JSON data upfront. This lets you store and query data that doesn't always adhere to fixed schemas and data types. By ingesting JSON data as a data type, BigQuery can encode and process each JSON field individually. You can then query the values of fields and array elements within the JSON data by using the field access operator, which makes JSON queries intuitive and cost efficient.\n• If you use a batch load job to ingest JSON data into a table, the source data must be in CSV, Avro, or JSON format. Other batch load formats are not supported.\n• The data type has a nesting limit of 500.\n• You can't use legacy SQL to query a table that contains types.\n• Row-level access policies cannot be applied on columns.\n\nTo learn about the properties of the data type, see type.\n\nYou can create an empty table with a column by using SQL or by using the bq command-line tool.\n\nYou can't partition or cluster a table on columns, because the equality and comparison operators are not defined on the type.\n\nYou can create values in the following ways:\n• Use the function to convert a value to a value.\n• Use the function to convert a SQL value to a value.\n• Use the function to create a JSON array from SQL values.\n• Use the function to create a JSON object from key-value pairs.\n\nThe following example inserts values into a table:\n\nThe following example converts a JSON-formatted value by using the function. The example converts a column from an existing table to a type and saves the results in a new table.\n\nThe prefix used in this example ensures that any conversion errors are returned as values.\n\nThe following example converts key-value pairs to JSON using the function.\n\nThe result is the following:\n\nThe following example converts a SQL value to a value by using the function:\n\nThe result is the following:\n\nYou can ingest JSON data into a BigQuery table in the following ways:\n• Use a batch load job to load into columns from the following formats.\n\nThe following example assumes that you have a CSV file named that contains the following records:\n\nNote that the second column contains JSON data that is encoded as a string. This involves correctly escaping the quotes for the CSV format. In CSV format, quotes are escaped by using the two character sequence .\n\nTo load this file using the bq command-line tool, use the command:\n\nThe following example assumes that you have a file named that contains the following records:\n\nTo load this file using the bq command-line tool, use the command:\n\nYou can use the Storage Write API to ingest JSON data. The following example uses the Storage Write API Python client to write data into a table with a JSON data type column.\n\nDefine a protocol buffer to hold the serialized streaming data. The JSON data is encoded as a string. In the following example, the field holds JSON data.\n\nFormat the JSON data for each row as a value:\n\nAppend the rows to the write stream as shown in the code example. The client library handles serialization to protocol buffer format.\n\nIf you aren't able to format the incoming JSON data, you need to use the method in your code. Here is an example:\n\nThe following example loads JSON data from a local file and streams it to a BigQuery table with a JSON data-type column named using the legacy streaming API.\n\nFor more information, see Streaming data into BigQuery.\n\nThis section describes how to use GoogleSQL to extract values from JSON. JSON is case-sensitive and supports UTF-8 in both fields and values.\n\nThe examples in this section use the following table:\n\nGiven a type in BigQuery, you can access the fields in a JSON expression by using the field access operator. The following example returns the field of the column.\n\nTo access an array element, use the JSON subscript operator. The following example returns the first element of the array:\n\nYou can also use the JSON subscript operator to reference the members of a JSON object by name:\n\nFor subscript operations, the expression inside the brackets can be any arbitrary string or integer expression, including non-constant expressions:\n\nField access and subscript operators both return types, so you can chain expressions that use them or pass the result to other functions that take types.\n\nThese operators improve readability for the basic functionality of the function. For example, the expression is equivalent to .\n\nIf a member with the specified name is not found in the JSON object, or if the JSON array doesn't have an element with the specified position, then these operators return SQL .\n\nThe equality and comparison operators are not defined on the data type. Therefore, you can't use values directly in clauses like or . Instead, use the function to extract field values as SQL strings, as described in the next section.\n\nThe function extracts a scalar value and returns it as a SQL string. It returns SQL if doesn't point to a scalar value in the JSON.\n\nYou can use the function in contexts that require equality or comparison, such as clauses and clauses. The following example shows a clause that filters against a value:\n\nAlternatively, you can use the function which extracts a JSON string and returns that value as a SQL . For example:\n\nIn addition to , you might have to extract values and return them as another SQL data type. The following value extraction functions are available:\n\nTo obtain the type of the value, you can use the function.\n\nYou can convert a value to a scalar SQL value flexibly with functions.\n\nThe following example uses the function to extract an value from a value.\n\nIn addition to , you can convert to other SQL types flexibly to JSON with the following functions:\n\nJSON can contain JSON arrays, which are not directly equivalent to an type in BigQuery. You can use the following functions to extract a BigQuery from JSON:\n• : extracts an array and returns it as an of JSON.\n• : extracts an array of scalar values and returns it as an of scalar values.\n\nThe following example uses to extract JSON arrays:\n\nTo split an array into its individual elements, use the operator, which returns a table with one row for each element in the array. The following example selects the member from each member of the array:\n\nThe next example is similar but uses the function to aggregate the values back into a SQL array.\n\nFor more information about arrays, see Working with arrays in GoogleSQL.\n\nThe type has a special value that is different from the SQL . A JSON is not treated as a SQL value, as the following example shows.\n\nWhen you extract a JSON field with a value, the behavior depends on the function:\n• The function returns a JSON , because it is a valid value.\n• The function returns the SQL , because JSON is not a scalar value.\n\nThe following example shows the different behaviors:"
    }
]