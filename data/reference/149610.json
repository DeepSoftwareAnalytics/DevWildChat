[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html",
        "document": "\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Cipher object encapsulating the CipherSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the method. - the name of the transformation, e.g., AES/CBC/PKCS5Padding. See the Cipher section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard transformation names. - if is null, empty, in an invalid format, or if no Provider supports a CipherSpi implementation for the specified algorithm. - if contains a padding scheme that is not available.\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the method. - the name of the transformation, e.g., AES/CBC/PKCS5Padding. See the Cipher section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard transformation names. - the name of the provider. - if is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified provider. - if the specified provider is not registered in the security provider list. - if contains a padding scheme that is not available. - if the is null or empty.\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list. - the name of the transformation, e.g., AES/CBC/PKCS5Padding. See the Cipher section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard transformation names. - if is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified Provider object. - if contains a padding scheme that is not available. - if the is null.\n• Returns the provider of this object. the provider of this object\n• object. Returns the algorithm name of thisobject. This is the same name that was specified in one of the calls that created this object.. the algorithm name of this object.\n• the block size (in bytes), or 0 if the underlying algorithm is not a block cipher\n• or operation, given the input length (in bytes). Returns the length in bytes that an output buffer would need to be in order to hold the result of the nextoroperation, given the input length(in bytes). This call takes into account any unprocessed (buffered) data from a previous call, padding, and AEAD tagging. The actual output length of the next or call may be smaller than the length returned by this method. - if this cipher is in a wrong state (e.g., has not yet been initialized)\n• Returns the initialization vector (IV) in a new buffer. This is useful in the case where a random IV was created, or in the context of password-based encryption or decryption, where the IV is derived from a user-supplied password. the initialization vector in a new buffer, or null if the underlying algorithm does not use an IV, or if the IV has not yet been set.\n• Returns the parameters used with this cipher. The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any. the parameters used with this cipher, or null if this cipher does not use any parameters.\n• Returns the exemption mechanism object used with this cipher. the exemption mechanism object used with this cipher, or null if this cipher does not use any exemption mechanism.\n• The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters that cannot be derived from the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters that cannot be derived from the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with the public key from the given certificate. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of , an is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given certificate, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with the public key from the given certificate and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of , an is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The bytes in the buffer are processed, and the result is stored in a new buffer. If has a length of zero, this method returns . the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block. - if this cipher is in a wrong state (e.g., has not been initialized)\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in a new buffer. If is zero, this method returns . - the offset in where the input starts the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block. - if this cipher is in a wrong state (e.g., has not been initialized)\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in the buffer. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. If is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if the given output buffer is too small to hold the result\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. If is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if the given output buffer is too small to hold the result\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. All bytes starting at are processed. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If bytes are insufficient to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Note: this method should be copy-safe, which means the and buffers can reference the same block of memory and no unprocessed input data is overwritten when the result is copied into the output buffer. the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if input and output are the same object - if the output buffer is read-only - if there is insufficient space in the output buffer\n• Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The bytes in the buffer, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. - the offset in where the input starts the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. All bytes starting at are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If bytes are insufficient to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if input and output are the same object - if the output buffer is read-only - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if there is insufficient space in the output buffer - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• - the key to be wrapped. - if this cipher is in a wrong state (e.g., has not been initialized). - if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size. - if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher). - if the corresponding method in the is not supported.\n• - the key to be unwrapped. - the algorithm associated with the wrapped key. - the type of the wrapped key. This must be one of , , or . - if this cipher is in a wrong state (e.g., has not been initialized). - if no installed providers can create keys of type for the . - if does not represent a wrapped key of type for the . - if the corresponding method in the is not supported.\n• Returns the maximum key length for the specified transformation according to the installed JCE jurisdiction policy files. If JCE unlimited strength jurisdiction policy files are installed, Integer.MAX_VALUE will be returned. For more information on default key size in JCE jurisdiction policy files, please see Appendix E in the Java Cryptography Architecture Reference Guide the maximum key length in bits or Integer.MAX_VALUE. - if is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\".\n• Returns an AlgorithmParameterSpec object which contains the maximum cipher parameter value according to the jurisdiction policy file. If JCE unlimited strength jurisdiction policy files are installed or there is no maximum limit on the parameters for the specified transformation in the policy file, null will be returned. an AlgorithmParameterSpec which holds the maximum value or null. - if is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\".\n• Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). - the buffer containing the Additional Authentication Data - if the byte array is null - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation\n• Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). - the buffer containing the AAD - the offset in where the AAD input starts - if the byte array is null, or the or is less than 0, or the sum of the and is greater than the length of the byte array - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation\n• Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). All bytes starting at are processed. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. - the buffer containing the AAD - if the is null - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/index.html?javax/crypto/Cipher.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://ibm.com/docs/en/sdk-java-technology/8?topic=jce-cipher",
        "document": "\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new Cipher object encapsulating the CipherSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the method. - the name of the transformation, e.g., DES/CBC/PKCS5Padding. See Appendix A in the Java Cryptography Extension Reference Guide for information about standard transformation names. - if is null, empty, in an invalid format, or if no Provider supports a CipherSpi implementation for the specified algorithm. - if contains a padding scheme that is not available.\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the method. - the name of the transformation, e.g., DES/CBC/PKCS5Padding. See Appendix A in the Java Cryptography Extension Reference Guide for information about standard transformation names. - the name of the provider. - if is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified provider. - if the specified provider is not registered in the security provider list. - if contains a padding scheme that is not available. - if the is null or empty.\n• object that implements the specified transformation. Returns aobject that implements the specified transformation. A new Cipher object encapsulating the CipherSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list. - the name of the transformation, e.g., DES/CBC/PKCS5Padding. See Appendix A in the Java Cryptography Extension Reference Guide for information about standard transformation names. - if is null, empty, in an invalid format, or if a CipherSpi implementation for the specified algorithm is not available from the specified Provider object. - if contains a padding scheme that is not available. - if the is null.\n• Returns the provider of this object. the provider of this object\n• object. Returns the algorithm name of thisobject. This is the same name that was specified in one of the calls that created this object.. the algorithm name of this object.\n• the block size (in bytes), or 0 if the underlying algorithm is not a block cipher\n• or operation, given the input length (in bytes). Returns the length in bytes that an output buffer would need to be in order to hold the result of the nextoroperation, given the input length(in bytes). This call takes into account any unprocessed (buffered) data from a previous call, padding, and AEAD tagging. The actual output length of the next or call may be smaller than the length returned by this method. - if this cipher is in a wrong state (e.g., has not yet been initialized)\n• Returns the initialization vector (IV) in a new buffer. This is useful in the case where a random IV was created, or in the context of password-based encryption or decryption, where the IV is derived from a user-supplied password. the initialization vector in a new buffer, or null if the underlying algorithm does not use an IV, or if the IV has not yet been set.\n• Returns the parameters used with this cipher. The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any. the parameters used with this cipher, or null if this cipher does not use any parameters.\n• Returns the exemption mechanism object used with this cipher. the exemption mechanism object used with this cipher, or null if this cipher does not use any exemption mechanism.\n• The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters that cannot be derived from the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters that cannot be derived from the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key, or if the given key has a keysize that exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key and a set of algorithm parameters. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If this cipher requires any algorithm parameters and is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the given key is inappropriate for initializing this cipher, or its keysize exceeds the maximum allowable keysize (as determined from the configured jurisdiction policy files). - if the given algorithm parameters are inappropriate for this cipher, or this cipher requires algorithm parameters and is null, or the given algorithm parameters imply a cryptographic strength that would exceed the legal limits (as determined from the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with the public key from the given certificate. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of , an is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given certificate, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them using the implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.) Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the public key in the given certificate is inappropriate for initializing this cipher, or cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Initializes this cipher with the public key from the given certificate and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of . If the certificate is of type X.509 and has a key usage extension field marked as critical, and the value of the key usage extension field implies that the public key in the certificate and its corresponding private key are not supposed to be used for the operation represented by the value of , an is thrown. If this cipher requires any algorithm parameters that cannot be derived from the public key in the given , the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using or (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from . Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it. - the operation mode of this cipher (this is one of the following: , , or ) - if the public key in the given certificate is inappropriate for initializing this cipher, or this cipher requires algorithm parameters that cannot be determined from the public key in the given certificate, or the keysize of the public key in the given certificate has a keysize that exceeds the maximum allowable keysize (as determined by the configured jurisdiction policy files). - if (@code opmode} is or but the mode is not implemented by the underlying .\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The bytes in the buffer are processed, and the result is stored in a new buffer. If has a length of zero, this method returns . the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block. - if this cipher is in a wrong state (e.g., has not been initialized)\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in a new buffer. If is zero, this method returns . - the offset in where the input starts the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block. - if this cipher is in a wrong state (e.g., has not been initialized)\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in the buffer. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. If is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if the given output buffer is too small to hold the result\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first bytes in the buffer, starting at inclusive, are processed, and the result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. If is zero, this method returns a length of zero. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if the given output buffer is too small to hold the result\n• Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. All bytes starting at are processed. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If bytes are insufficient to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Note: this method should be copy-safe, which means the and buffers can reference the same block of memory and no unprocessed input data is overwritten when the result is copied into the output buffer. the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if input and output are the same object - if the output buffer is read-only - if there is insufficient space in the output buffer\n• Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized. Input data that may have been buffered during a previous operation is processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The bytes in the buffer, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. - the offset in where the input starts the new buffer with the result - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first bytes in the buffer, starting at inclusive, and any input bytes that may have been buffered during a previous operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the buffer, starting at inclusive. If the buffer is too small to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. - the offset in where the input starts - the buffer for the result - the offset in where the result is stored the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if the given output buffer is too small to hold the result - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. All bytes starting at are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If bytes are insufficient to hold the result, a is thrown. In this case, repeat this call with a larger output buffer. Use to determine how big the output buffer should be. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to . That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to ) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Note: this method should be copy-safe, which means the and buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer. the number of bytes stored in - if this cipher is in a wrong state (e.g., has not been initialized) - if input and output are the same object - if the output buffer is read-only - if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided. - if there is insufficient space in the output buffer - if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes - if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value\n• - the key to be wrapped. - if this cipher is in a wrong state (e.g., has not been initialized). - if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size. - if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher). - if the corresponding method in the is not supported.\n• - the key to be unwrapped. - the algorithm associated with the wrapped key. - the type of the wrapped key. This must be one of , , or . - if this cipher is in a wrong state (e.g., has not been initialized). - if no installed providers can create keys of type for the . - if does not represent a wrapped key of type for the . - if the corresponding method in the is not supported.\n• Returns the maximum key length for the specified transformation according to the installed JCE jurisdiction policy files. If JCE unlimited strength jurisdiction policy files are installed, Integer.MAX_VALUE will be returned. For more information on default key size in JCE jurisdiction policy files, please see appendix E in JCE Reference Guide the maximum key length in bits or Integer.MAX_VALUE. - if is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\".\n• Returns an AlgorithmParameterSpec object which contains the maximum cipher parameter value according to the jurisdiction policy file. If JCE unlimited strength jurisdiction policy files are installed or there is no maximum limit on the parameters for the specified transformation in the policy file, null will be returned. an AlgorithmParameterSpec which holds the maximum value or null. - if is not a valid transformation, i.e. in the form of \"algorithm\" or \"algorithm/mode/padding\".\n• Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). - the buffer containing the Additional Authentication Data - if the byte array is null - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation\n• Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). - the buffer containing the AAD - the offset in where the AAD input starts - if the byte array is null, or the or is less than 0, or the sum of the and is greater than the length of the byte array - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation\n• Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the and methods). All bytes starting at are processed. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. - the buffer containing the AAD - if the is null - if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the methods has already been called for the active encryption/decryption operation - if the corresponding method in the has not been overridden by an implementation"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/javax.crypto.cipher?view=net-android-35.0",
        "document": "This class provides the functionality of a cryptographic cipher for encryption and decryption. It forms the core of the Java Cryptographic Extension (JCE) framework.\n\nIn order to create a Cipher object, the application calls the Cipher's method, and passes the name of the requested transformation to it. Optionally, the name of a provider may be specified.\n\nA transformation is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., DES), and may be followed by a feedback mode and padding scheme.\n\nA transformation is of the form:\n\n(in the latter case, provider-specific default values for the mode and padding scheme are used). For example, the following is a valid transformation:\n\nUsing modes such as and , block ciphers can encrypt data in units smaller than the cipher's actual block size. When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the \" \" and \" \" transformations. If no such number is specified, a provider-specific default is used. (For example, the SunJCE provider uses a default of 64 bits for DES.) Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8.\n\nModes such as Authenticated Encryption with Associated Data (AEAD) provide authenticity assurances for both confidential data and Additional Associated Data (AAD) that is not encrypted. (Please see RFC 5116 for more information on AEAD and AEAD algorithms such as GCM/CCM.) Both confidential and AAD data can be used when calculating the authentication tag (similar to a ). This tag is appended to the ciphertext during encryption, and is verified on decryption.\n\nAEAD modes such as GCM/CCM perform all AAD authenticity calculations before starting the ciphertext authenticity calculations. To avoid implementations having to internally buffer ciphertext, all AAD data must be supplied to GCM/CCM implementations (via the methods) <b>before</b> the ciphertext is processed (via the and methods).\n\nNote that GCM mode has a uniqueness requirement on IVs used in encryption with a given key. When IVs are repeated for GCM encryption, such usages are subject to forgery attacks. Thus, after each encryption operation using GCM mode, callers should re-initialize the cipher objects with GCM parameters which has a different IV value.\n\nAndroid provides the following transformations: <table> <thead> <tr> <th>Algorithm</th> <th>Modes</th> <th>Paddings</th> <th>Supported API Levels</th> <th>Notes</th> </tr> </thead> <tbody> <tr> <td rowspan=\"3\"><span style=\"white-space: nowrap\">AES</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">CFB</span><br><span style=\"white-space: nowrap\">CTR</span><br><span style=\"white-space: nowrap\">CTS</span><br><span style=\"white-space: nowrap\">ECB</span><br><span style=\"white-space: nowrap\">OFB</span></td> <td><span style=\"white-space: nowrap\">ISO10126Padding</span><br><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">1+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">10+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM-SIV</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">30+</span></td> <td></td> </tr> <tr> <td rowspan=\"3\"><span style=\"white-space: nowrap\">AES_128</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">ECB</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">26+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">26+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM-SIV</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">30+</span></td> <td></td> </tr> <tr> <td rowspan=\"3\"><span style=\"white-space: nowrap\">AES_256</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">ECB</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">26+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">26+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">GCM-SIV</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">30+</span></td> <td></td> </tr> <tr> <td rowspan=\"2\"><span style=\"white-space: nowrap\">ARC4</span></td> <td><span style=\"white-space: nowrap\">ECB</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">10+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">NONE</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">28+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">BLOWFISH</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">CFB</span><br><span style=\"white-space: nowrap\">CTR</span><br><span style=\"white-space: nowrap\">CTS</span><br><span style=\"white-space: nowrap\">ECB</span><br><span style=\"white-space: nowrap\">OFB</span></td> <td><span style=\"white-space: nowrap\">ISO10126Padding</span><br><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">10+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">ChaCha20</span></td> <td><span style=\"white-space: nowrap\">NONE</span><br><span style=\"white-space: nowrap\">Poly1305</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span></td> <td><span style=\"white-space: nowrap\">28+</span></td> <td>ChaCha with 20 rounds, 96-bit nonce, and 32-bit counter as described in RFC 7539.</td> </tr> <tr> <td><span style=\"white-space: nowrap\">DES</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">CFB</span><br><span style=\"white-space: nowrap\">CTR</span><br><span style=\"white-space: nowrap\">CTS</span><br><span style=\"white-space: nowrap\">ECB</span><br><span style=\"white-space: nowrap\">OFB</span></td> <td><span style=\"white-space: nowrap\">ISO10126Padding</span><br><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">1+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">DESede</span></td> <td><span style=\"white-space: nowrap\">CBC</span><br><span style=\"white-space: nowrap\">CFB</span><br><span style=\"white-space: nowrap\">CTR</span><br><span style=\"white-space: nowrap\">CTS</span><br><span style=\"white-space: nowrap\">ECB</span><br><span style=\"white-space: nowrap\">OFB</span></td> <td><span style=\"white-space: nowrap\">ISO10126Padding</span><br><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">PKCS5Padding</span></td> <td><span style=\"white-space: nowrap\">1+</span></td> <td></td> </tr> <tr> <td rowspan=\"3\"><span style=\"white-space: nowrap\">RSA</span></td> <td rowspan=\"3\"><span style=\"white-space: nowrap\">ECB</span><br><span style=\"white-space: nowrap\">NONE</span></td> <td><span style=\"white-space: nowrap\">NoPadding</span><br><span style=\"white-space: nowrap\">OAEPPadding</span><br><span style=\"white-space: nowrap\">PKCS1Padding</span></td> <td><span style=\"white-space: nowrap\">1+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">OAEPwithSHA-1andMGF1Padding</span><br><span style=\"white-space: nowrap\">OAEPwithSHA-256andMGF1Padding</span></td> <td><span style=\"white-space: nowrap\">10+</span></td> <td></td> </tr> <tr> <td><span style=\"white-space: nowrap\">OAEPwithSHA-224andMGF1Padding</span><br><span style=\"white-space: nowrap\">OAEPwithSHA-384andMGF1Padding</span><br><span style=\"white-space: nowrap\">OAEPwithSHA-512andMGF1Padding</span></td> <td><span style=\"white-space: nowrap\">23+</span></td> <td></td> </tr> </tbody> </table>\n\nThese transformations are described in the Cipher section of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License."
    },
    {
        "link": "https://public.dhe.ibm.com/s390/java/jce4758/API_users_guide.html",
        "document": "Note : Before using this information and the product it supports, be sure to read the general information under Notices .\n\nHow to Make Applications \"Exempt\" from Cryptographic Restrictions\n• import java.math.BigInteger;\n\n import java.security.AlgorithmParameterGenerator;\n\n import java.security.AlgorithmParameters;\n\n import java.security.KeyFactory;\n\n import java.security.KeyPair;\n\n import java.security.KeyPairGenerator;\n\n import java.security.PublicKey;\n\n import java.security.spec.X509EncodedKeySpec;\n\n import java.util.Arrays;\n\n\n\n import javax.crypto.Cipher;\n\n import javax.crypto.KeyAgreement;\n\n import javax.crypto.SecretKey;\n\n import javax.crypto.ShortBufferException;\n\n import javax.crypto.interfaces.DHPublicKey;\n\n import javax.crypto.spec.DHParameterSpec;\n\n\n\n /**\n\n * This program executes the Diffie-Hellman key agreement protocol\n\n * between 2 parties: Alice and Bob.\n\n *\n\n * By default, preconfigured parameters (1024-bit prime modulus and base\n\n * generator used by SKIP) are used.\n\n * If this program is called with the \"-gen\" option, a new set of\n\n * parameters is created.\n\n */\n\n\n\n public class DHKeyAgreement2 {\n\n\n\n private DHKeyAgreement2() {\n\n }\n\n\n\n public static void main(String argv[]) {\n\n try {\n\n String mode = \"USE_SKIP_DH_PARAMS\";\n\n\n\n DHKeyAgreement2 keyAgree = new DHKeyAgreement2();\n\n\n\n if (argv.length > 1) {\n\n keyAgree.usage();\n\n throw new Exception(\"Wrong number of command options\");\n\n } else\n\n if (argv.length == 1) {\n\n if (!(argv[0].equals(\"-gen\"))) {\n\n keyAgree.usage();\n\n throw new Exception(\"Unrecognized flag: \" + argv[0]);\n\n }\n\n mode = \"GENERATE_DH_PARAMS\";\n\n }\n\n\n\n keyAgree.run(mode);\n\n } catch (Exception e) {\n\n System.err.println(\"Error: \" + e);\n\n System.exit(1);\n\n }\n\n }\n\n\n\n private void run(String mode) throws Exception {\n\n\n\n DHParameterSpec dhSkipParamSpec;\n\n\n\n if (mode.equals(\"GENERATE_DH_PARAMS\")) {\n\n // Some central authority creates new DH parameters\n\n System.out.println(\"Creating Diffie-Hellman parameters (takes VERY long) ...\");\n\n AlgorithmParameterGenerator paramGen =\n\n AlgorithmParameterGenerator.getInstance(\"DH\");\n\n paramGen.init(512);\n\n AlgorithmParameters params = paramGen.generateParameters();\n\n dhSkipParamSpec =\n\n (DHParameterSpec) params.getParameterSpec(DHParameterSpec.class);\n\n } else {\n\n // use some pre-generated, default DH parameters\n\n System.out.println(\"Using SKIP Diffie-Hellman parameters\");\n\n dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);\n\n }\n\n\n\n /*\n\n * Alice creates her own DH key pair, using the DH parameters from\n\n * above\n\n */\n\n System.out.println(\"ALICE: Generate DH keypair ...\");\n\n KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(\"DH\");\n\n aliceKpairGen.initialize(dhSkipParamSpec);\n\n KeyPair aliceKpair = aliceKpairGen.generateKeyPair();\n\n\n\n // Alice creates and initializes her DH KeyAgreement object\n\n System.out.println(\"ALICE: Initialization ...\");\n\n KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(\"DH\");\n\n aliceKeyAgree.init(aliceKpair.getPrivate());\n\n\n\n // Alice encodes her public key, and sends it over to Bob.\n\n byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();\n\n\n\n /*\n\n * Let's turn over to Bob. Bob has received Alice's public key\n\n * in encoded format.\n\n * He instantiates a DH public key from the encoded key material.\n\n */\n\n KeyFactory bobKeyFac = KeyFactory.getInstance(\"DH\");\n\n X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(alicePubKeyEnc);\n\n PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);\n\n\n\n /*\n\n * Bob gets the DH parameters associated with Alice's public key. \n\n * He must use the same parameters when he generates his own key\n\n * pair.\n\n */\n\n DHParameterSpec dhParamSpec = ((DHPublicKey) alicePubKey).getParams();\n\n\n\n // Bob creates his own DH key pair\n\n System.out.println(\"BOB: Generate DH keypair ...\");\n\n KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(\"DH\");\n\n bobKpairGen.initialize(dhParamSpec);\n\n KeyPair bobKpair = bobKpairGen.generateKeyPair();\n\n\n\n // Bob creates and initializes his DH KeyAgreement object\n\n System.out.println(\"BOB: Initialization ...\");\n\n KeyAgreement bobKeyAgree = KeyAgreement.getInstance(\"DH\");\n\n bobKeyAgree.init(bobKpair.getPrivate());\n\n\n\n // Bob encodes his public key, and sends it over to Alice.\n\n byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();\n\n\n\n /*\n\n * Alice uses Bob's public key for the first (and only) phase\n\n * of her version of the DH\n\n * protocol.\n\n * Before she can do so, she has to instanticate a DH public key\n\n * from Bob's encoded key material.\n\n */\n\n KeyFactory aliceKeyFac = KeyFactory.getInstance(\"DH\");\n\n x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);\n\n PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);\n\n System.out.println(\"ALICE: Execute PHASE1 ...\");\n\n aliceKeyAgree.doPhase(bobPubKey, true);\n\n\n\n /*\n\n * Bob uses Alice's public key for the first (and only) phase\n\n * of his version of the DH\n\n * protocol.\n\n */\n\n System.out.println(\"BOB: Execute PHASE1 ...\");\n\n bobKeyAgree.doPhase(alicePubKey, true);\n\n\n\n /*\n\n * At this stage, both Alice and Bob have completed the DH key\n\n * agreement protocol.\n\n * Both generate the (same) shared secret.\n\n */\n\n byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();\n\n int aliceLen = aliceSharedSecret.length;\n\n\n\n byte[] bobSharedSecret = new byte[aliceLen];\n\n int bobLen;\n\n try {\n\n // show example of what happens if you\n\n // provide an output buffer that is too short\n\n bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 1);\n\n } catch (ShortBufferException e) {\n\n System.out.println(e.getMessage());\n\n }\n\n // provide output buffer of required size\n\n bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);\n\n\n\n System.out.println(\"Alice secret: \" + toHexString(aliceSharedSecret));\n\n System.out.println(\"Bob secret: \" + toHexString(bobSharedSecret));\n\n\n\n if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))\n\n throw new Exception(\"Shared secrets differ\");\n\n System.out.println(\"Shared secrets are the same\");\n\n\n\n /*\n\n * Now let's return the shared secret as a SecretKey object\n\n * and use it for encryption. First, we generate SecretKeys for the\n\n * \"DES\" algorithm (based on the raw shared secret data) and\n\n * then we use DES in ECB mode\n\n * as the encryption algorithm. DES in ECB mode does not require any\n\n * parameters.\n\n *\n\n * Then we use DES in CBC mode, which requires an initialization\n\n * vector (IV) parameter. In CBC mode, you need to initialize the\n\n * Cipher object with an IV, which can be supplied using the\n\n * javax.crypto.spec.IvParameterSpec class. Note that you have to use\n\n * the same IV for encryption and decryption: If you use a different\n\n * IV for decryption than you used for encryption, decryption will\n\n * fail.\n\n *\n\n * Note: If you do not specify an IV when you initialize the\n\n * Cipher object for encryption, the underlying implementation\n\n * will generate a random IV. You will have to retrieve this IV using the\n\n * javax.crypto.Cipher.getParameters() method, which returns an \n\n * instance of java.security.AlgorithmParameters. You need to transfer\n\n * the contents of that object (for example, in encoded format, obtained \n\n * using the AlgorithmParameters.getEncoded() method) to the party who will\n\n * do the decryption. When initializing the Cipher for decryption,\n\n * the (reinstantiated) AlgorithmParameters object must be passed to\n\n * the Cipher.init() method.\n\n */\n\n System.out.println(\"Return shared secret as SecretKey object ...\");\n\n // Bob\n\n // Note: The call to bobKeyAgree.generateSecret above reset the key\n\n // agreement object, so we call doPhase again prior to another\n\n // generateSecret call\n\n bobKeyAgree.doPhase(alicePubKey, true);\n\n SecretKey bobDesKey = bobKeyAgree.generateSecret(\"DES\");\n\n\n\n // Alice\n\n // Note: The call to aliceKeyAgree.generateSecret above reset the key\n\n // agreement object, so we call doPhase again prior to another\n\n // generateSecret call\n\n aliceKeyAgree.doPhase(bobPubKey, true);\n\n SecretKey aliceDesKey = aliceKeyAgree.generateSecret(\"DES\");\n\n\n\n /*\n\n * Bob encrypts, using DES in ECB mode\n\n */\n\n Cipher bobCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);\n\n\n\n byte[] cleartext = \"This is just an example\".getBytes();\n\n byte[] ciphertext = bobCipher.doFinal(cleartext);\n\n\n\n /*\n\n * Alice decrypts, using DES in ECB mode\n\n */\n\n Cipher aliceCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey);\n\n byte[] recovered = aliceCipher.doFinal(ciphertext);\n\n\n\n if (!java.util.Arrays.equals(cleartext, recovered))\n\n throw new Exception(\n\n \"DES in CBC mode recovered text is \" + \"different from cleartext\");\n\n System.out.println(\"DES in ECB mode recovered text is \" + \"same as cleartext\");\n\n\n\n /*\n\n * Bob encrypts, using DES in CBC mode\n\n */\n\n bobCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);\n\n\n\n cleartext = \"This is just an example\".getBytes();\n\n ciphertext = bobCipher.doFinal(cleartext);\n\n // Retrieve the parameter that was used, and transfer it to Alice in\n\n // encoded format\n\n byte[] encodedParams = bobCipher.getParameters().getEncoded();\n\n\n\n /*\n\n * Alice decrypts, using DES in CBC mode\n\n */\n\n // Instantiate AlgorithmParameters object from parameter encoding\n\n // obtained from Bob\n\n AlgorithmParameters params = AlgorithmParameters.getInstance(\"DES\");\n\n params.init(encodedParams);\n\n aliceCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params);\n\n recovered = aliceCipher.doFinal(ciphertext);\n\n\n\n if (!java.util.Arrays.equals(cleartext, recovered))\n\n throw new Exception(\n\n \"DES in CBC mode recovered text is \" + \"different from cleartext\");\n\n System.out.println(\"DES in CBC mode recovered text is \" + \"same as cleartext\");\n\n }\n\n\n\n /*\n\n * Converts a byte to hex digit and writes to the supplied buffer\n\n */\n\n private void byte2hex(byte b, StringBuffer buf) {\n\n char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n\n '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\n int high = ((b & 0xf0) >> 4);\n\n int low = (b & 0x0f);\n\n buf.append(hexChars[high]);\n\n buf.append(hexChars[low]);\n\n }\n\n\n\n /*\n\n * Converts a byte array to hex string\n\n */\n\n private String toHexString(byte[] block) {\n\n StringBuffer buf = new StringBuffer();\n\n\n\n int len = block.length;\n\n\n\n for (int i = 0; i < len; i++) {\n\n byte2hex(block[i], buf);\n\n if (i < len - 1) {\n\n buf.append(\":\");\n\n }\n\n }\n\n return buf.toString();\n\n }\n\n\n\n /*\n\n * Prints the usage of this test.\n\n */\n\n private void usage() {\n\n System.err.print(\"DHKeyAgreement usage: \");\n\n System.err.println(\"[-gen]\");\n\n }\n\n\n\n // The 1024 bit Diffie-Hellman modulus values used by SKIP\n\n private static final byte skip1024ModulusBytes[] = {\n\n (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,\n\n (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,\n\n (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,\n\n (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,\n\n (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,\n\n (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,\n\n (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,\n\n (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,\n\n (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,\n\n (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,\n\n (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,\n\n (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,\n\n (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,\n\n (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,\n\n (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,\n\n (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,\n\n (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,\n\n (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,\n\n (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,\n\n (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,\n\n (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,\n\n (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,\n\n (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,\n\n (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,\n\n (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,\n\n (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,\n\n (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,\n\n (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,\n\n (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,\n\n (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,\n\n (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,\n\n (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7\n\n };\n\n\n\n\n\n // The SKIP 1024 bit modulus\n\n private static final BigInteger skip1024Modulus =\n\n new BigInteger(1, skip1024ModulusBytes);\n\n\n\n // The base used with the SKIP 1024 bit modulus\n\n private static final BigInteger skip1024Base = BigInteger.valueOf(2);\n\n}\n• import java.math.BigInteger;\n\n import java.security.Key;\n\nimport java.security.KeyPair;\n\n import java.security.KeyPairGenerator;\n\n import java.util.Arrays;\n\n\n\n import javax.crypto.KeyAgreement;\n\nimport javax.crypto.spec.DHParameterSpec;\n\n\n\n /**\n\n * This program executes the Diffie-Hellman key agreement protocol\n\n * between 3 parties: Alice, Bob, and Carol.\n\n *\n\n * We use the same 1024-bit prime modulus and base generator that are \n\n * used by SKIP.\n\n */\n\n\n\npublic class DHKeyAgreement3 {\n\n\n\n private DHKeyAgreement3() {\n\n }\n\n\n\n public static void main(String argv[]) {\n\n try {\n\n DHKeyAgreement3 keyAgree = new DHKeyAgreement3();\n\n keyAgree.run();\n\n } catch (Exception e) {\n\n System.err.println(\"Error: \" + e );\n\n System.exit(1);\n\n }\n\n }\n\n\n\n private void run() throws Exception {\n\n\n\n DHParameterSpec dhSkipParamSpec;\n\n\n\n System.out.println(\"Using SKIP Diffie- Hellman parameters\");\n\n dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);\n\n\n\n // Alice creates her own DH key pair\n\n System.out.println(\"ALICE: Generate DH keypair ...\");\n\n KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(\"DH\");\n\n aliceKpairGen.initialize(dhSkipParamSpec);\n\n KeyPair aliceKpair = aliceKpairGen.generateKeyPair();\n\n\n\n // Bob creates his own DH key pair\n\n System.out.println(\"BOB: Generate DH keypair ...\");\n\n KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance(\"DH\");\n\n bobKpairGen.initialize(dhSkipParamSpec);\n\n KeyPair bobKpair = bobKpairGen. generateKeyPair();\n\n\n\n // Carol creates her own DH key pair\n\n System.out.println(\"CAROL: Generate DH keypair ...\");\n\n KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance(\"DH\");\n\n carolKpairGen.initialize(dhSkipParamSpec);\n\n KeyPair carolKpair = carolKpairGen.generateKeyPair();\n\n\n\n // Alice initialize\n\n System.out.println(\"ALICE: Initialize ...\");\n\n KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(\"DH\");\n\n aliceKeyAgree.init(aliceKpair.getPrivate());\n\n\n\n // Bob initialize\n\n System.out.println(\"BOB: Initialize ...\");\n\n KeyAgreement bobKeyAgree = KeyAgreement.getInstance(\"DH\");\n\n bobKeyAgree.init(bobKpair.getPrivate());\n\n\n\n // Carol initialize\n\n System.out.println(\"CAROL: Initialize ...\");\n\n KeyAgreement carolKeyAgree = KeyAgreement.getInstance(\"DH\");\n\n carolKeyAgree.init(carolKpair.getPrivate());\n\n\n\n // Alice uses Carol's public key\n\n Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);\n\n\n\n // Bob uses Alice's public key\n\n Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);\n\n\n\n // Carol uses Bob's public key\n\n Key cb = carolKeyAgree.doPhase(bobKpair. getPublic(), false);\n\n\n\n // Alice uses Carol's result from above\n\n aliceKeyAgree.doPhase(cb, true);\n\n\n\n // Bob uses Alice's result from above\n\n bobKeyAgree.doPhase(ac, true);\n\n\n\n // Carol uses Bob's result from above\n\n carolKeyAgree.doPhase(ba, true);\n\n\n\n // Alice, Bob and Carol compute their secrets\n\n byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();\n\n System.out.println(\"Alice secret: \" + toHexString(aliceSharedSecret));\n\n\n\n byte[] bobSharedSecret = bobKeyAgree.generateSecret();\n\n System.out.println(\"Bob secret: \" + toHexString(bobSharedSecret));\n\n\n\n byte[] carolSharedSecret = carolKeyAgree.generateSecret();\n\n System.out.println(\"Carol secret: \" + toHexString(carolSharedSecret));\n\n\n\n // Compare Alice and Bob\n\n if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))\n\n throw new Exception(\"Alice and Bob differ\");\n\n System.out.println(\"Alice and Bob are the same\");\n\n\n\n // Compare Bob and Carol\n\n if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))\n\n throw new Exception(\"Bob and Carol differ\");\n\n System.out.println(\"Bob and Carol are the same\");\n\n }\n\n\n\n /*\n\n * Converts a byte to hex digit and writes to the supplied buffer\n\n */\n\n private void byte2hex(byte b, StringBuffer buf) {\n\n char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n\n '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n\n int high = ((b & 0xf0) >> 4);\n\n int low = (b & 0x0f);\n\n buf.append(hexChars[high]);\n\n buf.append(hexChars[low]);\n\n }\n\n\n\n /*\n\n * Converts a byte array to hex string\n\n */\n\n private String toHexString(byte[] block) {\n\n StringBuffer buf = new StringBuffer();\n\n\n\n int len = block.length;\n\n\n\n for (int i = 0; i < len; i++) {\n\n byte2hex(block[i], buf);\n\n if (i < len - 1) {\n\n buf.append(\":\");\n\n }\n\n }\n\n return buf.toString();\n\n }\n\n\n\n /*\n\n * Prints the usage of this test.\n\n */\n\n private void usage() {\n\n System.err.print(\"DHKeyAgreement usage: \");\n\n System.err.println(\"[-gen]\");\n\n }\n\n\n\n // The 1024 bit Diffie-Hellman modulus values used by SKIP\n\n private static final byte skip1024ModulusBytes[] = {\n\n (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,\n\n (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,\n\n (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,\n\n (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,\n\n (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,\n\n (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,\n\n (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,\n\n (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,\n\n (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,\n\n (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,\n\n (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,\n\n (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,\n\n (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,\n\n (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,\n\n (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,\n\n (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,\n\n (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,\n\n (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,\n\n (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,\n\n (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,\n\n (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,\n\n (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,\n\n (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,\n\n (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,\n\n (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,\n\n (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,\n\n (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,\n\n (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,\n\n (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,\n\n (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,\n\n (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,\n\n (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7\n\n };\n\n\n\n\n\n // The SKIP 1024 bit modulus\n\n private static final BigInteger skip1024Modulus =\n\n new BigInteger(1, skip1024ModulusBytes);\n\n\n\n // The base used with the SKIP 1024 bit modulus\n\n private static final BigInteger skip1024Base = BigInteger.valueOf(2);\n\n }\n• import javax.crypto.Cipher;\n\nimport javax.crypto.KeyGenerator;\n\n import javax.crypto.SecretKey;\n\nimport javax.crypto.spec.SecretKeySpec;\n\n\n\n /**\n\n * This program generates a Blowfish key, retrieves its raw bytes, and \n\n * then reinstantiates a Blowfish key from the key bytes.\n\n * The reinstantiated key is used to initialize a Blowfish cipher for\n\n * encryption.\n\n */\n\n\n\npublic class BlowfishKey {\n\n\n\n public static void main(String[] args) throws Exception {\n\n\n\n KeyGenerator kgen = KeyGenerator.getInstance(\"Blowfish\");\n\n SecretKey skey = kgen.generateKey();\n\n byte[] raw = skey.getEncoded();\n\n SecretKeySpec skeySpec = new SecretKeySpec(raw, \"Blowfish\");\n\n\n\n Cipher cipher = Cipher.getInstance(\"Blowfish\");\n\n cipher.init(Cipher. ENCRYPT_MODE, skeySpec);\n\n byte[] encrypted = cipher.doFinal(\"This is just an example\".getBytes());\n\n }\n\n }\n• import javax.crypto.KeyGenerator;\n\nimport javax.crypto.Mac;\n\n import javax.crypto.SecretKey;\n\n\n\n/**\n\n * This program demonstrates how to generate a secret-key object for\n\n * HMAC-MD5, and initialize an HMAC-MD5 object with it.\n\n */\n\n\n\npublic class initMac {\n\n\n\n public static void main(String[] args) throws Exception {\n\n\n\n // Generate secret key for HMAC-MD5\n\n KeyGenerator kg = KeyGenerator.getInstance(\"HmacMD5\");\n\n SecretKey sk = kg. generateKey();\n\n\n\n // Get instance of Mac object implementing HMAC-MD5, and \n\n // initialize it with the above secret key\n\n Mac mac = Mac.getInstance(\"HmacMD5\");\n\n mac.init(sk);\n\n byte[] result = mac.doFinal(\"Hi There\".getBytes());\n\n }\n\n}\n• Other example code can be found in the samples package.\n\nThe IBMJCECCA provider replaces the IBMJCE4758 provider from earlier releases. The IBMJCECCA provider extends Java Cryptography Extension (JCE) and Java Cryptography Architecture (JCA) seamlessly to add the capability to use hardware cryptography using IBM Common Cryptographic Architecture (CCA) interfaces. This provider implements the existing JCE architecture, taking advantage of hardware cryptography to give Java SE programmers the significant security and performance advantages of hardware cryptography with minimal changes to existing Java applications. Because the complexities of hardware cryptography are handled within the normal JCE APIs, the advanced security and performance of hardware cryptographic devices are made easily available. IBM CCA is a set of software elements that provide common application interfaces to secure, high-speed cryptographic services on various platforms using hardware cryptographic devices. On the z/OS platform, access to hardware cryptographic devices is controlled by the Integrated Cryptographic Service Facility (ICSF). The ICSF component of z/OS provides IBM Common Cryptographic Architecture interfaces to hardware devices. One or more hardware cryptography features must be installed in order to use the IBMJCECCA provider. For more information about the cryptographic features supported, refer to the zSeries machine's reference or technical guide and your service / support organization. See http://www-03.ibm.com/systems/z/os/zos/tools/java/products/j6jcecca.html#over for more information about the cryptographic services which are supported by the hardware cryptographic devices you have installed. The \"Configuring and using hardware cryptographic devices on z/OS\" section of this document should be consulted for configuring the correct hardware environment. In addition, the unrestricted policy files in your JVM should be installed to allow the IBMJCECCA provider to load and to function. The IBMJCECCA provider supports the following:\n• Message Digest via the MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512 algorithms\n• the symmetric algorithms AES, DES, triple DES (also known as DESede), HMAC, PBE\n• the asymmetric algorithms RSA encryption and decryption with zero padding and PKCS 1 type 2 padding\n• digital signature creation and verification using the RSA and DSA algorithms (note that DSA is only supported on IBM eServer zSeries 800 (z800) and IBM eServer zSeries 900 (z900) hardware)\n• generation and management of keys and certificates using the application Like other JCE providers, the IBMJCECCA provider can be added to the JVM using the and methods, and by adding it to the provider list in the lib/ext/java.security file. In the cryptography environment there are multiple ways to take advantage of cryptographic hardware. The IBMJCECCA provider supports multiple types of hardware utilization. Once an asymmetric key pair or symmetric key is generated, it is tied to the hardware type used to generate it. The type supported for asymmetric key pairs is \"PKDS\". The two types supported only for symmetric keys are \"CKDS\" and \"PROTECTED\". Type \"CLEAR\" is supported both for asymmetric key pairs and for symmetric keys. Each type is described in more detail below. The types of hardware utilization make trade offs between increased security and increased performance but, in general, any type of hardware cryptographic utilization is more secure than similar cryptographic functions provided by a provider implemented to use only software cryptography. These keys are known to ICSF as encrypted DATA keys. In this case the encrypted DATA key is subsequently stored in the PKDS. The hardware can be used with key pairs to provide increased security and also to take advantage of multiple hardware devices on the system. Key pairs generated using this high level of security are called PKDS key pairs. When a PKDS key pair is generated, the private key is encrypted using the system's master key, and the key pair is stored in a system key storage area. This key storage area is a RACF-protected data set. The clear text version of this key can never be viewed or retrieved. What is stored in the JCE keystore or returned to the application at key pair generation is only a reference to the private key, called a label. Because the key is stored in a data set instead of on a particular hardware device, cryptographic operations using PKDS key pairs can take advantage of multiple cryptographic hardware devices. When a cryptographic operation request is received, the private key is decrypted by the CCA software layer and the request is submitted to the next available cryptographic device. The PKDS key type provides the highest level of security supported by the IBMJCECCA provider. Operations using PKDS key types are more secure and generally slower than similar operations using CLEAR type key pairs. These keys are known to ICSF as encrypted DATA keys. In this case the encrypted DATA key is subsequently stored in the CKDS. The hardware can be used with symmetric keys to provide increased security and also to take advantage of multiple hardware devices on the system. Symmetric keys generated using this high level of security are called CKDS keys. When a CKDS key is generated, it is encrypted using the system's master key and the resulting key token is stored in a system key storage area. This key storage area is a RACF-protected data set. The clear text version of this key can never be viewed or retrieved. What is stored in the JCE keystore or returned to the application at key generation is only a reference to the key, called a label. Because the key is stored in a data set instead of on a particular hardware device, cryptographic operations using CKDS keys can take advantage of multiple cryptographic hardware devices. When a cryptographic operation request is received, the key is decrypted by the CCA software layer and the request is submitted to the next available cryptographic device. The system master key can only be changed using the ICSF component of z/OS. When the system master key is changed, ICSF also updates the CKDS entries so that the keys it contains will be encrypted using the new system master key. This ensures that CKDS keys remain usable even if the system master key is changed. The CKDS key type provides the highest level of security supported by the IBMJCECCA provider for symmetric keys. Operations using CKDS key types are the most secure symmetric key operations supported by the IBMJCECCA provider. These keys are known to ICSF as encrypted DATA keys. The hardware can be used with symmetric keys to provide increased security and also to take advantage of multiple hardware devices on the system. Symmetric keys generated using this level of security are called PROTECTED keys. When a PROTECTED key is generated, it is encrypted using the system's master key. What is stored in the JCE keystore or returned to the application at key generation is only the encrypted key, called a key token. Because the system master key is never available outside the CCA software layer, a PROTECTED key is more secure than a CLEAR key. When a cryptographic operation request is received, the key is decrypted by the CCA software layer and the request is submitted to the next available cryptographic device. ICSF is the z/OS component that is used to change the system master key. PROTECTED keys are encrypted using the host master key and then stored outside the CKDS, that is, outside the control of ICSF. This means that if the system master key is changed, any PROTECTED key created using the old system master key becomes unusable and data encrypted using it cannot be decrypted. For this reason, PROTECTED keys are recommended only for short-term use. They should not be used for data that will be encrypted and then decrypted at a much later date. The PROTECTED key type has the highest level of security supported by the IBMJCECCA provider for symmetric keys. Operations using PROTECTED key types are more secure and generally slower than similar operations using CLEAR keys. These keys are known to ICSF as clear DATA keys. The hardware can also be used to accelerate the performance of the cryptographic operation. The lowest level of hardware security is a \"CLEAR\" key pair or symmetric key. When the key pair or symmetric key is generated as type CLEAR, the keypair or symmetric key is stored in a clear and unprotected representation. This clear key pair or symmetric key can be used by the application to perform cryptographic operations on any CCA-capable hardware cryptographic device the system supports. There is no overhead for retrieving the key from the PKDS or CKDS, no overhead for decrypting the key, and no requirement for the cryptographic operation to be processed by a specific hardware device. The CLEAR key type is the fastest type supported by the IBMJCECCA provider, but it is also the least secure. Note: Most JCE providers using software cryptography support only the key pair and symmetric key type CLEAR. \n\n All three types of hardware key pair and all three types of symmetric key supported by the IBMJCECCA provider can be used by any application. For CKDS and PKDS keys, the application will have only a label. For PROTECTED keys, the application will have only an encrypted token. For CLEAR keys, the application will have an actual clear representation of the key material. The IBMJCECCA provider accepts key labels, key tokens, and clear representations of keys interchangeably and treats all the same as actual keys. Key labels, key tokens, and clear representations of keys can be stored by the application using whatever mechanism they choose. The IBMJCECCA provider includes a Java keystore (type JCECCAKS) that can be used to store any of these representations of keys. A JCECCAKS keystore provides an added level of security, allowing the keys stored in it to be encrypted using passwords before they are stored in the keystore file. This means that if you choose CLEAR keys or PROTECTED keys for performance reasons, they can be stored in keystore entries that are password protected. While password protection is provided for all keystore entries, regardless of the type of key stored in the entry, it is not as important for PKDS and CKDS keys. This is because, for PKDS and CKDS keys, the keystore entry contains only a key label and no sensitive key information. Key generation can be accomplished either using the keytool application included with the IBMJCECCA provider or using JCE APIs. The keytool application included with the IBMJCECCA provider is called hwkeytool. It enables you to generate symmetric keys and key pairs then store them in a keystore file of type JCECCAKS. The JCE APIs allow you to generate symmetric keys and key pairs in an application and then, at the discretion of the application, also store them in a keystore of type JCECCAKS. The IBMJCECCA provider supports digital signature and verification with the available RSA and DSA algorithms (note that DSA is only supported on z800 and z900 hardware). This implementation moves all algorithm processing to the installed cryptographic hardware device. RSA is a relatively compute intensive algorithm, so this moves a significant portion of the CPU instructions off the main processor and onto the cryptographic hardware device. The cryptographic hardware processes this work on a secure card, making it much harder to capture and compromise the sensitive material involved. The cryptographic hardware is also much faster than software cryptographic processing. An additional benefit provided by cryptographic hardware is the choice of two levels of security, CLEAR key pairs and PKDS based key pairs. Cryptographic hardware capabilities imcrease the base security of the operation (by having the hardware process the algorithm and data), reduce the load on general purpose CPs, potentially increase the throughput rate of the request, and (optionally) permit use of more secure key pairs. Note that the DSA algorithm is only supported on hardware cryptographic devices for z800 and z900 machines. DSA signature and verification using hardware cryptographic devices is only available in Cryptographic Coprocessor Facility (CCF) hardware. An additional restriction is that, due to the hardware capabilities for DSA in the CCF hardware, the only type of key pair that is available for DSA is PKDS. The CCF hardware does not support CLEAR DSA key pairs. Hashing algorithms are not as compute intensive as the RSA and DSA algorithms, so it is not always better to use hardware devices to perform them. This is because the overhead of using the hardware device can outweigh the potential performance gains. Further, the security of performing hashing algorithms on hardware is not substantially better than performing the same operations in software, because the hash subsequently is used in a more secure RSA or DSA sign or verify operation. For these reasons many hardware cryptography devices don't support hashing algorithms and, in some cases, the CCA layer performs the hashing algorithm in software rather than hardware.\n\n The IBMJCECCA provider calls the CCA interfaces to perform MD5, SHA-1, SHA-256, SHA-384, and SHA-512 hashing, and performs MD2 hashing via software. In some cases, the IBM CCA layer performs the MD5 hash using software instead of hardware. Note the following regarding the SHA algorithms.\n• SHA-256 is only supported on z9 and newer zSeries processor families.\n• SHA-384 and SHA-512 are only supported on z10 and newer zSeries processor families. \n\n The IBM CCA hardware devices provide a true random number generator. This is an improvement over the java.util.Random class which provides a pseudo random number generation capability based on salting a random number operation with some value. The IBMJCECCA provider takes advantage of the true random number generation capabilities in the cryptographic hardware and makes them available to applications with the class.\n• An implementation of the Digital Signature Algorithm (DSA), described in NIST FIPS 186 (only supported on z800 and z900 hardware)\n• An implementation of RSA, described in PKCS #1.\n• An implementation of the MD2 (RFC1319), MD5 (RFC 1321) and SHA-1 (NIST FIPS 180-1) SHA (SHA1, SHA-256, SHA-384, SHA512: NIST FIPS 180-3) message digest algorithms. Note the following regarding the SHA algorithms.\n• SHA-256 is supported on z9 and newer zSeries processor families\n• SHA-384 and SHA-512 are supported on z10 and newer zSeries processor families.\n• An implementation of the HmacMD2, HmacMD5, HmacSHA1, HmacSHA256, HmacSHA384, and HmacSHA512 hashing message authentication code algorithms. Note the following regarding the HmacSHA algorithms.\n• HmacSHA256 is supported on z9 and newer zSeries processor families.\n• HmacSHA384 and HmacSHA512 are supported on z10 and newer zSeries processor families.\n• An implementation of the AES cipher algorithm.\n• An implementation of the DES cipher algorithm.\n• An implementation of the TripleDES cipher algorithm.\n• An implementation of the following PBE algorithms:\n• A DSA key pair generator for generating a pair of public and private keys suitable for the DSA algorithm (only supported on z800 and z900 hardware).\n• An RSA key pair generator for generating a pair of public and private keys suitable for the RSA algorithm.\n• An AES key generator for generating a key suitable for the AES algorithm.\n• A DES key generator for generating a key suitable for the DES algorithm.\n• A TripleDES key generator for generating a key suitable for the TripleDES algorithm.\n• An HmacMD2 key generator for generating a key suitable for the HmacMD2 algorithm.\n• An HmacMD5 key generator for generating a key suitable for the HmacMD5 algorithm.\n• A HmacSHA1 key generator for generating a key suitable for the HmacSHA1. algorithm.\n• An HmacSHA256 key generator for generating a key suitable for the HmacSHA256 algorithm.\n• Note that the HmacSHA256 algorithm is supported on z9 and newer zSeries processor families.\n• An HmacSHA384 key generator for generating a key suitable for the HmacSHA384 algorithm.\n• Note that the HmacSHA384 algorithm is supported on z10 and newer zSeries processor families.\n• An HmacSHA512 key generator for generating a key suitable for the HmacSHA512 algorithm.\n• Note that the HmacSHA512 algorithm is supported on z10 and newer zSeries processor families.\n• A DSA algorithm parameter generator (only supported on z800 and z900 hardware).\n• A DSA algorithm parameter manager (only supported on z800 and z900 hardware).\n• An implementation of the proprietary \"IBMSecureRandom\" random number generation algorithm. Overview of differences between the software JCE implementation and the hardware JCE implementation There are few differences between the software cryptography implementation of JCE (IBMJCE) and the hardware implementation (IBMJCECCA). For example, DES and Triple DES operations available in the IBMJCE provider are the same in the IBMJCECCA provider. One difference, discussed below, is in the required key attribute restrictions for the RSA cipher algorithm. A more important difference is in the list of supported cryptographic algorithms. The IBMJCECCA provider supports fewer algorithms than the IBMJCE provider, due to limitations in the currently available hardware. The cryptographic operations provided by the IBMJCECCA are the same as for previous versions of JCE. Therefore, an existing application can be migrated easily from a software JCE provider, such as IBMJCE, into the hardware JCE environment, IBMJCECCA. To migrate, it is only necessary to generate new key pairs for RSA or DSA with appropriate attributes (see below) and to change the security provider. The security provider can be changed either by using API calls with the provider parameter or by changing the provider list to place the IBMJCECCA in a preferred position (that is, with a lower sequence number than the IBMJCE provider). If it is necessary to have a software JCE provider, such as IBMJCE, in the provider list in a position preferred to the position of the IBMJCECCA, you must specify the IBMJCECCA provider in the getInstance() API if you want to use it instead of the software provider. If the provider is not specified on an API call, the actual provider invoked at runtime will be the first one on the provider list that supports the requested algorithm and key type. This could cause a software JCE provider to be used instead of the IBMJCECCA provider. The following section, titled \"Specific Changes and Requirements\", provides more details for the advanced applications developer. The following sections discuss the restrictions and features that differ from the basic software JCE provider (IBMJCE) to the hardware assisted JCE provider (IBMJCECCA). The key factory class is an engine class designed to provide opaque cryptographic keys (objects of type ) and key specifications (transparent representations of the underlying key material). The IBMJCECCA provider supports a key type for AES keys that have been stored previously in the host CKDS. The keys are objects of type . The can be used to generate a key of this type from a containing the CKDS label for the key. Other classes supported by the AES include the and the . The IBMJCECCA provider supports a key type for DES keys that have been stored previously in the host CKDS. The keys are objects of type . The can be used to generate a key of this type from a containing the CKDS label for the key. Other classes supported by the DES include the and the . The IBMJCECCA provider supports a key type for triple DES keys that have been stored previously in the host CKDS. The keys are objects of type . The can be used to generate a key of this type from a containing the CKDS label for the key. Other classes supported by the triple DES include the and the . The IBMJCECCA provider supports a key type for DSA private hardware keys that is similar to the DSA Private keys available in software providers. DSA private hardware keys are objects of type . The corresponding DSA public keys are objects of type . The class can be used to generate a DSA Private hardware key from a . The can also be used to generate a DSA public key from a or an . The class can also derive a from a DSA Private hardware key or a or from a DSA public key. \n\n The IBMJCECCA provider adds a new key type for RSA private hardware keys that is similar to the RSA Private keys available in software providers. RSA private hardware keys are objects of type . The corresponding RSA public keys are objects of type . The class can be used to generate an RSA private hardware key from a , , , or . The can also be used to generate an RSA public key from an , ,or . Keys that already in the PKDS can also be created by passing a to the RSA . The class can also derive an from an RSA private hardware key or an or from an RSA public key. \n\n Note that an and a are valid only on the system where the private key was originally generated. Private hardware keys can not be moved from the system on which they are generated to another system. This is true for all private hardware keys, including clear private keys, and is part of the security provided for them. The class: \n\n \n\n This class (which implements the interface) specifies whether the AES, DES, or triple DES key to be generated will be a secret hardware key and whether it will be stored in the CKDS. In the default case, an object of this class is created without specifying a key type, and this object is passed to the method of an , a , or a . In this case, a subsequent call to will return a key object containing the requested key encrypted using the host master key. A object can be used to specify the strength (size) of the key to be generated. If the object is being used to generate a key in the system CKDS, the can be used to specify the CKDS label to use to identify the CKDS entry. If a label is specified, it must be unique in the CKDS and must follow the ICSF rules for CKDS entry labels. If no label is specifed for a new CKDS entry, the method will create one automatically. A object can also be used to explicitly specify the type of key to be generated:\n• can be passed to the constructor, and the resulting object passed to the method of an , a , or a . In this case, a subsequent call to will return a key object containing the CKDS label for requested key encrypted using the host master key and stored in the system CKDS.\n• can be passed to the constructor, and the resulting object passed to the method of an , a , or a . In this case, a subsequent call to will return a key object containing the requested key encrypted using the host master key. This key can also be generated using a class and passing a object, created without specifying a key type, to the method.\n• can be passed to the constructor and the resulting object passed to the method of an , a , or a . In this case, a subsequent call to will return a key object containing the clear key material for requested key. This key can also be generated using a class without passing any object to the method. has the following constructors: \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n Parameters that can be passed to the constructors: \n\n \n\n The parameter must be valid for the specific algorithm of the to which this will be passed.\n\n \n\n The parameter must be one of the following constant values: \n\n The parameter must be valid for the ICSF component, according to the rules defined for the Key Generator Utility Program (KGUP).\n\n has the following methods: \n\n This method returns the key size specified to the constructor. If no key size was specified, this method returns 0. \n\n \n\n \n\n This method returns the key type specified to the constructor. The returned value will be one of the following constant values: \n\n \n\n This method returns the CKDS label specified to the constructor. If no CKDS label was specified, this method returns . \n\n \n\n It is not necessary to specify a object in order to create a key using an , a , or a . If no object is passed to the method before the method is called, the key object returned will contain the clear key material for requested key. The class for DSA hardware ( ): \n\n \n\n This class (which implements the interface) specifies the set of parameters to use with the DSA hardware algorithm. These are:\n• Due to hardware restrictions, these must be and .\n• This parameter specifies the size of the key based on prime .\n• This parameter specifies the name that will be used as a reference to the key stored in the hardware. \n\n See the Java API documentation for the specific methods, default values and restrictions associated with this class. \n\n The class for RSA hardware ( ): \n\n \n\n This class (which implements the interface) specifies the set of parameters to use with the RSA hardware algorithm. These are:\n• \n• which must have one of the following values:\n• which must have one of the following values:\n• This parameter specifies the size of the key.\n• If the is not specified as , this parameter specifies the name that will be used as a reference to the key stored in hardware. See the Java API documentation for the specific methods, default values and restrictions associated with this class. \n\n As discussed above, the clear key material for private hardware keys of type PKDS is never returned to an application and can never be transported for use on another system. For this reason, no implementation of the interface can be used to represent them. A software reference to a private hardware key of type PKDS is not a key or a key specification, but instead is a label that can be specified to the IBMJCECCA provider in place of a key. The following method can be used to retrieve the representation of a hardware key pair: For a DSA key pair, returns the label that represents the key stored in the PKDS associated with the hardware. For an RSA key pair of type CLEAR, returns an internal CCA token. For an RSA key pair of type PKDS, returns the label that represents the key stored in the PKDS associated with the hardware. The \n\n \n\n This class (which implements the Interface) specifies the CKDS label for an AES, DES, or DESede key stored in the system CKDS. If a is passed to the method of an , a , or a then the key object returned will represent a key already stored in the CKDS. Note that does not create a new CKDS entry and does not verify that such an entry currently exists in the CKDS. It has the following methods:\n\n \n\n This method returns the CKDS label for the key.\n\n \n\n \n\n This method returns the ASCII byte representation of the CKDS label for the key.\n\n \n\n The \n\n \n\n This class (which implements the Interface) specifies a DSA private hardware key with its associated parameters. It has the following methods:\n\n \n\n This method returns the DSA algorithm parameters used to calculate the key.\n\n \n\n \n\n This method returns the DSA hardware attributes associated with the key.\n\n \n\n See the Java API documentation for the specific methods, default values and restrictions associated with this class. \n\n The Class \n\n \n\n This class (which implements the Interface) specifies an RSA private hardware key with its associated parameters. It has the following methods:\n\n \n\n This method returns the private key token, which can be an internal CCA token or a key label.\n\n \n\n \n\n This method returns the RSA hardware attributes associated with the key.\n\n \n\n See the Java API documentation for the specific methods, default values and restrictions associated with this class. The class in this provider is a true random number generator that does not need seeding. Therefore, calls to , and will throw an exception. The following illustrates using : \n\n In this example, an instance of the class is obtained, a byte array is instantiated, and a random number of size 1024 bytes is generated. See the Java API documentation for the specific methods, default values and restrictions associated with this class \n\n Certificates encoded with Base64 are read in and written out in the ISO8859_1 code page, not the local code page. This is done to make them compatible with the Base64-Encoded Certificates on other platforms. For this reason an encoded certificate may not be human readable on some platforms. The IBMJCECCA provider supports signatures of the following types:\n• SHA1 with DSA, except that DSA is only supported on z800 and z900 hardware\n• SHA256 with RSA (supported on z9 and newer zSeries processor families)\n• SHA384 with RSA (supported on z10 and newer zSeries processor families)\n• SHA512 with RSA (supported on z10 and newer zSeries processor families) A Signature is created by calling the class that will be used when computing the signature and then calling the CCA hardware to create the actual signature from the hash and the corresponding private key. A Signature is verified by creating a hash and passing in both the public key and the previously generated signature to the hardware. (See \"Specific Changes and Requirements\" for specific class names.) The hardware JCE implementation (IBMJCECCA) extends the DES key available in the software JCE implementation (IBMJCE). In the IBMJCE implementation, the actual DES key material is stored in the key object. The IBMJCECCA implementation extends this by adding the following alternative representations:\n• A DES key previously stored in the CKDS. The key object will contain the CKDS label for the key. The following illustrates creating a DES key object for a key already stored in the CKDS with the label \"MYENCRYPTEDDESKEY\" and then (for purposes of illustration) deleting the CKDS entry. // create a key object for an existing CKDS entry // (No checking is done to verify that the entry exists, or // that the key it contains is actually a DES key.) // SecretKeyFactory desKeyFactory = SecretKeyFactory.getInstance(\"DES\", \"IBMJCECCA\"); KeyLabelKeySpec spec = new KeyLabelKeySpec(\"MYENCRYPTEDDESKEY\"); SecretKey key = desKeyFactory.generateSecret(spec); // delete the entry from the CKDS // (An exception is thrown if the CKDS entry does not exist.) // key.deleteCKDSEntry(); // // Note that, in this example, the Java key object still // exists, but the CKDS entry it represents has been deleted. // Any attempt to use the object \"key\" will cause an exception // containing a hardware return code and reason code. // On z800 and z900 machines, a key object containing the CKDS label for an encrypted DES key can be used for CBC mode encryption and decryption with the IBMJCECCA provider. On the z890 and z990 and newer zSeries processors, a key object containing the CKDS label for a clear DES key can be used for CBC mode, CFB mode, or ECB mode encryption and decryption with the IBMJCECCA provider. This environment also supports using a key object containing the CKDS label for an encrypted DES key for CBC mode encryption and decryption with the IBMJCECCA provider. A key object containing the CKDS label for an encrypted DES key can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a DES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a DES hardware token. Unwrapping to a key object containing a DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping DES keys, see RSA\n• A DES key generated by an IBMJCECCA call to the underlying hardware. The key object will contain a hardware token. This token contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating a DES key object containing a hardware key token // create a new key token and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(); KeyGenerator keyGen = KeyGenerator.getInstance( \"DES\", \"IBMJCECCA\" ); keyGen.init( ccaAlgParmSpec, null ); Key desKey = keyGen.generateKey(); A key object containing a DES hardware token can be used for CBC mode encryption and decryption with the IBMJCECCA provider. A key object containing a DES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a DES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a DES hardware token. Unwrapping to a key object containing a DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping DES keys, see RSA\n• A DES key generated by an IBMJCECCA call to the underlying hardware and then stored in the CKDS. The key object will contain the label for the new CKDS entry. The CKDS entry holds a token that contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating a protected DES key token, storing it in a new CKDS entry with an automatically generated label, and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS); KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\", \"IBMJCECCA\"); keyGen.init( ccaAlgParmSpec, null ); Key thisKey = keyGen.generateKey(); The following illustrates generating a protected DES key token, storing it in a new CKDS entry with the label \"ADESTOKENINCKDS\", and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS, \"ADESTOKENINCKDS\"); KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\", \"IBMJCECCA\"); keyGen.init(ccaAlgParmSpec,null); Key thisKey = keyGen.generateKey(); A key object representing a DES hardware token can be used for CBC mode encryption and decryption with the IBMJCECCA provider. A key object representing a DES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a DES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a DES hardware token. Unwrapping to a key object containing the label for a CKDS entry that contains a DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping DES keys, see RSA The hardware JCE implementation (IBMJCECCA) of DES does not change any of the APIs that are available in software JCE implementation (IBMJCE). Therefore, an application that used the DES capabilities of the IBMJCE will not require modification to use the IBMJCECCA, except for specific references to the provider. For example, if a call to the getInstance() API specified the IBMJCE provider, it will be necessary to change the call to specify the IBMJCECCA provider instead. Although all DES ciphers are available in the IBMJCECCA provider, they are not all available in the hardware devices. The hardware cryptographic devices only support the Cipher Block Chaining (CBC) and Electronic Code Book (ECB) versions of DES. That is, all of the DES ciphers are supported by the IBMJCECCA provider, but only CBC and ECB modes use hardware cryptography. It is not always more efficient to use hardware cryptography instead of software cryptography. The DES algorithm is not as compute intensive as some asymmetric algorithms such as RSA. For smaller data sizes, software DES cryptography can be faster than hardware cryptography. Because of this, a software version of DES with CBC and ECB also were implemented in the IBMJCECCA provider. For small amounts of data, software DES (CBC or ECB) is sometimes faster than hardware DES (CBC or ECB) cryptography, The exact size of the data at which the performance trade off is found varies from system to system. Therefore, a \"clip level\" is used to specify the data size at which hardware cryptography is used. Any data length below the clip level will use software cryptography. The clip level is a system property called \"ibm.DES.usehdwr.size\" and has a default value of 60. Thus, by default, any DES CBC or ECB processing where the data size is 60 bytes or less will be performed using software cryptography and any data size greater than 60 bytes will be performed using hardware cryptography. For ciphers other than DES CBC and DES ECB this system property has no function. You can adjust the clip level by changing the system property to the desired level. If you set the system property to 0, all DES CBC and DES ECB processing will be performed using hardware cryptography. If you set the system property to -1, all DES CBC and DES ECB processing will be performed using software cryptography. This system property applies to both DES and triple DES CBC and ECB processing. Note that the data size comparison to the clip level is done when the first data is passed to the cipher for encryption or decryption. For example, consider an application that decrypts the contents of a tape by reading each record and passing it to the cipher before reading the next record. In this case, the first record passed to the cipher object will be the tape header. If the tape header is smaller than the current clip level, the decryption will be done using software, even though the subsequent records may be very large. This is a case where you might choose to set the clip level to 0 so that hardware cryptography will be used, regardless of the size of the first record processed. The example below shows how to set the \"ibm.DES.usehdwr.size\" system property when a java program named programName is run. \n\n This value can also be set programatically with the Java method. The hardware JCE implementation (IBMJCECCA) extends the triple DES key available in the software JCE implementation (IBMJCE). In the IBMJCE implementation, the actual triple DES key material is stored in the key object. The IBMJCECCA implementation extends this by adding the following alternative representations:\n• A triple DES key previously stored in the CKDS. The key object will contain the CKDS label for the key. The following illustrates creating a triple DES key object for a key already stored in the CKDS with the label \"MYENCRYPTEDTDESKEY\" and then (for purposes of illustration) deleting the CKDS entry. // create a key object for an existing CKDS entry // (No checking is done to verify that the entry exists, or // that the key it contains is actually a DESede key.) // SecretKeyFactory desKeyFactory = SecretKeyFactory.getInstance(\"DESede\", \"IBMJCECCA\"); KeyLabelKeySpec spec = new KeyLabelKeySpec(\"MYENCRYPTEDTDESKEY\"); SecretKey key = desKeyFactory.generateSecret(spec); // delete the entry from the CKDS // (An exception is thrown if the CKDS entry does not exist.) // key.deleteCKDSEntry(); // // Note that, in this example, the Java key object still // exists, but the CKDS entry it represents has been deleted. // Any attempt to use the object \"key\" will cause an exception // containing a hardware return code and reason code. // On z800 and z900 machines, a key object containing the CKDS label for an encrypted DES key can be used for CBC mode encryption and decryption with the IBMJCECCA provider. On z890, z990, and newer zSeries processors, a key object containing the CKDS label for a clear DES key can be used for CBC mode, CFB mode, or ECB mode encryption and decryption with the IBMJCECCA provider. This environment also supports using a key object containing the CKDS label for an encrypted DES key for CBC mode encryption and decryption with the IBMJCECCA provider. A key object containing the CKDS label for an encrypted triple DES key can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A triple DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear triple DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a triple DES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a triple DES hardware token. Unwrapping to a key object containing a triple DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping triple DES keys, see RSA\n• A triple DES key generated by an IBMJCECCA call to the underlying hardware. The key object will contain a hardware token. This token contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating a triple DES key object containing a hardware key token // create a new key token and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(); KeyGenerator keyGen = KeyGenerator.getInstance( \"DESede\", \"IBMJCECCA\" ); keyGen.init( ccaAlgParmSpec, null ); Key tdesKey = keyGen.generateKey(); A key object containing a triple DES hardware token can be used for CBC mode encryption and decryption with the IBMJCECCA provider. A key object containing a triple DES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A triple DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear triple DES key. If the RSA Cipher object is initialized with a CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a triple DES hardware token. Unwrapping to a key object containing a triple DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping triple DES keys, see RSA\n• A triple DES key generated by an IBMJCECCA call to the underlying hardware and then stored in the CKDS. The key object will contain the label for the new CKDS entry. The CKDS entry holds a token that contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating a protected triple DES key token, storing it in a new CKDS entry with an automatically generated label, and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS); KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\",\"IBMJCECCA\"); keyGen.init(ccaAlgParmSpec,null); Key thisKey = keyGen.generateKey(); The following illustrates generating a protected triple DES key token, storing it in a new CKDS entry with the label \"ATRIPLEDESTOKENINCKDS\", and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS, \"ATRIPLEDESTOKENINCKDS\"); KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\", \"IBMJCECCA\"); keyGen.init(ccaAlgParmSpec, null); Key thisKey = keyGen.generateKey(); A key object representing a triple DES hardware token can be used for CBC mode encryption and decryption with the IBMJCECCA provider. A key object representing a triple DES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). A triple DES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear triple DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a triple DES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a triple DES hardware token. Unwrapping to a key object containing the label for a CKDS entry that contains a triple DES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping triple DES keys, see RSA Although all triple DES ciphers are available in the IBMJCECCA provider, they are not all available in the hardware devices. The hardware cryptographic devices only support the Cipher Block Chaining (CBC) and Electronic Code Book (ECB) version of triple DES. That is, all of the triple DES ciphers are supported by the IBMJCECCA provider, but only CBC and ECB use hardware cryptography. Triple DES is slightly more compute intensive than DES, but like DES is less compute intensive than asymmetric algorithms such as RSA. Therefore, for smaller data sizes, software triple DES cryptography can be faster than hardware triple DES cryptography. For this reason, triple DES with CBC or ECB is also implemented in software within the IBMJCE4758 provider. The same \"clip level\" (specified in a system property called \"ibm.DES.usehdwr.size\") is used to determine the data size at which hardware cryptography is used for triple DES. For more information about the \"ibm.DES.usehdwr.size\" system property, see the discussion above. The hardware JCE implementation (IBMJCECCA) extends the AES key available in the software JCE implementation (IBMJCE). In the IBMJCE implementation, the actual AES key material is stored in the key object. The IBMJCECCA implementation extends this by adding the following alternative representation:\n• An AES key previously stored in the CKDS. The key object will contain the CKDS label for the key. The following illustrates creating an AES key object for a key already stored in the CKDS with the label \"MYENCRYPTEDAESKEY\" and then (for purposes of illustration) deleting the CKDS entry. // create a key object for an existing CKDS entry // (No checking is done to verify that the entry exists, or // that the key it contains is actually an AES key.) // SecretKeyFactory aesKeyFactory = SecretKeyFactory.getInstance(\"AES\", \"IBMJCECCA\"); KeyLabelKeySpec spec = new KeyLabelKeySpec(\"MYENCRYPTEDAESKEY\"); SecretKey key = aesKeyFactory.generateSecret(spec); // delete the entry from the CKDS // (An exception is thrown if the CKDS entry does not exist.) // key.deleteCKDSEntry(); // // Note that, in this example, the Java key object still // exists, but the CKDS entry it represents has been deleted. // Any attempt to use the object \"key\" will cause an exception // containing a hardware return code and reason code. // A key object containing the CKDS label for a clear AES key can be used for CBC mode, CFB mode, or ECB mode encryption and decryption with the IBMJCECCA provider. A key object containing the CKDS label for an encrypted AES key can be used for CBC mode or ECB mode encryption and decryption with the IBMJCECCA provider. A key object containing the CKDS label for an encrypted AES key can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). An AES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear AES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain an AES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains an AES hardware token. Unwrapping to a key object containing an AES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping AES keys, see RSA\n• An AES key generated by an IBMJCECCA call to the underlying hardware. The key object will contain a hardware token. This token contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating an AES key object containing a hardware key token A key object containing an AES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). An AES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear AES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain an AES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains an AES hardware token. Unwrapping to a key object containing an AES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping AES keys, see RSA\n• An AES key generated by an IBMJCECCA call to the underlying hardware and then stored in the CKDS. The key object will contain the label for the new CKDS entry. The CKDS entry holds a token that contains the key encrypted with the host master key. The key material for this type of key is never resident in system memory in clear form. The following illustrates generating a protected AES key token, storing it in a new CKDS entry with an automatically generated label, and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS); KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\", \"IBMJCECCA\"); keyGen.init( ccaAlgParmSpec, null ); Key thisKey = keyGen.generateKey(); The following illustrates generating a protected AES key token, storing it in a new CKDS entry with the label \"ANAESTOKENINCKDS\", and creating a key object containing the label for the CKDS entry. // create a new CKDS entry and a key object to represent it // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(CCAAlgorithmParameterSpec.CKDS, \"ANAESTOKENINCKDS\"); KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\", \"IBMJCECCA\"); keyGen.init(ccaAlgParmSpec, null); Key thisKey = keyGen.generateKey(); A key object representing an AES hardware token can be used for CBC mode encryption and decryption with the IBMJCECCA provider. A key object representing an AES hardware token can be passed to an IBMJCECCA RSA Cipher object to be wrapped for export to another host. This is not supported for AMODE(64). An AES key that has been wrapped by an RSA Cipher can be passed to the IBMJCECCA RSA Cipher to be unwrapped for import from another host. By default, the resulting (unwrapped) key object will contain a clear DES key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain an AES hardware token. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains an AES hardware token. Unwrapping to a key object containing the label for a CKDS entry that contains an AES hardware token is not supported for AMODE(64). For more information about wrapping and unwrapping AES keys, see RSA The hardware JCE implementation (IBMJCECCA) of AES does not change any of the APIs that are available in software JCE implementation (IBMJCE). Therefore, an application that used the AES capabilities of the IBMJCE will not require modification to use the IBMJCECCA, except for specific references to the provider. For example, if a call to the getInstance() API specified the IBMJCE provider, it will be necessary to change the call to specify the IBMJCECCA provider instead. The IBMJCECCA provider hardware cryptographic devices only support the Cipher Feedback (CFB), the Cipher Block Chaining (CBC) and the Electronic Code Book (ECB) versions of AES. Software failover support, as provided for DES and DESede, is available for AES ECB ciphers and AES CBC ciphers only. Both RSA encryption and decryption are available in the IBMJCECCA provider using hardware cryptography. Because the RSA algorithm is quite compute intensive, using hardware cryptography provides significant performance improvements over software cryptography. Using hardware to perform the RSA encryption and decryption also allows use of the more secure PKDS stored key pairs. With a PKDS stored key pair, the sensitive private key is never made available in the clear. In software implementations of JCE providers (such as IBMJCE), RSA encryption and decryption are implemented with PKCS 1 type 2 padding. RSA encryption and decryption with PKCS 1 type 2 padding is also implemented in hardware cryptography and available with the IBMJCECCA provider. However, there are two restrictions imposed by the hardware:\n• The type of key pair that is needed The hardware implementation of RSA requires that the keys used to encrypt/decrypt data be generated to have a key usage of KEYMANAGEMENT. This means that when the RSA key pair is generated the key usage must be set to KEYMANAGEMENT.\n• The maximum length of the data that can be encrypted or decrypted The hardware implementation of RSA limits the amount of data to be encrypted or decrypted to 245 bytes or 11 bytes smaller that the modulus size of the key, in bytes, which ever is smaller. The IBMJCECCA provider also implements RSA encryption/decryption with \"zero padding\". This padding scheme is not supported by all JCE providers. The default padding scheme is PKCS 1 type 2 padding for the IBMJCECCA provider. The following illustrates creating an instance of an RSA Cipher with \"zero padding\" The following illustrate creating an instance on an RSA Cipher with \"PKCS 1 type 2 padding\" Or The IBMJCECCA provider supports RSA wrapping of a symmetric key for export to another host. The following keys are supported for RSA wrapping:\n• a key object containing a CKDS label for an encrypted AES, DES or triple DES key\n• a key object containing a hardware token with an encrypted AES, DES or triple DES key. The following keys are not supported for RSA wrapping with AMODE(64):\n• a key object containing a CKDS label for an encrypted AES, DES or triple DES key.\n• a key object containing a hardware token with an encrypted AES, DES or triple DES key. The IBMJCECCA provider supports RSA unwrapping of a symmetric key for import from another host. By default, the resulting (unwrapped) key object will contain a clear key. If a CCAAlgorithmParameterSpec is created with no type specified, or with type CCAAlgorithmParameterSpec.PROTECTED, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain a hardware token. This token will contain the key encrypted with the host master key. If a CCAAlgorithmParameterSpec is created with type CAAlgorithmParameterSpec.CKDS, and the RSA Cipher is initialized with this CCAAlgorithmParameterSpec, the resulting (unwrapped) key object will contain the label for a CKDS entry that contains a hardware token. This token will contain the key encrypted with the host master key. Unwrapping to a key object containing a hardware token is not supported with AMODE(64). The following illustrates generating a triple DES key object containing a clear key, wrapping it, then unwrapping it to a triple DES key object containing a clear key. // Generate a clear triple DES key // KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\", \"IBMJCECCA\"); Key tdesKey = keyGen.generateKey(); // Generate an RSA key pair // KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance(\"RSA\",\"IBMJCECCA\"); rsaKeyPairGen.initialize(1024); KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair(); PublicKey rsaPub = rsaKeyPair.getPublic(); PrivateKey rsaPriv = rsaKeyPair.getPrivate(); // Wrap the triple DES key as for export // Cipher rsaCipher = Cipher.getInstance(\"RSA\",\"IBMJCECCA\"); rsaCipher.init(Cipher.WRAP_MODE, rsaPub, (AlgorithmParameters)null, null); byte[] wrappedKey = rsaCipher.wrap(tdesKey); // Unwrap the triple DES key as for import // Unwrap to a clear key // Key unwrappedDesKey = rsaCipher.unwrap(wrappedKey, \"DESede\", Cipher.SECRET_KEY); The following illustrates generating a triple DES key object containing a hardware key token, wrapping it, then unwrapping it to a triple DES key object containing a hardware key token. // Generate a secure triple DES hardware key // CCAAlgorithmParameterSpec ccaAlgParmSpec = new CCAAlgorithmParameterSpec(); KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\", \"IBMJCECCA\"); keyGen.init(ccaAlgParmSpec, null); Key tdesKey = keyGen.generateKey(); // Generate an RSA key pair // KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance(\"RSA\",\"IBMJCECCA\"); rsaKeyPairGen.initialize(1024); KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair(); PublicKey rsaPub = rsaKeyPair.getPublic(); PrivateKey rsaPriv = rsaKeyPair.getPrivate(); // Wrap the triple DES hardware key as for export // Cipher rsaCipher = Cipher.getInstance(\"RSA\",\"IBMJCECCA\"); rsaCipher.init(Cipher.WRAP_MODE, rsaPub, (AlgorithmParameters)null, null); byte[] wrappedKey = rsaCipher.wrap(tdesKey); // Unwrap the triple DES key as for import // Unwrap to a secure hardware key // CCAAlgorithmParameterSpec ccaAlgParmSpec_forUnwrap = new CCAAlgorithmParameterSpec(); rsaCipher.init(Cipher.UNWRAP_MODE, rsaPriv, ccaAlgParmSpec_forUnwrap, null); Key unwrappedDesKey = rsaCipher.unwrap(wrappedKey, \"DESede\", Cipher.SECRET_KEY); The following illustrates deleting a RSA hardware key object for a key stored in PKDS, with the label \"MYRSAKEY\". // Get the key store instance, open an input stream to the // keystore file and load the key store. // KeyStore jceccaks = KeyStore.getInstance(\"JCECCAKS\", \"IBMJCECCA\"); InputStream istream = new FileInputStream(\"keyStore.cca\"); jceccaks.load(istream, \"keystorePW\".toCharArray()); // Given the alias for the PKDS key entry, retrieve the private // hardware key from the key store. // PrivateKey privateKey = (PrivateKey) jceccaks.getKey(\"MYRSAKEY\", \"myrsakeyPW\".toCharArray()); // Delete the RSA hardware PKDS key entry. // ((RSAPrivateHWKey)privateKey).deletePKDSEntry(); // Delete the RSA key store object. // jceccaks.deleteEntry(\"MYRSAKEY\"); // Write the modified key store contents to the key store file. // OutputStream ostream = new FileOutputStream(\"keyStore.cca\"); jceccaks.store(ostream, \"keystorePW\".toCharArray()); NOTE: The DSAPrivateHWKey class also has a method. The illustration above can be followed to delete DSA private hardware PKDS key entries by substituting the DSAPrivateHWKey class for the RSAPrivateHWKey class. The HMAC and PBE algorithms are supported in the IBMJCECCA provider using the same APIs that are supported by software JCE providers such as IBMJCE. However, the IBMJCECCA provider supports them by making use of other algorithms implemented in the cryptographic hardware. The IBMJCECCA provider supports four keystores: JCECCAKS, JCE4758KS, JCECCARACFKS, and JCE4758RACFKS. The JCECCAKS uses strong encryption (triple DES) to protect the keys when stored in a file. The JCECCARACFKS keystore handles keys and certificates stored in RACF keyrings. The JCE4758KS and JCE4758RACFKS keystores are included for downward compatibility. The JCECCAKS keystore extends and replaces the JCE4758KS keystore. The JCECCARACFKS keystore extends and replaces the JCE4758RACFKS keystore. JCECCAKS supports migration of keys from other keystores using normal keystore interfaces. The following is a list of keys that are supported by JCECCAKS for migration and for storage: For an example of migrating keys from one keystore to another, see Migrate.java in the directory, where $(java_home) is the directory where the Java SDK is installed. \n\n The default JCE keystore is named .keystore and is located in the user's home directory. The default JCECCAKS keystore is named .HWkeystore and is located in the user's home directory. On the z/OS platform, the user with ID userid has a default home directory (\"user.home\") of /home/userid. For example, the user ID \"U23LPTQ \" would, by default, have a home directory of /home/U23LPTQ. In the event of an ICSF error, an application can retrieve error data from the ICSF API call using the runtime exception class. The class: \n\n \n\n The IBMJCECCA provider might throw an instance of this class (which extends ) during operations with ICSF. The class includes methods to retrieve the following data from the ICSF API call:\n• The name of the ICSF API call which threw the exception\n• The exception message generated by the IBMJCECCA provider For example, an application can catch this exception and display ICSF API call data as: Configuring and using hardware cryptographic devices on z/OS To use a hardware cryptographic device, the appropriate card must be installed and configured according to the specifications that are provided with the card. On some platforms it is also necessary for the user or application to set up the cryptographic environment and provide access control (log into the card). \n\n On the z/OS platform, access to hardware cryptographic devices is controlled by the Integrated Cryptographic Service Facility (ICSF). The ICSF product provides IBM Common Cryptographic Architecture (CCA) interfaces to hardware devices. ICSF must be configured and running before the hardware cryptographic device is accessed. For more information about ICSF see the ICSF publications, including the following: With few exceptions, the hardware keytool application (hwkeytool) uses the same syntax and commands as the software version provided with JCA (keytool). The differences between hwkeytool and keytool are as follows:\n• hwkeytool provides additional parameters to the genkeypair, genseckey, and delete commands.\n• The default keystore is .HWkeystore, although the JCE default (.keystore) can be specified using the -keystore parameter. The additional parameters for genkeypair are:\n• -keylabel [-keylabel <keylabel>]\n\n \n\n If -hardwaretype PKDS is specified, this optional parameter is used to specify the label that will identify the hardware key within the hardware storage. If -hardwaretype PKDS is specified and this parameter is not specified, a random label is generated.\n• -hardwaretype [-hardwaretype <hardwaretype>]\n\n \n\n This optional parameter is used to set the type of key pair generated (CLEAR, PKDS). If this parameter is not specified when generating a DSA key pair, the generated key pair is type PKDS. If this parameter is not specified when generating an RSA key pair, the generated key pair is type CLEAR.\n• -hardwareusage [-hardwareusage <hardwareusage>]\n\n \n\n This optional parameter is used to set the usage (SIGNATURE, KEYMANAGEMENT) for a generated key pair. If this parameter is not specified, when generating a DSA key pair, the generated key pair has usage SIGNATURE. If this parameter is not specified when generating an RSA key pair, the generated key pair has usage KEYMANAGEMENT.\n• -existinglabel [-existinglabel <existinglabel>]\n\n \n\n This optional parameter is used to specify the PKDS label for an existing PKDS key entry. When using this parameter, the genkeypair request will create a key object for this PKDS key entry. The -file parameter must be specified to include the certificate file associated with the PKDS key entry. The parameters -hardwaretype, -hardwareusage, -keysize, -dname, -sigalg, -keylabel and -validity are not required and must not be specified.\n• -file [-file <cert_file>]\n\n \n\n This optional parameter is used to specify the certificate file associated with a PKDS key entry. This parameter must be specified when -existinglabel is specified. The additional parameters for genseckey are:\n• -hardwaretype [-hardwaretype <hardwaretype>]\n\n \n\n This optional parameter is used to set the type of secret key generated (CLEAR, PROTECTED, or CKDS). If this parameter is not specified, the generated key is type CLEAR.\n• -keylabel [-keylabel <keylabel>]\n\n \n\n If -hardwaretype CKDS is specified, this optional parameter is used to specify the label that will identify the hardware key within the hardware storage. If -hardwaretype CKDS is specified and the -keylabel parameter is specified, the request is for a new key to be generated and stored in the CKDS using the specified keylabel. If -hardwaretype CKDS is specified and neither this parameter nor the -existinglabel parameter is specified, the request is for a new key to be generated and a random CKDS label generated.\n• -existinglabel [-existinglabel <existingkeylabel>]\n\n \n\n If -hardwaretype CKDS is specified, this optional parameter is used to specify the label that identifies the hardware key within the hardware storage. If -hardwaretype CKDS is specified and the -existinglabel parameter is specified, the request is for a key object representing a key already stored in the CKDS with the specified keylabel. The additional parameter for delete is:\n• -hardwarekey [-hardwarekey]\n\n \n\n This optional parameter is used to specify that the key pair be deleted from both the keystore and the hardware. If this parameter is not specified, the key is only deleted from the keystore. The concept of -hardwareusage is introduced with the hwkeytool. By using this parameter when creating a key pair, you can specify the authority that key pair will have in the CCA provider. The hwkeytool interfaces support the hardwareusage values SIGNATURE and KEYMANAGEMENT. A key pair created with hardwareusage SIGNATURE is valid for signatures (sign and verify) only. A keypair created with hardwareusage KEYMANAGEMENT is valid for signatures and for key management functions. The Java Cryptography Architecture also defines hardwareusage type CCA, for keys used for key management only, but this is not supported by hwkeytool because it is not useful to applications. Key pairs with hardwareusage SIGNATURE and KEYMANAGEMENT behave similarly in JCE because both can be used for signatures. Key pairs with hardwareusage KEYMANAGEMENT are needed for other components of Java, including the Java Secure Sockets Layer (JSSE). The concept of -keylabel is introduced with the hwkeytool. By using this parameter when creating a secret key or keypair, you can specify the label that will be used to identify the hardware key within the hardware storage. That is, -keylabel can be specified when creating a key or key pair to set a specific label that the CCA software will use to identify the key or key pair for storage and retrieval. This label is not used by normal JCE applications, but is made available for the advanced user who needs to control the label used by underlying CCA software to identify the key or key pair. In other words, a normal JCE application will identify the keypair by name (alias); this label is only used by the CCA software to identify CKDS and PKDS key entries. By default, the JCE methods generate a random label to identify the key entry. The concept of -existinglabel is introduced with the hwkeytool. By using this parameter when creating a key or key pair object, you indicate that the key or key pair is already stored within the hardware storage with the label you specify as the -existinglabel value. That is, -existinglabel can be used when creating a secret key or key pair object to specify the label that must be used to identify the secret key or key pair for retrieval. This label is not used by normal JCE applications, but is made available for the advanced user who needs to use keys stored in the underlying CCA software to identify the key or key pair. In other words, a normal JCE application will identify the keypair by name (alias); this label is only used by the CCA software to identify CKDS keys and PKDS key pairs. The following illustrates creating and storing an RSA key pair with the name Test1 with PKDS hardware: \n\n The following illustrates deleting that key entry from the keystore and also deleting the keys from hardware storage: At times it might be desirable to migrate a software key into a JCECCAKS hardware keystore. To aid in this process, the class com.ibm.crypto.hdwrCCA.provider.WrapperKey has been created. An instance of this class is a wrapper that contains a software key and the hardware attributes to associate with the key when it is imported into the hardware keystore. The following code snippet illustrates wrapping a software key \"SoftwareKey\" and inserting it into keystore \"okeyStore\":\n\nThe digital certificate support in the System Authorization Facility (SAF) and implementations in external security managers such as RACF provide applications with an alternative to storing certificates and/or keys in datasets or files. Previously, Java security providers on z/OS were unable to take advantage of the digital certificate support in SAF because there was no Java keystore that supported SAF. The JCECCARACFKS and JCERACFKS keystores now available in the SDK provides SAF digital certificate support, enabling the IBMJCE and IBMJCECCA providers to store and retrieve keys and certificates from SAF. See Key Management for more information on keystores. Digital certificate support is implemented as two Keystore types, JCERACFKS and JCECCARACFKS. An InputStream class called , an OutputStream class called , and a class are also implemented. The URLStreamHandler class enables a RACFInputStream or RACFOutputStream to be accessed using a URL. URLStreamHandlers are also available for both the IBMJCE keytool program and the IBMJCECCA keytool program (hwkeytool) for z/OS. See the keytool users guide for more information on keytool. The RACF keystore classes, JCERACFKS for the IBMJCE provider and JCECCARACFKS for the IBMJCECCA provider, are only available on the z/OS platform where SAF is available. A keystore class, JceRACFKeyStore, is implemented in both the IBMJCE and IBMJCECCA providers. This class is available for storing and retrieving certificates and keys from a RACF key ring. The RACFInputStream and RACFOutputStream are only intended to be used with the JceRACFKeyStore. Use of the RACFInputStream or RACFOutputStream with other Key Stores may cause unexpected results. All of the JAVA RACF services, including the , and , make use of the R_datalib (IRRSDL00) service to retrieve and store certificates from RACF. In order to use this service certain authorizations must be granted to the user, depending on the desired setup. Be sure to have the correct authorizations set for R_datalib before using any Java RACF classes. For more information on how to set the necessary authorizations see the following publication: There are two ways to access keys and certificates stored in an SAF external security manager implementation using the RACFInputStream and RACFOutputStream. The first is using the RACFInputStream or RACFOutputStream directly by passing a newly created instance of it to the JceRACFKeyStore. The second is indirect, using URLStreamHandler to call RACFInputStream or RACFOutputStream and then passing the instance into JceRACFKeyStore. These are described in more detail below. The JCECCARACFKS and JCERACFKS keystores are able to store and retrieve certificates from a keyring honoring mixed case label and alias names. Users are encouraged to make use of alias or label names that contain at least one different character in their name than the rest of the alias or label names that are attached to the keyring. It is highly encouraged that users do not make use of same character alias or label names that differ only by case. A search mismatch can occur when storing or retrieving information from a JCECCARACFKS and JCERACFKS keystore when using same character label or alias names differing only by case. When setting up a keyring, any certificate connected as a \"PERSONAL\" certificate is considered a and therefore can be used as an end user certificate (for example, in a SSL handshake) since the private key is available. Any certificate connected as \"CERTAUTH\" is considered a and can be used, for example, as a Certificate Authority (CA) certificate in the authentication process of SSL. Any keyring that has a certificate that is not self signed and is connected as \"PERSONAL\" must also have the CA certificate of the \"PERSONAL\" certificate connected as \"CERTAUTH\". In the case of a self signed certificate, a \"CERTAUTH\" certificate is not required to be present. Certificates connected as \"SITE\" are not supported at this time. Below is an example setup of a RACF keyring that can be used by a JSSE client and server for both trust and key information. Certificate Label Name Cert Owner USAGE DEFAULT ---------------------- ---------- -------- ------- PersonalEndUserCert ID(USERID) PERSONAL YES PersonalEndUserCACert CERTAUTH CERTAUTH NO Using a RACFInputStream to load a RACF key ring into a Java RACF KeyStore Creating a RACFInputStream requires these three parameters:\n• userID - a string containing the ID of the user that owns the keyring\n• ringid - a string containing the name of the RACF key ring\n• password - a character array containing the password for the keystore The following is an example of using RACFInputSteam directly, passing it a user ID, a ring ID and a null password. In the above example, the system property \"user.name\" is used to obtain the userid that will be passed to RACF. In an actual application, this will probably not be done. Using a RACFOutputStream to store a Java RACF KeyStore into a RACF key ring Creating a RACFOutputStream requires these three parameters:\n• userID - a string containing the ID of the user that owns the keyring\n• ringid - a string containing the name of the RACF key ring\n• password - a character array containing the password for the keystore The following is an example of using RACFOutputStream directly, passing it a user ID, a ring ID and a null password. In the above example, the system property \"user.name\" is used to obtain the userid that will be passed to RACF. In an actual application, this will probably not be done. Storing keys into RACF using the RACFKeyStore The RACF KeyStore can be used to update an existing RACF key ring or create a new RACF key ring. If the RACF key ring specified by the userid and ring name to the does not exist, the Key Ring will be created. If the RACF Key Ring already exists, then it will be updated. In either case, all certificates and keys in the KeyStore will be added to the RACF key ring when the store method is invoked. When updating an existing RACF key ring, any existing RACF certificates and keys that are deleted, will be removed from the RACF key ring when the store method is invoked. Entries deleted from the RACF KeyStore will be removed from the RACF key ring, but the RACF certificate profile will not be deleted from RACF. If a certificate is added that already exists in RACF, but with a different label/alias, the certificate will be added to the RACF Key Ring with the existing label, and an IOException will be returned to indicate the certificate already exists with a different label/alias. If an error is detected while updating a RACF Key Ring, all additional adds or deletes of entries are processed, but only the first error will be reported as an exception.\n\n The following scenario demonstrates this property:\n• A is created to specify an existing input RACF Key Ring.\n• The is loaded into a using the method.\n• The input ring contains 1 key entry named Key01 and 1 trusted certificate entry named Cert01.\n• Key01 is deleted using the method.\n• Two new key entries named Key02 and Key03 are added to the using the method.\n• A is created to specify an output RACF Key Ring.\n• The updates are written to the RACF Key Ring specified in the using the method.\n• First, the delete entry is processed by successfully removing Key01 from the output RACF Key Ring.\n• Next, all entries from the RACFKeyStore are added to the output RACF Key Ring.\n• In this example, an error occurs while attempting to add Key02 to the output RACF Key Ring.\n• Cert01 is added successfully to the output RACF Key Ring.\n• An error occurs while attempting to add Key03 to the output RACF Key Ring.\n• An exception is thrown with the details of the error that occured while attempting to add Key02. In SDK 1.2 and above, the URLStreamHandler class enables access to data using user defined classes. The system property java.protocol.handler.pkgs allows the application to define the classes that access the data. The URL \"safkeyring \" and associated classes access data stored in an SAF (RACF) keyring. The following java property must be defined to enable the URLStreamHandler class to create a RACFInputStream: If the IBMJCE provider is being used to provide cryptographic support, the property must be set to the value com.ibm.crypto.provider. The following example illustrates setting this property on the java command line when running the Java class \"myApplication\": If the IBMJCECCA provider is being used to provide cryptographic support, the property must be set to the value com.ibm.crypto.hdwrCCA.provider. The following example illustrates setting this property programatically in a Java application: The JCERACFKS RACF Key Store supports the following Java key types: The JCECCARACFKS RACF Key Store supports the following Java key types:\n• - Software key format\n\n This key type is converted to RSAPrivateHWKey format\n• - Software CRT format\n\n This key type is converted to an RSAPrivateHWKey format All other key formats are not supported. In file based KeyStores the password parameter is used for three primary reasons:\n• Protect the integrity of the KeyStore file\n• Protect keys in Java memory while being used in a KeyStore\n• Protect keys when at rest in the file based KeyStore The password parameter is used differently by the RACF KeyStore. Since keys in the RACF KeyStore are stored in the RACF Data Base rather than in a file, the password is only used to protect keys while the KeyStore is in Java memory. Digital Certificates and Keys in RACF Key Rings are protected by RACF profiles. All the following RACF KeyStore methods use the password parameter: The method uses the input password to protect keys loaded from RACF in Java memory. The method uses the input password to validate that the input RACFInputStream is constructed with the same password. The method uses the input password to protect the input key. The method uses the input password to recover the protected key. The method uses the input password to validate that the input RACFOutputStream is constructed with the same password. The method uses the input password to recover any protected keys from Java memory before storing them to a RACF Key Ring. In addition to KeyStore passwords, Java APIs enable an application to specify a password to protect an individual KeyStore entry. Within an instance of using the JceRACFKeyStore, RACFInputStream and RACFOutputStream to retrieve and set keys, the same password must be used. It is recommended that all passwords are left to default. The password parameter defaults to \" \" on all methods by passing in . hwkeytool and the ICSF CSFSERV and CSFKEYS RACF classes If the user of hwkeytool is not authorized to create new profiles in the ICSF CSFKEYS RACF class, hwkeytool may create a key that the user is not able to access. To prevent this from happening, the user of hwkeytool should verify that they are authorized to the profiles in the ICSF CSFSERV RACF class including CSFPKG. A number of these ICSF services are used by hwkeytool. In addition, the user of hwkeytool should verify that they have authority to create new profiles in the ICSF CSFKEYS RACF class. Developers and users of programs that invoke the Java security class KeyPairGenerator to generate an IBMJCECCA public and private key pair should also be aware of above item relating to the ICSF CSFKEYS and CSFSERV RACF classes. A KeyStore is a Java object containing a collection of keys and certificates that are referenced by unique labels or alias names. For most Java keystores, the persistent data is stored in a file. However, the persistent data for a JCECCARACFKS keystore is stored in the RACF database and connected to a RACF keyring. Due to the nature of the RACF database and keyrings, the behavior of a JCECCARACFKS keystore during update operations differs from the behavior of file based keystores. In the following discussion, \"application\" can refer to a user KeyStore application or can refer to the hwkeytool utility program. In order to access the contents of a keystore, an application uses the load() method to retrieve the persistent data from the keystore and create a KeyStore object. This object can be queried and updated by the application. KeyStore update methods include deleteEntry(), setEntry(), setCertificateEntry(), and setKeyEntry(). hwkeytool update commands supported for RACF keystores include -delete, -genkeypair, -importcert, and -importkeystore. If the application intends to modify the persistent data for the keystore, it uses the store() method. The behavior of the store() method depends on the underlying storage of the persistent data. The update model for file based keystores is a replace model. When the application uses the store() method for a file based keystore, the contents of the KeyStore object in the application memory replace the current persistent data for the keystore. In other words, any KeyStore update that has been successful will be reflected in the new version of the persistent data for the keystore. One consequence of the replace model occurs if two applications are updating the same keystore at the same time. To illustrate, suppose application app1 and application app2 are modifying some keystore and\n• app1 loads the keystore into a KeyStore object and makes some updates\n• app2 loads the keystore into a KeyStore object and makes some updates\n• app1 stores the contents of the KeyStore object into the persistent keystore data\n• app2 stores the contents of the KeyStore object into the persistent keystore data In this case, because the app1 changes were not stored in persistent data before app2 loaded the keystore, and because app2 replaced the persistent data after app1, updates made by app1 are overwritten by app2. \n\n The update model for a JCECCARACFKS keystore is an update model. It was implemented in this way to avoid the effect described above. If a change is made to an existing KeyStore entry, the existing version of the entry is disconnected from the keyring, the data for the new entry is added to the RACF database, and then the new entry is connected to the keyring. Even if the update is a delete operation, whether deleteEntry() or hwkeytool -delete, the data is not removed from the RACF database, it is only disconnected from the keyring represented by the KeyStore. To delete data from the RACF database, you must use the RACF utility RACDCERT. Some RACF database and keyring updates that are not permitted are:\n• An entry with an expired certificate cannot be updated.\n• An entry cannot be updated with an expired certificate.\n• A certificate entry cannot be replaced with a key entry.\n• A key entry cannot be replaced with a certificate entry.\n• An entry cannot be updated unless the public key in the new version matches the public key in the existing version.\n• Although a single certificate can be connected to many keyrings, there can be only one copy of it in the RACF database and it will be stored with only one label. When the IBMJCECCA security provider can detect an update that will not be allowed by RACF, an exception is thrown when the KeyStore entry update is attempted. In some cases, the IBMJCECCA security provider can not predict that a RACF database update will be unsuccessful. One consequence of this is that a KeyStore update may be successful but an error or warning is reported during the store() operation. Some possible effects of this behavior are:\n• The previous version of the entry is disconnected from the keyring and the new version is not connected to the keyring.\n• A certificate may be connected to the keyring using a label other than the one specified in the KeyStore update. If there are unintended and undesired changes to a keystore, it might be necessary to reconnect or to update keyring entries using the RACF utility RACDCERT. For more information on inserting or updating information in the RACF External Security Manager refer to the command. Publications available for RACF include: \n\n\n\nThis information was developed for products and services offered in the U.S.A. IBM may not offer the products, services, or features discussed in this document in other countries. Consult your local IBM representative for information on the products and services currently available in your area. Any reference to an IBM product, program, or service is not intended to state or imply that only that IBM product, program, or service may be used. Any functionally equivalent product, program, or service that does not infringe any IBM intellectual property right may be used instead. However, it is the user's responsibility to evaluate and verify the operation of any non-IBM product, program, or service.\n\nIBM may have patents or pending patent applications covering subject matter in this document. The furnishing of this document does not give you any license to these patents. You can send license inquiries, in writing, to:\n\nFor license inquiries regarding double-byte (DBCS) information, contact the IBM Intellectual Property Department in your country or send inquiries, in writing, to:\n\nThe following paragraph does not apply to the United Kingdom or any other country where such provisions are inconsistent with local law:\n\nINTERNATIONAL BUSINESS MACHINES CORPORATION PROVIDES THIS PUBLICATION \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Some states do not allow disclaimer of express or implied warranties in certain transactions, therefore, this statement may not apply to you.\n\nThis information could include technical inaccuracies or typographical errors. Changes are periodically made to the information herein; these changes will be incorporated in new editions of the information. IBM may make improvements and/or changes in the product(s) and/or the program(s) described in this information at any time without notice.\n\nAny references in this information to non-IBM Web sites are provided for convenience only and do not in any manner serve as an endorsement of those Web sites. The materials at those Web sites are not part of the materials for this IBM product and use of those Web sites is at your own risk.\n\nIBM may use or distribute any of the information you supply in any way it believes appropriate without incurring any obligation to you.\n\nLicensees of this program who wish to have information about it for the purpose of enabling (i) the exchange of information between independently created programs and other programs (including this one) and (ii) the mutual use of the information which has been exchanged, should contact:\n\nSuch information may be available, subject to appropriate terms and conditions, including in some cases, payment of a fee.\n\nThe licensed program described in this document and all licensed material available for it are provided by IBM under terms of the IBM Customer Agreement, IBM International Program License Agreement or any equivalent agreement between us.\n\nAny performance data contained herein was determined in a controlled environment. Therefore, the results obtained in other operating environments may vary significantly. Some measurements may have been made on development-level systems and there is no guarantee that these measurements will be the same on generally available systems. Furthermore, some measurement may have been estimated through extrapolation. Actual results may vary. Users of this document should verify the applicable data for their specific environment.\n\nInformation concerning non-IBM products was obtained from the suppliers of those products, their published announcements or other publicly available sources. IBM has not tested those products and cannot confirm the accuracy of performance, compatibility or any other claims related to non-IBM products. Questions on the capabilities of non-IBM products should be addressed to the suppliers of those products.\n\nIBM is a trademark or registered trademark of International Business Machines Corporation in the United States, or other countries, or both.\n\nJava and all Java-based trademarks and logos are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States, other countries, or both.\n\nOther company, product, or service names may be trademarks or service marks of others."
    },
    {
        "link": "https://medium.com/@zomev/16-encryption-key-management-best-practices-e80d2a21b928",
        "document": "Every company that uses cryptography to protect sensitive data must follow encryption key management best practices. These practices keep cryptographic keys safe throughout their lifecycle and ensure cybersecurity measures do not fall short due to a lack of proper key management.\n\nUse Appropriate Algorithms and Key Sizes\n\nSelect the correct algorithm and key size for each encryption key. This decision depends on the use case and must account for:\n• The amount and value of encrypted data.\n\nDepending on the use case, you can either use:\n• Asymmetric algorithms (such as RSA or ECDSA).\n\nSymmetric algorithms are a good choice for protecting data at rest, so use this approach to keep databases safe. Asymmetric encryption is ideal for protecting data in motion, such as emails or web content. Choosing the correct key size requires balancing. \n\n \n\nLarger keys result in more secure encryption, but key length can impact performance. Be sensible with key sizes as large keys often cause issues. For example, using the AES-256 symmetric encryption for all processes will make your system secure, but you will run into performance problems.\n\nRely on the Principle of Least Privilege\n\nEmployees should only have access to the keys they require to perform their duties and tasks. The same need-to-know basis also applies to apps. Ensuring only authorized users and systems can access a key helps:\n• Limit the options for an attacker with a compromised key.\n• Limit the risk of an insider threat.\n\nProperly authenticate users every time they access, manage, or use an encryption key. Use role-based access controls (RBAC) to restrict permissions according to each user’s specific duties. \n\n \n\nConsider using the dual control principle (a.k.a. four eyes) for the keys responsible for vital operations, such as rotation or deletion. This practice requires two or more authorized people to approve the process before it can start.\n\nEach key in your organization should have a crypto period during which a key is functional. You calculate the crypto period by accounting for two factors:\n• The originator usage period (OUP): The time during which you apply cryptographic protection to a system.\n• The recipient usage period (RUP): The time during which users can decrypt data with a specific key.\n\nThe two periods start concurrently and are flexible, so define the crypto period based on:\n• The strength of the encryption algorithm.\n• The value of encrypted data.\n\nOnce the crypto period expires, run a rotation to replace the old key with a new one. Limiting the amount of data you encrypt with one key reduces the risk of lost or stolen credentials. Ideally, the rotation process should be automatic to prevent human errors and free the team from repetitive tasks. \n\n \n\nSee Also: Experience Our for Free VPS Hosting: Enjoy a 30-Day Trial with Risk-Free Servers\n\nA single company can rely on hundreds or even thousands of encryption keys. A centralized management platform helps organize, protect, manage, and use all those keys. A centralized platform leads to:\n• Simplified management that removes the need for using a set of different tools.\n• Total visibility into how employees and teams use keys.\n\nCentralized key management reduces risk, improves efficiency, and simplifies admin tasks. You can use this strategy to:\n• Create policies and procedures for all key-related operations (access controls, duty segregation, split knowledge, etc.).\n• Control access to valuable keys with user profiles, roles, and credentials.\n• Reduce costs by automating tasks and lowering the number of necessary staff members.\n\nIncluding key material in source code is a significant security concern. If the code is public, an attacker has a direct way to read the key. Even if the code is private, the development team becomes a go-to target for hackers, and your attack surface needlessly increases. \n\n \n\nAs an attacker can obtain a key without compromising the management app, you can suffer completely undetected breaches. Besides introducing needless risk, hard coding a key also poses a problem for rollovers and overall cryptographic agility.\n\nRelying on manual key management is time-consuming, expensive, and prone to mistakes. Automation allows you to:\n• Clear up the team’s schedule and allow employees to focus on innovation and improvements.\n\nAutomation in key management improves processes throughout a key’s lifecycle, so consider automating the following operations:\n• Rotating keys at set intervals to avoid going past their crypto period.\n\nSecurity policies dictate how staff members and teams should store, use, and manage keys. These policies provide:\n• Guidelines on what users can and cannot do with keys.\n• The responsibilities for the management of cryptographic keying material.\n\nOnce you prepare your policies, run training sessions to ensure employees know what you expect from the team. A centralized platform is the most reliable method of enforcing, updating, and communicating policies. \n\n \n\nAlso, if your encryptions rely on the cloud, ensure your key management and cloud security policies align well with each other.\n\nAn HSM (hardware security module) is a physical device that stores keys and enables you to perform cryptographic operations on-premises. These devices provide strong physical and logical security as stealing a key from an HSM requires an attacker to:\n• Steal the access card needed to reach the HSM.\n• Take the device from the premises without being noticed.\n• Bypass the encryption algorithm that protects the keys.\n\nRelying on an HSM in the cloud is also a viable method. In that scenario, the success depends on the cloud service provider’s security levels, so always side with a reputable vendor if you choose that option.\n\nSeparating key management tasks is an essential practice for any security-aware organization. This strategy requires you to divide responsibilities for critical tasks between different staff members. By doing so, you:\n• Minimize the potential for frauds and insider threats.\n\nFor example, you can task one person with authorizing access, another with distributing keys, and a third with creating keys. In that scenario, the user who permits access cannot steal the key during distribution or know the key’s value during the generation phase.\n\nCompanies should use a purpose-built secure API to safely distribute keys from the point of creation to the system or person that will use them. Consider the following:\n• For online distribution, you should encrypt keys and send them over a secure Transport Layer Security (TLS)\n• For offline transport, encrypt the key and split it into 2 or 3 components that are useless on their own.\n\nKey splitting ranks high among encryption key management best practices. With this strategy, a lost component does not lead to a stolen key unless the attacker can gather other portions. \n\n \n\nConsider using white-box cryptography for when keys arrive at their destination. White-box cryptography uses a software-based algorithm to protect keys no matter where they are or if they have hardware support. \n\n \n\nSee Also: Experience Our for Free VPS Hosting: Enjoy a 30-Day Trial with Risk-Free Servers\n\nIf your storage runs into an error or someone attacks it, you must have the ability to restore keys. Not being able to recover a key can lead to permanent loss of encrypted data. Ensure you have robust backups that allow you to restore lost keys quickly and reliably. Good practices include:\n• Running periodic checks of the backup app to ensure everything works correctly.\n\nSecure, automated, and centralized logging and reporting are vital to safe and compliant key management. Good practices include:\n• Keeping a complete history of each key throughout its lifecycle.\n• Logging details about every interaction with the key, including the purpose, the user (person or system), accessed data, queries, and the time of usage.\n\nClean, detailed logging and reporting help with:\n• Understanding the mechanics of your key management.\n\nConsider integrating your key management platform with a SIEM tool to enable deeper analysis and reporting.\n\nNever Use the Same Key for Different Purposes\n\nEach key should only have a single purpose, such as:\n\nEnsure employees never use duplicate keys for different tasks.\n\nKeep Keys Away from Encrypted Data\n\nNever keep the key in the same database as the encrypted data. While this practice simplifies management, keeping encrypted content alongside the key for decryption enables a hacker to compromise data with a single breach.\n\nNo matter how many policies and measures you set up, something will eventually go wrong. Even if you implement all encryption key management best practices, the following incidents are still likely:\n• A user will lose credentials to their key.\n• Someone will accidentally send keys to the wrong person.\n• Hackers might break into the key storage.\n\nAccidents happen, so being prepared helps mitigate the risk. Identify all possibilities and create a robust disaster recovery plan to ensure the team is ready for all scenarios.Read about cloud disaster recovery and the benefits of backing up critical data into the cloud.\n\nA company can run encryption and decryption processes either:\n• Locally at the file, database field, or app level.\n\nFrom a security perspective, distributing the scrambling and descrambling processes is a better option. If you set up secure key distribution, separating encryption and decryption leads to:\n\nRunning encryption and decryption at a central server is simpler to set up, but you will likely run into performance issues. Also, if an attacker compromises the central server, your entire security infrastructure could go down.\n\nEncryption Key Management Best Practices Keep Cryptography Safe and Healthy\n\nImplementing the practices listed above will ensure key management does not become a weakness in your security strategy. Use strong policies, robust access controls, and centralization to protect and stay in control of your encryption keys.\n\n\n\nhttps://www.zumiv.com/blog/16-encryption-key-management-best-practices/?feed_id=2313&_unique_id=655244c9ba2c8\n\n#server #webhosting #cloud #dedicatedserver #hosting #datacenter #Zumiv"
    },
    {
        "link": "https://thalestct.com/wp-content/uploads/2022/09/Best-Practices-for-Cryptographic-Key-Management.pdf",
        "document": "Thales Trusted Cyber Technologies protects the government’s most vital data from the core to the cloud to the edge with a unified approach to data protection. Our solutions reduce the risks associated with the most critical attack vectors and address the most stringent encryption, key management, and access control requirements."
    },
    {
        "link": "https://guardrails.io/blog/12-java-security-best-practices",
        "document": ""
    },
    {
        "link": "https://ssl.com/article/key-management-best-practices-a-practical-guide",
        "document": "As digital transformation accelerates across industries, organizations rely more heavily on cryptographic keys to secure data and enable secure digital processes. Cryptographic keys form the backbone of security for encryption, digital signatures, and authentication. However, more is required than simply deploying the latest cryptographic algorithms. Organizations must have robust key management practices to protect sensitive data and systems.\n\nThis article provides a practical guide to implementing key management best practices. We’ll cover key management’s importance, challenges, and best practices with real-world examples, key management solutions, and a checklist summary.\n\nKey management refers to the comprehensive processes and infrastructure required to control cryptographic keys throughout their lifecycle. This includes key generation (creating new cryptographic keys using secure algorithms), key distribution (securely delivering keys to authorized entities), key use (employing keys for cryptographic operations like encryption), key storage (storing keys securely when not in use), key revocation (revoking compromised or obsolete keys), and key destruction (securely destroying keys at end of life).\n\nRobust key management ensures keys remain confidential, available when needed, and cryptographically strong. Keys could be compromised, abused, or improperly tracked without proper controls. For example, weak key generation algorithms could produce predictable keys that are easy for attackers to crack. Insecure key storage, like unencrypted text files, leaves keys vulnerable to theft. Failing to revoke compromised keys promptly enables continued unauthorized decryption. Poor key management practices render encryption useless, leaving data exposed. That’s why standards bodies like NIST provide in-depth key management guidance.\n\nThe 2011 RSA breach exposed authentication that compromised millions of SecurID tokens. Hackers obtained cryptographic “seed” values RSA failed to properly secure on internal systems. This enabled the attackers to clone SecurID algorithms for two-factor authentication on banking, government and military networks. RSA did not adequately restrict access or encrypt the stolen SecurID seed database. The incident revealed severe implications of key management failures at a major security provider. It highlighted the need for access restrictions, network segmentation, and encryption to protect critical secrets.\n\nHere are some key management best practices that can help avoid these pitfalls:\n• None – Document detailed policies for all stages of the key lifecycle from creation to revocation and destruction. Define key management roles aligned to separation of duties and least privilege access. For example, the cryptographic officer role focuses on key generation, backup, and recovery, while the security auditor oversees policy compliance. Maintain an updated inventory detailing each key’s metadata, like creation date; encryption algorithm approved uses, and ownership.\n• None – Adhere to the latest guidance the global cryptography community has recently recommended moving from 2048-bit RSA keys to 3072-bit RSA keys. This is due to concerns that 2048-bit RSA keys may become vulnerable to attacks, particularly with the potential advent of large-scale quantum computers in the future. The 3072-bit RSA key length provides increased security margins and is the new recommended minimum standard for high-security use cases.\n• None – Use tested random number generators with high entropy sources to create keys with maximum unpredictability. For public/private key pairs, generate keys inside trusted cryptographic modules like HSMs rather than less secure software. Destroy seed values and unnecessary key copies immediately after generation.\n• None – Avoid manual key transfer whenever possible. Use automated secure protocols like TLS for key delivery. For software keys, inject directly into applications and encrypt while at rest. Never hardcode keys. For hardware modules like HSMs, use tamper-resistant hardware with secure boot mechanisms.\n• None – Keep keys in isolated cryptographic modules like HSMs with locked-down access controls where possible. Encrypt software keys while at rest using other keys or passphrases. Store encrypted keys separately from encrypted data. Use access controls, configuration hardening, and key camouflaging techniques to increase the security of stored keys.\n• None – Logically or physically separate keys used for different purposes to limit the potential impact of any compromise. For example, we secure keys for CA/PKI infrastructure separately from encryption keys for customer data.\n• None – Periodically rotate intermediate and end-entity keys to limit the amount of data exposed if keys are compromised. Use shorter rotation periods based on your risk analysis for high-impact keys. Automate rotation processes using secure protocols to minimize operational overhead.\n• None – Monitor access attempts, key usage patterns, and other activity to detect potential misuse or compromise. For hardware keys, monitor tamper events like unauthorized physical access or configuration changes.\n• None – Have automated emergency processes to revoke compromised keys organization-wide rapidly. For destroyed keys, utilize techniques like cryptographic erasure to prevent key reconstruction.\n• None – Keep encrypted backups of keys in separate systems like air-gapped offline storage—document detailed disaster recovery plans for restoring backups and replacing keys in case of catastrophic loss.\n• None – Perform annual audits examining all aspects of key management infrastructure, including policies, personnel, technologies, and processes. Continuously assess new encryption-breaking advances like quantum computing and adjust key strength accordingly.\n• None automate generation, rotation, and other aspects of the key lifecycle\n\nOrganizations should conduct in-depth evaluations of solutions against their security and operational requirements before selection. They should also regularly review the controls of providers like cloud services.\n\nUse this checklist of critical steps for implementing a robust key management strategy:\n• None Logically or physically separate keys based on the use case\n• None Set up automated periodic key rotation for intermediate and end-entity keys.\n\nFollowing these best practices throughout the key lifecycle can help secure your organization’s sensitive data and systems from compromise.\n\nAt SSL.com, we are devoted to assisting businesses in navigating this challenging environment because we recognize the value of sound key management procedures. To support your key management requirements and ensure the security and integrity of your digital assets, we provide solutions that are at the forefront of the industry.\n\nYou may create a strong, secure key management system that will act as a solid basis for your company’s overall cybersecurity framework by adhering to the guidelines provided in this article and using the knowledge of reliable partners like SSL.com."
    },
    {
        "link": "https://stackoverflow.com/questions/63165910/best-practice-to-store-encryption-keys-salt-password-in-java",
        "document": "I have a configuration properties file that contains sensitive information, so naturally I want to encrypt them. I'm aware there are a lot of methods to encrypting them, but most of them requires a password/key/salt to encrypt and decrypt those values.\n\nSo my question is, what is the best practice to store those encryption keys? I don't have a database or server since the application that reads that config file does not need them."
    }
]