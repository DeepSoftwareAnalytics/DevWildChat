[
    {
        "link": "https://cplusplus.com/reference/vector/vector",
        "document": "an unsigned integral type that can represent any non-negative value of\n\nusually the same as size_t"
    },
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/the-c-standard-template-library-stl",
        "document": "The C++ Standard Template Library (STL) is a set of template classes and functions that provides the implementation of common data structures and algorithms such as lists, stacks, arrays, sorting, searching, etc. It also provides the iterators and functors which makes it easier to work with algorithms and containers.\n\nSTL was originally designed by Alexander Stepanov and was later accepted as the part of C++ standard in C++ 98. It is a generalized library so we can use it with almost every data type without repeating the implementation code.\n\nThe components of STL are the features provided by Standard Template Library (STL) in C++ that can be classified into 4 types:\n\nThese components are designed to be efficient, flexible, and reusable, making them an integral part of modern C++ programming.\n\nContainers are the data structures used to store objects and data according to the requirement. Each container is implemented as a template class that also contains the methods to perform basic operations on it. Every STL container is defined inside its own header file.\n\nContainers can be further classified into 4 types:\n\nIf you want to dive deep into STL and understand its full potential, our Complete C++ Course offers a complete guide to mastering containers, iterators, and algorithms provided by STL.\n\nSequence containers store the data in the linear manner. They are also used to implement container adaptors.\n\nThere are 5 sequence containers in C++ STL:\n• Arrays : The STL array is an implementation of a compile time non-resizable array. It contains various method for common array operations.\n• Vector : An STL vector can be defined as the dynamic sized array which can be resized automatically when new elements are added or removed.\n• Deque : Deque or Double-Ended Queue is sequence containers with the feature of expansion and contraction on both ends. It means we can add and remove the data to and from both ends.\n• Lists : List container stores data in non-contiguous memory unlike vectors and only provide sequential access to the stored data. It basically implements the doubly linked list.\n• Forward Lists: Forward lists also store the data in a sequential manner like lists, but with the difference that forward list stores the location of only the next elements in the sequence. It implements the singly linked list.\n\nThe container adapters are the type of STL containers that adapt existing container classes to suit specific needs or requirements.\n\nThere are 3 container adaptors in C++ STL:\n• Stack: STL Stack follows the Last In First Out (LIFO) principle of element insertion and deletion. Also, these operations are performed only at one end of the stack.\n• Queue: STL Queue follows the First In First Out (FIFO) principle, means the element are inserted first are removed first and the elements inserted last are removed at last. It uses deque container by default.\n• Priority Queue: STL Priority Queue does not follow any of the FIFO or LIFO principle, but the deletion of elements is done on the basis of its priority. So, the element with the highest (by default) is always removed first. By default, it uses vector as underlying container.\n\nAssociative containers are the type of containers that store the elements in a sorted order based on keys rather than their insertion order.\n\nThere are 4 associative containers in C++ STL:\n• Sets : STL Set is a type of associative container in which each element has to be unique because the value of the element identifies it. By default, the values are stored in ascending order.\n• Maps : STL Maps are associative containers that store elements in the form of a key-value pair. The keys have to be unique and the container is sorted on the basis of the values of the keys.\n• Multisets : STL Multiset is similar to the set container except that it can store duplicate values.\n• Multimaps : STL Multimap is similar to a map container but allows multiple mapped values to have same keys.\n\nUnordered associative containers store the data in no particular order, but they allow the fastest insertion, deletion and search operations among all the container types in STL.\n\nThere are 4 unordered associative containers in C++ STL:\n• Unordered Set : STL Unordered Set stores the unique keys in the form of hash table. The order is randomized but insertion, deletion and search are fast.\n• Unordered Multiset : STL Unordered Multiset works similarly to an unordered set but can store multiple copies of the same key.\n• Unordered Map : STL Unordered Map stores the key-value pair in a hash table, where key is hashed to find the storage place.\n• Unordered Multimap : STL Unordered Multimap container is similar to unordered map, but it allows multiple values mapped to the same key.\n\nSTL algorithms offer a wide range of functions to perform common operations on data (mainly containers). These functions implement the most efficient version of the algorithm for tasks such as sorting, searching, modifying and manipulating data in containers, etc. All STL algorithms are defined inside the <algorithm> and <numeric> header file.\n\nThere is no formal classification of STL algorithms, but we can group them into two types based on the type of operations they perform:\n\nManipulative algorithms perform operations that modifies the elements of the given container or rearrange their order.\n\nSome of the common manipulative algorithm includes:\n• copy : Copies a specific number of elements from one range to another.\n• fill : Assigns a specified value to all elements in a range.\n• transform : Applies a function to each element in a range and stores the result in another range.\n• replace : Replaces all occurrences of a specific value in a range with a new value.\n• swap : Exchanges the values of two variables.\n• reverse : Reverses the order of elements in a range.\n• rotate : Rotates the elements in a range such that a specific element becomes the first.\n• remove : Removes all elements with a specified value from a range but does not reduce the container size.\n\nNon-manipulating algorithms are the type of algorithms provided by the Standard Template Library (STL) that operate on elements in a range without altering their values or the order of the elements.\n\nThe below are the few examples of the STL’s non-manipulative algorithms:\n• max_element : Find the maximum element in the given range.\n• min_element : To find the minimum element in the given range.\n• accumulate : Finds the sum of the elements of the given range.\n• count : Counts the occurrences of given element in the range.\n• find : Returns an iterator to the first occurrence of an element in the range.\n• is_permutation : Checks if one range is a permutation of another.\n• is_sorted : Checks if the elements in a range are sorted in non-decreasing order.\n• partial_sum : Computes the cumulative sum of elements in a range.\n\nIterators are the pointer like objects that are used to point to the memory addresses of STL containers. They are one of the most important components that contributes the most in connecting the STL algorithms with the containers. Iterators are defined inside the <iterator> header file.\n\nIn C++ STL, iterators are of 5 types:\n• Input Iterators : Input Iterators can be used to read values from a sequence once and only move forward.\n• Output Iterators : Output Iterators can be used to write values into a sequence once and only move forward.\n• Forward Iterators : Forward Iterators combine the features of both input and output iterators.\n• Bidirectional Iterators : Bidirectional Iterators support all operations of forward iterators and additionally can move backward.\n• Random Access Iterators : Random Access Iterators support all operations of bidirectional iterators and additionally provide efficient random access to elements.\n\nFunctors are objects that can be treated as though they are a function. Functors are most commonly used along with STL algorithms. It overloads the function-call operator and allows us to use an object like a function. There are many predefined functors in C++ STL that are defined inside the <functional> header file.\n\nFunctors can be classified into multiple types based on the type of operator they perform:\n• plus – Returns the sum of two parameters.\n• minus – Returns the difference of two parameters.\n• multiplies – Returns the product of two parameters.\n• divides – Returns the result after dividing two parameters.\n• modulus – Returns the remainder after dividing two parameters.\n• negate – Returns the negated value of a parameter.\n• equal_to – Returns true if the two parameters are equal.\n• not_equal_to – Returns true if the two parameters are not equal.\n• greater – Returns true if the first parameter is greater than the second.\n• greater_equal – Returns true if the first parameter is greater than or equal to the second.\n• less – Returns true if the first parameter is less than the second.\n• less_equal – Returns true if the first parameter is less than or equal to the second.\n• logical_and – Returns the result of Logical AND operation of two parameters.\n• logical_or – Returns the result of Logical OR operation of two parameters.\n• logical_not – Returns the result of Logical NOT operation of the parameters.\n• bit_and – Returns the result of Bitwise AND operation of two parameters.\n• bit_or – Returns the result of Bitwise OR operation of two parameters.\n• bit_xor – Returns the result of Bitwise XOR operation of two parameters.\n\nThe Utility Library is a collection of utility components provided by the Standard Template Library (STL) that does not fall in the above categories. It offers various features such as pairs, tuples, etc.\n\nThe memory library contains the function that helps users to efficiently manage the memory such as std::move, smart pointers, etc.\n• Move Semantics : It allows the transfer of resources from one object to another without copying.\n• Smart Pointers : They are a wrapper over the raw pointers and helps in avoiding errors associated with pointers.\n• Utility Functions : Utility functions in C++ provide important operations like std::forward to facilitate efficient, generic and safe code manipulation.\n• Integer Sequence : Enable compile-time generation of integer sequences, useful in metaprogramming.\n\nThe key benefit of the STL is that it provides a way to write generic, reusable code and tested code that can be applied to different data types. This means you can write an algorithm once and then use it with other types of data without having to write separate code for each type.\n\nOther benefits include:\n• None STL provides flexibility through customizable templates, functors, and lambdas.\n• None Pre-implemented tools let you focus on problem-solving rather than low-level coding.\n\nThe major limitation of the C++ Standard Template Library (STL) is Performance Overheads. While STL is highly optimized for general use cases, its generic nature can lead to less efficient memory usage and execution time compared to custom and specialized solutions.\n\nOther limitations can be:\n\nDespite these limitations, STL remains an invaluable part of C++ programming, offering a wide range of powerful and flexible tools."
    },
    {
        "link": "https://github.com/MicrosoftDocs/cpp-docs/blob/master/docs/cppcx/platform-collections-vector-class.md",
        "document": "Represents a sequential collection of objects that can be individually accessed by index. Implements Windows::Foundation::Collections::IObservableVector to help with XAML data binding.\n\nT\n\n The type of the elements contained in the Vector object.\n\nE\n\n Specifies a binary predicate for testing equality with values of type T. The default value is .\n\nThe Vector class is the C++ concrete implementation of the Windows::Foundation::Collections::IVector interface.\n\nIf you attempt to use a Vector type in a public return value or parameter, compiler error C3986 is raised. You can fix the error by changing the parameter or return value type to Windows::Foundation::Collections::IVector. For more information, see Collections (C++/CX).\n\nInserts the specified item after the last item in the current Vector.\n\nindex\n\n The item to insert into the Vector. The type of item is defined by the T typename.\n\nDeletes all the elements in the current Vector.\n\nReturns an iterator that points to the first element in the Vector.\n\nAn iterator that points to the first element in the Vector.\n\nA convenient way to hold the iterator returned by First() is to assign the return value to a variable that is declared with the type deduction keyword. For example, . This iterator knows the length of the collection.\n\nWhen you need a pair of iterators to pass to an STL function, use the free functions Windows::Foundation::Collections::begin and Windows::Foundation::Collections::end\n\nRetrieves the element of the current Vector that is identifed by the specified index.\n\nindex\n\n A zero-based, unsigned integer that specifies a particular element in the Vector object.\n\nThe element specified by the index parameter. The element type is defined by the T typename.\n\nRetrieves a sequence of items from the current Vector, starting at the specified index, and copies them into the caller-allocated array.\n\nstartIndex\n\n The zero-based index of the start of the items to retrieve.\n\ndest\n\n A caller-allocated array of items that begin at the element specified by startIndex and end at the last element in the Vector.\n\nThis function is not intended for use directly by client code. It is used internally in the to_vector Function to enable efficient conversion of Platform::Vector intances to std::vector instances.\n\nReturns a read-only view of a Vector; that is, an IVectorView.\n\nSearches for the specified item in the current Vector, and if found, returns the index of the item.\n\nindex\n\n The zero-based index of the item if parameter value is found; otherwise, 0.\n\nThe index parameter is 0 if either the item is the first element of the Vector or the item was not found. If the return value is , the item was found and it is the first element; otherwise, the item was not found.\n\nif the specified item is found; otherwise, .\n\nIndexOf uses std::find_if to find the item. Custom element types should therefore overload the == and != operator in order to enable the equality comparisons that find_if requires.\n\nInserts the specified item into the current Vector at the element identified by the specified index.\n\nindex\n\n A zero-based, unsigned integer that specifies a particular element in the Vector object.\n\nitem\n\n An item to insert into the Vector at the element specified by index. The type of item is defined by the T typename.\n\nDeletes the element identified by the specified index from the current Vector.\n\nindex\n\n A zero-based, unsigned integer that specifies a particular element in the Vector object.\n\nDeletes the element at the end of the current Vector.\n\nDeletes the elements in the current Vector and then inserts the elements from the specified array.\n\narr\n\n An array of objects whose type is defined by the T typename.\n\nAssigns the specified value to the element in the current Vector that is identified by the specified index.\n\nindex\n\n A zero-based, unsigned integer that specifies a particular element in the Vector object.\n\nitem\n\n The value to assign to the specified element. The type of item is defined by the T typename.\n\nReturns the number of elements in the current Vector object.\n\nThe number of elements in the current Vector.\n\nInitializes a new instance of the Vector class.\n\na\n\n A std::array that will be used to initialize the Vector.\n\narr\n\n A Platform::Array that will be used to initialize the Vector.\n\nInIt\n\n The type of a collection of objects that is used to initialize the current Vector.\n\nil\n\n A std::initializer_list of objects of type T that will be used to initialize the Vector.\n\nN\n\n The number of elements in a collection of objects that is used to initialize the current Vector.\n\nsize\n\n The number of elements in the Vector.\n\nvalue\n\n A value that is used to initialize each element in the current Vector.\n\nv\n\n An Lvalues and Rvalues to a std::vector that is used to initialize the current Vector.\n\nptr\n\n Pointer to a that is used to initialize the current Vector.\n\nfirst\n\n The first element in a sequence of objects that are used to initialize the current Vector. The type of first is passed by means of perfect forwarding. For more information, see Rvalue Reference Declarator: &&.\n\nlast\n\n The last element in a sequence of objects that are used to initialize the current Vector. The type of last is passed by means of perfect forwarding. For more information, see Rvalue Reference Declarator: &&."
    },
    {
        "link": "https://geeksforgeeks.org/operator-overloading-cpp",
        "document": "in C++, Operator overloading is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.\n\nIn this article, we will further discuss about operator overloading in C++ with examples and see which operators we can or cannot overload in C++.\n\nC++ has the ability to provide the operators with a special meaning for a data type, this ability is known as operator overloading. Operator overloading is a compile-time polymorphism. For example, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +. Other example classes where arithmetic operators may be overloaded are Complex Numbers, Fractional Numbers, Big integers, etc.\n\nHere, variables “a” and “b” are of types “int” and “float”, which are built-in data types. Hence the addition operator ‘+’ can easily add the contents of “a” and “b”. This is because the addition operator “+” is predefined to add variables of built-in data type only.\n\n\n\nIn this example, we have 3 variables “a1”, “a2” and “a3” of type “class A”. Here we are trying to add two objects “a1” and “a2”, which are of user-defined type i.e. of type “class A” using the “+” operator. This is not allowed, because the addition operator “+” is predefined to operate only on built-in data types. But here, “class A” is a user-defined type, so the compiler generates an error. This is where the concept of “Operator overloading” comes in.\n\nNow, if the user wants to make the operator “+” add two class objects, the user has to redefine the meaning of the “+” operator such that it adds two class objects. This is done by using the concept of “Operator overloading”. So the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.\n\nExample of Operator Overloading in C++\n\nOperator functions are the same as normal functions. The only differences are, that the name of an operator function is always the operator keyword followed by the symbol of the operator, and operator functions are called when the corresponding operator is used.\n\nCan We Overload All Operators?\n\nAlmost all operators can be overloaded except a few. Following is the list of operators that cannot be overloaded.\n\nOperators that can be Overloaded in C++\n\nBut, among them, there are some operators that cannot be overloaded. They are\n\nWhy can’t the above-stated operators be overloaded?\n\nThis returns the size of the object or datatype entered as the operand. This is evaluated by the compiler and cannot be evaluated during runtime. The proper incrementing of a pointer in an array of objects relies on the sizeof operator implicitly. Altering its meaning using overloading would cause a fundamental part of the language to collapse.\n\nThis provides a CPP program with the ability to recover the actually derived type of the object referred to by a pointer or reference. For this operator, the whole point is to uniquely identify a type. If we want to make a user-defined type ‘look’ like another type, polymorphism can be used but the meaning of the typeid operator must remain unaltered, or else serious issues could arise.\n\nThis helps identify and specify the context to which an identifier refers by specifying a namespace. It is completely evaluated at runtime and works on names rather than values. The operands of scope resolution are note expressions with data types and CPP has no syntax for capturing them if it were overloaded. So it is syntactically impossible to overload this operator.\n\nThe importance and implicit use of class member access operators can be understood through the following example:\n\nThe statement ComplexNumber c3 = c1 + c2; is internally translated as ComplexNumber c3 = c1.operator+ (c2); in order to invoke the operator function. The argument c1 is implicitly passed using the ‘.’ operator. The next statement also makes use of the dot operator to access the member function print and pass c3 as an argument.\n\nBesides, these operators also work on names and not values and there is no provision (syntactically) to overload them.\n\nThe ternary or conditional operator is a shorthand representation of an if-else statement. In the operator, the true/false expressions are only evaluated on the basis of the truth value of the conditional expression.\n\nconditional statement ? expression1 (if statement is TRUE) : expression2 (else)\n\nA function overloading the ternary operator for a class say ABC using the definition\n\nwould not be able to guarantee that only one of the expressions was evaluated. Thus, the ternary operator cannot be overloaded.\n\n1) For operator overloading to work, at least one of the operands must be a user-defined class object.\n\n2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment operator does assign all members of the right side to the left side and works fine in most cases (this behavior is the same as the copy constructor). See this for more details.\n\n3) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.\n\nOverloaded conversion operators must be a member method. Other operators can either be the member method or the global method.\n\n4) Any constructor that can be called with a single argument works as a conversion constructor, which means it can also be used for implicit conversion to the class being constructed."
    },
    {
        "link": "http://cs.caltech.edu/courses/cs11/material/cpp/donnie/cpp-ops.html",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/operators",
        "document": "Customizes the C++ operators for operands of user-defined types.\n\nThe behaviors of non-punctuation operators are described in their own respective pages. Unless otherwise specified, the remaining description in this page does not apply to these functions.\n\nWhen an operator appears in an expression, and at least one of its operands has a class type or an enumeration type, then overload resolution is used to determine the user-defined function to be called among all the functions whose signatures match the following:\n\nOverloaded operators (but not the built-in operators) can be called using function notation:\n• An operator function must have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.\n• The operators (scope resolution), (member access), (member access through pointer to member), and (ternary conditional) cannot be overloaded.\n• New operators such as , , or cannot be created.\n• It is not possible to change the precedence, grouping, or number of operands of operators.\n• The overload of operator must either return a raw pointer, or return an object (by reference or by value) for which operator is in turn overloaded.\n• The overloads of operators and lose short-circuit evaluation.\n\nBesides the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: operator+ is expected to add, rather than multiply its arguments, operator= is expected to assign, etc. The related operators are expected to behave similarly (operator+ and operator+= do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write a = b = c = d, because the built-in operators allow that.\n\nCommonly overloaded operators have the following typical, canonical forms:[1]\n\nThe assignment operator operator= has special properties: see copy assignment and move assignment for details.\n\nThe canonical copy-assignment operator is expected to be safe on self-assignment, and to return the lhs by reference:\n\nIn those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member std::vector or std::string), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.\n\nThis form automatically provides strong exception guarantee, but prohibits resource reuse.\n\nThe overloads of and that take a std::istream& or std::ostream& as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument ( in ), they must be implemented as non-members.\n\nThese operators are sometimes implemented as friend functions.\n\nWhen a user-defined class overloads the function call operator operator(), it becomes a FunctionObject type.\n\nAn object of such a type can be used in a function call expression:\n\nMany standard library algorithms accept FunctionObjects to customize behavior. There are no particularly notable canonical forms of operator(), but to illustrate the usage:\n\nWhen the postfix increment or decrement operator appears in an expression, the corresponding user-defined function (operator++ or operator--) is called with an integer argument ​0​. Typically, it is declared as T operator++(int) or T operator--(int), where the argument is ignored. The postfix increment and decrement operators are usually implemented in terms of the prefix versions:\n\nAlthough the canonical implementations of the prefix increment and decrement operators return by reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for std::atomic return by value.\n\nBinary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if operator+ is a member function of the complex type, then only complex + integer would compile, and not integer + complex). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:\n\nStandard library algorithms such as std::sort and containers such as std::set expect operator< to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the Compare requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by std::tie:\n\nTypically, once operator< is provided, the other relational operators are implemented in terms of operator<.\n\nLikewise, the inequality operator is typically implemented in terms of operator==:\n\nWhen three-way comparison (such as std::memcmp or std::string::compare) is provided, all six two-way comparison operators may be expressed through that:\n\nUser-defined classes that provide array-like access that allows both reading and writing typically define two overloads for operator[]: const and non-const variants:\n\nIf the value type is known to be a scalar type, the const variant should return by value.\n\nWhere direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue c[i] = v; and rvalue v = c[i]; usage, operator[] may return a proxy. See for example std::bitset::operator[].\n\nUser-defined classes and enumerations that implement the requirements of BitmaskType are required to overload the bitwise arithmetic operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^=, and may optionally overload the shift operators operator<< operator>>, operator>>=, and operator<<=. The canonical implementations usually follow the pattern for binary arithmetic operators described above.\n\nThe following operators are rarely overloaded:\n• The address-of operator, . If the unary & is applied to an lvalue of incomplete type and the complete type declares an overloaded , it is unspecified whether the operator has the built-in meaning or the operator function is called. Because this operator may be overloaded, generic libraries use to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded is the Microsoft class . An example of this operator's use in EDSL can be found in boost.spirit.\n• The boolean logic operators, and . Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. Also unlike the built-in versions, they do not sequence their left operand before the right one. In the standard library, these operators are only overloaded for .\n• The comma operator, . Unlike the built-in version, the overloads do not sequence their left operand before the right one. Because this operator may be overloaded, generic libraries use expressions such as instead of to sequence execution of expressions of user-defined types. The boost library uses in boost.assign, boost.spirit, and other libraries. The database access library SOCI also overloads .\n• The member access through pointer to member . There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of a smart pointer interface, and in fact is used in that capacity by actors in boost.phoenix. It is more common in EDSLs such as cpp.react.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://mygreatlearning.com/blog/operator-overloading-in-cpp",
        "document": "Operator overloading in C++ is a powerful feature that allows you to redefine the behavior of operators for user-defined data types.\n\nIn this blog, we delve into the concept of Operator overloading in C++, accompanied by clear examples to illustrate its usage and benefits.\n\nWhether you’re new to programming or seeking to enhance your understanding of C++, this exploration will provide valuable insights into leveraging Operator overloading effectively in your code.\n\nBut before that, if you don’t know the difference between C and C++, check out our blog: “Differences and Similarities Between C & C++“.\n\nWhat is Operator overloading in C++?\n\nc++ operator overloading refers to the practice of redefining the functionality of operators for user-defined data types. \n\n\n\nThis feature, also known as “operator overriding in C++,” allows you to customize the behavior of operators such as +, -, *, and / to work with objects of your classes, enhancing the flexibility and expressiveness of your code.\n\nExplore the fundamentals of classes in C++.\n\nOperators in programming languages are symbols or keywords that perform specific operations on operands to produce results. \n\n\n\nThese operations can include arithmetic operations like addition and subtraction, comparison operations like equal to and not equal to, logical operations like AND and OR, and more. In essence, operators enable you to manipulate data and control the flow of your code.\n\nAlso, Explore beginner-friendly Simple C++ Programs to learn the C++ fundamentals.\n\nWhat are the types of operator overloading?\n\nThere are two types of operator overloading:\n\nThe process of having two or more functions with the same name but with different parameters (arguments) is called function overloading. The function is redefined by either using different types of arguments or a different number of arguments. It is only through these differences that a compiler can differentiate between functions.\n\nLearn more about function overloading in C++ with examples and discover practical examples to strengthen your concept of function overloading in C++!\n\nOperator overloading in C++ program can add special features to the functionality and behavior of already existing operators, such as athematics and other operations. \n\n\n\nThe mechanism of giving special meaning to an operator is known as operator overloading. For example, we can overload an operator ‘+’ in a class-like string to concatenate two strings by just using +.\n\nOperations that can be performed:\n\nExplore the core concepts of C programming with our free Introduction to C course.\n\nExample 1: Let us multiply two fractions using the overloading of the multiplication operator in C++.\n\nExplanation \n\nThis code demonstrates Operator overloading in C++ to multiply two fractions. The Frac class defines a fraction with numerator a and denominator b and overloads the * operator to perform the multiplication of fractions. \n\n\n\nWhen executed, the program prompts the user to input two fractions, multiplies them using the overloaded * operator, and prints the result. In the provided output, when the fractions 2/5 and 12/7 are multiplied, the result is correctly calculated as 24/35.\n\nExample 2: A C++ program to overload a prefix decrement operator\n\nExplanation \n\nThis code showcases the overloading of the prefix decrement operator in C++. The OverLoad class represents two integer variables, a and b, and overloads the — operator to decrement both. \n\n\n\nUpon execution, the program prompts the user to input two numbers, then decrements them using the overloaded — Operator and displays the decremented values. In the provided output, 56 and 234 are decremented to 55 and 223 respectively.\n\nExplanation \n\nThis code demonstrates the overloading of the NOT (!) Operator in C++. The NotOp class includes an integer variable, a, and a boolean variable, b. It overloads the! The Operator will perform logical negation on both variables. \n\n\n\nUpon execution, the program prompts the user to input a number and a boolean value, then applies the overloaded ! Operator and displays the negated values. In the provided output, the number is negated to 1 (if initially non-zero), and the boolean value is negated to 0.\n\nDon’t miss out on Our free Basics of C++ course – the perfect starting point for aspiring programmers!\n\nWhat are the rules for operator overloading in C++?\n\nIn C++, the rules of Operator overloading in c++ include:\n• Overloaded operators must have at least one operand that is a user-defined type.\n• Overloaded operators cannot change the precedence and associativity of operators.\n• Certain operators cannot be overloaded. (dot), .* (pointer to member), :: (scope resolution), ?: (ternary conditional), and sizeof.\n• The arity of the Operator cannot be changed; for instance, you cannot make + unary if it’s binary.\n• Some operators are not suitable for overloading. For example, &&, ||, ,, . (member selection), .* (member selection through a pointer), and:: (scope resolution).\n• The overloaded operators can be member functions or global functions.\n• Unary operators have one operand, binary operators have two, and ternary operators have three.\n\nWhich operators Cannot be overloaded?\n• Conditional [?:], size of, scope(::), Member selector(.), member pointer selector(.*) and the casting operators.\n• We can only overload the operators that exist and cannot create new operators or rename existing operators.\n• At least one of the operands in overloaded operators must be user-defined, which means we cannot overload the minus operator to work with one integer and one double. However, you could overload the minus operator to work with an integer and a mystring.\n• It is not possible to change the number of operands of an operator supports.\n• All operators keep their default precedence and associations (what they use for), which cannot be changed.\n• Only built-in operators can be overloaded.\n\nAdvantages of an operator overloading in C++\n• Simplified Syntax: Operator overloading allows programmers to use notation closer to the target domain, making code more intuitive and expressive.\n• Consistency: It provides similar support to built-in types for user-defined types, enhancing consistency and ease of use.\n• Easier Understanding: Operator overloading can make programs more accessible to understand by allowing the use of familiar operators with user-defined types, which can improve code readability and maintainability.\n\nDisadvantages of an operator overloading in C++\n• Potential Misuse: With great power comes great responsibility. Overloading operators can lead to abuse or misuse, resulting in difficult-to-understand or maintain code.\n• Complexity: Overuse or misuse of operator overloading can introduce complexity, especially when overloaded operators don’t behave as expected or when there’s ambiguity in their usage.\n• Limited Overloading: While many C++ operations can be overloaded, there are some exceptions, such as the member access operators (. and ->) and the scope resolution operator (::). This limitation can sometimes restrict the flexibility of operator overloading.\n\nWhat are Unary Operators and Binary Operator overloading?\n\nUnary operator overloading involves defining behaviors for operators that act on a single operand. For example, increment (++), decrement (—), logical NOT (!), and unary minus (–) are unary operators that can be overloaded in C++. This means you can redefine their behavior for your custom classes.\n\nExample: Let us try overloading the increment and decrement operators through a C++ program.\n\nExplanation\n\nThis code illustrates unary Operator overloading in C++. The UnaryOverload class represents time in hours and minutes. It overloads the unary increment (++) and decrement (–) operators to increment and decrement the time, respectively. \n\n\n\nUpon execution, the program prompts the user to input the time, then increments it and displays the result. Subsequently, it decrements the time twice and shows the final result. In the provided output, the time is incremented from 5hr 56min to 6hr 57min and then decremented to 4hr 55min as expected.\n\nBinary Operator overloading defines behaviors for operators that act on two operands. \n\n\n\nCommon binary operators include addition (+), subtraction (-), multiplication (*), division (/), and comparison operators like equal to (==) and less than (<). By overloading these operators, you can specify how they should operate on objects of your custom classes, allowing for intuitive and natural expressions in your code.\n\nAlso, learn how the Binary Search Algorithm can complement your understanding of binary operator overloading.\n\nExample: Let us see the following C++ code that elaborates the overloading of the addition operator.\n\nExplanation\n\nThis code demonstrates binary Operator overloading in C++. The Time class represents time in hours and minutes. The + Operator is overloaded to add two Time objects together. \n\n\n\nUpon execution, the program prompts the user to input two times, adds them using the overloaded + Operator, and displays the result. In the provided output, 11hrs 56min and 2hrs 10min are added together, resulting in 14hrs 6min.\n\nDiscover ‘C++ Projects To Work On‘ that will challenge and excite you as you hone your C++ proficiency.\n\nNow that you saw the overloading of unary and binary operators in C++ in the previous sections of this blog, you must know that not all operators can be overloaded. The operators that can be overloaded in C++ are known as overloadable operators. However, there are some non-overloadable operators as well that can’t be overloaded.\n\nThe list of non-overloadable operators goes as follows:\n\nThese operators cannot be overloaded because doing so will cause significant programming problems. As an illustration, the sizeof operator returns the operand, which is the size of the object or datatype. The compiler evaluates this. It cannot be assessed in real-time. We can’t thus overburden it.\n\nSome of the special operators in C++ are as follows:\n• new – It is used to allocate the memory dynamically.\n• Delete – It is used to free the memory dynamically.\n• = – It is used to assign the values.\n• () – It is used for function call.\n\nThe operators other than listed above can be overloaded either as a member or as non-members. But in general, non-member overloading is recommended. Because:\n• Symmetry: When a binary operator is defined as a class method, it must have objects as its operands. We should write like complex*5 but not like 5*complex because 5. operator*(complex)does not make any sense. In other words, a*b should be the same as b*a. Otherwise, it breaks the cumulativeness that the user is expecting from the *operator. So, in this case, we should use no-member operators overloading.\n• Weak coupling: since a non-member method cannot access private member, it tends to make the class less coupled\n\nExplanation \n\nIn this code, when we write ++count1, the void operator++() function is triggered. This function increments the value attribute of the count1 object by 1. Operator overloading allows us to redefine how operators behave. \n\n\n\nFor instance, we could have made ++ increase the value by 100, but clarity is crucial in coding. Consistently and using overloaded operators ensures easy comprehension. \n\n\n\nIn this example, ++ is overloaded as a prefix. The syntax void operator++() is used, with int inside parentheses to indicate it’s a unary operator. This clarifies the usage, avoiding confusion.\n\nExploring Operator overloading in C++ has provided valuable insights into enhancing code readability and flexibility. By allowing custom definitions for operators, developers can streamline coding processes and improve code maintainability. \n\n\n\nIf you want to master C++ programming and its advanced concepts like operator overloading, consider enrolling in Great Learning’s free C++ course. Designed to equip learners with essential coding skills, this course lays a solid foundation for pursuing a career in software engineering. \n\n\n\nAdditionally, our Software Engineering Courses offer comprehensive training in software development methodologies, project management, and industry best practices, paving the way for a rewarding future in the tech industry.\n\nLearning never stops, and neither should you! Unlock more learning opportunities with our free online courses designed to help learners enhance their knowledge for free."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-overload-operator-in-cpp",
        "document": "A class in C++ is the building block that leads to Object-Oriented programming. Class is a user-defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class.\n\nThe overloading of operators is a polymorphism that occurs at compile-time. A special meaning can be given to an existing operator in C++ without changing its meaning.\n\nExcept for a few that cannot be overloaded, almost all operators can be overloaded. These operators are as follows:\n\n== is a comparison operator that returns a true or false Boolean value. It checks if the two operands on the operator’s left and right sides are equal.\n\nConsider a class Car having the following data members:\n\nIn this class, we can use the == operator to determine whether the two worker’s objects are equivalent."
    }
]