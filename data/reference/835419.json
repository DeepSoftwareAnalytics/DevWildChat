[
    {
        "link": "https://arduino.cc/en/reference/servo",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/learn/electronics/servo-motors",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Tutorial/Sweep",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Tutorial/Knob",
        "document": ""
    },
    {
        "link": "https://howtomechatronics.com/how-it-works/how-servo-motors-work-how-to-control-servos-using-arduino",
        "document": "In this tutorial we will learn how servo motors work and how to control servo motors with Arduino. Servo motors are very popular and widely used in many Arduino projects because they are easy to use and provide great position control.\n\nServos are great choice for robotics projects, automation, RC models and so on. I have already used them in many of my Arduino projects and you can check out some of them here:\n• SCARA Robot | How To Build Your Own Arduino Based Robot\n\nYou can watch the following video or read the written tutorial below. It includes several examples how to use a servo motor with Arduino, wiring diagram and codes. In additional, it has a guide how to control multiple servo motors with Arduino using the PCA9685 PWM driver.\n\nA servo motor is a closed-loop system that uses position feedback to control its motion and final position. There are many types of servo motors and their main feature is the ability to precisely control the position of their shaft.\n\nIn industrial type servo motors the position feedback sensor is usually a high precision encoder, while in the smaller RC or hobby servos the position sensor is usually a simple potentiometer. The actual position captured by these devices is fed back to the error detector where it is compared to the target position. Then according to the error the controller corrects the actual position of the motor to match with the target position.\n\nIn this tutorial we will take a detailed look at the hobby servo motors. We will explain how these servos work and how to control them using Arduino.\n\nHobby servos are small in size actuators used for controlling RC toys cars, boats, airplanes etc. They are also used by engineering students for prototyping in robotics, creating robotic arms, biologically inspired robots, humanoid robots and so on.\n\nThere are four main components inside of a hobby servo, a DC motor, a gearbox, a potentiometer and a control circuit. The DC motor is high speed and low torque but the gearbox reduces the speed to around 60 RPM and at the same time increases the torque.\n\nThe potentiometer is attached on the final gear or the output shaft, so as the motor rotates the potentiometer rotates as well, thus producing a voltage that is related to the absolute angle of the output shaft. In the control circuit, this potentiometer voltage is compared to the voltage coming from the signal line. If needed, the controller activates an integrated H-Bridge which enables the motor to rotate in either direction until the two signals reach a difference of zero.\n\nA servo motor is controlled by sending a series of pulses through the signal line. The frequency of the control signal should be 50Hz or a pulse should occur every 20ms. The width of pulse determines angular position of the servo and these type of servos can usually rotate 180 degrees (they have a physical limits of travel).\n\nGenerally pulses with 1ms duration correspond to 0 degrees position, 1.5ms duration to 90 degrees and 2ms to 180 degrees. Though the minimum and maximum duration of the pulses can sometimes vary with different brands and they can be 0.5ms for 0 degrees and 2.5ms for 180 degrees position.\n\nRead More: Stepper Motors and Arduino – The Ultimate Guide\n\nThere are many different models and manufacturers of RC or hobby. The main consideration when choosing a servo motor is its torque, operating voltage, current draw and size.\n\nHere are the two most popular servo models among makers, the SG90 Micro Servo and the MG996R.\n\nLet’s put the above said to test and make a practical example of controlling a hobby servo using Arduino. I will use the MG996R which is a high-torque servo featuring metal gearing with stall torque of 10 kg-cm. The high torque comes at a price and that’s the stall current of the servo which is 2.5A. The running current is from 500mA to 900mA and the operating voltage is from 4.8 to 7.2V.\n\nThe current ratings indicate that we cannot directly connect this servo to the Arduino, but we must use a separate power supply for it.\n\nHere’s the circuit diagram for this example.\n\nWe simply need to connect the control pin of the servo to any digital pin of the Arduino board, connect the Ground and the positive wires to the external 5V power supply, and also connect the Arduino ground to the servo ground.\n\nIn case we use a smaller hobby servo, the S90 Micro Servo, it’s possible to power it directly from the 5V Arduino pin.\n\nThe S90 Micro Servo has lower current consumption, around 100-200mA no-load running current, but around 500-700mA stall current. On the other hand, the Arduino 5V pin can output only around 500mA if powered via USB, or up to 1A in powered via the barrel connector.\n\nEven though it’s possible to run these 9g servo motors directly to Arduino, for more stable work I would suggest to always use an external power supply for them.\n\nYou can get the components needed for this example from the links below:\n\nDisclosure: These are affiliate links. As an Amazon Associate I earn from qualifying purchases.\n\nNow let’s take a look at the Arduino code for controlling the servo motor. The code is very simple. We just need to define the pin to which the servo is connect, define that pin as an output, and in the loop section generate pulses with the specific duration and frequency as we explained earlier.\n\nAfter some testing I came up with the following values for the duration of the pulses that work with my servo. Pulses with 0.6ms duration corresponded to 0 degrees position, 1.45ms to 90 degrees and 2.3ms to 180 degrees.\n\nI connected a multimeter in series with the servo to check the current draw. The maximum current draw that I noticed was up to 0.63A at stall. Well that’s because this isn’t the original TowerPro MG996R servo, but a cheaper replica, which obviously has worse performance.\n\nNevertheless, let’s take a look at a more convenient way of controlling servos using Arduino. That’s using the Arduino servo library.\n\nHere we just need to include the library, define the servo object, and using the attach() function define the pin to which the servo is connected as well as define the minimum and maximum values of the pulses durations. Then using the write() function we simply set the position of the servo from 0 to 180 degrees.\n\nThe Arduino servo library supports controlling of up to 12 servos at the same time with most the Arduino boards, and 48 servos using the Arduino Mega board. On top of that, controlling multiple servo motors with Arduino is as easy as controlling just a single one.\n\nHere’s an example code for controlling multiple servos:\n\nSo, we just have to create objects from the Servo class for each servo motor, and define to which Arduino pin is connected. Of course, we can set any servo to move to any position, at any time.\n\nAs an example you can also check my Arduino Ant Hexapod Robot project where I used an Arduino MEGA board to control 22 servo motors.\n\nThere’s also another way of controlling servos with Arduino, and that’s using the PCA9685 servo driver. This is a 16-Channel 12-bit PWM and servo driver which communicates with Arduino using the I2C bus. It has a built in clock so it can drive 16 servos free running, or independently of Arduino.\n\nWhat’s even cooler we can daisy-chain up to 62 of these drivers on a single I2C bus. So theoretically we can control up to 992 servos using only the two I2C pins from the Arduino board. The 6 address select pins are used for setting different I2C addressed for each additional driver. We just need to connect the solder pads according to this table.\n\nHere’s the circuit schematic and we can once again notice that we need a separate power supply for the servos.\n\nYou can get the components needed for this example from the links below:\n\nDisclosure: These are affiliate links. As an Amazon Associate I earn from qualifying purchases.\n\nNow let’s take a look at the Arduino code. For controlling this servo driver we will use the PCA9685 library which can be downloaded from GitHub.\n\nSo first we need to include the libraries and define the PCA9685 object. Then using the Servo_Evaluator instance define the pulses duration or the PWM output of the driver. Note that the outputs are 12-bit, or that’s a resolution of 4096 steps. So the minimum pulse duration of 0.5ms or 0 degrees position would correspond to 102 steps, and the maximum pulse duration of 2.5ms or 180 degrees position to 512 steps. But as explained earlier these values should be adjusted according your servo motor. I had value from 102 to 470 which corresponded to 0 to 180 degrees position.\n\nIn the setup section we need to define the I2C clock rate, set the driver address and set the frequency to 50Hz.\n\nIn the loop section, using the setChannelPWM() and pwmForAngle() functions we simply set the servo to the desired angle.\n\nI connected a second servo to the driver, and as I expected, it wasn’t positioning the same as the first one, and that’s because the servos that I’m using are cheap copies and they are not so reliable. However, this isn’t a big problem because using the Servo_Evaluator instance we can set different output settings for each servo. We can also adjust the 90 degrees position in case it’s not precisely in the middle. In that way all servos will work the same and position at the exact angle.\n\nControlling a lot of servos with Arduino and the PCA9685 drivers\n\nWe will take a look at one more example and that’s controlling a lot of servos with multiple chained PCA9685 drivers.\n\nFor that purpose we need to connect the drivers to each other and connect the appropriate address select solder pads. Here’s the circuit schematic:\n\nLet’s take a look at the Arduino code now.\n\nSo we should create separate PCA9685 object for each driver, define the addresses for each driver as well as set the frequency to 50Hz. Now simply using the setChannelPWM() and pwmForAngle() functions we can set any servo at any driver to position any angle we want.\n\nThis is a common problem with these hobby servo motors, the SG90 Micro Servo and the MG996R. The reason for this is that, as mentioned earlier, they can draw quite significant amount of current when they are at load. This can cause the Arduino board to reset, especially if you are powering the servo directly from the Arduino 5V pin.\n\nIn order to solve this issue you can use a capacitor across the GND and the 5V pin. It will act as a decouple capacitor which will provide additional current to the system at start up when the DC motor starts.\n\nThis is another common problem with these hobby servos. As we explained earlier, a pulse width of 1ms (0.5ms) corresponds to 0 degrees position, and 2ms (2.5ms) to 180 degrees. However, these values can vary from servo to servo and between different manufacturers.\n\nIn order to solve this problem, we need to adjust the pulse width we are sending to the servo motor with the Arduino. Luckily, using the Arduino Servo library we can easily adjust the pulse widths values in the attach() function.\n\nThe attach() function can take two additional parameters, and that’s the minimum and maximum pulse width in microseconds. The default values are 544 microseconds (0.544milliseconds) for minimum (0 degrees) angle, and 2400 microseconds (2.4ms). So by adjusting these values we can fine tune the moment range of the servo.\n\nI made 3D models of the two most popular servo motors, the SG90 Micro Servo and the MG996R servo motor. You can download load them from the links below.\n\nSo, we have covered almost everything we need to know about using servo motors with Arduino. Of course, there are some many manufacturers and models of these type of hobby or RC servo motors, and each of them has its own unique features that might differ from what we explained above.\n\nThe possibilities for creating awesome robotics, automation and RC projects using motors are endless, however choosing the right model for your application is very important.\n\nI hope you enjoyed this tutorial and learned something new. Feel free to ask any question in the comments section below, as well as make sure you can my Arduino Projects Collection."
    },
    {
        "link": "https://forum.arduino.cc/t/robot-drawing-with-two-servos-calculating-x-y-to-angles/232169",
        "document": "So we're in the early stages of building this robot-drawer thing. We have a MAX patch that's doing some face-tracking and we are getting a single pair of X,Y coords out of it. We want to convert this to usable data for a servo-drawing apparatus. The challenge is that we need to get this into circular motion somehow. Here are some pictures attached.\n\nThe paper shows two arms, the bottom and middle circles are servos. We need to angle the \"shoulder\" servo, then angle the \"elbow\" servo.\n\nWe got this from a robotics website but can't make much sense of it:\n\nOur design is kind of similar to this: http://www.blogcdn.com/www.engadget.com/media/2012/03/doodle-clock.jpg in that it has a shoulder and elbow motor."
    },
    {
        "link": "https://medium.com/@pacogarcia3/converting-y-z-coordinates-into-angles-for-a-two-axis-robot-arm-from-fdxlabs-d480b01fc9a4",
        "document": "[I published this in April 11, 2019 in m y personal blog fdxlabs, which I’m shutting down, posting here for readers to leverage]\n\nI aimed to built the simplest robot that could prove to be useful in light use cases and my design has two rotating axis that control the Y and Z position, and a linear axis that controls the X position.\n\nFor movements, in it’s crudest form the robot arm requires 2 angle inputs (for the servo motors) and number of steps and direction. The X-axis motion is extremely straightforward and can be easily be identified by reading the code, so I won’t cover it in this blog. I will focus on the Y, Z motion.\n\nIt is very counter-intuitive to provide angles as inputs and it makes it extremely hard to control the robot. The goals is to provide the robot with a set of coordinates, like Y=5 and Z=-6 and have the program itself figure out the position required by the servos. In the industry this is commonly known as Inverse Kinematics, and the case I’ll describe here, is probably one of the simplest one can find.\n\nYou can dive right into the Arduino sketch code in my Github repository.\n\nYou can read through my Medium post on the overview of the robot and watch the video of it in operation in Youtube.\n\nAs a reminder, this is the setup of this robot:\n\nTo adequately understand the progression I will go through, it is important to understand th frames of reference of each component. In this blog, we are going to focus solely on the Robot Arm:\n\nFor illustration purposes, this is how I will reference the arm in the lines and dots of the rightmost illustration. Our main focus is P1 (point 1) and Tp (Target Point), and we will ignore G, which is the added Z dimension by the Gripper, which is a constant and very easy to add.\n\nThe first step, is mapping out in the coordinate system the two points of interest. P1 is at the base of the robot and it is in the axis of the upper arm (in orange). Tp is our Target Point (where we want the arm to move) and we are looking to be able to provide Ym and Zm to the robot so it automatically figures out the servo angles:\n\nThe second step, is realizing that initially we don’t care about the arms, we care about finding H, or the straight-line between P1 and Tp. You can see how we have now converted the problem into a triangle:\n\nOn the third step, we now get both arms back in the picture, which have length L (they are both the same length in this robot). Using trigonometry, we can figure out s1 and s2, which in turn, enables us to figure out angles alpha and beta.\n\nStep four: we now know the angle for servo 1! To figure out the angle for servo 2, we need to identify P3 (point 3).\n\nIn step five, we place the top arm right on the Z axis (bubble 1) and by performing a rotation by alpha+beta (bubble 3), we get the coordinates of P3. We now have P3 and our original target coordiantes Ym,Zm, and we can calculate the angle for Servo 2!\n\nNote: This is a very simple explanation of how to calculate the arm servos, and they work really work in the range of 0 to 90 degrees. For solutions that require solving beyond this range of angles, several adjustments have to be made to account for the changes in trigonometry.\n\nYou can dive right into the Arduino sketch code in my Github repository.\n\nThe key function I use to perform this calculation is here, and you can see the logic I apply when the servo 2 angle exceeds 90 degrees, to correct for the change in the tangent calculation.\n\nAfter the above steps, now you can input coordinates and your robot will reach the destination reliable, but you will quickly identify the opportunity.\n\nEach of the servos in the arm, will have different target angles and they will reach their targets at different times, which makes the robot movement very unpredictable (see illustration below). In the scenario that Servo 1 has to move 50 degrees, while Servo 2 has to move 20 degrees, if both are moving independently (one first another second) or they move at the same speed, the trajectory will be problematic and erratic.\n\nThis is a very well known problem in Robotics and it gets complex extremely fast (and with multiple axis and complex trajectories, it can be computational intensive).\n\nA simple solution I came up with, was to coordinate the speed of the servos sot that they both reach their target angles at the same time. Below is the function I use and it is in operation in the video of my robot, so I can say it does give very good results and smooths out the trajectory.\n\nThere is an additional higher level motion, that does have the ability to perform Y first then Z and vice-verse and those still leverage this underlying servo coordination function.\n\nvoid twoarm_step_coordinate(double toparm_target, double middlearm_target) {\n\n//Serial.println(\"--> two arm step Start /\");\n\n double incr_steps0=1;\n\n double incr_steps1= 1;\n\n int inner_step_delay0 = 0;\n\n int inner_step_delay1 = 0;\n\n int outer_step_delay = 30;\n\n double i, j;\n\n int e0 = 0;\n\n int e1 = 0;\n\n //Reference to function: servo_steps(int servo_num, int angle_target, int incr_step=10, int step_delay=50)\n\n //identify which of the arms has a greater delta in terms of degress to move\n\n double delta0 = abs(angle_current[0] - toparm_target);\n\n double delta1 = abs(angle_current[1] - middlearm_target);\n\n //coordinate the speed of the two access through the incremental steps, so they can move smoothly in the x/y plane\n\n // (this avoids one arm finishing its movements first, and generating huge variagtionsin the real x/y position of the endpoint)\n\n if (delta0!=0 && delta1!=0) {\n\n if (delta0 >= delta1) {\n\n incr_steps0 = (delta0 / delta1)*incr_steps1;\n\n //slow down motion as steps increase (just in case big jump in steps)\n\n inner_step_delay0=(delta0/delta1)*0.5;\n\n //reduce the outer step\n\n outer_step_delay=outer_step_delay-inner_step_delay0;\n\n } else {\n\n incr_steps1 = (delta1 / delta0)*incr_steps0;\n\n //slow down motion as steps increase (just in case big jump in steps)\n\n inner_step_delay1=(delta1/delta0)*0.5;\n\n //reduce the outer step\n\n outer_step_delay=outer_step_delay-inner_step_delay1;\n\n }\n\n }\n\n //set to zero if negative value on outer delay\n\n if (outer_step_delay<0) {\n\n outer_step_delay=0;\n\n }\n\n \n\n //identify the direction of steps\n\n if (angle_current[0] > toparm_target) {\n\n i = -incr_steps0;\n\n } else {\n\n i = incr_steps0;\n\n }\n\n if (angle_current[1] > middlearm_target) {\n\n j = -incr_steps1;\n\n } else {\n\n j = incr_steps1;\n\n }\n\n \n\n // user the servo step functions, doing inter-twined steps until the gaps are reached.\n\n // we send a delay of 0 to the servo step function, given we'll control the delay in this outer loop.\n\n while (1) {\n\n // top arm moves\n\n if (abs(angle_current[0] - toparm_target) > incr_steps0) {\n\n servo_steps(0, angle_current[0] + i, incr_steps0, inner_step_delay0);\n\n } else {\n\n servo_steps(0, toparm_target, incr_steps0, inner_step_delay0);\n\n e0 = 1;\n\n }\n\n // middle arm moves\n\n if (abs(angle_current[1] - middlearm_target) > incr_steps1) {\n\n servo_steps(1, angle_current[1] + j, incr_steps1, inner_step_delay1);\n\n } else {\n\n servo_steps(1, middlearm_target, incr_steps1, inner_step_delay1);\n\n e1 = 1;\n\n }\n\n delay(outer_step_delay);\n\n if ((e0 + e1) >= 2) break;\n\n }\n\n //Serial.println(\"--> two arm step End /\");\n\n}"
    },
    {
        "link": "https://forum.arduino.cc/t/3d-robot-arm-with-arduino/405125",
        "document": "Hi, please check the image below. I want to build this robot arm using arduino and I know there ARE THOUSAND projects online about this. BUT NONE, REALLY NONE, talk about how to keep the last bar horizontal without using a servo at that very last bar cause almost all robot arm does not use a servo to keep the last bar horizontal! You see in the image I attached that the green and blue bars are gonna be controlled using 2 servos, spinning the bars in precise angles. My problem is this: what kind of mechanism or bar linkage can I use in order to always keep the last bar (red) horizontal so my pencil will always get vertical? I know I could use a servo in this very last bar (red) and spin it in order to keep the red bar horizontal BUT I saw many 3D robot arm in the internet that uses some kind of mechanism to keep the last bar always horizontal, no matter the angle of the other 2 bars. You can see the last bar is always horizontal and those projects are not using a servo to keep it horizontal. What type of mechanism or bar size of relation or bar linkage rule that I need to follow in order to my keep my last bar horizontal?\n\nWhy don't you build a linkage like in one of the two pictures you have posted? The important feature is that 2 points on the arm you want to stay horizontal should be fixed to two points on the base. Then the arm will always stay in the same orientation relative to the base. Get some pieces of Lego and experiment.\n\nI just cant copy those projects cause I dont know the bars size and if I want to scale it I have no idea if it will work I think this approach (makearm) is WAAAAAY better than most \"3d robot arm\" projects around cause it has veeery feew linkages and it's so simple to build and the pencil will always be vertical, without any mechanism. Does any of you know any disadvantagem of makearm related to the common 3d robot arm approach (which I provided pictures in the first post)?\n\nStudy the pictures that you yourself have provided and figure out how they work. Then make your own example using the same principles. If you study the photos you will see that there is a piece at the top hinge point that also retains its orientation as the arms move. And it transfers that fixed orientation to the bar at the end. Like I said earlier if you have Lego you can easily experiment. Or you could make bars from cardboard with thumbtacks for joints.\n\n@Robin2 if would nicer if you said \"I have no idea how to help, maybe you should wait if another humble person can help you\". Instead of saying \"you lost your time coming here making this question, go f*** yourself and try to get the answer by yourself cause nobody here knows how to help you\". If I go to a forum make a question I hope I can have some help instead of stupid person coming here saying \"check your own pictures and find yourself the answer you are looking for\". If you had spent a few minutes trying to understand what I said you will see that even a difference of few millimeters in bars sizes will not work so trial and error is a stupid approach.\n\nbatata004:\n\n @Robin2 if would nicer if you said \"I have no idea how to help, maybe you should wait if another humble person can help you\". Instead of saying \"you lost your time coming here making this question, go f*** yourself and try to get the answer by yourself cause nobody here knows how to help you\". I take great exception to that. I said nothing of the sort. I have never said anything like that to any person on the Fourm. All of my Posts were sincere attempts to help. I am reporting your abusive comment to the Moderator."
    },
    {
        "link": "https://forum.arduino.cc/t/robotic-arm-need-help-with-servo-movement/253413",
        "document": "HEY!!! Don't bother printing this, it wobbles too much! Print Lite Arm i2 instead it is more stable and requires less specialized components:http://www.thingiverse.com/thing:480446 -Armatec Update 08/14/2014 I will be uploading all add-on parts..."
    },
    {
        "link": "https://stackoverflow.com/questions/37007417/inverse-kinematics-how-to-calculate-angles-for-servos-of-a-robotic-arm-to-reach",
        "document": "I have a robotic arm composed of 2 servo motors. I am trying to calculate inverse kinematics such that the arm is positioned in the middle of a canvas and can move to all possible points in both directions (left and right). This is an image of the system Image. The first servo moves 0-180 (Anti-clockwise). The second servo moves 0-180 (clockwise).\n\nHere is my code:\n\nInitially, when the system is first started, the arm is straightened with shoulder=90, elbow =0. When I give positive x values I get correct results in the left side of the canvas. However, I want the arm to move in the right side as well. I do not get correct values when I enter negatives. What am I doing wrong? Do I need an extra servo to reach points in the right side?\n\nSorry if the explanation is not good. English is not my first language."
    }
]