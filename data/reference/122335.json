[
    {
        "link": "https://react.dev/reference/react/useRef",
        "document": "Do not write or read during rendering. React expects that the body of your component behaves like a pure function:\n• If the inputs (props, state, and context) are the same, it should return exactly the same JSX.\n• Calling it in a different order or with different arguments should not affect the results of other calls. Reading or writing a ref during rendering breaks these expectations. You can read or write refs from event handlers or effects instead. If you have to read or write something during rendering, use state instead. When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more about keeping your components pure. It’s particularly common to use a ref to manipulate the DOM. React has built-in support for this. First, declare a ref object with an initial value of : Then pass your ref object as the attribute to the JSX of the DOM node you want to manipulate: After React creates the DOM node and puts it on the screen, React will set the property of your ref object to that DOM node. Now you can access the ’s DOM node and call methods like : React will set the property back to when the node is removed from the screen. Read more about manipulating the DOM with refs.\n\nReact saves the initial ref value once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects. To solve it, you may initialize the ref like this instead: Normally, writing or reading during render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable. How to avoid null checks when initializing useRef later If you use a type checker and don’t want to always check for , you can try a pattern like this instead: Here, the itself is nullable. However, you should be able to convince your type checker that there is no case in which returns . Then use in your event handlers. If you try to pass a to your own component like this: You might get an error in the console: By default, your own components don’t expose refs to the DOM nodes inside them. To fix this, find the component that you want to get a ref to: And then add to the list of props your component accepts and pass as a prop to the relevent child built-in component like this: Then the parent component can get a ref to it. Read more about accessing another component’s DOM nodes."
    },
    {
        "link": "https://hygraph.com/blog/react-useref-a-complete-guide",
        "document": "The Hook is a versatile tool, often overlooked but crucial for managing references, optimizing performance, and interacting directly with the Document Object Model (DOM). While it might not be as widely discussed as useState or useEffect, it plays a pivotal role in many React applications.\n\nThis guide will discuss the Hook, its use cases, practical applications, and drawbacks. By the end, you'll be well equipped to leverage its full potential, unlocking new levels of efficiency and control in your React projects.\n\nThe Hook is a built-in React feature that persists values between component re-renders. Unlike state variables managed by , values stored in a ref object remain unchanged across renders, making it ideal for scenarios where data doesn't directly affect the UI but is essential for the component's behavior.\n\nWhen React encounters a Hook, it returns a plain JavaScript object with a single property: . This property stores mutable values, which can be of any type, from simple values like numbers and strings to complex objects, functions, or even references to DOM elements.\n\nReact assigns the initial value you define to the property of the returned reference. React will set the value of the useRef to if you don't provide an initial value. Importantly, you can update this value directly without triggering a re-render of the component. This can be seen in the snippet below:\n\nAlso, the returned reference object is mutable. You can update the value directly, as shown in the snippet below.\n\nClicking the “Update” button changes the value from to and the other way around.\n\nBeyond its ability to persist values, the Hook has several vital roles in React applications:\n\nImagine a login page where users need to enter their username and password. To enhance the user experience, you can automatically direct their focus to the username field as soon as the page loads.\n\nTo achieve this, use the 's capacity to access rendered DOM elements. This feature returns the referenced DOM element and its properties, providing room for direct manipulations.\n\nThe above snippet shows a component that renders a form with an input field for the user’s username. Also, it defines a username reference with the Hook, which the method is called on. This is executed inside a Hook, so it runs immediately after the UI finishes loading.\n\nBy storing the previous value of the input element as a state variable in a ref, you can monitor changes and address them accordingly. This technique is useful for implementing \"undo\" functionality, creating custom Hooks that need to compare previous and current values, or optimizing performance by preventing unnecessary calculations.\n\nIn this example, the Hook stores the previous value of the state variable. Every time the changes, the Hook compares the new to the value stored in the and logs a message to the console if they differ. This way, you can track how the value evolves over time.\n\nThe simplifies the management of timers and intervals within your components. You can store the timer's ID in a ref, allowing you to start, stop, or reset it as needed without triggering unnecessary re-renders.\n\nIn this example, a timer component was created using the and Hooks. The Hook manages the seconds variable, which keeps track of the elapsed time. Meanwhile, stores a reference to the interval ID (timerRef), which is responsible for updating the seconds every 1000 milliseconds (1 second).\n\nThe functions , , and control the timer's behavior. starts the interval, stops it, and resets the elapsed time to zero.\n\nWhen creating custom Hooks that need to maintain an internal state between renders, becomes an invaluable asset. It enables you to store and update data privately within the Hook, promoting reusability and encapsulation of complex logic.\n\nImagine having multiple components that are required to maintain their previous state. It will appear too tedious to write this logic individually for every component. To avoid this, create a custom Hook using the Hook as follows:\n\nFirst, create a Hooks folder and a file , then add the following snippet:\n\nIn the snippet above, a instance was created, then on every page re-render, assign the value passed to the Hook to the . Finally, return the value of the .\n\nTo illustrate the custom Hook's utility, let’s revisit the 'tracking previous values' scenario\n\nIn the snippet above, all instances of the initial were replaced with the newly created custom Hook. This shows that creating a custom Hook makes it possible to reuse complex logic.\n\nBeyond its DOM manipulation capabilities, useRef shines as a performance enhancer. Imagine you have a computationally intensive task within your component, such as filtering a dataset or performing calculations, re-executing these operations on every render would be wasteful.\n\nStoring values of these calculations within a ref variable using useRef can avoid unnecessary re-computations. Since refs persist across renders without triggering updates, the calculated value remains accessible and doesn't need to be recalculated unless the underlying data changes. Let's look at the example shown below:\n\nIn the snippet above, the Hook, named , is employed to optimize performance by caching the results of a computationally expensive calculation like the Fibonacci sequence. The property stores both the input number and the calculated result, allowing for comparison on subsequent renders.\n\nThe useMemo Hook is used to memoize the calculation. It checks if the input number ( ) has changed since the last render. If not, it returns the cached result from , avoiding redundant computation. If the input number changes, the Fibonacci calculation is performed, and the result is stored in for future reuse.\n\nThis memoization strategy improves the component's performance by preventing recalculations whenever the component re-renders due to unrelated state changes. While offers performance benefits, knowing its potential drawbacks is essential.\n• Manual management: Unlike state variables managed with or , changes to the property of a ref attribute do not automatically trigger re-renders of your component. This means you need to manage updates and trigger re-renders manually when necessary and can add extra complexity to your code.\n• Potential memory leaks: If you're not careful, you can create dangling refs. This happens when a ref is still holding onto a reference to a DOM element or other object that has already been unmounted or removed from the DOM, leading to memory leaks.\n• Overuse: While refs are helpful in certain scenarios, overusing them can lead to a more complex and less maintainable codebase.\n• Debugging challenges: Since changes to refs don't trigger re-renders, debugging issues related to refs can sometimes be more complicated than debugging state-related problems.\n• Not suitable for array or object updates: Although you can store arrays or objects in a ref, updating individual properties or elements within them won't trigger re-renders. You'll need to manually update the entire array or object and trigger a re-render if you want those changes to be reflected in the UI. This can require more work than using state for mutable value structures.\n• Use the when necessary and prioritize managing UI-related data with state ( or ) as it automatically triggers re-renders.\n• Always ensure proper cleanup of refs when components are removed from the DOM to prevent memory leaks.\n• Leverage debugging tools like React DevTools to track ref values and their impact if your code becomes overly reliant on refs.\n• Consider alternative approaches like lifting the state up or using context to streamline state management and component communication.\n\nWhile both and useState store values in React components, they serve different purposes and behave differently. Let's look at these Hooks, exploring their characteristics and how they contribute to state management in a React component.\n\nBefore the Hooks era, React used createRef() for refs in their application. Let's break down their key distinctions when it comes to managing refs in React applications:\n\nIf you're using functional components with React Hooks, is the way to go. But if you're working with legacy class components, is your best option.\n\nHowever, consider refactoring to functional components and the Hook for a more modern and maintainable approach. Next, let's discuss the Hook in data fetched from content management systems.\n\nThe Hook, although not inherently tied to Content Management Systems (CMS), plays a crucial role in enhancing user interactions with dynamically fetched content from platforms like Hygraph, a GraphQL-Native Headless Content Management, and Federation System.\n\nBy storing references to specific elements within the fetched data, such as images or content blocks, developers can implement features like lazy loading, smooth scrolling, or interactive components.\n\nFurthermore, is valuable in optimizing data fetching from CMSs by caching results, especially for complex queries or large datasets. This caching mechanism reduces the load on the CMS and improves the application's performance as it avoids redundant data fetching operations.\n\nWhile often overlooked, the Hook is a powerful asset in a React developer's toolkit. It excels in managing references, optimizing performance, and enabling seamless interactions with DOM elements.\n\nUnderstanding its capabilities and appropriate use cases allows developers to create more efficient, maintainable, and interactive React applications. Whether you're building complex animations, managing timers, or integrating with headless CMS platforms like Hygraph to optimize content delivery, proves its value repeatedly.\n\nReady to explore the power of Hygraph? Sign up for a free-forever developer account and experience the seamless integration of Hygraph with React and its powerful Hook like ."
    },
    {
        "link": "https://dev.to/samabaasi/mastering-reacts-useref-hook-a-deep-dive-1548",
        "document": "React's hook is a powerful and versatile tool that allows you to interact with the DOM, manage state, and optimize performance without causing unnecessary re-renders. In this comprehensive guide, we'll take a deep dive into how works under the hood, why it doesn't trigger re-renders, and how you can harness its full potential.\n\nReact's functional components have revolutionized the way we build user interfaces. With the introduction of hooks, managing state and side effects has become more straightforward. Among these hooks, stands out for its unique capabilities.\n\nuseRef is a hook in React that allows you to create a mutable reference to a DOM element or any other value that persists across renders. While it's often used to access and manipulate DOM elements directly, it's also a handy tool for storing values that should not trigger re-renders when they change.\n\nWhy is it useful?\n\nHere are some common scenarios where useRef shines:\n• Accessing and Manipulating DOM Elements: With , you can easily access DOM elements and interact with them directly. This is useful for tasks like focusing an input field, scrolling to a specific element, or animating elements.\n• Storing Mutable Values Without Re-renders: Unlike state variables, changes to a object's property do not trigger re-renders. This makes it an excellent choice for storing values that don't impact your component's UI.\n• Optimizing Performance: is a valuable tool for optimizing performance. You can use it to memoize expensive calculations, ensuring they are only recomputed when necessary.\n\nNow, let's delve into the inner workings of and understand why it doesn't cause re-renders.\n\nTo grasp why doesn't trigger re-renders, it's essential to understand closures in JavaScript.\n\nA closure is a fundamental concept in JavaScript where a function \"remembers\" its lexical scope, even when it's executed outside that scope. Closures enable functions to access variables from their containing function, even after the containing function has finished executing.\n\nIn this example, has access to the variable, thanks to closures. This property of closures is crucial in understanding how retains values across renders.\n\nReact's leverages closures to maintain the reference to its property across renders. This means that even when a component re-renders, the object remains the same, and changes to its property don't trigger re-renders.\n\nIn other words, creates a closure that captures its property, ensuring it persists between renders. This is why modifying 's property does not cause your component to re-render.\n\nNow that we understand closures, let's look at a simplified representation of how might be implemented in vanilla JavaScript.\n• None We define a function that takes an as an argument.\n• None Inside the function, we create an object called with a property, which is initialized to the .\n• None Finally, we return the , which can be used to access and update the property.\n\nThis is a basic representation of how could be implemented in plain JavaScript. However, in React, is more powerful and versatile because it's integrated with React's rendering and lifecycle system.\n\nReact's rendering mechanism relies on immutability. When React detects changes in the state or props of a component, it re-renders that component. However, the object's property can be updated without causing React to re-render.\n\nIn this example, when the button is clicked, we modify the of the element. This change doesn't cause the component to re-render because the object itself remains the same.\n\nThis behavior aligns with React's philosophy of immutability. React identifies changes by comparing new and previous values. Since the object's identity (i.e., the reference itself) doesn't change when we update its property, React does not consider it a state or prop change that would trigger a re-render.\n\nTo further understand why doesn't trigger re-renders, it's essential to explore React's process of identity and reconciliation.\n\nReact's core algorithm, called reconciliation, is responsible for determining when and how to update the DOM to match the new virtual DOM (vDOM) representation.\n• None Virtual DOM: React maintains a virtual representation of the actual DOM, known as the virtual DOM (vDOM). When a component's state or props change, React generates a new vDOM tree.\n• None Reconciliation: React compares the new vDOM tree with the previous one to determine the differences (or \"diffs\") between them. This process is called reconciliation.\n• None Minimizing Updates: React's goal is to minimize the number of updates to the actual DOM. It identifies which parts of the vDOM have changed and calculates the most efficient way to update the DOM to reflect those changes.\n• None Component Identity: To determine whether a component should be updated, React checks if its identity has changed. Identity here means the reference to the component or element, which is determined by variables or functions used in the component tree.\n\nThe critical point to note is that objects, including their property, retain their identity across renders. When a component re-renders, React ensures that the object remains the same as it was in the previous render.\n\nIn the example above, when the button is clicked and the of is modified, the object itself remains unchanged. React recognizes that the identity of the object hasn't changed and, therefore, does not trigger a re-render.\n\nThis behavior aligns with React's goal of minimizing updates to the actual DOM by identifying components that have truly changed.\n\nReact goes to great lengths to ensure that the object's property remains consistent across renders. Let's explore some examples to illustrate this consistency.\n\nIn this example, is a object that persists across renders. It's used to create a reference to the element, and you can access the DOM element using . The hook is used to focus on the input element when the component mounts.\n\nThe key takeaway here is that the object retains its identity across renders, ensuring that consistently refers to the same DOM element.\n\nIn this example, we use to memoize the doubled value of . The object persists across renders, and we calculate and memoize the doubled count value only if it hasn't been memoized before.\n\nAgain, the object's identity remains consistent across renders, ensuring that the memoized value is accessible and up-to-date.\n\nNow that we've covered the inner workings of and why it retains its identity across renders, let's explore some common use cases for this versatile hook.\n\nOne of the most frequent use cases for is accessing and manipulating DOM elements directly. This is particularly useful when you need to perform actions such as focusing on an input field, scrolling to a specific element, or animating elements.\n\nHere's an example that demonstrates how to use to focus on an input field:\n\n\n\nIn this example, is a object that stores a reference to the element. When the \"Focus Input\" button is clicked, the line is executed, and the input field receives focus.\n\nUnlike state variables, changes to a object's current property do not trigger re-renders. This makes an excellent choice for storing values that don't impact your component's UI but need to persist between renders.\n\nHere's an example that uses to store a previous value:\n\n\n\nIn this example, is a object that stores the previous value of . We update it within the hook whenever changes. The stored value persists across renders without triggering re-renders, allowing us to display the previous count.\n\ncan also be a valuable tool for optimizing performance. You can use it to memoize expensive calculations, ensuring they are only recomputed when necessary.\n\nConsider an example where you need to compute a complex value that depends on a set of inputs. You can use to store and memoize the result:\n\n\n\nIn this example, we use as a object to store the results of expensive calculations based on the . If the result for a particular input value is not already in the cache, we perform the calculation and store the result in the cache. This optimizes performance by avoiding redundant calculations.\n\nWhile we've covered the basics of , there are advanced techniques and patterns you can explore to leverage its full potential.\n\nand can be combined to handle more complex scenarios. You can use to manage mutable values or references and to perform side effects.\n\nHere's an example where we combine the two to observe changes in the document title:\n\n\n\nIn this example, is a object used to store the document title. We combine it with useEffect to observe changes to the value and update the document . This pattern allows us to manage side effects effectively.\n\nAs you become proficient with , here are some best practices and recommendations to keep in mind:\n\nUse for its intended purpose: managing mutable references and values that should not trigger re-renders.\n\nCombine with other hooks when needed. For example, combine it with to manage side effects or with to access context values.\n\nBe mindful of initialization. Ensure that useRef objects are initialized appropriately, especially when working with DOM elements.\n\nIn this comprehensive guide, we've explored React's hook in depth. We've learned how leverages closures, retains its identity across renders, and provides a versatile tool for accessing and manipulating DOM elements, storing mutable values, and optimizing performance. We've also covered advanced techniques and best practices to help you become a master of .\n\nAs you continue to build React applications, remember that is not just a tool for accessing the DOM; it's a powerful tool for managing state and optimizing performance. Whether you're a React novice or an experienced developer, mastering will undoubtedly enhance your React skills and make you a more proficient developer.\n\nSo go ahead, harness the power of , and build more efficient and performant React applications with confidence!"
    },
    {
        "link": "https://stackoverflow.com/questions/64188338/scrolling-components-into-view-with-react-with-useref",
        "document": "I'm trying to get the onclick handlers in my navbar to scroll different components into view. I have found a way that works, but I'm getting a warning from react, as well as the code is not looking very clean. I'm hoping someone knows how to solve this is in a more correct way, so that the warning goes away and also keeps the code clean.\n\nI'm going to create a scrollTo on each component, so in the Header.js there will be almost similar calls, with different names only.\n\nHere is the structure of the app:\n\nHere is the warning:\n\nAssignments to the 'technology' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect\n\nTo solve this I guess I need to pass it from App.js to Header.js, and get it from each Component to App.js? My googling skills have not been sufficient in solving this unfortunately.\n\nI know there is a library for this in react, but I was hoping to solve this in a more \"native\" way for now."
    },
    {
        "link": "https://react.dev/learn/manipulating-the-dom-with-refs",
        "document": "React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node.\n• How to access a DOM node managed by React with the attribute\n• How the JSX attribute relates to the Hook\n• How to access another component’s DOM node\n• In which cases it’s safe to modify the DOM managed by React Getting a ref to the node To access a DOM node managed by React, first, import the Hook: Then, use it to declare a ref inside your component: Finally, pass your ref as the attribute to the JSX tag for which you want to get the DOM node: The Hook returns an object with a single property called . Initially, will be . When React creates a DOM node for this , React will put a reference to this node into . You can then access this DOM node from your event handlers and use the built-in browser APIs defined on it. In this example, clicking the button will focus the input:\n• Pass it as . This tells React to put this ’s DOM node into .\n• In the function, read the input DOM node from and call on it with .\n• Pass the event handler to with . While DOM manipulation is the most common use case for refs, the Hook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don’t trigger re-renders when you set them. Read about refs in Referencing Values with Refs. Example: Scrolling to an element You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browser method on the corresponding DOM node:\n\nHow to manage a list of refs using a ref callback In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don’t know how many you will have. Something like this wouldn’t work: This is because Hooks must only be called at the top-level of your component. You can’t call in a loop, in a condition, or inside a call. One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like to “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes. Another solution is to pass a function to the attribute. This is called a callback. React will call your ref callback with the DOM node when it’s time to set the ref, and with when it’s time to clear it. This lets you maintain your own array or a Map, and access any ref by its index or some kind of ID. This example shows how you can use this approach to scroll to an arbitrary node in a long list: In this example, doesn’t hold a single DOM node. Instead, it holds a Map from item ID to a DOM node. (Refs can hold any values!) The callback on every list item takes care to update the Map: This lets you read individual DOM nodes from the Map later. When Strict Mode is enabled, ref callbacks will run twice in development. Read more about how this helps find bugs in callback refs. Refs are an escape hatch. Manually manipulating another component’s DOM nodes can make your code fragile. You can pass refs from parent component to child components just like any other prop. In the above example, a ref is created in the parent component, , and is passed to the child component, . then passes the ref to . Because is a built-in component React sets the property of the ref to the DOM element. The created in now points to the DOM element returned by . A click handler created in can access and call to set the focus on .\n\nExposing a subset of the API with an imperative handle In the above example, the ref passed to is passed on to the original DOM input element. This lets the parent component call on it. However, this also lets the parent component do something else—for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that with : Here, inside holds the actual input DOM node. However, instructs React to provide your own special object as the value of a ref to the parent component. So inside the component will only have the method. In this case, the ref “handle” is not the DOM node, but the custom object you create inside call. In React, every update is split in two phases:\n• During render, React calls your components to figure out what should be on the screen.\n• During commit, React applies changes to the DOM. In general, you don’t want to access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, so will be . And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them. React sets during the commit. Before updating the DOM, React sets the affected values to . After updating the DOM, React immediately sets them to the corresponding DOM nodes. Usually, you will access refs from event handlers. If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss Effects on the next pages. Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that was just before the last added one: The issue is with these two lines: In React, state updates are queued. Usually, this is what you want. However, here it causes a problem because does not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always “lags behind” by one item. To fix this issue, you can force React to update (“flush”) the DOM synchronously. To do this, import from and wrap the state update into a call: This will instruct React to update the DOM synchronously right after the code wrapped in executes. As a result, the last todo will already be in the DOM by the time you try to scroll to it: Best practices for DOM manipulation with refs Refs are an escape hatch. You should only use them when you have to “step outside React”. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose. If you stick to non-destructive actions like focusing and scrolling, you shouldn’t encounter any problems. However, if you try to modify the DOM manually, you can risk conflicting with the changes React is making. To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence using conditional rendering and state, as you would usually do in React. The second button uses the DOM API to forcefully remove it from the DOM outside of React’s control. Try pressing “Toggle with setState” a few times. The message should disappear and appear again. Then press “Remove from the DOM”. This will forcefully remove it. Finally, press “Toggle with setState”:\n\nAfter you’ve manually removed the DOM element, trying to use to show it again will lead to a crash. This is because you’ve changed the DOM, and React doesn’t know how to continue managing it correctly. Avoid changing DOM nodes managed by React. Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above. However, this doesn’t mean that you can’t do it at all. It requires caution. You can safely modify parts of the DOM that React has no reason to update. For example, if some is always empty in the JSX, React won’t have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there.\n• Refs are a generic concept, but most often you’ll use them to hold DOM elements.\n• You instruct React to put a DOM node into by passing .\n• Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.\n• A component doesn’t expose its DOM nodes by default. You can opt into exposing a DOM node by using the prop.\n• If you do modify DOM nodes managed by React, modify parts that React has no reason to update."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/intro",
        "document": "builds on top of by adding APIs for working with React components.\n\nTo get started with , you'll need to install it together with its peerDependency :\n\nTo get full type coverage, you need to install the types for and as well:\n\nYou want to write maintainable tests for your React components. As a part of this goal, you want your tests to avoid including implementation details of your components and rather focus on making your tests give you the confidence for which they are intended. As part of this, you want your testbase to be maintainable in the long run so refactors of your components (changes to implementation but not functionality) don't break your tests and slow you and your team down.\n\nThe is a very light-weight solution for testing React components. It provides light utility functions on top of and , in a way that encourages better testing practices. Its primary guiding principle is:\n\nSo rather than dealing with instances of rendered React components, your tests will work with actual DOM nodes. The utilities this library provides facilitate querying the DOM in the same way the user would. Finding form elements by their label text (just like a user would), finding links and buttons from their text (like a user would). It also exposes a recommended way to find elements by a as an \"escape hatch\" for elements where the text content and label do not make sense or is not practical.\n\nThis library encourages your applications to be more accessible and allows you to get your tests closer to using your components the way a user will, which allows your tests to give you more confidence that your application will work when a real user uses it.\n\nThis library is a replacement for Enzyme. While you can follow these guidelines using Enzyme itself, enforcing this is harder because of all the extra utilities that Enzyme provides (utilities which facilitate testing implementation details). Read more about this in the FAQ.\n\nWhat this library is not:\n• Specific to a testing framework (though we recommend Jest as our preference, the library works with any framework. See Using Without Jest)\n\nHave a look at the \"What is React Testing library?\" video below for an introduction to the library.\n\nAlso, don't miss this tutorial for React Testing Library."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/api",
        "document": "re-exports everything from as well as these methods:\n\nRender into a container which is appended to .\n\nYou won't often need to specify options, but if you ever do, here are the available options which you could provide as a second argument to .\n\nBy default, will create a and append that to the and this is where your React component will be rendered. If you provide your own HTMLElement via this option, it will not be appended to the automatically.\n\nFor example: If you are unit testing a element, it cannot be a child of a . In this case, you can specify a as the render .\n\nIf the is specified, then this defaults to that, otherwise this defaults to . This is used as the base element for the queries as well as what is printed when you use .\n\nIf hydrate is set to true, then it will render with ReactDOM.hydrate. This may be useful if you are using server-side rendering and use ReactDOM.hydrate to mount your components.\n\nBy default we'll render with support for concurrent features (i.e. ). However, if you're dealing with a legacy app that requires rendering like in React 17 (i.e. ) then you should enable this option by setting .\n\nCallback called when React catches an error in an Error Boundary. Behaves the same as in .\n\nCallback called when React automatically recovers from errors. Behaves the same as in .\n\nPass a React Component as the option to have it rendered around the inner element. This is most useful for creating reusable custom render functions for common data providers. See setup for examples.\n\nQueries to bind. Overrides the default set from unless merged.\n\nSee helpers for guidance on using utility functions to create custom queries.\n\nCustom queries can also be added globally by following the custom render guide.\n\nThe method returns an object that has a few properties:\n\nThe most important feature of is that the queries from DOM Testing Library are automatically returned with their first argument bound to the baseElement, which defaults to .\n\nThe containing DOM node of your rendered React Element (rendered using ). It's a . This is a regular DOM node, so you can call etc. to inspect the children.\n\nThe containing DOM node where your React Element is rendered in the container. If you don't specify the in the options of , it will default to .\n\nThis is useful when the component you want to test renders something outside the container div, e.g. when you want to snapshot test your portal component which renders its HTML directly in the body.\n\nThis method is a shortcut for .\n\nThis is a simple wrapper around which is also exposed and comes from .\n\nIt'd probably be better if you test the component that's doing the prop updating to ensure that the props are being updated correctly (see the Guiding Principles section). That said, if you'd prefer to update the props of a rendered component in your test, this function can be used to update props of the rendered component.\n\nThis will cause the rendered component to be unmounted. This is useful for testing what happens when your component is removed from the page (like testing that you don't leave event handlers hanging around causing memory leaks).\n\nReturns a of your rendered component. This can be useful if you need to avoid live bindings and see how your component reacts to events.\n\nUnmounts React trees that were mounted with render.\n\nFor example, if you're using the ava testing framework, then you would need to use the hook like so:\n\nFailing to call when you've called could result in a memory leak and tests which are not \"idempotent\" (which can lead to difficult to debug errors in your tests).\n\nThis is a light wrapper around the function. All it does is forward all arguments to the act function if your version of react supports . It is recommended to use the import from over for consistency reasons.\n\nThis is a convenience wrapper around with a custom test component. The API emerged from a popular testing pattern and is mostly interesting for libraries publishing hooks. You should prefer since a custom test component results in more readable and robust tests since the thing you want to test is not hidden behind an abstraction.\n\nDeclares the props that are passed to the render-callback when first invoked. These will not be passed if you call without props.\n\nCallback called when React catches an error in an Error Boundary. Behaves the same as in .\n\nCallback called when React automatically recovers from errors. Behaves the same as in .\n\nThe method returns an object that has a few properties:\n\nHolds the value of the most recently committed return value of the render-callback:\n\nNote that the value is held in . Think of as a ref for the most recently committed value.\n\nRenders the previously rendered render-callback with the new props:\n\nChanges global options. Basic usage can be seen at Configuration Options.\n\nWhen enabled, is rendered around the inner element. Defaults to ."
    },
    {
        "link": "https://jestjs.io/docs/tutorial-react",
        "document": "At Facebook, we use Jest to test React applications.\n\nIf you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add for rendering snapshots.\n\nIf you have an existing application you'll need to install a few packages to make everything work well together. We are using the package and the babel preset to transform our code inside of the test environment. Also see using babel.\n\nYour should look something like this (where is the actual latest version number for the package). Please add the scripts and jest configuration entries:\n\nAnd you're good to go!\n\nNow let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:\n\nWhen you run or , this will produce an output file like this:\n\nThe next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with to overwrite the existing snapshot.\n\nThe code for this example is available at examples/snapshot.\n\nThere's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:\n\nThen you will see warnings in the console:\n\nReact 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:\n• Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:\n• Render as a custom element. DOM \"custom elements\" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.\n• Use . The test renderer doesn't care about element types and will happily accept e.g. . You could check snapshots using the test renderer, and check component behavior separately using Enzyme.\n• Disable warnings all together (should be done in your jest setup file): This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.\n\nIf you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use .\n\nLet's implement a checkbox which swaps between two labels:\n\nThe code for this example is available at examples/react-testing-library.\n\nIf you need more advanced functionality, you can also build your own transformer. Instead of using , here is an example of using :\n\nDon't forget to install the and packages for this example to work.\n\nTo make this work with Jest you need to update your Jest configuration with this: .\n\nIf you'd like to build a transformer with babel support, you can also use to compose one and pass in your custom configuration options:\n\nSee dedicated docs for more details."
    },
    {
        "link": "https://keploy.io/blog/community/a-guide-to-testing-react-components-with-jest-and-react-testing-library",
        "document": "API testing plays a vital role in software development, making sure that applications work together smoothly. While...\n\nIn the constantly changing landscape of software development, code reliability is paramount. One of the best methods...\n\nAs the time goes by, we can see that requirements for software products also change. These requirements...\n\nIn today’s fast-paced software development landscape, ensuring the quality of applications is critical. Traditional testing methods often...\n\nReact Testing on VS Code: Best Practices Testing React applications in VS Code ensures better reliability, performance, and maintainability. Without proper testing, UI bugs,...\n\nAI and CLI Tools: A New Era of Developer Productivity and Testing We all know the importance of software quality in today’s digital landscape and technological advancements. Software quality...\n\nThe Growing Influence of AI in Software Development AI’s influence on the marketplace is more profound than..."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-test-a-react-app-with-jest-and-react-testing-library",
        "document": "The author selected Vets Who Code to receive a donation as part of the Write for DOnations program.\n\nObtaining solid test coverage is imperative for building confidence in your web application. Jest is a JavaScript test runner that provides resources for writing and running tests. React Testing Library offers a set of testing helpers that structure your tests based on user interactions rather than components’ implementation details. Both Jest and React Testing Library come pre-packaged with Create React App and adhere to the guiding principle that testing apps should resemble how the software will be used.\n\nIn this tutorial, you will test asynchronous code and interactions in a sample project containing various UI elements. You will use Jest to write and run unit tests, and you will implement React Testing Library as a helper DOM (Document Object Model) library to handle interacting with components.\n\nTo complete this tutorial, you will need:\n• Node.js version 14 or greater installed on your local machine. To install Node.js on macOS or Ubuntu 18.04, follow the steps in How to Install Node.js and Create a Local Development Environment on macOS or the Installing Using a PPA section of How To Install Node.js on Ubuntu 18.04.\n• version 5.2 or greater on your local machine, which you will need to use Create React App and in the sample project. If you did not install alongside , do that now. For Linux, use the command .\n• For packages to work in this tutorial, install the package. For Linux, use the command .\n• Git installed on your local machine. You can check if Git is installed on your computer or go through the installation process for your operating system with How To Install Git on Ubuntu 20.04.\n• Familiarity with React, which you can develop with the How To Code in React.js series. Because the sample project is bootstrapped with Create React App, you do not need to install it separately.\n• Some familiarity with Jest as a test runner or framework is helpful but not required. Because Jest is pre-packaged with Create React App, you do not need to install it separately.\n\nIn this step, you will clone a sample project and launch the test suite. The sample project utilizes three main tools: Create React App, Jest, and React Testing Library. Create React App is used to bootstrap a single-page React application. Jest is used as the test runner, and React Testing Library provides test helpers for structuring tests around user interactions.\n\nTo begin, you will clone a pre-built React App from GitHub. You will work with the Doggy Directory app, which is a sample project that leverages the Dog API to build a search and display system for a collection of dog images based on a specific breed.\n\nTo clone the project from Github, open your terminal and run the following command:\n\nYou will see an output similar to this:\n\nThe command will install all the project dependencies defined in the file.\n\nAfter installing the dependencies, you can either view the deployed version of the app or you can run the app locally with the following command:\n\nIf you chose to run the app locally, it will open on . You will see the following output in the terminal:\n\nAfter launching, the landing page for the app will look like this:\n\nThe project dependencies have been installed, and the app is now running. Next, open a new terminal and launch the tests with the following command:\n\nThe command starts the tests in an interactive watch mode with Jest as its test runner. When in watch mode, the tests automatically re-run after a file is changed. The tests will run whenever you change a file and let you know if that change passed the tests.\n\nAfter running for the first time, you will see this output in the terminal:\n\nNow that you have the example application and test suite running, you can start testing with the landing page.\n\nBy default, Jest will look for files with the suffix and files with the suffix in folders. When you make changes to the relevant test files, they will be detected automatically. As test cases are modified, the output will update automatically. The testing file prepared for the sample project is set up with minimal code before you add testing paradigms. In this step, you will write tests to verify that the app’s landing page will load before performing a search.\n\nOpen in your editor to see the following code:\n\nA minimum of one test block is required in each test file. Each test block accepts two required parameters: the first argument is a string representing the name of the test case; the second argument is a function that holds the expectations of the test.\n\nInside the function, there is a method that React Testing Library provides to render your component into the DOM. With the component that you want to test rendered into the testing environment’s DOM, you can now start writing code to assert against the expected functionality.\n\nYou will add a test block to the method that will test if the landing page renders accurately before any API calls or selections are made. Add the highlighted code underneath the method:\n\nThe function is used every time you want to verify a certain outcome, and it accepts a single argument representing the value that your code produces. Most functions are paired with a matcher function to assert something about a particular value. For most of these assertions, you will use additional matchers provided by jest-dom to make it easier to check for common aspects found in the DOM. For example, is the matcher for the function in the first line, while is the selector to grab the DOM element.\n\nReact Testing Library provides the object as a convenient way to access the pertinent queries needed to assert against the test DOM environment. By default, React Testing Library provides queries that allow you to locate elements within the DOM. There are three main categories of queries:\n\nEach query type serves a specific purpose which will be defined later in the tutorial. In this step, you will focus on the query, which is the most common query type. To see an exhaustive list of the different query variations, you can review React’s query cheatsheet.\n\nBelow is an annotated image of the Doggy Directory landing page indicating each section that the first test (on rendering the landing page) covers:\n\nEach function is asserting against the following (shown in the annotated image above):\n• You expect the element with the heading role to have a substring match of Doggy Directory.\n• You expect the select input to have an exact display value of Select a breed.\n• You expect the Search button to be disabled since a selection has not been made.\n• You expect the placeholder image to be present in the document since a search has not taken place.\n\nWhen finished, save the file. Because the tests are running in watch mode, the changes will register automatically. If the changes do not register automatically, you may need to stop and restart the test suite.\n\nNow, when you look at your tests in the terminal, you will see the following output:\n\nIn this step, you wrote an initial test to verify the initial rendering view of the Doggy Directory landing page. In the next step, you will learn how to mock an API call for testing asynchronous code.\n\nIn this step, you will review one approach to mocking JavaScript’s method. While there are numerous ways to achieve this, this implementation will use Jest’s and methods.\n\nWhen you rely on external APIs, there is a chance that their API will go down or take a while to return a response. Mocking out the method provides a consistent and predictable environment, giving you more confidence in your tests. An API mocking mechanism is necessary to properly run tests that use an external API.\n\nOpen in your editor to review how the method works:\n\nThe method returns an object that closely resembles the structure of what a call would return in response to API calls within the application. The method is necessary to test the asynchronous functionality across two areas of the Doggy Directory app: the select dropdown that populates the list of breeds and the API call to retrieve dog images when a search is performed.\n\nClose . Now that you understand how the method will be used in your tests, you can import it into your test file. The function will be passed in as an argument to the method and will then be used as a faux implementation of the fetch API.\n\nIn , add the highlighted lines of code to import the method:\n\nThis code will set up and tear down the mock implementation so that each test starts from a level playing field.\n\ncreates a mock function that will track calls to the method attached to the global window variable in the DOM.\n\naccepts a function that will be used to implement the mock method. Because this command overrides the original implementation, it will run whenever is called within the app code.\n\nNow, when you look at your tests in the terminal, you will receive the following output:\n\nThe warning tells you that a state update occurred when it was not expected. However, the output also indicates that the tests have successfully simulated the method.\n\nIn this step, you mocked the method and incorporated that method into a test suite. Although the test is passing, you still need to address the warning.\n\nIn this step, you will learn how to fix the warning that surfaced after the changes in Step 3.\n\nThe warning occurs because you have mocked out the method, and when the component mounts, it makes an API call to grab the list of breeds. The breeds list is stored in a state variable that populates the element within the select input.\n\nThe image below shows what the select input looks like after a successful API call was made to populate the list of breeds:\n\nThe warning is thrown because the state is set after the test block finishes rendering the component.\n\nTo fix this issue, add the highlighted modifications to the test case in :\n\nThe keyword tells Jest that asynchronous code runs as a result of the API call that occurs when the component mounts.\n\nA new assertion with the query verifies that the document contains an option with the value of . queries are used when you need to test asynchronous code that is dependent on something being in the DOM after a period of time. Because the query returns a promise that gets resolved when the requested element is found in the DOM, the keyword is used within the method.\n\nWhen finished, save the changes made in .\n\nWith the new additions, you will now see that the warning is no longer present in your tests:\n\nIn this step, you learned how to fix the warning that can occur when working with asynchronous code. Next, you will add a second test case to verify the interactive functionalities of the Doggy Directory application.\n\nIn the final step, you will write a new test case to verify the search and image display feature. You will leverage a variety of queries and API methods to achieve the proper test coverage.\n\nReturn to the file in your editor. At the top of the file, import the companion library and the async method into the test file with the highlighted commands:\n\nYou will use these imports later in this section.\n\nAfter the initial method, add a new async test block and render the component with the following block of code:\n\nWith the component rendered, you can now add functions that verify the interactive features of the Doggy Directory app.\n\nStill in , add the highlighted blocks of code within the second method:\n\nThe highlighted section above will simulate the selection of a dog breed and verify that the correct value is displayed.\n\nThe query grabs the selected element and assigns it to the variable.\n\nSimilar to how you fixed the warning in Step 4, use the query to wait for the option to appear in the document before proceeding with further assertions.\n\nThe object imported earlier will simulate common user interactions. In this example, the method selects the option that you waited for on the previous line.\n\nThe last line asserts that the variable contains the value selected above.\n\nThe next section that you will add to the Javascript block will initiate the search request to find dog images based on the breed selected and confirm the presence of a loading state.\n\nThe query locates the search button and assigns it to the variable.\n\nThe jest-dom matcher will verify that the search button is not disabled when a breed selection is made.\n\nThe method on the object simulates clicking the search button.\n\nThe async helper function imported earlier will wait for the appearance and disappearance of the Loading message while the search API call is in flight. within the callback checks for the absence of an element without throwing an error.\n\nThe image below shows the loading state that will be displayed when a search is in progress:\n\nNext, add the following Javascript code to validate the image and results count display:\n\nThe query will select all the dog images and assign them to the variable. The variant of the query returns an array containing multiple elements that match the specified role. The variant differs from the variant, which can only return a single element.\n\nThe mocked implementation contained two image URLs within the response. With Jest’s matcher, you can verify that there are two images displayed.\n\nThe query will check that the proper results count appears in the right-hand corner.\n\nTwo assertions using the matchers verify that the appropriate alt text is associated with individual images.\n\nA completed search displaying images of the dog based on the breed selected along with the number of results found will look like this:\n\nWhen you combine all the pieces of the new Javascript code, the file will look like this:\n\nSave the changes made in .\n\nWhen you review your tests, the final output in the terminal will now have the following output:\n\nIn this final step, you added a test that verifies the search, loading, and display functionalities of the Doggy Directory application. With the final assertion written, you now know that your app works.\n\nThroughout this tutorial, you wrote test cases using Jest, React Testing Library, and jest-dom matchers. Building incrementally, you wrote tests based on how a user interacts with the UI. You also learned the differences between the , , and queries and how to test asynchronous code.\n\nTo learn more about the topics mentioned above, take a look at the Jest, React Testing Library, and jest-dom official documentation. You can also read Kent C. Dodd’s Common Mistakes with React Testing Library to learn about best practices when working with React Testing Library. For more on using snapshot tests within a React App, check out How To Write Snapshot Tests."
    }
]