[
    {
        "link": "https://thepythoncodingbook.com/2023/01/18/best-practices-in-python-functions",
        "document": "You’ve covered a lot of material in this Intermediate Python Functions Series. In this final article, you’ll read about some best practices in Python functions.\n\nThis topic is different from the previous ones discussed in this series. You won’t get a , or any other error if you don’t follow best practices. Your code may still work exactly the same if you use best practices or if you don’t, although bugs are more likely to creep into your code if you don’t.\n\nLet’s see why it still matters to know and use best practices. There were two options when writing this article: either write a very long article covering every possible best practice or write a much more concise article highlighting two key best practices. I’ve chosen to go down the route of writing a short article and focus on the two I think are most relevant.\n\nHere’s an overview of the seven articles in this series:\n• Introduction to the series: Do you know all your functions terminology well?\n• Choosing whether to use positional or keyword arguments when calling a function\n• Using optional arguments by including default values when defining a function\n• Using any number of optional positional and keyword arguments: and\n• Using positional-only arguments and keyword-only arguments: the “rogue” forward slash / or asterisk * in function signatures\n• [This article] Best practices when defining and using functions\n\nStart The Function Name With A Verb\n\nLet’s start with a function you’ve seen often in this series of articles:\n\nIt is clear from the name of the function what the function does. It greets a person! If you choose to call the function , it will be unclear what the function is doing with that greeting.\n\nAnd you should always avoid calling a function or or other names with no descriptive value.\n\nLet’s look at another example. Let’s assume you’re reading code that displays shapes and patterns. You see a function called . Is this function drawing a square or working out the square of a number to use in some calculation? You may be able to figure this out quickly by reading further or running the code. However, if the function name were , you wouldn’t even need to ask yourself the question about the function’s purpose.\n\nDid you notice what’s common in the two best practice examples you read about above? Here are a few more examples of best practice in Python function names compared to versions that you should avoid:\n\nA function performs an action. In the languages we use for human communication, such as English, verbs perform a similar role of denoting an action. Therefore, the best practice in Python functions is to use a verb as the first word in a function name to describe what the function does.\n\nIn the examples you read in the table above, the parameter name is also different in some cases. This series is about functions, so I’ll focus on function names. But when choosing variable names, including parameter names, you often want to use a noun which tells you what the value stored in the variable represents.\n\nWrite A Function That Only Does One Thing\n\nLet’s assume you’re writing a program that deals with historical temperatures which you want to analyse. The data is in Fahrenheit, but you need to work in Celsius and then find the range of temperature in a subset of the data by subtracting the minimum value from the maximum value.\n\nYou decide to write the function . You’ve followed the ‘start with a verb’ best practice and feel you’ve written a descriptive name. All good, then, right?\n\nThere’s a word in your function that’s a giveaway for the next best practice I’ll write about. This is the word “and” in the function name. If you feel the need to add an “and” in your function name, you probably want to write two functions instead.\n\nA function should only perform one action. In this example, you can write a function and another function called .\n\nThis rule sounds simple enough initially. However, some nuance is involved in defining a “single action”.\n\nFor example, consider the function , which takes a string with a person’s full name and returns a string with the initials. This function may need to split the string to separate the components in the full name, such as first name, last name, and perhaps middle names. Then, it will need to extract the first letter from each subcomponent and concatenate them with periods after each letter.\n\nThese are several actions. Does this mean this function goes against the “perform one action” best practice? Every programmer will need to make these decisions in the context of the program and application they’re writing. In this example, it’s likely that grouping the steps listed above into a single function is fine. The single action you want to perform is to get the initials from a name.\n\nAs a rule, if the steps you want to include in a function will always be performed together, then you probably want them in the same function. You’ll get better at making these decisions.\n\nBest practices in Python functions matter. They often make sure code is more readable for others and your future self. They also make bugs less likely and the code more maintainable.\n\nProgrammers will have different views on what constitutes a best practice. You’ll have to make up your mind on which ones to follow. And you may find that as you progress through your Python learning journey, you’ll also change your views on which best practices to adopt!\n\nThis is the final article in the Intermediate Python Functions Series\n• Chapter 3: Power-up Your Coding: Create Your Own Functions for an in-depth introduction to Python functions\n• Chapter 6: Functions Revisited. This chapter covers topics that will be dealt with later on in the series\n• The White Room: Understanding Programming. In this article, I briefly referred to parameters as boxes which store data. This is part of a broader analogy I like to use. You can read more in this chapter\n• Using Python Optional Arguments When Defining Functions is an article I wrote for Real Python if you want to read ahead."
    },
    {
        "link": "https://kdnuggets.com/5-tips-for-writing-better-python-functions",
        "document": "This tutorial covers five simple yet effective practices for writing better and maintainable Python functions.\n\nWe all write functions when coding in Python. But do we necessarily write good functions? Well, let’s find out.\n\nFunctions in Python let you write modular code. When you have a task you need to perform at multiple places, you can wrap the logic of the task into a Python function. And you can call the function every time you need to perform that specific task. As simple as it seems to get started with Python functions, writing maintainable and performant functions is not so straightforward.\n\nAnd that’s why we’ll explore a few practices that’ll help you write cleaner and easy-to-maintain Python functions. Let's get started…\n\n1. Write Functions That Do Only One Thing\n\nWhen writing functions in Python, it's often tempting to put all related tasks into a single function. While this can help you code things up quickly, it’ll only make your code a pain to maintain in the near future. Not only will this make understanding what a function does more difficult but also leads to other issues such as too many parameters (more on that later!).\n\nAs a good practice, you should always try to make your function do only one thing—one task—and do that well. But sometimes, for a single task, you may need to work through a series of subtasks. So how do you decide if and how the function should be refactored?\n\nDepending on what the function is trying to do and how complex the task is, you can work out the separation of concerns between subtasks. And then identify a suitable level at which you can refactor the function into multiple functions—each focusing on a specific subtask.\n\nHere’s an example. Look at the function :\n\nIt's quite easy to see that it can be refactored into two functions: one calculating the sales metrics and another on writing the sales metrics to a file like so:\n\nNow it’s easier to debug any concerns with the calculation of sales metrics and file operations separately. And here’s a sample function call:\n\nYou should be able to see the ‘sales_report.txt’ file in your working directory with the sales metrics. This is a simple example to get started, but this is helpful especially when you're working on more complex functions.\n\nPython is a dynamically typed language. So you do not need to declare types for the variables you create. But you can add type hints to specify the expected data type for variables. When you define the function, you can add the expected data types for the parameters and the return values.\n\nBecause Python does not enforce types at runtime, adding type hints has no effect at runtime. But there still are benefits to using type hints, especially on the maintainability front:\n• Adding type hints to Python functions serves as inline documentation and gives a better idea of what the function does and what values it consumes and returns.\n• When you add type hints to your functions, you can configure your IDE to leverage these type hints. So you’ll get helpful warnings if you try to pass an argument of invalid type in one or more function calls, implement functions whose return values do not match the expected type, and the like. So you can minimize errors upfront.\n• You can optionally use static type checkers like mypy to catch errors earlier rather than letting type mismatches introduce subtle bugs that are difficult to debug.\n\nNow let's add type hints to the function like so:\n\nWith the modified version, you get to know that the function takes in a list of dictionaries. The keys of the dictionary should all be strings and the values can either be integers or floating point values. The function also returns a dictionary. Let’s take a sample function call:\n\nIn this example, type hints help us get a better idea of how the function works. Going forward, we'll add type hints for all the better versions of Python functions we write.\n\n3. Accept Only the Arguments You Actually Need\n\nIf you are a beginner or have just started your first dev role, it’s important to think about the different parameters when defining the function signature. It's quite common to introduce additional parameters in the function signature that the function never actually processes.\n\nEnsuring that the function takes in only the arguments that are actually necessary keeps function calls cleaner and more maintainable in general. On a related note, too many parameters in the function signature also make it a pain to maintain. So how do you go about defining easy-to-maintain functions with the right number of parameters?\n\nIf you find yourself writing a function signature with a growing number of parameters, the first step is to remove all unused parameters from the signature. If there are too many parameters even after this step, go back to tip #1: break down the task into multiple subtasks and refactor the function into multiple smaller functions. This will help keep the number of parameters in check.\n\nIt’s time for a simple example. Here the function definition to calculate student grades contains the parameter that’s never used:\n\nYou can rewrite the function without the parameter like so:\n\nHere's the output of the function call:\n\nIn practice, most Python functions take in multiple arguments. You can pass in arguments to Python functions as positional arguments, keyword arguments, or a mix of both. Read Python Function Arguments: A Definitive Guide for a quick review of function arguments.\n\nSome arguments are naturally positional. But sometimes having function calls containing only positional arguments can be confusing. This is especially true when the function takes in multiple arguments of the same data type, some required and some optional.\n\nIf you recall, with positional arguments, the arguments are passed to the parameters in the function signature in the same order in which they appear in the function call. So change in order of arguments can introduce subtle bugs and type errors.\n\nIt’s often helpful to make optional arguments keyword-only. This also makes adding optional parameters much easier—without breaking existing calls.\n\nHere’s an example. The function takes in an optional string:\n\nSay you want to make the optional a keyword-only argument. Here’s how you can do it:\n\nNow try passing in all arguments as positional:\n\nYou’ll get an error as shown:\n\n5. Don’t Return Lists From Functions; Use Generators Instead\n\nIt's quite common to write Python functions that generate sequences such as a list of values. But as much as possible, you should avoid returning lists from Python functions. Instead you can rewrite them as generator functions. Generators use lazy evaluation; so they yield elements of the sequence on demand rather than computing all the values ahead of time. Read Getting Started with Python Generators for an introduction to how generators work in Python.\n\nAs an example, take the following function that generates the Fibonacci sequence up to a certain upper limit:\n\nIt’s a recursive implementation that’s computationally expensive and populating the list and returning it seems more verbose than necessary. Here’s an improved version of the function that uses generators:\n\nIn this case, the function returns a generator object which you can then loop through to get the elements of the sequence:\n\nAs you can see, using generators can be much more efficient especially for large input sizes. Also, you can chain multiple generators together, so you can create efficient data processing pipelines with generators.\n\nAnd that’s a wrap. You can find all the code on GitHub. Here’s a review of the different tips we went over:\n• Write functions that do only one thing\n• Accept only the arguments you actually need\n• Don't return lists from functions; use generators instead\n\nI hope you found them helpful! If you aren’t already, try out these practices when writing Python functions. Happy coding!\n\n \n\n\n\nBala Priya C is a developer and technical writer from India. She likes working at the intersection of math, programming, data science, and content creation. Her areas of interest and expertise include DevOps, data science, and natural language processing. She enjoys reading, writing, coding, and coffee! Currently, she's working on learning and sharing her knowledge with the developer community by authoring tutorials, how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews and coding tutorials."
    },
    {
        "link": "https://stackoverflow.com/questions/55340041/best-practice-how-to-pass-many-arguments-to-a-function",
        "document": "I am running some numerical simulations, in which my main function must receive lots and lots of arguments - I'm talking 10 to 30 arguments depending on the simulation to run.\n\nWhat are some best practices to handle cases like this? Dividing the code into, say, 10 functions with 3 arguments each doesn't sound very feasible in my case.\n\nWhat I do is create an instance of a class (with no methods), store the inputs as attributes of that instance, then pass the instance - so the function receives only one input.\n\nI like this because the code looks clean, easy to read, and because I find it easy to define and run alternative scenarios.\n\nI dislike it because accessing class attributes within a function is slower than accessing a local variable (see: How / why to optimise code by copying class attributes to local variables?) and because it is not an efficient use of memory - too much data stored multiple times unnecessarily."
    },
    {
        "link": "https://reddit.com/r/Python/comments/o9psjn/best_practice_for_function_placement_within_a_code",
        "document": "I am new to Python(<1 year) and want my code to be clean, clear and legible. I wasn't able to get a good answer to this question via stack overflow/google so I figured I would reach out to the reddit community. ..\n\nWhere do you place your functions? Do you place them at the start of your code? Do you leave it wherever you originally create it within the code? Do you want it to be just before it's first usage? Is there a consensus amongst the community or is it like the wild west?\n\nAny help or tips would be greatly appreciated, TIA!"
    },
    {
        "link": "https://jessica-miles.medium.com/writing-functions-in-python-a-beginners-guide-ed9182db959b",
        "document": "It’s worth briefly returning to the concept I mentioned above: you can ask your function to make decisions about certain things so you don’t have to do it manually. The normality test code segment is a very simple example of coding a decision that I would otherwise have to make manually: in addition to printing the result of the test, I’m also having the code determine if the p-value is significant at an alpha level of 0.05, and telling me the result of that decision. Although I could actually make this decision quite easily myself by looking at the value, much more complex logic could be written for more nuanced decisions.\n\nNow that I’ve got working code for each of the exploratory steps that I want to perform, I can combine them into a function.\n• Write the function definition using the format with empty parentheses (no parameters) to start with. Make sure to put a colon at the end.\n• Add an empty multiline string using a set of triple quotes ( ), as a placeholder for your docstring. We’ll come back to this later.\n• Add to the end of your function body as a placeholder for the eventual stopping point. The keyword is how we indicate the point at which the function will terminate and code execution will continue at the point where the function was originally called. Optionally, the function can pass a return variable or value back to the calling code, usually representing the fruits of its labor. We’re setting the output equal to for now, and you can come back and update it later.\n\nIt’s not mandatory for functions to explicitly return a value. In this example, we could easily just print all the visualizations and statistics so we can read through them, and may not be interested in having our function actually return anything else. If you don’t include a statement at all, will be implicit. I recommend including as a placeholder to remind you to think carefully whether there is something you might want to return. If not, you can just leave as-is or remove it with no change in functionality. Also, keep in mind that you can have multiple statements if your function returns different values, or terminates from different branches of the logic tree depending the circumstances.\n\n3. Copy your code into the function body\n• Starting now, and continuing as you modify the function, be sure to add descriptive comments so you can easily skim through and find which tasks each section of code performs. You’ll be glad you did when you return to a function you wrote weeks or months ago and need to remember how it works to make an update! Just put a at the beginning of each comment line.\n• Remember that in Python, groups of statements like loops and functions need to be indented, and the indentation in the statements you coded separately may need to be adjusted.\n\nIt’s generally recommended to use a consistent number of spaces (2 or 4 spaces are common) instead of tab characters to indent code blocks. Tab characters may be interpreted in different ways, and mixing them with spaces for indentation will cause issues with code execution. If you’re working in a Jupyter Notebook, you can use for indentation and by default it will automatically be converted to 4 spaces (you can also customize this setting). Jupyter Notebook will also maintain the appropriate level of indentation when you hit enter when writing within a block of code. This is great, since it keeps your code consistent and runnable outside Jupyter Notebooks, but still allows you to use shortcuts to save time. You can select multiple lines of code and and use to indent the whole group one level, or to de-indent the whole group by one level. The ability to use these shortcuts to indent or un-indent multiple lines of code at once is very useful when assembling code you wrote outside a function, and adding loops as your function becomes more complex.\n\nParameters are the values a function expects as inputs. They may represent variables to be updated or transformed, values to be used in calculations, or options indicating which tasks the function should or shouldn’t perform. Selecting which variables in the body of the function should be parameterized is key to having a flexible function that can be easily reused with varying inputs.\n\nWhen considering which variables should be parameterized in your first draft, ask yourself:\n• What will definitely change each time I run this? These should definitely become parameters.\n• Is there anything I’ve hard-coded in my first draft that I might want to adjust in the future? These could become parameters up front, or you could also just assign values to variables at the top of the function, so you can easily assign them from parameters later.\n\nIn our example, I’m using predictor and target columns stored in a Pandas dataframe, and if I want to use this function on a different dataframe then I’ll definitely want that to be passed in. I also want to be able to explore a custom subset of predictor columns that will change each time I run the function, so I’ll create a parameter for the list of predictor column names. And finally, although for this project my target will always be , I want to use the function for future projects where the target will be named something else, so I should have a parameter for that too.\n• Add each parameter to the function definition, inside the parentheses. The names will be used not only to refer to that variable in the body of the function, but also as the keyword argument names when the function is called.\n• Choose parameter names that aren’t too long, and will naturally bring to mind what they stand for. Shorter names will be easy to refer to throughout the function body and easier to refer to when calling the function.\n• Use the same rules for naming parameters as for naming functions (all lower-case, with underscores to separate words).\n• If there is a variable or value you’re using like a constant for now but think you might want to adjust later, add it as default parameter so you don’t have to specify it as an argument every time you call the function. To make a default parameter, assign a value to it in the function definition using the equals sign.\n\nAny parameter not assigned a value in the definition (non-default) will be considered required. In , and are both required because we haven’t assigned any values to them. If we tried to call this function with only one argument (such as ), we would get an error. If you assign default values to parameters, they will be optional to include as arguments when the function is called. Default parameters that are assigned values are usually placed at the end of the parameter list. If we had the function , would be optional when the function is called because it has been assigned the default value of . We would only need to provide an argument for so calling this like will work fine assuming we’re OK with having the default value of . However, we do still have the option to specify a value other than the default for if we want to, such as ( ). Using default parameters helps simplify calling a function, since fewer arguments need to be passed and someone calling the function doesn’t need to understand every single argument in order to get started. But for less common or more advanced functionality, the optional argument values still can be easily customized.\n• Remember to keep things simple to start with and add more complexity and flexibility as needed. Start with just parameterizing what is obvious and necessary and don’t “boil the ocean” trying to think of every option you might ever want to specify.\n\nOnce you’ve decided which variables should be parameterized and chosen names for them, go through the function body be sure to replace the hard-coded values or previous variable names with the new parameters.\n\n5. Code your return value (or not)\n\nIf your function was naturally designed to output a calculated value or object, just use this step to make sure you’re returning whatever that is at the end of the function. Replace the initial placeholder with your final variable or expression.\n\nIf you’re building a function to print graphs or a report like in our example, consider whether returning a dictionary or dataframe of some of the information might also be helpful. In our example, the primary goal is to print visualizations and descriptive statistics of different predictors, but we’re also performing a normality test and calculating the Pearson correlation coefficient. Right now, we’re printing that information along with the graphs, but if I had a large number of columns I might want to compile the results in one place so I could filter or sort it instead of reading back through a bunch of printed statements.\n\nFor this example, I decided to add a few lines of code to compile some of the statistics and test result in a list of lists, and then convert that list to a dataframe that will be returned.\n\nNow that we have the basics of our function coded, it’s time to test out the function and make sure it’s working as expected.\n\nIt’s easier to to troubleshoot problems if you have a shorter list of things you’ve changed since it last worked.\n• If you’re working in a Jupyter Notebook, make sure to execute the cell containing the function to load up its most recent version.\n• If your function returns a value, don’t forget to set a variable equal to the output of the function when you call it, so you can capture the output.\n\nSuccess! In addition to the graphs and printouts that I had coded earlier, now I also get a dataframe with a bunch of the statistics I calculated for each column, so I can easily review them without scrolling back through the graphs.\n\nA note about the different ways you can pass arguments when calling a function:\n\nWhen you pass arguments to a function, you can do so by keywords, or by position. Passing arguments using keywords means that you include the parameter name as well as the value or variable, using an equals sign to connect the argument value with the proper function parameter. Here’s an example of passing arguments by keywords: The benefit of using keywords include: - It’s easy to tell which value each argument is being passed to - The keyword arguments can be in any order, since the argument names are specified If you pass arguments positionally, you don’t include the names, but you must pass them in the order in which they occurred in the function definition. Without the keywords, the compiler relies on the order to match up the argument values with the function parameters. I generally recommend passing arguments using keywords because I think it makes code more readable and I like the flexibility of being able to pass them in any order (makes it easier to add another argument to the end of the list, if needed). But ultimately it’s up to you!\n\n7. Add a docstring (even just a basic one)\n\nA docstring is a block of text that you add as the very first thing after the function definition. Docstrings explains what the function does, what arguments it takes, and what it outputs, and can also include other helpful info such as code examples. They’re an easy way for the author of the function, who is the expert on what it does and how it works, to provide built-in instructions to anyone who might want to use it.\n\nIn a Jupyter Notebook, you can show the docstring for a built-in Python function by typing the name of the function, then the opening parentheses, then on your keyboard. This initially shows the beginning of the docstring, but you can click the button to show a deeper pop-up, or the button to open a separate container on the bottom of the notebook that is easier to scroll through.\n\nThe function signature (the names of the arguments and the order in which they occur) is automatically pulled up when you summon the docstring even if you haven’t added anything manually, but without any further explanation it would be difficult for anyone else to know what the function does. Even future-you who may want to use this function a few months from now will appreciate a reminder on what it does and what to pass as each argument!\n\nYou don’t have to write a novel, but I highly recommend creating a docstring in your first draft that includes at least these basics:\n• A brief summary of what the function does\n• A list of the parameters/arguments including name, data type(s) accepted, whether it’s optional or required, and brief description of what the value or object should represent\n• A description of what the function returns, if anything\n• If there is anything you specifically know your function does NOT support yet, include that information as well\n\nSee the PEP docstring conventions here for more best practices.\n\nAt this point we’ve made a basic function for exploring data by showing visualizations and statistics and running a normality test. I’ve tested it on a few of my predictor columns, and confirmed it works.\n\nI initially developed this example function using just two predictor columns, both of which were continuous numeric variables. The method proved useful, and I gained valuable insight into these types of variables by plotting a histogram, boxplot, and scatterplot against the target. But if I also have categorical variables or binary variables, I probably need to use other methods to understand the distribution of the values and how they relate to the target.\n\nBy keeping my first draft simple I was able to get a working and useful function up and running fairly quickly, but at the cost of having a fairly narrow scope that may not work on future data sets.\n\nIn real life, I went back and updated the initial function a whole bunch of times to incorporate support for different types of data I encountered, and make the output more flexible. Here’s a list of some of the things I eventually updated, so you can get a sense for just how much more I added after the first draft:\n• Added logic to evaluate what type of data was in each column (continuous or categorical) based partly on column type in the dataframe but also on the number of unique values\n• Depending on data type, generated different types of graphs and statistics ( instead of ) for what the function judged were categorical.\n• Added parameters for each type of chart to allow them to be turned off, which involved having to make the number of axes in the figure be calculated dynamically\n• Added dynamic sizing for the matplotlib figure to allow the barplot for categorical variables to show all values even if they had high cardinality\n\nIt did take some work, but I ended up with a robust function that can handle lots of different types of data, and that I can easily reuse in many data science projects to come!\n\nThe approach of starting simple and building iteratively means you don’t have to get overwhelmed trying to think of every exception or scenario in the beginning: start with the basics and let your own usage of the first draft guide what you add in the second draft and beyond."
    },
    {
        "link": "https://w3schools.com/python/ref_string_isnumeric.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/python-string-isnumeric-method",
        "document": "The isnumeric() method is a built-in method in Python that belongs to the string class. It is used to determine whether the string consists of numeric characters or not. It returns a Boolean value. If all characters in the string are numeric and it is not empty, it returns “True” If all characters in the string are numeric characters, otherwise returns “False”.\n\nExample: In this given string we will check string contains numeric characters or not.\n\nWays to Implement the isnumeric() Method in Python\n\nIn Python, there are different libraries, functions, and methods to check if strings contain numeric characters. Here are the different ways in which we can use Isnumeric method.\n\nWe can use various methods to check if the string contains numeric characters or not. To check this we can use different approach to solve this.\n\nIn this example, the isnumeric() method is used to check the number of numeric characters and the resulting string after removing numeric characters.\n\nIt does not contain any arguments, therefore, it returns an error if a parameter is passed.\n\nWhite spaces are not considered to be numeric, therefore, it returns “False”.\n\nSubscript, Superscript, Fractions, and Roman numerals (all written in Unicode)are all considered to be numeric, Therefore, it returns “True”.\n\nIn this example, the isnumeric() method is used to check if the string “75” consists of only numeric characters.\n\nThe isnumeric() method in Python is primarily designed to work with strings. In this example, we can see the isnumeric() method may not directly support other numeric types like integers or floats, but still can utilize in combination with type conversion to perform numeric validation"
    },
    {
        "link": "https://programiz.com/python-programming/methods/string/isnumeric",
        "document": "The syntax of the method is:\n\nHere, checks if all characters in are numeric or not.\n\nThe method doesn't take any parameters.\n• -if all characters in the string are numeric\n• -if at least one character is not a numeric\n\nIn the above example, we have used the method to check whether every character in and is numeric or not.\n• - for since every character in are numeric\n• - for since every character in are not numeric\n\nExample 2: isnumeric() with Other Numeric Types\n\nPython treats mathematical characters like numbers, subscripts, superscripts, and characters having Unicode numeric value properties (like a fraction, roman numerals, currency numerators) as numeric characters.\n\nThe method returns with these characters. For example:\n\nHere, we have used the method with strings that contain superscript and fraction.\n• -returns because contains all numeric characters.\n• - returns because contains all numeric characters."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://tutorialspoint.com/python/string_isnumeric.htm",
        "document": "The python string isnumeric() method is used to check whether the string consists of numeric characters. This method returns true if all the characters in the input string are numeric and there is atleast one character. Otherwise, it returns false.\n\nThe numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.\n\nIn the following section, let us look into this method with more details.\n\nFollowing is the syntax for the python string isnumeric() method −\n\nThe python string isnumeric() method doesnot contain any parameters.\n\nThe python string isnumeric() method returns true if all characters in the string are numeric and there is at least one character and false otherwise.\n\nThe following is an example of the python string isnumeric() method. In this program, we are trying to find whether the string \"Welcome2023\" is alpha numeric.\n\nOn executing the above program, the following output is generated -\n\nlet us see another example -\n\nThe following is the output obtained by executing the above program -\n\nThe unicode representation of numbers are also considered as numeric by the isnumeric() method.\n\nThe following output is obtained by executing the above program -\n\nThe python string isnumeric() method considers unicode representation of fractions as numeric only.\n\nThe above program, on executing, displays the following output -\n\nThe Kharosthi numbers such as ,,,,,, are considered as numeric. So, the python string isnumeric() method returns true.\n\nThe output of the above program is displayed as follows -"
    },
    {
        "link": "https://medium.com/pythoneers/gracefully-handling-validation-errors-in-python-dictionaries-093ac2e8014b",
        "document": "How you can avoid dreaded ValidationError responses when sending data via API calls to Notion.\n\nI want to share some of the challenges I’ve come across building my automations and how I overcame them. I hope you find this useful.\n\nThere’s nothing worse than the excitement of sending data to Notion and receiving the dreaded undefined error response from Notion. We’ve all been there thinking — I checked and double checked. Why is this wrong?\n\nI have utilised multiple ways to handle errors in Python dictionaries before sending them to Notion. I discuss the problem of KeyErrors as well as None values in dictionaries and how Notion does not accept them as valid inputs for its API.\n\nOver the past months, I have tried to make my daily tracking updates in Notion more robust and resilient to missing data. For example, how will my automation handle missing data when I do not measure my weight or if my watch battery dies overnight and I do not have an up to date sleep metrics?\n\nMy answer is outlined below:\n\nThe high level process I use to remove None values is provided below. I will then go into more detail on what these functions actually do and provide you with some more insight in how we can remove None values from dictionaries.\n\nI wrote in more detail on the steps I take to capture garmin data and upload to Notionhere:\n\nAnyway, back to the main topic. When working with dictionaries in Python, there are several ways to handle the that may occur when accessing a key that does not exist. Here are some main approaches:\n• Using the method: Instead of directly accessing the key, you can use the method of dictionaries. This method allows you to provide a default value that will be returned if the key is not found. For example:\n• Using the operator: You can use the operator to check if a key exists in a dictionary before accessing it. This prevents the from being raised. For example: if key in my_dict: value = my_dict[key] else: value = default_value\n• Using exception handling: You can use a try-except block to catch the and handle it gracefully. By wrapping the dictionary access in a try block, you can execute alternative code in the except block if the key is not found. For example:\n\nThese are some common ways to handle with dictionaries in Python. Each approach has its own advantages and can be used depending on the specific requirements of your code.\n\nHowever, if you are using Python to send data to Notion, you may encounter some errors due to the way Notion accept dictionaries that contain database property values. Dictionaries are one of the most common and useful data structures in Python, but they also have some quirks that you need to be aware of, especially when dealing with None values.\n\nWhy None Values Are a Problem for Notion\n\nWhile the above methods help you avoid the KeyError problem, they don’t completely help with uploaded the data to Notion.\n\nNone values cause problems when you try to send them to Notion, because Notion does not accept None values as valid inputs for its API. For example, if you try to create a new page in Notion using a dictionary that contains a key with a None value, you will get an error like this:\n\nAs you can see, Notion expects the value of the text content property to be defined, but instead it receives a None value, which is undefined. This causes the API to reject the request and raise a validation error with Status Code: 400\n\nYou can find more about Notion Error Codes here:\n\nTo avoid this error, you can need to remove any keys that have None values from your dictionary before sending it to Notion. This will ensure that your dictionary only contains valid and meaningful data that Notion can process and store.\n\nHow to Remove None Values from a Dictionary in Python\n\nThere are several ways to remove None values from a dictionary in Python, but one of the simplest and most elegant ways is to use a dictionary comprehension. A dictionary comprehension is a concise and expressive way to create a new dictionary from an existing one, by applying some condition or transformation to each key-value pair.\n\nFor example, to remove any keys that have None values from a dictionary, you can use a dictionary comprehension like this:\n\nThe dictionary comprehension iterates over each key-value pair in the original dictionary, and only keeps the ones that have a value that is not None. The result is a new dictionary that does not contain any None values.\n\nYou can then send the clean dictionary to Notion.\n\nHow to Remove None Values from a Nested Dictionary in Python\n\nThe previous method works well for a flat dictionary, but what if you have a nested dictionary, as Notion requires. The values you send are nested dictionaries! For example, suppose you have a dictionary like this:\n\nAs you can see, the dictionary has two None values, one in the Water_ML property and one in the BMI property. If you try to use the same dictionary comprehension as before, you will not remove any of the properties, because the dictionary comprehension does not recurse into the nested dictionaries. The result will be a dictionary like this:\n\nThis dictionary still contains a None value in the Water_ML value, which will cause an error when sending it to Notion.\n\nTo remove all None values from a nested dictionary, I use two helper functions. One is used to identify if the value for a particular key is a dictionary or not. If it is not, I would check if its value is None. If it is a dictionary, I check if the key contains null, number, rich_text, or plain-text as these are the property types used in notion.\n\nIn order to remove the keys which contain a dictionary and a none value in that dictionary, you can utilise two functions to determine if the value in a key value pair is to be removed (ie the nested dictionary contains a None Value) and another which is essentially a dictionary comprehension to then actually remove the key:\n\nI will then use this function within another function to remove the actual keys.\n\nIn this article, I showed you how you can clean up your Python dictionaries before sending them to Notion, by removing any keys that have None values. This will ensure that your data is consistent and compatible with Notion’s API, and avoid any potential errors or data loss.\n\nI also showed you how to use a dictionary comprehensions and helper functions to remove None values from both flat and nested dictionaries, using simple and elegant Python code.\n\nI hope you found this article useful and informative. If you have any questions or feedback, please let me know in the comments.\n\nThank you for reading. 😊"
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary",
        "document": "A Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can’t be repeated and must be immutable.\n\nExample: Here, The data is stored in key:value pairs in dictionaries, which makes it easier to find values.\n\nIn Python, a dictionary can be created by placing a sequence of elements within curly {} braces, separated by a ‘comma’.\n• Dictionary keys are case sensitive: the same name but different cases of Key will be treated distinctly.\n• Keys must be immutable: This means keys can be strings, numbers, or tuples but not lists.\n• Keys must be unique: Duplicate keys are not allowed and any duplicate key will overwrite the previous value.\n• None . Hence, operations like search, insert, delete can be performed in Constant Time\n\nWe can access a value from a dictionary by using the key within square brackets orget()method.\n\nWe can add new key-value pairs or update existing keys by using assignment.\n\nWe can remove items from dictionary using the following methods:\n• None : Removes an item by key and returns its value.\n• None : Removes and returns the last key-value pair.\n\nWe can iterate over keys [using keys() method] , values [using values() method] or both [using item() method] with a for loop.\n\nRead in detail – Ways to Iterating Over a Dictionary\n• None Check if two arrays are equal or not\n• None Max distance between two occurrences in array\n• None Count all pairs with absolute difference equal to k\n• None Remove minimum elements such that no common elements exist in two arrays\n• None Count distinct elements in every window of size k\n\nHow to use dictionaries in Python?\n\nHow to print dictionaries in Python?\n\nHow to declare a dictionary in Python?\n\nWhat are dictionary keys and values in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/15078519/python-dictionary-passed-as-an-input-to-a-function-acts-like-a-global-in-that-fu",
        "document": "I am very confused by the behaviour below. Cases 1, 3, and 4 perform as I would expect, but case 2 does not. Why does case 2 allow the function to change the value of the dictionary entry globally, even though the dictionary is never returned by the function? A main reason I am using functions is to isolate everything in the function from the rest of the code, but this does not seem to be possible if I choose to use the same variable names inside of the function. I was under the understanding that anything explicitly defined in a function is local to that function, but this does not seem to be the case if the dictionary is defined and passed as an input to the function."
    },
    {
        "link": "https://geeksforgeeks.org/python-dictionary-methods",
        "document": "Python dictionary methods is collection of Python functions that operates on Dictionary.\n\nPython Dictionary is like a map that is used to store data in the form of a key: value pair. Python provides various built-in functions to deal with dictionaries. In this article, we will see a list of all the functions provided by Python to work with dictionaries.\n\nPython provides several built-in methods for dictionaries that allow for efficient manipulation, access, and transformation of dictionary data. Here’s a list of some important Python dictionary methods:\n\nThese methods provide various functionalities for working with dictionaries in Python, making it easier to manage and manipulate data stored in key-value pairs.\n\nNote: For more information on Python Dictionary refer to Python Dictionary Tutorial.\n\nIn Python Dictionary we have various built-in functions that provide a wide range of operations for working with dictionaries. These techniques enable efficient manipulation, access, and transformation of dictionary data.\n\nLets Look at some Python dictionary methods with examples:\n\nThe clear() method in Python is a built-in method that is used to remove all the elements (key-value pairs) from a dictionary. It essentially empties the dictionary, leaving it with no key-value pairs.\n\nIn Python, the get() method is a pre-built dictionary function that enables you to obtain the value linked to a particular key in a dictionary. It is a secure method to access dictionary values without causing a KeyError if the key isn’t present.\n\nIn Python, the items() method is a built-in dictionary function that retrieves a view object containing a list of tuples. Each tuple represents a key-value pair from the dictionary. This method is a convenient way to access both the keys and values of a dictionary simultaneously, and it is highly efficient.\n\nThe keys() method in Python returns a view object with dictionary keys, allowing efficient access and iteration.\n\nPython’s update() method is a built-in dictionary function that updates the key-value pairs of a dictionary using elements from another dictionary or an iterable of key-value pairs. With this method, you can include new data or merge it with existing dictionary entries.\n\nThe values() method in Python returns a view object containing all dictionary values, which can be accessed and iterated through efficiently.\n\nIn Python, the pop() method is a pre-existing dictionary method that removes and retrieves the value linked with a given key from a dictionary. If the key is not present in the dictionary, you can set an optional default value to be returned.\n\nThe popitem() method in Python dictionaries is used to remove and return the last inserted key-value pair as a tuple. If the dictionary is empty then it raises a KeyError.\n\nQ2: How we can access values in a Python dictionary?\n\nQ3: What happens when we try to access a key that doesn’t exist in the dictionary?\n\nQ4: How do we remove an item from a dictionary?"
    },
    {
        "link": "https://stackoverflow.com/questions/26655230/update-method-of-python-dictionary-did-not-work",
        "document": "I want to combine them to .\n\nAs this says, can complete it. But when I try, I get:\n\nWould anyone like to explain it to me why I cannot gain a dict type?\n\nI also tried this, and it did well:\n\nWhat is the difference between these two methods and why did the first one not work?"
    }
]