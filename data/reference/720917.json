[
    {
        "link": "https://stackoverflow.com/questions/68730566/how-can-i-fix-this-jda-discord-bot-error",
        "document": "Reach devs & technologists worldwide about your product, service or employer brand"
    },
    {
        "link": "https://stackoverflow.com/questions/53617357/getting-exception-in-onguildmessagereceivedevent-discord-jda",
        "document": "I am making a Discord JDA bot that can when a user sends the message: Prefix(\"$\") + hastebin + their code, the bot will create a request to hastebin and paste their code, after that he will take the paste URL and print it to the console(I will send it as a message after I solve the problem).\n\nThis is my HastebinCommand class:\n\nThis is my Hastebin request class:\n\nI would really appreciate getting help after trying to solve my problem for so long."
    },
    {
        "link": "https://github.com/DV8FromTheWorld/JDA/issues/304",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/ExperiencedDevs/comments/1af490p/what_is_your_practice_regarding_error_handling",
        "document": "Let's say I call a service that does some math, let's call it , and for some reason the math fails. gives me some pretty detailed information about what failed -- which might include information. I don't want to divulge, since I have no real control over what that library is doing.\n\nShould I pass that very detailed information onto the front end? Or should I obfuscate it behind something like \"sorry fancyStats failed, please try again later\"?\n\nI know where I come down on this, I just don't know where I picked it up. So if anybody has an article that explains why sending the raw error messages to the front end is a bad idea, please share it. It feels like a potential security risk to me. You have no idea what information might be coming back from that call and if you just pass it to the API caller you might be revealing sensitive information that could be used to compromise your API. I'm saying obfuscation is better than detail when it comes to things that somebody could use to attack you.\n\nEdit: this is GQL so we can send back more than just an HTTP status code"
    },
    {
        "link": "https://jda.wiki/using-jda/troubleshooting",
        "document": "This is a collection of common issues and recommended solutions.\n\nDidn't find an answer? Try asking in our Discord server\n\nWhen you call or the JDA instance will stop all of its threads. However, if HTTP/2 was used by the instance it will keep the JVM running due to a timeout thread for http connections. This can be terminated by shutting it down manually:\n\nAn error like or similar means you are not including your dependencies or transitive dependencies in the archive.\n\nThis exception indicates that the token you have used in your is not a valid bot token. Usually, this means you tried using the secret instead of the bot token. To get your token, follow these steps:\n‚Ä¢ On the left side, click the Bot tab\n‚Ä¢ If you don't have a bot yet, you must create one\n‚Ä¢ Once you have a bot, there is a token section. Click COPY.\n‚Ä¢ The token is now in your clipboard and you can paste it into your code\n\nIf you follow these steps and you still get the same exception, it could be due to one of these problems:\n‚Ä¢ You included excess whitespace in your string. The token string should not include any newlines or spaces.\n‚Ä¢ You were banned from the API or your server is hosted on a public hosting platform like Glitch or Heroku.\n‚Ä¢ The token is not for a bot account, we do not support client accounts.\n\nA valid token looks like this:\n\nCan't get emoji from message¬∂\n\nMethods such as and only include custom emoji which have to be uploaded to a guild by a moderator. Unicode emoji such as üëç are not included and require using a 3rd party library to be located in a string. You can use emoji-java to extract unicode emoji from a message.\n\nAn example use-case including a code sample can be found in this answer to a related question on StackOverflow\n\nWhen JDA encounters an issue while executing a it will emit an error through the failure callback. You can handle this by adding a second callback to , for example: .\n\nYou can use ErrorHandler to handle or ignore specific ErrorResponse failures.\n\nNothing happens when using X¬∂\n\nIn JDA we make use of async rate-limit handling through the use of the common RestAction class. \n\nWhen you have code such as or nothing actually happens. This is because both as well as return a instance. You are not done here since that class is only an intermediate step to executing your request. Here you can decide to use async (recommended) or or the blocking (not recommended).\n\nYou might notice that returns . This is because it's async and uses callbacks instead. Read More\n\nIf you do have a then maybe your code doesn't even run? Try putting a right before and after your code and see if it prints. If not, then read this My event listener code is not executed.\n\nMy event listener code is not executed¬∂\n\nThere are many reasons why your event listener might not be executed but here are the most common issues:\n‚Ä¢ You are using a deprecated or removed part of JDA, such as . \n\nUse the replacement that is documented, for example .\n‚Ä¢ You are using the wrong login token. \n\nIf the token is for another bot which doesn't have access to the desired guilds then the event listener code cannot run.\n‚Ä¢ Your bot is not actually in the guild. \n\nMake sure your bot is online and has access to the resource you are trying to interact with.\n‚Ä¢ You never registered your listener. \n\nUse on either the or instance\n‚Ä¢ You did not override the correct method. \n\nUse and see if it fails. Your method has to use the correct name and parameter list defined in . Read More.\n‚Ä¢ You don't actually extend or . \n\nYour class should either use or .\n‚Ä¢ You are missing a required for this event. \n\nMake sure that you on the to allow the events to be received.\n‚Ä¢ The event has other requirements that might not be satisfied such as the cache not being enabled. \n\nPlease check the requirements on the event documentation.\n\nIf none of the above apply to you then you might have an issue in your listener's code, at that point you should use a debugger.\n\nThis warning implies your event thread is too busy and will block critical events from being received. You should try to limit blocking calls and make sure your event handlers don't take up too much time. Do profiling to figure out what takes so long or create a thread dump when you get this warning to see where the issue is.\n\nBy default, all events are handled on the same thread they get received and handled on. If you block this thread for too long then JDA cannot keep up with important lifecycle events sent by Discord. Either you start writing non-blocking code (replace with etc.) or you use a thread pool for your event handling.\n\nWhen you get an exception like this, that means one of the event listeners you registered does not implement the interface provided by JDA.\n\nThis is not a valid event listener class:\n\nYou can either use ListenerAdapter or EventListener:\n\nWhen using EventListener make sure you actually imported the correct interface from JDA and not :\n\nThis error can occur when trying to reload a plugin in various minecraft frameworks. The cause of this error is a quirk with how plugin loading works, where it disables class loading when disabling the plugin. This causes problems when JDA hasn't finished shutting down all of its internal threads yet.\n\nThe best way to handle this is to use :\n\nAlternatively, you can also use immediately and then use . This will prevent any currently queued requests from executing and immediately stop the threads.\n\nIn general, using is frowned upon due to its unsafe and buggy nature. It is recommended to use alternative measures to reload your plugin, as recommended in this article by the WorldEdit author.\n\nWhen Discord emits a or they only provide the new content of the message. Since JDA does not keep a cache of messages it is unable to provide the previous content. Instead you will have to track content of messages yourself.\n\nPreventing use of complete() in callback threads¬∂\n\nThe following code will illustrate an issue where callbacks might cause a deadlock\n\nSince we decided to use a single-thread pool (1) we only have one thread to execute callbacks. This thread is used by the first callback (2) and cannot be used for the second callback (3).\n\nDue to this reason we simply don't allow using in any callback threads at all. If you use callbacks you should use .\n\nWhen you update your game or online status you emit a socket message to Discord. If you do that often enough you hit a limit and JDA has to backoff for 60 seconds.\n\nThings that contribute to the WebSocket RateLimit include:\n\nIt is also possible that you get spammed by this warning if you use (this is done when using ). If your bot is in more than 120 guilds then this warning is unavoidable when using member chunking. It is recommended to use to reduce the startup time and get rid of this warning. If chunking on startup is absolutely necessary, you have to accept this warning.\n\nThere are many ways to retrieve members: Loading Members\n\nI explained this in a bit more detail in issue #1290\n\nTo make chunking a little more efficient, you can additionally enable the . This will load all online members for each guild directly, instead of relying on additional member chunk requests, which can be a significant boost to reduce startup time and potentially reduce these warnings.\n\nWhen the internal jda rate-limiter fails to predict a rate limit bucket the HTTP response is . This means the request has to be retried. If you see this a lot (many times per minute), then JDA might have an issue with the rate limit handling of that route. If you use it could also mean that your clock is not properly synchronizing with NTP.\n\nEncountering the global rate-limit is something JDA cannot predict or prevent. This rate-limit implies you sent too many requests in total across all routes. Discord limits how much HTTP traffic a client is allowed to do and will tell us to limit all requests for a specified time interval. You should avoid hitting this too often.\n\nCannot get reference as it has already been Garbage Collected¬∂\n\nDue to how we structure cache we sometimes have to invalidate our entire cache (that's just how Discord works). When you store references to JDA entities for a long period of time such as a field you will suffer with the error java.lang.IllegalStateException: Cannot get reference as it has already been Garbage Collected once the entity was removed from the JDA cache. We highly recommend to store only the parts you actually need of the specific entity such as and use something like .\n\nEntities that should not be stored for a long period of time include:\n\nInstead store IDs of the entities, or for messages simply the parts you need such as content.\n\nThe default behavior in is to only cache members connected to voice channels. If you need members to be cached, for example to lookup users by roles, then you have to enable this explicitly.\n\nI explained this in this wiki page and this stackoverflow answer.\n\nThere are many ways you can retrieve members dynamically: Loading Members\n\nCannot get message content / Attempting to access message content without GatewayIntent¬∂\n\nWhen you receive this warning, that means you tried to access the content of a message without the privileged .\n\nAs of JDA version 5.0.0-alpha.14, you are required to enable this intent explicitly with on your or .\n\nThis affects anyone who accesses these methods on messages:\n\nYou are also required to enable this in your application dashboard. Note, however, that this is a privileged intent and will require a valid use-case for your bot to be verified in over 75 servers.\n\nThis means you tried to use , , or without enabling it in your application dashboard. To use these privileged intents you first have to enable them.\n‚Ä¢ Under the Privileged Gateway Intents section, enable the intents that you are using in your bot. Toggle on SERVER MEMBERS INTENT, PRESENCE INTENT, or MESSAGE CONTENT INTENT depending on your needs.\n\nIf you use these intents you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent you have to verify your bot. This will be available in your application dashboard when the bot joins at least 75 guilds.\n\nThe application did not respond¬∂\n\nThis means you didn't acknowledge or reply to an interaction in time. You only have 3 seconds to reply or acknowledge. You have to use , , , or . (If you don't it won't do it) \n\nMake sure your event listener code is executed.\n\nThis exception can happen due to two reasons:\n\nThe interaction took longer than 3 seconds to be acknowledged¬∂\n\nPossible reasons why your response was too slow:\n‚Ä¢ JDA's WebSocket thread was blocked for too long, when you see the This application did not respond on Discord, make a thread dump and look at the stack trace around to see where it may have blocked\n‚Ä¢ Your interaction took too long to acknowledge, you can use to extend the response time to 15 minutes\n\nThe interaction was acknowledged by another process running the same bot¬∂\n\nYou can confirm this by checking if your bot replied, or the three dots in a button disappeared without saying , or you see '[Bot] is thinking...' for more than 3 seconds.\n\nTo resolve this, try stopping all current processes for the bot that could be responsible, or resetting your bot token.\n\nThis means you sent followup messages through or similar but never acknowledged the interaction."
    },
    {
        "link": "https://stackoverflow.com/questions/507522/java-capturing-system-err-println-or-capturing-a-printstream",
        "document": "I need to capture the text being written to a printStream by a 3rd party component.\n\nThe PrintStream is defaulted to System.err, but can be changed to another PrintStream.\n\nLooking through the docs, I couldn't find an easy way to direct the contents of a PrintStream to a string writer / buffer.\n\nCan someone please assist?"
    },
    {
        "link": "https://stackoverflow.com/questions/14715748/redirect-system-out-and-system-err",
        "document": "Just to add to Rick's and Mikhail's solutions, which are really the only option in this scenario, I wanted to give an example of how creating a custom OutputStream can potentially lead to not so easy to detect/fix problems. Here's some code:\n\nThis example shows the pitfalls of using a custom output stream. For simplicity the write() function uses a log4j logger, but this can be replaced with any custom logging facility (such as the one in my scenario). The main function creates a PrintStream that wraps a CustomOutputStream and set the output stream to point to it. Then it executes a System.out.println() statement. This statement is redirected to the CustomOutputStream which redirects it to a logger. Unfortunately, since the logger is lazy initialized, it will acquire a copy of the console output stream (as per the log4j configuration file which defines a ConsoleAppender) too late, i.e., the output stream will point to the CustomOutputStream we just created causing a redirection loop and thus a StackOverflowError at runtime.\n\nNow, with log4j this is easy to fix: we just need to initialize the log4j framework before we call System.setOut(), e.g., by uncommenting the first line of the main function. Luckily for me, the custom logging facility I have to deal with is just a wrapper around log4j and I know it will get initialized before it's too late. However, in the case of a totally custom logging facility that uses System.out/err under the cover, unless the source code is accessible, it's impossible to tell if and where direct calls to System.out/err are performed instead of calls to a PrintStream reference acquired during initialization. The only work around I can think of for this particular case would be to retrieve the function call stack and detect redirection loops, since the write() functions should not be recursive."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html",
        "document": "\n‚Ä¢ origin time (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin. Returns the current value of the running Java Virtual Machine's high-resolution time source, in nanoseconds. This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time. The value returned represents nanoseconds since some fixed but arbitrarytime (perhaps in the future, so values may be negative). The same origin is used by all invocations of this method in an instance of a Java virtual machine; other virtual machine instances are likely to use a different origin. This method provides nanosecond precision, but not necessarily nanosecond resolution (that is, how frequently the value changes) - no guarantees are made except that the resolution is at least as good as that of . Differences in successive calls that span greater than approximately 292 years (263 nanoseconds) will not correctly compute elapsed time due to numerical overflow. The values returned by this method become meaningful only when the difference between two such values, obtained within the same instance of a Java virtual machine, is computed. For example, to measure how long some code takes to execute: To compare elapsed time against a timeout, use instead of because of the possibility of numerical overflow. instead ofbecause of the possibility of numerical overflow. the current value of the running Java Virtual Machine's high-resolution time source, in nanoseconds\n‚Ä¢ to the destination array referenced by . The number of components copied is equal to the argument. The components at positions through in the source array are copied into positions through , respectively, of the destination array. Copies an array from the specified source array, beginning at the specified position, to the specified position of the destination array. A subsequence of array components are copied from the source array referenced byto the destination array referenced by. The number of components copied is equal to theargument. The components at positionsthroughin the source array are copied into positionsthrough, respectively, of the destination array. If the and arguments refer to the same array object, then the copying is performed as if the components at positions through were first copied to a temporary array with components and then the contents of the temporary array were copied into positions through of the destination array. If is , then a is thrown. If is , then a is thrown and the destination array is not modified. Otherwise, if any of the following is true, an is thrown and the destination is not modified:\n‚Ä¢ The argument refers to an object that is not an array.\n‚Ä¢ The argument refers to an object that is not an array.\n‚Ä¢ The argument and argument refer to arrays whose component types are different primitive types.\n‚Ä¢ The argument refers to an array with a primitive component type and the argument refers to an array with a reference component type.\n‚Ä¢ The argument refers to an array with a reference component type and the argument refers to an array with a primitive component type. Otherwise, if any of the following is true, an is thrown and the destination is not modified:\n‚Ä¢ is greater than , the length of the source array.\n‚Ä¢ is greater than , the length of the destination array. Otherwise, if any actual component of the source array from position through cannot be converted to the component type of the destination array by assignment conversion, an is thrown. In this case, let k be the smallest nonnegative integer less than length such that k cannot be converted to the component type of the destination array; when the exception is thrown, source array components from positions through k will already have been copied to destination array positions through k and no other positions of the destination array will have been modified. (Because of the restrictions already itemized, this paragraph effectively applies only to the situation where both arrays have component types that are reference types.) - the number of array elements to be copied. - if copying would cause access of data outside array bounds. - if an element in the array could not be stored into the array because of a type mismatch. - if either or is .\n‚Ä¢ method is called with no arguments. This may result in a security exception. Determines the current system properties. First, if there is a security manager, itsmethod is called with no arguments. This may result in a security exception. The current set of system properties for use by the method is returned as a object. If there is no current set of system properties, a set of system properties is first created and initialized. This set of system properties includes a value for each of the following keys unless the description of the associated value indicates that the value is optional. Description of Associated Value Java Runtime Environment version, which may be interpreted as a Java Runtime Environment version date, in ISO-8601 YYYY-MM-DD format, which may be interpreted as a Java Virtual Machine specification version, whose value is the feature element of the runtime version Java Virtual Machine implementation version which may be interpreted as a Java Runtime Environment specification version, whose value is the feature element of the runtime version Java Runtime Environment specification maintenance version, may be interpreted as a positive integer (optional, see below) List of paths to search when loading libraries Name of JIT compiler to use Character encoding name derived from the host environment and/or the user's settings. Setting this system property has no effect. The property is defined if the specification implemented by this runtime at the time of its construction had undergone a maintenance release. When defined, its value identifies that maintenance release. To indicate the first maintenance release this property will have the value , to indicate the second maintenance release this property will have the value , and so on. Multiple paths in a system property value are separated by the path separator character of the platform. Note that even if the security manager does not permit the operation, it may choose to permit the operation. Changing a standard system property may have unpredictable results unless otherwise specified. Property values may be cached during initialization or on first use. Setting a standard property after initialization using , , , or may not have the desired effect. In addition to the standard system properties, the system properties may include the following keys: Description of Associated Value The module name of the initial/main module The main class name of the initial module - if a security manager exists and its method doesn't allow access to the system properties.\n‚Ä¢ Gets the value of the specified environment variable. An environment variable is a system-dependent external named value. If a security manager exists, its method is called with a permission. This may result in a being thrown. If no exception is thrown the value of the variable is returned. System properties and environment variables are both conceptually mappings between names and values. Both mechanisms can be used to pass user-defined information to a Java process. Environment variables have a more global effect, because they are visible to all descendants of the process which defines them, not just the immediate Java subprocess. They can have subtly different semantics, such as case insensitivity, on different operating systems. For these reasons, environment variables are more likely to have unintended side effects. It is best to use system properties where possible. Environment variables should be used when a global effect is desired, or when an external system interface requires an environment variable (such as ). On UNIX systems the alphabetic case of is typically significant, while on Microsoft Windows systems it is typically not. For example, the expression is likely to be true on Microsoft Windows. - the name of the environment variable the string value of the variable, or if the variable is not defined in the system environment - if a security manager exists and its method doesn't allow access to the environment variable\n‚Ä¢ Runs the garbage collector in the Java Virtual Machine. Calling the method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for reuse by the Java Virtual Machine. When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all unused objects. There is no guarantee that this effort will recycle any particular number of unused objects, reclaim any particular amount of space, or complete at any particular time, if at all, before the method returns or ever. There is also no guarantee that this effort will determine the change of reachability in any particular number of objects, or that any particular number of objects will be cleared and enqueued. The call is effectively equivalent to the call:"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/PrintStream.html",
        "document": "\n‚Ä¢ method will be invoked on the underlying output stream. Writes the specified byte to this stream. If the byte is a newline and automatic flushing is enabled then themethod will be invoked on the underlying output stream. Note that the byte is written as given; to write a character that will be translated according to the platform's default character encoding, use the or methods. - The byte to be written\n‚Ä¢ bytes from the specified byte array starting at offset to this stream. If automatic flushing is enabled then the method will be invoked on the underlying output stream. Writesbytes from the specified byte array starting at offsetto this stream. If automatic flushing is enabled then themethod will be invoked on the underlying output stream. Note that the bytes will be written as given; to write characters that will be translated according to the platform's default character encoding, use the or methods. - Offset from which to start taking bytes\n‚Ä¢ method will be invoked on the underlying output stream. Writes all bytes from the specified byte array to this stream. If automatic flushing is enabled then themethod will be invoked on the underlying output stream. Note that the bytes will be written as given; to write characters that will be translated according to the platform's default character encoding, use the or methods. Although declared to throw , this method never actually does so. Instead, like other methods that this class overrides, it sets an internal flag which may be tested via the method. To write an array of bytes without having to write a block for the , use either or . This method is equivalent to .\n‚Ä¢ Appends the specified character sequence to this output stream. An invocation of this method of the form behaves in exactly the same way as the invocation Depending on the specification of for the character sequence , the entire sequence may not be appended. For instance, invoking then method of a character buffer will return a subsequence whose content depends upon the buffer's position and limit. - The character sequence to append. If is , then the four characters are appended to this output stream."
    },
    {
        "link": "https://geeksforgeeks.org/system-out-println-in-java",
        "document": "Java System.out.println() is used to print an argument that is passed to it.\n\nThe statement can be broken into 3 parts which can be understood separately:\n‚Ä¢ System: It is a final class defined in the\n‚Ä¢ out: This is an instance of type, which is a public and static member field of the\n‚Ä¢ println(): As all instances of the have a public method println(), we can invoke the same on out as well. This is an upgraded version of print(). It prints any argument passed to it and adds a new line to the output. We can assume that System.out represents the Standard Output Stream.\n\nParameters: The parameter might be anything that the user wishes to print on the output screen.\n\nBelow is the implementation of System.out.println :\n\nBelow is the implementation of System.out.println :\n\nJust like System.out, Java provides us with two other standard or default input-output streams:\n‚Ä¢ System.in : This is the standard input stream that is used to read characters from the keyboard or any other standard input device. Example:\n‚Ä¢ System.err : This is the standard error stream that is used to output all the error data that a program might throw, on a computer screen or any standard output device. \n\nExample:\n\nAs we know, Method Overloading in Java allows different methods to have the same name, but different signatures or parameters where each signature can differ by the number of input parameters or type of input parameters or both. From the use of println() we observed that it is a single method of PrintStream class that allows the users to print various types of elements by accepting different type and number of parameters.\n\nPrintStream has around 10 different overloads of println() method that are invoked based on the type of parameters passed by the user.\n\nThis method prints the text on the console and the cursor remains at the end of the text at the console. The next printing takes place from just here. This method must take at least one parameter else it will throw an error.\n\nThis method prints the text on the console and the cursor remains at the start of the next line at the console. The next printing takes place from the next line. This method may or may not take any parameter.\n\nprintln() is a method that helps display output on a console. This might be dependent on various factors that drive the performance of this method. The message passed using println() is passed to the server‚Äôs console where kernel time is required to execute the task. Kernel time refers to the CPU time. Since println() is a synchronized method, so when multiple threads are passed could lead to the low-performance issue. System.out.println() is a slow operation as it incurs heavy overhead on the machine compared to most IO operations. There is an alternative way of performing output operations by invoking PrintWriter or the BufferedWriter class. They are fast as compared to the println() of the PrintStream class."
    }
]