[
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://red-gate.com/simple-talk/databases/sql-server/performance-sql-server/the-except-and-intersect-operators-in-sql-server",
        "document": "Quite often, you’re faced with the task of comparing two or more tables, or query results, to determine which information is the same and which isn’t. One of the most common approaches to doing such a comparison is to use the UNION or UNION ALL operator to combine the relevant columns of the results that you want to compare. As long as you adhere to the restrictions placed on either of those operators, you can combine data sets whether they come from different databases or even different servers. With the UNION operator, you end up with a result containing every distinct row from the two results combined. However, it becomes more difficult to use UNION to return only the common data that is held in both results, or the different data that exists in one table but not the other(s). To get the results you need, you must use UNION ALL with a GROUP BY clause, though the logic isn’t always obvious on how to do this. And it isn’t any easier to use a JOIN operator to get the result you want. .\n\nEnter the INTERSECT and EXCEPT operators. Beginning with SQL Server 2005, you can use these operators to combine queries and get the results you need. For instance, you can use the INTERSECT operator to return only values that match within both data sets, as shown in the following illustration .\n\nThe illustration shows how the INTERSECT operator returns data that is common to both results set; the common data is represented by the area where the two circles intersect. The illustration also shows how the EXCEPT operator works; only data that exists in one of the data sets outside the intersecting area is returned. For instance, if Set A is specified to the left of the EXCEPT operator, only values that are not in Set B are returned. In the illustration above, that would be the data in the left circle, outside the section where the two data sets intersect. The following bullets sum up which operator to use to return different combinations of data:\n• To return the data in Set A that doesn’t overlap with B, use A EXCEPT B.\n• To return only the data that overlaps in the two sets, use A INTERSECT B.\n• To return the data in Set B that doesn’t overlap with A, use B EXCEPT A.\n• To return the data in all three areas without duplicates, use A UNION B.\n• To return the data in all three areas, including duplicates, use A UNION ALL B.\n• To return the data in the non-overlapping areas of both sets, use (A UNION B) except (A INTERSECT B), or perhaps (A EXCEPT B) UNION (B EXCEPT A)\n\nThe differences between the INTERSECT and EXCEPT operators and how to use each of them will become clearer as we work through the examples in the article. Just to give you a basic idea of how they work, we’ll start with a rather unrealistic example. To demonstrate those, however, we must first create two test views (using SQL Server 2005-compatible syntax). The first view contains a single column that describes what you might have had for lunch:\n\nThe second view also contains a single column and describes what you might have had for dinner:\n\nNow we can use these two views to demonstrate how to use the UNION, INTERSECT, and EXCEPT operators. I’ve also included a couple examples that use the JOIN operator to demonstrate the differences.\n\nThe first example uses the UNION operator to join the two views in order to return everything you’ve eaten today:\n\nNow we return the same data by using a full outer join:\n\nNotice that the join requires more complex syntax; however, both statements return the same results, as shown in the following table:\n\nNow let’s look at how you would return only the food you ate (or drank) for lunch, but did not have for dinner:\n\nIn this case, I used the EXCEPT operator to return the lunch-only items. I could have achieved the same results using the following left outer join:\n\nOnce again, you can see that the join is more complex, though the results are the same, as shown in the following table:\n\nIf you wanted to return those items you had for dinner but not lunch, you can again use the EXCEPT operator, but you must reverse the order of the queries, as shown in the following example:\n\nNotice that I first retrieve the data from the Dinner view. To use the left outer join, you would again have to reverse the order of the tables:\n\nAs expected, the results are the same for both SELECT statements:\n\nIn the next example, I use the INTERSECT operator to return only the food that was eaten at both meals:\n\nAs you can see, I simply connect the two queries with the INTERSECT operator, as I did with the EXCEPT operator. You can achieve the same results by using an inner join:\n\nAs the following results show, the only items you had at both meals were olives, bread, and coffee:\n\nNow let’s look at how you would return a list of food that you ate at one of the meals, but not both meals, in other words, the food you ate other than bread, olives, and coffee. In the following statement, I use a UNION operator to join two SELECT statements:\n\nNotice that first statement retrieves only the food you ate for lunch, and the second statement retrieves only the food ate for dinner. I achieve this in the same way I did in previous examples-by using the EXCEPT operator. I then used the UNION operator to join the two result sets. You can achieve the same results by using a full outer join:\n\nIn both examples, the statements return the following results:\n\nFrom this point on, I developed the examples on a local instance of SQL Server 2008 and the AdventureWorks2008 database. Each example uses either the INTERSECT or EXCEPT operator to compare data between the Employee and JobCandidate tables, both part of the HumanResources schema. The comparison is based on the BusinessEntityID column in each table. The BusinessEntityID column in the Employee table is the primary key. In the JobCandidate table, the BusinessEntityID column is a foreign key that references the BusinessEntityID column in the Employee table. The column in the JobCandidate table also permits null values.\n\nAs I mentioned above, when you use the INTERSECT operator to combine queries, the data returned is only that which matches between the two data sets. That means, with regard to the Employee and JobCandidate tables, the result set will include only rows in which the BusinessEntityID value in the Employee table matches the BusinessEntityID value in the JobCandidate table.\n\nIn the following example, I create two queries that retrieve data from the Employee and JobCandidate tables and use the INTERSECT operator to combine those queries:\n\nThe first SELECT statement, as you can see, retrieves the BusinessEntityID column from the Employee table, and the second SELECT statement retrieves the BusinessEntityID column from the JobCandidate table. The INTERSECT operator combines the two queries.\n\nWhen you use the INTERSECT operator to combine queries (or EXCEPT, for that matter), the number of columns must be the same in both queries and the columns must be in the same order. In addition, the corresponding columns between the queries must be configured with compatible data types. The example above meets these conditions because each query returns only one column of the same data type (INT). When the INTERSECT operator is used to combine these the two queries, the statement returns the following results:\n\nAs it turns out, the Employee table and JobCandidate table have only two BusinessEntityID values in common. If you were to examine the data in the JobCandidate table, you would find that the query results here are consistent with the data in that table. The table contains only 13 rows, and the BusinessEntityID column is NULL for all but two of the rows. The BusinessEntityID values in those rows are 212 and 274. And, as you would expect, the Employee table also contains a row with a BusinessEntityID value of 212 and a row with a value of 274.\n\nCertainly, as the above example indicates, using the INTERSECT operator to combine the results of two queries together is a straightforward process. The key, as I’ve stated, is to make sure the SELECT lists in the two queries are in sync with each other.\n\nHowever, that also points out one of the limitations of using the INTERSECT operator to combine queries-and that is, you cannot include columns in one query that are not included of the second query. If you do include multiple matching columns in each query, all the column values must match in order for a row to be returned. For example, suppose you’re retrieving data from two tables that each include columns for employee IDs, first names, and last names. If you want to match the two tables based on those three columns, the three values in the first table must match the three values in the second table for a row to be returned. (At this point, you might be asking yourself what you’re doing with all that redundant data in your database.)\n\nInstead of taking this approach, you may decide to compare the IDs in both tables, but pull the first and last name from only one of the tables. Or you might decide that you want to pull information from one table that is not stored in the other table. However, because columns must correspond between the two queries when using an INTERSECT operator to combine them, you have to find a way to work around this limitation. One of the easiest ways to do that is to put your INTERSECT construction into a common table expression (CTE) and then join the expression to one of the tables to pull the additional data. For instance, the following example includes a CTE that contains the same INTERSECT construction you saw in the example above:\n\nNotice that I’ve created a CTE named cteCandidates. As you would expect, the CTE returns the BusinessEntityID values that are contained in both the Employee and JobCandidate tables. In the primary SELECT statement, I then join the Employee table to the CTE in order to also retrieve the LoginID and JobTitle values from the Employee table. Because I put the INTERSECT join in the CTE, the statement can now return the following results:\n\nAs you can see, I’ve gotten around the limitations of the INTERSECT operator and am now returning additional information from one of the tables. I could have also joined the CTE to a different table in order to include additional information. For example, I might have joined what I have here to the Person table to retrieve the employee’s first and last names. The point is, the CTE let’s you be quite flexible when working with the INTERSECT operator; you can still determine which rows match but also return all the data you need, regardless of the source table.\n\nWorking with the EXCEPT Operator\n\nOnce you’ve mastered the INTERSECT operator, you have, for the most part, mastered the EXCEPT operator. As I stated earlier, the EXCEPT operator returns only those rows that do not have a match in the joined table. The important point to remember when using the EXCEPT operator is that it makes a difference which side of the operator you place the query. Only data from the query to the left of the operator (before the operator) is returned. Let’s look at an example to demonstrate how this works.\n\nIn the following statement, I again combine two queries, one that retrieves data from the Employee table and one that retrieves data from the JobCandidate table:\n\nThis statement is nearly identical to the INTERSECT construction you saw in the first two examples, except, of course, for the use of the EXCEPT operator. However, because the query to the left of the operator is retrieving data from the Employee table, the final result set will include data only from that table, and not the JobCandidate table.\n\nThe Employee table, as it turns out, contains 290 rows. As you’ll recall from the previous examples, the two rows in the table with the BusinessEntityID values of 212 and 274 match the two rows in the JobCandidate table that also have BusinessEntityID values of 212 and 274. That means, these two rows should be excluded from the result set of the query above, which is exactly what happens. The query returns 288 rows that have BusinessEntityID values of 1 through 290. However, IDs 212 and 274 are not included in those results.\n\nNow let’s look at what happens when you reverse the order of the queries, as I’ve done in the following example:\n\nNotice that the query that retrieves data from the JobCandidate table now comes first, that is, sits to the left of the EXCEPT operator. The results from this statement, as you would expect, are quite different from the previous example. All that is returned is a single NULL value. In other words, according to the results, the JobCandidate table contains no BusinessEntityID values that are not contained in the Employee table. This is, of course, exactly the case.\n\nAs with the CTE example above, which uses the INTERSECT operator, you can also use CTEs with EXCEPT operators. But as the last example points out, if your CTE returns no data, your main query will also return no data (at least if you’re using an inner join), but that’s true with either operator. Overall, in fact, you’ll find there’s little difference between the INTERSECT and EXCEPT operators, in terms of how you use them. The difference, of course, is in the results. INTERSECT returns rows common to both queries, and EXCEPT returns only rows in the left query. Both operators, however, are useful additions to the types of joins that the UNION and UNION ALL operators provide. You can find more details about the INTERSECT and EXCEPT operators by referring to the topic “EXCEPT and INTERSECT (Transact-SQL)” in SQL Server Books Online. There you’ll find additional information about each operator and additional examples of how to use them."
    },
    {
        "link": "https://geeksforgeeks.org/sql-server-intersect-and-except-operator",
        "document": "Multiple SQL Queries may return duplicate values in recordsets from each query result. There could be situations when a single resultset is needed to be returned by combining multiple SQL queries. In SQL Server, there are many SET operators like UNION, EXCEPT, and INTERSECT to merge multiple results of select statements to a single result set. The INTERSECT operator is one of them which is used to filter distinct values.\n\nStructured Query Language (SQL) is a powerful tool for managing and manipulating relational databases. In SQL Server, various operators allow you to perform different types of set operations on your data. Two such operators are and , which are used to compare and combine the results of two queries.\n\nThe INTERSECT operator is one of the Set Operators in SQL Server which is used to filter out duplicates and return only distinct rows of data. The INTERSET operator combines two or more SELECT statements and returns a single dataset with common and distinct data between the SELECT statements on the right and the left of the INTERSECT operator.\n• query_specification query_expression is a SELECT statement with or without a where clause.\n• None INTERSECT is the operator used to filter distinct or unique data common to the queries specified.\n\nEXCEPT keyword is an operator that is used to retrieve distinct rows from the left query result set that are not present in the right query result set in a given query. It can be useful in finding the difference between two sets of data. The syntax for the EXCEPT operator is given as follows\n\nExamples of SQL Server INTERSECT and EXCEPT Operator\n\nThere are 3 tables used in the examples below and the queries to create tables and insert data are given below:\n\nExample 1: Identifying Employees Who Also Serve as Managers\n\nIn the above example, there are two tables namely Employees and Managers. Using the INTERSECT operator the resultant dataset will return data of employees who are managers, meaning the names which exists in both Employees and Managers tables.\n\nExample 2: Identifying Employees with Java Technology Who Also Serve as Managers\n\nThe above example has where clause combining 2 SQL Queries, to all employees with Technology 'Java' and are managers.\n\nExample 3: We use EXCEPT Operator to Find the employees in the Employee Table that do not have any Project Assignments\n\nIn the example below, we use EXCEPT operator to find the employees in the Employee table that do not have any project assignments. In the Projects table, we use JOIN to find the employees that have project assignments.\n\nIn SQL Server, the INTERSECT and EXCEPT operators are used to get the common rows of two SELECT statements. The first SELECT statement retrieves the rows that are common to both SELECT statements. The second SELECT statement retrieves different rows that are not common to the two SELECT statements. These operators help to compare and analyze the data between two pairs of results in an SQL query."
    },
    {
        "link": "https://learn.microsoft.com/bs-latn-ba/SQL/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=aps-pdw-2016",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://geeksforgeeks.org/sql-intersect-except-clause",
        "document": "1. INTERSECT clause : As the name suggests, the intersect clause is used to provide the result of the intersection of two select statements. This implies the result contains all the rows which are common to both the SELECT statements. Syntax :\n\nExample : Table 1 containing Employee Details Table 2 containing details of employees who are provided bonus Query :\n\nResult : 2. EXCEPT clause : contains all the rows that are returned by the first SELECT operation, and not returned by the second SELECT operation. Syntax :\n\nExample : Table 1 containing Employee Details Table 2 containing details of employees who are provided bonus Query :"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://essentialsql.com/sql-union-intersect-except",
        "document": "The SQL UNION, SQL INTERSECT, and SQL EXCEPT clauses are used to combine or exclude like rows from two or more tables. They are useful when you need to combine the results from separate queries into one single result. They differ from a join in that entire rows are matched and, as a result, included or excluded from the combined result.\n\nThese operators can be used on any query; however, a couple simple of conditions must be met:\n• The number and order columns must be the same in both queries\n• The data types must be the same or compatible.\n\nIn this section let’s talk about the SQL UNION operator. You can use the UNION clause to combine table rows from two different queries into one result.\n\nUnlike a join, which combines columns from different tables, a union combines rows from different tables. Here is an illustration of what a SQL UNION looks like\n\nIn SQL this statement looks like\n\nIn order to union two tables there are a couple of requirements:\n• The number of columns must be the same for both select statements.\n• The columns, in order, must be of the same data type.\n\nWhen rows are combined duplicate rows are eliminated. If you want to keep all rows from both select statement’s results use the ALL keyword.\n\nThe Union operator returns rows from both tables. Use UNION to return a distinct list of values. Use UNION ALL to return distinct rows. SQL UNION for sorting results from two separate queries as one combined result. For instance, if you have two tables, Vendor, and Customer, and you want a combined list of names, you can easily do so using:\n\nNote the ORDER BY clause applies to the combined result.\n\nSuppose you were asked to provide a list of all AdventureWorks product categories and subcategories. To do this you could write two separate queries and provide two separate results, such as two spreadsheets, or you could use the SQL UNION operator to deliver one combined result:\n\nFrom this you get a combined list of names, but suppose you wanted to know which names were categories versus subcategories. To do this you can add a new column indicating the category type:\n\nThe difference between UNION and UNION ALL is that UNION returns a unique set of rows from the result; whereas, UNION ALL returns every row.\n\nReturns 575 rows, which is the number of distinct city names within the table. Running SQL UNION All returns the entire set of city names twice:\n\nAs you can see there is a big difference with using the ALL qualifier. When not used, the results are distinct values. Duplicates are not only eliminated between rows from each result, but also from within.\n\nSuppose management wants a combined list of people, vendors, and store names identified by source.\n\nTo do this we create three separate queries and then use the SQL UNIONclause to put them together. We will then order the list.\n\nAt first glance you may think the ORDER BY clause would only apply to the last select statement, but in fact it applies to all the results returned by the sql union. The database engine first process all the union statements then the order by.\n\nIf you’re in doubt about the processing order, you can use parenthesis “()” to control the order of evaluation much like you can with expressions. Here is what the statement, in general, would look like with parenthesis:\n\nThe SQL INTERSECT operator is used to combine like rows from two queries. It returns rows that are in common between both results. To use the SQL INTERSECT operator, both queries must return the same number of columns and those columns must be of compatible data types.\n\nIn this example, the circles represent two queries. The orange circle is the left query; whereas, the blue circle is the right. The area within each circle represents that query’s results.\n\nAs you can see the green portion represents the result of the SQL INTERSECT operator. This area represents those rows that are in both the left and right query.\n\nBelow is the general format of the INTERSECT operator.\n\nThere are two queries which are separated by the SQL INTERSECT operator. The top query is commonly called the left query.\n\nThe query is valid since both the left and right queries contain the same number of columns and each column is a similar data type; Char and Date respectively.\n\nWhich is invalid on multiple levels. First the number of columns isn’t the same. Additionally, the data type for each column is incompatible. For instance, Name, which is a Char column isn’t a compatible data type with Age.\n\nThe intersect operator is good when you want to find common rows between two results. The INTERSECT operator is similar to the AND operator; however, they operate on different database objects.\n\nThe SQL Intersect operator is used to compare entire rows; whereas, the AND operator is used to compare columns within rows.\n\nDon’t worry, it becomes clearer below.\n\nLet’s assume we want to find all job titles for positions held by both male and female employees. How could we do this? The first set is to compose the queries to find positions held by males, then to do the same for females.\n\nHere is the query for males, the one for the females is very similar:\n\nTo finish we need to find out which titles are in common. To do this we can use the SQL INTERSECT operator.\n\nYou may be tempted to try and simplify this statement by eliminating the INTERSECT operator all together and use the following\n\nBut this won’t simply work. Why? Because the Where clause is evaluated for each row and you’re never going to find a Gender value equal to both M and F for the same record.\n\nUsing Order By with SQL INTERSECT\n\nTo order the result by JobTitle we can use an ORDER BY clause. Keep in mind this works on the the final row set returned by the interest operator.\n\nThe INTERSECT hasn’t always been part of SQL Server . Before its introduction to the language you had to mimic the INTERSECT behavior using and INNER JOIN.\n\nBelow is the equivalent statement to find job titles in common for both genders:\n\nThis join is called a self-join, since we are joining the table to itself. The idea is to match up every JobTitle with same values. By pairing these values together we can then compare their corresponding gender values and keep those where one gender is male and the other female.\n\nNOTE: These are equivalent to a point. AS we have learned, NULL aren’t values, therefore NULL = NULL is always false. Given this, the INNER JOIN fails to match on joins; however, the SQL INTERSECT operator does match NULLS.\n\nYou’ll find there is usually more than one way to solve a problem in SQL.\n\nThe SQL EXCEPT operator is used to exclude like rows that are found in one query but not another. It returns rows that are unique to one result. To use the EXCEPT operator, both queries must return the same number of columns and those columns must be of compatible data types.\n\nIn this example, the circles represent two queries. The orange circle is the left query; whereas, the blue circle is the right. The area within each circle represents that query’s results.\n\nAs you can see the orange crescent (moon shape) represents the result of the EXCEPT operator. This area represents those rows that are on the left and not in the right query.\n\nBelow is the general format of the EXCEPT operator.\n\nThere are two queries that are separated by the EXCEPT operator. The top query is commonly called the left query.\n\nThe query is valid since both the left and right queries contain the same number of columns and each column is a similar data type; Char and Date respectively.\n\nWhich is invalid on multiple levels. First, the number of columns isn’t the same. Additionally, the data type for each column is incompatible. For instance, Name, which is a Char column isn’t a compatible data type with Age.\n\nUses for SQL Except\n\nThe except operator is good when you want to find common rows exclusive to one result. I like to use it when testing query results. I take the result of my un proven query and EXCEPT them against a proven query. This help me identify rows deserving my attention and troubleshooting.\n\nLet’s assume we want to find all job titles for positions held by males but not female employees. How could we do this? The first set is to compose the queries to find positions held by males, then to do the same for females.\n\nHere are the query males, the one for females is very similar:\n\nTo finish we need to find out which titles are common to only male employees. To do this we can use the EXCEPT operator.\n\nYou may be tempted to try and simplify this statement by eliminating the EXCEPT operator all together and use the following\n\nBut this won’t simply work. Why? Because the Where clause is evaluated for each row. Logically this where clause will return all job titles for males.\n\nUsing Order By with EXCEPT\n\nTo order the result by JobTitle we can use an ORDER BY clause. Keep in mind this works on the final row set returned by the except operator.\n\nThe EXCEPT operator was just recently added to SQL Server. Before its introduction to the language, you had to mimic the EXCEPT behavior using a subquery.\n\nBelow is the equivalent statement to find job titles only held by Males:\n\nI colored the subquery in green. We haven’t talked about sub queries yet, but will in the next series of articles. In general, the subquery is run once for each result returned from the main query. In this example, once we select a job title that is held by a male (the main query) we then do another query asking whether that job title in the set of job titles held by females (the subquery). If not, then the job title is retained in the results.\n\nUse the EXCEPT Operator to return only rows found in the left query. It returns unique rows from the left query that aren’t in the right query’s results. This query is useful when you’re looking to find rows that are in one set but not another. For example, to create a list of all vendors that are not customers you could write:\n\nLike INTERSECTION, EXCEPT has an equivalent SQL statement. In this case, we can use an OUTER JOIN to construct its equivalent:\n\nYou can build complicated queries using these operators. In fact, there’s nothing stopping you from combining one or more of these operators into a super query. When this is done, be sure to use parenthesis “()” to control which operators are evaluated first.\n\nIt may not be apparent to you or another SQL reader that,\n\nWhen there is no parenthesis, the order of evaluation is:\n• EXCEPT and UNION are evaluated Left to Right\n\nCan you remember this?\n\nMy recommendation is to just use parenthesis and make it clear. Tricky is kewl, but you’ll get burned down the road when you misread your own code – trust me on this one…\n\nOut of the three queries, the UNION operator is irreplaceable. There is no other way to combine results from two queries into a single result without using UNION.\n\nOn the other hand, as you saw earlier, both EXCEPT and INTERSECT’s results can be reproduced using OUTER and INNER JOINS respectively. In fact, you’ll find that the JOIN version of the queries runs more efficiently than EXCEPT and INTERSECT do and is more versatile as you can include fields from the left table that aren’t in the right.\n\nIsn’t valid, since the number of columns in both queries doesn’t match, whereas,"
    },
    {
        "link": "https://datalemur.com/sql-tutorial/sql-union-intercept-except",
        "document": "In our previous SQL Joins tutorial, you mastered the art of combining data from multiple tables horizontally. In this tutorial, we'll explore , which combines data vertically.\n\nWe'll also cover related SQL commands like and which help us identify commonalities and differences in our datasets.\n\nUNION and UNION ALL in SQL\n\nIn SQL, and and are operators used to vertically concatenate two or more results.\n\nThe key difference between and is:\n• UNION ALL keeps everything, including duplicates.\n• UNION removes duplicates, so you get only the unique items.\n\nTo ensure the correct use of and , remember to follow these rules:\n• The number of columns in each statement must match.\n• The data types (e.g. INT, VARCHAR, DATETIME, etc.) of the columns must match.\n• The columns selected in both statements must be in the same order.\n\nLet's look at a SQL query that uses these commands.\n\nAs mentioned earlier, combines results from two or more statements, but here's the twist: it includes all values, including duplicates.\n\nTo see this in practice, imagine you have two lists of ingredients for different cake recipes 🍰, stored in two different tables called and . You're planning your shopping trip and you want to combine these shopping lists so you can buy all the ingredients you need.\n\nWe can use to combine the two ingredient lists:\n\nThis generates the following output:\n\nUsing , you get all ingredients from both recipes, including duplicates.\n\nNow, let's apply these concepts to the Goodreads Book dataset you've worked with in the SQL Joins tutorial.\n\nIn this example, we retrieve a total of 40 books. This is because we're using which combines the results, including duplicates. If you examine the sequence, you'll notice duplicates for each .\n\nalso combines results from two or more statements, but here's the twist: it gives you a list of unique values without duplicates.\n\nLet's apply the operator to our earlier cake ingredients dataset:\n\nDo you see how this is a list of all the ingredients from , along with the unique items (Cinnamon, Nutmeg) from .\n\nLet's now put these ideas to work using the Goodreads Book dataset.\n\nRunning this code returns a count of 20 books. Why? Because we're using which removes duplicates. In the result, you'll find no duplicate entries.\n\nIf you're feeling brave, try to attempt this tricky Amazon SQL Interview Question which makes use of / operators.\n\nYour given the following Amazon table, and asked to maximize the number of items it can stock in a 500,000 square feet warehouse based on how much space each item in inventory takes:\n\nYou'll want to calculate the total square footage and the number of items for both prime and non-prime items as separate groups, and then use to combine the results into one result.\n\nThe SQL operation is like finding common elements between two lists.\n\nImagine you have a columns of numbers in two different tables, and you want to know which numbers appear in both tables.\n\nWhen you use operator on these two lists, it gives you the numbers that are in both lists, which in this case would be 4, 8, and 10. It removes duplicates, so you get a clean list of common elements between two different tables.\n\nUsing the same cake ingredients data as before, imagine you want to know which ingredients are common between the two recipes. Here's the SQL query you'd write:\n\nIn this case, the common ingredients are: Flour, Sugar, Eggs, and Salt, so here's what the output would look like:\n• The number of columns selected in both statements must be the same.\n• The data types of the corresponding columns in both statements must be compatible.\n• The columns you select in both statements should have the same order.\n\nSuppose you want to identify and retrieve order IDs that represent orders with two or more books that have been successfully delivered. Here's how you can do it using the and tables from the Goodreads Books dataset:\n\nIn this example, you'll get a result of 5 order IDs which represent orders that have deliveries with two or more books.\n\nThe SQL statement is like a filter that helps you find records that are unique to one set of data when you have two sets of data.\n\nWhen you use the statement on the ingredient lists below, it gives you the ingredients that are in Recipe 1, but not in Recipe 2.\n\nHere are the recipes for your reference: Recipe 1 (6 items): Flour, Sugar, Eggs, Milk, Vanilla Extract, Salt Recipe 2 (6 items): Flour, Sugar, Eggs, Cinnamon, Nutmeg, Salt\n\nIn this case, the ingredients in Recipe 1 that are not in recipe 2 are: Milk and Vanilla Extract, so you'd get the following output:\n\nConditions for using the statement in SQL:\n• The number of columns and their order in the statements must match between the tables.\n• The data types of corresponding columns in both tables should either be the same or compatible.\n\nNow, let's find orders that have been placed but not delivered using the Goodreads Book dataset.\n\nThe result will be a list of order IDs that have been placed but not yet delivered.\n\nTry using to solve the FB SQL interview question, where you're given two tables containing data about Facebook Pages and their respective likes (as in \"Like a Facebook Page\"), and are asked to return the IDs of the Facebook pages that have zero likes.\n\nBringing It All Together\n\nTo sum it up:\n• and stacks two or more results vertically.\n• identifies common rows between two or more results.\n• finds unique rows in the first query, but not present in the second query.\n\nCongrats, you've learned pretty much every major SQL keyword. Now, it's time to learn some best practices for writing clean, well-styled SQL."
    },
    {
        "link": "https://stackoverflow.com/questions/51641358/sql-union-all-and-except",
        "document": "I am seeing a strange behavior when I do except and union statements in SQL.\n\nData looks like this\n\nThis is my final query\n\nand gives these records\n\nQuestion I have is.. Shouldn't there be another row in this from the first except clause:\n\nShouldn't the final query have 3 rows instead of only 2, since not all columns are the same."
    },
    {
        "link": "https://red-gate.com/simple-talk/databases/sql-server/performance-sql-server/the-except-and-intersect-operators-in-sql-server",
        "document": "Quite often, you’re faced with the task of comparing two or more tables, or query results, to determine which information is the same and which isn’t. One of the most common approaches to doing such a comparison is to use the UNION or UNION ALL operator to combine the relevant columns of the results that you want to compare. As long as you adhere to the restrictions placed on either of those operators, you can combine data sets whether they come from different databases or even different servers. With the UNION operator, you end up with a result containing every distinct row from the two results combined. However, it becomes more difficult to use UNION to return only the common data that is held in both results, or the different data that exists in one table but not the other(s). To get the results you need, you must use UNION ALL with a GROUP BY clause, though the logic isn’t always obvious on how to do this. And it isn’t any easier to use a JOIN operator to get the result you want. .\n\nEnter the INTERSECT and EXCEPT operators. Beginning with SQL Server 2005, you can use these operators to combine queries and get the results you need. For instance, you can use the INTERSECT operator to return only values that match within both data sets, as shown in the following illustration .\n\nThe illustration shows how the INTERSECT operator returns data that is common to both results set; the common data is represented by the area where the two circles intersect. The illustration also shows how the EXCEPT operator works; only data that exists in one of the data sets outside the intersecting area is returned. For instance, if Set A is specified to the left of the EXCEPT operator, only values that are not in Set B are returned. In the illustration above, that would be the data in the left circle, outside the section where the two data sets intersect. The following bullets sum up which operator to use to return different combinations of data:\n• To return the data in Set A that doesn’t overlap with B, use A EXCEPT B.\n• To return only the data that overlaps in the two sets, use A INTERSECT B.\n• To return the data in Set B that doesn’t overlap with A, use B EXCEPT A.\n• To return the data in all three areas without duplicates, use A UNION B.\n• To return the data in all three areas, including duplicates, use A UNION ALL B.\n• To return the data in the non-overlapping areas of both sets, use (A UNION B) except (A INTERSECT B), or perhaps (A EXCEPT B) UNION (B EXCEPT A)\n\nThe differences between the INTERSECT and EXCEPT operators and how to use each of them will become clearer as we work through the examples in the article. Just to give you a basic idea of how they work, we’ll start with a rather unrealistic example. To demonstrate those, however, we must first create two test views (using SQL Server 2005-compatible syntax). The first view contains a single column that describes what you might have had for lunch:\n\nThe second view also contains a single column and describes what you might have had for dinner:\n\nNow we can use these two views to demonstrate how to use the UNION, INTERSECT, and EXCEPT operators. I’ve also included a couple examples that use the JOIN operator to demonstrate the differences.\n\nThe first example uses the UNION operator to join the two views in order to return everything you’ve eaten today:\n\nNow we return the same data by using a full outer join:\n\nNotice that the join requires more complex syntax; however, both statements return the same results, as shown in the following table:\n\nNow let’s look at how you would return only the food you ate (or drank) for lunch, but did not have for dinner:\n\nIn this case, I used the EXCEPT operator to return the lunch-only items. I could have achieved the same results using the following left outer join:\n\nOnce again, you can see that the join is more complex, though the results are the same, as shown in the following table:\n\nIf you wanted to return those items you had for dinner but not lunch, you can again use the EXCEPT operator, but you must reverse the order of the queries, as shown in the following example:\n\nNotice that I first retrieve the data from the Dinner view. To use the left outer join, you would again have to reverse the order of the tables:\n\nAs expected, the results are the same for both SELECT statements:\n\nIn the next example, I use the INTERSECT operator to return only the food that was eaten at both meals:\n\nAs you can see, I simply connect the two queries with the INTERSECT operator, as I did with the EXCEPT operator. You can achieve the same results by using an inner join:\n\nAs the following results show, the only items you had at both meals were olives, bread, and coffee:\n\nNow let’s look at how you would return a list of food that you ate at one of the meals, but not both meals, in other words, the food you ate other than bread, olives, and coffee. In the following statement, I use a UNION operator to join two SELECT statements:\n\nNotice that first statement retrieves only the food you ate for lunch, and the second statement retrieves only the food ate for dinner. I achieve this in the same way I did in previous examples-by using the EXCEPT operator. I then used the UNION operator to join the two result sets. You can achieve the same results by using a full outer join:\n\nIn both examples, the statements return the following results:\n\nFrom this point on, I developed the examples on a local instance of SQL Server 2008 and the AdventureWorks2008 database. Each example uses either the INTERSECT or EXCEPT operator to compare data between the Employee and JobCandidate tables, both part of the HumanResources schema. The comparison is based on the BusinessEntityID column in each table. The BusinessEntityID column in the Employee table is the primary key. In the JobCandidate table, the BusinessEntityID column is a foreign key that references the BusinessEntityID column in the Employee table. The column in the JobCandidate table also permits null values.\n\nAs I mentioned above, when you use the INTERSECT operator to combine queries, the data returned is only that which matches between the two data sets. That means, with regard to the Employee and JobCandidate tables, the result set will include only rows in which the BusinessEntityID value in the Employee table matches the BusinessEntityID value in the JobCandidate table.\n\nIn the following example, I create two queries that retrieve data from the Employee and JobCandidate tables and use the INTERSECT operator to combine those queries:\n\nThe first SELECT statement, as you can see, retrieves the BusinessEntityID column from the Employee table, and the second SELECT statement retrieves the BusinessEntityID column from the JobCandidate table. The INTERSECT operator combines the two queries.\n\nWhen you use the INTERSECT operator to combine queries (or EXCEPT, for that matter), the number of columns must be the same in both queries and the columns must be in the same order. In addition, the corresponding columns between the queries must be configured with compatible data types. The example above meets these conditions because each query returns only one column of the same data type (INT). When the INTERSECT operator is used to combine these the two queries, the statement returns the following results:\n\nAs it turns out, the Employee table and JobCandidate table have only two BusinessEntityID values in common. If you were to examine the data in the JobCandidate table, you would find that the query results here are consistent with the data in that table. The table contains only 13 rows, and the BusinessEntityID column is NULL for all but two of the rows. The BusinessEntityID values in those rows are 212 and 274. And, as you would expect, the Employee table also contains a row with a BusinessEntityID value of 212 and a row with a value of 274.\n\nCertainly, as the above example indicates, using the INTERSECT operator to combine the results of two queries together is a straightforward process. The key, as I’ve stated, is to make sure the SELECT lists in the two queries are in sync with each other.\n\nHowever, that also points out one of the limitations of using the INTERSECT operator to combine queries-and that is, you cannot include columns in one query that are not included of the second query. If you do include multiple matching columns in each query, all the column values must match in order for a row to be returned. For example, suppose you’re retrieving data from two tables that each include columns for employee IDs, first names, and last names. If you want to match the two tables based on those three columns, the three values in the first table must match the three values in the second table for a row to be returned. (At this point, you might be asking yourself what you’re doing with all that redundant data in your database.)\n\nInstead of taking this approach, you may decide to compare the IDs in both tables, but pull the first and last name from only one of the tables. Or you might decide that you want to pull information from one table that is not stored in the other table. However, because columns must correspond between the two queries when using an INTERSECT operator to combine them, you have to find a way to work around this limitation. One of the easiest ways to do that is to put your INTERSECT construction into a common table expression (CTE) and then join the expression to one of the tables to pull the additional data. For instance, the following example includes a CTE that contains the same INTERSECT construction you saw in the example above:\n\nNotice that I’ve created a CTE named cteCandidates. As you would expect, the CTE returns the BusinessEntityID values that are contained in both the Employee and JobCandidate tables. In the primary SELECT statement, I then join the Employee table to the CTE in order to also retrieve the LoginID and JobTitle values from the Employee table. Because I put the INTERSECT join in the CTE, the statement can now return the following results:\n\nAs you can see, I’ve gotten around the limitations of the INTERSECT operator and am now returning additional information from one of the tables. I could have also joined the CTE to a different table in order to include additional information. For example, I might have joined what I have here to the Person table to retrieve the employee’s first and last names. The point is, the CTE let’s you be quite flexible when working with the INTERSECT operator; you can still determine which rows match but also return all the data you need, regardless of the source table.\n\nWorking with the EXCEPT Operator\n\nOnce you’ve mastered the INTERSECT operator, you have, for the most part, mastered the EXCEPT operator. As I stated earlier, the EXCEPT operator returns only those rows that do not have a match in the joined table. The important point to remember when using the EXCEPT operator is that it makes a difference which side of the operator you place the query. Only data from the query to the left of the operator (before the operator) is returned. Let’s look at an example to demonstrate how this works.\n\nIn the following statement, I again combine two queries, one that retrieves data from the Employee table and one that retrieves data from the JobCandidate table:\n\nThis statement is nearly identical to the INTERSECT construction you saw in the first two examples, except, of course, for the use of the EXCEPT operator. However, because the query to the left of the operator is retrieving data from the Employee table, the final result set will include data only from that table, and not the JobCandidate table.\n\nThe Employee table, as it turns out, contains 290 rows. As you’ll recall from the previous examples, the two rows in the table with the BusinessEntityID values of 212 and 274 match the two rows in the JobCandidate table that also have BusinessEntityID values of 212 and 274. That means, these two rows should be excluded from the result set of the query above, which is exactly what happens. The query returns 288 rows that have BusinessEntityID values of 1 through 290. However, IDs 212 and 274 are not included in those results.\n\nNow let’s look at what happens when you reverse the order of the queries, as I’ve done in the following example:\n\nNotice that the query that retrieves data from the JobCandidate table now comes first, that is, sits to the left of the EXCEPT operator. The results from this statement, as you would expect, are quite different from the previous example. All that is returned is a single NULL value. In other words, according to the results, the JobCandidate table contains no BusinessEntityID values that are not contained in the Employee table. This is, of course, exactly the case.\n\nAs with the CTE example above, which uses the INTERSECT operator, you can also use CTEs with EXCEPT operators. But as the last example points out, if your CTE returns no data, your main query will also return no data (at least if you’re using an inner join), but that’s true with either operator. Overall, in fact, you’ll find there’s little difference between the INTERSECT and EXCEPT operators, in terms of how you use them. The difference, of course, is in the results. INTERSECT returns rows common to both queries, and EXCEPT returns only rows in the left query. Both operators, however, are useful additions to the types of joins that the UNION and UNION ALL operators provide. You can find more details about the INTERSECT and EXCEPT operators by referring to the topic “EXCEPT and INTERSECT (Transact-SQL)” in SQL Server Books Online. There you’ll find additional information about each operator and additional examples of how to use them."
    }
]