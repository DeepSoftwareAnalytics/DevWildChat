[
    {
        "link": "https://sequelize.org/docs/v6/getting-started",
        "document": "In this tutorial, you will learn to make a simple setup of Sequelize.\n\nSequelize is available via npm (or yarn).\n\nYou'll also have to manually install the driver for your database of choice:\n\nTo connect to the database, you must create a Sequelize instance. This can be done by either passing the connection parameters separately to the Sequelize constructor or by passing a single connection URI:\n\nThe Sequelize constructor accepts a lot of options. They are documented in the API Reference.\n\nYou can use the function to test if the connection is OK:\n\nSequelize will keep the connection open by default, and use the same connection for all queries. If you need to close the connection, call (which is asynchronous and returns a Promise).\n\nObserve that, in the examples above, refers to the library itself while refers to an instance of Sequelize, which represents a connection to one database. This is the recommended convention and it will be followed throughout the documentation.\n\nYou are encouraged to run code examples locally while reading the Sequelize docs. This will help you learn faster. The easiest way to do this is using the SQLite dialect:\n\nTo experiment with the other dialects, which are harder to set up locally, you can use the Sequelize SSCCE GitHub repository, which allows you to run code on all supported dialects directly from GitHub, for free, without any setup!\n\nIf you are starting a project from scratch, and your database is still empty, Sequelize can be used from the beginning in order to automate the creation of every table in your database.\n\nAlso, if you want to use Sequelize to connect to a database that is already filled with tables and data, that works as well! Sequelize has got you covered in both cases.\n\nBy default, Sequelize will log into the console for every SQL query it performs. The option can be used to customize this behavior, by defining the function that gets executed every time Sequelize logs something. The default value is and when using that only the first log parameter of a log function call is displayed. For example, for query logging the first parameter is the raw query and the second (hidden by default) is the Sequelize object.\n\nMost of the methods provided by Sequelize are asynchronous and therefore return Promises. They are all Promises, so you can use the Promise API (for example, using , , ) out of the box.\n\nOf course, using and works fine as well."
    },
    {
        "link": "https://sequelize.org/docs/v7/databases/mssql",
        "document": "To use Sequelize with Microsoft SQL Server, you need to install the dialect package:\n\nThen use the class as the dialect option in your Sequelize instance:\n\nConnection Options are used to configure a connection to the database.\n\nThe simplest way to use them is at the root of the configuration object. These options can also be used in the option to customize the connection for each replica, and can be modified by the hook on a connection-by-connection basis.\n\nThe following options are passed as-is to the package that Sequelize uses to connect to SQL Server. Please refer to the Tedious documentation for more information about what each of these options do.\n\nFor convenience, here is an edited copy of the documentation that only includes the options that are accepted by Sequelize:\n\nIn order to connect with a domain account, use the following format."
    },
    {
        "link": "https://sequelize.org/docs/v7/getting-started",
        "document": "In this tutorial you will learn to make a simple setup of Sequelize.\n\nSequelize is available via npm (or yarn).\n\nTo connect to the database, you must create a Sequelize instance, and pass it the database configuration information, such as the dialect, the host, and the username and password.\n\nEach dialect supports a different set of options. Follow the links below to see how to connect to your database:\n\nIf your database is not listed above, Sequelize does not support it out of the box. However, Sequelize is extensible, and you can create your own dialect, or find a community-maintained one. For more information, see our documentation about supporting other databases.\n\nHere is a short example of how to connect to a SQLite database:\n\nThe Sequelize constructor accepts many options. They are documented in the API Reference.\n\nYou can use the function to test if the connection is OK. Note that this is completely optional, but recommended as Sequelize fetches your Database version on the first connection. That version is then used to determine which SQL features are available.\n\nSequelize uses a connection pool to manage connections to the database. This means some connection can remain open even after you're done with them. If you wish to gracefully shut down your application, you can use to close all active connections.\n\nObserve that, in the examples above, refers to the library itself while the lowercase refers to an instance of Sequelize. This is the recommended convention, and it will be followed throughout the documentation.\n\nHead to the Version Policy page to know which versions of TypeScript are supported, and make sure that the package corresponding to your Node.js version is installed in your project.\n\nOur documentation makes heavy use of ECMAScript Modules (ESM), but CommonJS is fully supported by Sequelize. To use Sequelize in a CommonJS project, simply use instead of :\n\nMost of the methods provided by Sequelize are asynchronous and therefore return Promises. we highly recommend using ECMAScript Modules, as they give you access to Top-Level Await, which we use extensively in our examples. Head to Node.js' documentation to learn how to use them in Node.js.\n\nTo ease debugging, you can enable logging in Sequelize. This is done by setting the option to a function that gets executed every time Sequelize needs to log something.\n\nNow that you have a Sequelize instance, the next step to get started is to define your first models."
    },
    {
        "link": "https://stackoverflow.com/questions/41819106/connecting-to-mssql-server-with-sequelize",
        "document": "I tried your Sequelize code and it works fine. So you might need to add Client IP address to allow access to Azure SQL Server. To do this, go to the Azure portal, click on All Resources, select your SQL server, click on Firewall in the SETTINGS menu.\n\nYour client address is conveniently included in the list, so you can just click on Add client IP followed by Save. When you run your code now, it should connect."
    },
    {
        "link": "https://medium.com/better-programming/node-js-backend-to-connect-mysql-database-using-sequelize-modeling-8cc637ed5f29",
        "document": "In this tutorial, I’m going to guide you in creating a loose-coupled Node.js backend server dealing with an SQL database, using Sequelize to perform the Object Relational Mapping.\n\nThe front-end app is going to be built using React, but we’ll come there in another article. In this article, let’s focus on the backend server.\n\nHere I’ll use which is a back-end web application framework for Node.js.\n\nIn other words, Sequelize does the mapping between the Object-Oriented usage of JavaScript and relational SQL database.\n\nWhat we are going to do?\n\nWe are going to create a simple CRUD application for student management. It has functionalities to add a student, update a student, remove a student and view the student details.\n\nFor those four actions, the Express server we create will expose the following 4 URLs.\n\nThis is the high-level architecture of our application.\n• We’ll start by creating our Node.js app! Just create a new folder to place your project. I’m creating a folder called Then open the inside the folder and initialize node there, using the following command :\n\nYou will be prompted with details, if you keep the default press enter, else put the required details, and enter — like this:\n\nNow onto the next step.\n\nLet’s install the required modules. The modules I’m going to install are , , , and .\n\nHere I’m using because it’s a MySQL client for Node.js with a focus on performance. It supports prepared statements, non-utf8 encodings, binary log protocol, compression, SSL, and much more. Read more from here\n\nCors (Cross-Origin Resource Sharing) is a Node.js package for managing cross-origin HTTP requests with other servers. If you’d like to read more on this I recommend this interesting article.\n\nUse the following command in cmd for the installation of the above:\n\nWe’ll create in the root directory of our back-end app. Add the following code to set up the server:\n\nNow just execute the server using the following command in :\n\nYou should get the following message by opening http://localhost:8080/ URL in your web browser!\n\nAs the fourth step, let’s create the database.\n\nCreate a MySQL database called using any convenient way. As the simplest way, you can use XAMPP to start apache and MySQL modules there. Then open in my web browser and create a new database named there. Only you need to create the database. The creation of data columns will be done with the help of when we first start the server! So no more worries with the database!\n\nNext, we’ll set up the database configuration.\n\nFor that, I’m creating a new folder called in the root directory and inside config I create the file and put the following configuration:\n\nNow we have to use Sequelize to perform the rest of the tasks! For those modeling, I create a separate folder called in my root directory.\n\nFirst, we need to initialize Sequelize providing the necessary configurations.\n\nFor that, we’ll create a file named in the folder and there we’ll do the initialization for Sequelize:\n\nNext we need to define our data model. How should the tables and their data fields in the database be? We’ll define them in a separate file in the folder. I’m creating a file named and place those modeling information there:\n\nSo when we start executing this backend app, it will check whether this table exists in the database. If it is not yet created, it will be created accordingly as we have defined here. Cool!\n\nNow let’s create the controller! In the , we defined how our data model looks like. Here we define how our app functions. For that, I’m creating a separate folder named in the root. Inside that, I’ll create my controller file named and there I create the functions I need to have in my application.\n\nIn this controller, we define the ways of sending and receiving data to and from the database.\n\nNow we are just one step behind.\n\nDefine the routes where your front-end app should looking for performing CRUD. I’ll create a folder in my app root called and inside it add a to place the routes:\n\nNow include the file in your server by adding this line:\n\nWe’re done If you didn’t run the app, just open the cmd in the root folder of your project and simply type and enter:\n\nThe backend should be up and running!\n\nYou can find the source code here in GitHub!\n\nCheers and thanks for reading."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-implement-caching-in-node-js-using-redis",
        "document": "The author selected /dev/color to receive a donation as part of the Write for DOnations program.\n\nMost applications depend on data, whether it comes from a database or an API. Fetching data from an API sends a network request to the API server and returns the data as the response. These round trips take time and can increase your application response time to users. Furthermore, most APIs limit the number of requests they can serve an application within a specific time frame, a process known as rate limiting.\n\nTo get around these problems, you can cache your data so that the application makes a single request to an API, and all the subsequent data requests will retrieve the data from the cache. Redis, an in-memory database that stores data in the server memory, is a popular tool to cache data. You can connect to Redis in Node.js using the module, which gives you methods to retrieve and store data in Redis.\n\nIn this tutorial, you’ll build an Express application that retrieves data from a RESTful API using the module. Next, you will modify the app to store the data fetched from the API in Redis using the module. After that, you will implement the cache validity period so that the cache can expire after a certain amount of time has passed. Finally, you will use the Express middleware to cache data.\n\nTo follow the tutorial, you will need:\n• Node.js environment setup on your server. If you are on Ubuntu 22.04, install the latest version of Node.js and npm by following option 3 in How To Install Node.js on Ubuntu 22.04. For other operating systems, see the How to Install Node.js and Create a Local Development Environment series.\n• Redis installed on your server. If you’re using Ubuntu 22.04, follow steps 1 and 2 of How To Install and Secure Redis on Ubuntu 22.04. If you’re working on another operating system, see How to Install and Secure Redis.\n• Knowledge of asynchronous programming. Follow Understanding the Event Loop, Callbacks, Promises, and Async/Await in JavaScript.\n• Basic knowledge using the Express web framework. See How To Get Started with Node.js and Express.\n\nIn this step, you’ll install the dependencies necessary for this project and start an Express server. In this tutorial, you’ll create a wiki containing information about different kinds of fish. We’ll call the project .\n\nFirst, create the directory for the project using the command:\n\nInitialize the file using the command:\n\nWhen you run the command, it will create the file in your directory with the following contents:\n\nNext, you will install the following packages:\n• : a Node.js HTTP client, which is helpful for making API calls.\n• : a Redis client that allows you to store and access data in Redis.\n\nTo install the three packages together, enter the following command:\n\nUsing or the text editor of your choice, create and open the file:\n\nIn your file, enter the following code to create an Express server:\n\nFirst, you import into the file. In the second line, you set the variable as an instance of , which gives you access to methods such as , , , and many more. This tutorial will focus on the and methods.\n\nIn the following line, you define and assign the variable to the port number you want the server to listen on. If no port number is available in an environmental variables file, port will be used as the default.\n\nFinally, using the variable, you invoke the module’s method to start the server on port .\n\nRun the file using the command to start the server:\n\nThe console will log a message similar to the following:\n\nThe output confirms that the server is running and ready to serve any requests on port . Because Node.js does not automatically reload the server when file are changed, you will now stop the server using so that you can update in the next step.\n\nOnce you have installed the dependencies and created an Express server, you’ll retrieve data from a RESTful API.\n\nIn this step, you’ll build upon the Express server from the previous step to retrieve data from a RESTful API without implementing caching, demonstrating what happens when data is not stored in a cache.\n\nTo begin, open the file in your text editor:\n\nNext, you will retrieve data from the FishWatch API. The FishWatch API returns information about fish species.\n\nIn your file, define a function that requests API data with the following highlighted code:\n\nIn the second line, you import the module. Next, you define an asynchronous function , which takes as a parameter. To make the function asynchronous, you prefix it with the keyword.\n\nWithin the function, you call the module’s method with the API endpoint you want the method to retrieve the data from, which is the FishWatch API in this example. Since the method implements a promise, you prefix it with the keyword to resolve the promise. Once the promise is resolved and data is returned from the API, you call the method. The method will log a message saying that a request has been sent to the API. Finally, you return the data from the API.\n\nNext, you will define an Express route that accepts requests. In your file, define the route with the following code:\n\nIn the preceding code block, you invoke the module’s method, which only listens on requests. The method takes two arguments:\n• : the endpoint that Express will be listening on. The endpoint takes a route parameter that captures anything entered on that position in the URL.\n• (not yet defined): a callback function that will be called when the URL matches the endpoint specified in the first argument.\n\nNow that the route is defined, specify the callback function:\n\nThe function is an asynchronous handler function passed to the module’s method as a second argument. The function takes two arguments: a request object and a response object. The request object contains information about the client, while the response object contains the information that will be sent to the client from Express.\n\nNext, add the highlighted code to call to retrieve data from an API in the callback function:\n\nIn the function, you extract the value captured from the endpoint stored in the object, then assign it to the variable. In the next line, you define the variable and set it to .\n\nAfter that, you invoke the function with the variable as an argument. The function call is prefixed with the syntax because it returns a promise. When the promise resolves, it returns the data, which is then assigned to the variable.\n\nNext, add the highlighted code to handle runtime errors:\n\nYou define the block to handle runtime errors. In the block, you call to retrieve data from an API. If an error is encountered, the block logs the error and returns a status code with a “Data unavailable” response.\n\nMost APIs return a 404 status code when they have no data for a specific query, which automatically triggers the block to execute. However, the FishWatch API returns a 200 status code with an empty array when there is no data for that specific query. A 200 status code means the request was successful, so the block is never triggered.\n\nTo trigger the block, you need to check if the array is empty and throw an error when the condition evaluates to true. When the conditions evaluate to false, you can send a response to the client containing the data.\n\nTo do that, add the highlighted code:\n\nOnce the data is returned from the API, the statement checks if the variable is empty. If the condition is met, you use the statement to throw a custom error with the message . After it runs, execution switches to the block, which logs the error message and returns a 404 response.\n\nConversely, if the variable has data, the statement condition will not be met. As a result, the program will skip the block and execute the response object’s method, which sends a response to the client.\n\nThe method takes an object that has the following properties:\n• : the property accepts a value that helps you know whether data is coming from the Redis cache or the API. You now assigned a value because the data comes from an API.\n• : the property is assigned the variable that contains the data returned from the API.\n\nAt this point, your complete code will look like this:\n\nNow that everything is in place, save and exit your file.\n\nThe Fishwatch API accepts many species, but we will use only the fish species as a route parameter on the endpoint you will be testing throughout this tutorial.\n\nNow launch your favorite web browser on your local computer. Navigate to the URL.\n\nOnce the page loads, you should see set to .\n\nNow, refresh the URL three more times and look at your terminal. The terminal will log “Request sent to the API” as many times as you have refreshed your browser.\n\nIf you refreshed the URL three times after the initial visit, your output will look like this:\n\nThis output shows that a network request is sent to the API server every time you refresh the browser. If you had an application with 1000 users hitting the same endpoint, that’s 1000 network requests sent to the API.\n\nWhen you implement caching, the request to the API will only be done once. All subsequent requests will get data from the cache, boosting your application performance.\n\nFor now, stop your Express server with .\n\nNow that you can request data from an API and serve it to users, you’ll cache data returned from an API in Redis.\n\nIn this section, you’ll cache data from the API so that only the initial visit to your app endpoint will request data from an API server, and all the following requests will fetch data from the Redis cache.\n\nIn your file, import the module:\n\nIn the same file, connect to Redis using the module by adding the highlighted code:\n\nFirst, you define the variable with the value set to undefined. After that, you define an anonymous self-invoked asynchronous function, which is a function that runs immediately after defining it. You define an anonymous self-invoked asynchronous function by enclosing a nameless function definition in parenthesis . To make it self-invoked, you immediately follow it with another set of parenthesis , which ends up looking like .\n\nWithin the function, you invoke the module’s method that creates a object. Since you did not provide the port for Redis to use when you invoked the method, Redis will use port , the default port.\n\nYou also call the Node.js method that registers events on the Redis object. The method takes two arguments: and a callback. The first argument is an event triggered when Redis encounters an error. The second argument is a callback that runs when the event is emitted. The callback logs the error in the console.\n\nFinally, you call the method, which starts the connection with Redis on the default port . The method returns a promise, so you prefix it with the syntax to resolve it.\n\nNow that your application is connected to Redis, you’ll modify the callback to store data in Redis on the initial visit and retrieve the data from the cache for all the requests that follow.\n\nIn your file, add and update the highlighted code:\n\nIn the function, you define the variable with the value . Within the block, you call the module’s method with as the argument. When the method finds the key in Redis that matches the variable value, it returns the data, which is then assigned to the variable.\n\nNext, an statement checks if the variable has data. If the condition is met, the variable is assigned . Following this, you invoke the method of the object with as the argument. The method converts JSON string data into a JavaScript object. After the JSON has been parsed, you invoke the method, which takes an object that has the property set to the variable. The method sends the response to the client.\n\nIf the method of the module finds no data in the cache, the variable is set to . As a result, the statement evaluates to false. When that happens, execution skips to the block where you call the function to fetch data from the API. However, once the data is returned from the API, it is not saved in Redis.\n\nTo store the data in the Redis cache, you need to use the module’s method to save it. To do that, add the highlighted line:\n\nWithin the block, once the data has been fetched, you call the module’s method to save the data in Redis under the key name of the value in the variable.\n\nThe method takes two arguments, which are key-value pairs: and .\n\nThe first argument, , is the key that the data will be saved under in Redis. Remember is set to the value passed to the endpoint you defined. For example, when you visit , is set to , which will be the key in Redis.\n\nThe second argument, , is the value for the key. In the second argument, you invoke the ’s method with the variable as the argument, which contains data returned from the API. The method converts JSON into a string; this is why, when you retrieved data from the cache using the module’s method earlier, you invoked the method with the variable as the argument.\n\nYour complete file will now look like the following:\n\nSave and exit your file, and run the using the command:\n\nOnce the server has started, refresh in your browser.\n\nNotice that is still set to :\n\nNow refresh the page again to see that this time is set to :\n\nRefresh the page five times and go back to the terminal. Your output will look similar to the following:\n\nNow, Request sent to the API has only been logged once after multiple URL refreshes, contrasting with the last section where the message was logged for each refresh. This output confirms that only one request was sent to the server and that subsequently, data is fetched from Redis.\n\nTo further confirm that the data is stored in Redis, stop your server using . Connect to the Redis server client with the following command:\n\nRetrieve the data under the key :\n\nYour output will resemble the following (edited for brevity):\n\nThe output shows the stringified version of JSON data that the API returns when you visit the endpoint, which confirms that the API data is stored in the Redis cache.\n\nNow that you can cache data from an API, you can also set the cache validity.\n\nWhen caching data, you need to know how often the data changes. Some API data changes in minutes; others in hours, weeks, months, or years. Setting a suitable cache duration ensures that your application serves up-to-date data to your users.\n\nIn this step, you’ll set the cache validity for the API data that needs to be stored in Redis. When the cache expires, your application will send a request to the API to retrieve recent data.\n\nYou need to consult your API documentation to set the correct expiry time for the cache. Most documentation will mention how frequently the data is updated. However, there are some cases where the documentation doesn’t provide the information, so you might have to guess. Checking the property of various API endpoints can show how frequently the data is updated.\n\nOnce you choose the cache duration, you need to convert it into seconds. For demonstration in this tutorial, you will set the cache duration to 3 minutes or 180 seconds. This sample duration will make testing the cache duration functionality easier.\n\nTo implement the cache validity duration, open the file:\n\nIn the module’s method, you pass a third argument of an object with the following properties:\n• : accepts a value with the cache duration in seconds.\n• : when set to , it ensures that the method should only set a key that doesn’t already exist in Redis.\n\nGo back to the Redis server client to test the cache validity:\n\nNow, start the development server with the command:\n\nSwitch back to your browser and refresh the URL. For the next three minutes, if you refresh the URL, the output in the terminal should be consistent with the following output:\n\nAfter three minutes have passed, refresh the URL in your browser. In the terminal, you should see that “Request sent to the API” has been logged twice.\n\nThis output shows that the cache expired, and a request to the API was made again.\n\nYou can stop the Express server.\n\nNow that you can set the cache validity, you’ll cache data using middleware next.\n\nIn this step, you’ll use the Express middleware to cache data. Middleware is a function that can access the request object, response object, and a callback that should run after it executes. The function that runs after the middleware also has access to the request and response object. When using middleware, you can modify request and response objects or return a response to the user earlier.\n\nTo use middleware in your application for caching, you will modify the handler function to fetch data from an API and store it in Redis. You’ll move all the code that looks for data in Redis to the middleware function.\n\nWhen you visit the endpoint, the middleware function will run first to search for data in the cache; if found, it will return a response, and the function won’t run. However, if the middleware does not find the data in the cache, it will call the function to fetch data from API and store it in Redis.\n\nIn the function, you remove all the code that looks for data stored in Redis. You also remove the variable since the function function will only fetch data from the API and store it in Redis.\n\nOnce the code has been removed, set to as highlighted below, so the function will look like the following:\n\nThe function retrieves the data from API, stores it in the cache, and returns a response to the user.\n\nNext, add the following code to define the middleware function for caching data in Redis:\n\nThe middleware function takes three arguments: , , and . In the block, the function checks if the value in the variable has data stored in Redis under its key. If the data is in Redis, it is returned and set to the variable.\n\nNext, the statement checks if has data. The data is saved in the variable if it evaluates to true. After that, the middleware uses the method to return an object with the properties set to and set to the variable.\n\nHowever, if the statement evaluates to false, execution switches to the block. Within the block, you call , which passes control to the next function that should execute after it.\n\nTo make the middleware pass control to the function when is invoked, update the module’s method accordingly:\n\nThe method now takes as its second argument, which is the middleware that looks for data cached in Redis and returns a response when found.\n\nNow, when you visit the endpoint, executes first. If data is cached, it will return the response, and the request-response cycle ends here. However, if no data is found in the cache, the will be called to retrieve data from API, store it in the cache, and return a response.\n\nThe complete file will now look like this:\n\nTo test the caching properly, you can delete the key in Redis. To do that, go into the Redis client:\n\nOnce the server starts, go back to the browser and visit the again. Refresh it multiple times.\n\nThe terminal will log the message that a request was sent to the API. The middleware will serve all requests for the next three minutes. Your output will look similar to this if you randomly refresh the URL in a four-minute timespan:\n\nThe behavior is consistent with how the application worked in the previous section.\n\nYou can now cache data in Redis using middleware.\n\nIn this article, you built an application that fetches data from an API and returns the data as a response to the client. You then modified the app to cache the API response in Redis on the initial visit and serve the data from the cache for all subsequent requests. You modified that cache duration to expire after a certain amount of time has passed, and then you used middleware to handle the cache data retrieval.\n\nAs a next step, you can explore the Node Redis documentation to learn more about the features available in the module. You can also read the Axios and Express documentation for a deeper look into the topics covered in this tutorial.\n\nTo continue building your Node.js skill, see How To Code in Node.js series."
    },
    {
        "link": "https://medium.com/@hamzamakh/how-to-optimize-node-js-app-with-api-caching-using-redis-4bda7961009",
        "document": "Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine. Redis provides data structures such as strings, hashes, lists, sets, sorted sets\n\nTo install Redis, Visit the official Redis website (https://redis.io/) and navigate to the download page. You can download the latest stable release or choose a specific version that suits your needs.\n\nBy default, Redis will run on the default port 6379. If you wish to use a different port, you can specify it with the flag, like this:\n\nTo start the Redis command-line interface (CLI), open a terminal or command prompt and write redis-cli\n\nFirst open a terminal and write redis-cli , you should see something like that :\n\nHere are some basic commands to interact with Redis once running:\n• SET: Set the value of a key.\n\n2. GET: Get the value of a key.\n\n3. DEL: Delete a key and its associated value.\n\n5. FLUSHALL: Remove all keys from the current database.\n\nYou can refer to the official Redis documentation (https://redis.io/documentation) for a comprehensive list of commands and their usage.\n\nHow use Redis with nodejs\n\nIn Node.js, there are several Redis libraries available for interacting with Redis servers. Some of the popular ones include:\n• ioredis: A robust, full-featured Redis client with high performance and support for both Node.js callbacks and Promises.\n• redis: The original Redis client for Node.js, providing a simple and straightforward interface to interact with Redis.\n• node_redis: A widely-used Redis client for Node.js that offers a rich feature set and supports both callbacks and Promises.\n• redis-async: A lightweight Redis client that uses async/await syntax and provides a simplified API for Redis operations.\n\nNow let’s focus on using the library specifically for API caching with Redis.\n\nStep 1: Install ioredis To get started, you need to install the library in your Node.js project. You can do this using npm or yarn:\n\nStep 2: Create a Redis client instance Once you have installed, you can create a Redis client instance in your Node.js application. Here's an example:\n\nAdjust the host and port values according to your Redis server configuration.\n\nBy default, if you don’t mention the host and the port ,it connects to\n\nStep 3: Caching API responses with Redis To cache API responses using Redis, you can use the and methods provided by the library. Here's an example:\n\nRemember to handle error scenarios, implement cache invalidation strategies, and adjust the caching logic according to your specific requirements.\n\nHow To Use redis Cahing Api with Mongodb Or with any database :\n\nTo organize things, you can create a new directory named and add a file called . Then, we can write all the logic of using Redis in it. We will create only two functions for the sake of this tutorial.\n• This function is defined to generalize the process of caching data. It accepts two parameters: and (callback function).\n• It returns a promise that resolves to either the cached data or the freshly retrieved data.\n• This function is defined to clear the entire cache stored in the Redis server.\n\nimport { Redis } from \"ioredis\"\n\n// or const Redis = require(\"ioredis\"); if you using CommonJS syntax\n\n\n\n// Create a Redis client instance\n\nconst redisClient = new Redis();\n\n\n\n// Default expiration time for cached data (2 hours)\n\nconst DEFAULT_EXPIRATION = 7200; // en seconds\n\n\n\n// Function to get or set cache\n\nexport function getOrSetCache(key, cb) {\n\n return new Promise(async (resolve, reject) => {\n\n // Try to get data from Redis using the provided key\n\n const data = await redisClient.get(key)\n\n .catch(error => {\n\n console.log(error);\n\n return reject(error);\n\n })\n\n\n\n // If data exists in cache, parse and return it\n\n if (data) return resolve(JSON.parse(data));\n\n\n\n // If data doesn't exist in cache, invoke the callback function (cb) to fetch fresh data\n\n const freshData = await cb();\n\n\n\n // Store the fresh data in Redis cache with the specified key and expiration time\n\n redisClient.set(key, JSON.stringify(freshData), 'EX', DEFAULT_EXPIRATION);\n\n\n\n // Resolve the promise with the fresh data\n\n resolve(freshData);\n\n })\n\n}\n\n\n\n// Function to clear the entire cache\n\nexport async function clearCache() {\n\n console.log(\"cache cleared\");\n\n // Flush all keys from the Redis cache\n\n await redisClient.flushall();\n\n}\n\nHere’s an example that demonstrates the usage , we gonna create a get route :\n\nif you unfamiliar with authentification and authorization , you can read about it in this blog.\n• We calls the function, passing the as the cache key and an async callback function.\n• The attempts to fetch the data associated with the from the cache. If the data is not present in the cache, it executes the provided callback function and stores the returned data from Mongodb in the cache. In this case, the callback function is defined as an async arrow function.\n\nthe first request take about 1073 ms , now the data will be stored in the cache\n\nlet’s verify this is well stored in redis database :\n\nNow , the next time I request this query it will fetch it from redis not mongodb\n\nyou can see it takes only 141 ms .\n\nThat’s it! You now have a basic understanding of how to use the library in Node.js to optimize your app with API caching using Redis."
    },
    {
        "link": "https://redis.io/docs/latest/develop/clients/nodejs",
        "document": "node-redis is the Redis client for Node.js/JavaScript. The sections below explain how to install and connect your application to a Redis database.\n\nrequires a running Redis or Redis Stack server. See Getting started for Redis installation instructions.\n\nYou can also access Redis with an object-mapping client interface. See RedisOM for Node.js for more information.\n\nTo connect to a different host or port, use a connection string in the format :\n\nTo check if the client is connected and ready to send commands, use , which returns a Boolean. is also available. This returns when the client's underlying socket is open, and when it isn't (for example, when the client is still connecting or reconnecting after a network error).\n\nThe website has more examples. The Github repository also has useful information, including a guide to the connection configuration options you can use.\n\nSee also the other pages in this section for more information and examples:"
    },
    {
        "link": "https://github.com/Munawwar/redicache",
        "document": "Two level caching strategy - Redis + Local (in process memory) - for storing important boot-time meta-data/dynamic configs - for node.js\n\nCaching works across any number of node.js processes regardless of architecture as long as they can connect to a common redis cluster (library uses redis pubsub and redlock).\n\nNote: If you are using redis 2.x, then switch to version 2.8+, as there are issues with TTL command in lower versions.\n\n// create redis client. please read 'redis' npm package's documentation for this. // redicache is a singleton. you can't initialize again // note that if you return nothing (undefined), then library will not // cache it. you need to send back a non-undefined value for caching. // good practice to namespace it, since redis is global // alternatively you can set expiry to any number of seconds // you can differentiate error from value using an instanceof check. // if you cache for unlimited duration of time, you need a way to refresh // it by API (without causing home page downtime) // name of attemptCacheRegeneration() is funny right? reason is, if another process is // running getOrInitCache() and has locked cache key for write purpose, then // attemptCacheRegeneration will fail (why? because, the process is already refreshing // the cache so why do it again?)\n• There is no memory cap/max limit for local cache. If you store too much in the cache (which is in-process memory), your process/node.js could crash. This is not exactly a limitation, but something to be aware of. redicache's primary design intention is for storing boot time configs/meta data which I assume is small (yet critical to run your app), and not built to cache high volumes of user data or the like.\n• Currently if redis is detected to be down, then library will fetch latest value and save it in local cache. Which means multiple processes could potentially request for fresh values parallelly. If this is too expensive to deal with, then currently there is no config to change this behavior. In future, I might add a way to configure to return stale value instead of fetching fresh. Also once redis comes back up, processes could have ended up with different values in their local cache.\n• Before requesting for fresh value for caching, redicache acquires a write-lock for the cache key on redis. If your fetch function never completes (or doesn't resolve promise) and runs indefinately then write-lock will never get released (Turing halting problem.. which has no solution).\n\nredicache is built with certain assumptions in mind:\n• that it is super expensive operation to request for fresh value to be cached. So redicache tries to minmize requests for fresh value, across all processes in the system. Hence you see the usage of distributed locks to prevent two processes/requests from requesting for fresh value (unless redis lock service is down).\n• the cached values are important for the functioning of your server. Therefore at no point should redicache delete a remote cache entry first and then request for fresh value.. this could bring down your server. Redicache requests fresh data, and then overwrites the exisitng cached value. This is a more resilient/robust approach."
    },
    {
        "link": "https://dev.to/sureshpattu/mastering-api-caching-with-redis-in-nodejs-11g8",
        "document": "Caching API responses is a key strategy to enhance application performance and reduce database load. In this comprehensive guide, we'll explore how to effectively cache APIs using Redis in a Node.js and Express.js environment, leveraging the power of MongoDB as our data source. By the end of this article, you'll have a solid understanding of caching techniques, Redis integration, and sample code to implement a robust caching solution.\n\nBenefits of Caching:\n\n Caching boosts application speed by storing frequently accessed data in memory, reducing the need to fetch data from the database repeatedly. It leads to faster response times, improved user experience, and reduced load on backend services.\n\nSelecting the Right Data for Caching:\n\n Caching should focus on data that is both frequently requested and relatively static. Dynamic or frequently changing data may not be suitable for caching due to its short-lived relevance.\n\nIntroduction to Redis:\n\n Redis is an in-memory data store that excels at caching due to its quick data retrieval capabilities. It supports various data structures and is highly efficient for read-heavy workloads.\n\nCaching Strategies: Full Response and Data:\n\n Choose between caching the entire API response or just the data. Full response caching includes headers, while data caching focuses solely on the content.\n\nUsing Redis to Cache API Responses:\n\n Implement Redis caching by storing data with a unique cache key. Retrieve data from Redis if present, or fetch it from MongoDB and then store it in Redis for subsequent requests.\n\nLet's walk through the process of creating a simple API using the Node.js, Express.js, and MongoDB tech stack, and then we'll implement caching using Redis for a 2-minute cache expiry time.\n\nFirst, make sure you have Node.js, Express.js, MongoDB, and Redis installed on your system. You can use the following commands to create a new project and install the required dependencies:\n\n\n\nCreate an file in your project directory and set up a basic Express.js application with a single route:\n\n\n\nInstall the package using the following command:\n\n\n\nNow, update the file to include Redis caching:\n\n\n\nIn this example, we've added a function that checks if the requested data is present in Redis. If it's found, we respond with the cached data. If not, we proceed to fetch the data from MongoDB, store it in Redis with a 2-minute expiry using , and then respond with the fetched data.\n\nPlease note that this is a basic example, and you'll need to implement the actual logic for fetching data from MongoDB based on your data model and structure.\n\nRun your Express.js application using the following command:\n\n\n\nNow your API is up and running, and it's caching responses using Redis for a 2-minute cache expiry time. Remember to adapt the code to your specific use case, including setting up your MongoDB data fetching logic.\n\nKeep in mind that this is a simplified example, and in a real-world scenario, you might want to handle cache invalidation when data changes, monitor Redis health, and consider more advanced caching strategies based on your application's needs.\n\nHere's a common function for cache invalidation that you can integrate into your Express.js application to clear cached data in Redis when data changes in your MongoDB:\n\n\n\n// Implement your logic to fetch data from MongoDB here // Store the fetched data in Redis with a 2-minute expiry // Example of cache invalidation when data changes (POST /api/books) // Implement your logic to update data in MongoDB here // Invalidate the cache for the /api/books route\n\nIn this example, the function is defined to clear a specific cache key. You can call this function whenever data changes in your MongoDB that impacts the cached data. In the route, after updating data in MongoDB, we call to invalidate the cache for the route.\n\nRemember to replace the comments with your actual MongoDB data fetching and updating logic.\n\nThis cache invalidation approach ensures that when data changes, the relevant cache entries are cleared, and users will receive up-to-date data in subsequent requests.\n\nManaging Cache Invalidation:\n\n Implement strategies to invalidate cache entries when data changes. This ensures that users receive up-to-date information.\n\nMonitoring Redis Health:\n\n Regularly monitor the health and performance of your Redis instance. Ensure that it can handle the cache load effectively.\n\nScaling Redis for Larger Workloads:\n\n Explore techniques to scale Redis horizontally or vertically to accommodate increased traffic and larger datasets.\n\nCaching API responses using Redis in a Node.js, Express.js, MongoDB, and Redis stack can significantly enhance your application's performance. By understanding caching strategies, implementing efficient code, and following best practices, you can build a caching solution that optimizes response times and improves user experience. With the knowledge gained from this guide, you'll be well-equipped to create a robust and responsive application that meets the demands of modern web development."
    }
]