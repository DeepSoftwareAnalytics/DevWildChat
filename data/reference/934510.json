[
    {
        "link": "https://stackoverflow.com/questions/8384737/extract-file-name-from-path-no-matter-what-the-os-path-format",
        "document": "For example, I'd like all of these paths to return me c :\n\nWhich Python library can I use to extract filenames from paths, no matter what the operating system or path format could be?\n\nUsing or as others suggest won't work in all cases: if you're running the script on Linux and attempt to process a classic windows-style path, it will fail. Windows paths can use either backslash or forward slash as path separator. Therefore, the module (which is equivalent to os.path when running on windows) will work for all(1) paths on all platforms. Of course, if the file ends with a slash, the basename will be empty, so make your own function to deal with it: >>> paths = ['a/b/c/', 'a/b/c', '\\\\a\\\\b\\\\c', '\\\\a\\\\b\\\\c\\\\', 'a\\\\b\\\\c', ... 'a/b/../../a/b/c/', 'a/b/../../a/b/c'] >>> [path_leaf(path) for path in paths] ['c', 'c', 'c', 'c', 'c', 'c', 'c'] (1) There's one caveat: Linux filenames may contain backslashes. So on linux, always refers to the file in the folder, while on Windows, it always refers to the file in the subfolder of the folder. So when both forward and backward slashes are used in a path, you need to know the associated platform to be able to interpret it correctly. In practice it's usually safe to assume it's a windows path since backslashes are seldom used in Linux filenames, but keep this in mind when you code so you don't create accidental security holes.\n\nIf your file path not ended with \"/\" and directories separated by \"/\" then use the following code. As we know generally path doesn't end with \"/\". But in some cases like URLs end with \"/\" then use the following code but when your path sperated by \"\\\" which you generally find in windows paths then you can use the following codes You can combine both into one function by check OS type and return the result.\n\nHere's a regex-only solution, which seems to work with any OS path on any OS. No other module is needed, and no preprocessing is needed either : import re def extract_basename(path): \"\"\"Extracts basename of a given path. Should Work with any OS Path on any OS\"\"\" basename = re.search(r'[^\\\\/]+(?=[\\\\/]?$)', path) if basename: return basename.group(0) paths = ['a/b/c/', 'a/b/c', '\\\\a\\\\b\\\\c', '\\\\a\\\\b\\\\c\\\\', 'a\\\\b\\\\c', 'a/b/../../a/b/c/', 'a/b/../../a/b/c'] print([extract_basename(path) for path in paths]) # ['c', 'c', 'c', 'c', 'c', 'c', 'c'] extra_paths = ['C:\\\\', 'alone', '/a/space in filename', 'C:\\\\multi\n\nline'] print([extract_basename(path) for path in extra_paths]) # ['C:', 'alone', 'space in filename', 'multi\n\nline'] If you only want a potential filename, if present (i.e., is a dir and so is ), change the regex to: . For the \"regex challenged,\" this changes the positive forward lookahead for some sort of slash to a negative forward lookahead, causing pathnames that end with said slash to return nothing instead of the last sub-directory in the pathname. Of course there is no guarantee that the potential filename actually refers to a file and for that or would need to be employed. This will match as follows: /a/b/c/ # nothing, pathname ends with the dir 'c' c:\\windows\\ # nothing, pathname ends with the dir 'windows' c:hello.txt # matches potential filename 'hello.txt' ~it_s_me/.bashrc # matches potential filename '.bashrc' c:\\windows\\system32 # matches potential filename 'system32', except # that is obviously a dir. os.path.is_dir() # should be used to tell us for sure The regex can be tested here.\n\nThe Windows separator can be in a Unix filename or Windows Path. The Unix separator can only exist in the Unix path. The presence of a Unix separator indicates a non-Windows path. The following will strip (cut trailing separator) by the OS specific separator, then split and return the rightmost value. It's ugly, but simple based on the assumption above. If the assumption is incorrect, please update and I will update this response to match the more accurate conditions. a.rstrip(\"\\\\\\\\\" if a.count(\"/\") == 0 else '/').split(\"\\\\\\\\\" if a.count(\"/\") == 0 else '/')[-1] b = ['a/b/c/','a/b/c','\\\\a\\\\b\\\\c','\\\\a\\\\b\\\\c\\\\','a\\\\b\\\\c','a/b/../../a/b/c/','a/b/../../a/b/c'] for a in b: print (a, a.rstrip(\"\\\\\" if a.count(\"/\") == 0 else '/').split(\"\\\\\" if a.count(\"/\") == 0 else '/')[-1])\n\nIn both Python 2 and 3, using the module pathlib2: import posixpath # to generate unix paths from pathlib2 import PurePath, PureWindowsPath, PurePosixPath def path2unix(path, nojoin=True, fromwinpath=False): \"\"\"From a path given in any format, converts to posix path format fromwinpath=True forces the input path to be recognized as a Windows path (useful on Unix machines to unit test Windows paths)\"\"\" if not path: return path if fromwinpath: pathparts = list(PureWindowsPath(path).parts) else: pathparts = list(PurePath(path).parts) if nojoin: return pathparts else: return posixpath.join(*pathparts) In [9]: path2unix('lala/lolo/haha.dat') Out[9]: ['lala', 'lolo', 'haha.dat'] In [10]: path2unix(r'C:\\lala/lolo/haha.dat') Out[10]: ['C:\\\\', 'lala', 'lolo', 'haha.dat'] In [11]: path2unix(r'C:\\lala/lolo/haha.dat') # works even with malformatted cases mixing both Windows and Linux path separators Out[11]: ['C:\\\\', 'lala', 'lolo', 'haha.dat'] In [12]: testcase = paths = ['a/b/c/', 'a/b/c', '\\\\a\\\\b\\\\c', '\\\\a\\\\b\\\\c\\\\', 'a\\\\b\\\\c', ...: ... 'a/b/../../a/b/c/', 'a/b/../../a/b/c'] In [14]: for t in testcase: ...: print(path2unix(t)[-1]) ...: ...: c c c c c c c The idea here is to convert all paths into the unified internal representation of , with different decoders depending on the platform. Fortunately, includes a generic decoder called that should work on any path. In case this does not work, you can force the recognition of windows path using . This will split the input string into parts, the last one is the leaf you are looking for, hence the . If the argument , the path will be joined back, so that the output is simply the input string converted to a Unix format, which can be useful to compare subpaths across platforms."
    },
    {
        "link": "https://docs.python.org/3/library/os.path.html",
        "document": "Source code: Lib/genericpath.py, Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows).\n\nThis module implements some useful functions on pathnames. To read or write files see , and for accessing the filesystem see the module. The path parameters can be passed as strings, or bytes, or any object implementing the protocol.\n\nUnlike a Unix shell, Python does not do any automatic path expansions. Functions such as and can be invoked explicitly when an application desires shell-like path expansion. (See also the module.)\n\nSince different operating systems have different path name conventions, there are several versions of this module in the standard library. The module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is always in one of the different formats. They all have the same interface:\n\nOn Unix and Windows, return the argument with an initial component of or replaced by that user’s home directory. On Unix, an initial is replaced by the environment variable if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module . An initial is looked up directly in the password directory. On Windows, will be used if set, otherwise a combination of and will be used. An initial is handled by checking that the last directory component of the current user’s home directory matches , and replacing it if so. If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged. Changed in version 3.8: No longer uses on Windows.\n\nJoin one or more path segments intelligently. The return value is the concatenation of path and all members of *paths, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment. On Windows, the drive is not reset when a rooted path segment (e.g., ) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, represents a path relative to the current directory on drive ( ), not . Changed in version 3.6: Accepts a path-like object for path and paths."
    },
    {
        "link": "https://geeksforgeeks.org/python-os-path-basename-method",
        "document": "OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using operating system dependent functionality. os.path module is sub module of OS module in Python used for common path name manipulation.\n\nos.path.basename() method in Python is used to get the base name in specified path. This method internally use os.path.split() method to split the specified path into a pair (head, tail). os.path.basename() method returns the tail part after splitting the specified path into (head, tail) pair. \n\n\n\nWhat is find() Method in Python?\n\nThe method in Python is used with strings to locate the position of a substring within the string. It returns the lowest index of the substring if it is found, or if it is not found. It can also take optional arguments to specify the start and end positions for the search within the string. text = \"Hello, welcome to my world.\" \n\n \n\n print(index) # Output: 7 (position of the first character of the substring)\n\nWhat is the Purpose of the Path Basename() Method?\n\nThe function in Python’s module is used to extract the base name of a specified pathname. This is useful when you need to extract the file name from a full path.\n\nIn Python, is a special attribute of a module or script. It contains the path to the script or the currently executing file. This is useful for generating paths relative to the current script, no matter where it is run from. # Prints the path to the current script \n\n\n\nWhat is the Use of Find() Method in String?\n\nThe method in strings is used to search for a substring within another string. It returns the index position of the first occurrence of the substring. If the substring is not found, it returns . This method is case-sensitive and can be used to check the presence of a substring before processing it further. \n\n \n\n print(result) # Output: 7 (the index where 'is' starts) These methods and attributes provide essential functionality for file handling and string manipulation in Python, making them indispensable for many programming tasks involving file operations and text processing."
    },
    {
        "link": "https://docs.vultr.com/python/examples/get-the-file-name-from-the-file-path",
        "document": "Get the file name from the file path\n\nPython Program to Get the File Name From the File Path\n\nExtracting the filename from a given file path is a common task that you might have to perform in Python programming, especially when handling file I/O operations. Whether you are writing scripts for data processing, managing logs, or simply organizing files, knowing how to isolate the file name from a full path is crucial for manipulation and processing tasks.\n\nIn this article, you will learn how to extract the file name from a file path in Python through practical examples. You'll discover methods using built-in libraries such as and , which simplify working with file paths across different operating systems, ensuring your code remains portable and clean.\n• None Import the module, which provides a portable way of using operating system dependent functionality.\n• None Use the function to extract the filename from a full path. This code snippet imports the module and uses to get from the given . The function parses the path and returns only the final component, which is typically the file name.\n• None Consider file paths that end with a slash, which might represent a directory rather than a file.\n• None Use in conjunction with other functions if necessary to ensure correct file name extraction. In this case, because ends with a slash, returns an empty string, highlighting the importance of validating paths.\n• None Import the module which offers a set of classes featuring all common operations on paths in an easy, object-oriented way.\n• None Use from the module to get the file name. In this example, creating a object from the file path allows access to various properties and methods, where directly provides the file name. This method is straightforward and fits well into a modern Pythonic approach to handling file system paths.\n• None Utilize the module to manipulate paths in a way that is independent of the operating system.\n• None Directly use methods like for the name without extension or for the extension. This snippet demonstrates how to separate the file name from its extension using and , enhancing the handling of file attributes separately, which is useful in many applications such as file sorting and filtering based on file type.\n\nExtracting the filename from a file path efficiently is a necessary skill in Python, especially useful in managing file operations and system administration tasks. By employing the and modules, you receive a robust toolkit for file path manipulation that works seamlessly across multiple operating systems. Embrace these techniques to ensure your code handles file paths gracefully and efficiently, keeping your file-related functions robust and flexible."
    },
    {
        "link": "https://stackoverflow.com/questions/678236/how-do-i-get-the-filename-without-the-extension-from-a-path-in-python",
        "document": "How do I get the filename without the extension from a path in Python?\n\nYou can make your own with: Important note: If there is more than one in the filename, only the last one is removed. For example: See below for other answers that address that.\n\nAnswers using Pathlib for Several Scenarios Using Pathlib, it is trivial to get the filename when there is just one extension (or none), but it can be awkward to handle the general case of multiple extensions. Zero or One extension from pathlib import Path pth = Path('./thefile.tar') fn = pth.stem print(fn) # thefile # Explanation: # the `stem` attribute returns only the base filename, stripping # any leading path if present, and strips the extension after # the last `.`, if present. # Further tests eg_paths = ['thefile', 'thefile.tar', './thefile', './thefile.tar', '../../thefile.tar', '.././thefile.tar', 'rel/pa.th/to/thefile', '/abs/path/to/thefile.tar'] for p in eg_paths: print(Path(p).stem) # prints thefile every time from pathlib import Path pth = Path('./thefile.tar.gz') fn = pth.with_suffix('').stem print(fn) # thefile # Explanation: # Using the `.with_suffix('')` trick returns a Path object after # stripping one extension, and then we can simply use `.stem`. # Further tests eg_paths += ['./thefile.tar.gz', '/abs/pa.th/to/thefile.tar.gz'] for p in eg_paths: print(Path(p).with_suffix('').stem) # prints thefile every time Any number of extensions (0, 1, or more) from pathlib import Path pth = Path('./thefile.tar.gz.bz.7zip') fn = pth.name if len(pth.suffixes) > 0: s = pth.suffixes[0] fn = fn.rsplit(s)[0] # or, equivalently fn = pth.name for s in pth.suffixes: fn = fn.rsplit(s)[0] break # or simply run the full loop fn = pth.name for _ in pth.suffixes: fn = fn.rsplit('.')[0] # In any case: print(fn) # thefile # Explanation # # pth.name -> 'thefile.tar.gz.bz.7zip' # pth.suffixes -> ['.tar', '.gz', '.bz', '.7zip'] # # If there may be more than two extensions, we can test for # that case with an if statement, or simply attempt the loop # and break after rsplitting on the first extension instance. # Alternatively, we may even run the full loop and strip one # extension with every pass. # Further tests eg_paths += ['./thefile.tar.gz.bz.7zip', '/abs/pa.th/to/thefile.tar.gz.bz.7zip'] for p in eg_paths: pth = Path(p) fn = pth.name for s in pth.suffixes: fn = fn.rsplit(s)[0] break print(fn) # prints thefile every time Special case in which the first extension is known For instance, if the extension could be , , , etc; you can simply the known extension and take the first element:\n\nThe other methods don't remove multiple extensions. Some also have problems with filenames that don't have extensions. This snippet deals with both instances and works in both Python 2 and 3. It grabs the basename from the path, splits the value on dots, and returns the first one which is the initial part of the filename. In every case, the value printed is:\n\nUsing is the right way to go, but here is an ugly solution that is way more efficient than the pathlib based approach. You have a filepath whose fields are separated by a forward slash , slashes cannot be present in filenames, so you split the filepath by , the last field is the filename. The extension is always the last element of the list created by splitting the filename by dot , so if you reverse the filename and split by dot once, the reverse of the second element is the file name without extension. Python 3.9.10 (tags/v3.9.10:f2f3f53, Jan 17 2022, 15:14:21) [MSC v.1929 64 bit (AMD64)] Type 'copyright', 'credits' or 'license' for more information IPython 7.28.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: from pathlib import Path In [2]: file = 'D:/ffmpeg/ffmpeg.exe' In [3]: Path(file).stem Out[3]: 'ffmpeg' In [4]: file.split('/')[-1][::-1].split('.', 1)[1][::-1] Out[4]: 'ffmpeg' In [5]: %timeit Path(file).stem 6.15 µs ± 433 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) In [6]: %timeit file.split('/')[-1][::-1].split('.', 1)[1][::-1] 671 ns ± 37.8 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) In [7]: This answer somehow got downvoted. Anyway I just found a better solution. I didn't know there is a function when I first posted the answer. Using it I don't need to do two reverses. In [11]: file = 'D:/ffmpeg/ffmpeg.exe' In [12]: file.split('/')[-1][::-1].split('.', 1)[1][::-1] Out[12]: 'ffmpeg' In [13]: file.split('/')[-1].rsplit('.', 1)[0] Out[13]: 'ffmpeg' In [14]: %timeit file.split('/')[-1].rsplit('.', 1)[0] 359 ns ± 4.59 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each) In [15]: %timeit file.split('/')[-1][::-1].split('.', 1)[1][::-1] 556 ns ± 3.9 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)"
    },
    {
        "link": "https://geeksforgeeks.org/file-getname-method-in-java-with-examples",
        "document": "The getName() method is a part of File class. This function returns the Name of the given file object. The function returns a string object which contains the Name of the given file object.If the abstract path does not contain any name then a null string is returned.\n\nParameters: This function does not accept any parameters.\n\nReturn value: This function returns a String value which is the Name of the given File object.\n\nBelow programs will illustrate the use of the getName() function:\n\nExample 1: We are given a file object of a file, we have to get the Name of the file object.\n\nExample 2: We are given a file object of a directory, we have to get the Name of the file object.\n\nThe programs might not run in an online IDE. please use an offline IDE and set the Name of the file"
    },
    {
        "link": "https://stackoverflow.com/questions/14526260/how-do-i-get-the-file-name-from-a-string-containing-the-absolute-file-path",
        "document": "Any file name/path manipulation should go through APIs in the package.\n\n[...] may be used to locate a file in a file system. It will typically represent a system dependent file path. A Path represents a path that is hierarchical and composed of a sequence of directory and file name elements separated by a special separator or delimiter. A root component, that identifies a file system hierarchy, may also be present. The name element that is farthest from the root of the directory hierarchy is the name of a file or directory. [...]\n\nYou can get an instance of type using the factory method, (or the class as described here).\n\nOnce you have an appropriate instance representing your full path, you can use\n\nNote: This all assumes you're running in a Windows environment (considering your file path). If not, you'll need to use a that supports Windows path naming.\n\nAlternatively, with only string manipulation, and considering the you're asking about is\n\nwe need to extract everything after the last separator, ie. . That is what we are interested in.\n\nYou can do\n\nThis will retrieve the index of the last in your and extract everything that comes after it into .\n\nIf you have a with a different separator, adjust the to use that separator. (There's even an overload that accepts an entire as a separator.)\n\nI've omitted it in the example above, but if you're unsure where the comes from or what it might contain, you'll want to validate that the returns a non-negative value because the Javadoc states it'll return"
    },
    {
        "link": "https://stackoverflow.com/questions/23017557/how-to-get-class-name-of-any-java-file",
        "document": "Does java offer a simple way to do this?\n\nI know how to get this using\n\nBut how would I be able to do this for any object I may be passing in through some method? Say\n\nWhere file is some java file with a .java extension. I know it works if I directly hard code the name of the java class into , but my approach at this includes java files not found in the current directory or package. Anyone guide me in the right direction? Thanks in advance."
    },
    {
        "link": "https://baeldung.com/java-filename-full-path",
        "document": "When we work with files in Java, we often need to extract the filename from a given absolute path.\n\nIn this tutorial, we’ll explore how to extract the filename.\n\nThe problem is pretty straightforward. Imagine we’re given an absolute file path string. We want to extract the filename from it. A couple of examples may explain the problem quickly:\n\nAs we’ve seen, different filesystems may have different file separators. Therefore, in this tutorial, we’ll address some platform-independent solutions. In other words, the same implementation will work on both *nix and Windows systems.\n\nFor simplicity, we’ll use unit test assertions to verify if the solutions work as expected.\n\nNext, let’s see them in action.\n\nFirst of all, filesystems don’t allow filenames to contain file separators. So, for example, we cannot create a file whose name contains “/” on Linux’s Ext2, Ext3, or Ext4 filesystems:\n\nIn the example above, the filesystem treats “a/” as a directory. Based on this rule, an idea to solve the problem is to take out the substring from the last file separator until the end of the string.\n\nString’s lastIndexOf() method returns a substring’s last indexing in that string. And then, we can simply get the filename by calling absolutePath.substring(lastIndex+1).\n\nAs we can see, the implementation is straightforward. However, we should note that to make our solution system-independent, we shouldn’t hard code the file separator as “\\\\” for Windows or “/” for *nix systems. Instead, let’s use File.separator in our code so that our program automatically adapts to the system it’s running on:\n\nThe test above passes if we run it on a Linux machine. Similarly, the test below passes on a Windows machine:\n\nAs we can see, the same implementation works on both systems.\n\nApart from parsing the absolute path as a string, we can use the standard File class to solve the problem.\n\nThe File class provides the getName() method to get the filename directly. Further, we can construct a File object from the given absolute path string.\n\nLet’s first test it on the Linux system:\n\nThe test passes if we give it a run. As File uses File.separator internally, if we test the same solution on a Windows system, it passes as well:\n\nFile is a standard class from the java.io package. Since Java 1.7, the newer java.nio libraries ship with the Path interface.\n\nOnce we have a Path object, we can get the filename by calling the Path.getFileName() method. Unlike the File class, we can create a Path instance using the static Paths.get() method.\n\nNext, let’s create a Path instance from the given PATH_LINUX string and test the solution on Linux:\n\nWhen we execute the test, it passes. It’s worth mentioning that Path.getFileName() returns a Path object. Therefore, we call the toString() method explicitly to convert it into a string.\n\nThe same implementation works on a Windows system with PATH_WIN as the path string too. This is because Path can detect the current FileSystem it’s running on:\n\n6. Using the FilenameUtils.getName() From Apache Commons IO\n\nSo far, we’ve addressed three solutions to extract the filename from an absolute path. As we’ve mentioned, they’re platform-independent. However, all these three solutions work correctly only if the given absolute path matches the system the program is running on. For instance, our program can only handle Windows paths if it runs on Windows.\n\nWell, in practice, the possibility of parsing a different system’s path format is relatively low. However, Apache Commons IO‘s FilenameUtils class can “intelligently” extract the filename from different path formats. So if our program runs on Windows, it can also work for Linux file paths and vice versa.\n\nAs we can see, the test above parses both PATH_LINUX and PATH_WIN. The test passes no matter whether we run it on Linux or Windows.\n\nSo next, we may want to know how FilenameUtils can automatically handle paths of different systems.\n\nIf we have a look at FilenameUtils.getName()‘s implementation, its logic is similar to our “lastIndexOf” file separator approach. The difference is that FilenameUtils calls the lastIndexOf() method twice, once with the *nix separator (/), then with the Windows file separator (\\). Finally, it takes the greater index as the “lastIndex”:\n\nTherefore, FilenameUtils.getName() doesn’t check the current filesystem or the system’s file separator. Instead, it finds the last file separator’s index, no matter which system it belongs to, and then extracts the substring from this index until the end of the string as the final result.\n\nNow we understand how FilenameUtils.getName() works. It’s indeed a clever solution, and it works in most cases. However, many Linux-supported filesystems allow a filename to contain backslashes (‘\\’):\n\nIf the filename in the given Linux file path contains backslashes, the FilenameUtils.getName() will fail. A test may explain it clearly:\n\nWe should keep this case in mind when we use this method.\n\nIn this article, we’ve learned how to extract the filename from a given absolute path string."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/File.html",
        "document": "\n• A particular Java platform may support zero or more hierarchically-organized file systems. Each file system has a directory from which all other files in that file system can be reached. Windows platforms, for example, have a root directory for each active drive; UNIX platforms have a single root directory, namely . The set of available filesystem roots is affected by various system-level operations such as the insertion or ejection of removable media and the disconnecting or unmounting of physical or virtual disk drives. This method returns an array of objects that denote the root directories of the available filesystem roots. It is guaranteed that the canonical pathname of any file physically present on the local machine will begin with one of the roots returned by this method. The canonical pathname of a file that resides on some other machine and is accessed via a remote-filesystem protocol such as SMB or NFS may or may not begin with one of the roots returned by this method. If the pathname of a remote file is syntactically indistinguishable from the pathname of a local file then it will begin with one of the roots returned by this method. Thus, for example, objects denoting the root directories of the mapped network drives of a Windows platform will be returned by this method, while objects containing UNC pathnames will not be returned by this method. Unlike most methods in this class, this method does not throw security exceptions. If a security manager exists and its method denies read access to a particular root directory, then that directory will not appear in the result. An array of objects denoting the available filesystem roots, or if the set of roots could not be determined. The array will be empty if there are no filesystem roots.\n• Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name. If this method returns successfully then it is guaranteed that:\n• The file denoted by the returned abstract pathname did not exist before this method was invoked, and\n• Neither this method nor any of its variants will return the same abstract pathname again in the current invocation of the virtual machine. This method provides only part of a temporary-file facility. To arrange for a file created by this method to be deleted automatically, use the This method provides only part of a temporary-file facility. To arrange for a file created by this method to be deleted automatically, use the method. The argument must be at least three characters long. It is recommended that the prefix be a short, meaningful string such as or . The argument may be , in which case the suffix will be used. To create the new file, the prefix and the suffix may first be adjusted to fit the limitations of the underlying platform. If the prefix is too long then it will be truncated, but its first three characters will always be preserved. If the suffix is too long then it too will be truncated, but if it begins with a period character ( ) then the period and the first three characters following it will always be preserved. Once these adjustments have been made the name of the new file will be generated by concatenating the prefix, five or more internally-generated characters, and the suffix. If the argument is then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property . On UNIX systems the default value of this property is typically or ; on Microsoft Windows systems it is typically . A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method. - The prefix string to be used in generating the file's name; must be at least three characters long - The suffix string to be used in generating the file's name; may be , in which case the suffix will be used - The directory in which the file is to be created, or if the default temporary-file directory is to be used - If the argument contains fewer than three characters - If a file could not be created - If a security manager exists and its method does not allow a file to be created"
    },
    {
        "link": "https://nodejs.org/api/path.html",
        "document": "The module provides utilities for working with file and directory paths. It can be accessed using:\n\nThe default operation of the module varies based on the operating system on which a Node.js application is running. Specifically, when running on a Windows operating system, the module will assume that Windows-style paths are being used. So using might yield different results on POSIX and Windows: To achieve consistent results when working with Windows file paths on any operating system, use : To achieve consistent results when working with POSIX file paths on any operating system, use : On Windows Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example, can potentially return a different result than . For more information, see this MSDN page.\n\nPassing a non-string as the argument will throw now. The method returns the last portion of a , similar to the Unix command. Trailing directory separators are ignored. Although Windows usually treats file names, including file extensions, in a case-insensitive manner, this function does not. For example, and refer to the same file, but treats the extension as a case-sensitive string: A is thrown if is not a string or if is given and is not a string.\n\nPassing a non-string as the argument will throw now. The method returns the extension of the , from the last occurrence of the (period) character to end of string in the last portion of the . If there is no in the last portion of the , or if there are no characters other than the first character of the basename of (see ) , an empty string is returned. A is thrown if is not a string.\n\nThe dot will be added if it is not specified in .\n• <Object> Any JavaScript object having the following properties: The method returns a path string from an object. This is the opposite of . When providing properties to the remember that there are combinations where one property has priority over another:\n• is ignored if is provided\n• and are ignored if exists\n\nThe method determines if the literal is absolute. Therefore, it’s not safe for mitigating path traversals. If the given is a zero-length string, will be returned. A is thrown if is not a string.\n\nThe method joins all given segments together using the platform-specific separator as a delimiter, then normalizes the resulting path. Zero-length segments are ignored. If the joined path string is a zero-length string then will be returned, representing the current working directory. A is thrown if any of the path segments is not a string.\n\nThe method normalizes the given , resolving and segments. When multiple, sequential path segment separation characters are found (e.g. on POSIX and either or on Windows), they are replaced by a single instance of the platform-specific path segment separator ( on POSIX and on Windows). Trailing separators are preserved. If the is a zero-length string, is returned, representing the current working directory. On POSIX, the types of normalization applied by this function do not strictly adhere to the POSIX specification. For example, this function will replace two leading forward slashes with a single slash as if it was a regular absolute path, whereas a few POSIX systems assign special meaning to paths beginning with exactly two forward slashes. Similarly, other substitutions performed by this function, such as removing segments, may change how the underlying system resolves the path. Since Windows recognizes multiple path separators, both separators will be replaced by instances of the Windows preferred separator ( ): A is thrown if is not a string.\n\nThe method returns an object whose properties represent significant elements of the . Trailing directory separators are ignored, see . The returned object will have the following properties: ┌─────────────────────┬────────────┐ │ dir │ base │ ├──────┬ ├──────┬─────┤ │ root │ │ name │ ext │ \" / home/user/dir / file .txt \" └──────┴──────────────┴──────┴─────┘ (All spaces in the \"\" line should be ignored. They are purely for formatting.) ┌─────────────────────┬────────────┐ │ dir │ base │ ├──────┬ ├──────┬─────┤ │ root │ │ name │ ext │ \" C:\\ path\\dir \\ file .txt \" └──────┴──────────────┴──────┴─────┘ (All spaces in the \"\" line should be ignored. They are purely for formatting.) A is thrown if is not a string.\n\nOn Windows, the leading slashes for UNC paths are now included in the return value. The method returns the relative path from to based on the current working directory. If and each resolve to the same path (after calling on each), a zero-length string is returned. If a zero-length string is passed as or , the current working directory will be used instead of the zero-length strings. A is thrown if either or is not a string.\n\nThe method resolves a sequence of paths or path segments into an absolute path. The given sequence of paths is processed from right to left, with each subsequent prepended until an absolute path is constructed. For instance, given the sequence of path segments: , , , calling would return because is not an absolute path but is. If, after processing all given segments, an absolute path has not yet been generated, the current working directory is used. The resulting path is normalized and trailing slashes are removed unless the path is resolved to the root directory. If no segments are passed, will return the absolute path of the current working directory. A is thrown if any of the arguments is not a string."
    },
    {
        "link": "https://nodejs.org/en/learn/manipulating-files/nodejs-file-paths",
        "document": "Every file in the system has a path. On Linux and macOS, a path might look like: while Windows computers are different, and have a structure such as:\n\nYou need to pay attention when using paths in your applications, as this difference must be taken into account.\n\nYou include this module in your files using and you can start using its methods.\n\nGetting information out of a path\n\nGiven a path, you can extract information out of it using those methods:\n• : gets the parent folder of a file\n\nYou can get the file name without the extension by specifying a second argument to :\n\nYou can join two or more parts of a path by using :\n\nYou can get the absolute path calculation of a relative path using :\n\nIn this case Node.js will simply append to the current working directory. If you specify a second parameter folder, will use the first as a base for the second:\n\nIf the first parameter starts with a slash, that means it's an absolute path:\n\nis another useful function, that will try and calculate the actual path, when it contains relative specifiers like or , or double slashes:\n\nNeither resolve nor normalize will check if the path exists. They just calculate a path based on the information they got."
    },
    {
        "link": "https://geeksforgeeks.org/node-js-path-basename-method",
        "document": "The path.basename() method is used to get the filename portion of a path to the file. The trailing directory separators are ignored when using this method.\n\nParameters: This method accepts two parameters as mentioned above and described below:\n• path: It is the file path that would be used to extract the filename.\n• extension: It is an optional file extension that would be removed from the returned string.\n\nReturn Value: It returns a string with the filename portion of the path. It throws an error if the path or the extension parameters are not string values.\n\nBelow programs illustrate the path.basename() method in node.js:"
    },
    {
        "link": "https://w3schools.com/nodejs/met_path_basename.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/19811541/get-file-name-from-absolute-path-in-nodejs",
        "document": "How can I get the file name from an absolute path in Nodejs? I know it works with a string operation, like , but I want to know is there an explicit way, like in Java?"
    }
]