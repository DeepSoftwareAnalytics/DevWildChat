[
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://programiz.com/c-programming/c-dynamic-memory-allocation",
        "document": "As you know, an array is a collection of a fixed number of values. Once the size of an array is declared, you cannot change it.\n\nSometimes the size of the array you declared may be insufficient. To solve this issue, you can allocate memory manually during run-time. This is known as dynamic memory allocation in C programming.\n\nTo allocate memory dynamically, library functions are , , and are used. These functions are defined in the header file.\n\nThe name \"malloc\" stands for memory allocation.\n\nThe function reserves a block of memory of the specified number of bytes. And, it returns a pointer of which can be casted into pointers of any form.\n\nThe above statement allocates 400 bytes of memory. It's because the size of is 4 bytes. And, the pointer holds the address of the first byte in the allocated memory.\n\nThe expression results in a pointer if the memory cannot be allocated.\n\nThe name \"calloc\" stands for contiguous allocation.\n\nThe function allocates memory and leaves the memory uninitialized, whereas the function allocates memory and initializes all bits to zero.\n\nThe above statement allocates contiguous space in memory for 25 elements of type .\n\nDynamically allocated memory created with either or doesn't get freed on their own. You must explicitly use to release the space.\n\nThis statement frees the space allocated in the memory pointed by .\n\nHere, we have dynamically allocated the memory for number of .\n\nIf the dynamically allocated memory is insufficient or more than required, you can change the size of previously allocated memory using the function.\n\nHere, is reallocated with a new size ."
    },
    {
        "link": "https://github.com/RAGUL1902/Dynamic-Memory-Allocation-in-C",
        "document": "Dynamic memory allocation is the process of assigning the memory space during runtime of the program. This is implemented in C as the functions malloc, calloc, realloc, and free from stdlib. malloc allocates a single block of memory of specified size and returns the pointer to the allocated block. calloc works similarly to malloc but initializes the allocated memory to zero. realloc is used to change the size of an allocated block of memory. Free deallocates memory associated with a pointer.\n• Each of the functions are implemented in seperate files.\n• The memory is being allocated as different blocks as per the requests.\n• Each block of memory that is being allocated contains two sections.\n• The first part contains the meta information about the block( aka meta_block) and the second part is left to use for storing data.\n• Storing meta information about the block is vital and becomes handy when dealing with freeing the memory allocated.\n• These blocks are maintained in the order they are being allocated.\n• For this purpose, these blocks are made into a doubly linked list.\n• Keeping the list of the blocks of free space and used space as a doubly linked list comes in handy when dealing with fragmentation.\n• The requested size is aligned to the multiple of 4 greater than or equal to the size. Handling the addresses becomes simpler when they are aligned.\n• The system calls and are used to move the break of the heap.\n• contains the structure which stores information about the memory block.\n• Every is a node in the doubly linked list. The head of the doubly linked list in maintained globally in the variable .\n• It stores information such as:\n• Whether the coresponding memory block is free or not.\n• The address of the next and previous node in the doubly linked list.\n• Pointer to the starting of the memory block used to store information.\n• A character array variable which does not store any value but is used to get the address from where data can be stored.\n• The function when invoked finds if there exist a free block of memory with aleast the required amount of space which is free by going through the linked list.\n• The function when invoked splits the memory block into two if it contains enough space that can be used to store data.\n• The function when invoked extends the heap and adds a new memory block to the linked list.\n• When the function is called:\n• Creates a new block by invoking if the is .\n• Else it iterates through the linkedlist to find if any suitable block(block with aleast requested size).\n• If a suitable block is found, it is returned.\n• Else it extends the heap and returns the newly created block.\n• It also check if the block found in the linkedlist has enough extra space to be splited. In this case, is invoked.\n• The function first checks if the pointer passed as argument is a valid pointer or not (i.e., created using malloc()) using .\n• Then using the address of the of that corresponding memory location can be found.\n• The block to be freed is merged with the previous or the next memory block it any of it is free using .\n• If the block to be freed is at the end of the linked list, then it is removed from the linkedlist and the break of the heap is modified using .\n• First is used to allocate the required amount of space.\n• Then by iterating through every byte the value is set to 0.\n• If the pointer to the old address(passed as argument) is , then malloc is used to allocate the required memory.\n• If the memory block of the old address has at least the required size then it is returned as it is.\n• Then the next block is checked if it free and merged using .\n• If the space in the block is more than required after merging, then it is split using .\n• If the next block is not free then new block is allocated using .\n• The data is then copied from the old location to the new location using .\n• The pointer to the new location is returned.\n• Testing code to test all the functions implemented.\n• First two new variables are created and allocated space using .\n• Then the first varaible is freed and is called again to show that space can be reused.\n• Then is used to allocate an int array of size 5. Initially the values will be set to 0 by ;\n• Then the array is resized to size 10 using .\n\nP.S: Please go through the comments in the code for more techincal details on the functions."
    },
    {
        "link": "https://medium.com/@theodoretsori/how-to-use-malloc-and-free-in-c-for-dynamic-memory-allocation-and-deallocation-335482dd15b4",
        "document": "and are two important functions in the C programming language that are used to dynamically allocate and deallocate memory, respectively.\n\nstands for \"memory allocation\", and it is used to dynamically allocate a block of memory in the heap. It takes a single argument, the size of the block of memory to be allocated in bytes, and returns a pointer to the first byte of the allocated memory. If the allocation fails, it returns a null pointer. Here is an example of using to dynamically allocate memory for an array of integers:\n\nis used to deallocate memory that was previously allocated using or another memory allocation function such as or . It takes a single argument, a pointer to the memory to be deallocated. It is important to deallocate memory when it is no longer needed to avoid memory leaks. Here is an example of using to deallocate the memory allocated in the example above:\n\nIt is important to note that does not set the pointer to the deallocated memory to , so it is a good idea to set the pointer to after calling to prevent any attempts to use the deallocated memory.\n\nIn summary, and are essential functions in C for dynamically allocating and deallocating memory. They allow a program to obtain and release memory as needed, making it possible to create complex data structures and manage memory efficiently.\n\nIf you found this article helpful follow and leave a comment."
    },
    {
        "link": "https://stackoverflow.com/questions/13442375/best-practice-for-allocating-memory-for-use-by-a-function-malloc-inside-or-out",
        "document": "The criteria I'd use for deciding are:\n• None If the code outside the called function can know how much memory to allocate, then it is better to have the calling code allocate the memory.\n• None If the code outside the called function cannot know how much memory to allocate, then the called function must do the memory allocation. It is likely then that there will be a second function available to release the memory returned by the first function (the 'called' function), unless it is just a single that's needed. The function documentation should make this clear.\n\nFor example, if the called function is reading a complete tree structure from a file, the function will have to allocate the memory. But, there will also be a companion function for releasing the memory (since the called code knows how to do it and the calling code shouldn't need to know).\n\nOn the other hand, if the called function is reading a simple list of integer and floating point values into a fixed size structure, it is far better to make the calling function allocate the memory. Note that I skipped 'strings'! If the strings are of a fixed size in the structure, then the calling function can do the allocation, but if the strings are of variable size, then probably the called function does the allocation.\n\nThe Standard C Library has functions like which expect the calling code to allocate the memory to be used. The calling sequence tells how much space is available. You run into problems if you didn't provide enough memory. (The problem with is that you may only get the start of a line of text, not the whole line of text.)\n\nThe POSIX 2008 Library provides which will allocate enough space for the line.\n\nThe and related functions (see TR24731-2) allocate memory as required. The function does not — it is told how much space there is available, it uses no more than that, and says how much it really needed, and it is up to you to note if you didn't provide enough space and do something about it (allocate more space and try again, or blithely ignore the truncated value and continue as if nothing went wrong)."
    },
    {
        "link": "https://stackoverflow.com/questions/34097032/what-should-you-keep-in-mind-when-doing-operations-on-doubly-linked-lists",
        "document": "When dealing with pointers, you always want to make sure you any objects that are no longer in use. That's so there aren't any memory leaks.\n\nEdge conditions are, for example, when inserting an element, does it work for an empty list, when the item will be inserted as the first element, as the last element? Normally, when implementing insert we do the logic for a typical element (i.e. one in the middle of an existing list). But it should work for all cases. The cases I mentioned could be considered edge conditions and have to be considered for each an every operation you want to implement for the list."
    },
    {
        "link": "https://geeksforgeeks.org/doubly-linked-list",
        "document": "A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages. The main advantage of a doubly linked list is that it allows for efficient traversal of the list in both directions. This is because each node in the list contains a pointer to the previous node and a pointer to the next node. This allows for quick and easy insertion and deletion of nodes from the list, as well as efficient traversal of the list in both directions.\n\nIn a data structure, a doubly linked list is represented using nodes that have three fields:\n• None A pointer to the next node ( next\n\nHere is how a node in a Doubly Linked List is typically represented:\n\n// To store the Value or data. // Pointer to point the Next Element // To store the Value or data. // Pointer to point the Next Element // To store the Value or data. // Reference to the next Node # To store the value or data. # Reference to the next node // To store the value or data // Pointer to the next node // To store the value or data. // Reference to the next node\n\nEach node in a Doubly Linked List contains the data it holds, a pointer to the next node in the list, and a pointer to the previous node in the list. By linking these nodes together through the next and prev pointers, we can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.\n\nTraversal in a Doubly Linked List involves visiting each node, processing its data, and moving to the next or previous node using the forward ( ) and backward ( ) pointers.\n• Traverse forward\n• None Visit the current node and process its data (e.g., print it).\n• None Move to the next node using\n• None Repeat the process until the end of the list (\n• Optionally, traverse backward\n• None Start from the tail (last node).\n• None Visit the current node and process its data.\n• None Move to the previous node using\n• None Repeat the process until the beginning of the list (\n\nTraversal is useful for displaying or processing all nodes in a doubly linked list.\n\nA Doubly Linked List (DLL) is a type of linked list where each node has two pointers:\n• None One pointing to the next node in the sequence.\n• None One pointing to the previous node in the sequence.\n\nTo find the length of a doubly linked list, we need to traverse the list while counting the nodes.\n• Set a pointer to the head node ) and initialize it to the head of the linked list.\n• Traverse the list\n• None Move to the next node (\n• Stop at the end of the list\n• Return the count : The final value of gives the length of the doubly linked list.\n\nInsertion in a Doubly Linked List (DLL) involves adding a new node at a specific position while maintaining the connections between nodes. Since each node contains a pointer to both the previous and next node, insertion requires adjusting these pointers carefully.\n\nThere are three primary types of insertion in a DLL:\n• None Create a new node with the given data.\n• None pointer of the new node to the current head.\n• None If the list is not empty, update the pointer of the current head to point to the new node.\n• None Update the head of the list to the new node.\n• None Create a new node with the given data.\n• None If the list is empty, set the new node as the head.\n• None Traverse the list until the last node is found.\n• None pointer of the last node to the new node.\n• None pointer of the new node to the last node.\n• None Create a new node with the given data.\n• None If inserting at the beginning, follow the steps for insertion at the start.\n• None Traverse the list to find the node after which insertion is needed.\n• None pointer of the new node to the next node of the current position.\n• None pointer of the new node to the current node.\n• None pointer of the next node to point to the new node (if it exists).\n• None pointer of the previous node to point to the new node.\n\nDeletion in a Doubly Linked List (DLL) involves removing a node while maintaining the integrity of the list. Since each node contains pointers to both its previous and next nodes, deletion requires careful pointer adjustments to ensure no broken links occur.\n• None Check if the list is empty; if it is, return as there is nothing to delete.\n• None Move the head pointer to the next node.\n• None If the new head exists, update its\n• None Delete the old head node to free memory.\n• None Check if the list is empty; if it is, return.\n• None Traverse the list to find the last node.\n• None Store the last node in a temporary variable.\n• None pointer of the second-last node to , making it the new tail.\n• None Delete the last node to free memory.\n• None Check if the list is empty; if it is, return.\n• None Traverse the list to find the node to be deleted.\n• None Store the node to be deleted in a temporary variable.\n• None pointer of the previous node to point to the next node.\n• None pointer of the next node to point to the previous node (if it exists).\n• Efficient traversal in both directions: Doubly linked lists allow for efficient traversal of the list in both directions, making it suitable for applications where frequent insertions and deletions are required.\n• Easy insertion and deletion of nodes: The presence of pointers to both the previous and next nodes makes it easy to insert or delete nodes from the list, without having to traverse the entire list.\n• Can be used to implement a stack or queue: Doubly linked lists can be used to implement both stacks and queues, which are common data structures used in programming.\n• More complex than singly linked lists: Doubly linked lists are more complex than singly linked lists, as they require additional pointers for each node.\n• More memory overhead: Doubly linked lists require more memory overhead than singly linked lists, as each node stores two pointers instead of one.\n• None Implementation of undo and redo functionality in text editors.\n• None Cache implementation where quick insertion and deletion of elements are required.\n• None Browser history management to navigate back and forth between visited pages.\n• None Music player applications to manage playlists and navigate through songs efficiently.\n• None (double-ended queue) for efficient insertion and deletion at both ends."
    },
    {
        "link": "https://stackoverflow.com/questions/25894679/memory-trouble-with-doubly-linked-list-in-c",
        "document": "I think you shouldn't allocate a new list (here ) every push; just make it point on . Here you are just allocating a list and right after make the pointer to this list pointing to your . So there's no point to alloc it.\n\nAn allocation create enough space writtable by your programme, the pointer only store the address and that is what you want cause your pointer on the address won't change as long as you iterate your instead of .\n\nI could have lost myself in those explaination and maybe lost the purpose of your question but hope this will help you.\n\nOh and one last thing, maybe you should make point on .\n\nBut there's I still don't understand why you allocate 2 node in your init instead of pushing them 1 by 1 to your head"
    },
    {
        "link": "https://linkedin.com/advice/1/what-most-common-errors-when-implementing-linked-list-fzlpe",
        "document": "A fifth common error when implementing a linked list is failing to test your code thoroughly and rigorously. This can leave undetected bugs, errors, or vulnerabilities in your code, which can compromise its quality, reliability, or security. To avoid testing errors, you should use a systematic and comprehensive testing strategy, such as unit testing, integration testing, or regression testing. You can also use tools such as frameworks, libraries, or generators to automate and simplify your testing process. Help others by sharing more (125 characters min.)\n• Testing linked lists involves checking fundamental operations (insertion, deletion, search), handling edge cases (empty lists, insertions at the beginning/end), validating traversal and memory management, detecting and preventing cyclic structures, assessing performance for large datasets, addressing concurrency issues in multithreaded environments, ensuring data integrity, conducting boundary testing, and checking error handling. Systematic testing helps identify and address errors, ensuring the reliability and correctness of the linked list implementation.\n• Testing error refers to the mistakes or inaccuracies that can occur during the process of testing a system, software, or product. It's like proofreading a document – even with careful testing, there might be overlooked errors or issues that need fixing. Reducing testing errors involves thorough and systematic testing, often using various testing techniques, to increase the reliability and accuracy of the final product.\n• Testing your linked-list implementation is crucial. If you don't consider all the possible edge cases , it can backfire pretty quickly."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/9tyrc4/implementing_linked_lists_best_practices_and_best",
        "document": "Say I've implemented a queue as a linked list. There are a couple of ways you might do it.\n\nThis style, or something like it, is something I see a lot:\n\nThe advantages are mostly that everybody can tell right off the bat what it does.\n\nBut I like this style:\n\nI think this is more elegant, but now it involves a double de-reference of . Does anybody have any feel for whether or not this extra indirection will be a significant performance loss?\n\nConversely, there are no more conditionals in the \"append\" function, and only one in the \"remove\" function. That could very well be a serious win in any pipelined architecture."
    }
]