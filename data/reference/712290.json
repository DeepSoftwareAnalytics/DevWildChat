[
    {
        "link": "https://baeldung.com/java-run-jar-with-arguments",
        "document": "Typically, every meaningful application includes one or more JAR files as dependencies. But there are times a JAR file itself represents a standalone application or a web application.\n\nHere we’ll focus on the standalone application scenario. From now on, we’ll refer to it as a JAR application.\n\nIn this tutorial, we’ll first learn how to create a JAR application. Later, we’ll learn how to run a JAR application with or without command-line arguments.\n\nA JAR file can contain one or more main classes. Each main class is the entry point of an application. So, a JAR file can theoretically contain more than one application, but it has to contain at least one main class to be able to run.\n\nA JAR file can have one entry point set in its manifest file. In this case, the JAR file is an executable JAR. The main class has to be included in that JAR file.\n\nFirst, let’s see a quick example of how to compile our classes and create an executable JAR with a manifest file:\n\nA nonexecutable JAR is simply a JAR file that doesn’t have a Main-Class defined in the manifest file. As we’ll see later, we can still run a main class that’s contained in the JAR file itself.\n\nHere’s how we would create a nonexecutable JAR without a manifest file:\n\nJust like any application, a JAR application accepts any number of arguments, including zero arguments. It all depends on the application’s need.\n\nThis allows the user to specify configuration information when the application is launched.\n\nAs a result, the application can avoid hard-coded values, and it still can handle many different use cases.\n\nAn argument can contain any alphanumeric characters, unicode characters and possibly some special characters allowed by the shell, for example, @.\n\nArguments are separated by one or more spaces. If an argument needs to contain spaces, the spaces have to be enclosed between quotes. Either single quotes or double quotes work fine.\n\nUsually, for a typical Java application, when invoking the application, the user enters command-line arguments after the name of the class.\n\nHowever, that’s not always the case for JAR applications.\n\nAs we discussed, the entry point of a Java main class is the main method. The arguments are all Strings and are passed to the main method as a String array.\n\nThat said, inside the application, we can convert any element of the String array to other data types, such as char, int, double, their wrapper classes or other appropriate types.\n\nLet’s see the basic syntax for running an executable JAR file with arguments:\n\nThe executable JAR created earlier is a simple application that just prints out the arguments passed in. We can run it with any number of arguments.\n\nHere’s an example with two arguments:\n\nWe’ll see this output in the console:\n\nSo, when invoking an executable JAR, we don’t need to specify the main class name on the command line. We simply add our arguments after the JAR file name. If we do provide a class name after the executable JAR file name, it simply becomes the first argument to the actual main class.\n\nMost times, a JAR application is an executable JAR. An executable JAR can have a maximum of one main class defined in the manifest file.\n\nConsequently, other applications in the same executable JAR file can’t be set in the manifest file, but we can still run them from the command line just like we would for a nonexecutable JAR. We’ll see exactly how in the next section.\n\nTo run an application in a nonexecutable JAR file, we have to use -cp option instead of -jar.\n\nWe’ll use the -cp option (short for classpath) to specify the JAR file that contains the class file we want to execute:\n\nAs we can see, in this case, we’ll have to include the main class name in the command line, followed by arguments.\n\nThe nonexecutable JAR created earlier contains the same simple application. We can run it with any (including zero) arguments.\n\nHere’s an example with two arguments:\n\nAnd, just like we saw above, we’ll see this output:\n\nIn this article, we learned two ways of running a JAR application on the command line with or without arguments.\n\nWe also demonstrated that an argument could contain spaces and special characters (when allowed by the shell)."
    },
    {
        "link": "https://stackoverflow.com/questions/5774970/run-jar-file-in-command-prompt",
        "document": "If you dont have an entry point defined in your manifest invoking will not work.\n\nUse this command if you dont have a manifest or to run a different main class than the one specified in the manifest:\n\nSee also instructions on how to create a manifest with an entry point: https://docs.oracle.com/javase/tutorial/deployment/jar/appman.html"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/specs/man/jar.html",
        "document": "jar - create an archive for classes and resources, and manipulate or restore individual classes or resources from an archive\n\nThe command is a general-purpose archiving and compression tool, based on the ZIP and ZLIB compression formats. Initially, the command was designed to package Java applets (not supported since JDK 11) or applications; however, beginning with JDK 9, users can use the command to create modular JARs. For transportation and deployment, it's usually more convenient to package modules as modular JARs.\n\nThe syntax for the command resembles the syntax for the command. It has several main operation modes, defined by one of the mandatory operation arguments. Other arguments are either options that modify the behavior of the operation or are required to perform the operation.\n\nWhen modules or the components of an application (files, images and sounds) are combined into a single archive, they can be downloaded by a Java agent (such as a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. The command also compresses files, which further improves download time. The command also enables individual entries in a file to be signed so that their origin can be authenticated. A JAR file can be used as a class path entry, whether or not it's compressed.\n\nAn archive becomes a modular JAR when you include a module descriptor, , in the root of the given directories or in the root of the archive. The following operations described in Operation Modifiers Valid Only in Create and Update Modes are valid only when creating or updating a modular jar or updating an existing non-modular jar:\n\nAll mandatory or optional arguments for long options are also mandatory or optional for any corresponding short options.\n\nWhen using the command, you must specify the operation for it to perform. You specify the operation mode for the command by including the appropriate operation arguments described in this section. You can mix an operation argument with other one-letter options. Generally the operation argument is the first argument specified on the command line.\n\nYou can use the following options to customize the actions of any operation mode included in the command.\n\nChanges the specified directory and includes the files specified at the end of the command line. Creates a multirelease JAR file. Places all files specified after the option into a versioned directory of the JAR file named VERSION , where VERSION must be must be a positive integer whose value is 9 or greater. At run time, where more than one version of a class exists in the JAR, the JDK will use the first one it finds, searching initially in the directory tree whose VERSION number matches the JDK's major version number. It will then look in directories with successively lower VERSION numbers, and finally look in the root of the JAR.\n\nYou can use the following options to customize the actions of the create and the update main operation modes:\n\nYou can use the following options to customize the actions of the create ( or ) the update ( or ) and the generate-index ( or FILE) main operation modes:\n\nThe following options are recognized by the command and not used with operation modes:\n• None Create an archive, , that contains two class files, and .\n• None Create an archive, , by using an existing manifest, , that contains all of the files in the directory .\n• None Create a modular JAR archive, , where the module descriptor is located in .\n• None Create a versioned or multi-release JAR, , that places the files in the directory at the root of the JAR, and the files in the directory in the directory of the JAR. In this example, the directory contains two classes, (the entry point class) and , both compiled for JDK 8. The directory contains a different version of the class, this one containing JDK 10 specific code and compiled for JDK 10. Given this setup, create a multirelease JAR file by running the following command from the directory containing the directories and . The JAR file now contains: As well as other information, the file , will contain the following lines to indicate that this is a multirelease JAR file with an entry point of . Assuming that the class calls a method on the class, running the program using JDK 10 will ensure that the class is the one in . Running the program using JDK 8 will ensure that the class is the one at the root of the JAR, in .\n• None Create an archive, , by reading options and lists of class files from the file . To shorten or simplify the command, you can provide an arg file that lists the files to include in the JAR file and pass it to the command with the at sign ( ) as a prefix. If one or more entries in the arg file cannot be found then the jar command fails without creating the JAR file."
    },
    {
        "link": "https://stackoverflow.com/questions/18413014/run-a-jar-file-from-the-command-line-and-specify-classpath",
        "document": "I've compiled a JAR file and specified the Main-Class in the manifest (I used the Eclipse Export function). My dependencies are all in a directory labeled . I can't seem to get a straight answer on how to execute my JAR file while specifying it should use the as the classpath.\n\nEach gives an error saying:\n\nor gives the indicating the libraries are not being found.\n\nI even tried remaking the JAR file and included the directory and contents, but still no dice...\n\nHow can I execute a JAR file from the command line and specify the classpath to use?"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/22/docs/specs/man/jar.html",
        "document": "jar - create an archive for classes and resources, and manipulate or restore individual classes or resources from an archive\n\nThe command is a general-purpose archiving and compression tool, based on the ZIP and ZLIB compression formats. Initially, the command was designed to package Java applets (not supported since JDK 11) or applications; however, beginning with JDK 9, users can use the command to create modular JARs. For transportation and deployment, it's usually more convenient to package modules as modular JARs.\n\nThe syntax for the command resembles the syntax for the command. It has several main operation modes, defined by one of the mandatory operation arguments. Other arguments are either options that modify the behavior of the operation or are required to perform the operation.\n\nWhen modules or the components of an application (files, images and sounds) are combined into a single archive, they can be downloaded by a Java agent (such as a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. The command also compresses files, which further improves download time. The command also enables individual entries in a file to be signed so that their origin can be authenticated. A JAR file can be used as a class path entry, whether or not it's compressed.\n\nAn archive becomes a modular JAR when you include a module descriptor, , in the root of the given directories or in the root of the archive. The following operations described in Operation Modifiers Valid Only in Create and Update Modes are valid only when creating or updating a modular jar or updating an existing non-modular jar:\n\nAll mandatory or optional arguments for long options are also mandatory or optional for any corresponding short options.\n\nWhen using the command, you must specify the operation for it to perform. You specify the operation mode for the command by including the appropriate operation arguments described in this section. You can mix an operation argument with other one-letter options. Generally the operation argument is the first argument specified on the command line.\n\nYou can use the following options to customize the actions of any operation mode included in the command.\n\nChanges the specified directory and includes the files specified at the end of the command line. Creates a multirelease JAR file. Places all files specified after the option into a versioned directory of the JAR file named VERSION , where VERSION must be must be a positive integer whose value is 9 or greater. At run time, where more than one version of a class exists in the JAR, the JDK will use the first one it finds, searching initially in the directory tree whose VERSION number matches the JDK's major version number. It will then look in directories with successively lower VERSION numbers, and finally look in the root of the JAR.\n\nYou can use the following options to customize the actions of the create and the update main operation modes:\n\nYou can use the following options to customize the actions of the create ( or ) the update ( or ) and the generate-index ( or FILE) main operation modes:\n\nThe following options are recognized by the command and not used with operation modes:\n• None Create an archive, , that contains two class files, and .\n• None Create an archive, , that contains two class files, and setting the last modified date and time to .\n• None Create an archive, , by using an existing manifest, , that contains all of the files in the directory .\n• None Create a modular JAR archive, , where the module descriptor is located in .\n• None Create a versioned or multi-release JAR, , that places the files in the directory at the root of the JAR, and the files in the directory in the directory of the JAR. In this example, the directory contains two classes, (the entry point class) and , both compiled for JDK 8. The directory contains a different version of the class, this one containing JDK 10 specific code and compiled for JDK 10. Given this setup, create a multirelease JAR file by running the following command from the directory containing the directories and . The JAR file now contains: As well as other information, the file , will contain the following lines to indicate that this is a multirelease JAR file with an entry point of . Assuming that the class calls a method on the class, running the program using JDK 10 will ensure that the class is the one in . Running the program using JDK 8 will ensure that the class is the one at the root of the JAR, in .\n• None Create an archive, , by reading options and lists of class files from the file . To shorten or simplify the command, you can provide an arg file that lists the files to include in the JAR file and pass it to the command with the at sign ( ) as a prefix. If one or more entries in the arg file cannot be found then the jar command fails without creating the JAR file."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api",
        "document": "Defines the jlink tool for creating run-time images, the jmod tool for creating and manipulating JMOD files, and the jimage tool for inspecting the JDK implementation-specific container file for classes and resources.\n\nDefines an API for expressing computations that can be reliably compiled at runtime into SIMD instructions, such as AVX instructions on x64, and NEON instructions on AArch64.\n\nReport a bug or suggest an enhancement\n\n For further API reference and developer documentation see the Java SE Documentation, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. Other versions.\n\n Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.\n\n Copyright © 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.\n\nAll rights reserved. Use is subject to license terms and the documentation redistribution policy."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html",
        "document": "To launch the main class in a JAR file:\n\nTo launch the main class in a module:\n\nThe command starts a Java application. It does this by starting the Java Virtual Machine (JVM), loading the specified class, and calling that class's method. The method must be declared and , it must not return any value, and it must accept a array as a parameter. The method declaration has the following form:\n\nIn source-file mode, the command can launch a class declared in a source file. See Using Source-File Mode to Launch Single-File Source-Code Programs for a description of using the source-file mode.\n\nBy default, the first argument that isn't an option of the command is the fully qualified name of the class to be called. If is specified, then its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the manifest header in its manifest file.\n\nArguments after the class file name or the JAR file name are passed to the method.\n\nWindows: The command is identical to , except that with there's no associated console window. Use when you don't want a command prompt window to appear. The launcher will, however, display a dialog box with error information if a launch fails.\n\nTo launch a class declared in a source file, run the launcher in source-file mode. Entering source-file mode is determined by two items on the command line:\n• None The first item on the command line that is not an option or part of an option. In other words, the item in the command line that would otherwise be the main class name.\n\nIf the class identifies an existing file that has a extension, or if the option is specified, then source-file mode is selected. The source file is then compiled and run. The option can be used to specify the source version or N of the source code. This determines the API that can be used. When you set N, you can only use the public API that was defined in JDK N.\n\nIf the file does not have the extension, the option must be used to tell the command to use the source-file mode. The option is used for cases when the source file is a \"script\" to be executed and the name of the source file does not follow the normal naming conventions for Java source files.\n\nIn source-file mode, the effect is as though the source file is compiled into memory, and the first class found in the source file is executed. Any arguments placed after the name of the source file in the original command line are passed to the compiled class when it is executed.\n\nFor example, if a file were named and contained a class named , then the source-file mode command to launch the class would be:\n\nThe example illustrates that the class can be in a named package, and does not need to be in the unnamed package. This use of source-file mode is informally equivalent to using the following two commands where is the name of the class in the package:\n\nIn source-file mode, any additional command-line options are processed as follows:\n• None The launcher scans the options specified before the source file for any that are relevant in order to compile the source file. This includes: , , , , , , , and any variant forms of those options. It also includes the new option, described in JEP 12.\n• None No provision is made to pass any additional options to the compiler, such as or .\n• None Command-line argument files ( -files) may be used in the standard way. Long lists of arguments for either the VM or the program being invoked may be placed in files specified on the command-line by prefixing the filename with an character.\n\nIn source-file mode, compilation proceeds as follows:\n• None Any command-line options that are relevant to the compilation environment are taken into account.\n• None No other source files are found and compiled, as if the source path is set to an empty value.\n• None Annotation processing is disabled, as if is in effect.\n• None If a version is specified, via the option, the value is used as the argument for an implicit option for the compilation. This sets both the source version accepted by compiler and the system API that may be used by the code in the source file.\n• None The source file is compiled in the context of an unnamed module.\n• None The source file should contain one or more top-level classes, the first of which is taken as the class to be executed.\n• None The compiler does not enforce the optional restriction defined at the end of JLS ??7.6, that a type in a named package should exist in a file whose name is composed from the type name followed by the extension.\n• None If the source file contains errors, appropriate error messages are written to the standard error stream, and the launcher exits with a non-zero exit code.\n\nIn source-file mode, execution proceeds as follows:\n• None The class to be executed is the first top-level class found in the source file. It must contain a declaration of the standard method.\n• None The compiled classes are loaded by a custom class loader, that delegates to the application class loader. This implies that classes appearing on the application class path cannot refer to any classes declared in the source file.\n• None The compiled classes are executed in the context of an unnamed module, as though is in effect. This is in addition to any other options that may be have been specified on the command line.\n• None Any arguments appearing after the name of the file on the command line are passed to the standard main method in the obvious way.\n• None It is an error if there is a class on the application class path whose name is the same as that of the class to be executed.\n\nprepends its content to the options parsed from the command line. The content of the environment variable is a list of arguments separated by white-space characters (as determined by ). These are prepended to the command line arguments passed to launcher. The encoding requirement for the environment variable is the same as the command line on the system. environment variable content is treated in the same manner as that specified in the command line.\n\nSingle ( ) or double ( ) quotes can be used to enclose arguments that contain whitespace characters. All content between the open quote and the first matching close quote are preserved by simply removing the pair of quotes. In case a matching quote is not found, the launcher will abort with an error message. -files are supported as they are specified in the command line. However, as in -files, use of a wildcard is not supported. In order to mitigate potential misuse of behavior, options that specify the main class (such as ) or cause the launcher to exit without executing the main class (such as ) are disallowed in the environment variable. If any of these options appear in the environment variable, the launcher will abort with an error message. When is set, the launcher prints a message to stderr as a reminder.\n\nis equivalent to the command line:\n\nThe command supports a wide range of options in the following categories:\n• None Standard Options for Java: Options guaranteed to be supported by all implementations of the Java Virtual Machine (JVM). They're used for common actions, such as checking the version of the JRE, setting the class path, enabling verbose output, and so on.\n• None Extra Options for Java: General purpose options that are specific to the Java HotSpot Virtual Machine. They aren't guaranteed to be supported by all JVM implementations, and are subject to change. These options start with .\n\nThe advanced options aren't recommended for casual use. These are developer options used for tuning specific areas of the Java HotSpot Virtual Machine operation that often have specific system requirements and may require privileged access to system configuration parameters. Several examples of performance tuning are provided in Performance Tuning Examples. These options aren't guaranteed to be supported by all JVM implementations and are subject to change. Advanced options start with .\n• None Advanced Runtime Options for Java: Control the runtime behavior of the Java HotSpot VM.\n• None Advanced JIT Compiler Options for java: Control the dynamic just-in-time (JIT) compilation performed by the Java HotSpot VM.\n• None Advanced Garbage Collection Options for Java: Control how garbage collection (GC) is performed by the Java HotSpot\n\nBoolean options are used to either enable a feature that's disabled by default or disable a feature that's enabled by default. Such options don't require a parameter. Boolean options are enabled using the plus sign ( OptionName) and disabled using the minus sign ( OptionName).\n\nFor options that require an argument, the argument may be separated from the option name by a space, a colon (:), or an equal sign (=), or the argument may directly follow the option (the exact syntax differs for each option). If you're expected to specify the size in bytes, then you can use no suffix, or use the suffix or for kilobytes (KB), or for megabytes (MB), or or for gigabytes (GB). For example, to set the size to 8 GB, you can specify either , , , or as the argument. If you are expected to specify the percentage, then use a number from 0 to 1. For example, specify for 25%.\n\nThe following sections describe the options that are obsolete, deprecated, and removed:\n• None Deprecated Java Options: Accepted and acted upon --- a warning is issued when they're used.\n• None Obsolete Java Options: Accepted but ignored --- a warning is issued when they're used.\n• None Removed Java Options: Removed --- using them results in an error.\n\nThese are the most commonly used options supported by all implementations of the JVM.\n\nThe following options are general purpose options that are specific to the Java HotSpot Virtual Machine.\n\nThe following extra options are macOS specific.\n\nThese options can be used to enable other advanced options.\n\nThese options control the runtime behavior of the Java HotSpot VM.\n\nOverrides the number of CPUs that the VM will use to calculate the size of thread pools it will use for various operations such as Garbage Collection and ForkJoinPool. The VM normally determines the number of available processors from the operating system. This flag can be useful for partitioning CPU resources when running multiple Java processes in docker containers. This flag is honored even if is not enabled. See for a description of enabling and disabling container support. Takes a path to the file system and uses memory mapping to allocate the object heap on the memory device. Using this option enables the HotSpot VM to allocate the Java object heap on an alternative memory device, such as an NV-DIMM, specified by the user. Alternative memory devices that have the same semantics as DRAM, including the semantics of atomic operations, can be used instead of DRAM for the object heap without changing the existing application code. All other memory structures (such as the code heap, metaspace, and thread stacks) continue to reside in DRAM. Some operating systems expose non-DRAM memory through the file system. Memory-mapped files in these file systems bypass the page cache and provide a direct mapping of virtual memory to the physical memory on the device. The existing heap related flags (such as and ) and garbage-collection related flags continue to work as before. Disables the Compact Strings feature. By default, this option is enabled. When this option is enabled, Java Strings containing only single-byte characters are internally represented and stored as single-byte-per-character Strings using ISO-8859-1 / Latin-1 encoding. This reduces, by 50%, the amount of space required for Strings containing only single-byte characters. For Java Strings containing at least one multibyte character: these are represented and stored as 2 bytes per character using UTF-16 encoding. Disabling the Compact Strings feature forces the use of UTF-16 encoding as the internal representation for all Java Strings. Cases where it may be beneficial to disable Compact Strings include the following:\n• None When it's known that an application overwhelmingly will be allocating multibyte character Strings\n• None In the unexpected event where a performance regression is observed in migrating from Java SE 8 to Java SE 9 and an analysis shows that Compact Strings introduces the regression In both of these scenarios, disabling Compact Strings makes sense. Specifies the path and file name to which error data is written when an irrecoverable error occurs. By default, this file is created in the current working directory and named pid where pid is the identifier of the process that encountered the error. The following example shows how to set the default log file (note that the identifier of the process is specified as ):\n• None Linux and macOS: The following example shows how to set the error log to :\n• None Windows: The following example shows how to set the error log file to : If the file exists, and is writeable, then it will be overwritten. Otherwise, if the file can't be created in the specified directory (due to insufficient space, permission problem, or another issue), then the file is created in the temporary directory for the operating system:\n• None Linux and macOS: The temporary directory is .\n• None Windows: The temporary directory is specified by the value of the environment variable; if that environment variable isn't defined, then the value of the environment variable is used. Enables the reporting of more extensive error information in the . This option can be turned on in environments where maximal information is desired - even if the resulting logs may be quite large and/or contain information that might be considered sensitive. The information can vary from release to release, and across different platforms. By default this option is disabled. Sets the parameters that control the behavior of JFR. The following list contains the available JFR parameter value entries: Specifies the total amount of primary memory used for data retention. The default value is based on the value specified for . Change the parameter to alter the size of global buffers. Specifies the maximum size (in bytes) of the data chunks in a recording. Append or to specify the size in megabytes (MB), or or to specify the size in gigabytes (GB). By default, the maximum size of data chunks is set to 12 MB. The minimum allowed is 1 MB. Determines how much buffer memory should be used, and sets the and parameters based on the size specified. Append or to specify the size in megabytes (MB), or or to specify the size in gigabytes (GB). By default, the memory size is set to 10 MB. Specifies the number of global buffers used. The default value is based on the memory size specified. Change the parameter to alter the number of global buffers. Maximum number of old objects to track. By default, the number of objects is set to 256. Specifies the repository (a directory) for temporary disk storage. By default, the system's temporary directory is used. Specifies whether event classes should be retransformed using JVMTI. If false, instrumentation is added when event classes are loaded. By default, this parameter is enabled. Specifies whether thread sampling is enabled. Thread sampling occurs only if the sampling event is enabled along with this parameter. By default, this parameter is enabled. Stack depth for stack traces. By default, the depth is set to 64 method calls. The maximum is 2048. Values greater than 64 could create significant overhead and reduce performance. Specifies the per-thread local buffer size (in bytes). By default, the local buffer size is set to 8 kilobytes, with a minimum value of 4 kilobytes. Overriding this parameter could reduce performance and is not recommended. You can specify values for multiple parameters by separating them with a comma. Sets the maximum large page size (in bytes) used by the JVM. The size argument must be a valid page size supported by the environment to have any effect. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the size is set to 0, meaning that the JVM will use the default large page size for the environment as the maximum size for large pages. See Large Pages. The following example describes how to set the large page size to 1 gigabyte (GB): Sets the maximum total size (in bytes) of the package, direct-buffer allocations. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the size is set to 0, meaning that the JVM chooses the size for NIO direct-buffer allocations automatically. The following examples illustrate how to set the NIO size to 1024 KB in different units: Disables the attempt to set the soft limit for the number of open file descriptors to the hard limit. By default, this option is enabled on all platforms, but is ignored on Windows. The only time that you may need to disable this is on Mac OS, where its use imposes a maximum of 10240, which is lower than the actual system maximum. Specifies the mode for tracking JVM native memory usage. Possible mode arguments for this option include the following: Instructs not to track JVM native memory usage. This is the default behavior if you don't specify the option. Tracks memory usage only by JVM subsystems, such as Java heap, class, code, and thread. In addition to tracking memory usage by JVM subsystems, track memory usage by individual , individual virtual memory region and its committed regions. Sets the memory alignment of Java objects (in bytes). By default, the value is set to 8 bytes. The specified value should be a power of 2, and must be within the range of 8 and 256 (inclusive). This option makes it possible to use compressed pointers with large Java heap sizes. The heap size limit in bytes is calculated as: Note: As the alignment value increases, the unused space between objects also increases. As a result, you may not realize any benefits from using compressed pointers with large Java heap sizes. Sets a custom command or a series of semicolon-separated commands to run when an irrecoverable error occurs. If the string contains spaces, then it must be enclosed in quotation marks.\n• None Linux and macOS: The following example shows how the option can be used to run the command to create a core image, and start the debugger to attach to the process in case of an irrecoverable error (the designates the current process identifier):\n• None Windows: The following example shows how the option can be used to run the utility to obtain a crash dump in case of an irrecoverable error (the designates the current process identifier). This example assumes that the path to the utility is specified in the environment variable: Sets a custom command or a series of semicolon-separated commands to run when an exception is first thrown. If the string contains spaces, then it must be enclosed in quotation marks. For an example of a command string, see the description of the option. Enables printing of ergonomically selected JVM flags that appeared on the command line. It can be useful to know the ergonomic values set by the JVM, such as the heap space size and the selected garbage collector. By default, this option is disabled and flags aren't printed. Selects between using the RBP register as a general purpose register ( ) and using the RBP register to hold the frame pointer of the currently executing method ( . If the frame pointer is available, then external profiling tools (for example, Linux perf) can construct more accurate stack traces. Enables printing of collected native memory tracking data at JVM exit when native memory tracking is enabled (see ). By default, this option is disabled and native memory tracking data isn't printed. Specifies the path and name of the class data sharing (CDS) archive file If this option is specified, the JVM will load a CDS archive file only if it passes an integrity check based on CRC32 checksums. The purpose of this flag is to check for unintentional damage to CDS archive files in transmission or storage. To guarantee the security and proper operation of CDS, the user must ensure that the CDS archive files used by Java applications cannot be modified without proper authorization. Specifies the text file that contains the names of the classes to store in the class data sharing (CDS) archive. This file contains the full name of one class per line, except slashes ( ) replace dots ( ). For example, to specify the classes and , create a text file that contains the following two lines: The classes that you specify in this text file should include the classes that are commonly used by the application. They may include any classes from the application, extension, or bootstrap class paths. Enables printing of improved messages. When an application throws a , the option enables the JVM to analyze the program's bytecode instructions to determine precisely which reference is , and describes the source with a null-detail message. The null-detail message is calculated and returned by , and will be printed as the exception message along with the method, filename, and line number. By default, this option is enabled. Enables the display of a dialog box when the JVM experiences an irrecoverable error. This prevents the JVM from exiting and keeps the process active so that you can attach a debugger to it to investigate the cause of the error. By default, this option is disabled. Starts a JFR recording for the Java application. This option is equivalent to the diagnostic command that starts a recording during runtime. You can set the following parameter value entries when starting a JFR recording: Specifies the delay between the Java application launch time and the start of the recording. Append to specify the time in seconds, for minutes, for hours, or for days (for example, means 10 minutes). By default, there's no delay, and this parameter is set to 0. Specifies whether to write temporary data to the disk repository. By default, this parameter is set to . To enable it, set the parameter to . Specifies if the running recording is dumped when the JVM shuts down. If enabled and a is not entered, the recording is written to a file in the directory where the process was started. The file name is a system-generated name that contains the process ID, recording ID, and current timestamp, similar to . By default, this parameter is disabled. Specifies the duration of the recording. Append to specify the time in seconds, for minutes, for hours, or for days (for example, specifying means 5 hours). By default, the duration isn't limited, and this parameter is set to 0. Specifies the path and name of the file to which the recording is written when the recording is stopped, for example: Takes both the name and the identifier of a recording. Specifies the maximum age of disk data to keep for the recording. This parameter is valid only when the parameter is set to . Append to specify the time in seconds, for minutes, for hours, or for days (for example, specifying means 30 seconds). By default, the maximum age isn't limited, and this parameter is set to . Specifies the maximum size (in bytes) of disk data to keep for the recording. This parameter is valid only when the parameter is set to . The value must not be less than the value for the parameter set with . Append or to specify the size in megabytes, or or to specify the size in gigabytes. By default, the maximum size of disk data isn't limited, and this parameter is set to . Specifies whether to collect the path to garbage collection (GC) roots at the end of a recording. By default, this parameter is disabled. The path to GC roots is useful for finding memory leaks, but collecting it is time-consuming. Enable this option only when you start a recording for an application that you suspect has a memory leak. If the parameter is set to , the stack trace from where the potential leaking object was allocated is included in the information collected. Specifies the path and name of the event settings file (of type JFC). By default, the file is used, which is located in . This default settings file collects a predefined set of information with low overhead, so it has minimal impact on performance and can be used with recordings that run continuously. A second settings file is also provided, profile.jfc, which provides more data than the default configuration, but can have more overhead and impact performance. Use this configuration for short periods of time when more information is needed. You can specify values for multiple parameters by separating them with a comma. Event settings and .jfc options can be specified using the following syntax: Specifies the option value to modify. To list available options, use the /bin/jfr tool. Specifies the event setting value to modify. Use the form: # = To add a new event setting, prefix the event name with '+'. You can specify values for multiple event settings and .jfc options by separating them with a comma. In case of a conflict between a parameter and a .jfc option, the parameter will take precedence. The whitespace delimiter can be omitted for timespan values, i.e. 20ms. For more information about the settings syntax, see Javadoc of the jdk.jfr package. Sets the Java thread stack size (in kilobytes). Use of a scaling suffix, such as , results in the scaling of the kilobytes value so that sets the Java thread stack size to 1024*1024 bytes or 1 megabyte. The default value depends on the platform:\n• None Windows: The default value depends on virtual memory The following examples show how to set the thread stack size to 1 megabyte in different units: This option is similar to . Disables the use of compressed pointers. By default, this option is enabled, and compressed pointers are used. This will automatically limit the maximum ergonomically determined Java heap size to the maximum amount of memory that can be covered by compressed pointers. By default this range is 32 GB. With compressed oops enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes smaller than the compressed oops pointer range. This option works only for 64-bit JVMs. It's possible to use compressed pointers with Java heap sizes greater than 32 GB. See the option. The VM now provides automatic container detection support, which allows the VM to determine the amount of memory and number of processors that are available to a Java process running in docker containers. It uses this information to allocate system resources. This support is only available on Linux x64 platforms. If supported, the default for this flag is , and container support is enabled by default. It can be disabled with . Unified Logging is available to help to diagnose issues related to this support. Use for maximum logging of container information. See Enable Logging with the JVM Unified Logging Framework for a description of using Unified Logging. Linux only: This option is the equivalent of specifying . This option is disabled by default. This option pre-allocates all large pages up-front, when memory is reserved; consequently the JVM can't dynamically grow or shrink large pages memory areas; see if you want this behavior. Enables the use of large page memory. By default, this option is disabled and large page memory isn't used. Linux only: Enables the use of large pages that can dynamically grow or shrink. This option is disabled by default. You may encounter performance problems with transparent huge pages as the OS moves other pages around to create huge pages; this option is made available for experimentation. Enables installation of signal handlers by the application. By default, this option is disabled and the application isn't allowed to install signal handlers. Allows user to specify VM options in a file, for example, .\n\nThese options control the dynamic just-in-time (JIT) compilation performed by the Java HotSpot VM.\n\nSets the number of lines to prefetch ahead of the instance allocation pointer. By default, the number of lines to prefetch is set to 1: Sets the size (in bytes) of the prefetch distance for object allocation. Memory about to be written with the value of new objects is prefetched up to this distance starting from the address of the last allocated object. Each Java thread has its own allocation point. Negative values denote that prefetch distance is chosen based on the platform. Positive values are bytes to prefetch. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value is set to -1. The following example shows how to set the prefetch distance to 1024 bytes: Sets the prefetch instruction to prefetch ahead of the allocation pointer. Possible values are from 0 to 3. The actual instructions behind the values depend on the platform. By default, the prefetch instruction is set to 0: Sets the number of cache lines to load after the last object allocation by using the prefetch instructions generated in compiled code. The default value is 1 if the last allocated object was an instance, and 3 if it was an array. The following example shows how to set the number of loaded cache lines to 5: Sets the step size (in bytes) for sequential prefetch instructions. Append the letter or to indicate kilobytes, or to indicate megabytes, or to indicate gigabytes. By default, the step size is set to 16 bytes: Sets the generated code style for prefetch instructions. The style argument is an integer from 0 to 3: Execute prefetch instructions after each allocation. This is the default setting. Use the thread-local allocation block (TLAB) watermark pointer to determine when prefetch instructions are executed. Enables background compilation. This option is enabled by default. To disable background compilation, specify (this is equivalent to specifying ). Sets the number of compiler threads to use for compilation. By default, the number of compiler threads is selected automatically depending on the number of CPUs and memory available for compiled code. The following example shows how to set the number of threads to 2: Dynamically create compiler thread up to the limit specified by . This option is enabled by default. Specifies a command to perform on a method. For example, to exclude the method of the class from being compiled, use the following: Note that the full class name is specified, including all packages and subpackages separated by a slash ( ). For easier cut-and-paste operations, it's also possible to use the method name format produced by the and options: If the method is specified without the signature, then the command is applied to all methods with the specified name. However, you can also specify the signature of the method in the class file format. In this case, you should enclose the arguments in quotation marks, because otherwise the shell treats the semicolon as a command end. For example, if you want to exclude only the method of the class from being compiled, use the following: You can also use the asterisk (*) as a wildcard for class and method names. For example, to exclude all methods in all classes from being compiled, use the following: The commas and periods are aliases for spaces, making it easier to pass compiler commands through a shell. You can pass arguments to using spaces as separators by enclosing the argument in quotation marks: Note that after parsing the commands passed on the command line using the options, the JIT compiler then reads commands from the file. You can add commands to this file or specify a different file using the option. To add several commands, either specify the option multiple times, or separate each argument with the new line separator ( ). The following commands are available: Sets a breakpoint when debugging the JVM to stop at the beginning of compilation of the specified method. Excludes all methods from compilation except for the specified method. As an alternative, you can use the option, which lets you specify several methods. Prevents inlining of the specified method. Excludes the specified method from compilation. Prints a help message for the option. Attempts to inline the specified method. Excludes compilation logging (with the option) for all methods except for the specified method. By default, logging is performed for all compiled methods. Passes a JIT compilation option to the specified method in place of the last argument ( ). The compilation option is set at the end, after the method name. For example, to enable the option for the method of the class, use the following: You can specify multiple compilation options, separated by commas or spaces. Prints generated assembler code after compilation of the specified method. Instructs not to print the compile commands. By default, the commands that you specify with the option are printed; for example, if you exclude from compilation the method of the class, then the following is printed to standard output: You can suppress this by specifying the option before other options. Sets the file from which JIT compiler commands are read. By default, the file is used to store commands performed by the JIT compiler. Each line in the command file represents a command, a class name, and a method name for which the command is used. For example, this line prints assembly code for the method of the class: If you're using commands for the JIT compiler to perform on methods, then see the option. Adds directives from a file to the directives stack when a program starts. See Compiler Control. The option has to be used together with the option that unlocks diagnostic JVM options. Prints the directives stack when the program starts or when a new directive is added. The option has to be used together with the option that unlocks diagnostic JVM options. Sets the list of methods (separated by commas) to which compilation should be restricted. Only the specified methods are compiled. Specify each method with the full class name (including the packages and subpackages). For example, to compile only the method of the class and the method of the class, use the following: Note that the full class name is specified, including all packages and subpackages separated by a slash ( ). For easier cut and paste operations, it's also possible to use the method name format produced by the and options: Although wildcards aren't supported, you can specify only the class or package name to compile all methods in that class or package, as well as specify just the method to compile methods with this name in any class: Provides unified control of first compilation. This option controls when methods are first compiled for both the tiered and the nontiered modes of operation. The option has a floating point value between 0 and +Inf and scales the thresholds corresponding to the current mode of operation (both tiered and nontiered). Setting to a value less than 1.0 results in earlier compilation while values greater than 1.0 delay compilation. Setting to 0 is equivalent to disabling compilation. Enables the use of escape analysis. This option is enabled by default. To disable the use of escape analysis, specify . Sets the initial code cache size (in bytes). Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value depends on the platform. The initial code cache size shouldn't be less than the system's minimal memory page size. The following example shows how to set the initial code cache size to 32 KB: Enables method inlining. This option is enabled by default to increase performance. To disable method inlining, specify . Sets the maximum code size (in bytes) for already compiled methods that may be inlined. This flag only applies to the C2 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value depends on the platform and on whether tiered compilation is enabled. In the following example it is set to 1000 bytes: Enables logging of compilation activity to a file named in the current working directory. You can specify a different log file path and name using the option. By default, this option is disabled and compilation activity isn't logged. The option has to be used together with the option that unlocks diagnostic JVM options. You can enable verbose diagnostic output with a message printed to the console every time a method is compiled by using the option. Sets the maximum bytecode size (in bytes) of a hot method to be inlined. This flag only applies to the C2 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value depends on the platform. In the following example it is set to 325 bytes: Sets the maximum bytecode size (in bytes) of a cold method to be inlined. This flag only applies to the C2 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the maximum bytecode size is set to 35 bytes: Sets the maximum bytecode size (in bytes) of a cold method to be inlined. This flag only applies to the C1 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the maximum bytecode size is set to 35 bytes: Sets the maximum bytecode size (in bytes) of a trivial method to be inlined. This flag only applies to the C2 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the maximum bytecode size of a trivial method is set to 6 bytes: Sets the maximum bytecode size (in bytes) of a trivial method to be inlined. This flag only applies to the C1 compiler. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. By default, the maximum bytecode size of a trivial method is set to 6 bytes: Sets the maximum number of nodes to be used during single method compilation. By default the value depends on the features enabled. In the following example the maximum number of nodes is set to 100,000: Sets the size in bytes of the code segment containing nonmethod code. A nonmethod code segment containing nonmethod code, such as compiler buffers and the bytecode interpreter. This code type stays in the code cache forever. This flag is used only if is enabled. Sets the size in bytes of the code segment containing nonprofiled methods. This flag is used only if is enabled. Enables the optimization of concatenation operations. This option is enabled by default. To disable the optimization of concatenation operations, specify . Enables printing of assembly code for bytecoded and native methods by using the external or library. For 64-bit VM on Windows, it's . This lets you to see the generated code, which may help you to diagnose performance issues. By default, this option is disabled and assembly code isn't printed. The option has to be used together with the option that unlocks diagnostic JVM options. Sets the size in bytes of the code segment containing profiled methods. This flag is used only if is enabled. Enables verbose diagnostic output from the JVM by printing a message to the console every time a method is compiled. This lets you to see which methods actually get compiled. By default, this option is disabled and diagnostic output isn't printed. You can also log compilation activity to a file by using the option. Enables printing of inlining decisions. This let's you see which methods are getting inlined. By default, this option is disabled and inlining information isn't printed. The option has to be used together with the option that unlocks diagnostic JVM options. Sets the maximum code cache size (in bytes) for JIT-compiled code. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default maximum code cache size is 240 MB; if you disable tiered compilation with the option , then the default size is 48 MB. This option has a limit of 2 GB; otherwise, an error is generated. The maximum code cache size shouldn't be less than the initial code cache size; see the option . Specifies the RTM abort ratio is specified as a percentage (%) of all executed RTM transactions. If a number of aborted transactions becomes greater than this ratio, then the compiled code is deoptimized. This ratio is used when the option is enabled. The default value of this option is 50. This means that the compiled code is deoptimized if 50% of all transactions are aborted. Specifies the number of times that the RTM locking code is retried, when it is aborted or busy, before falling back to the normal locking mechanism. The default value for this option is 5. The option must be enabled. Enables segmentation of the code cache. Without the , the code cache consists of one large segment. With , we have separate segments for nonmethod, profiled method, and nonprofiled method code. These segments aren't resized at runtime. The feature is enabled by default if tiered compilation is enabled ( ) and >= 240 MB. The advantages are better control of the memory footprint, reduced code fragmentation, and better iTLB/iCache behavior due to improved locality. iTLB/iCache is a CPU-specific term meaning Instruction Translation Lookaside Buffer (ITLB). ICache is an instruction cache in theCPU. The implementation of the code cache can be found in the file: . Forces stack scanning of active methods to aggressively remove unused code when only the given percentage of the code cache is free. The default value is 10%. Disables the use of tiered compilation. By default, this option is enabled. Enables the use of SSE instruction set of a specified version. Is set by default to the highest supported version available (x86 only). Enables the use of AVX instruction set of a specified version. Is set by default to the highest supported version available (x86 only). Enables hardware-based AES intrinsics for hardware that supports it. This option is on by default on hardware that has the necessary instructions. The is used in conjunction with UseAESIntrinsics. Flags that control intrinsics now require the option . Enables AES intrinsics. Specifying is equivalent to also enabling . To disable hardware-based AES intrinsics, specify . For example, to enable hardware AES, use the following flags: Flags that control intrinsics now require the option . Controls the use of GHASH intrinsics. Enabled by default on platforms that support the corresponding instructions. Flags that control intrinsics now require the option . Controls the use of accelerated BASE64 encoding routines for . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Controls the use of Adler32 checksum algorithm intrinsic for . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Controls the use of CRC32 intrinsics for . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Controls the use of CRC32C intrinsics for . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Enables hardware-based intrinsics for SHA crypto hash functions for some hardware. The option is used in conjunction with the , , and options. The and flags are enabled by default on machines that support the corresponding instructions. This feature is applicable only when using the provider for SHA operations. Flags that control intrinsics now require the option . To disable all hardware-based SHA intrinsics, specify the . To disable only a particular SHA intrinsic, use the appropriate corresponding option. For example: . Enables intrinsics for SHA-1 crypto hash function. Flags that control intrinsics now require the option . Enables intrinsics for SHA-224 and SHA-256 crypto hash functions. Flags that control intrinsics now require the option . Enables intrinsics for SHA-384 and SHA-512 crypto hash functions. Flags that control intrinsics now require the option . Enables intrinsification of various functions. Enabled by default. Flags that control intrinsics now require the option . Enables intrinsification of . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Enables intrinsification of . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Enables intrinsification of . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Enables intrinsification of . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Enables intrinsification of . Enabled by default on platforms that support it. Flags that control intrinsics now require the option . Generates CMove (scalar and vector) instructions regardless of profitability analysis. Enables flushing of the code cache before shutting down the compiler. This option is enabled by default. To disable flushing of the code cache before shutting down the compiler, specify . Enables checking if the card is already marked before updating the card table. This option is disabled by default. It should be used only on machines with multiple sockets, where it increases the performance of Java applications that rely on concurrent operations. Keeps safepoints in counted loops. Its default value depends on whether the selected garbage collector requires low latency safepoints. Controls the number of iterations in the inner strip mined loop. Strip mining transforms counted loops into two level nested loops. Safepoints are kept in the outer loop while the inner loop can execute at full speed. This option controls the maximum number of iterations in the inner loop. The default value is 1,000. Controls loop strip mining optimization. Loops with the number of iterations less than specified will not have safepoints in them. Default value is 1/10th of . Enables hardware-based FMA intrinsics for hardware where FMA instructions are available (such as, Intel and ARM64). FMA intrinsics are generated for the a b c methods that calculate the value of a b c expressions. Autotunes RTM locking depending on the abort ratio. This ratio is specified by the option. If the number of aborted transactions exceeds the abort ratio, then the method containing the lock is deoptimized and recompiled with all locks as normal locks. This option is disabled by default. The option must be enabled. Generates Restricted Transactional Memory (RTM) locking code for all inflated locks, with the normal locking mechanism as the fallback handler. This option is disabled by default. Options related to RTM are available only on x86 CPUs that support Transactional Synchronization Extensions (TSX). RTM is part of Intel's TSX, which is an x86 instruction set extension and facilitates the creation of multithreaded applications. RTM introduces the new instructions , , , and . The and instructions enclose a set of instructions to run as a transaction. If no conflict is found when running the transaction, then the memory and register modifications are committed together at the instruction. The instruction can be used to explicitly abort a transaction and the instruction checks if a set of instructions is being run in a transaction. A lock on a transaction is inflated when another thread tries to access the same transaction, thereby blocking the thread that didn't originally request access to the transaction. RTM requires that a fallback set of operations be specified in case a transaction aborts or fails. An RTM lock is a lock that has been delegated to the TSX's system. RTM improves performance for highly contended locks with low conflict in a critical region (which is code that must not be accessed by more than one thread concurrently). RTM also improves the performance of coarse-grain locking, which typically doesn't perform well in multithreaded applications. (Coarse-grain locking is the strategy of holding locks for long periods to minimize the overhead of taking and releasing locks, while fine-grained locking is the strategy of trying to achieve maximum parallelism by locking only when necessary and unlocking as soon as possible.) Also, for lightly contended locks that are used by different threads, RTM can reduce false cache line sharing, also known as cache line ping-pong. This occurs when multiple threads from different processors are accessing different resources, but the resources share the same cache line. As a result, the processors repeatedly invalidate the cache lines of other processors, which forces them to read from main memory instead of their cache. Enables the transformation of scalar operations into superword operations. Superword is a vectorization optimization. This option is enabled by default. To disable the transformation of scalar operations into superword operations, specify .\n\nThese options provide the ability to gather system information and perform extensive debugging.\n\nThese options control how garbage collection (GC) is performed by the Java HotSpot VM.\n\nEnables Java heap optimization. This sets various parameters to be optimal for long-running jobs with intensive memory allocation, based on the configuration of the computer (RAM and CPU). By default, the option is disabled and the heap sizes are configured less aggressively. Requests the VM to touch every page on the Java heap after requesting it from the operating system and before handing memory out to the application. By default, this option is disabled and all pages are committed as the application uses the heap space. Sets the number of threads used for concurrent GC. Sets to approximately 1/4 of the number of parallel garbage collection threads. The default value depends on the number of CPUs available to the JVM. For example, to set the number of threads for concurrent GC to 2, specify the following option: Enables the option that disables processing of calls to the method. This option is disabled by default, meaning that calls to are processed. If processing of calls to is disabled, then the JVM still performs GC when necessary. Enables invoking of concurrent GC by using the request. This option is disabled by default and can be enabled only with the option. When is enabled, this option sets the number of completed marking cycles used to gather samples until G1 adaptively determines the optimum value of . Before, G1 uses the value of directly for this purpose. The default value is 3. Sets the size of the regions into which the Java heap is subdivided when using the garbage-first (G1) collector. The value is a power of 2 and can range from 1 MB to 32 MB. The default region size is determined ergonomically based on the heap size with a goal of approximately 2048 regions. The following example sets the size of the subdivisions to 16 MB: Sets the percentage of heap that you're willing to waste. The Java HotSpot VM doesn't initiate the mixed garbage collection cycle when the reclaimable percentage is less than the heap waste percentage. The default is 5 percent. Sets the percentage of the heap size to use as the maximum for the young generation size. The default value is 60 percent of your Java heap. This is an experimental flag. This setting replaces the setting. Sets the target number of mixed garbage collections after a marking cycle to collect old regions with at most live data. The default is 8 mixed garbage collections. The goal for mixed collections is to be within this target number. Sets the occupancy threshold for an old region to be included in a mixed garbage collection cycle. The default occupancy is 85 percent. This is an experimental flag. This setting replaces the setting. Sets the percentage of the heap to use as the minimum for the young generation size. The default value is 5 percent of your Java heap. This is an experimental flag. This setting replaces the setting. Sets an upper limit on the number of old regions to be collected during a mixed garbage collection cycle. The default is 10 percent of the Java heap. Sets the percentage of the heap (0 to 50) that's reserved as a false ceiling to reduce the possibility of promotion failure for the G1 collector. When you increase or decrease the percentage, ensure that you adjust the total Java heap by the same amount. By default, this option is set to 10%. The following example sets the reserved heap to 20%: Controls adaptive calculation of the old generation occupancy to start background work preparing for an old generation collection. If enabled, G1 uses for the first few times as specified by the value of , and after that adaptively calculates a new optimum value for the initiating occupancy automatically. Otherwise, the old generation collection process always starts at the old generation occupancy determined by . Sets the initial size (in bytes) of the memory allocation pool. This value must be either 0, or a multiple of 1024 and greater than 1 MB. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value is selected at run time based on the system configuration. The following examples show how to set the size of allocated memory to 6 MB using various units: If you set this option to 0, then the initial size is set as the sum of the sizes allocated for the old generation and the young generation. The size of the heap for the young generation can be set using the option. Note that the option sets both the minimum and the initial heap size of the heap. If appears after on the command line, then the initial heap size gets set to the value specified with . Sets the initial amount of memory that the JVM will use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the option. The default value is 1.5625 percent. The following example shows how to set the percentage of the initial amount of memory used for the Java heap: Sets the initial survivor space ratio used by the throughput garbage collector (which is enabled by the option). Adaptive sizing is enabled by default with the throughput garbage collector by using the option, and the survivor space is resized according to the application behavior, starting with the initial value. If adaptive sizing is disabled (using the option), then the option should be used to set the size of the survivor space for the entire execution of the application. The following formula can be used to calculate the initial size of survivor space (S) based on the size of the young generation (Y), and the initial survivor space ratio (R): The 2 in the equation denotes two survivor spaces. The larger the value specified as the initial survivor space ratio, the smaller the initial survivor space size. By default, the initial survivor space ratio is set to 8. If the default value for the young generation space size is used (2 MB), then the initial size of the survivor space is 0.2 MB. The following example shows how to set the initial survivor space ratio to 4: Sets the percentage of the old generation occupancy (0 to 100) at which to start the first few concurrent marking cycles for the G1 garbage collector. By default, the initiating value is set to 45%. A value of 0 implies nonstop concurrent GC cycles from the beginning until G1 adaptively sets this value. See also the and options. The following example shows how to set the initiating heap occupancy to 75%: Sets a target for the maximum GC pause time (in milliseconds). This is a soft goal, and the JVM will make its best effort to achieve it. The specified value doesn't adapt to your heap size. By default, for G1 the maximum pause time target is 200 milliseconds. The other generational collectors do not use a pause time goal by default. The following example shows how to set the maximum target pause time to 500 ms: Sets the maximum size (in byes) of the memory allocation pool. This value must be a multiple of 1024 and greater than 2 MB. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value is selected at run time based on the system configuration. For server deployments, the options and are often set to the same value. The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units: The option is equivalent to . Sets the maximum allowed percentage of free heap space (0 to 100) after a GC event. If free heap space expands above this value, then the heap is shrunk. By default, this value is set to 70%. Minimize the Java heap size by lowering the values of the parameters (default value is 70%) and (default value is 40%) with the command-line options and . Lowering to as low as 10% and to 5% has successfully reduced the heap size without too much performance regression; however, results may vary greatly depending on your application. Try different values for these parameters until they're as low as possible yet still retain acceptable performance. Customers trying to keep the heap small should also add the option . See Performance Tuning Examples for a description of using this option to keep the Java heap small by reducing the dynamic footprint for embedded applications. Sets the maximum amount of native memory that can be allocated for class metadata. By default, the size isn't limited. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system. The following example shows how to set the maximum class metadata size to 256 MB: Sets the maximum size (in bytes) of the heap for the young generation (nursery). The default value is set ergonomically. Sets the maximum amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics. The default value is the maximum amount of available memory to the JVM process or 128 GB, whichever is lower. The maximum amount of available memory to the JVM process is the minimum of the machine's physical memory and any constraints set by the environment (e.g. container). Specifying this option disables automatic use of compressed oops if the combined result of this and other options influencing the maximum amount of memory is larger than the range of memory addressable by compressed oops. See for further information about compressed oops. The following example shows how to set the maximum amount of available memory for sizing the Java heap to 2 GB: Sets the maximum amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the option. The default value is 25 percent. Specifying this option disables automatic use of compressed oops if the combined result of this and other options influencing the maximum amount of memory is larger than the range of memory addressable by compressed oops. See for further information about compressed oops. The following example shows how to set the percentage of the maximum amount of memory used for the Java heap: Sets the maximum amount of memory that the JVM may use for the Java heap before applying ergonomics heuristics as a percentage of the maximum amount determined as described in the option for small heaps. A small heap is a heap of approximately 125 MB. The default value is 50 percent. The following example shows how to set the percentage of the maximum amount of memory used for the Java heap for small heaps: Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector. The following example shows how to set the maximum tenuring threshold to 10: Sets the size of the allocated class metadata space that triggers a garbage collection the first time it's exceeded. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used. The default size depends on the platform. Sets the minimum allowed percentage of free heap space (0 to 100) after a GC event. If free heap space falls below this value, then the heap is expanded. By default, this value is set to 40%. Minimize Java heap size by lowering the values of the parameters (default value is 70%) and (default value is 40%) with the command-line options and . Lowering to as low as 10% and to 5% has successfully reduced the heap size without too much performance regression; however, results may vary greatly depending on your application. Try different values for these parameters until they're as low as possible, yet still retain acceptable performance. Customers trying to keep the heap small should also add the option . See Performance Tuning Examples for a description of using this option to keep the Java heap small by reducing the dynamic footprint for embedded applications. Sets the minimum size (in bytes) of the memory allocation pool. This value must be either 0, or a multiple of 1024 and greater than 1 MB. Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The default value is selected at run time based on the system configuration. The following examples show how to set the mimimum size of allocated memory to 6 MB using various units: If you set this option to 0, then the minimum size is set to the same value as the initial size. Sets the ratio between young and old generation sizes. By default, this option is set to 2. The following example shows how to set the young-to-old ratio to 1: Sets the initial size (in bytes) of the heap for the young generation (nursery). Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. The young generation region of the heap is used for new objects. GC is performed in this region more often than in other regions. If the size for the young generation is too low, then a large number of minor GCs are performed. If the size is too high, then only full GCs are performed, which can take a long time to complete. It is recommended that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size. The following examples show how to set the initial size of the young generation to 256 MB using various units: The option is equivalent to . Sets the number of the stop-the-world (STW) worker threads. The default value depends on the number of CPUs available to the JVM and the garbage collector selected. For example, to set the number of threads for G1 GC to 2, specify the following option: Enables parallel reference processing. By default, this option is disabled. Enables printing of information about adaptive-generation sizing. By default, this option is disabled. Enables GC of the young generation before each full GC. This option is enabled by default. It is recommended that you don't disable it, because scavenging the young generation before a full GC can reduce the number of objects reachable from the old generation space into the young generation space. To disable GC of the young generation before each full GC, specify the option . Sets the amount of time (in milliseconds) a softly reachable object is kept active on the heap after the last time it was referenced. The default value is one second of lifetime per free megabyte in the heap. The option accepts integer values representing milliseconds per one megabyte of the current heap size (for Java HotSpot Client VM) or the maximum possible heap size (for Java HotSpot Server VM). This difference means that the Client VM tends to flush soft references rather than grow the heap, whereas the Server VM tends to grow the heap rather than flush soft references. In the latter case, the value of the option has a significant effect on how quickly soft references are garbage collected. The following example shows how to set the value to 2.5 seconds: Incrementally reduces the Java heap to the target size, specified by the option . This option is enabled by default. If disabled, then it immediately reduces the Java heap to the target size instead of requiring multiple garbage collection cycles. Disable this option if you want to minimize the Java heap size. You will likely encounter performance degradation when this option is disabled. See Performance Tuning Examples for a description of using the option to keep the Java heap small by reducing the dynamic footprint for embedded applications. Identifies objects reaching the specified age that are considered candidates for deduplication. An object's age is a measure of how many times it has survived garbage collection. This is sometimes referred to as tenuring. Note: objects that are promoted to an old heap region before this age has been reached are always considered candidates for deduplication. The default value for this option is . See the option. Sets the ratio between eden space size and survivor space size. By default, this option is set to 8. The following example shows how to set the eden/survivor space ratio to 4: Sets the desired percentage of survivor space (0 to 100) used after young garbage collection. By default, this option is set to 50%. The following example shows how to set the target survivor space ratio to 30%: Sets the initial size (in bytes) of a thread-local allocation buffer (TLAB). Append the letter or to indicate kilobytes, or to indicate megabytes, or or to indicate gigabytes. If this option is set to 0, then the JVM selects the initial size automatically. The following example shows how to set the initial TLAB size to 512 KB: Enables the use of adaptive generation sizing. This option is enabled by default. To disable adaptive generation sizing, specify and set the size of the memory allocation pool explicitly. See the option. Enables the use of the garbage-first (G1) garbage collector. It's a server-style garbage collector, targeted for multiprocessor machines with a large amount of RAM. This option meets GC pause time goals with high probability, while maintaining good throughput. The G1 collector is recommended for applications requiring large heaps (sizes of around 6 GB or larger) with limited GC latency requirements (a stable and predictable pause time below 0.5 seconds). By default, this option is enabled and G1 is used as the default garbage collector. Enables the use of a policy that limits the proportion of time spent by the JVM on GC before an exception is thrown. This option is enabled, by default, and the parallel GC will throw an if more than 98% of the total time is spent on garbage collection and less than 2% of the heap is recovered. When the heap is small, this feature can be used to prevent applications from running for long periods of time with little or no progress. To disable this option, specify the option . Enables performance optimization of an application on a machine with nonuniform memory architecture (NUMA) by increasing the application's use of lower latency memory. By default, this option is disabled and no optimization for NUMA is made. The option is available only when the parallel garbage collector is used ( ). Enables the use of the parallel scavenge garbage collector (also known as the throughput collector) to improve the performance of your application by leveraging multiple processors. By default, this option is disabled and the default collector is used. Enables the use of the serial garbage collector. This is generally the best choice for small and simple applications that don't require any special functionality from garbage collection. By default, this option is disabled and the default collector is used. Linux only: Enables the JVM to use shared memory to set up large pages. See Large Pages for setting up large pages. Enables string deduplication. By default, this option is disabled. To use this option, you must enable the garbage-first (G1) garbage collector. String deduplication reduces the memory footprint of objects on the Java heap by taking advantage of the fact that many objects are identical. Instead of each object pointing to its own character array, identical objects can point to and share the same character array. Enables the use of thread-local allocation blocks (TLABs) in the young generation space. This option is enabled by default. To disable the use of TLABs, specify the option . Enables the use of the Z garbage collector (ZGC). This is a low latency garbage collector, providing max pause times of a few milliseconds, at some throughput cost. Pause times are independent of what heap size is used. Supports heap sizes from 8MB to 16TB. Sets the allocation spike tolerance for ZGC. By default, this option is set to 2.0. This factor describes the level of allocation spikes to expect. For example, using a factor of 3.0 means the current allocation rate can be expected to triple at any time. Sets the maximum interval (in seconds) between two GC cycles when using ZGC. By default, this option is set to 0 (disabled). Sets the maximum acceptable heap fragmentation (in percent) for ZGC. By default, this option is set to 25. Using a lower value will cause the heap to be compacted more aggressively, to reclaim more memory at the cost of using more CPU time. Enables proactive GC cycles when using ZGC. By default, this option is enabled. ZGC will start a proactive GC cycle if doing so is expected to have minimal impact on the running application. This is useful if the application is mostly idle or allocates very few objects, but you still want to keep the heap size down and allow reference processing to happen even when there are a lot of free space on the heap. Enables uncommitting of unused heap memory when using ZGC. By default, this option is enabled. Uncommitting unused heap memory will lower the memory footprint of the JVM, and make that memory available for other processes to use. Sets the amount of time (in seconds) that heap memory must have been unused before being uncommitted. By default, this option is set to 300 (5 minutes). Committing and uncommitting memory are relatively expensive operations. Using a lower value will cause heap memory to be uncommitted earlier, at the risk of soon having to commit it again.\n\nThese options are deprecated and might be removed in a future JDK release. They're still accepted and acted upon, but a warning is issued when they're used.\n\nThese options are still accepted but ignored, and a warning is issued when they're used.\n\nThese options have been removed in JDK 17 and using them results in an error of:\n\nFor the lists and descriptions of options removed in previous releases see the Removed Java Options section in:\n• None Java Platform, Standard Edition Tools Reference, Release 8 for Oracle JDK on Solaris, Linux, and macOS\n\nYou can shorten or simplify the command by using argument files to specify one or more text files that contain arguments, such as options and class names, which are passed to the command. This let's you to create commands of any length on any operating system.\n\nIn the command line, use the at sign ( ) prefix to identify an argument file that contains options and class names. When the command encounters a file beginning with the at sign ( ), it expands the contents of that file into an argument list just as they would be specified on the command line.\n\nThe launcher expands the argument file contents until it encounters the option. You can use the option anywhere on the command line, including in an argument file, to stop argument files expansion.\n\nThe following items describe the syntax of argument files:\n• None The argument file must contain only ASCII characters or characters in system default encoding that's ASCII friendly, such as UTF-8.\n• None The argument file size must not exceed MAXINT (2,147,483,647) bytes.\n• None The launcher doesn't expand wildcards that are present within an argument file.\n• None Use white space or new line characters to separate arguments included in the file.\n• For example, it is possible to have a path with a space, such as that can be specified as either or, to avoid an escape, .\n• None Any option that contains spaces, such as a path component, must be within quotation marks using quotation ('\"') characters in its entirety.\n• None A string within quotation marks may contain the characters , , , and . They are converted to their respective ASCII codes.\n• None If a file name contains embedded spaces, then put the whole file name in double quotation marks.\n• None File names in an argument file are relative to the current directory, not to the location of the argument file.\n• None Use the number sign in the argument file to identify comments. All characters following the are ignored until the end of line.\n• None Additional at sign prefixes to prefixed options act as an escape, (the first is removed and the rest of the arguments are presented to the launcher literally).\n• None Lines may be continued using the continuation character ( ) at the end-of-line. The two lines are concatenated with the leading white spaces trimmed. To prevent trimming the leading white spaces, a continuation character ( ) may be placed at the first column.\n• None Because backslash (\\) is an escape character, a backslash character must be escaped with another backslash character.\n• None Partial quote is allowed and is closed by an end-of-file.\n• None An open quote stops at end-of-line unless is the last character, which then joins the next line by removing all leading white space characters.\n• None Wildcards (*) aren't allowed in these lists (such as specifying ).\n• None Use of the at sign ( ) to recursively interpret files isn't supported.\n\nExample of Open or Partial Quotes in an Argument File\n\nthis is interpreted as:\n\nExample of a Backslash Character Escaped with Another Backslash Character in an Argument File\n\nTo output the following:\n\nThe backslash character must be specified in the argument file as:\n\nExample of an EOL Escape Used to Force Concatenation of Lines in an Argument File\n\nThis is interpreted as:\n\nExample of Line Continuation with Leading Spaces in an Argument File\n\nThis is interpreted as:\n\nYou can use a single argument file, such as in the following example, to hold all required arguments:\n\nExamples of Using Argument Files with Paths\n\nYou can include relative paths in argument files; however, they're relative to the current working directory and not to the paths of the argument files themselves. In the following example, and represent argument files with different paths. Any relative paths that they contain are relative to the current working directory and not to the argument files:\n\nThere are occasions when having insight into the current state of the JVM code heap would be helpful to answer questions such as:\n• None Why was the JIT turned off and then on again and again?\n• None Where has all the code heap space gone?\n• None Why is the method sweeper not working effectively?\n\nTo provide this insight, a code heap state analytics feature has been implemented that enables on-the-fly analysis of the code heap. The analytics process is divided into two parts. The first part examines the entire code heap and aggregates all information that is believed to be useful or important. The second part consists of several independent steps that print the collected information with an emphasis on different aspects of the data. Data collection and printing are done on an \"on request\" basis.\n\nRequests for real-time, on-the-fly analysis can be issued with the following command:\n\nIf you are only interested in how the code heap looks like after running a sample workload, you can use the command line option:\n\nTo see the code heap state when a \"CodeCache full\" condition exists, start the VM with the command line option:\n\nSee CodeHeap State Analytics (OpenJDK) for a detailed description of the code heap state analytics feature, the supported functions, and the granularity options.\n\nYou use the option to configure or enable logging with the Java Virtual Machine (JVM) unified logging framework.\n\nThe Java Virtual Machine (JVM) unified logging framework provides a common logging system for all components of the JVM. GC logging for the JVM has been changed to use the new logging framework. The mapping of old GC flags to the corresponding new Xlog configuration is described in Convert GC Logging Flags to Xlog. In addition, runtime logging has also been changed to use the JVM unified logging framework. The mapping of legacy runtime logging flags to the corresponding new Xlog configuration is described in Convert Runtime Logging Flags to Xlog.\n\nThe following provides quick reference to the command and syntax for options:\n\nWhen the option and nothing else is specified on the command line, the default configuration is used. The default configuration logs all messages with a level that matches either warning or error regardless of what tags the message is associated with. The default configuration is equivalent to entering the following on the command line:\n\nLogging can also be controlled at run time through Diagnostic Commands (with the jcmd utility). Everything that can be specified on the command line can also be specified dynamically with the command. As the diagnostic commands are automatically exposed as MBeans, you can use JMX to change logging configuration at run time.\n\nEach log message has a level and a tag set associated with it. The level of the message corresponds to its details, and the tag set corresponds to what the message contains or which JVM component it involves (such as, , , or ). Mapping GC flags to the Xlog configuration is described in Convert GC Logging Flags to Xlog. Mapping legacy runtime logging flags to the corresponding Xlog configuration is described in Convert Runtime Logging Flags to Xlog.\n\nThere are literally dozens of log tags, which in the right combinations, will enable a range of logging output. The full set of available log tags can be seen using . Specifying instead of a tag combination matches all tag combinations.\n\nThe option supports the following types of outputs:\n\nWhen using filename, specifying and/or in the file name expands to the JVM's PID and startup timestamp, respectively. You can also configure text files to handle file rotation based on file size and a number of files to rotate. For example, to rotate the log file every 10 MB and keep 5 files in rotation, specify the options . The target size of the files isn't guaranteed to be exact, it's just an approximate value. Files are rotated by default with up to 5 rotated files of target size 20 MB, unless configured otherwise. Specifying means that the log file shouldn't be rotated. There's a possibility of the pre-existing log file getting overwritten.\n\nBy default logging messages are output synchronously - each log message is written to the designated output when the logging call is made. But you can instead use asynchronous logging mode by specifying:\n\nIn asynchronous logging mode, log sites enqueue all logging messages to an intermediate buffer and a standalone thread is responsible for flushing them to the corresponding outputs. The intermediate buffer is bounded and on buffer exhaustion the enqueuing message is discarded. Log entry write operations are guaranteed non-blocking.\n\nThe option specifies the memory budget in bytes for the intermediate buffer. The default value should be big enough to cater for most cases. Users can provide a custom value to trade memory overhead for log accuracy if they need to.\n\nLogging messages are decorated with information about the message. You can configure each output to use a custom set of decorators. The order of the output is always the same as listed in the table. You can configure the decorations to be used at run time. Decorations are prepended to the log message. For example:\n\nOmitting defaults to , , and . The decorator is special and is used to turn off all decorations.\n\n( ), ( ), ( ), ( ), ( ), ( ), ( ), ( ), ( ), ( ), ( ), ( ) decorators can also be specified as for no decoration.\n\nThese legacy flags are no longer recognized and will cause an error if used directly. Use their unified logging equivalent instead.\n\nThe following are examples.\n\nThe following describes a few complex examples of using the option.\n\nYou use values provided to all Java Virtual Machine (JVM) command-line flags for validation and, if the input value is invalid or out-of-range, then an appropriate error message is displayed.\n\nWhether they're set ergonomically, in a command line, by an input tool, or through the APIs (for example, classes contained in the package ) the values provided to all Java Virtual Machine (JVM) command-line flags are validated. Ergonomics are described in Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide.\n\nRange and constraints are validated either when all flags have their values set during JVM initialization or a flag's value is changed during runtime (for example using the tool). The JVM is terminated if a value violates either the range or constraint check and an appropriate error message is printed on the error stream.\n\nFor example, if a flag violates a range or a constraint check, then the JVM exits with an error:\n\nThe flag prints the range of all the flags. This flag allows automatic testing of the flags by the values provided by the ranges. For the flags that have the ranges specified, the type, name, and the actual range is printed in the output.\n\nFor the flags that don't have the range specified, the values aren't displayed in the print out. For example:\n\nThis helps to identify the flags that need to be implemented. The automatic testing framework can skip those flags that don't have values and aren't implemented.\n\nYou use large pages, also known as huge pages, as memory pages that are significantly larger than the standard memory page size (which varies depending on the processor and operating system). Large pages optimize processor Translation-Lookaside Buffers.\n\nA Translation-Lookaside Buffer (TLB) is a page translation cache that holds the most-recently used virtual-to-physical address translations. A TLB is a scarce system resource. A TLB miss can be costly because the processor must then read from the hierarchical page table, which may require multiple memory accesses. By using a larger memory page size, a single TLB entry can represent a larger memory range. This results in less pressure on a TLB, and memory-intensive applications may have better performance.\n\nHowever, using large pages can negatively affect system performance. For example, when a large amount of memory is pinned by an application, it may create a shortage of regular memory and cause excessive paging in other applications and slow down the entire system. Also, a system that has been up for a long time could produce excessive fragmentation, which could make it impossible to reserve enough large page memory. When this happens, either the OS or JVM reverts to using regular pages.\n\nLinux supports large pages since version 2.6. To check if your environment supports large pages, try the following:\n\nIf the output contains items prefixed with \"Huge\", then your system supports large pages. The values may vary depending on environment. The field shows the default large page size in your environment, and the other fields show details for large pages of this size. Newer kernels have support for multiple large page sizes. To list the supported page sizes, run this:\n\nThe above environment supports 2 MB and 1 GB large pages, but they need to be configured so that the JVM can use them. When using large pages and not enabling transparent huge pages (option ), the number of large pages must be pre-allocated. For example, to enable 8 GB of memory to be backed by 2 MB large pages, login as and run:\n\nIt is always recommended to check the value of after the request to make sure the kernel was able to allocate the requested number of large pages.\n\nWhen using the option to enable large pages you also need to make sure the parameter is configured to allow large enough shared memory segments to be allocated. To allow a maximum shared segment of 8 GB, login as and run:\n\nIn some environments this is not needed since the default value is large enough, but it is important to make sure the value is large enough to fit the amount of memory intended to be backed by large pages.\n\nIf you configure the OS kernel parameters to enable use of large pages, the Java processes may allocate large pages for the Java heap as well as other internal areas, for example:\n\nConsequently, if you configure the parameter to the size of the Java heap, then the JVM can still fail to allocate the heap using large pages because other areas such as the code cache might already have used some of the configured large pages.\n\nTo use large pages support on Windows, the administrator must first assign additional privileges to the user who is running the application:\n\nNote that these steps are required even if it's the administrator who's running the application, because administrators by default don't have the privilege to lock pages in memory.\n\nApplication Class Data Sharing (AppCDS) stores classes used by your applications in an archive file. Since these classes are stored in a format that can be loaded very quickly (compared to classes stored in a JAR file), AppCDS can improve the start-up time of your applications. In addition, AppCDS can reduce the runtime memory footprint by sharing parts of these classes across multiple processes.\n\nClasses in the CDS archive are stored in an optimized format that's about 2 to 5 times larger than classes stored in JAR files or the JDK runtime image. Therefore, it's a good idea to archive only those classes that are actually used by your application. These usually are just a small portion of all available classes. For example, your application may use only a few APIs provided by a large library.\n\nBy default, in most JDK distributions, unless is specified, the JVM starts up with a default CDS archive, which is usually located in (or on Windows). This archive contains about 1300 core library classes that are used by most applications.\n\nTo use CDS for the exact set of classes used by your application, you can use the option, which has the general form:\n• The provides additional classes that can be loaded on top of those in the .\n• On Windows, the above path delimiter should be replaced with\n\n(The names \"static\" and \"dyanmic\" are used for historical reasons. The only significance is that the \"static\" archive is loaded first and the \"dynamic\" archive is loaded second).\n\nThe JVM can use up to two archives. To use only a single , you can omit the portion:\n\nFor convenience, the records the location of the . Therefore, you can omit the by saying only:\n\nCDS archives can be created with several methods:\n\nOne common operation in all these methods is a \"trial run\", where you run the application once to determine the classes that should be stored in the archive.\n\nThe following steps create a static CDS archive file that contains all the classes used by the application.\n• None Create a list of all classes used by the application. The following command creates a file named that contains a list of all classes used by this application: The classpath specified by the parameter must contain only JAR files.\n• None Create a static archive, named , that contains all the classes in :\n• None Run the application with the archive :\n• None Optional Verify that the application is using the class contained in the shared archive: The output of this command should contain the following text:\n• They usually use less disk space, since they don't need to store the classes that are already in the static archive.\n• They are created with one fewer step than the comparable static archive.\n\nThe following steps create a dynamic CDS archive file that contains the classes that are used by the application, excluding those that are already in the default CDS archive.\n• None Create a dynamic CDS archive, named , that contains all the classes in loaded by the application :\n• None Run the application with the shared archive :\n• None Optional Repeat step 4 of the previous section to verify that the application is using the class contained in the shared archive.\n\nIt's also possible to create a dynamic CDS archive with a non-default static CDS archive. E.g.,\n\nTo run the application using this dynamic CDS archive:\n\nAs mention above, the name of the static archive can be skipped:\n\nThe previous two sections require you to modify the application's start-up script in order to create a CDS archive. Sometimes this could be difficult, for example, if the application's class path is set up by complex routines.\n\nThe command provides a less intrusive way for creating a CDS archive by connecting to a running JVM process. You can create either a static:\n\nTo use the resulting archive file in a subsequent run of the application without modifying the application's start-up script, you can use the following technique:\n\nNote: to use , the JVM process identified by must be started with , which can also be passed to the application start-up script with the same technique:\n• None Neither the class path ( and ) nor the module path ( ) can contain non-empty directories.\n• None Only modular JAR files are supported in . Exploded modules are not supported.\n• None The class path used at archive creation time must be the same as (or a prefix of) the class path used at run time. (There's no such requirement for the module path.)\n• None The CDS archive cannot be loaded if any JAR files in the class path or module path are modified after the archive is generated.\n• None If any of the VM options , or are specified, CDS is disabled. This means that the JVM will execute without loading any CDS archives. In addition, if you try to create a CDS archive with any of these 3 options specified, the JVM will report an error.\n\nYou can use the Java advanced runtime options to optimize the performance of your applications.\n\nUse the following commands and advanced options to achieve higher throughput performance for your application:\n\nUse the following commands and advanced options to achieve lower response times for your application:\n\nUse the following advanced runtime options to keep the Java heap small and reduce the dynamic footprint of embedded applications:\n\nThe following exit values are typically returned by the launcher when the launcher is called with the wrong arguments, serious errors, or exceptions thrown by the JVM. However, a Java application may choose to return any value by using the API call . The values are:"
    },
    {
        "link": "https://download.java.net/java/early_access/jdk24/docs/api",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/6597562/obtain-and-download-javadoc-jdk-api-documentation-to-a-local-file-for-offline",
        "document": "The technique below does not now work with Java 11, and probably higher versions: there isn't any way of ignoring multiple \"broken links\" (i.e., to other classes, other APIs). Solution: keep your javadoc executable file (or javadoc.exe) from Java version 8\n\nThere are good reasons for making your own local javadocs, and it's not particularly difficult!\n\nFirst you need the source. At the time of writing the Java 8 JDK comes with a zip file called . Sometimes, for unexplained reasons, Oracle don't always include the source. So for some older versions (and who knows about the future) you have to get hold of the Java source in another way. It's worth also being aware that, in the past, Oracle have sometimes included the source with the Linux version of the JDK, but not with the Windows one.\n\nI just unzipped this file... the top directories are \"com\", \"java\", \"javax\", \"launcher\" and \"org\". Directory contains no files to document.\n\nYou can generate the javadocs very very simply from any or all of these by cd'ing at the command prompt/terminal to the directory . Then go\n\nNB note that there is a \".\" after\n\nSimple as that. Generating your own javadocs also has two huge advantages\n• you know they are precisely the right javadocs for the JDK (or any external JAR file) you are using on your system\n• once you get into the habit, reconstituting your Javadocs is not a tiresome challenge (i.e,. where to go looking for them). For example, I just unzipped a couple of source JAR files whose packages were closely coupled, so their sources were in effect \"merged\" & then made a single Javadoc from them...\n\nNB Swing is semi-officially dead. We should all be switching to JavaFX, which is helpfully bundled with Java 8 JDK, but in its own source file, .\n\nUnzipped, this reveals three \"root\" packages: , and (wha'?). These should be manually moved over to the appropriate places under the unzipped directory (including the JavaFX packages under the Java structure). Compiling all these Javadoc files took my machine a non-negligible time. I'd expect to see all the JavaFX source classes in with all the other source classes some time soon.\n\nBTW, the same thinking applies to documenting any and all Java JAR files (with source) which you use. However, all versions of most JAR files will be found with their documentation available for download at Maven Central http://search.maven.org...\n\nPS afterthought: \n\nusing Eclipse and the \"Gradle STS\" plugin: the \"New Gradle STS Project\" wizard will create a file containing the line\n\nThis magically downloads the source JAR file with the executable JAR file (under ) when you go\n\n... giving you an extra degree of certainty that you have got the right and therefore the right for the dependency in question."
    },
    {
        "link": "https://geeksforgeeks.org/jdk-in-java",
        "document": "The Java Development Kit (JDK) is a cross-platformed software development environment that offers a collection of tools and libraries necessary for developing Java-based software applications and applets. It is a core package used in Java, along with the JVM (Java Virtual Machine) and the JRE (Java Runtime Environment).\n\nBeginners often get confused with JRE and JDK, if you are only interested in running Java programs on your machine then you can easily do it using Java Runtime Environment. However, if you would like to develop a Java-based software application then along with JRE you may need some additional necessary tools, which is called JDK.\n\nThe Java Development Kit is an implementation of one of the Java Platform:\n\nThe JDK has a private Java Virtual Machine (JVM) and a few other resources necessary for the development of a Java Application.\n• None An archiver (jar) and many more.\n\nThe Java Runtime Environment in JDK is usually called Private Runtime because it is separated from the regular JRE and has extra content. The Private Runtime in JDK contains a JVM and all the class libraries present in the production environment, as well as additional libraries useful to developers, e.g, internationalization libraries and the IDL libraries.\n• Oracle JDK: the most popular JDK and the main distributor of Java11,\n• OpenJDK: Ready for use: JDK 15, JDK 14, and JMC,\n• IBM J9 JDK: for AIX, Linux, Windows, and many other OS,\n• Amazon Corretto: the newest option with the no-cost build of OpenJDK and long-term support.\n\nSetting up JDK in your development environment is super easy, just follow the below simple steps.\n• None Go to this Oracle’s official Download Page through this\n• None Select the latest JDK version and click Download and add it to your classpath.\n• None Just check the JDK software is installed or not on your computer at the correct location, for example, at C:\\Program Files\\Java\\jdk11.0.9.\n• None Go to the Advanced tab and select Environment Variables, and then edit JAVA_HOME to point to the exact location where your JDK software is stored, for example, C:\\Program Files\\Java\\jdk11.0.9 is the default location in windows.\n\nJava maintains backward compatibility, so don’t worry just download the latest release and you will get all the old and many new features. After Installing the JDK and JRE adds the java command to your command line. You can verify this through the command prompt by the java -version command. In some cases, you need to restart your system after installing the JDK.\n\nYou can use the JDK compiler to convert your Java text file into an executable program. Your Java text segment is converted into bytecode after compilation which carries the .class extension.\n\nFirst, create a Java text file and save it using a name. Here we are saving the file as Hello.java.\n\n\n\nAfter that just simply use the javac command, which is used for the compilation purpose in Java. Please don’t forget to provide the full path of your java text file to the command line else you will get an error as “The system cannot find the path specified”,\n\nYour command should be similar to the given below example where Hello is the file name and the full path to the file is specified before the file name. The path and javac.exe should be inside the quotes.\n\nYou can notice now that the Hello.class file is being created in the same directory as Hello.java. Now you can run your code by simply using the java Hello command, which will give you the desired result according to your code. Please remember that you don’t have to include the .class to run your code.\n\nJDK contains many useful tools and among them, the most popular after javac is the jar tool. The jar file is nothing but a full pack of Java classes. After creating the .class files, you can put them together in a .jar, which compresses and structures them in a predictable fashion. Now, let’s convert our Hello.class to a jar file.\n\nBefore proceeding, please note that you should be in the same directory where the Hello.java file was saved. Now type the command given below in the command line.\n\nNow you can notice that Hello.jar file had been created in the same directory using Hello.class file and jar.exe. You can use the jar file by adding it to your classpath and executing the program inside it. Here the -cp stands for classpath which helps to add the jar to the same classpath.\n\nBelow there is a comprehensive list of mostly used components of Jdk which are very useful during the development of a java application."
    }
]